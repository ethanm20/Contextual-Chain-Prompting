,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
3151,180887,,Remote,Not required,,CVE-2017-15906,https://www.cvedetails.com/cve/CVE-2017-15906/,CWE-269,Low,,Partial,,2017-10-25,5.0,"The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",2019-10-02,,2,https://github.com/openbsd/src/commit/a6981567e8e215acc1ef690c8dbb30f2d9b00a19,a6981567e8e215acc1ef690c8dbb30f2d9b00a19,"disallow creation (of empty files) in read-only mode; reported by
Michal Zalewski, feedback & ok deraadt@",2,usr.bin/ssh/sftp-server.c,"{""sha"": ""42249ebd60d0f46a2219d61203a30e0da65d38ec"", ""filename"": ""usr.bin/ssh/sftp-server.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/openbsd/src/blob/a6981567e8e215acc1ef690c8dbb30f2d9b00a19/usr.bin/ssh/sftp-server.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/a6981567e8e215acc1ef690c8dbb30f2d9b00a19/usr.bin/ssh/sftp-server.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/sftp-server.c?ref=a6981567e8e215acc1ef690c8dbb30f2d9b00a19"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: sftp-server.c,v 1.110 2016/09/12 01:22:38 deraadt Exp $ */\n+/* $OpenBSD: sftp-server.c,v 1.111 2017/04/04 00:24:56 djm Exp $ */\n /*\n  * Copyright (c) 2000-2004 Markus Friedl.  All rights reserved.\n  *\n@@ -683,8 +683,8 @@ process_open(u_int32_t id)\n \tlogit(\""open \\\""%s\\\"" flags %s mode 0%o\"",\n \t    name, string_from_portable(pflags), mode);\n \tif (readonly &&\n-\t    ((flags & O_ACCMODE) == O_WRONLY ||\n-\t    (flags & O_ACCMODE) == O_RDWR)) {\n+\t    ((flags & O_ACCMODE) != O_RDONLY ||\n+\t    (flags & (O_CREAT|O_TRUNC)) != 0)) {\n \t\tverbose(\""Refusing open request in read-only mode\"");\n \t\tstatus = SSH2_FX_PERMISSION_DENIED;\n \t} else {""}","process_open(u_int32_t id)
{
	u_int32_t pflags;
	Attrib a;
	char *name;
	int r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
	    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

	debug3(""request %u: open flags %d"", id, pflags);
	flags = flags_from_portable(pflags);
	mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
	    ((flags & O_ACCMODE) != O_RDONLY ||
	    (flags & (O_CREAT|O_TRUNC)) != 0)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {
		fd = open(name, flags, mode);
		if (fd < 0) {
			status = errno_to_portable(errno);
		} else {
			handle = handle_new(HANDLE_FILE, name, fd, flags, NULL);
			if (handle < 0) {
				close(fd);
			} else {
				send_handle(id, handle);
				status = SSH2_FX_OK;
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	free(name);
}
","process_open(u_int32_t id)
{
	u_int32_t pflags;
	Attrib a;
	char *name;
	int r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
	    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

	debug3(""request %u: open flags %d"", id, pflags);
	flags = flags_from_portable(pflags);
	mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
	    ((flags & O_ACCMODE) == O_WRONLY ||
	    (flags & O_ACCMODE) == O_RDWR)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {
		fd = open(name, flags, mode);
		if (fd < 0) {
			status = errno_to_portable(errno);
		} else {
			handle = handle_new(HANDLE_FILE, name, fd, flags, NULL);
			if (handle < 0) {
				close(fd);
			} else {
				send_handle(id, handle);
				status = SSH2_FX_OK;
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	free(name);
}
",C,"	    ((flags & O_ACCMODE) != O_RDONLY ||
	    (flags & (O_CREAT|O_TRUNC)) != 0)) {
","	    ((flags & O_ACCMODE) == O_WRONLY ||
	    (flags & O_ACCMODE) == O_RDWR)) {
",,"@@ -1,4 +1,4 @@
-/* $OpenBSD: sftp-server.c,v 1.110 2016/09/12 01:22:38 deraadt Exp $ */
+/* $OpenBSD: sftp-server.c,v 1.111 2017/04/04 00:24:56 djm Exp $ */
 /*
  * Copyright (c) 2000-2004 Markus Friedl.  All rights reserved.
  *
@@ -683,8 +683,8 @@ process_open(u_int32_t id)
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
-	    ((flags & O_ACCMODE) == O_WRONLY ||
-	    (flags & O_ACCMODE) == O_RDWR)) {
+	    ((flags & O_ACCMODE) != O_RDONLY ||
+	    (flags & (O_CREAT|O_TRUNC)) != 0)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {",src,a6981567e8e215acc1ef690c8dbb30f2d9b00a19,f7bf1b90edbc30ad71b90a869e7a850ec6700918,1,"process_open(u_int32_t id)
{
	u_int32_t pflags;
	Attrib a;
	char *name;
	int r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
	    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

	debug3(""request %u: open flags %d"", id, pflags);
	flags = flags_from_portable(pflags);
	mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
//flaw_line_below:
	    ((flags & O_ACCMODE) == O_WRONLY ||
//flaw_line_below:
	    (flags & O_ACCMODE) == O_RDWR)) {
//fix_flaw_line_below:
//	    ((flags & O_ACCMODE) != O_RDONLY ||
//fix_flaw_line_below:
//	    (flags & (O_CREAT|O_TRUNC)) != 0)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {
		fd = open(name, flags, mode);
		if (fd < 0) {
			status = errno_to_portable(errno);
		} else {
			handle = handle_new(HANDLE_FILE, name, fd, flags, NULL);
			if (handle < 0) {
				close(fd);
			} else {
				send_handle(id, handle);
				status = SSH2_FX_OK;
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	free(name);
}
"
3807,181543,,Local,Not required,Partial,CVE-2017-5940,https://www.cvedetails.com/cve/CVE-2017-5940/,CWE-269,Low,Partial,Partial,,2017-02-09,4.6,"Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",2019-10-02,,15,https://github.com/netblue30/firejail/commit/38d418505e9ee2d326557e5639e8da49c298858f,38d418505e9ee2d326557e5639e8da49c298858f,security fix,3,src/firejail/fs_home.c,"{""sha"": ""2d19c8e94d032a2e9a7d696397738eb605d5bae0"", ""filename"": ""src/firejail/fs_home.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 5, ""changes"": 22, ""blob_url"": ""https://github.com/netblue30/firejail/blob/38d418505e9ee2d326557e5639e8da49c298858f/src/firejail/fs_home.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/38d418505e9ee2d326557e5639e8da49c298858f/src/firejail/fs_home.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/fs_home.c?ref=38d418505e9ee2d326557e5639e8da49c298858f"", ""patch"": ""@@ -42,8 +42,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.zshrc\"", &s) == 0) {\n-\t\t\tcopy_file(\""/etc/skel/.zshrc\"", fname, u, g, 0644);\n+\t\t\tcopy_file_as_user(\""/etc/skel/.zshrc\"", fname, u, g, 0644);\n \t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n \t\t}\n \t\telse {\n@@ -61,8 +65,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.cshrc\"", &s) == 0) {\n-\t\t\tcopy_file(\""/etc/skel/.cshrc\"", fname, u, g, 0644);\n+\t\t\tcopy_file_as_user(\""/etc/skel/.cshrc\"", fname, u, g, 0644);\n \t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n \t\t}\n \t\telse {\n@@ -80,8 +88,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0) \n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.bashrc\"", &s) == 0) {\n-\t\t\tcopy_file(\""/etc/skel/.bashrc\"", fname, u, g, 0644);\n+\t\t\tcopy_file_as_user(\""/etc/skel/.bashrc\"", fname, u, g, 0644);\n \t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n \t\t}\n \t\tfree(fname);\n@@ -94,7 +106,7 @@ static int store_xauthority(void) {\n \n \tchar *src;\n \tchar *dest = RUN_XAUTHORITY_FILE;\n-\t// create an empty file \n+\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \""w\"");\n \tif (fp) {\n \t\tfprintf(fp, \""\\n\"");\n@@ -126,7 +138,7 @@ static int store_asoundrc(void) {\n \n \tchar *src;\n \tchar *dest = RUN_ASOUNDRC_FILE;\n-\t// create an empty file \n+\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \""w\"");\n \tif (fp) {\n \t\tfprintf(fp, \""\\n\"");""}","static void skel(const char *homedir, uid_t u, gid_t g) {
	char *fname;

	if (!arg_shell_none && (strcmp(cfg.shell,""/usr/bin/zsh"") == 0 || strcmp(cfg.shell,""/bin/zsh"") == 0)) {
		if (asprintf(&fname, ""%s/.zshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		if (stat(fname, &s) == 0)
 			return;
		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
			fprintf(stderr, ""Error: invalid %s file\n"", fname);
			exit(1);
		}
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
			copy_file_as_user(""/etc/skel/.zshrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.zshrc"");
 		}
 		else {
			touch_file_as_user(fname, u, g, 0644);
			fs_logger2(""touch"", fname);
		}
		free(fname);
	}
	else if (!arg_shell_none && strcmp(cfg.shell,""/bin/csh"") == 0) {
		if (asprintf(&fname, ""%s/.cshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		if (stat(fname, &s) == 0)
 			return;
		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
			fprintf(stderr, ""Error: invalid %s file\n"", fname);
			exit(1);
		}
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
			copy_file_as_user(""/etc/skel/.cshrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.cshrc"");
 		}
 		else {
			touch_file_as_user(fname, u, g, 0644);
			fs_logger2(""touch"", fname);
		}
		free(fname);
	}
	else {
		if (asprintf(&fname, ""%s/.bashrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		if (stat(fname, &s) == 0) 
 			return;
		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
			fprintf(stderr, ""Error: invalid %s file\n"", fname);
			exit(1);
		}
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
			copy_file_as_user(""/etc/skel/.bashrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
	}
}
","static void skel(const char *homedir, uid_t u, gid_t g) {
	char *fname;

	if (!arg_shell_none && (strcmp(cfg.shell,""/usr/bin/zsh"") == 0 || strcmp(cfg.shell,""/bin/zsh"") == 0)) {
		if (asprintf(&fname, ""%s/.zshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.zshrc"");
 		}
 		else {
			touch_file_as_user(fname, u, g, 0644);
			fs_logger2(""touch"", fname);
		}
		free(fname);
	}
	else if (!arg_shell_none && strcmp(cfg.shell,""/bin/csh"") == 0) {
		if (asprintf(&fname, ""%s/.cshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.cshrc"");
 		}
 		else {
			touch_file_as_user(fname, u, g, 0644);
			fs_logger2(""touch"", fname);
		}
		free(fname);
	}
	else {
		if (asprintf(&fname, ""%s/.bashrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		if (stat(fname, &s) == 0) 
 			return;
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
	}
}
",C,"		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
			fprintf(stderr, ""Error: invalid %s file\n"", fname);
			exit(1);
		}
			copy_file_as_user(""/etc/skel/.zshrc"", fname, u, g, 0644);
		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
			fprintf(stderr, ""Error: invalid %s file\n"", fname);
			exit(1);
		}
			copy_file_as_user(""/etc/skel/.cshrc"", fname, u, g, 0644);
		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
			fprintf(stderr, ""Error: invalid %s file\n"", fname);
			exit(1);
		}
			copy_file_as_user(""/etc/skel/.bashrc"", fname, u, g, 0644);
","			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);
			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);
			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);
",,"@@ -42,8 +42,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
-			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);
+			copy_file_as_user(""/etc/skel/.zshrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.zshrc"");
 		}
 		else {
@@ -61,8 +65,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
-			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);
+			copy_file_as_user(""/etc/skel/.cshrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.cshrc"");
 		}
 		else {
@@ -80,8 +88,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0) 
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
-			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);
+			copy_file_as_user(""/etc/skel/.bashrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
@@ -94,7 +106,7 @@ static int store_xauthority(void) {
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
-	// create an empty file 
+	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
@@ -126,7 +138,7 @@ static int store_asoundrc(void) {
 
 	char *src;
 	char *dest = RUN_ASOUNDRC_FILE;
-	// create an empty file 
+	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");",firejail,38d418505e9ee2d326557e5639e8da49c298858f,b8a4ff9775318ca5e679183884a6a63f3da8f863,1,"static void skel(const char *homedir, uid_t u, gid_t g) {
	char *fname;

	// zsh
	if (!arg_shell_none && (strcmp(cfg.shell,""/usr/bin/zsh"") == 0 || strcmp(cfg.shell,""/bin/zsh"") == 0)) {
		// copy skel files
		if (asprintf(&fname, ""%s/.zshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
//fix_flaw_line_below:
//		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
//fix_flaw_line_below:
//			fprintf(stderr, ""Error: invalid %s file\n"", fname);
//fix_flaw_line_below:
//			exit(1);
//fix_flaw_line_below:
//		}
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
//flaw_line_below:
			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);
//fix_flaw_line_below:
//			copy_file_as_user(""/etc/skel/.zshrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.zshrc"");
 		}
 		else {
			touch_file_as_user(fname, u, g, 0644);
			fs_logger2(""touch"", fname);
		}
		free(fname);
	}
	// csh
	else if (!arg_shell_none && strcmp(cfg.shell,""/bin/csh"") == 0) {
		// copy skel files
		if (asprintf(&fname, ""%s/.cshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
//fix_flaw_line_below:
//		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
//fix_flaw_line_below:
//			fprintf(stderr, ""Error: invalid %s file\n"", fname);
//fix_flaw_line_below:
//			exit(1);
//fix_flaw_line_below:
//		}
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
//flaw_line_below:
			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);
//fix_flaw_line_below:
//			copy_file_as_user(""/etc/skel/.cshrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.cshrc"");
 		}
 		else {
			touch_file_as_user(fname, u, g, 0644);
			fs_logger2(""touch"", fname);
		}
		free(fname);
	}
	// bash etc.
	else {
		// copy skel files
		if (asprintf(&fname, ""%s/.bashrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0) 
 			return;
//fix_flaw_line_below:
//		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
//fix_flaw_line_below:
//			fprintf(stderr, ""Error: invalid %s file\n"", fname);
//fix_flaw_line_below:
//			exit(1);
//fix_flaw_line_below:
//		}
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
//flaw_line_below:
			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);
//fix_flaw_line_below:
//			copy_file_as_user(""/etc/skel/.bashrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
	}
}
"
3808,181544,,Local,Not required,Partial,CVE-2017-5940,https://www.cvedetails.com/cve/CVE-2017-5940/,CWE-269,Low,Partial,Partial,,2017-02-09,4.6,"Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",2019-10-02,,1,https://github.com/netblue30/firejail/commit/38d418505e9ee2d326557e5639e8da49c298858f,38d418505e9ee2d326557e5639e8da49c298858f,security fix,0,src/firejail/fs_home.c,"{""sha"": ""2d19c8e94d032a2e9a7d696397738eb605d5bae0"", ""filename"": ""src/firejail/fs_home.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 5, ""changes"": 22, ""blob_url"": ""https://github.com/netblue30/firejail/blob/38d418505e9ee2d326557e5639e8da49c298858f/src/firejail/fs_home.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/38d418505e9ee2d326557e5639e8da49c298858f/src/firejail/fs_home.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/fs_home.c?ref=38d418505e9ee2d326557e5639e8da49c298858f"", ""patch"": ""@@ -42,8 +42,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.zshrc\"", &s) == 0) {\n-\t\t\tcopy_file(\""/etc/skel/.zshrc\"", fname, u, g, 0644);\n+\t\t\tcopy_file_as_user(\""/etc/skel/.zshrc\"", fname, u, g, 0644);\n \t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n \t\t}\n \t\telse {\n@@ -61,8 +65,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.cshrc\"", &s) == 0) {\n-\t\t\tcopy_file(\""/etc/skel/.cshrc\"", fname, u, g, 0644);\n+\t\t\tcopy_file_as_user(\""/etc/skel/.cshrc\"", fname, u, g, 0644);\n \t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n \t\t}\n \t\telse {\n@@ -80,8 +88,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0) \n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.bashrc\"", &s) == 0) {\n-\t\t\tcopy_file(\""/etc/skel/.bashrc\"", fname, u, g, 0644);\n+\t\t\tcopy_file_as_user(\""/etc/skel/.bashrc\"", fname, u, g, 0644);\n \t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n \t\t}\n \t\tfree(fname);\n@@ -94,7 +106,7 @@ static int store_xauthority(void) {\n \n \tchar *src;\n \tchar *dest = RUN_XAUTHORITY_FILE;\n-\t// create an empty file \n+\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \""w\"");\n \tif (fp) {\n \t\tfprintf(fp, \""\\n\"");\n@@ -126,7 +138,7 @@ static int store_asoundrc(void) {\n \n \tchar *src;\n \tchar *dest = RUN_ASOUNDRC_FILE;\n-\t// create an empty file \n+\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \""w\"");\n \tif (fp) {\n \t\tfprintf(fp, \""\\n\"");""}","static int store_asoundrc(void) {
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_ASOUNDRC_FILE;
	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0644);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat s;
	if (stat(src, &s) == 0) {
		if (is_link(src)) {
			/* coverity[toctou] */
			char* rp = realpath(src, NULL);
			if (!rp) {
				fprintf(stderr, ""Error: Cannot access %s\n"", src);
				exit(1);
			}
			if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {
				fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n"");
				exit(1);
			}
			free(rp);
		}

		copy_file_as_user(src, dest, getuid(), getgid(), 0644);
		fs_logger2(""clone"", dest);
		return 1; // file copied
	}
	
	return 0;
}
","static int store_asoundrc(void) {
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_ASOUNDRC_FILE;
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0644);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat s;
	if (stat(src, &s) == 0) {
		if (is_link(src)) {
			/* coverity[toctou] */
			char* rp = realpath(src, NULL);
			if (!rp) {
				fprintf(stderr, ""Error: Cannot access %s\n"", src);
				exit(1);
			}
			if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {
				fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n"");
				exit(1);
			}
			free(rp);
		}

		copy_file_as_user(src, dest, getuid(), getgid(), 0644);
		fs_logger2(""clone"", dest);
		return 1; // file copied
	}
	
	return 0;
}
",C,"	// create an empty file as root, and change ownership to user
",,,"@@ -42,8 +42,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
-			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);
+			copy_file_as_user(""/etc/skel/.zshrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.zshrc"");
 		}
 		else {
@@ -61,8 +65,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
-			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);
+			copy_file_as_user(""/etc/skel/.cshrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.cshrc"");
 		}
 		else {
@@ -80,8 +88,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0) 
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
-			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);
+			copy_file_as_user(""/etc/skel/.bashrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
@@ -94,7 +106,7 @@ static int store_xauthority(void) {
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
-	// create an empty file 
+	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
@@ -126,7 +138,7 @@ static int store_asoundrc(void) {
 
 	char *src;
 	char *dest = RUN_ASOUNDRC_FILE;
-	// create an empty file 
+	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");",firejail,38d418505e9ee2d326557e5639e8da49c298858f,b8a4ff9775318ca5e679183884a6a63f3da8f863,1,"static int store_asoundrc(void) {
	// put a copy of .Xauthority in XAUTHORITY_FILE
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_ASOUNDRC_FILE;
//flaw_line_below:
	// create an empty file 
//fix_flaw_line_below:
//	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0644);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat s;
	if (stat(src, &s) == 0) {
		if (is_link(src)) {
			// make sure the real path of the file is inside the home directory
			/* coverity[toctou] */
			char* rp = realpath(src, NULL);
			if (!rp) {
				fprintf(stderr, ""Error: Cannot access %s\n"", src);
				exit(1);
			}
			if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {
				fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n"");
				exit(1);
			}
			free(rp);
		}

		copy_file_as_user(src, dest, getuid(), getgid(), 0644);
		fs_logger2(""clone"", dest);
		return 1; // file copied
	}
	
	return 0;
}
"
3809,181545,,Local,Not required,Partial,CVE-2017-5940,https://www.cvedetails.com/cve/CVE-2017-5940/,CWE-269,Low,Partial,Partial,,2017-02-09,4.6,"Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",2019-10-02,,1,https://github.com/netblue30/firejail/commit/38d418505e9ee2d326557e5639e8da49c298858f,38d418505e9ee2d326557e5639e8da49c298858f,security fix,0,src/firejail/fs_home.c,"{""sha"": ""2d19c8e94d032a2e9a7d696397738eb605d5bae0"", ""filename"": ""src/firejail/fs_home.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 5, ""changes"": 22, ""blob_url"": ""https://github.com/netblue30/firejail/blob/38d418505e9ee2d326557e5639e8da49c298858f/src/firejail/fs_home.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/38d418505e9ee2d326557e5639e8da49c298858f/src/firejail/fs_home.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/fs_home.c?ref=38d418505e9ee2d326557e5639e8da49c298858f"", ""patch"": ""@@ -42,8 +42,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.zshrc\"", &s) == 0) {\n-\t\t\tcopy_file(\""/etc/skel/.zshrc\"", fname, u, g, 0644);\n+\t\t\tcopy_file_as_user(\""/etc/skel/.zshrc\"", fname, u, g, 0644);\n \t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n \t\t}\n \t\telse {\n@@ -61,8 +65,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.cshrc\"", &s) == 0) {\n-\t\t\tcopy_file(\""/etc/skel/.cshrc\"", fname, u, g, 0644);\n+\t\t\tcopy_file_as_user(\""/etc/skel/.cshrc\"", fname, u, g, 0644);\n \t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n \t\t}\n \t\telse {\n@@ -80,8 +88,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0) \n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.bashrc\"", &s) == 0) {\n-\t\t\tcopy_file(\""/etc/skel/.bashrc\"", fname, u, g, 0644);\n+\t\t\tcopy_file_as_user(\""/etc/skel/.bashrc\"", fname, u, g, 0644);\n \t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n \t\t}\n \t\tfree(fname);\n@@ -94,7 +106,7 @@ static int store_xauthority(void) {\n \n \tchar *src;\n \tchar *dest = RUN_XAUTHORITY_FILE;\n-\t// create an empty file \n+\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \""w\"");\n \tif (fp) {\n \t\tfprintf(fp, \""\\n\"");\n@@ -126,7 +138,7 @@ static int store_asoundrc(void) {\n \n \tchar *src;\n \tchar *dest = RUN_ASOUNDRC_FILE;\n-\t// create an empty file \n+\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \""w\"");\n \tif (fp) {\n \t\tfprintf(fp, \""\\n\"");""}","static int store_xauthority(void) {
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat s;
	if (stat(src, &s) == 0) {
		if (is_link(src)) {
			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
			return 0;
		}

		copy_file_as_user(src, dest, getuid(), getgid(), 0600);
		fs_logger2(""clone"", dest);
		return 1; // file copied
	}
	
	return 0;
}
","static int store_xauthority(void) {
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat s;
	if (stat(src, &s) == 0) {
		if (is_link(src)) {
			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
			return 0;
		}

		copy_file_as_user(src, dest, getuid(), getgid(), 0600);
		fs_logger2(""clone"", dest);
		return 1; // file copied
	}
	
	return 0;
}
",C,"	// create an empty file as root, and change ownership to user
",,,"@@ -42,8 +42,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
-			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);
+			copy_file_as_user(""/etc/skel/.zshrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.zshrc"");
 		}
 		else {
@@ -61,8 +65,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
-			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);
+			copy_file_as_user(""/etc/skel/.cshrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.cshrc"");
 		}
 		else {
@@ -80,8 +88,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0) 
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
-			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);
+			copy_file_as_user(""/etc/skel/.bashrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
@@ -94,7 +106,7 @@ static int store_xauthority(void) {
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
-	// create an empty file 
+	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
@@ -126,7 +138,7 @@ static int store_asoundrc(void) {
 
 	char *src;
 	char *dest = RUN_ASOUNDRC_FILE;
-	// create an empty file 
+	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");",firejail,38d418505e9ee2d326557e5639e8da49c298858f,b8a4ff9775318ca5e679183884a6a63f3da8f863,1,"static int store_xauthority(void) {
	// put a copy of .Xauthority in XAUTHORITY_FILE
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
//flaw_line_below:
	// create an empty file 
//fix_flaw_line_below:
//	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat s;
	if (stat(src, &s) == 0) {
		if (is_link(src)) {
			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
			return 0;
		}

		copy_file_as_user(src, dest, getuid(), getgid(), 0600);
		fs_logger2(""clone"", dest);
		return 1; // file copied
	}
	
	return 0;
}
"
3854,181590,,Local,Not required,Complete,CVE-2017-5207,https://www.cvedetails.com/cve/CVE-2017-5207/,CWE-269,Low,Complete,Complete,,2017-03-23,7.2,"Firejail before 0.9.44.4, when running a bandwidth command, allows local users to gain root privileges via the --shell argument.",2019-10-02,+Priv ,1,https://github.com/netblue30/firejail/commit/5d43fdcd215203868d440ffc42036f5f5ffc89fc,5d43fdcd215203868d440ffc42036f5f5ffc89fc,security fix,7,src/firejail/bandwidth.c,"{""sha"": ""b9a982d776a62e8200bbf0db7916d8ccece262a4"", ""filename"": ""RELNOTES"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/netblue30/firejail/blob/5d43fdcd215203868d440ffc42036f5f5ffc89fc/RELNOTES"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/5d43fdcd215203868d440ffc42036f5f5ffc89fc/RELNOTES"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/RELNOTES?ref=5d43fdcd215203868d440ffc42036f5f5ffc89fc"", ""patch"": ""@@ -1,5 +1,6 @@\n firejail (0.9.45) baseline; urgency=low\n   * development version, work in progress\n+  * security: --bandwidth root shel found by Martin Carpenter\n   * security: disabled --allow-debuggers when running on kernel\n     versions prior to 4.8; a kernel bug in ptrace system call\n     allows a full bypass of seccomp filter; problem reported by Lizzie Dixon""}<_**next**_>{""sha"": ""84c9dc53a331e5787941bf31dd3b7ba5dbe77e2f"", ""filename"": ""src/firejail/bandwidth.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 8, ""changes"": 9, ""blob_url"": ""https://github.com/netblue30/firejail/blob/5d43fdcd215203868d440ffc42036f5f5ffc89fc/src/firejail/bandwidth.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/5d43fdcd215203868d440ffc42036f5f5ffc89fc/src/firejail/bandwidth.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/bandwidth.c?ref=5d43fdcd215203868d440ffc42036f5f5ffc89fc"", ""patch"": ""@@ -435,15 +435,8 @@ void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, in\n \tif (setregid(0, 0))\n \t\terrExit(\""setregid\"");\n \n-\tif (!cfg.shell)\n-\t\tcfg.shell = guess_shell();\n-\tif (!cfg.shell) {\n-\t\tfprintf(stderr, \""Error: no POSIX shell found, please use --shell command line option\\n\"");\n-\t\texit(1);\n-\t}\n-\n \tchar *arg[4];\n-\targ[0] = cfg.shell;\n+\targ[0] = \""/bin/sh\"";\n \targ[1] = \""-c\"";\n \targ[2] = cmd;\n \targ[3] = NULL;""}","void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {
	EUID_ASSERT();
	EUID_ROOT();
	char *comm = pid_proc_comm(pid);
	EUID_USER();
	if (!comm) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}

	if (strcmp(comm, ""firejail"") != 0) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}
	free(comm);
	
	char *name;
	if (asprintf(&name, ""/run/firejail/network/%d-netmap"", pid) == -1)
		errExit(""asprintf"");
	struct stat s;
	if (stat(name, &s) == -1) {
		fprintf(stderr, ""Error: the sandbox doesn't use a new network namespace\n"");
		exit(1);
	}

	pid_t child;
	if (find_child(pid, &child) == -1) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	EUID_ROOT();
	if (join_namespace(child, ""net"")) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	if (strcmp(command, ""set"") == 0)
		bandwidth_set(pid, dev, down, up);
	else if (strcmp(command, ""clear"") == 0)
		bandwidth_remove(pid, dev);

	char *devname = NULL;
	if (dev) {
		char *fname;
		if (asprintf(&fname, ""%s/%d-netmap"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)
			errExit(""asprintf"");
		FILE *fp = fopen(fname, ""r"");
		if (!fp) {
			fprintf(stderr, ""Error: cannot read network map file %s\n"", fname);
			exit(1);
		}
		
		char buf[1024];
		int len = strlen(dev);
		while (fgets(buf, 1024, fp)) {
			char *ptr = strchr(buf, '\n');
			if (ptr)
				*ptr = '\0';
			if (*buf == '\0')
				break;

			if (strncmp(buf, dev, len) == 0  && buf[len] == ':') {
				devname = strdup(buf + len + 1);
				if (!devname)
					errExit(""strdup"");
				if (if_nametoindex(devname) == 0) {
					fprintf(stderr, ""Error: cannot find network device %s\n"", devname);
					exit(1);
				}
				break;
			}
		}
		free(fname);
		fclose(fp);
	}
	
	char *cmd = NULL;
	if (devname) {
		if (strcmp(command, ""set"") == 0) {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s %d %d"",
				LIBDIR, command, devname, down, up) == -1)
				errExit(""asprintf"");
		}
		else {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s"",
				LIBDIR, command, devname) == -1)
				errExit(""asprintf"");
		}
	}
	else {
		if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s"", LIBDIR, command) == -1)
			errExit(""asprintf"");
	}
	assert(cmd);

	environ = NULL;

	if (setreuid(0, 0))
		errExit(""setreuid"");
 	if (setregid(0, 0))
 		errExit(""setregid"");
 
 	char *arg[4];
	arg[0] = ""/bin/sh"";
 	arg[1] = ""-c"";
 	arg[2] = cmd;
 	arg[3] = NULL;
	clearenv();
	execvp(arg[0], arg);
	
	errExit(""execvp"");
}
","void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {
	EUID_ASSERT();
	EUID_ROOT();
	char *comm = pid_proc_comm(pid);
	EUID_USER();
	if (!comm) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}

	if (strcmp(comm, ""firejail"") != 0) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}
	free(comm);
	
	char *name;
	if (asprintf(&name, ""/run/firejail/network/%d-netmap"", pid) == -1)
		errExit(""asprintf"");
	struct stat s;
	if (stat(name, &s) == -1) {
		fprintf(stderr, ""Error: the sandbox doesn't use a new network namespace\n"");
		exit(1);
	}

	pid_t child;
	if (find_child(pid, &child) == -1) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	EUID_ROOT();
	if (join_namespace(child, ""net"")) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	if (strcmp(command, ""set"") == 0)
		bandwidth_set(pid, dev, down, up);
	else if (strcmp(command, ""clear"") == 0)
		bandwidth_remove(pid, dev);

	char *devname = NULL;
	if (dev) {
		char *fname;
		if (asprintf(&fname, ""%s/%d-netmap"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)
			errExit(""asprintf"");
		FILE *fp = fopen(fname, ""r"");
		if (!fp) {
			fprintf(stderr, ""Error: cannot read network map file %s\n"", fname);
			exit(1);
		}
		
		char buf[1024];
		int len = strlen(dev);
		while (fgets(buf, 1024, fp)) {
			char *ptr = strchr(buf, '\n');
			if (ptr)
				*ptr = '\0';
			if (*buf == '\0')
				break;

			if (strncmp(buf, dev, len) == 0  && buf[len] == ':') {
				devname = strdup(buf + len + 1);
				if (!devname)
					errExit(""strdup"");
				if (if_nametoindex(devname) == 0) {
					fprintf(stderr, ""Error: cannot find network device %s\n"", devname);
					exit(1);
				}
				break;
			}
		}
		free(fname);
		fclose(fp);
	}
	
	char *cmd = NULL;
	if (devname) {
		if (strcmp(command, ""set"") == 0) {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s %d %d"",
				LIBDIR, command, devname, down, up) == -1)
				errExit(""asprintf"");
		}
		else {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s"",
				LIBDIR, command, devname) == -1)
				errExit(""asprintf"");
		}
	}
	else {
		if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s"", LIBDIR, command) == -1)
			errExit(""asprintf"");
	}
	assert(cmd);

	environ = NULL;

	if (setreuid(0, 0))
		errExit(""setreuid"");
 	if (setregid(0, 0))
 		errExit(""setregid"");
 
	if (!cfg.shell)
		cfg.shell = guess_shell();
	if (!cfg.shell) {
		fprintf(stderr, ""Error: no POSIX shell found, please use --shell command line option\n"");
		exit(1);
	}
 	char *arg[4];
	arg[0] = cfg.shell;
 	arg[1] = ""-c"";
 	arg[2] = cmd;
 	arg[3] = NULL;
	clearenv();
	execvp(arg[0], arg);
	
	errExit(""execvp"");
}
",C,"	arg[0] = ""/bin/sh"";
","	if (!cfg.shell)
		cfg.shell = guess_shell();
	if (!cfg.shell) {
		fprintf(stderr, ""Error: no POSIX shell found, please use --shell command line option\n"");
		exit(1);
	}
	arg[0] = cfg.shell;
",,"@@ -435,15 +435,8 @@ void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, in
 	if (setregid(0, 0))
 		errExit(""setregid"");
 
-	if (!cfg.shell)
-		cfg.shell = guess_shell();
-	if (!cfg.shell) {
-		fprintf(stderr, ""Error: no POSIX shell found, please use --shell command line option\n"");
-		exit(1);
-	}
-
 	char *arg[4];
-	arg[0] = cfg.shell;
+	arg[0] = ""/bin/sh"";
 	arg[1] = ""-c"";
 	arg[2] = cmd;
 	arg[3] = NULL;",firejail,5d43fdcd215203868d440ffc42036f5f5ffc89fc,6435525696e8eda2d1bc0ef50488523422b9126d,1,"void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {
	EUID_ASSERT();
	//************************
	// verify sandbox
	//************************
	EUID_ROOT();
	char *comm = pid_proc_comm(pid);
	EUID_USER();
	if (!comm) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}

	// check for firejail sandbox
	if (strcmp(comm, ""firejail"") != 0) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}
	free(comm);
	
	// check network namespace
	char *name;
	if (asprintf(&name, ""/run/firejail/network/%d-netmap"", pid) == -1)
		errExit(""asprintf"");
	struct stat s;
	if (stat(name, &s) == -1) {
		fprintf(stderr, ""Error: the sandbox doesn't use a new network namespace\n"");
		exit(1);
	}

	//************************
	// join the network namespace
	//************************
	pid_t child;
	if (find_child(pid, &child) == -1) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	EUID_ROOT();
	if (join_namespace(child, ""net"")) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	// set run file
	if (strcmp(command, ""set"") == 0)
		bandwidth_set(pid, dev, down, up);
	else if (strcmp(command, ""clear"") == 0)
		bandwidth_remove(pid, dev);

	//************************
	// build command
	//************************
	char *devname = NULL;
	if (dev) {
		// read network map file
		char *fname;
		if (asprintf(&fname, ""%s/%d-netmap"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)
			errExit(""asprintf"");
		FILE *fp = fopen(fname, ""r"");
		if (!fp) {
			fprintf(stderr, ""Error: cannot read network map file %s\n"", fname);
			exit(1);
		}
		
		char buf[1024];
		int len = strlen(dev);
		while (fgets(buf, 1024, fp)) {
			// remove '\n'
			char *ptr = strchr(buf, '\n');
			if (ptr)
				*ptr = '\0';
			if (*buf == '\0')
				break;

			if (strncmp(buf, dev, len) == 0  && buf[len] == ':') {
				devname = strdup(buf + len + 1);
				if (!devname)
					errExit(""strdup"");
				// check device in namespace
				if (if_nametoindex(devname) == 0) {
					fprintf(stderr, ""Error: cannot find network device %s\n"", devname);
					exit(1);
				}
				break;
			}
		}
		free(fname);
		fclose(fp);
	}
	
	// build fshaper.sh command
	char *cmd = NULL;
	if (devname) {
		if (strcmp(command, ""set"") == 0) {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s %d %d"",
				LIBDIR, command, devname, down, up) == -1)
				errExit(""asprintf"");
		}
		else {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s"",
				LIBDIR, command, devname) == -1)
				errExit(""asprintf"");
		}
	}
	else {
		if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s"", LIBDIR, command) == -1)
			errExit(""asprintf"");
	}
	assert(cmd);

	// wipe out environment variables
	environ = NULL;

	//************************
	// build command
	//************************
	// elevate privileges
	if (setreuid(0, 0))
		errExit(""setreuid"");
 	if (setregid(0, 0))
 		errExit(""setregid"");
 
//flaw_line_below:
	if (!cfg.shell)
//flaw_line_below:
		cfg.shell = guess_shell();
//flaw_line_below:
	if (!cfg.shell) {
//flaw_line_below:
		fprintf(stderr, ""Error: no POSIX shell found, please use --shell command line option\n"");
//flaw_line_below:
		exit(1);
//flaw_line_below:
	}
//flaw_line_below:

 	char *arg[4];
//flaw_line_below:
	arg[0] = cfg.shell;
//fix_flaw_line_below:
//	arg[0] = ""/bin/sh"";
 	arg[1] = ""-c"";
 	arg[2] = cmd;
 	arg[3] = NULL;
	clearenv();
	execvp(arg[0], arg);
	
	// it will never get here
	errExit(""execvp"");
}
"
4589,182325,,Local,Not required,Partial,CVE-2018-13405,https://www.cvedetails.com/cve/CVE-2018-13405/,CWE-269,Low,Partial,Partial,,2018-07-06,4.6,"The inode_init_owner function in fs/inode.c in the Linux kernel through 4.17.4 allows local users to create files with an unintended group ownership, in a scenario where a directory is SGID to a certain group and is writable by a user who is not a member of that group. Here, the non-member can trigger creation of a plain file whose group ownership is that group. The intended behavior was that the non-member can trigger creation of a directory (but not a plain file) whose group ownership is that group. The non-member can escalate privileges by making the plain file executable and SGID.",2019-10-02,,6,https://github.com/torvalds/linux/commit/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7,0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7,"Fix up non-directory creation in SGID directories

sgid directories have special semantics, making newly created files in
the directory belong to the group of the directory, and newly created
subdirectories will also become sgid.  This is historically used for
group-shared directories.

But group directories writable by non-group members should not imply
that such non-group members can magically join the group, so make sure
to clear the sgid bit on non-directories for non-members (but remember
that sgid without group execute means ""mandatory locking"", just to
confuse things even more).

Reported-by: Jann Horn <jannh@google.com>
Cc: Andy Lutomirski <luto@kernel.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,fs/inode.c,"{""sha"": ""8c86c809ca17b30e003913e169626aa42df2e908"", ""filename"": ""fs/inode.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7/fs/inode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7/fs/inode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/inode.c?ref=0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7"", ""patch"": ""@@ -1999,8 +1999,14 @@ void inode_init_owner(struct inode *inode, const struct inode *dir,\n \tinode->i_uid = current_fsuid();\n \tif (dir && dir->i_mode & S_ISGID) {\n \t\tinode->i_gid = dir->i_gid;\n+\n+\t\t/* Directories are special, and always inherit S_ISGID */\n \t\tif (S_ISDIR(mode))\n \t\t\tmode |= S_ISGID;\n+\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n+\t\t\t !in_group_p(inode->i_gid) &&\n+\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n+\t\t\tmode &= ~S_ISGID;\n \t} else\n \t\tinode->i_gid = current_fsgid();\n \tinode->i_mode = mode;""}","void inode_init_owner(struct inode *inode, const struct inode *dir,
			umode_t mode)
{
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;

		/* Directories are special, and always inherit S_ISGID */
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
		else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&
			 !in_group_p(inode->i_gid) &&
			 !capable_wrt_inode_uidgid(dir, CAP_FSETID))
			mode &= ~S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;
}
","void inode_init_owner(struct inode *inode, const struct inode *dir,
			umode_t mode)
{
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;
}
",C,"
		/* Directories are special, and always inherit S_ISGID */
		else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&
			 !in_group_p(inode->i_gid) &&
			 !capable_wrt_inode_uidgid(dir, CAP_FSETID))
			mode &= ~S_ISGID;
",,,"@@ -1999,8 +1999,14 @@ void inode_init_owner(struct inode *inode, const struct inode *dir,
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;
+
+		/* Directories are special, and always inherit S_ISGID */
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
+		else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&
+			 !in_group_p(inode->i_gid) &&
+			 !capable_wrt_inode_uidgid(dir, CAP_FSETID))
+			mode &= ~S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;",linux,0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7,d02d21ea007b6b33cdaf15c2f84fb1fea996ecc2,1,"void inode_init_owner(struct inode *inode, const struct inode *dir,
			umode_t mode)
{
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//		/* Directories are special, and always inherit S_ISGID */
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
//fix_flaw_line_below:
//		else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&
//fix_flaw_line_below:
//			 !in_group_p(inode->i_gid) &&
//fix_flaw_line_below:
//			 !capable_wrt_inode_uidgid(dir, CAP_FSETID))
//fix_flaw_line_below:
//			mode &= ~S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;
}
"
5512,183248,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,6,https://github.com/ioquake/ioq3/commit/b173ac05993f634a42be3d3535e1b158de0c3372,b173ac05993f634a42be3d3535e1b158de0c3372,"Merge some file writing extension checks from OpenJK.

Thanks Ensiform.
https://github.com/JACoders/OpenJK/commit/05928a57f9e4aae15a3bd0
https://github.com/JACoders/OpenJK/commit/ef124fd0fc48af164581176",0,code/client/cl_console.c,"{""sha"": ""32ab87e0370aaa2532af0ab0062b75f093c64c39"", ""filename"": ""code/client/cl_console.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/ioquake/ioq3/blob/b173ac05993f634a42be3d3535e1b158de0c3372/code/client/cl_console.c"", ""raw_url"": ""https://github.com/ioquake/ioq3/raw/b173ac05993f634a42be3d3535e1b158de0c3372/code/client/cl_console.c"", ""contents_url"": ""https://api.github.com/repos/ioquake/ioq3/contents/code/client/cl_console.c?ref=b173ac05993f634a42be3d3535e1b158de0c3372"", ""patch"": ""@@ -191,6 +191,12 @@ void Con_Dump_f (void)\n \tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n \tCOM_DefaultExtension( filename, sizeof( filename ), \"".txt\"" );\n \n+\tif (!COM_CompareExtension(filename, \"".txt\""))\n+\t{\n+\t\tCom_Printf(\""Con_Dump_f: Only the \\\"".txt\\\"" extension is supported by this command!\\n\"");\n+\t\treturn;\n+\t}\n+\n \tf = FS_FOpenFileWrite( filename );\n \tif (!f)\n \t{""}<_**next**_>{""sha"": ""f3cf1214ceb667c1dc5728bd4ed5660aebf9419b"", ""filename"": ""code/qcommon/common.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/ioquake/ioq3/blob/b173ac05993f634a42be3d3535e1b158de0c3372/code/qcommon/common.c"", ""raw_url"": ""https://github.com/ioquake/ioq3/raw/b173ac05993f634a42be3d3535e1b158de0c3372/code/qcommon/common.c"", ""contents_url"": ""https://api.github.com/repos/ioquake/ioq3/contents/code/qcommon/common.c?ref=b173ac05993f634a42be3d3535e1b158de0c3372"", ""patch"": ""@@ -2975,6 +2975,13 @@ void Com_WriteConfig_f( void ) {\n \t\treturn;\n \t}\n \n+\n+\tif (!COM_CompareExtension(filename, \"".cfg\""))\n+\t{\n+\t\tCom_Printf(\""Com_WriteConfig_f: Only the \\\"".cfg\\\"" extension is supported by this command!\\n\"");\n+\t\treturn;\n+\t}\n+\n \tQ_strncpyz( filename, Cmd_Argv(1), sizeof( filename ) );\n \tCOM_DefaultExtension( filename, sizeof( filename ), \"".cfg\"" );\n \tCom_Printf( \""Writing %s.\\n\"", filename );""}","void Con_Dump_f (void)
{
	int		l, x, i;
	short	*line;
	fileHandle_t	f;
	int		bufferlen;
	char	*buffer;
	char	filename[MAX_QPATH];

	if (Cmd_Argc() != 2)
	{
		Com_Printf (""usage: condump <filename>\n"");
		return;
	}

 	Q_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".txt"" );
 
	if (!COM_CompareExtension(filename, "".txt""))
	{
		Com_Printf(""Con_Dump_f: Only the \"".txt\"" extension is supported by this command!\n"");
		return;
	}

 	f = FS_FOpenFileWrite( filename );
 	if (!f)
 	{
		Com_Printf (""ERROR: couldn't open %s.\n"", filename);
		return;
	}

	Com_Printf (""Dumped console text to %s.\n"", filename );

	for (l = con.current - con.totallines + 1 ; l <= con.current ; l++)
	{
		line = con.text + (l%con.totallines)*con.linewidth;
		for (x=0 ; x<con.linewidth ; x++)
			if ((line[x] & 0xff) != ' ')
				break;
		if (x != con.linewidth)
			break;
	}

#ifdef _WIN32
	bufferlen = con.linewidth + 3 * sizeof ( char );
#else
	bufferlen = con.linewidth + 2 * sizeof ( char );
#endif

	buffer = Hunk_AllocateTempMemory( bufferlen );

	buffer[bufferlen-1] = 0;
	for ( ; l <= con.current ; l++)
	{
		line = con.text + (l%con.totallines)*con.linewidth;
		for(i=0; i<con.linewidth; i++)
			buffer[i] = line[i] & 0xff;
		for (x=con.linewidth-1 ; x>=0 ; x--)
		{
			if (buffer[x] == ' ')
				buffer[x] = 0;
			else
				break;
		}
#ifdef _WIN32
		Q_strcat(buffer, bufferlen, ""\r\n"");
#else
		Q_strcat(buffer, bufferlen, ""\n"");
#endif
		FS_Write(buffer, strlen(buffer), f);
	}

	Hunk_FreeTempMemory( buffer );
	FS_FCloseFile( f );
}
","void Con_Dump_f (void)
{
	int		l, x, i;
	short	*line;
	fileHandle_t	f;
	int		bufferlen;
	char	*buffer;
	char	filename[MAX_QPATH];

	if (Cmd_Argc() != 2)
	{
		Com_Printf (""usage: condump <filename>\n"");
		return;
	}

 	Q_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".txt"" );
 
 	f = FS_FOpenFileWrite( filename );
 	if (!f)
 	{
		Com_Printf (""ERROR: couldn't open %s.\n"", filename);
		return;
	}

	Com_Printf (""Dumped console text to %s.\n"", filename );

	for (l = con.current - con.totallines + 1 ; l <= con.current ; l++)
	{
		line = con.text + (l%con.totallines)*con.linewidth;
		for (x=0 ; x<con.linewidth ; x++)
			if ((line[x] & 0xff) != ' ')
				break;
		if (x != con.linewidth)
			break;
	}

#ifdef _WIN32
	bufferlen = con.linewidth + 3 * sizeof ( char );
#else
	bufferlen = con.linewidth + 2 * sizeof ( char );
#endif

	buffer = Hunk_AllocateTempMemory( bufferlen );

	buffer[bufferlen-1] = 0;
	for ( ; l <= con.current ; l++)
	{
		line = con.text + (l%con.totallines)*con.linewidth;
		for(i=0; i<con.linewidth; i++)
			buffer[i] = line[i] & 0xff;
		for (x=con.linewidth-1 ; x>=0 ; x--)
		{
			if (buffer[x] == ' ')
				buffer[x] = 0;
			else
				break;
		}
#ifdef _WIN32
		Q_strcat(buffer, bufferlen, ""\r\n"");
#else
		Q_strcat(buffer, bufferlen, ""\n"");
#endif
		FS_Write(buffer, strlen(buffer), f);
	}

	Hunk_FreeTempMemory( buffer );
	FS_FCloseFile( f );
}
",C,"	if (!COM_CompareExtension(filename, "".txt""))
	{
		Com_Printf(""Con_Dump_f: Only the \"".txt\"" extension is supported by this command!\n"");
		return;
	}

",,,"@@ -191,6 +191,12 @@ void Con_Dump_f (void)
 	Q_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".txt"" );
 
+	if (!COM_CompareExtension(filename, "".txt""))
+	{
+		Com_Printf(""Con_Dump_f: Only the \"".txt\"" extension is supported by this command!\n"");
+		return;
+	}
+
 	f = FS_FOpenFileWrite( filename );
 	if (!f)
 	{",OpenJK,b173ac05993f634a42be3d3535e1b158de0c3372,f61fe5f6a0419ef4a88d46a128052f2e8352e85d,1,"void Con_Dump_f (void)
{
	int		l, x, i;
	short	*line;
	fileHandle_t	f;
	int		bufferlen;
	char	*buffer;
	char	filename[MAX_QPATH];

	if (Cmd_Argc() != 2)
	{
		Com_Printf (""usage: condump <filename>\n"");
		return;
	}

 	Q_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".txt"" );
 
//fix_flaw_line_below:
//	if (!COM_CompareExtension(filename, "".txt""))
//fix_flaw_line_below:
//	{
//fix_flaw_line_below:
//		Com_Printf(""Con_Dump_f: Only the \"".txt\"" extension is supported by this command!\n"");
//fix_flaw_line_below:
//		return;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	f = FS_FOpenFileWrite( filename );
 	if (!f)
 	{
		Com_Printf (""ERROR: couldn't open %s.\n"", filename);
		return;
	}

	Com_Printf (""Dumped console text to %s.\n"", filename );

	// skip empty lines
	for (l = con.current - con.totallines + 1 ; l <= con.current ; l++)
	{
		line = con.text + (l%con.totallines)*con.linewidth;
		for (x=0 ; x<con.linewidth ; x++)
			if ((line[x] & 0xff) != ' ')
				break;
		if (x != con.linewidth)
			break;
	}

#ifdef _WIN32
	bufferlen = con.linewidth + 3 * sizeof ( char );
#else
	bufferlen = con.linewidth + 2 * sizeof ( char );
#endif

	buffer = Hunk_AllocateTempMemory( bufferlen );

	// write the remaining lines
	buffer[bufferlen-1] = 0;
	for ( ; l <= con.current ; l++)
	{
		line = con.text + (l%con.totallines)*con.linewidth;
		for(i=0; i<con.linewidth; i++)
			buffer[i] = line[i] & 0xff;
		for (x=con.linewidth-1 ; x>=0 ; x--)
		{
			if (buffer[x] == ' ')
				buffer[x] = 0;
			else
				break;
		}
#ifdef _WIN32
		Q_strcat(buffer, bufferlen, ""\r\n"");
#else
		Q_strcat(buffer, bufferlen, ""\n"");
#endif
		FS_Write(buffer, strlen(buffer), f);
	}

	Hunk_FreeTempMemory( buffer );
	FS_FCloseFile( f );
}
"
5513,183249,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,7,https://github.com/ioquake/ioq3/commit/b173ac05993f634a42be3d3535e1b158de0c3372,b173ac05993f634a42be3d3535e1b158de0c3372,"Merge some file writing extension checks from OpenJK.

Thanks Ensiform.
https://github.com/JACoders/OpenJK/commit/05928a57f9e4aae15a3bd0
https://github.com/JACoders/OpenJK/commit/ef124fd0fc48af164581176",0,code/qcommon/common.c,"{""sha"": ""32ab87e0370aaa2532af0ab0062b75f093c64c39"", ""filename"": ""code/client/cl_console.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/ioquake/ioq3/blob/b173ac05993f634a42be3d3535e1b158de0c3372/code/client/cl_console.c"", ""raw_url"": ""https://github.com/ioquake/ioq3/raw/b173ac05993f634a42be3d3535e1b158de0c3372/code/client/cl_console.c"", ""contents_url"": ""https://api.github.com/repos/ioquake/ioq3/contents/code/client/cl_console.c?ref=b173ac05993f634a42be3d3535e1b158de0c3372"", ""patch"": ""@@ -191,6 +191,12 @@ void Con_Dump_f (void)\n \tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n \tCOM_DefaultExtension( filename, sizeof( filename ), \"".txt\"" );\n \n+\tif (!COM_CompareExtension(filename, \"".txt\""))\n+\t{\n+\t\tCom_Printf(\""Con_Dump_f: Only the \\\"".txt\\\"" extension is supported by this command!\\n\"");\n+\t\treturn;\n+\t}\n+\n \tf = FS_FOpenFileWrite( filename );\n \tif (!f)\n \t{""}<_**next**_>{""sha"": ""f3cf1214ceb667c1dc5728bd4ed5660aebf9419b"", ""filename"": ""code/qcommon/common.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/ioquake/ioq3/blob/b173ac05993f634a42be3d3535e1b158de0c3372/code/qcommon/common.c"", ""raw_url"": ""https://github.com/ioquake/ioq3/raw/b173ac05993f634a42be3d3535e1b158de0c3372/code/qcommon/common.c"", ""contents_url"": ""https://api.github.com/repos/ioquake/ioq3/contents/code/qcommon/common.c?ref=b173ac05993f634a42be3d3535e1b158de0c3372"", ""patch"": ""@@ -2975,6 +2975,13 @@ void Com_WriteConfig_f( void ) {\n \t\treturn;\n \t}\n \n+\n+\tif (!COM_CompareExtension(filename, \"".cfg\""))\n+\t{\n+\t\tCom_Printf(\""Com_WriteConfig_f: Only the \\\"".cfg\\\"" extension is supported by this command!\\n\"");\n+\t\treturn;\n+\t}\n+\n \tQ_strncpyz( filename, Cmd_Argv(1), sizeof( filename ) );\n \tCOM_DefaultExtension( filename, sizeof( filename ), \"".cfg\"" );\n \tCom_Printf( \""Writing %s.\\n\"", filename );""}","void Com_WriteConfig_f( void ) {
	char	filename[MAX_QPATH];

	if ( Cmd_Argc() != 2 ) {
		Com_Printf( ""Usage: writeconfig <filename>\n"" );
 		return;
 	}
 

	if (!COM_CompareExtension(filename, "".cfg""))
	{
		Com_Printf(""Com_WriteConfig_f: Only the \"".cfg\"" extension is supported by this command!\n"");
		return;
	}

 	Q_strncpyz( filename, Cmd_Argv(1), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".cfg"" );
 	Com_Printf( ""Writing %s.\n"", filename );
	Com_WriteConfigToFile( filename );
}
","void Com_WriteConfig_f( void ) {
	char	filename[MAX_QPATH];

	if ( Cmd_Argc() != 2 ) {
		Com_Printf( ""Usage: writeconfig <filename>\n"" );
 		return;
 	}
 
 	Q_strncpyz( filename, Cmd_Argv(1), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".cfg"" );
 	Com_Printf( ""Writing %s.\n"", filename );
	Com_WriteConfigToFile( filename );
}
",C,"
	if (!COM_CompareExtension(filename, "".cfg""))
	{
		Com_Printf(""Com_WriteConfig_f: Only the \"".cfg\"" extension is supported by this command!\n"");
		return;
	}

",,,"@@ -2975,6 +2975,13 @@ void Com_WriteConfig_f( void ) {
 		return;
 	}
 
+
+	if (!COM_CompareExtension(filename, "".cfg""))
+	{
+		Com_Printf(""Com_WriteConfig_f: Only the \"".cfg\"" extension is supported by this command!\n"");
+		return;
+	}
+
 	Q_strncpyz( filename, Cmd_Argv(1), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".cfg"" );
 	Com_Printf( ""Writing %s.\n"", filename );",OpenJK,b173ac05993f634a42be3d3535e1b158de0c3372,f61fe5f6a0419ef4a88d46a128052f2e8352e85d,1,"void Com_WriteConfig_f( void ) {
	char	filename[MAX_QPATH];

	if ( Cmd_Argc() != 2 ) {
		Com_Printf( ""Usage: writeconfig <filename>\n"" );
 		return;
 	}
 
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (!COM_CompareExtension(filename, "".cfg""))
//fix_flaw_line_below:
//	{
//fix_flaw_line_below:
//		Com_Printf(""Com_WriteConfig_f: Only the \"".cfg\"" extension is supported by this command!\n"");
//fix_flaw_line_below:
//		return;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	Q_strncpyz( filename, Cmd_Argv(1), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".cfg"" );
 	Com_Printf( ""Writing %s.\n"", filename );
	Com_WriteConfigToFile( filename );
}
"
5514,183250,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,7,https://github.com/ioquake/ioq3/commit/f61fe5f6a0419ef4a88d46a128052f2e8352e85d,f61fe5f6a0419ef4a88d46a128052f2e8352e85d,Don't open .pk3 files as OpenAL drivers.,1,code/client/snd_openal.c,"{""sha"": ""319ea371b8a038c3cfc0d8533c7eaf7a09636066"", ""filename"": ""code/client/snd_openal.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/ioquake/ioq3/blob/f61fe5f6a0419ef4a88d46a128052f2e8352e85d/code/client/snd_openal.c"", ""raw_url"": ""https://github.com/ioquake/ioq3/raw/f61fe5f6a0419ef4a88d46a128052f2e8352e85d/code/client/snd_openal.c"", ""contents_url"": ""https://api.github.com/repos/ioquake/ioq3/contents/code/client/snd_openal.c?ref=f61fe5f6a0419ef4a88d46a128052f2e8352e85d"", ""patch"": ""@@ -2512,11 +2512,17 @@ qboolean S_AL_Init( soundInterface_t *si )\n \ts_alRolloff = Cvar_Get( \""s_alRolloff\"", \""2\"", CVAR_CHEAT);\n \ts_alGraceDistance = Cvar_Get(\""s_alGraceDistance\"", \""512\"", CVAR_CHEAT);\n \n-\ts_alDriver = Cvar_Get( \""s_alDriver\"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );\n+\ts_alDriver = Cvar_Get( \""s_alDriver\"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );\n \n \ts_alInputDevice = Cvar_Get( \""s_alInputDevice\"", \""\"", CVAR_ARCHIVE | CVAR_LATCH );\n \ts_alDevice = Cvar_Get(\""s_alDevice\"", \""\"", CVAR_ARCHIVE | CVAR_LATCH);\n \n+\tif ( COM_CompareExtension( s_alDriver->string, \"".pk3\"" ) )\n+\t{\n+\t\tCom_Printf( \""Rejecting DLL named \\\""%s\\\""\"", s_alDriver->string );\n+\t\treturn qfalse;\n+\t}\n+\n \t// Load QAL\n \tif( !QAL_Init( s_alDriver->string ) )\n \t{""}","qboolean S_AL_Init( soundInterface_t *si )
{
#ifdef USE_OPENAL
	const char* device = NULL;
	const char* inputdevice = NULL;
	int i;

	if( !si ) {
		return qfalse;
	}

	for (i = 0; i < MAX_RAW_STREAMS; i++) {
		streamSourceHandles[i] = -1;
		streamPlaying[i] = qfalse;
		streamSources[i] = 0;
		streamNumBuffers[i] = 0;
		streamBufIndex[i] = 0;
	}

	s_alPrecache = Cvar_Get( ""s_alPrecache"", ""1"", CVAR_ARCHIVE );
	s_alGain = Cvar_Get( ""s_alGain"", ""1.0"", CVAR_ARCHIVE );
	s_alSources = Cvar_Get( ""s_alSources"", ""96"", CVAR_ARCHIVE );
	s_alDopplerFactor = Cvar_Get( ""s_alDopplerFactor"", ""1.0"", CVAR_ARCHIVE );
	s_alDopplerSpeed = Cvar_Get( ""s_alDopplerSpeed"", ""9000"", CVAR_ARCHIVE );
	s_alMinDistance = Cvar_Get( ""s_alMinDistance"", ""120"", CVAR_CHEAT );
	s_alMaxDistance = Cvar_Get(""s_alMaxDistance"", ""1024"", CVAR_CHEAT);
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
	if ( COM_CompareExtension( s_alDriver->string, "".pk3"" ) )
	{
		Com_Printf( ""Rejecting DLL named \""%s\"""", s_alDriver->string );
		return qfalse;
	}

 	if( !QAL_Init( s_alDriver->string ) )
 	{
		Com_Printf( ""Failed to load library: \""%s\"".\n"", s_alDriver->string );
		if( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {
			return qfalse;
		}
	}

	device = s_alDevice->string;
	if(device && !*device)
		device = NULL;

	inputdevice = s_alInputDevice->string;
	if(inputdevice && !*inputdevice)
		inputdevice = NULL;


	enumeration_all_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATE_ALL_EXT"");
	enumeration_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATION_EXT"");

	if(enumeration_ext || enumeration_all_ext)
	{
		char devicenames[16384] = """";
		const char *devicelist;
#ifdef _WIN32
		const char *defaultdevice;
#endif
		int curlen;

		if(enumeration_all_ext)
		{
			devicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);
#endif
		}
		else
		{
			devicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
#endif
			enumeration_ext = qtrue;
		}

#ifdef _WIN32
		if(!device && defaultdevice && !strcmp(defaultdevice, ""Generic Hardware""))
			device = ""Generic Software"";
#endif


		if(devicelist)
		{
			while((curlen = strlen(devicelist)))
			{
				Q_strcat(devicenames, sizeof(devicenames), devicelist);
				Q_strcat(devicenames, sizeof(devicenames), ""\n"");

				devicelist += curlen + 1;
			}
		}

		s_alAvailableDevices = Cvar_Get(""s_alAvailableDevices"", devicenames, CVAR_ROM | CVAR_NORESTART);
	}

	alDevice = qalcOpenDevice(device);
	if( !alDevice && device )
	{
		Com_Printf( ""Failed to open OpenAL device '%s', trying default.\n"", device );
		alDevice = qalcOpenDevice(NULL);
	}

	if( !alDevice )
	{
		QAL_Shutdown( );
		Com_Printf( ""Failed to open OpenAL device.\n"" );
		return qfalse;
	}

	alContext = qalcCreateContext( alDevice, NULL );
	if( !alContext )
	{
		QAL_Shutdown( );
		qalcCloseDevice( alDevice );
		Com_Printf( ""Failed to create OpenAL context.\n"" );
		return qfalse;
	}
	qalcMakeContextCurrent( alContext );

	S_AL_BufferInit( );
	S_AL_SrcInit( );

	qalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);
	qalDopplerFactor( s_alDopplerFactor->value );
	qalSpeedOfSound( s_alDopplerSpeed->value );

#ifdef USE_VOIP
	s_alCapture = Cvar_Get( ""s_alCapture"", ""1"", CVAR_ARCHIVE | CVAR_LATCH );
	if (!s_alCapture->integer)
	{
		Com_Printf(""OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n"");
	}
#if USE_MUMBLE
	else if (cl_useMumble->integer)
	{
		Com_Printf(""OpenAL capture support disabled for Mumble support\n"");
	}
#endif
	else
	{
#ifdef __APPLE__
		if (qalcCaptureOpenDevice == NULL)
#else
		if (!qalcIsExtensionPresent(NULL, ""ALC_EXT_capture""))
#endif
		{
			Com_Printf(""No ALC_EXT_capture support, can't record audio.\n"");
		}
		else
		{
			char inputdevicenames[16384] = """";
			const char *inputdevicelist;
			const char *defaultinputdevice;
			int curlen;

			capture_ext = qtrue;

			inputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);
			defaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);

			if (inputdevicelist)
			{
				while((curlen = strlen(inputdevicelist)))
				{
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), ""\n"");
					inputdevicelist += curlen + 1;
				}
			}

			s_alAvailableInputDevices = Cvar_Get(""s_alAvailableInputDevices"", inputdevicenames, CVAR_ROM | CVAR_NORESTART);

			Com_Printf(""OpenAL default capture device is '%s'\n"", defaultinputdevice ? defaultinputdevice : ""none"");
			alCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			if( !alCaptureDevice && inputdevice )
			{
				Com_Printf( ""Failed to open OpenAL Input device '%s', trying default.\n"", inputdevice );
				alCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			}
			Com_Printf( ""OpenAL capture device %s.\n"",
				    (alCaptureDevice == NULL) ? ""failed to open"" : ""opened"");
		}
	}
#endif

	si->Shutdown = S_AL_Shutdown;
	si->StartSound = S_AL_StartSound;
	si->StartLocalSound = S_AL_StartLocalSound;
	si->StartBackgroundTrack = S_AL_StartBackgroundTrack;
	si->StopBackgroundTrack = S_AL_StopBackgroundTrack;
	si->RawSamples = S_AL_RawSamples;
	si->StopAllSounds = S_AL_StopAllSounds;
	si->ClearLoopingSounds = S_AL_ClearLoopingSounds;
	si->AddLoopingSound = S_AL_AddLoopingSound;
	si->AddRealLoopingSound = S_AL_AddRealLoopingSound;
	si->StopLoopingSound = S_AL_StopLoopingSound;
	si->Respatialize = S_AL_Respatialize;
	si->UpdateEntityPosition = S_AL_UpdateEntityPosition;
	si->Update = S_AL_Update;
	si->DisableSounds = S_AL_DisableSounds;
	si->BeginRegistration = S_AL_BeginRegistration;
	si->RegisterSound = S_AL_RegisterSound;
	si->ClearSoundBuffer = S_AL_ClearSoundBuffer;
	si->SoundInfo = S_AL_SoundInfo;
	si->SoundList = S_AL_SoundList;

#ifdef USE_VOIP
	si->StartCapture = S_AL_StartCapture;
	si->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;
	si->Capture = S_AL_Capture;
	si->StopCapture = S_AL_StopCapture;
	si->MasterGain = S_AL_MasterGain;
#endif

	return qtrue;
#else
	return qfalse;
#endif
}
","qboolean S_AL_Init( soundInterface_t *si )
{
#ifdef USE_OPENAL
	const char* device = NULL;
	const char* inputdevice = NULL;
	int i;

	if( !si ) {
		return qfalse;
	}

	for (i = 0; i < MAX_RAW_STREAMS; i++) {
		streamSourceHandles[i] = -1;
		streamPlaying[i] = qfalse;
		streamSources[i] = 0;
		streamNumBuffers[i] = 0;
		streamBufIndex[i] = 0;
	}

	s_alPrecache = Cvar_Get( ""s_alPrecache"", ""1"", CVAR_ARCHIVE );
	s_alGain = Cvar_Get( ""s_alGain"", ""1.0"", CVAR_ARCHIVE );
	s_alSources = Cvar_Get( ""s_alSources"", ""96"", CVAR_ARCHIVE );
	s_alDopplerFactor = Cvar_Get( ""s_alDopplerFactor"", ""1.0"", CVAR_ARCHIVE );
	s_alDopplerSpeed = Cvar_Get( ""s_alDopplerSpeed"", ""9000"", CVAR_ARCHIVE );
	s_alMinDistance = Cvar_Get( ""s_alMinDistance"", ""120"", CVAR_CHEAT );
	s_alMaxDistance = Cvar_Get(""s_alMaxDistance"", ""1024"", CVAR_CHEAT);
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
 	if( !QAL_Init( s_alDriver->string ) )
 	{
		Com_Printf( ""Failed to load library: \""%s\"".\n"", s_alDriver->string );
		if( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {
			return qfalse;
		}
	}

	device = s_alDevice->string;
	if(device && !*device)
		device = NULL;

	inputdevice = s_alInputDevice->string;
	if(inputdevice && !*inputdevice)
		inputdevice = NULL;


	enumeration_all_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATE_ALL_EXT"");
	enumeration_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATION_EXT"");

	if(enumeration_ext || enumeration_all_ext)
	{
		char devicenames[16384] = """";
		const char *devicelist;
#ifdef _WIN32
		const char *defaultdevice;
#endif
		int curlen;

		if(enumeration_all_ext)
		{
			devicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);
#endif
		}
		else
		{
			devicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
#endif
			enumeration_ext = qtrue;
		}

#ifdef _WIN32
		if(!device && defaultdevice && !strcmp(defaultdevice, ""Generic Hardware""))
			device = ""Generic Software"";
#endif


		if(devicelist)
		{
			while((curlen = strlen(devicelist)))
			{
				Q_strcat(devicenames, sizeof(devicenames), devicelist);
				Q_strcat(devicenames, sizeof(devicenames), ""\n"");

				devicelist += curlen + 1;
			}
		}

		s_alAvailableDevices = Cvar_Get(""s_alAvailableDevices"", devicenames, CVAR_ROM | CVAR_NORESTART);
	}

	alDevice = qalcOpenDevice(device);
	if( !alDevice && device )
	{
		Com_Printf( ""Failed to open OpenAL device '%s', trying default.\n"", device );
		alDevice = qalcOpenDevice(NULL);
	}

	if( !alDevice )
	{
		QAL_Shutdown( );
		Com_Printf( ""Failed to open OpenAL device.\n"" );
		return qfalse;
	}

	alContext = qalcCreateContext( alDevice, NULL );
	if( !alContext )
	{
		QAL_Shutdown( );
		qalcCloseDevice( alDevice );
		Com_Printf( ""Failed to create OpenAL context.\n"" );
		return qfalse;
	}
	qalcMakeContextCurrent( alContext );

	S_AL_BufferInit( );
	S_AL_SrcInit( );

	qalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);
	qalDopplerFactor( s_alDopplerFactor->value );
	qalSpeedOfSound( s_alDopplerSpeed->value );

#ifdef USE_VOIP
	s_alCapture = Cvar_Get( ""s_alCapture"", ""1"", CVAR_ARCHIVE | CVAR_LATCH );
	if (!s_alCapture->integer)
	{
		Com_Printf(""OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n"");
	}
#if USE_MUMBLE
	else if (cl_useMumble->integer)
	{
		Com_Printf(""OpenAL capture support disabled for Mumble support\n"");
	}
#endif
	else
	{
#ifdef __APPLE__
		if (qalcCaptureOpenDevice == NULL)
#else
		if (!qalcIsExtensionPresent(NULL, ""ALC_EXT_capture""))
#endif
		{
			Com_Printf(""No ALC_EXT_capture support, can't record audio.\n"");
		}
		else
		{
			char inputdevicenames[16384] = """";
			const char *inputdevicelist;
			const char *defaultinputdevice;
			int curlen;

			capture_ext = qtrue;

			inputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);
			defaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);

			if (inputdevicelist)
			{
				while((curlen = strlen(inputdevicelist)))
				{
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), ""\n"");
					inputdevicelist += curlen + 1;
				}
			}

			s_alAvailableInputDevices = Cvar_Get(""s_alAvailableInputDevices"", inputdevicenames, CVAR_ROM | CVAR_NORESTART);

			Com_Printf(""OpenAL default capture device is '%s'\n"", defaultinputdevice ? defaultinputdevice : ""none"");
			alCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			if( !alCaptureDevice && inputdevice )
			{
				Com_Printf( ""Failed to open OpenAL Input device '%s', trying default.\n"", inputdevice );
				alCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			}
			Com_Printf( ""OpenAL capture device %s.\n"",
				    (alCaptureDevice == NULL) ? ""failed to open"" : ""opened"");
		}
	}
#endif

	si->Shutdown = S_AL_Shutdown;
	si->StartSound = S_AL_StartSound;
	si->StartLocalSound = S_AL_StartLocalSound;
	si->StartBackgroundTrack = S_AL_StartBackgroundTrack;
	si->StopBackgroundTrack = S_AL_StopBackgroundTrack;
	si->RawSamples = S_AL_RawSamples;
	si->StopAllSounds = S_AL_StopAllSounds;
	si->ClearLoopingSounds = S_AL_ClearLoopingSounds;
	si->AddLoopingSound = S_AL_AddLoopingSound;
	si->AddRealLoopingSound = S_AL_AddRealLoopingSound;
	si->StopLoopingSound = S_AL_StopLoopingSound;
	si->Respatialize = S_AL_Respatialize;
	si->UpdateEntityPosition = S_AL_UpdateEntityPosition;
	si->Update = S_AL_Update;
	si->DisableSounds = S_AL_DisableSounds;
	si->BeginRegistration = S_AL_BeginRegistration;
	si->RegisterSound = S_AL_RegisterSound;
	si->ClearSoundBuffer = S_AL_ClearSoundBuffer;
	si->SoundInfo = S_AL_SoundInfo;
	si->SoundList = S_AL_SoundList;

#ifdef USE_VOIP
	si->StartCapture = S_AL_StartCapture;
	si->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;
	si->Capture = S_AL_Capture;
	si->StopCapture = S_AL_StopCapture;
	si->MasterGain = S_AL_MasterGain;
#endif

	return qtrue;
#else
	return qfalse;
#endif
}
",C,"	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );
	if ( COM_CompareExtension( s_alDriver->string, "".pk3"" ) )
	{
		Com_Printf( ""Rejecting DLL named \""%s\"""", s_alDriver->string );
		return qfalse;
	}

","	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );
",,"@@ -2512,11 +2512,17 @@ qboolean S_AL_Init( soundInterface_t *si )
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
-	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );
+	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
+	if ( COM_CompareExtension( s_alDriver->string, "".pk3"" ) )
+	{
+		Com_Printf( ""Rejecting DLL named \""%s\"""", s_alDriver->string );
+		return qfalse;
+	}
+
 	// Load QAL
 	if( !QAL_Init( s_alDriver->string ) )
 	{",OpenJK,f61fe5f6a0419ef4a88d46a128052f2e8352e85d,376267d534476a875d8b9228149c4ee18b74a4fd,1,"qboolean S_AL_Init( soundInterface_t *si )
{
#ifdef USE_OPENAL
	const char* device = NULL;
	const char* inputdevice = NULL;
	int i;

	if( !si ) {
		return qfalse;
	}

	for (i = 0; i < MAX_RAW_STREAMS; i++) {
		streamSourceHandles[i] = -1;
		streamPlaying[i] = qfalse;
		streamSources[i] = 0;
		streamNumBuffers[i] = 0;
		streamBufIndex[i] = 0;
	}

	// New console variables
	s_alPrecache = Cvar_Get( ""s_alPrecache"", ""1"", CVAR_ARCHIVE );
	s_alGain = Cvar_Get( ""s_alGain"", ""1.0"", CVAR_ARCHIVE );
	s_alSources = Cvar_Get( ""s_alSources"", ""96"", CVAR_ARCHIVE );
	s_alDopplerFactor = Cvar_Get( ""s_alDopplerFactor"", ""1.0"", CVAR_ARCHIVE );
	s_alDopplerSpeed = Cvar_Get( ""s_alDopplerSpeed"", ""9000"", CVAR_ARCHIVE );
	s_alMinDistance = Cvar_Get( ""s_alMinDistance"", ""120"", CVAR_CHEAT );
	s_alMaxDistance = Cvar_Get(""s_alMaxDistance"", ""1024"", CVAR_CHEAT);
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
//flaw_line_below:
	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );
//fix_flaw_line_below:
//	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
//fix_flaw_line_below:
//	if ( COM_CompareExtension( s_alDriver->string, "".pk3"" ) )
//fix_flaw_line_below:
//	{
//fix_flaw_line_below:
//		Com_Printf( ""Rejecting DLL named \""%s\"""", s_alDriver->string );
//fix_flaw_line_below:
//		return qfalse;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	// Load QAL
 	if( !QAL_Init( s_alDriver->string ) )
 	{
		Com_Printf( ""Failed to load library: \""%s\"".\n"", s_alDriver->string );
		if( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {
			return qfalse;
		}
	}

	device = s_alDevice->string;
	if(device && !*device)
		device = NULL;

	inputdevice = s_alInputDevice->string;
	if(inputdevice && !*inputdevice)
		inputdevice = NULL;


	// Device enumeration support
	enumeration_all_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATE_ALL_EXT"");
	enumeration_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATION_EXT"");

	if(enumeration_ext || enumeration_all_ext)
	{
		char devicenames[16384] = """";
		const char *devicelist;
#ifdef _WIN32
		const char *defaultdevice;
#endif
		int curlen;

		// get all available devices + the default device name.
		if(enumeration_all_ext)
		{
			devicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);
#endif
		}
		else
		{
			// We don't have ALC_ENUMERATE_ALL_EXT but normal enumeration.
			devicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
#endif
			enumeration_ext = qtrue;
		}

#ifdef _WIN32
		// check whether the default device is generic hardware. If it is, change to
		// Generic Software as that one works more reliably with various sound systems.
		// If it's not, use OpenAL's default selection as we don't want to ignore
		// native hardware acceleration.
		if(!device && defaultdevice && !strcmp(defaultdevice, ""Generic Hardware""))
			device = ""Generic Software"";
#endif

		// dump a list of available devices to a cvar for the user to see.

		if(devicelist)
		{
			while((curlen = strlen(devicelist)))
			{
				Q_strcat(devicenames, sizeof(devicenames), devicelist);
				Q_strcat(devicenames, sizeof(devicenames), ""\n"");

				devicelist += curlen + 1;
			}
		}

		s_alAvailableDevices = Cvar_Get(""s_alAvailableDevices"", devicenames, CVAR_ROM | CVAR_NORESTART);
	}

	alDevice = qalcOpenDevice(device);
	if( !alDevice && device )
	{
		Com_Printf( ""Failed to open OpenAL device '%s', trying default.\n"", device );
		alDevice = qalcOpenDevice(NULL);
	}

	if( !alDevice )
	{
		QAL_Shutdown( );
		Com_Printf( ""Failed to open OpenAL device.\n"" );
		return qfalse;
	}

	// Create OpenAL context
	alContext = qalcCreateContext( alDevice, NULL );
	if( !alContext )
	{
		QAL_Shutdown( );
		qalcCloseDevice( alDevice );
		Com_Printf( ""Failed to create OpenAL context.\n"" );
		return qfalse;
	}
	qalcMakeContextCurrent( alContext );

	// Initialize sources, buffers, music
	S_AL_BufferInit( );
	S_AL_SrcInit( );

	// Set up OpenAL parameters (doppler, etc)
	qalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);
	qalDopplerFactor( s_alDopplerFactor->value );
	qalSpeedOfSound( s_alDopplerSpeed->value );

#ifdef USE_VOIP
	// !!! FIXME: some of these alcCaptureOpenDevice() values should be cvars.
	// !!! FIXME: add support for capture device enumeration.
	// !!! FIXME: add some better error reporting.
	s_alCapture = Cvar_Get( ""s_alCapture"", ""1"", CVAR_ARCHIVE | CVAR_LATCH );
	if (!s_alCapture->integer)
	{
		Com_Printf(""OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n"");
	}
#if USE_MUMBLE
	else if (cl_useMumble->integer)
	{
		Com_Printf(""OpenAL capture support disabled for Mumble support\n"");
	}
#endif
	else
	{
#ifdef __APPLE__
		// !!! FIXME: Apple has a 1.1-compliant OpenAL, which includes
		// !!! FIXME:  capture support, but they don't list it in the
		// !!! FIXME:  extension string. We need to check the version string,
		// !!! FIXME:  then the extension string, but that's too much trouble,
		// !!! FIXME:  so we'll just check the function pointer for now.
		if (qalcCaptureOpenDevice == NULL)
#else
		if (!qalcIsExtensionPresent(NULL, ""ALC_EXT_capture""))
#endif
		{
			Com_Printf(""No ALC_EXT_capture support, can't record audio.\n"");
		}
		else
		{
			char inputdevicenames[16384] = """";
			const char *inputdevicelist;
			const char *defaultinputdevice;
			int curlen;

			capture_ext = qtrue;

			// get all available input devices + the default input device name.
			inputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);
			defaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);

			// dump a list of available devices to a cvar for the user to see.
			if (inputdevicelist)
			{
				while((curlen = strlen(inputdevicelist)))
				{
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), ""\n"");
					inputdevicelist += curlen + 1;
				}
			}

			s_alAvailableInputDevices = Cvar_Get(""s_alAvailableInputDevices"", inputdevicenames, CVAR_ROM | CVAR_NORESTART);

			Com_Printf(""OpenAL default capture device is '%s'\n"", defaultinputdevice ? defaultinputdevice : ""none"");
			alCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			if( !alCaptureDevice && inputdevice )
			{
				Com_Printf( ""Failed to open OpenAL Input device '%s', trying default.\n"", inputdevice );
				alCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			}
			Com_Printf( ""OpenAL capture device %s.\n"",
				    (alCaptureDevice == NULL) ? ""failed to open"" : ""opened"");
		}
	}
#endif

	si->Shutdown = S_AL_Shutdown;
	si->StartSound = S_AL_StartSound;
	si->StartLocalSound = S_AL_StartLocalSound;
	si->StartBackgroundTrack = S_AL_StartBackgroundTrack;
	si->StopBackgroundTrack = S_AL_StopBackgroundTrack;
	si->RawSamples = S_AL_RawSamples;
	si->StopAllSounds = S_AL_StopAllSounds;
	si->ClearLoopingSounds = S_AL_ClearLoopingSounds;
	si->AddLoopingSound = S_AL_AddLoopingSound;
	si->AddRealLoopingSound = S_AL_AddRealLoopingSound;
	si->StopLoopingSound = S_AL_StopLoopingSound;
	si->Respatialize = S_AL_Respatialize;
	si->UpdateEntityPosition = S_AL_UpdateEntityPosition;
	si->Update = S_AL_Update;
	si->DisableSounds = S_AL_DisableSounds;
	si->BeginRegistration = S_AL_BeginRegistration;
	si->RegisterSound = S_AL_RegisterSound;
	si->ClearSoundBuffer = S_AL_ClearSoundBuffer;
	si->SoundInfo = S_AL_SoundInfo;
	si->SoundList = S_AL_SoundList;

#ifdef USE_VOIP
	si->StartCapture = S_AL_StartCapture;
	si->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;
	si->Capture = S_AL_Capture;
	si->StopCapture = S_AL_StopCapture;
	si->MasterGain = S_AL_MasterGain;
#endif

	return qtrue;
#else
	return qfalse;
#endif
}
"
5515,183251,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,6,https://github.com/iortcw/iortcw/commit/11a83410153756ae350a82ed41b08d128ff7f998,11a83410153756ae350a82ed41b08d128ff7f998,All: Merge some file writing extension checks,0,MP/code/client/cl_console.c,"{""sha"": ""dad42d9e4db1631e1415473a2d5cb7f24678232d"", ""filename"": ""MP/code/client/cl_console.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/11a83410153756ae350a82ed41b08d128ff7f998/MP/code/client/cl_console.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/11a83410153756ae350a82ed41b08d128ff7f998/MP/code/client/cl_console.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/client/cl_console.c?ref=11a83410153756ae350a82ed41b08d128ff7f998"", ""patch"": ""@@ -227,6 +227,12 @@ void Con_Dump_f( void ) {\n \tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n \tCOM_DefaultExtension( filename, sizeof( filename ), \"".txt\"" );\n \n+\tif (!COM_CompareExtension(filename, \"".txt\""))\n+\t{\n+\t\tCom_Printf(\""Con_Dump_f: Only the \\\"".txt\\\"" extension is supported by this command!\\n\"");\n+\t\treturn;\n+\t}\n+\n \tf = FS_FOpenFileWrite( filename );\n \tif ( !f ) {\n \t\tCom_Printf (\""ERROR: couldn't open %s.\\n\"", filename);""}<_**next**_>{""sha"": ""13b36fd3f1e57c817c88f2927ba5f7cf3d3b1fdd"", ""filename"": ""MP/code/qcommon/common.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/11a83410153756ae350a82ed41b08d128ff7f998/MP/code/qcommon/common.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/11a83410153756ae350a82ed41b08d128ff7f998/MP/code/qcommon/common.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/qcommon/common.c?ref=11a83410153756ae350a82ed41b08d128ff7f998"", ""patch"": ""@@ -3058,6 +3058,12 @@ void Com_WriteConfig_f( void ) {\n \t\treturn;\n \t}\n \n+\tif (!COM_CompareExtension(filename, \"".cfg\""))\n+\t{\n+\t\tCom_Printf(\""Com_WriteConfig_f: Only the \\\"".cfg\\\"" extension is supported by this command!\\n\"");\n+\t\treturn;\n+\t}\n+\n \tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n \tCOM_DefaultExtension( filename, sizeof( filename ), \"".cfg\"" );\n \tCom_Printf( \""Writing %s.\\n\"", filename );""}<_**next**_>{""sha"": ""e7797eae7a1634ec8f45ac597a9239c19492aed4"", ""filename"": ""SP/code/client/cl_console.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/11a83410153756ae350a82ed41b08d128ff7f998/SP/code/client/cl_console.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/11a83410153756ae350a82ed41b08d128ff7f998/SP/code/client/cl_console.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/client/cl_console.c?ref=11a83410153756ae350a82ed41b08d128ff7f998"", ""patch"": ""@@ -219,6 +219,12 @@ void Con_Dump_f( void ) {\n \tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n \tCOM_DefaultExtension( filename, sizeof( filename ), \"".txt\"" );\n \n+\tif (!COM_CompareExtension(filename, \"".txt\""))\n+\t{\n+\t\tCom_Printf(\""Con_Dump_f: Only the \\\"".txt\\\"" extension is supported by this command!\\n\"");\n+\t\treturn;\n+\t}\n+\n \tf = FS_FOpenFileWrite( filename );\n \tif ( !f ) {\n \t\tCom_Printf (\""ERROR: couldn't open %s.\\n\"", filename);""}<_**next**_>{""sha"": ""402941f346ce7c2253e8cf4ec6a6a7b8e2c4d5e8"", ""filename"": ""SP/code/qcommon/common.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/11a83410153756ae350a82ed41b08d128ff7f998/SP/code/qcommon/common.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/11a83410153756ae350a82ed41b08d128ff7f998/SP/code/qcommon/common.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/qcommon/common.c?ref=11a83410153756ae350a82ed41b08d128ff7f998"", ""patch"": ""@@ -2601,6 +2601,12 @@ void Com_WriteConfig_f( void ) {\n \t\treturn;\n \t}\n \n+\tif (!COM_CompareExtension(filename, \"".cfg\""))\n+\t{\n+\t\tCom_Printf(\""Com_WriteConfig_f: Only the \\\"".cfg\\\"" extension is supported by this command!\\n\"");\n+\t\treturn;\n+\t}\n+\n \tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n \tCOM_DefaultExtension( filename, sizeof( filename ), \"".cfg\"" );\n \tCom_Printf( \""Writing %s.\\n\"", filename );""}","void Con_Dump_f( void ) {
	int l, x, i;
	short   *line;
	fileHandle_t f;
	int		bufferlen;
	char	*buffer;
	char	filename[MAX_QPATH];

	if ( Cmd_Argc() != 2 ) {
		Com_Printf( ""usage: condump <filename>\n"" );
		return;
	}

 	Q_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".txt"" );
 
	if (!COM_CompareExtension(filename, "".txt""))
	{
		Com_Printf(""Con_Dump_f: Only the \"".txt\"" extension is supported by this command!\n"");
		return;
	}

 	f = FS_FOpenFileWrite( filename );
 	if ( !f ) {
 		Com_Printf (""ERROR: couldn't open %s.\n"", filename);
		return;
	}

	Com_Printf (""Dumped console text to %s.\n"", filename );

	for ( l = con.current - con.totallines + 1 ; l <= con.current ; l++ )
	{
		line = con.text + ( l % con.totallines ) * con.linewidth;
		for ( x = 0 ; x < con.linewidth ; x++ )
			if ( ( line[x] & 0xff ) != ' ' ) {
				break;
			}
		if ( x != con.linewidth ) {
			break;
		}
	}

#ifdef _WIN32
	bufferlen = con.linewidth + 3 * sizeof ( char );
#else
	bufferlen = con.linewidth + 2 * sizeof ( char );
#endif

	buffer = Hunk_AllocateTempMemory( bufferlen );

	buffer[bufferlen-1] = 0;
	for ( ; l <= con.current ; l++ )
	{
		line = con.text + ( l % con.totallines ) * con.linewidth;
		for ( i = 0; i < con.linewidth; i++ )
			buffer[i] = line[i] & 0xff;
		for ( x = con.linewidth - 1 ; x >= 0 ; x-- )
		{
			if ( buffer[x] == ' ' ) {
				buffer[x] = 0;
			} else {
				break;
			}
		}
#ifdef _WIN32
		Q_strcat(buffer, bufferlen, ""\r\n"");
#else
		Q_strcat(buffer, bufferlen, ""\n"");
#endif
		FS_Write( buffer, strlen( buffer ), f );
	}

	Hunk_FreeTempMemory( buffer );
	FS_FCloseFile( f );
}
","void Con_Dump_f( void ) {
	int l, x, i;
	short   *line;
	fileHandle_t f;
	int		bufferlen;
	char	*buffer;
	char	filename[MAX_QPATH];

	if ( Cmd_Argc() != 2 ) {
		Com_Printf( ""usage: condump <filename>\n"" );
		return;
	}

 	Q_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".txt"" );
 
 	f = FS_FOpenFileWrite( filename );
 	if ( !f ) {
 		Com_Printf (""ERROR: couldn't open %s.\n"", filename);
		return;
	}

	Com_Printf (""Dumped console text to %s.\n"", filename );

	for ( l = con.current - con.totallines + 1 ; l <= con.current ; l++ )
	{
		line = con.text + ( l % con.totallines ) * con.linewidth;
		for ( x = 0 ; x < con.linewidth ; x++ )
			if ( ( line[x] & 0xff ) != ' ' ) {
				break;
			}
		if ( x != con.linewidth ) {
			break;
		}
	}

#ifdef _WIN32
	bufferlen = con.linewidth + 3 * sizeof ( char );
#else
	bufferlen = con.linewidth + 2 * sizeof ( char );
#endif

	buffer = Hunk_AllocateTempMemory( bufferlen );

	buffer[bufferlen-1] = 0;
	for ( ; l <= con.current ; l++ )
	{
		line = con.text + ( l % con.totallines ) * con.linewidth;
		for ( i = 0; i < con.linewidth; i++ )
			buffer[i] = line[i] & 0xff;
		for ( x = con.linewidth - 1 ; x >= 0 ; x-- )
		{
			if ( buffer[x] == ' ' ) {
				buffer[x] = 0;
			} else {
				break;
			}
		}
#ifdef _WIN32
		Q_strcat(buffer, bufferlen, ""\r\n"");
#else
		Q_strcat(buffer, bufferlen, ""\n"");
#endif
		FS_Write( buffer, strlen( buffer ), f );
	}

	Hunk_FreeTempMemory( buffer );
	FS_FCloseFile( f );
}
",C,"	if (!COM_CompareExtension(filename, "".txt""))
	{
		Com_Printf(""Con_Dump_f: Only the \"".txt\"" extension is supported by this command!\n"");
		return;
	}

",,,"@@ -227,6 +227,12 @@ void Con_Dump_f( void ) {
 	Q_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".txt"" );
 
+	if (!COM_CompareExtension(filename, "".txt""))
+	{
+		Com_Printf(""Con_Dump_f: Only the \"".txt\"" extension is supported by this command!\n"");
+		return;
+	}
+
 	f = FS_FOpenFileWrite( filename );
 	if ( !f ) {
 		Com_Printf (""ERROR: couldn't open %s.\n"", filename);",OpenJK,11a83410153756ae350a82ed41b08d128ff7f998,b248763e4878ef12d5835ece6600be8334f67da1,1,"void Con_Dump_f( void ) {
	int l, x, i;
	short   *line;
	fileHandle_t f;
	int		bufferlen;
	char	*buffer;
	char	filename[MAX_QPATH];

	if ( Cmd_Argc() != 2 ) {
		Com_Printf( ""usage: condump <filename>\n"" );
		return;
	}

 	Q_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".txt"" );
 
//fix_flaw_line_below:
//	if (!COM_CompareExtension(filename, "".txt""))
//fix_flaw_line_below:
//	{
//fix_flaw_line_below:
//		Com_Printf(""Con_Dump_f: Only the \"".txt\"" extension is supported by this command!\n"");
//fix_flaw_line_below:
//		return;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	f = FS_FOpenFileWrite( filename );
 	if ( !f ) {
 		Com_Printf (""ERROR: couldn't open %s.\n"", filename);
		return;
	}

	Com_Printf (""Dumped console text to %s.\n"", filename );

	// skip empty lines
	for ( l = con.current - con.totallines + 1 ; l <= con.current ; l++ )
	{
		line = con.text + ( l % con.totallines ) * con.linewidth;
		for ( x = 0 ; x < con.linewidth ; x++ )
			if ( ( line[x] & 0xff ) != ' ' ) {
				break;
			}
		if ( x != con.linewidth ) {
			break;
		}
	}

#ifdef _WIN32
	bufferlen = con.linewidth + 3 * sizeof ( char );
#else
	bufferlen = con.linewidth + 2 * sizeof ( char );
#endif

	buffer = Hunk_AllocateTempMemory( bufferlen );

	// write the remaining lines
	buffer[bufferlen-1] = 0;
	for ( ; l <= con.current ; l++ )
	{
		line = con.text + ( l % con.totallines ) * con.linewidth;
		for ( i = 0; i < con.linewidth; i++ )
			buffer[i] = line[i] & 0xff;
		for ( x = con.linewidth - 1 ; x >= 0 ; x-- )
		{
			if ( buffer[x] == ' ' ) {
				buffer[x] = 0;
			} else {
				break;
			}
		}
#ifdef _WIN32
		Q_strcat(buffer, bufferlen, ""\r\n"");
#else
		Q_strcat(buffer, bufferlen, ""\n"");
#endif
		FS_Write( buffer, strlen( buffer ), f );
	}

	Hunk_FreeTempMemory( buffer );
	FS_FCloseFile( f );
}
"
5516,183252,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,6,https://github.com/iortcw/iortcw/commit/11a83410153756ae350a82ed41b08d128ff7f998,11a83410153756ae350a82ed41b08d128ff7f998,All: Merge some file writing extension checks,0,MP/code/qcommon/common.c,"{""sha"": ""dad42d9e4db1631e1415473a2d5cb7f24678232d"", ""filename"": ""MP/code/client/cl_console.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/11a83410153756ae350a82ed41b08d128ff7f998/MP/code/client/cl_console.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/11a83410153756ae350a82ed41b08d128ff7f998/MP/code/client/cl_console.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/client/cl_console.c?ref=11a83410153756ae350a82ed41b08d128ff7f998"", ""patch"": ""@@ -227,6 +227,12 @@ void Con_Dump_f( void ) {\n \tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n \tCOM_DefaultExtension( filename, sizeof( filename ), \"".txt\"" );\n \n+\tif (!COM_CompareExtension(filename, \"".txt\""))\n+\t{\n+\t\tCom_Printf(\""Con_Dump_f: Only the \\\"".txt\\\"" extension is supported by this command!\\n\"");\n+\t\treturn;\n+\t}\n+\n \tf = FS_FOpenFileWrite( filename );\n \tif ( !f ) {\n \t\tCom_Printf (\""ERROR: couldn't open %s.\\n\"", filename);""}<_**next**_>{""sha"": ""13b36fd3f1e57c817c88f2927ba5f7cf3d3b1fdd"", ""filename"": ""MP/code/qcommon/common.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/11a83410153756ae350a82ed41b08d128ff7f998/MP/code/qcommon/common.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/11a83410153756ae350a82ed41b08d128ff7f998/MP/code/qcommon/common.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/qcommon/common.c?ref=11a83410153756ae350a82ed41b08d128ff7f998"", ""patch"": ""@@ -3058,6 +3058,12 @@ void Com_WriteConfig_f( void ) {\n \t\treturn;\n \t}\n \n+\tif (!COM_CompareExtension(filename, \"".cfg\""))\n+\t{\n+\t\tCom_Printf(\""Com_WriteConfig_f: Only the \\\"".cfg\\\"" extension is supported by this command!\\n\"");\n+\t\treturn;\n+\t}\n+\n \tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n \tCOM_DefaultExtension( filename, sizeof( filename ), \"".cfg\"" );\n \tCom_Printf( \""Writing %s.\\n\"", filename );""}<_**next**_>{""sha"": ""e7797eae7a1634ec8f45ac597a9239c19492aed4"", ""filename"": ""SP/code/client/cl_console.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/11a83410153756ae350a82ed41b08d128ff7f998/SP/code/client/cl_console.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/11a83410153756ae350a82ed41b08d128ff7f998/SP/code/client/cl_console.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/client/cl_console.c?ref=11a83410153756ae350a82ed41b08d128ff7f998"", ""patch"": ""@@ -219,6 +219,12 @@ void Con_Dump_f( void ) {\n \tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n \tCOM_DefaultExtension( filename, sizeof( filename ), \"".txt\"" );\n \n+\tif (!COM_CompareExtension(filename, \"".txt\""))\n+\t{\n+\t\tCom_Printf(\""Con_Dump_f: Only the \\\"".txt\\\"" extension is supported by this command!\\n\"");\n+\t\treturn;\n+\t}\n+\n \tf = FS_FOpenFileWrite( filename );\n \tif ( !f ) {\n \t\tCom_Printf (\""ERROR: couldn't open %s.\\n\"", filename);""}<_**next**_>{""sha"": ""402941f346ce7c2253e8cf4ec6a6a7b8e2c4d5e8"", ""filename"": ""SP/code/qcommon/common.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/11a83410153756ae350a82ed41b08d128ff7f998/SP/code/qcommon/common.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/11a83410153756ae350a82ed41b08d128ff7f998/SP/code/qcommon/common.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/qcommon/common.c?ref=11a83410153756ae350a82ed41b08d128ff7f998"", ""patch"": ""@@ -2601,6 +2601,12 @@ void Com_WriteConfig_f( void ) {\n \t\treturn;\n \t}\n \n+\tif (!COM_CompareExtension(filename, \"".cfg\""))\n+\t{\n+\t\tCom_Printf(\""Com_WriteConfig_f: Only the \\\"".cfg\\\"" extension is supported by this command!\\n\"");\n+\t\treturn;\n+\t}\n+\n \tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n \tCOM_DefaultExtension( filename, sizeof( filename ), \"".cfg\"" );\n \tCom_Printf( \""Writing %s.\\n\"", filename );""}","void Com_WriteConfig_f( void ) {
	char filename[MAX_QPATH];

	if ( Cmd_Argc() != 2 ) {
		Com_Printf( ""Usage: writeconfig <filename>\n"" );
 		return;
 	}
 
	if (!COM_CompareExtension(filename, "".cfg""))
	{
		Com_Printf(""Com_WriteConfig_f: Only the \"".cfg\"" extension is supported by this command!\n"");
		return;
	}

 	Q_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".cfg"" );
 	Com_Printf( ""Writing %s.\n"", filename );
	Com_WriteConfigToFile( filename );
}
","void Com_WriteConfig_f( void ) {
	char filename[MAX_QPATH];

	if ( Cmd_Argc() != 2 ) {
		Com_Printf( ""Usage: writeconfig <filename>\n"" );
 		return;
 	}
 
 	Q_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".cfg"" );
 	Com_Printf( ""Writing %s.\n"", filename );
	Com_WriteConfigToFile( filename );
}
",C,"	if (!COM_CompareExtension(filename, "".cfg""))
	{
		Com_Printf(""Com_WriteConfig_f: Only the \"".cfg\"" extension is supported by this command!\n"");
		return;
	}

",,,"@@ -3058,6 +3058,12 @@ void Com_WriteConfig_f( void ) {
 		return;
 	}
 
+	if (!COM_CompareExtension(filename, "".cfg""))
+	{
+		Com_Printf(""Com_WriteConfig_f: Only the \"".cfg\"" extension is supported by this command!\n"");
+		return;
+	}
+
 	Q_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".cfg"" );
 	Com_Printf( ""Writing %s.\n"", filename );",OpenJK,11a83410153756ae350a82ed41b08d128ff7f998,b248763e4878ef12d5835ece6600be8334f67da1,1,"void Com_WriteConfig_f( void ) {
	char filename[MAX_QPATH];

	if ( Cmd_Argc() != 2 ) {
		Com_Printf( ""Usage: writeconfig <filename>\n"" );
 		return;
 	}
 
//fix_flaw_line_below:
//	if (!COM_CompareExtension(filename, "".cfg""))
//fix_flaw_line_below:
//	{
//fix_flaw_line_below:
//		Com_Printf(""Com_WriteConfig_f: Only the \"".cfg\"" extension is supported by this command!\n"");
//fix_flaw_line_below:
//		return;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	Q_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".cfg"" );
 	Com_Printf( ""Writing %s.\n"", filename );
	Com_WriteConfigToFile( filename );
}
"
5517,183253,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,1,https://github.com/iortcw/iortcw/commit/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,"All: Don't load .pk3s as .dlls, and don't load user config files from .pk3s",1,MP/code/client/cl_main.c,"{""sha"": ""92675c53d7d8d4e2072a5423e471fb48daeec2c6"", ""filename"": ""MP/code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/client/cl_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/client/cl_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -3674,7 +3674,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_mp_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -4014,7 +4014,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get( \""cl_allowDownload\"", \""1\"", CVAR_ARCHIVE );\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \t// init autoswitch so the ui will have it correctly even""}<_**next**_>{""sha"": ""c262e6b62003d9fa427776ce44bfa958569ecd18"", ""filename"": ""MP/code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/qcommon/files.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/qcommon/files.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -1424,12 +1424,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and wolfconfig_mp.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t        len = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \t        \n \t        if(file == NULL)""}<_**next**_>{""sha"": ""f3dc2e91909d7f1f90227e2ba68dfa2e61a40485"", ""filename"": ""MP/code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/sys/sys_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -499,6 +499,13 @@ from executable path, then fs_basepath.\n void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n+\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);""}<_**next**_>{""sha"": ""18c16aa973bb821e6972cf1da0c98c3007ddbfd6"", ""filename"": ""SP/code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/client/cl_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/client/cl_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -3348,7 +3348,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_sp_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -3690,7 +3690,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get( \""cl_allowDownload\"", \""0\"", CVAR_ARCHIVE );\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \t// init autoswitch so the ui will have it correctly even""}<_**next**_>{""sha"": ""15910bd5e96fec07e0fb331beba36879ea237545"", ""filename"": ""SP/code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/qcommon/files.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/qcommon/files.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -1591,12 +1591,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and wolfconfig.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t\tlen = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \n \t\tif(file == NULL)""}<_**next**_>{""sha"": ""e591d9890c74ee974af303dae0be35f1236d5473"", ""filename"": ""SP/code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/sys/sys_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -499,6 +499,13 @@ from executable path, then fs_basepath.\n void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n+\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);""}","void CL_Init( void ) {
	Com_Printf( ""----- Client Initialization -----\n"" );

	Con_Init();

	if(!com_fullyInitialized)
	{
		CL_ClearState();
		clc.state = CA_DISCONNECTED;	// no longer CA_UNINITIALIZED
		cl_oldGameSet = qfalse;
	}

	cls.realtime = 0;

	CL_InitInput();

	cl_noprint = Cvar_Get( ""cl_noprint"", ""0"", 0 );
#ifdef UPDATE_SERVER_NAME
	cl_motd = Cvar_Get( ""cl_motd"", ""1"", 0 );
#endif
	cl_autoupdate = Cvar_Get( ""cl_autoupdate"", ""0"", CVAR_ARCHIVE );

	cl_timeout = Cvar_Get( ""cl_timeout"", ""200"", 0 );

	cl_wavefilerecord = Cvar_Get( ""cl_wavefilerecord"", ""0"", CVAR_TEMP );

	cl_timeNudge = Cvar_Get( ""cl_timeNudge"", ""0"", CVAR_TEMP );
	cl_shownet = Cvar_Get( ""cl_shownet"", ""0"", CVAR_TEMP );
	cl_shownuments = Cvar_Get( ""cl_shownuments"", ""0"", CVAR_TEMP );
	cl_visibleClients = Cvar_Get( ""cl_visibleClients"", ""0"", CVAR_TEMP );
	cl_showServerCommands = Cvar_Get( ""cl_showServerCommands"", ""0"", 0 );
	cl_showSend = Cvar_Get( ""cl_showSend"", ""0"", CVAR_TEMP );
	cl_showTimeDelta = Cvar_Get( ""cl_showTimeDelta"", ""0"", CVAR_TEMP );
	cl_freezeDemo = Cvar_Get( ""cl_freezeDemo"", ""0"", CVAR_TEMP );
	rcon_client_password = Cvar_Get( ""rconPassword"", """", CVAR_TEMP );
	cl_activeAction = Cvar_Get( ""activeAction"", """", CVAR_TEMP );

	cl_timedemo = Cvar_Get( ""timedemo"", ""0"", 0 );
	cl_timedemoLog = Cvar_Get (""cl_timedemoLog"", """", CVAR_ARCHIVE);
	cl_autoRecordDemo = Cvar_Get (""cl_autoRecordDemo"", ""0"", CVAR_ARCHIVE);
	cl_aviFrameRate = Cvar_Get (""cl_aviFrameRate"", ""25"", CVAR_ARCHIVE);
	cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE);
	cl_avidemo = Cvar_Get( ""cl_avidemo"", ""0"", 0 );
	cl_forceavidemo = Cvar_Get( ""cl_forceavidemo"", ""0"", 0 );

	rconAddress = Cvar_Get( ""rconAddress"", """", 0 );

	cl_yawspeed = Cvar_Get( ""cl_yawspeed"", ""140"", CVAR_ARCHIVE );
	cl_pitchspeed = Cvar_Get( ""cl_pitchspeed"", ""140"", CVAR_ARCHIVE );
	cl_anglespeedkey = Cvar_Get( ""cl_anglespeedkey"", ""1.5"", 0 );

	cl_maxpackets = Cvar_Get( ""cl_maxpackets"", ""38"", CVAR_ARCHIVE );
	cl_packetdup = Cvar_Get( ""cl_packetdup"", ""1"", CVAR_ARCHIVE );

	cl_showPing = Cvar_Get( ""cl_showPing"", ""0"", CVAR_ARCHIVE );

	cl_run = Cvar_Get( ""cl_run"", ""1"", CVAR_ARCHIVE );
	cl_sensitivity = Cvar_Get( ""sensitivity"", ""5"", CVAR_ARCHIVE );
	cl_mouseAccel = Cvar_Get( ""cl_mouseAccel"", ""0"", CVAR_ARCHIVE );
	cl_freelook = Cvar_Get( ""cl_freelook"", ""1"", CVAR_ARCHIVE );

	cl_mouseAccelStyle = Cvar_Get( ""cl_mouseAccelStyle"", ""0"", CVAR_ARCHIVE );
	cl_mouseAccelOffset = Cvar_Get( ""cl_mouseAccelOffset"", ""5"", CVAR_ARCHIVE );
	Cvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);

	cl_showMouseRate = Cvar_Get( ""cl_showmouserate"", ""0"", 0 );
 
 	cl_allowDownload = Cvar_Get( ""cl_allowDownload"", ""1"", CVAR_ARCHIVE );
 #ifdef USE_CURL_DLOPEN
	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
 #endif
 
	Cvar_Get( ""cg_autoswitch"", ""0"", CVAR_ARCHIVE );

	Cvar_Get( ""cg_wolfparticles"", ""1"", CVAR_ARCHIVE );

	cl_conXOffset = Cvar_Get( ""cl_conXOffset"", ""0"", 0 );
	cl_inGameVideo = Cvar_Get( ""r_inGameVideo"", ""1"", CVAR_ARCHIVE );

	cl_serverStatusResendTime = Cvar_Get( ""cl_serverStatusResendTime"", ""750"", 0 );

	cl_recoilPitch = Cvar_Get( ""cg_recoilPitch"", ""0"", CVAR_ROM );

	cl_bypassMouseInput = Cvar_Get( ""cl_bypassMouseInput"", ""0"", 0 ); //CVAR_ROM );			// NERVE - SMF

	m_pitch = Cvar_Get( ""m_pitch"", ""0.022"", CVAR_ARCHIVE );
	m_yaw = Cvar_Get( ""m_yaw"", ""0.022"", CVAR_ARCHIVE );
	m_forward = Cvar_Get( ""m_forward"", ""0.25"", CVAR_ARCHIVE );
	m_side = Cvar_Get( ""m_side"", ""0.25"", CVAR_ARCHIVE );
	m_filter = Cvar_Get( ""m_filter"", ""0"", CVAR_ARCHIVE );

	j_pitch =        Cvar_Get (""j_pitch"",        ""0.022"", CVAR_ARCHIVE);
	j_yaw =          Cvar_Get (""j_yaw"",          ""-0.022"", CVAR_ARCHIVE);
	j_forward =      Cvar_Get (""j_forward"",      ""-0.25"", CVAR_ARCHIVE);
	j_side =         Cvar_Get (""j_side"",         ""0.25"", CVAR_ARCHIVE);
	j_up =           Cvar_Get (""j_up"",           ""0"", CVAR_ARCHIVE);

	j_pitch_axis =   Cvar_Get (""j_pitch_axis"",   ""3"", CVAR_ARCHIVE);
	j_yaw_axis =     Cvar_Get (""j_yaw_axis"",     ""2"", CVAR_ARCHIVE);
	j_forward_axis = Cvar_Get (""j_forward_axis"", ""1"", CVAR_ARCHIVE);
	j_side_axis =    Cvar_Get (""j_side_axis"",    ""0"", CVAR_ARCHIVE);
	j_up_axis =      Cvar_Get (""j_up_axis"",      ""4"", CVAR_ARCHIVE);

	Cvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);

	cl_motdString = Cvar_Get( ""cl_motdString"", """", CVAR_ROM );

	Cvar_Get( ""cl_maxPing"", ""800"", CVAR_ARCHIVE );

	cl_lanForcePackets = Cvar_Get (""cl_lanForcePackets"", ""1"", CVAR_ARCHIVE);

	cl_guid = Cvar_Get( ""cl_guid"", ""unknown"", CVAR_USERINFO | CVAR_ROM );

	cl_guidServerUniq = Cvar_Get (""cl_guidServerUniq"", ""1"", CVAR_ARCHIVE);

	cl_consoleKeys = Cvar_Get( ""cl_consoleKeys"", ""~ ` 0x7e 0x60"", CVAR_ARCHIVE);

	Cvar_Get( ""cg_drawCompass"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_drawNotifyText"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_quickMessageAlt"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_popupLimboMenu"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_descriptiveText"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_drawTeamOverlay"", ""2"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_uselessNostalgia"", ""0"", CVAR_ARCHIVE ); // JPW NERVE
	Cvar_Get( ""cg_drawGun"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_cursorHints"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_voiceSpriteTime"", ""6000"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_teamChatsOnly"", ""0"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_noVoiceChats"", ""0"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_noVoiceText"", ""0"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_crosshairSize"", ""48"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_drawCrosshair"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_zoomDefaultSniper"", ""20"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_zoomstepsniper"", ""2"", CVAR_ARCHIVE );

	Cvar_Get( ""mp_playerType"", ""0"", 0 );
	Cvar_Get( ""mp_currentPlayerType"", ""0"", 0 );
	Cvar_Get( ""mp_weapon"", ""0"", 0 );
	Cvar_Get( ""mp_team"", ""0"", 0 );
	Cvar_Get( ""mp_currentTeam"", ""0"", 0 );

	Cvar_Get( ""name"", ""WolfPlayer"", CVAR_USERINFO | CVAR_ARCHIVE );
	cl_rate = Cvar_Get( ""rate"", ""25000"", CVAR_USERINFO | CVAR_ARCHIVE );     // NERVE - SMF - changed from 3000
	Cvar_Get( ""snaps"", ""20"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""model"", ""multi"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""head"", ""default"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""color"", ""4"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""handicap"", ""100"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""sex"", ""male"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""cl_anonymous"", ""0"", CVAR_USERINFO | CVAR_ARCHIVE );

	Cvar_Get( ""password"", """", CVAR_USERINFO );
	Cvar_Get( ""cg_predictItems"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE );

#ifdef USE_MUMBLE
	cl_useMumble = Cvar_Get (""cl_useMumble"", ""0"", CVAR_ARCHIVE | CVAR_LATCH);
	cl_mumbleScale = Cvar_Get (""cl_mumbleScale"", ""0.0254"", CVAR_ARCHIVE);
#endif

#ifdef USE_VOIP
	cl_voipSend = Cvar_Get (""cl_voipSend"", ""0"", 0);
	cl_voipSendTarget = Cvar_Get (""cl_voipSendTarget"", ""spatial"", 0);
	cl_voipGainDuringCapture = Cvar_Get (""cl_voipGainDuringCapture"", ""0.2"", CVAR_ARCHIVE);
	cl_voipCaptureMult = Cvar_Get (""cl_voipCaptureMult"", ""2.0"", CVAR_ARCHIVE);
	cl_voipUseVAD = Cvar_Get (""cl_voipUseVAD"", ""0"", CVAR_ARCHIVE);
	cl_voipVADThreshold = Cvar_Get (""cl_voipVADThreshold"", ""0.25"", CVAR_ARCHIVE);
	cl_voipShowMeter = Cvar_Get (""cl_voipShowMeter"", ""1"", CVAR_ARCHIVE);

	cl_voip = Cvar_Get (""cl_voip"", ""1"", CVAR_ARCHIVE);
	Cvar_CheckRange( cl_voip, 0, 1, qtrue );
	cl_voipProtocol = Cvar_Get (""cl_voipProtocol"", cl_voip->integer ? ""opus"" : """", CVAR_USERINFO | CVAR_ROM);
#endif

	Cvar_Get( ""cg_autoactivate"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE );

	Cvar_Get( ""cg_viewsize"", ""100"", CVAR_ARCHIVE );
	Cvar_Get (""cg_stereoSeparation"", ""0"", CVAR_ROM);

	Cvar_Get( ""cg_autoReload"", ""1"", CVAR_ARCHIVE | CVAR_USERINFO );

	cl_missionStats = Cvar_Get( ""g_missionStats"", ""0"", CVAR_ROM );
	cl_waitForFire = Cvar_Get( ""cl_waitForFire"", ""0"", CVAR_ROM );

	cl_language = Cvar_Get( ""cl_language"", ""0"", CVAR_ARCHIVE );
	cl_debugTranslation = Cvar_Get( ""cl_debugTranslation"", ""0"", 0 );

	cl_updateavailable = Cvar_Get( ""cl_updateavailable"", ""0"", CVAR_ROM );
	cl_updatefiles = Cvar_Get( ""cl_updatefiles"", """", CVAR_ROM );

	Q_strncpyz( cls.autoupdateServerNames[0], AUTOUPDATE_SERVER1_NAME, MAX_QPATH );
	Q_strncpyz( cls.autoupdateServerNames[1], AUTOUPDATE_SERVER2_NAME, MAX_QPATH );
	Q_strncpyz( cls.autoupdateServerNames[2], AUTOUPDATE_SERVER3_NAME, MAX_QPATH );
	Q_strncpyz( cls.autoupdateServerNames[3], AUTOUPDATE_SERVER4_NAME, MAX_QPATH );
	Q_strncpyz( cls.autoupdateServerNames[4], AUTOUPDATE_SERVER5_NAME, MAX_QPATH );

	Cmd_AddCommand( ""cmd"", CL_ForwardToServer_f );
	Cmd_AddCommand( ""configstrings"", CL_Configstrings_f );
	Cmd_AddCommand( ""clientinfo"", CL_Clientinfo_f );
	Cmd_AddCommand( ""snd_restart"", CL_Snd_Restart_f );
	Cmd_AddCommand( ""vid_restart"", CL_Vid_Restart_f );
	Cmd_AddCommand( ""ui_restart"", CL_UI_Restart_f );          // NERVE - SMF
	Cmd_AddCommand( ""disconnect"", CL_Disconnect_f );
	Cmd_AddCommand( ""record"", CL_Record_f );
	Cmd_AddCommand( ""demo"", CL_PlayDemo_f );
	Cmd_SetCommandCompletionFunc( ""demo"", CL_CompleteDemoName );
	Cmd_AddCommand( ""cinematic"", CL_PlayCinematic_f );
	Cmd_AddCommand( ""stoprecord"", CL_StopRecord_f );
	Cmd_AddCommand( ""connect"", CL_Connect_f );
	Cmd_AddCommand( ""reconnect"", CL_Reconnect_f );
	Cmd_AddCommand( ""localservers"", CL_LocalServers_f );
	Cmd_AddCommand( ""globalservers"", CL_GlobalServers_f );
	Cmd_AddCommand( ""rcon"", CL_Rcon_f );
	Cmd_SetCommandCompletionFunc( ""rcon"", CL_CompleteRcon );
	Cmd_AddCommand( ""ping"", CL_Ping_f );
	Cmd_AddCommand( ""serverstatus"", CL_ServerStatus_f );
	Cmd_AddCommand( ""showip"", CL_ShowIP_f );
	Cmd_AddCommand( ""fs_openedList"", CL_OpenedPK3List_f );
	Cmd_AddCommand( ""fs_referencedList"", CL_ReferencedPK3List_f );
	Cmd_AddCommand (""video"", CL_Video_f );
	Cmd_AddCommand (""stopvideo"", CL_StopVideo_f );

	Cmd_AddCommand( ""cache_startgather"", CL_Cache_StartGather_f );
	Cmd_AddCommand( ""cache_usedfile"", CL_Cache_UsedFile_f );
	Cmd_AddCommand( ""cache_setindex"", CL_Cache_SetIndex_f );
	Cmd_AddCommand( ""cache_mapchange"", CL_Cache_MapChange_f );
	Cmd_AddCommand( ""cache_endgather"", CL_Cache_EndGather_f );

	Cmd_AddCommand( ""updatehunkusage"", CL_UpdateLevelHunkUsage );
	Cmd_AddCommand( ""updatescreen"", SCR_UpdateScreen );
	Cmd_AddCommand( ""SaveTranslations"", CL_SaveTranslations_f );     // NERVE - SMF - localization
	Cmd_AddCommand( ""SaveNewTranslations"", CL_SaveNewTranslations_f );   // NERVE - SMF - localization
	Cmd_AddCommand( ""LoadTranslations"", CL_LoadTranslations_f );     // NERVE - SMF - localization

	Cmd_AddCommand( ""startSingleplayer"", CL_startSingleplayer_f );      // NERVE - SMF

	Cmd_AddCommand( ""setRecommended"", CL_SetRecommended_f );

	CL_InitRef();

	SCR_Init();


	Cvar_Set( ""cl_running"", ""1"" );

	autoupdateChecked = qfalse;
	autoupdateStarted = qfalse;

	CL_InitTranslation();   // NERVE - SMF - localization

	CL_GenerateQKey();
	CL_UpdateGUID( NULL, 0 );

	Com_Printf( ""----- Client Initialization Complete -----\n"" );
}
","void CL_Init( void ) {
	Com_Printf( ""----- Client Initialization -----\n"" );

	Con_Init();

	if(!com_fullyInitialized)
	{
		CL_ClearState();
		clc.state = CA_DISCONNECTED;	// no longer CA_UNINITIALIZED
		cl_oldGameSet = qfalse;
	}

	cls.realtime = 0;

	CL_InitInput();

	cl_noprint = Cvar_Get( ""cl_noprint"", ""0"", 0 );
#ifdef UPDATE_SERVER_NAME
	cl_motd = Cvar_Get( ""cl_motd"", ""1"", 0 );
#endif
	cl_autoupdate = Cvar_Get( ""cl_autoupdate"", ""0"", CVAR_ARCHIVE );

	cl_timeout = Cvar_Get( ""cl_timeout"", ""200"", 0 );

	cl_wavefilerecord = Cvar_Get( ""cl_wavefilerecord"", ""0"", CVAR_TEMP );

	cl_timeNudge = Cvar_Get( ""cl_timeNudge"", ""0"", CVAR_TEMP );
	cl_shownet = Cvar_Get( ""cl_shownet"", ""0"", CVAR_TEMP );
	cl_shownuments = Cvar_Get( ""cl_shownuments"", ""0"", CVAR_TEMP );
	cl_visibleClients = Cvar_Get( ""cl_visibleClients"", ""0"", CVAR_TEMP );
	cl_showServerCommands = Cvar_Get( ""cl_showServerCommands"", ""0"", 0 );
	cl_showSend = Cvar_Get( ""cl_showSend"", ""0"", CVAR_TEMP );
	cl_showTimeDelta = Cvar_Get( ""cl_showTimeDelta"", ""0"", CVAR_TEMP );
	cl_freezeDemo = Cvar_Get( ""cl_freezeDemo"", ""0"", CVAR_TEMP );
	rcon_client_password = Cvar_Get( ""rconPassword"", """", CVAR_TEMP );
	cl_activeAction = Cvar_Get( ""activeAction"", """", CVAR_TEMP );

	cl_timedemo = Cvar_Get( ""timedemo"", ""0"", 0 );
	cl_timedemoLog = Cvar_Get (""cl_timedemoLog"", """", CVAR_ARCHIVE);
	cl_autoRecordDemo = Cvar_Get (""cl_autoRecordDemo"", ""0"", CVAR_ARCHIVE);
	cl_aviFrameRate = Cvar_Get (""cl_aviFrameRate"", ""25"", CVAR_ARCHIVE);
	cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE);
	cl_avidemo = Cvar_Get( ""cl_avidemo"", ""0"", 0 );
	cl_forceavidemo = Cvar_Get( ""cl_forceavidemo"", ""0"", 0 );

	rconAddress = Cvar_Get( ""rconAddress"", """", 0 );

	cl_yawspeed = Cvar_Get( ""cl_yawspeed"", ""140"", CVAR_ARCHIVE );
	cl_pitchspeed = Cvar_Get( ""cl_pitchspeed"", ""140"", CVAR_ARCHIVE );
	cl_anglespeedkey = Cvar_Get( ""cl_anglespeedkey"", ""1.5"", 0 );

	cl_maxpackets = Cvar_Get( ""cl_maxpackets"", ""38"", CVAR_ARCHIVE );
	cl_packetdup = Cvar_Get( ""cl_packetdup"", ""1"", CVAR_ARCHIVE );

	cl_showPing = Cvar_Get( ""cl_showPing"", ""0"", CVAR_ARCHIVE );

	cl_run = Cvar_Get( ""cl_run"", ""1"", CVAR_ARCHIVE );
	cl_sensitivity = Cvar_Get( ""sensitivity"", ""5"", CVAR_ARCHIVE );
	cl_mouseAccel = Cvar_Get( ""cl_mouseAccel"", ""0"", CVAR_ARCHIVE );
	cl_freelook = Cvar_Get( ""cl_freelook"", ""1"", CVAR_ARCHIVE );

	cl_mouseAccelStyle = Cvar_Get( ""cl_mouseAccelStyle"", ""0"", CVAR_ARCHIVE );
	cl_mouseAccelOffset = Cvar_Get( ""cl_mouseAccelOffset"", ""5"", CVAR_ARCHIVE );
	Cvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);

	cl_showMouseRate = Cvar_Get( ""cl_showmouserate"", ""0"", 0 );
 
 	cl_allowDownload = Cvar_Get( ""cl_allowDownload"", ""1"", CVAR_ARCHIVE );
 #ifdef USE_CURL_DLOPEN
	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);
 #endif
 
	Cvar_Get( ""cg_autoswitch"", ""0"", CVAR_ARCHIVE );

	Cvar_Get( ""cg_wolfparticles"", ""1"", CVAR_ARCHIVE );

	cl_conXOffset = Cvar_Get( ""cl_conXOffset"", ""0"", 0 );
	cl_inGameVideo = Cvar_Get( ""r_inGameVideo"", ""1"", CVAR_ARCHIVE );

	cl_serverStatusResendTime = Cvar_Get( ""cl_serverStatusResendTime"", ""750"", 0 );

	cl_recoilPitch = Cvar_Get( ""cg_recoilPitch"", ""0"", CVAR_ROM );

	cl_bypassMouseInput = Cvar_Get( ""cl_bypassMouseInput"", ""0"", 0 ); //CVAR_ROM );			// NERVE - SMF

	m_pitch = Cvar_Get( ""m_pitch"", ""0.022"", CVAR_ARCHIVE );
	m_yaw = Cvar_Get( ""m_yaw"", ""0.022"", CVAR_ARCHIVE );
	m_forward = Cvar_Get( ""m_forward"", ""0.25"", CVAR_ARCHIVE );
	m_side = Cvar_Get( ""m_side"", ""0.25"", CVAR_ARCHIVE );
	m_filter = Cvar_Get( ""m_filter"", ""0"", CVAR_ARCHIVE );

	j_pitch =        Cvar_Get (""j_pitch"",        ""0.022"", CVAR_ARCHIVE);
	j_yaw =          Cvar_Get (""j_yaw"",          ""-0.022"", CVAR_ARCHIVE);
	j_forward =      Cvar_Get (""j_forward"",      ""-0.25"", CVAR_ARCHIVE);
	j_side =         Cvar_Get (""j_side"",         ""0.25"", CVAR_ARCHIVE);
	j_up =           Cvar_Get (""j_up"",           ""0"", CVAR_ARCHIVE);

	j_pitch_axis =   Cvar_Get (""j_pitch_axis"",   ""3"", CVAR_ARCHIVE);
	j_yaw_axis =     Cvar_Get (""j_yaw_axis"",     ""2"", CVAR_ARCHIVE);
	j_forward_axis = Cvar_Get (""j_forward_axis"", ""1"", CVAR_ARCHIVE);
	j_side_axis =    Cvar_Get (""j_side_axis"",    ""0"", CVAR_ARCHIVE);
	j_up_axis =      Cvar_Get (""j_up_axis"",      ""4"", CVAR_ARCHIVE);

	Cvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);

	cl_motdString = Cvar_Get( ""cl_motdString"", """", CVAR_ROM );

	Cvar_Get( ""cl_maxPing"", ""800"", CVAR_ARCHIVE );

	cl_lanForcePackets = Cvar_Get (""cl_lanForcePackets"", ""1"", CVAR_ARCHIVE);

	cl_guid = Cvar_Get( ""cl_guid"", ""unknown"", CVAR_USERINFO | CVAR_ROM );

	cl_guidServerUniq = Cvar_Get (""cl_guidServerUniq"", ""1"", CVAR_ARCHIVE);

	cl_consoleKeys = Cvar_Get( ""cl_consoleKeys"", ""~ ` 0x7e 0x60"", CVAR_ARCHIVE);

	Cvar_Get( ""cg_drawCompass"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_drawNotifyText"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_quickMessageAlt"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_popupLimboMenu"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_descriptiveText"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_drawTeamOverlay"", ""2"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_uselessNostalgia"", ""0"", CVAR_ARCHIVE ); // JPW NERVE
	Cvar_Get( ""cg_drawGun"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_cursorHints"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_voiceSpriteTime"", ""6000"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_teamChatsOnly"", ""0"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_noVoiceChats"", ""0"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_noVoiceText"", ""0"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_crosshairSize"", ""48"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_drawCrosshair"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_zoomDefaultSniper"", ""20"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_zoomstepsniper"", ""2"", CVAR_ARCHIVE );

	Cvar_Get( ""mp_playerType"", ""0"", 0 );
	Cvar_Get( ""mp_currentPlayerType"", ""0"", 0 );
	Cvar_Get( ""mp_weapon"", ""0"", 0 );
	Cvar_Get( ""mp_team"", ""0"", 0 );
	Cvar_Get( ""mp_currentTeam"", ""0"", 0 );

	Cvar_Get( ""name"", ""WolfPlayer"", CVAR_USERINFO | CVAR_ARCHIVE );
	cl_rate = Cvar_Get( ""rate"", ""25000"", CVAR_USERINFO | CVAR_ARCHIVE );     // NERVE - SMF - changed from 3000
	Cvar_Get( ""snaps"", ""20"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""model"", ""multi"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""head"", ""default"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""color"", ""4"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""handicap"", ""100"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""sex"", ""male"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""cl_anonymous"", ""0"", CVAR_USERINFO | CVAR_ARCHIVE );

	Cvar_Get( ""password"", """", CVAR_USERINFO );
	Cvar_Get( ""cg_predictItems"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE );

#ifdef USE_MUMBLE
	cl_useMumble = Cvar_Get (""cl_useMumble"", ""0"", CVAR_ARCHIVE | CVAR_LATCH);
	cl_mumbleScale = Cvar_Get (""cl_mumbleScale"", ""0.0254"", CVAR_ARCHIVE);
#endif

#ifdef USE_VOIP
	cl_voipSend = Cvar_Get (""cl_voipSend"", ""0"", 0);
	cl_voipSendTarget = Cvar_Get (""cl_voipSendTarget"", ""spatial"", 0);
	cl_voipGainDuringCapture = Cvar_Get (""cl_voipGainDuringCapture"", ""0.2"", CVAR_ARCHIVE);
	cl_voipCaptureMult = Cvar_Get (""cl_voipCaptureMult"", ""2.0"", CVAR_ARCHIVE);
	cl_voipUseVAD = Cvar_Get (""cl_voipUseVAD"", ""0"", CVAR_ARCHIVE);
	cl_voipVADThreshold = Cvar_Get (""cl_voipVADThreshold"", ""0.25"", CVAR_ARCHIVE);
	cl_voipShowMeter = Cvar_Get (""cl_voipShowMeter"", ""1"", CVAR_ARCHIVE);

	cl_voip = Cvar_Get (""cl_voip"", ""1"", CVAR_ARCHIVE);
	Cvar_CheckRange( cl_voip, 0, 1, qtrue );
	cl_voipProtocol = Cvar_Get (""cl_voipProtocol"", cl_voip->integer ? ""opus"" : """", CVAR_USERINFO | CVAR_ROM);
#endif

	Cvar_Get( ""cg_autoactivate"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE );

	Cvar_Get( ""cg_viewsize"", ""100"", CVAR_ARCHIVE );
	Cvar_Get (""cg_stereoSeparation"", ""0"", CVAR_ROM);

	Cvar_Get( ""cg_autoReload"", ""1"", CVAR_ARCHIVE | CVAR_USERINFO );

	cl_missionStats = Cvar_Get( ""g_missionStats"", ""0"", CVAR_ROM );
	cl_waitForFire = Cvar_Get( ""cl_waitForFire"", ""0"", CVAR_ROM );

	cl_language = Cvar_Get( ""cl_language"", ""0"", CVAR_ARCHIVE );
	cl_debugTranslation = Cvar_Get( ""cl_debugTranslation"", ""0"", 0 );

	cl_updateavailable = Cvar_Get( ""cl_updateavailable"", ""0"", CVAR_ROM );
	cl_updatefiles = Cvar_Get( ""cl_updatefiles"", """", CVAR_ROM );

	Q_strncpyz( cls.autoupdateServerNames[0], AUTOUPDATE_SERVER1_NAME, MAX_QPATH );
	Q_strncpyz( cls.autoupdateServerNames[1], AUTOUPDATE_SERVER2_NAME, MAX_QPATH );
	Q_strncpyz( cls.autoupdateServerNames[2], AUTOUPDATE_SERVER3_NAME, MAX_QPATH );
	Q_strncpyz( cls.autoupdateServerNames[3], AUTOUPDATE_SERVER4_NAME, MAX_QPATH );
	Q_strncpyz( cls.autoupdateServerNames[4], AUTOUPDATE_SERVER5_NAME, MAX_QPATH );

	Cmd_AddCommand( ""cmd"", CL_ForwardToServer_f );
	Cmd_AddCommand( ""configstrings"", CL_Configstrings_f );
	Cmd_AddCommand( ""clientinfo"", CL_Clientinfo_f );
	Cmd_AddCommand( ""snd_restart"", CL_Snd_Restart_f );
	Cmd_AddCommand( ""vid_restart"", CL_Vid_Restart_f );
	Cmd_AddCommand( ""ui_restart"", CL_UI_Restart_f );          // NERVE - SMF
	Cmd_AddCommand( ""disconnect"", CL_Disconnect_f );
	Cmd_AddCommand( ""record"", CL_Record_f );
	Cmd_AddCommand( ""demo"", CL_PlayDemo_f );
	Cmd_SetCommandCompletionFunc( ""demo"", CL_CompleteDemoName );
	Cmd_AddCommand( ""cinematic"", CL_PlayCinematic_f );
	Cmd_AddCommand( ""stoprecord"", CL_StopRecord_f );
	Cmd_AddCommand( ""connect"", CL_Connect_f );
	Cmd_AddCommand( ""reconnect"", CL_Reconnect_f );
	Cmd_AddCommand( ""localservers"", CL_LocalServers_f );
	Cmd_AddCommand( ""globalservers"", CL_GlobalServers_f );
	Cmd_AddCommand( ""rcon"", CL_Rcon_f );
	Cmd_SetCommandCompletionFunc( ""rcon"", CL_CompleteRcon );
	Cmd_AddCommand( ""ping"", CL_Ping_f );
	Cmd_AddCommand( ""serverstatus"", CL_ServerStatus_f );
	Cmd_AddCommand( ""showip"", CL_ShowIP_f );
	Cmd_AddCommand( ""fs_openedList"", CL_OpenedPK3List_f );
	Cmd_AddCommand( ""fs_referencedList"", CL_ReferencedPK3List_f );
	Cmd_AddCommand (""video"", CL_Video_f );
	Cmd_AddCommand (""stopvideo"", CL_StopVideo_f );

	Cmd_AddCommand( ""cache_startgather"", CL_Cache_StartGather_f );
	Cmd_AddCommand( ""cache_usedfile"", CL_Cache_UsedFile_f );
	Cmd_AddCommand( ""cache_setindex"", CL_Cache_SetIndex_f );
	Cmd_AddCommand( ""cache_mapchange"", CL_Cache_MapChange_f );
	Cmd_AddCommand( ""cache_endgather"", CL_Cache_EndGather_f );

	Cmd_AddCommand( ""updatehunkusage"", CL_UpdateLevelHunkUsage );
	Cmd_AddCommand( ""updatescreen"", SCR_UpdateScreen );
	Cmd_AddCommand( ""SaveTranslations"", CL_SaveTranslations_f );     // NERVE - SMF - localization
	Cmd_AddCommand( ""SaveNewTranslations"", CL_SaveNewTranslations_f );   // NERVE - SMF - localization
	Cmd_AddCommand( ""LoadTranslations"", CL_LoadTranslations_f );     // NERVE - SMF - localization

	Cmd_AddCommand( ""startSingleplayer"", CL_startSingleplayer_f );      // NERVE - SMF

	Cmd_AddCommand( ""setRecommended"", CL_SetRecommended_f );

	CL_InitRef();

	SCR_Init();


	Cvar_Set( ""cl_running"", ""1"" );

	autoupdateChecked = qfalse;
	autoupdateStarted = qfalse;

	CL_InitTranslation();   // NERVE - SMF - localization

	CL_GenerateQKey();
	CL_UpdateGUID( NULL, 0 );

	Com_Printf( ""----- Client Initialization Complete -----\n"" );
}
",C,"	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
","	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);
",,"@@ -3674,7 +3674,7 @@ void CL_InitRef( void ) {
 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
-	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH);
+	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_mp_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
@@ -4014,7 +4014,7 @@ void CL_Init( void ) {
 
 	cl_allowDownload = Cvar_Get( ""cl_allowDownload"", ""1"", CVAR_ARCHIVE );
 #ifdef USE_CURL_DLOPEN
-	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);
+	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
 #endif
 
 	// init autoswitch so the ui will have it correctly even",OpenJK,b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,1efb19a25feace6de9b103fa3fe334fa1901b495,1,"void CL_Init( void ) {
	Com_Printf( ""----- Client Initialization -----\n"" );

	Con_Init();

	if(!com_fullyInitialized)
	{
		CL_ClearState();
		clc.state = CA_DISCONNECTED;	// no longer CA_UNINITIALIZED
		cl_oldGameSet = qfalse;
	}

	cls.realtime = 0;

	CL_InitInput();

	//
	// register our variables
	//
	cl_noprint = Cvar_Get( ""cl_noprint"", ""0"", 0 );
#ifdef UPDATE_SERVER_NAME
	cl_motd = Cvar_Get( ""cl_motd"", ""1"", 0 );
#endif
	cl_autoupdate = Cvar_Get( ""cl_autoupdate"", ""0"", CVAR_ARCHIVE );

	cl_timeout = Cvar_Get( ""cl_timeout"", ""200"", 0 );

	cl_wavefilerecord = Cvar_Get( ""cl_wavefilerecord"", ""0"", CVAR_TEMP );

	cl_timeNudge = Cvar_Get( ""cl_timeNudge"", ""0"", CVAR_TEMP );
	cl_shownet = Cvar_Get( ""cl_shownet"", ""0"", CVAR_TEMP );
	cl_shownuments = Cvar_Get( ""cl_shownuments"", ""0"", CVAR_TEMP );
	cl_visibleClients = Cvar_Get( ""cl_visibleClients"", ""0"", CVAR_TEMP );
	cl_showServerCommands = Cvar_Get( ""cl_showServerCommands"", ""0"", 0 );
	cl_showSend = Cvar_Get( ""cl_showSend"", ""0"", CVAR_TEMP );
	cl_showTimeDelta = Cvar_Get( ""cl_showTimeDelta"", ""0"", CVAR_TEMP );
	cl_freezeDemo = Cvar_Get( ""cl_freezeDemo"", ""0"", CVAR_TEMP );
	rcon_client_password = Cvar_Get( ""rconPassword"", """", CVAR_TEMP );
	cl_activeAction = Cvar_Get( ""activeAction"", """", CVAR_TEMP );

	cl_timedemo = Cvar_Get( ""timedemo"", ""0"", 0 );
	cl_timedemoLog = Cvar_Get (""cl_timedemoLog"", """", CVAR_ARCHIVE);
	cl_autoRecordDemo = Cvar_Get (""cl_autoRecordDemo"", ""0"", CVAR_ARCHIVE);
	cl_aviFrameRate = Cvar_Get (""cl_aviFrameRate"", ""25"", CVAR_ARCHIVE);
	cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE);
	cl_avidemo = Cvar_Get( ""cl_avidemo"", ""0"", 0 );
	cl_forceavidemo = Cvar_Get( ""cl_forceavidemo"", ""0"", 0 );

	rconAddress = Cvar_Get( ""rconAddress"", """", 0 );

	cl_yawspeed = Cvar_Get( ""cl_yawspeed"", ""140"", CVAR_ARCHIVE );
	cl_pitchspeed = Cvar_Get( ""cl_pitchspeed"", ""140"", CVAR_ARCHIVE );
	cl_anglespeedkey = Cvar_Get( ""cl_anglespeedkey"", ""1.5"", 0 );

	cl_maxpackets = Cvar_Get( ""cl_maxpackets"", ""38"", CVAR_ARCHIVE );
	cl_packetdup = Cvar_Get( ""cl_packetdup"", ""1"", CVAR_ARCHIVE );

	cl_showPing = Cvar_Get( ""cl_showPing"", ""0"", CVAR_ARCHIVE );

	cl_run = Cvar_Get( ""cl_run"", ""1"", CVAR_ARCHIVE );
	cl_sensitivity = Cvar_Get( ""sensitivity"", ""5"", CVAR_ARCHIVE );
	cl_mouseAccel = Cvar_Get( ""cl_mouseAccel"", ""0"", CVAR_ARCHIVE );
	cl_freelook = Cvar_Get( ""cl_freelook"", ""1"", CVAR_ARCHIVE );

	// 0: legacy mouse acceleration
	// 1: new implementation
	cl_mouseAccelStyle = Cvar_Get( ""cl_mouseAccelStyle"", ""0"", CVAR_ARCHIVE );
	// offset for the power function (for style 1, ignored otherwise)
	// this should be set to the max rate value
	cl_mouseAccelOffset = Cvar_Get( ""cl_mouseAccelOffset"", ""5"", CVAR_ARCHIVE );
	Cvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);

	cl_showMouseRate = Cvar_Get( ""cl_showmouserate"", ""0"", 0 );
 
 	cl_allowDownload = Cvar_Get( ""cl_allowDownload"", ""1"", CVAR_ARCHIVE );
 #ifdef USE_CURL_DLOPEN
//flaw_line_below:
	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);
//fix_flaw_line_below:
//	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
 #endif
 
 	// init autoswitch so the ui will have it correctly even
	// if the cgame hasn't been started
	// -NERVE - SMF - disabled autoswitch by default
	Cvar_Get( ""cg_autoswitch"", ""0"", CVAR_ARCHIVE );

	// Rafael - particle switch
	Cvar_Get( ""cg_wolfparticles"", ""1"", CVAR_ARCHIVE );
	// done

	cl_conXOffset = Cvar_Get( ""cl_conXOffset"", ""0"", 0 );
	cl_inGameVideo = Cvar_Get( ""r_inGameVideo"", ""1"", CVAR_ARCHIVE );

	cl_serverStatusResendTime = Cvar_Get( ""cl_serverStatusResendTime"", ""750"", 0 );

	// RF
	cl_recoilPitch = Cvar_Get( ""cg_recoilPitch"", ""0"", CVAR_ROM );

	cl_bypassMouseInput = Cvar_Get( ""cl_bypassMouseInput"", ""0"", 0 ); //CVAR_ROM );			// NERVE - SMF

	m_pitch = Cvar_Get( ""m_pitch"", ""0.022"", CVAR_ARCHIVE );
	m_yaw = Cvar_Get( ""m_yaw"", ""0.022"", CVAR_ARCHIVE );
	m_forward = Cvar_Get( ""m_forward"", ""0.25"", CVAR_ARCHIVE );
	m_side = Cvar_Get( ""m_side"", ""0.25"", CVAR_ARCHIVE );
	m_filter = Cvar_Get( ""m_filter"", ""0"", CVAR_ARCHIVE );

	j_pitch =        Cvar_Get (""j_pitch"",        ""0.022"", CVAR_ARCHIVE);
	j_yaw =          Cvar_Get (""j_yaw"",          ""-0.022"", CVAR_ARCHIVE);
	j_forward =      Cvar_Get (""j_forward"",      ""-0.25"", CVAR_ARCHIVE);
	j_side =         Cvar_Get (""j_side"",         ""0.25"", CVAR_ARCHIVE);
	j_up =           Cvar_Get (""j_up"",           ""0"", CVAR_ARCHIVE);

	j_pitch_axis =   Cvar_Get (""j_pitch_axis"",   ""3"", CVAR_ARCHIVE);
	j_yaw_axis =     Cvar_Get (""j_yaw_axis"",     ""2"", CVAR_ARCHIVE);
	j_forward_axis = Cvar_Get (""j_forward_axis"", ""1"", CVAR_ARCHIVE);
	j_side_axis =    Cvar_Get (""j_side_axis"",    ""0"", CVAR_ARCHIVE);
	j_up_axis =      Cvar_Get (""j_up_axis"",      ""4"", CVAR_ARCHIVE);

	Cvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);

	cl_motdString = Cvar_Get( ""cl_motdString"", """", CVAR_ROM );

	Cvar_Get( ""cl_maxPing"", ""800"", CVAR_ARCHIVE );

	cl_lanForcePackets = Cvar_Get (""cl_lanForcePackets"", ""1"", CVAR_ARCHIVE);

	cl_guid = Cvar_Get( ""cl_guid"", ""unknown"", CVAR_USERINFO | CVAR_ROM );

	cl_guidServerUniq = Cvar_Get (""cl_guidServerUniq"", ""1"", CVAR_ARCHIVE);

	// ~ and `, as keys and characters
	cl_consoleKeys = Cvar_Get( ""cl_consoleKeys"", ""~ ` 0x7e 0x60"", CVAR_ARCHIVE);

	// NERVE - SMF
	Cvar_Get( ""cg_drawCompass"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_drawNotifyText"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_quickMessageAlt"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_popupLimboMenu"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_descriptiveText"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_drawTeamOverlay"", ""2"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_uselessNostalgia"", ""0"", CVAR_ARCHIVE ); // JPW NERVE
	Cvar_Get( ""cg_drawGun"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_cursorHints"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_voiceSpriteTime"", ""6000"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_teamChatsOnly"", ""0"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_noVoiceChats"", ""0"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_noVoiceText"", ""0"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_crosshairSize"", ""48"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_drawCrosshair"", ""1"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_zoomDefaultSniper"", ""20"", CVAR_ARCHIVE );
	Cvar_Get( ""cg_zoomstepsniper"", ""2"", CVAR_ARCHIVE );

	Cvar_Get( ""mp_playerType"", ""0"", 0 );
	Cvar_Get( ""mp_currentPlayerType"", ""0"", 0 );
	Cvar_Get( ""mp_weapon"", ""0"", 0 );
	Cvar_Get( ""mp_team"", ""0"", 0 );
	Cvar_Get( ""mp_currentTeam"", ""0"", 0 );
	// -NERVE - SMF

	// userinfo
	Cvar_Get( ""name"", ""WolfPlayer"", CVAR_USERINFO | CVAR_ARCHIVE );
	cl_rate = Cvar_Get( ""rate"", ""25000"", CVAR_USERINFO | CVAR_ARCHIVE );     // NERVE - SMF - changed from 3000
	Cvar_Get( ""snaps"", ""20"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""model"", ""multi"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""head"", ""default"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""color"", ""4"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""handicap"", ""100"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""sex"", ""male"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""cl_anonymous"", ""0"", CVAR_USERINFO | CVAR_ARCHIVE );

	Cvar_Get( ""password"", """", CVAR_USERINFO );
	Cvar_Get( ""cg_predictItems"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE );

#ifdef USE_MUMBLE
	cl_useMumble = Cvar_Get (""cl_useMumble"", ""0"", CVAR_ARCHIVE | CVAR_LATCH);
	cl_mumbleScale = Cvar_Get (""cl_mumbleScale"", ""0.0254"", CVAR_ARCHIVE);
#endif

#ifdef USE_VOIP
	cl_voipSend = Cvar_Get (""cl_voipSend"", ""0"", 0);
	cl_voipSendTarget = Cvar_Get (""cl_voipSendTarget"", ""spatial"", 0);
	cl_voipGainDuringCapture = Cvar_Get (""cl_voipGainDuringCapture"", ""0.2"", CVAR_ARCHIVE);
	cl_voipCaptureMult = Cvar_Get (""cl_voipCaptureMult"", ""2.0"", CVAR_ARCHIVE);
	cl_voipUseVAD = Cvar_Get (""cl_voipUseVAD"", ""0"", CVAR_ARCHIVE);
	cl_voipVADThreshold = Cvar_Get (""cl_voipVADThreshold"", ""0.25"", CVAR_ARCHIVE);
	cl_voipShowMeter = Cvar_Get (""cl_voipShowMeter"", ""1"", CVAR_ARCHIVE);

	cl_voip = Cvar_Get (""cl_voip"", ""1"", CVAR_ARCHIVE);
	Cvar_CheckRange( cl_voip, 0, 1, qtrue );
	cl_voipProtocol = Cvar_Get (""cl_voipProtocol"", cl_voip->integer ? ""opus"" : """", CVAR_USERINFO | CVAR_ROM);
#endif

//----(SA) added
	Cvar_Get( ""cg_autoactivate"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE );
//----(SA) end

	// cgame might not be initialized before menu is used
	Cvar_Get( ""cg_viewsize"", ""100"", CVAR_ARCHIVE );
	// Make sure cg_stereoSeparation is zero as that variable is deprecated and should not be used anymore.
	Cvar_Get (""cg_stereoSeparation"", ""0"", CVAR_ROM);

	Cvar_Get( ""cg_autoReload"", ""1"", CVAR_ARCHIVE | CVAR_USERINFO );

	cl_missionStats = Cvar_Get( ""g_missionStats"", ""0"", CVAR_ROM );
	cl_waitForFire = Cvar_Get( ""cl_waitForFire"", ""0"", CVAR_ROM );

	// NERVE - SMF - localization
	cl_language = Cvar_Get( ""cl_language"", ""0"", CVAR_ARCHIVE );
	cl_debugTranslation = Cvar_Get( ""cl_debugTranslation"", ""0"", 0 );
	// -NERVE - SMF

	// DHM - Nerve :: Auto-update
	cl_updateavailable = Cvar_Get( ""cl_updateavailable"", ""0"", CVAR_ROM );
	cl_updatefiles = Cvar_Get( ""cl_updatefiles"", """", CVAR_ROM );

	Q_strncpyz( cls.autoupdateServerNames[0], AUTOUPDATE_SERVER1_NAME, MAX_QPATH );
	Q_strncpyz( cls.autoupdateServerNames[1], AUTOUPDATE_SERVER2_NAME, MAX_QPATH );
	Q_strncpyz( cls.autoupdateServerNames[2], AUTOUPDATE_SERVER3_NAME, MAX_QPATH );
	Q_strncpyz( cls.autoupdateServerNames[3], AUTOUPDATE_SERVER4_NAME, MAX_QPATH );
	Q_strncpyz( cls.autoupdateServerNames[4], AUTOUPDATE_SERVER5_NAME, MAX_QPATH );
	// DHM - Nerve

	//
	// register our commands
	//
	Cmd_AddCommand( ""cmd"", CL_ForwardToServer_f );
	Cmd_AddCommand( ""configstrings"", CL_Configstrings_f );
	Cmd_AddCommand( ""clientinfo"", CL_Clientinfo_f );
	Cmd_AddCommand( ""snd_restart"", CL_Snd_Restart_f );
	Cmd_AddCommand( ""vid_restart"", CL_Vid_Restart_f );
	Cmd_AddCommand( ""ui_restart"", CL_UI_Restart_f );          // NERVE - SMF
	Cmd_AddCommand( ""disconnect"", CL_Disconnect_f );
	Cmd_AddCommand( ""record"", CL_Record_f );
	Cmd_AddCommand( ""demo"", CL_PlayDemo_f );
	Cmd_SetCommandCompletionFunc( ""demo"", CL_CompleteDemoName );
	Cmd_AddCommand( ""cinematic"", CL_PlayCinematic_f );
	Cmd_AddCommand( ""stoprecord"", CL_StopRecord_f );
	Cmd_AddCommand( ""connect"", CL_Connect_f );
	Cmd_AddCommand( ""reconnect"", CL_Reconnect_f );
	Cmd_AddCommand( ""localservers"", CL_LocalServers_f );
	Cmd_AddCommand( ""globalservers"", CL_GlobalServers_f );
	Cmd_AddCommand( ""rcon"", CL_Rcon_f );
	Cmd_SetCommandCompletionFunc( ""rcon"", CL_CompleteRcon );
	Cmd_AddCommand( ""ping"", CL_Ping_f );
	Cmd_AddCommand( ""serverstatus"", CL_ServerStatus_f );
	Cmd_AddCommand( ""showip"", CL_ShowIP_f );
	Cmd_AddCommand( ""fs_openedList"", CL_OpenedPK3List_f );
	Cmd_AddCommand( ""fs_referencedList"", CL_ReferencedPK3List_f );
	Cmd_AddCommand (""video"", CL_Video_f );
	Cmd_AddCommand (""stopvideo"", CL_StopVideo_f );

	// Ridah, startup-caching system
	Cmd_AddCommand( ""cache_startgather"", CL_Cache_StartGather_f );
	Cmd_AddCommand( ""cache_usedfile"", CL_Cache_UsedFile_f );
	Cmd_AddCommand( ""cache_setindex"", CL_Cache_SetIndex_f );
	Cmd_AddCommand( ""cache_mapchange"", CL_Cache_MapChange_f );
	Cmd_AddCommand( ""cache_endgather"", CL_Cache_EndGather_f );

	Cmd_AddCommand( ""updatehunkusage"", CL_UpdateLevelHunkUsage );
	Cmd_AddCommand( ""updatescreen"", SCR_UpdateScreen );
	// done.
	Cmd_AddCommand( ""SaveTranslations"", CL_SaveTranslations_f );     // NERVE - SMF - localization
	Cmd_AddCommand( ""SaveNewTranslations"", CL_SaveNewTranslations_f );   // NERVE - SMF - localization
	Cmd_AddCommand( ""LoadTranslations"", CL_LoadTranslations_f );     // NERVE - SMF - localization
	// NERVE - SMF - don't do this in multiplayer
	// RF, add this command so clients can't bind a key to send client damage commands to the server
//	Cmd_AddCommand( ""cld"", CL_ClientDamageCommand );

	Cmd_AddCommand( ""startSingleplayer"", CL_startSingleplayer_f );      // NERVE - SMF

	Cmd_AddCommand( ""setRecommended"", CL_SetRecommended_f );

	CL_InitRef();

	SCR_Init();

//	Cbuf_Execute();

	Cvar_Set( ""cl_running"", ""1"" );

	// DHM - Nerve
	autoupdateChecked = qfalse;
	autoupdateStarted = qfalse;

	CL_InitTranslation();   // NERVE - SMF - localization

	CL_GenerateQKey();
	CL_UpdateGUID( NULL, 0 );

	Com_Printf( ""----- Client Initialization Complete -----\n"" );
}
"
5518,183254,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,1,https://github.com/iortcw/iortcw/commit/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,"All: Don't load .pk3s as .dlls, and don't load user config files from .pk3s",1,MP/code/client/cl_main.c,"{""sha"": ""92675c53d7d8d4e2072a5423e471fb48daeec2c6"", ""filename"": ""MP/code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/client/cl_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/client/cl_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -3674,7 +3674,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_mp_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -4014,7 +4014,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get( \""cl_allowDownload\"", \""1\"", CVAR_ARCHIVE );\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \t// init autoswitch so the ui will have it correctly even""}<_**next**_>{""sha"": ""c262e6b62003d9fa427776ce44bfa958569ecd18"", ""filename"": ""MP/code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/qcommon/files.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/qcommon/files.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -1424,12 +1424,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and wolfconfig_mp.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t        len = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \t        \n \t        if(file == NULL)""}<_**next**_>{""sha"": ""f3dc2e91909d7f1f90227e2ba68dfa2e61a40485"", ""filename"": ""MP/code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/sys/sys_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -499,6 +499,13 @@ from executable path, then fs_basepath.\n void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n+\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);""}<_**next**_>{""sha"": ""18c16aa973bb821e6972cf1da0c98c3007ddbfd6"", ""filename"": ""SP/code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/client/cl_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/client/cl_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -3348,7 +3348,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_sp_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -3690,7 +3690,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get( \""cl_allowDownload\"", \""0\"", CVAR_ARCHIVE );\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \t// init autoswitch so the ui will have it correctly even""}<_**next**_>{""sha"": ""15910bd5e96fec07e0fb331beba36879ea237545"", ""filename"": ""SP/code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/qcommon/files.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/qcommon/files.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -1591,12 +1591,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and wolfconfig.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t\tlen = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \n \t\tif(file == NULL)""}<_**next**_>{""sha"": ""e591d9890c74ee974af303dae0be35f1236d5473"", ""filename"": ""SP/code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/sys/sys_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -499,6 +499,13 @@ from executable path, then fs_basepath.\n void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n+\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);""}","void CL_InitRef( void ) {
	refimport_t ri;
	refexport_t *ret;
#ifdef USE_RENDERER_DLOPEN
	GetRefAPI_t		GetRefAPI;
	char			dllName[MAX_OSPATH];
#endif

 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_mp_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
	if(!(rendererLib = Sys_LoadDll(dllName, qfalse)) && strcmp(cl_renderer->string, cl_renderer->resetString))
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Cvar_ForceReset(""cl_renderer"");

		Com_sprintf(dllName, sizeof(dllName), ""renderer_mp_opengl1_"" ARCH_STRING DLL_EXT);
		rendererLib = Sys_LoadDll(dllName, qfalse);
	}

	if(!rendererLib)
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Com_Error(ERR_FATAL, ""Failed to load renderer"");
	}

	GetRefAPI = Sys_LoadFunction(rendererLib, ""GetRefAPI"");
	if(!GetRefAPI)
	{
		Com_Error(ERR_FATAL, ""Can't load symbol GetRefAPI: '%s'"",  Sys_LibraryError());
	}
#endif

	ri.Cmd_AddCommand = Cmd_AddCommand;
	ri.Cmd_RemoveCommand = Cmd_RemoveCommand;
	ri.Cmd_Argc = Cmd_Argc;
	ri.Cmd_Argv = Cmd_Argv;
	ri.Cmd_ExecuteText = Cbuf_ExecuteText;
	ri.Printf = CL_RefPrintf;
	ri.Error = Com_Error;
	ri.Milliseconds = CL_ScaledMilliseconds;
#ifdef ZONE_DEBUG
	ri.Z_MallocDebug = CL_RefMallocDebug;
#else
	ri.Z_Malloc = CL_RefMalloc;
#endif
	ri.Free = Z_Free;
	ri.Tag_Free = CL_RefTagFree;
	ri.Hunk_Clear = Hunk_ClearToMark;
#ifdef HUNK_DEBUG
	ri.Hunk_AllocDebug = Hunk_AllocDebug;
#else
	ri.Hunk_Alloc = Hunk_Alloc;
#endif
	ri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory;
	ri.Hunk_FreeTempMemory = Hunk_FreeTempMemory;

	ri.CM_ClusterPVS = CM_ClusterPVS;
	ri.CM_DrawDebugSurface = CM_DrawDebugSurface;
	ri.FS_ReadFile = FS_ReadFile;
	ri.FS_FreeFile = FS_FreeFile;
	ri.FS_WriteFile = FS_WriteFile;
	ri.FS_FreeFileList = FS_FreeFileList;
	ri.FS_ListFiles = FS_ListFiles;
	ri.FS_FileIsInPAK = FS_FileIsInPAK;
	ri.FS_FileExists = FS_FileExists;
	ri.Cvar_Get = Cvar_Get;
	ri.Cvar_Set = Cvar_Set;
	ri.Cvar_SetValue = Cvar_SetValue;
	ri.Cvar_CheckRange = Cvar_CheckRange;
	ri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue;


	ri.CIN_UploadCinematic = CIN_UploadCinematic;
	ri.CIN_PlayCinematic = CIN_PlayCinematic;
	ri.CIN_RunCinematic = CIN_RunCinematic;

	ri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame;

	ri.IN_Init = IN_Init;
	ri.IN_Shutdown = IN_Shutdown;
	ri.IN_Restart = IN_Restart;

	ri.ftol = Q_ftol;

	ri.Sys_SetEnv = Sys_SetEnv;
	ri.Sys_GLimpSafeInit = Sys_GLimpSafeInit;
	ri.Sys_GLimpInit = Sys_GLimpInit;
	ri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory;

	ret = GetRefAPI( REF_API_VERSION, &ri );

	if ( !ret ) {
		Com_Error( ERR_FATAL, ""Couldn't initialize refresh"" );
	}

	re = *ret;

	Com_Printf( ""---- Renderer Initialization Complete ----\n"" );

	Cvar_Set( ""cl_paused"", ""0"" );
}
","void CL_InitRef( void ) {
	refimport_t ri;
	refexport_t *ret;
#ifdef USE_RENDERER_DLOPEN
	GetRefAPI_t		GetRefAPI;
	char			dllName[MAX_OSPATH];
#endif

 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_mp_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
	if(!(rendererLib = Sys_LoadDll(dllName, qfalse)) && strcmp(cl_renderer->string, cl_renderer->resetString))
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Cvar_ForceReset(""cl_renderer"");

		Com_sprintf(dllName, sizeof(dllName), ""renderer_mp_opengl1_"" ARCH_STRING DLL_EXT);
		rendererLib = Sys_LoadDll(dllName, qfalse);
	}

	if(!rendererLib)
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Com_Error(ERR_FATAL, ""Failed to load renderer"");
	}

	GetRefAPI = Sys_LoadFunction(rendererLib, ""GetRefAPI"");
	if(!GetRefAPI)
	{
		Com_Error(ERR_FATAL, ""Can't load symbol GetRefAPI: '%s'"",  Sys_LibraryError());
	}
#endif

	ri.Cmd_AddCommand = Cmd_AddCommand;
	ri.Cmd_RemoveCommand = Cmd_RemoveCommand;
	ri.Cmd_Argc = Cmd_Argc;
	ri.Cmd_Argv = Cmd_Argv;
	ri.Cmd_ExecuteText = Cbuf_ExecuteText;
	ri.Printf = CL_RefPrintf;
	ri.Error = Com_Error;
	ri.Milliseconds = CL_ScaledMilliseconds;
#ifdef ZONE_DEBUG
	ri.Z_MallocDebug = CL_RefMallocDebug;
#else
	ri.Z_Malloc = CL_RefMalloc;
#endif
	ri.Free = Z_Free;
	ri.Tag_Free = CL_RefTagFree;
	ri.Hunk_Clear = Hunk_ClearToMark;
#ifdef HUNK_DEBUG
	ri.Hunk_AllocDebug = Hunk_AllocDebug;
#else
	ri.Hunk_Alloc = Hunk_Alloc;
#endif
	ri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory;
	ri.Hunk_FreeTempMemory = Hunk_FreeTempMemory;

	ri.CM_ClusterPVS = CM_ClusterPVS;
	ri.CM_DrawDebugSurface = CM_DrawDebugSurface;
	ri.FS_ReadFile = FS_ReadFile;
	ri.FS_FreeFile = FS_FreeFile;
	ri.FS_WriteFile = FS_WriteFile;
	ri.FS_FreeFileList = FS_FreeFileList;
	ri.FS_ListFiles = FS_ListFiles;
	ri.FS_FileIsInPAK = FS_FileIsInPAK;
	ri.FS_FileExists = FS_FileExists;
	ri.Cvar_Get = Cvar_Get;
	ri.Cvar_Set = Cvar_Set;
	ri.Cvar_SetValue = Cvar_SetValue;
	ri.Cvar_CheckRange = Cvar_CheckRange;
	ri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue;


	ri.CIN_UploadCinematic = CIN_UploadCinematic;
	ri.CIN_PlayCinematic = CIN_PlayCinematic;
	ri.CIN_RunCinematic = CIN_RunCinematic;

	ri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame;

	ri.IN_Init = IN_Init;
	ri.IN_Shutdown = IN_Shutdown;
	ri.IN_Restart = IN_Restart;

	ri.ftol = Q_ftol;

	ri.Sys_SetEnv = Sys_SetEnv;
	ri.Sys_GLimpSafeInit = Sys_GLimpSafeInit;
	ri.Sys_GLimpInit = Sys_GLimpInit;
	ri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory;

	ret = GetRefAPI( REF_API_VERSION, &ri );

	if ( !ret ) {
		Com_Error( ERR_FATAL, ""Couldn't initialize refresh"" );
	}

	re = *ret;

	Com_Printf( ""---- Renderer Initialization Complete ----\n"" );

	Cvar_Set( ""cl_paused"", ""0"" );
}
",C,"	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
","	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH);
",,"@@ -3674,7 +3674,7 @@ void CL_InitRef( void ) {
 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
-	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH);
+	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_mp_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
@@ -4014,7 +4014,7 @@ void CL_Init( void ) {
 
 	cl_allowDownload = Cvar_Get( ""cl_allowDownload"", ""1"", CVAR_ARCHIVE );
 #ifdef USE_CURL_DLOPEN
-	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);
+	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
 #endif
 
 	// init autoswitch so the ui will have it correctly even",OpenJK,b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,1efb19a25feace6de9b103fa3fe334fa1901b495,1,"void CL_InitRef( void ) {
	refimport_t ri;
	refexport_t *ret;
#ifdef USE_RENDERER_DLOPEN
	GetRefAPI_t		GetRefAPI;
	char			dllName[MAX_OSPATH];
#endif

 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
//flaw_line_below:
	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH);
//fix_flaw_line_below:
//	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_mp_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
	if(!(rendererLib = Sys_LoadDll(dllName, qfalse)) && strcmp(cl_renderer->string, cl_renderer->resetString))
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Cvar_ForceReset(""cl_renderer"");

		Com_sprintf(dllName, sizeof(dllName), ""renderer_mp_opengl1_"" ARCH_STRING DLL_EXT);
		rendererLib = Sys_LoadDll(dllName, qfalse);
	}

	if(!rendererLib)
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Com_Error(ERR_FATAL, ""Failed to load renderer"");
	}

	GetRefAPI = Sys_LoadFunction(rendererLib, ""GetRefAPI"");
	if(!GetRefAPI)
	{
		Com_Error(ERR_FATAL, ""Can't load symbol GetRefAPI: '%s'"",  Sys_LibraryError());
	}
#endif

	ri.Cmd_AddCommand = Cmd_AddCommand;
	ri.Cmd_RemoveCommand = Cmd_RemoveCommand;
	ri.Cmd_Argc = Cmd_Argc;
	ri.Cmd_Argv = Cmd_Argv;
	ri.Cmd_ExecuteText = Cbuf_ExecuteText;
	ri.Printf = CL_RefPrintf;
	ri.Error = Com_Error;
	ri.Milliseconds = CL_ScaledMilliseconds;
#ifdef ZONE_DEBUG
	ri.Z_MallocDebug = CL_RefMallocDebug;
#else
	ri.Z_Malloc = CL_RefMalloc;
#endif
	ri.Free = Z_Free;
	ri.Tag_Free = CL_RefTagFree;
	ri.Hunk_Clear = Hunk_ClearToMark;
#ifdef HUNK_DEBUG
	ri.Hunk_AllocDebug = Hunk_AllocDebug;
#else
	ri.Hunk_Alloc = Hunk_Alloc;
#endif
	ri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory;
	ri.Hunk_FreeTempMemory = Hunk_FreeTempMemory;

	ri.CM_ClusterPVS = CM_ClusterPVS;
	ri.CM_DrawDebugSurface = CM_DrawDebugSurface;
	ri.FS_ReadFile = FS_ReadFile;
	ri.FS_FreeFile = FS_FreeFile;
	ri.FS_WriteFile = FS_WriteFile;
	ri.FS_FreeFileList = FS_FreeFileList;
	ri.FS_ListFiles = FS_ListFiles;
	ri.FS_FileIsInPAK = FS_FileIsInPAK;
	ri.FS_FileExists = FS_FileExists;
	ri.Cvar_Get = Cvar_Get;
	ri.Cvar_Set = Cvar_Set;
	ri.Cvar_SetValue = Cvar_SetValue;
	ri.Cvar_CheckRange = Cvar_CheckRange;
	ri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue;

	// cinematic stuff

	ri.CIN_UploadCinematic = CIN_UploadCinematic;
	ri.CIN_PlayCinematic = CIN_PlayCinematic;
	ri.CIN_RunCinematic = CIN_RunCinematic;

	ri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame;

	ri.IN_Init = IN_Init;
	ri.IN_Shutdown = IN_Shutdown;
	ri.IN_Restart = IN_Restart;

	ri.ftol = Q_ftol;

	ri.Sys_SetEnv = Sys_SetEnv;
	ri.Sys_GLimpSafeInit = Sys_GLimpSafeInit;
	ri.Sys_GLimpInit = Sys_GLimpInit;
	ri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory;

	ret = GetRefAPI( REF_API_VERSION, &ri );

	if ( !ret ) {
		Com_Error( ERR_FATAL, ""Couldn't initialize refresh"" );
	}

	re = *ret;

	Com_Printf( ""---- Renderer Initialization Complete ----\n"" );

	// unpause so the cgame definately gets a snapshot and renders a frame
	Cvar_Set( ""cl_paused"", ""0"" );
}
"
5519,183255,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,6,https://github.com/iortcw/iortcw/commit/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,"All: Don't load .pk3s as .dlls, and don't load user config files from .pk3s",0,MP/code/qcommon/files.c,"{""sha"": ""92675c53d7d8d4e2072a5423e471fb48daeec2c6"", ""filename"": ""MP/code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/client/cl_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/client/cl_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -3674,7 +3674,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_mp_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -4014,7 +4014,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get( \""cl_allowDownload\"", \""1\"", CVAR_ARCHIVE );\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \t// init autoswitch so the ui will have it correctly even""}<_**next**_>{""sha"": ""c262e6b62003d9fa427776ce44bfa958569ecd18"", ""filename"": ""MP/code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/qcommon/files.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/qcommon/files.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -1424,12 +1424,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and wolfconfig_mp.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t        len = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \t        \n \t        if(file == NULL)""}<_**next**_>{""sha"": ""f3dc2e91909d7f1f90227e2ba68dfa2e61a40485"", ""filename"": ""MP/code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/sys/sys_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -499,6 +499,13 @@ from executable path, then fs_basepath.\n void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n+\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);""}<_**next**_>{""sha"": ""18c16aa973bb821e6972cf1da0c98c3007ddbfd6"", ""filename"": ""SP/code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/client/cl_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/client/cl_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -3348,7 +3348,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_sp_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -3690,7 +3690,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get( \""cl_allowDownload\"", \""0\"", CVAR_ARCHIVE );\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \t// init autoswitch so the ui will have it correctly even""}<_**next**_>{""sha"": ""15910bd5e96fec07e0fb331beba36879ea237545"", ""filename"": ""SP/code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/qcommon/files.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/qcommon/files.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -1591,12 +1591,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and wolfconfig.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t\tlen = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \n \t\tif(file == NULL)""}<_**next**_>{""sha"": ""e591d9890c74ee974af303dae0be35f1236d5473"", ""filename"": ""SP/code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/sys/sys_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -499,6 +499,13 @@ from executable path, then fs_basepath.\n void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n+\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);""}","long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueFILE)
 {
 	searchpath_t *search;
 	long len;
	qboolean isLocalConfig;
 
 	if(!fs_searchpaths)
 		Com_Error(ERR_FATAL, ""Filesystem call made without initialization"");
 
	isLocalConfig = !strcmp(filename, ""autoexec.cfg"") || !strcmp(filename, Q3CONFIG_CFG);
 	for(search = fs_searchpaths; search; search = search->next)
 	{
		// autoexec.cfg and wolfconfig_mp.cfg can only be loaded outside of pk3 files.
		if (isLocalConfig && search->pack)
			continue;

 	        len = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);
 	        
 	        if(file == NULL)
	        {
	                if(len > 0)
	                        return len;
	        }
	        else
	        {
	                if(len >= 0 && *file)
	                        return len;
	        }
	        
	}
	
#ifdef FS_MISSING
	if(missingFiles)
		fprintf(missingFiles, ""%s\n"", filename);
#endif

	if(file)
	{
		*file = 0;
		return -1;
	}
	else
	{
		return 0;
	}
}
","long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueFILE)
 {
 	searchpath_t *search;
 	long len;
 
 	if(!fs_searchpaths)
 		Com_Error(ERR_FATAL, ""Filesystem call made without initialization"");
 
 	for(search = fs_searchpaths; search; search = search->next)
 	{
 	        len = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);
 	        
 	        if(file == NULL)
	        {
	                if(len > 0)
	                        return len;
	        }
	        else
	        {
	                if(len >= 0 && *file)
	                        return len;
	        }
	        
	}
	
#ifdef FS_MISSING
	if(missingFiles)
		fprintf(missingFiles, ""%s\n"", filename);
#endif

	if(file)
	{
		*file = 0;
		return -1;
	}
	else
	{
		return 0;
	}
}
",C,"	qboolean isLocalConfig;
	isLocalConfig = !strcmp(filename, ""autoexec.cfg"") || !strcmp(filename, Q3CONFIG_CFG);
		// autoexec.cfg and wolfconfig_mp.cfg can only be loaded outside of pk3 files.
		if (isLocalConfig && search->pack)
			continue;

",,,"@@ -1424,12 +1424,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF
 {
 	searchpath_t *search;
 	long len;
+	qboolean isLocalConfig;
 
 	if(!fs_searchpaths)
 		Com_Error(ERR_FATAL, ""Filesystem call made without initialization"");
 
+	isLocalConfig = !strcmp(filename, ""autoexec.cfg"") || !strcmp(filename, Q3CONFIG_CFG);
 	for(search = fs_searchpaths; search; search = search->next)
 	{
+		// autoexec.cfg and wolfconfig_mp.cfg can only be loaded outside of pk3 files.
+		if (isLocalConfig && search->pack)
+			continue;
+
 	        len = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);
 	        
 	        if(file == NULL)",OpenJK,b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,1efb19a25feace6de9b103fa3fe334fa1901b495,1,"long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueFILE)
 {
 	searchpath_t *search;
 	long len;
//fix_flaw_line_below:
//	qboolean isLocalConfig;
 
 	if(!fs_searchpaths)
 		Com_Error(ERR_FATAL, ""Filesystem call made without initialization"");
 
//fix_flaw_line_below:
//	isLocalConfig = !strcmp(filename, ""autoexec.cfg"") || !strcmp(filename, Q3CONFIG_CFG);
 	for(search = fs_searchpaths; search; search = search->next)
 	{
//fix_flaw_line_below:
//		// autoexec.cfg and wolfconfig_mp.cfg can only be loaded outside of pk3 files.
//fix_flaw_line_below:
//		if (isLocalConfig && search->pack)
//fix_flaw_line_below:
//			continue;
//fix_flaw_line_below:
//
 	        len = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);
 	        
 	        if(file == NULL)
	        {
	                if(len > 0)
	                        return len;
	        }
	        else
	        {
	                if(len >= 0 && *file)
	                        return len;
	        }
	        
	}
	
#ifdef FS_MISSING
	if(missingFiles)
		fprintf(missingFiles, ""%s\n"", filename);
#endif

	if(file)
	{
		*file = 0;
		return -1;
	}
	else
	{
		// When file is NULL, we're querying the existance of the file
		// If we've got here, it doesn't exist
		return 0;
	}
}
"
5520,183256,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,7,https://github.com/iortcw/iortcw/commit/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,"All: Don't load .pk3s as .dlls, and don't load user config files from .pk3s",0,MP/code/sys/sys_main.c,"{""sha"": ""92675c53d7d8d4e2072a5423e471fb48daeec2c6"", ""filename"": ""MP/code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/client/cl_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/client/cl_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -3674,7 +3674,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_mp_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -4014,7 +4014,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get( \""cl_allowDownload\"", \""1\"", CVAR_ARCHIVE );\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \t// init autoswitch so the ui will have it correctly even""}<_**next**_>{""sha"": ""c262e6b62003d9fa427776ce44bfa958569ecd18"", ""filename"": ""MP/code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/qcommon/files.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/qcommon/files.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -1424,12 +1424,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and wolfconfig_mp.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t        len = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \t        \n \t        if(file == NULL)""}<_**next**_>{""sha"": ""f3dc2e91909d7f1f90227e2ba68dfa2e61a40485"", ""filename"": ""MP/code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/sys/sys_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -499,6 +499,13 @@ from executable path, then fs_basepath.\n void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n+\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);""}<_**next**_>{""sha"": ""18c16aa973bb821e6972cf1da0c98c3007ddbfd6"", ""filename"": ""SP/code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/client/cl_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/client/cl_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -3348,7 +3348,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_sp_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -3690,7 +3690,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get( \""cl_allowDownload\"", \""0\"", CVAR_ARCHIVE );\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \t// init autoswitch so the ui will have it correctly even""}<_**next**_>{""sha"": ""15910bd5e96fec07e0fb331beba36879ea237545"", ""filename"": ""SP/code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/qcommon/files.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/qcommon/files.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -1591,12 +1591,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and wolfconfig.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t\tlen = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \n \t\tif(file == NULL)""}<_**next**_>{""sha"": ""e591d9890c74ee974af303dae0be35f1236d5473"", ""filename"": ""SP/code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/sys/sys_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -499,6 +499,13 @@ from executable path, then fs_basepath.\n void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n+\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);""}"," void *Sys_LoadDll(const char *name, qboolean useSystemLib)
 {
 	void *dllhandle;

	// Don't load any DLLs that end with the pk3 extension
	if (COM_CompareExtension(name, "".pk3""))
	{
		Com_Printf(""Rejecting DLL named \""%s\"""", name);
		return NULL;
	}
 	
 	if(useSystemLib)
 		Com_Printf(""Trying to load \""%s\""...\n"", name);
	
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);

		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	
	return dllhandle;
}
"," void *Sys_LoadDll(const char *name, qboolean useSystemLib)
 {
 	void *dllhandle;
 	
 	if(useSystemLib)
 		Com_Printf(""Trying to load \""%s\""...\n"", name);
	
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);

		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	
	return dllhandle;
}
",C,"
	// Don't load any DLLs that end with the pk3 extension
	if (COM_CompareExtension(name, "".pk3""))
	{
		Com_Printf(""Rejecting DLL named \""%s\"""", name);
		return NULL;
	}
",,,"@@ -499,6 +499,13 @@ from executable path, then fs_basepath.
 void *Sys_LoadDll(const char *name, qboolean useSystemLib)
 {
 	void *dllhandle;
+
+	// Don't load any DLLs that end with the pk3 extension
+	if (COM_CompareExtension(name, "".pk3""))
+	{
+		Com_Printf(""Rejecting DLL named \""%s\"""", name);
+		return NULL;
+	}
 	
 	if(useSystemLib)
 		Com_Printf(""Trying to load \""%s\""...\n"", name);",OpenJK,b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,1efb19a25feace6de9b103fa3fe334fa1901b495,1," void *Sys_LoadDll(const char *name, qboolean useSystemLib)
 {
 	void *dllhandle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	// Don't load any DLLs that end with the pk3 extension
//fix_flaw_line_below:
//	if (COM_CompareExtension(name, "".pk3""))
//fix_flaw_line_below:
//	{
//fix_flaw_line_below:
//		Com_Printf(""Rejecting DLL named \""%s\"""", name);
//fix_flaw_line_below:
//		return NULL;
//fix_flaw_line_below:
//	}
 	
 	if(useSystemLib)
 		Com_Printf(""Trying to load \""%s\""...\n"", name);
	
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);

		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	
	return dllhandle;
}
"
5521,183257,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,1,https://github.com/iortcw/iortcw/commit/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,"All: Don't load .pk3s as .dlls, and don't load user config files from .pk3s",1,SP/code/client/cl_main.c,"{""sha"": ""92675c53d7d8d4e2072a5423e471fb48daeec2c6"", ""filename"": ""MP/code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/client/cl_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/client/cl_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -3674,7 +3674,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_mp_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -4014,7 +4014,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get( \""cl_allowDownload\"", \""1\"", CVAR_ARCHIVE );\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \t// init autoswitch so the ui will have it correctly even""}<_**next**_>{""sha"": ""c262e6b62003d9fa427776ce44bfa958569ecd18"", ""filename"": ""MP/code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/qcommon/files.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/qcommon/files.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -1424,12 +1424,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and wolfconfig_mp.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t        len = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \t        \n \t        if(file == NULL)""}<_**next**_>{""sha"": ""f3dc2e91909d7f1f90227e2ba68dfa2e61a40485"", ""filename"": ""MP/code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/sys/sys_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -499,6 +499,13 @@ from executable path, then fs_basepath.\n void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n+\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);""}<_**next**_>{""sha"": ""18c16aa973bb821e6972cf1da0c98c3007ddbfd6"", ""filename"": ""SP/code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/client/cl_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/client/cl_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -3348,7 +3348,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_sp_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -3690,7 +3690,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get( \""cl_allowDownload\"", \""0\"", CVAR_ARCHIVE );\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \t// init autoswitch so the ui will have it correctly even""}<_**next**_>{""sha"": ""15910bd5e96fec07e0fb331beba36879ea237545"", ""filename"": ""SP/code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/qcommon/files.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/qcommon/files.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -1591,12 +1591,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and wolfconfig.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t\tlen = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \n \t\tif(file == NULL)""}<_**next**_>{""sha"": ""e591d9890c74ee974af303dae0be35f1236d5473"", ""filename"": ""SP/code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/sys/sys_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -499,6 +499,13 @@ from executable path, then fs_basepath.\n void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n+\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);""}","void CL_Init( void ) {
	Com_Printf( ""----- Client Initialization -----\n"" );

	Con_Init();

	if(!com_fullyInitialized)
	{
		CL_ClearState();
		clc.state = CA_DISCONNECTED;	// no longer CA_UNINITIALIZED
		cl_oldGameSet = qfalse;
	}

	cls.realtime = 0;

	CL_InitInput();

	cl_noprint = Cvar_Get( ""cl_noprint"", ""0"", 0 );
#ifdef UPDATE_SERVER_NAME
	cl_motd = Cvar_Get( ""cl_motd"", ""1"", 0 );
#endif

	cl_timeout = Cvar_Get( ""cl_timeout"", ""200"", 0 );

	cl_timeNudge = Cvar_Get( ""cl_timeNudge"", ""0"", CVAR_TEMP );
	cl_shownet = Cvar_Get( ""cl_shownet"", ""0"", CVAR_TEMP );
	cl_showSend = Cvar_Get( ""cl_showSend"", ""0"", CVAR_TEMP );
	cl_showTimeDelta = Cvar_Get( ""cl_showTimeDelta"", ""0"", CVAR_TEMP );
	cl_freezeDemo = Cvar_Get( ""cl_freezeDemo"", ""0"", CVAR_TEMP );
	rcon_client_password = Cvar_Get( ""rconPassword"", """", CVAR_TEMP );
	cl_activeAction = Cvar_Get( ""activeAction"", """", CVAR_TEMP );

	cl_timedemo = Cvar_Get( ""timedemo"", ""0"", 0 );
	cl_timedemoLog = Cvar_Get (""cl_timedemoLog"", """", CVAR_ARCHIVE);
	cl_autoRecordDemo = Cvar_Get (""cl_autoRecordDemo"", ""0"", CVAR_ARCHIVE);
	cl_aviFrameRate = Cvar_Get (""cl_aviFrameRate"", ""25"", CVAR_ARCHIVE);
	cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE);
	cl_avidemo = Cvar_Get( ""cl_avidemo"", ""0"", 0 );
	cl_forceavidemo = Cvar_Get( ""cl_forceavidemo"", ""0"", 0 );

	rconAddress = Cvar_Get( ""rconAddress"", """", 0 );

	cl_yawspeed = Cvar_Get( ""cl_yawspeed"", ""140"", CVAR_ARCHIVE );
	cl_pitchspeed = Cvar_Get( ""cl_pitchspeed"", ""140"", CVAR_ARCHIVE );
	cl_anglespeedkey = Cvar_Get( ""cl_anglespeedkey"", ""1.5"", 0 );

	cl_maxpackets = Cvar_Get( ""cl_maxpackets"", ""38"", CVAR_ARCHIVE );
	cl_packetdup = Cvar_Get( ""cl_packetdup"", ""1"", CVAR_ARCHIVE );

	cl_run = Cvar_Get( ""cl_run"", ""1"", CVAR_ARCHIVE );
	cl_sensitivity = Cvar_Get( ""sensitivity"", ""5"", CVAR_ARCHIVE );
	cl_mouseAccel = Cvar_Get( ""cl_mouseAccel"", ""0"", CVAR_ARCHIVE );
	cl_freelook = Cvar_Get( ""cl_freelook"", ""1"", CVAR_ARCHIVE );

	cl_mouseAccelStyle = Cvar_Get( ""cl_mouseAccelStyle"", ""0"", CVAR_ARCHIVE );
	cl_mouseAccelOffset = Cvar_Get( ""cl_mouseAccelOffset"", ""5"", CVAR_ARCHIVE );
	Cvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);

	cl_showMouseRate = Cvar_Get( ""cl_showmouserate"", ""0"", 0 );
 
 	cl_allowDownload = Cvar_Get( ""cl_allowDownload"", ""0"", CVAR_ARCHIVE );
 #ifdef USE_CURL_DLOPEN
	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
 #endif
 
	Cvar_Get( ""cg_autoswitch"", ""2"", CVAR_ARCHIVE );

	Cvar_Get( ""cg_wolfparticles"", ""1"", CVAR_ARCHIVE );

	cl_conXOffset = Cvar_Get( ""cl_conXOffset"", ""0"", 0 );
	cl_inGameVideo = Cvar_Get( ""r_inGameVideo"", ""1"", CVAR_ARCHIVE );

	cl_serverStatusResendTime = Cvar_Get( ""cl_serverStatusResendTime"", ""750"", 0 );

	cl_recoilPitch = Cvar_Get( ""cg_recoilPitch"", ""0"", CVAR_ROM );

	m_pitch = Cvar_Get( ""m_pitch"", ""0.022"", CVAR_ARCHIVE );
	m_yaw = Cvar_Get( ""m_yaw"", ""0.022"", CVAR_ARCHIVE );
	m_forward = Cvar_Get( ""m_forward"", ""0.25"", CVAR_ARCHIVE );
	m_side = Cvar_Get( ""m_side"", ""0.25"", CVAR_ARCHIVE );
	m_filter = Cvar_Get( ""m_filter"", ""0"", CVAR_ARCHIVE );

	j_pitch =        Cvar_Get (""j_pitch"",        ""0.022"", CVAR_ARCHIVE);
	j_yaw =          Cvar_Get (""j_yaw"",          ""-0.022"", CVAR_ARCHIVE);
	j_forward =      Cvar_Get (""j_forward"",      ""-0.25"", CVAR_ARCHIVE);
	j_side =         Cvar_Get (""j_side"",         ""0.25"", CVAR_ARCHIVE);
	j_up =           Cvar_Get (""j_up"",           ""0"", CVAR_ARCHIVE);

	j_pitch_axis =   Cvar_Get (""j_pitch_axis"",   ""3"", CVAR_ARCHIVE);
	j_yaw_axis =     Cvar_Get (""j_yaw_axis"",     ""2"", CVAR_ARCHIVE);
	j_forward_axis = Cvar_Get (""j_forward_axis"", ""1"", CVAR_ARCHIVE);
	j_side_axis =    Cvar_Get (""j_side_axis"",    ""0"", CVAR_ARCHIVE);
	j_up_axis =      Cvar_Get (""j_up_axis"",      ""4"", CVAR_ARCHIVE);

	Cvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);

	cl_motdString = Cvar_Get( ""cl_motdString"", """", CVAR_ROM );

	Cvar_Get( ""cl_maxPing"", ""800"", CVAR_ARCHIVE );

	cl_lanForcePackets = Cvar_Get (""cl_lanForcePackets"", ""1"", CVAR_ARCHIVE);

	cl_guidServerUniq = Cvar_Get (""cl_guidServerUniq"", ""1"", CVAR_ARCHIVE);

	cl_consoleKeys = Cvar_Get( ""cl_consoleKeys"", ""~ ` 0x7e 0x60"", CVAR_ARCHIVE);

	Cvar_Get( ""name"", ""WolfPlayer"", CVAR_USERINFO | CVAR_ARCHIVE );
	cl_rate = Cvar_Get( ""rate"", ""25000"", CVAR_USERINFO | CVAR_ARCHIVE );     // NERVE - SMF - changed from 3000
	Cvar_Get( ""snaps"", ""20"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""model"", ""bj2"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""head"", ""default"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""color"", ""4"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""handicap"", ""100"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""sex"", ""male"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""cl_anonymous"", ""0"", CVAR_USERINFO | CVAR_ARCHIVE );

	Cvar_Get( ""password"", """", CVAR_USERINFO );
	Cvar_Get( ""cg_predictItems"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE );

#ifdef USE_MUMBLE
	cl_useMumble = Cvar_Get (""cl_useMumble"", ""0"", CVAR_ARCHIVE | CVAR_LATCH);
	cl_mumbleScale = Cvar_Get (""cl_mumbleScale"", ""0.0254"", CVAR_ARCHIVE);
#endif

#ifdef USE_VOIP
	cl_voipSend = Cvar_Get (""cl_voipSend"", ""0"", 0);
	cl_voipSendTarget = Cvar_Get (""cl_voipSendTarget"", ""spatial"", 0);
	cl_voipGainDuringCapture = Cvar_Get (""cl_voipGainDuringCapture"", ""0.2"", CVAR_ARCHIVE);
	cl_voipCaptureMult = Cvar_Get (""cl_voipCaptureMult"", ""2.0"", CVAR_ARCHIVE);
	cl_voipUseVAD = Cvar_Get (""cl_voipUseVAD"", ""0"", CVAR_ARCHIVE);
	cl_voipVADThreshold = Cvar_Get (""cl_voipVADThreshold"", ""0.25"", CVAR_ARCHIVE);
	cl_voipShowMeter = Cvar_Get (""cl_voipShowMeter"", ""1"", CVAR_ARCHIVE);

	cl_voip = Cvar_Get (""cl_voip"", ""1"", CVAR_ARCHIVE);
	Cvar_CheckRange( cl_voip, 0, 1, qtrue );
	cl_voipProtocol = Cvar_Get (""cl_voipProtocol"", cl_voip->integer ? ""opus"" : """", CVAR_USERINFO | CVAR_ROM);
#endif

	Cvar_Get( ""cg_autoactivate"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""cg_emptyswitch"", ""0"", CVAR_USERINFO | CVAR_ARCHIVE );

	Cvar_Get( ""cg_viewsize"", ""100"", CVAR_ARCHIVE );
	Cvar_Get (""cg_stereoSeparation"", ""0"", CVAR_ROM);

	cl_missionStats = Cvar_Get( ""g_missionStats"", ""0"", CVAR_ROM );
	cl_waitForFire = Cvar_Get( ""cl_waitForFire"", ""0"", CVAR_ROM );

	cl_language = Cvar_Get( ""cl_language"", ""0"", CVAR_ARCHIVE );
	cl_debugTranslation = Cvar_Get( ""cl_debugTranslation"", ""0"", 0 );

	Cmd_AddCommand( ""cmd"", CL_ForwardToServer_f );
	Cmd_AddCommand( ""configstrings"", CL_Configstrings_f );
	Cmd_AddCommand( ""clientinfo"", CL_Clientinfo_f );
	Cmd_AddCommand( ""snd_restart"", CL_Snd_Restart_f );
	Cmd_AddCommand( ""vid_restart"", CL_Vid_Restart_f );
	Cmd_AddCommand( ""disconnect"", CL_Disconnect_f );
	Cmd_AddCommand( ""record"", CL_Record_f );
	Cmd_AddCommand( ""demo"", CL_PlayDemo_f );
	Cmd_SetCommandCompletionFunc( ""demo"", CL_CompleteDemoName );
	Cmd_AddCommand( ""cinematic"", CL_PlayCinematic_f );
	Cmd_AddCommand( ""stoprecord"", CL_StopRecord_f );
	Cmd_AddCommand( ""connect"", CL_Connect_f );
	Cmd_AddCommand( ""reconnect"", CL_Reconnect_f );
	Cmd_AddCommand( ""localservers"", CL_LocalServers_f );
	Cmd_AddCommand( ""globalservers"", CL_GlobalServers_f );
	Cmd_AddCommand( ""rcon"", CL_Rcon_f );
	Cmd_SetCommandCompletionFunc( ""rcon"", CL_CompleteRcon );
	Cmd_AddCommand( ""ping"", CL_Ping_f );
	Cmd_AddCommand( ""serverstatus"", CL_ServerStatus_f );
	Cmd_AddCommand( ""showip"", CL_ShowIP_f );
	Cmd_AddCommand( ""fs_openedList"", CL_OpenedPK3List_f );
	Cmd_AddCommand( ""fs_referencedList"", CL_ReferencedPK3List_f );
	Cmd_AddCommand (""video"", CL_Video_f );
	Cmd_AddCommand (""stopvideo"", CL_StopVideo_f );

	Cmd_AddCommand( ""cache_startgather"", CL_Cache_StartGather_f );
	Cmd_AddCommand( ""cache_usedfile"", CL_Cache_UsedFile_f );
	Cmd_AddCommand( ""cache_setindex"", CL_Cache_SetIndex_f );
	Cmd_AddCommand( ""cache_mapchange"", CL_Cache_MapChange_f );
	Cmd_AddCommand( ""cache_endgather"", CL_Cache_EndGather_f );

	Cmd_AddCommand( ""updatehunkusage"", CL_UpdateLevelHunkUsage );
	Cmd_AddCommand( ""updatescreen"", SCR_UpdateScreen );

	Cmd_AddCommand( ""cld"", CL_ClientDamageCommand );

	Cmd_AddCommand( ""startMultiplayer"", CL_startMultiplayer_f );        // NERVE - SMF

	Cmd_AddCommand( ""shellExecute"", CL_ShellExecute_URL_f );

	Cmd_AddCommand( ""map_restart"", CL_MapRestart_f );

	Cmd_AddCommand( ""setRecommended"", CL_SetRecommended_f );

	CL_InitRef();

	SCR_Init();


	Cvar_Set( ""cl_running"", ""1"" );

	CL_GenerateQKey();
	Cvar_Get( ""cl_guid"", """", CVAR_USERINFO | CVAR_ROM );
	CL_UpdateGUID( NULL, 0 );

	Com_Printf( ""----- Client Initialization Complete -----\n"" );
}
","void CL_Init( void ) {
	Com_Printf( ""----- Client Initialization -----\n"" );

	Con_Init();

	if(!com_fullyInitialized)
	{
		CL_ClearState();
		clc.state = CA_DISCONNECTED;	// no longer CA_UNINITIALIZED
		cl_oldGameSet = qfalse;
	}

	cls.realtime = 0;

	CL_InitInput();

	cl_noprint = Cvar_Get( ""cl_noprint"", ""0"", 0 );
#ifdef UPDATE_SERVER_NAME
	cl_motd = Cvar_Get( ""cl_motd"", ""1"", 0 );
#endif

	cl_timeout = Cvar_Get( ""cl_timeout"", ""200"", 0 );

	cl_timeNudge = Cvar_Get( ""cl_timeNudge"", ""0"", CVAR_TEMP );
	cl_shownet = Cvar_Get( ""cl_shownet"", ""0"", CVAR_TEMP );
	cl_showSend = Cvar_Get( ""cl_showSend"", ""0"", CVAR_TEMP );
	cl_showTimeDelta = Cvar_Get( ""cl_showTimeDelta"", ""0"", CVAR_TEMP );
	cl_freezeDemo = Cvar_Get( ""cl_freezeDemo"", ""0"", CVAR_TEMP );
	rcon_client_password = Cvar_Get( ""rconPassword"", """", CVAR_TEMP );
	cl_activeAction = Cvar_Get( ""activeAction"", """", CVAR_TEMP );

	cl_timedemo = Cvar_Get( ""timedemo"", ""0"", 0 );
	cl_timedemoLog = Cvar_Get (""cl_timedemoLog"", """", CVAR_ARCHIVE);
	cl_autoRecordDemo = Cvar_Get (""cl_autoRecordDemo"", ""0"", CVAR_ARCHIVE);
	cl_aviFrameRate = Cvar_Get (""cl_aviFrameRate"", ""25"", CVAR_ARCHIVE);
	cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE);
	cl_avidemo = Cvar_Get( ""cl_avidemo"", ""0"", 0 );
	cl_forceavidemo = Cvar_Get( ""cl_forceavidemo"", ""0"", 0 );

	rconAddress = Cvar_Get( ""rconAddress"", """", 0 );

	cl_yawspeed = Cvar_Get( ""cl_yawspeed"", ""140"", CVAR_ARCHIVE );
	cl_pitchspeed = Cvar_Get( ""cl_pitchspeed"", ""140"", CVAR_ARCHIVE );
	cl_anglespeedkey = Cvar_Get( ""cl_anglespeedkey"", ""1.5"", 0 );

	cl_maxpackets = Cvar_Get( ""cl_maxpackets"", ""38"", CVAR_ARCHIVE );
	cl_packetdup = Cvar_Get( ""cl_packetdup"", ""1"", CVAR_ARCHIVE );

	cl_run = Cvar_Get( ""cl_run"", ""1"", CVAR_ARCHIVE );
	cl_sensitivity = Cvar_Get( ""sensitivity"", ""5"", CVAR_ARCHIVE );
	cl_mouseAccel = Cvar_Get( ""cl_mouseAccel"", ""0"", CVAR_ARCHIVE );
	cl_freelook = Cvar_Get( ""cl_freelook"", ""1"", CVAR_ARCHIVE );

	cl_mouseAccelStyle = Cvar_Get( ""cl_mouseAccelStyle"", ""0"", CVAR_ARCHIVE );
	cl_mouseAccelOffset = Cvar_Get( ""cl_mouseAccelOffset"", ""5"", CVAR_ARCHIVE );
	Cvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);

	cl_showMouseRate = Cvar_Get( ""cl_showmouserate"", ""0"", 0 );
 
 	cl_allowDownload = Cvar_Get( ""cl_allowDownload"", ""0"", CVAR_ARCHIVE );
 #ifdef USE_CURL_DLOPEN
	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);
 #endif
 
	Cvar_Get( ""cg_autoswitch"", ""2"", CVAR_ARCHIVE );

	Cvar_Get( ""cg_wolfparticles"", ""1"", CVAR_ARCHIVE );

	cl_conXOffset = Cvar_Get( ""cl_conXOffset"", ""0"", 0 );
	cl_inGameVideo = Cvar_Get( ""r_inGameVideo"", ""1"", CVAR_ARCHIVE );

	cl_serverStatusResendTime = Cvar_Get( ""cl_serverStatusResendTime"", ""750"", 0 );

	cl_recoilPitch = Cvar_Get( ""cg_recoilPitch"", ""0"", CVAR_ROM );

	m_pitch = Cvar_Get( ""m_pitch"", ""0.022"", CVAR_ARCHIVE );
	m_yaw = Cvar_Get( ""m_yaw"", ""0.022"", CVAR_ARCHIVE );
	m_forward = Cvar_Get( ""m_forward"", ""0.25"", CVAR_ARCHIVE );
	m_side = Cvar_Get( ""m_side"", ""0.25"", CVAR_ARCHIVE );
	m_filter = Cvar_Get( ""m_filter"", ""0"", CVAR_ARCHIVE );

	j_pitch =        Cvar_Get (""j_pitch"",        ""0.022"", CVAR_ARCHIVE);
	j_yaw =          Cvar_Get (""j_yaw"",          ""-0.022"", CVAR_ARCHIVE);
	j_forward =      Cvar_Get (""j_forward"",      ""-0.25"", CVAR_ARCHIVE);
	j_side =         Cvar_Get (""j_side"",         ""0.25"", CVAR_ARCHIVE);
	j_up =           Cvar_Get (""j_up"",           ""0"", CVAR_ARCHIVE);

	j_pitch_axis =   Cvar_Get (""j_pitch_axis"",   ""3"", CVAR_ARCHIVE);
	j_yaw_axis =     Cvar_Get (""j_yaw_axis"",     ""2"", CVAR_ARCHIVE);
	j_forward_axis = Cvar_Get (""j_forward_axis"", ""1"", CVAR_ARCHIVE);
	j_side_axis =    Cvar_Get (""j_side_axis"",    ""0"", CVAR_ARCHIVE);
	j_up_axis =      Cvar_Get (""j_up_axis"",      ""4"", CVAR_ARCHIVE);

	Cvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);

	cl_motdString = Cvar_Get( ""cl_motdString"", """", CVAR_ROM );

	Cvar_Get( ""cl_maxPing"", ""800"", CVAR_ARCHIVE );

	cl_lanForcePackets = Cvar_Get (""cl_lanForcePackets"", ""1"", CVAR_ARCHIVE);

	cl_guidServerUniq = Cvar_Get (""cl_guidServerUniq"", ""1"", CVAR_ARCHIVE);

	cl_consoleKeys = Cvar_Get( ""cl_consoleKeys"", ""~ ` 0x7e 0x60"", CVAR_ARCHIVE);

	Cvar_Get( ""name"", ""WolfPlayer"", CVAR_USERINFO | CVAR_ARCHIVE );
	cl_rate = Cvar_Get( ""rate"", ""25000"", CVAR_USERINFO | CVAR_ARCHIVE );     // NERVE - SMF - changed from 3000
	Cvar_Get( ""snaps"", ""20"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""model"", ""bj2"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""head"", ""default"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""color"", ""4"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""handicap"", ""100"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""sex"", ""male"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""cl_anonymous"", ""0"", CVAR_USERINFO | CVAR_ARCHIVE );

	Cvar_Get( ""password"", """", CVAR_USERINFO );
	Cvar_Get( ""cg_predictItems"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE );

#ifdef USE_MUMBLE
	cl_useMumble = Cvar_Get (""cl_useMumble"", ""0"", CVAR_ARCHIVE | CVAR_LATCH);
	cl_mumbleScale = Cvar_Get (""cl_mumbleScale"", ""0.0254"", CVAR_ARCHIVE);
#endif

#ifdef USE_VOIP
	cl_voipSend = Cvar_Get (""cl_voipSend"", ""0"", 0);
	cl_voipSendTarget = Cvar_Get (""cl_voipSendTarget"", ""spatial"", 0);
	cl_voipGainDuringCapture = Cvar_Get (""cl_voipGainDuringCapture"", ""0.2"", CVAR_ARCHIVE);
	cl_voipCaptureMult = Cvar_Get (""cl_voipCaptureMult"", ""2.0"", CVAR_ARCHIVE);
	cl_voipUseVAD = Cvar_Get (""cl_voipUseVAD"", ""0"", CVAR_ARCHIVE);
	cl_voipVADThreshold = Cvar_Get (""cl_voipVADThreshold"", ""0.25"", CVAR_ARCHIVE);
	cl_voipShowMeter = Cvar_Get (""cl_voipShowMeter"", ""1"", CVAR_ARCHIVE);

	cl_voip = Cvar_Get (""cl_voip"", ""1"", CVAR_ARCHIVE);
	Cvar_CheckRange( cl_voip, 0, 1, qtrue );
	cl_voipProtocol = Cvar_Get (""cl_voipProtocol"", cl_voip->integer ? ""opus"" : """", CVAR_USERINFO | CVAR_ROM);
#endif

	Cvar_Get( ""cg_autoactivate"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""cg_emptyswitch"", ""0"", CVAR_USERINFO | CVAR_ARCHIVE );

	Cvar_Get( ""cg_viewsize"", ""100"", CVAR_ARCHIVE );
	Cvar_Get (""cg_stereoSeparation"", ""0"", CVAR_ROM);

	cl_missionStats = Cvar_Get( ""g_missionStats"", ""0"", CVAR_ROM );
	cl_waitForFire = Cvar_Get( ""cl_waitForFire"", ""0"", CVAR_ROM );

	cl_language = Cvar_Get( ""cl_language"", ""0"", CVAR_ARCHIVE );
	cl_debugTranslation = Cvar_Get( ""cl_debugTranslation"", ""0"", 0 );

	Cmd_AddCommand( ""cmd"", CL_ForwardToServer_f );
	Cmd_AddCommand( ""configstrings"", CL_Configstrings_f );
	Cmd_AddCommand( ""clientinfo"", CL_Clientinfo_f );
	Cmd_AddCommand( ""snd_restart"", CL_Snd_Restart_f );
	Cmd_AddCommand( ""vid_restart"", CL_Vid_Restart_f );
	Cmd_AddCommand( ""disconnect"", CL_Disconnect_f );
	Cmd_AddCommand( ""record"", CL_Record_f );
	Cmd_AddCommand( ""demo"", CL_PlayDemo_f );
	Cmd_SetCommandCompletionFunc( ""demo"", CL_CompleteDemoName );
	Cmd_AddCommand( ""cinematic"", CL_PlayCinematic_f );
	Cmd_AddCommand( ""stoprecord"", CL_StopRecord_f );
	Cmd_AddCommand( ""connect"", CL_Connect_f );
	Cmd_AddCommand( ""reconnect"", CL_Reconnect_f );
	Cmd_AddCommand( ""localservers"", CL_LocalServers_f );
	Cmd_AddCommand( ""globalservers"", CL_GlobalServers_f );
	Cmd_AddCommand( ""rcon"", CL_Rcon_f );
	Cmd_SetCommandCompletionFunc( ""rcon"", CL_CompleteRcon );
	Cmd_AddCommand( ""ping"", CL_Ping_f );
	Cmd_AddCommand( ""serverstatus"", CL_ServerStatus_f );
	Cmd_AddCommand( ""showip"", CL_ShowIP_f );
	Cmd_AddCommand( ""fs_openedList"", CL_OpenedPK3List_f );
	Cmd_AddCommand( ""fs_referencedList"", CL_ReferencedPK3List_f );
	Cmd_AddCommand (""video"", CL_Video_f );
	Cmd_AddCommand (""stopvideo"", CL_StopVideo_f );

	Cmd_AddCommand( ""cache_startgather"", CL_Cache_StartGather_f );
	Cmd_AddCommand( ""cache_usedfile"", CL_Cache_UsedFile_f );
	Cmd_AddCommand( ""cache_setindex"", CL_Cache_SetIndex_f );
	Cmd_AddCommand( ""cache_mapchange"", CL_Cache_MapChange_f );
	Cmd_AddCommand( ""cache_endgather"", CL_Cache_EndGather_f );

	Cmd_AddCommand( ""updatehunkusage"", CL_UpdateLevelHunkUsage );
	Cmd_AddCommand( ""updatescreen"", SCR_UpdateScreen );

	Cmd_AddCommand( ""cld"", CL_ClientDamageCommand );

	Cmd_AddCommand( ""startMultiplayer"", CL_startMultiplayer_f );        // NERVE - SMF

	Cmd_AddCommand( ""shellExecute"", CL_ShellExecute_URL_f );

	Cmd_AddCommand( ""map_restart"", CL_MapRestart_f );

	Cmd_AddCommand( ""setRecommended"", CL_SetRecommended_f );

	CL_InitRef();

	SCR_Init();


	Cvar_Set( ""cl_running"", ""1"" );

	CL_GenerateQKey();
	Cvar_Get( ""cl_guid"", """", CVAR_USERINFO | CVAR_ROM );
	CL_UpdateGUID( NULL, 0 );

	Com_Printf( ""----- Client Initialization Complete -----\n"" );
}
",C,"	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
","	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);
",,"@@ -3348,7 +3348,7 @@ void CL_InitRef( void ) {
 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
-	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH);
+	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_sp_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
@@ -3690,7 +3690,7 @@ void CL_Init( void ) {
 
 	cl_allowDownload = Cvar_Get( ""cl_allowDownload"", ""0"", CVAR_ARCHIVE );
 #ifdef USE_CURL_DLOPEN
-	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);
+	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
 #endif
 
 	// init autoswitch so the ui will have it correctly even",OpenJK,b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,1efb19a25feace6de9b103fa3fe334fa1901b495,1,"void CL_Init( void ) {
	Com_Printf( ""----- Client Initialization -----\n"" );

	Con_Init();

	if(!com_fullyInitialized)
	{
		CL_ClearState();
		clc.state = CA_DISCONNECTED;	// no longer CA_UNINITIALIZED
		cl_oldGameSet = qfalse;
	}

	cls.realtime = 0;

	CL_InitInput();

	//
	// register our variables
	//
	cl_noprint = Cvar_Get( ""cl_noprint"", ""0"", 0 );
#ifdef UPDATE_SERVER_NAME
	cl_motd = Cvar_Get( ""cl_motd"", ""1"", 0 );
#endif

	cl_timeout = Cvar_Get( ""cl_timeout"", ""200"", 0 );

	cl_timeNudge = Cvar_Get( ""cl_timeNudge"", ""0"", CVAR_TEMP );
	cl_shownet = Cvar_Get( ""cl_shownet"", ""0"", CVAR_TEMP );
	cl_showSend = Cvar_Get( ""cl_showSend"", ""0"", CVAR_TEMP );
	cl_showTimeDelta = Cvar_Get( ""cl_showTimeDelta"", ""0"", CVAR_TEMP );
	cl_freezeDemo = Cvar_Get( ""cl_freezeDemo"", ""0"", CVAR_TEMP );
	rcon_client_password = Cvar_Get( ""rconPassword"", """", CVAR_TEMP );
	cl_activeAction = Cvar_Get( ""activeAction"", """", CVAR_TEMP );

	cl_timedemo = Cvar_Get( ""timedemo"", ""0"", 0 );
	cl_timedemoLog = Cvar_Get (""cl_timedemoLog"", """", CVAR_ARCHIVE);
	cl_autoRecordDemo = Cvar_Get (""cl_autoRecordDemo"", ""0"", CVAR_ARCHIVE);
	cl_aviFrameRate = Cvar_Get (""cl_aviFrameRate"", ""25"", CVAR_ARCHIVE);
	cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE);
	cl_avidemo = Cvar_Get( ""cl_avidemo"", ""0"", 0 );
	cl_forceavidemo = Cvar_Get( ""cl_forceavidemo"", ""0"", 0 );

	rconAddress = Cvar_Get( ""rconAddress"", """", 0 );

	cl_yawspeed = Cvar_Get( ""cl_yawspeed"", ""140"", CVAR_ARCHIVE );
	cl_pitchspeed = Cvar_Get( ""cl_pitchspeed"", ""140"", CVAR_ARCHIVE );
	cl_anglespeedkey = Cvar_Get( ""cl_anglespeedkey"", ""1.5"", 0 );

	cl_maxpackets = Cvar_Get( ""cl_maxpackets"", ""38"", CVAR_ARCHIVE );
	cl_packetdup = Cvar_Get( ""cl_packetdup"", ""1"", CVAR_ARCHIVE );

	cl_run = Cvar_Get( ""cl_run"", ""1"", CVAR_ARCHIVE );
	cl_sensitivity = Cvar_Get( ""sensitivity"", ""5"", CVAR_ARCHIVE );
	cl_mouseAccel = Cvar_Get( ""cl_mouseAccel"", ""0"", CVAR_ARCHIVE );
	cl_freelook = Cvar_Get( ""cl_freelook"", ""1"", CVAR_ARCHIVE );

	// 0: legacy mouse acceleration
	// 1: new implementation
	cl_mouseAccelStyle = Cvar_Get( ""cl_mouseAccelStyle"", ""0"", CVAR_ARCHIVE );
	// offset for the power function (for style 1, ignored otherwise)
	// this should be set to the max rate value
	cl_mouseAccelOffset = Cvar_Get( ""cl_mouseAccelOffset"", ""5"", CVAR_ARCHIVE );
	Cvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);

	cl_showMouseRate = Cvar_Get( ""cl_showmouserate"", ""0"", 0 );
 
 	cl_allowDownload = Cvar_Get( ""cl_allowDownload"", ""0"", CVAR_ARCHIVE );
 #ifdef USE_CURL_DLOPEN
//flaw_line_below:
	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);
//fix_flaw_line_below:
//	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
 #endif
 
 	// init autoswitch so the ui will have it correctly even
	// if the cgame hasn't been started
	Cvar_Get( ""cg_autoswitch"", ""2"", CVAR_ARCHIVE );

	// Rafael - particle switch
	Cvar_Get( ""cg_wolfparticles"", ""1"", CVAR_ARCHIVE );
	// done

	cl_conXOffset = Cvar_Get( ""cl_conXOffset"", ""0"", 0 );
	cl_inGameVideo = Cvar_Get( ""r_inGameVideo"", ""1"", CVAR_ARCHIVE );

	cl_serverStatusResendTime = Cvar_Get( ""cl_serverStatusResendTime"", ""750"", 0 );

	// RF
	cl_recoilPitch = Cvar_Get( ""cg_recoilPitch"", ""0"", CVAR_ROM );

	m_pitch = Cvar_Get( ""m_pitch"", ""0.022"", CVAR_ARCHIVE );
	m_yaw = Cvar_Get( ""m_yaw"", ""0.022"", CVAR_ARCHIVE );
	m_forward = Cvar_Get( ""m_forward"", ""0.25"", CVAR_ARCHIVE );
	m_side = Cvar_Get( ""m_side"", ""0.25"", CVAR_ARCHIVE );
	m_filter = Cvar_Get( ""m_filter"", ""0"", CVAR_ARCHIVE );

	j_pitch =        Cvar_Get (""j_pitch"",        ""0.022"", CVAR_ARCHIVE);
	j_yaw =          Cvar_Get (""j_yaw"",          ""-0.022"", CVAR_ARCHIVE);
	j_forward =      Cvar_Get (""j_forward"",      ""-0.25"", CVAR_ARCHIVE);
	j_side =         Cvar_Get (""j_side"",         ""0.25"", CVAR_ARCHIVE);
	j_up =           Cvar_Get (""j_up"",           ""0"", CVAR_ARCHIVE);

	j_pitch_axis =   Cvar_Get (""j_pitch_axis"",   ""3"", CVAR_ARCHIVE);
	j_yaw_axis =     Cvar_Get (""j_yaw_axis"",     ""2"", CVAR_ARCHIVE);
	j_forward_axis = Cvar_Get (""j_forward_axis"", ""1"", CVAR_ARCHIVE);
	j_side_axis =    Cvar_Get (""j_side_axis"",    ""0"", CVAR_ARCHIVE);
	j_up_axis =      Cvar_Get (""j_up_axis"",      ""4"", CVAR_ARCHIVE);

	Cvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);

	cl_motdString = Cvar_Get( ""cl_motdString"", """", CVAR_ROM );

	Cvar_Get( ""cl_maxPing"", ""800"", CVAR_ARCHIVE );

	cl_lanForcePackets = Cvar_Get (""cl_lanForcePackets"", ""1"", CVAR_ARCHIVE);

	cl_guidServerUniq = Cvar_Get (""cl_guidServerUniq"", ""1"", CVAR_ARCHIVE);

	// ~ and `, as keys and characters
	cl_consoleKeys = Cvar_Get( ""cl_consoleKeys"", ""~ ` 0x7e 0x60"", CVAR_ARCHIVE);

	// userinfo
	Cvar_Get( ""name"", ""WolfPlayer"", CVAR_USERINFO | CVAR_ARCHIVE );
	cl_rate = Cvar_Get( ""rate"", ""25000"", CVAR_USERINFO | CVAR_ARCHIVE );     // NERVE - SMF - changed from 3000
	Cvar_Get( ""snaps"", ""20"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""model"", ""bj2"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""head"", ""default"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""color"", ""4"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""handicap"", ""100"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""sex"", ""male"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""cl_anonymous"", ""0"", CVAR_USERINFO | CVAR_ARCHIVE );

	Cvar_Get( ""password"", """", CVAR_USERINFO );
	Cvar_Get( ""cg_predictItems"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE );

#ifdef USE_MUMBLE
	cl_useMumble = Cvar_Get (""cl_useMumble"", ""0"", CVAR_ARCHIVE | CVAR_LATCH);
	cl_mumbleScale = Cvar_Get (""cl_mumbleScale"", ""0.0254"", CVAR_ARCHIVE);
#endif

#ifdef USE_VOIP
	cl_voipSend = Cvar_Get (""cl_voipSend"", ""0"", 0);
	cl_voipSendTarget = Cvar_Get (""cl_voipSendTarget"", ""spatial"", 0);
	cl_voipGainDuringCapture = Cvar_Get (""cl_voipGainDuringCapture"", ""0.2"", CVAR_ARCHIVE);
	cl_voipCaptureMult = Cvar_Get (""cl_voipCaptureMult"", ""2.0"", CVAR_ARCHIVE);
	cl_voipUseVAD = Cvar_Get (""cl_voipUseVAD"", ""0"", CVAR_ARCHIVE);
	cl_voipVADThreshold = Cvar_Get (""cl_voipVADThreshold"", ""0.25"", CVAR_ARCHIVE);
	cl_voipShowMeter = Cvar_Get (""cl_voipShowMeter"", ""1"", CVAR_ARCHIVE);

	cl_voip = Cvar_Get (""cl_voip"", ""1"", CVAR_ARCHIVE);
	Cvar_CheckRange( cl_voip, 0, 1, qtrue );
	cl_voipProtocol = Cvar_Get (""cl_voipProtocol"", cl_voip->integer ? ""opus"" : """", CVAR_USERINFO | CVAR_ROM);
#endif

//----(SA) added
	Cvar_Get( ""cg_autoactivate"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get( ""cg_emptyswitch"", ""0"", CVAR_USERINFO | CVAR_ARCHIVE );
//----(SA) end

	// cgame might not be initialized before menu is used
	Cvar_Get( ""cg_viewsize"", ""100"", CVAR_ARCHIVE );
	// Make sure cg_stereoSeparation is zero as that variable is deprecated and should not be used anymore.
	Cvar_Get (""cg_stereoSeparation"", ""0"", CVAR_ROM);

	cl_missionStats = Cvar_Get( ""g_missionStats"", ""0"", CVAR_ROM );
	cl_waitForFire = Cvar_Get( ""cl_waitForFire"", ""0"", CVAR_ROM );

	// NERVE - SMF - localization
	cl_language = Cvar_Get( ""cl_language"", ""0"", CVAR_ARCHIVE );
	cl_debugTranslation = Cvar_Get( ""cl_debugTranslation"", ""0"", 0 );
	// -NERVE - SMF

	//
	// register our commands
	//
	Cmd_AddCommand( ""cmd"", CL_ForwardToServer_f );
	Cmd_AddCommand( ""configstrings"", CL_Configstrings_f );
	Cmd_AddCommand( ""clientinfo"", CL_Clientinfo_f );
	Cmd_AddCommand( ""snd_restart"", CL_Snd_Restart_f );
	Cmd_AddCommand( ""vid_restart"", CL_Vid_Restart_f );
	Cmd_AddCommand( ""disconnect"", CL_Disconnect_f );
	Cmd_AddCommand( ""record"", CL_Record_f );
	Cmd_AddCommand( ""demo"", CL_PlayDemo_f );
	Cmd_SetCommandCompletionFunc( ""demo"", CL_CompleteDemoName );
	Cmd_AddCommand( ""cinematic"", CL_PlayCinematic_f );
	Cmd_AddCommand( ""stoprecord"", CL_StopRecord_f );
	Cmd_AddCommand( ""connect"", CL_Connect_f );
	Cmd_AddCommand( ""reconnect"", CL_Reconnect_f );
	Cmd_AddCommand( ""localservers"", CL_LocalServers_f );
	Cmd_AddCommand( ""globalservers"", CL_GlobalServers_f );
	Cmd_AddCommand( ""rcon"", CL_Rcon_f );
	Cmd_SetCommandCompletionFunc( ""rcon"", CL_CompleteRcon );
	Cmd_AddCommand( ""ping"", CL_Ping_f );
	Cmd_AddCommand( ""serverstatus"", CL_ServerStatus_f );
	Cmd_AddCommand( ""showip"", CL_ShowIP_f );
	Cmd_AddCommand( ""fs_openedList"", CL_OpenedPK3List_f );
	Cmd_AddCommand( ""fs_referencedList"", CL_ReferencedPK3List_f );
	Cmd_AddCommand (""video"", CL_Video_f );
	Cmd_AddCommand (""stopvideo"", CL_StopVideo_f );

	// Ridah, startup-caching system
	Cmd_AddCommand( ""cache_startgather"", CL_Cache_StartGather_f );
	Cmd_AddCommand( ""cache_usedfile"", CL_Cache_UsedFile_f );
	Cmd_AddCommand( ""cache_setindex"", CL_Cache_SetIndex_f );
	Cmd_AddCommand( ""cache_mapchange"", CL_Cache_MapChange_f );
	Cmd_AddCommand( ""cache_endgather"", CL_Cache_EndGather_f );

	Cmd_AddCommand( ""updatehunkusage"", CL_UpdateLevelHunkUsage );
	Cmd_AddCommand( ""updatescreen"", SCR_UpdateScreen );
	// done.

	// RF, add this command so clients can't bind a key to send client damage commands to the server
	Cmd_AddCommand( ""cld"", CL_ClientDamageCommand );

	Cmd_AddCommand( ""startMultiplayer"", CL_startMultiplayer_f );        // NERVE - SMF

	Cmd_AddCommand( ""shellExecute"", CL_ShellExecute_URL_f );

	// RF, prevent users from issuing a map_restart manually
	Cmd_AddCommand( ""map_restart"", CL_MapRestart_f );

	Cmd_AddCommand( ""setRecommended"", CL_SetRecommended_f );

	CL_InitRef();

	SCR_Init();

//	Cbuf_Execute();

	Cvar_Set( ""cl_running"", ""1"" );

	CL_GenerateQKey();
	Cvar_Get( ""cl_guid"", """", CVAR_USERINFO | CVAR_ROM );
	CL_UpdateGUID( NULL, 0 );

	Com_Printf( ""----- Client Initialization Complete -----\n"" );
}
"
5522,183258,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,1,https://github.com/iortcw/iortcw/commit/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,"All: Don't load .pk3s as .dlls, and don't load user config files from .pk3s",1,SP/code/client/cl_main.c,"{""sha"": ""92675c53d7d8d4e2072a5423e471fb48daeec2c6"", ""filename"": ""MP/code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/client/cl_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/client/cl_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -3674,7 +3674,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_mp_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -4014,7 +4014,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get( \""cl_allowDownload\"", \""1\"", CVAR_ARCHIVE );\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \t// init autoswitch so the ui will have it correctly even""}<_**next**_>{""sha"": ""c262e6b62003d9fa427776ce44bfa958569ecd18"", ""filename"": ""MP/code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/qcommon/files.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/qcommon/files.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -1424,12 +1424,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and wolfconfig_mp.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t        len = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \t        \n \t        if(file == NULL)""}<_**next**_>{""sha"": ""f3dc2e91909d7f1f90227e2ba68dfa2e61a40485"", ""filename"": ""MP/code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/sys/sys_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -499,6 +499,13 @@ from executable path, then fs_basepath.\n void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n+\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);""}<_**next**_>{""sha"": ""18c16aa973bb821e6972cf1da0c98c3007ddbfd6"", ""filename"": ""SP/code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/client/cl_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/client/cl_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -3348,7 +3348,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_sp_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -3690,7 +3690,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get( \""cl_allowDownload\"", \""0\"", CVAR_ARCHIVE );\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \t// init autoswitch so the ui will have it correctly even""}<_**next**_>{""sha"": ""15910bd5e96fec07e0fb331beba36879ea237545"", ""filename"": ""SP/code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/qcommon/files.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/qcommon/files.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -1591,12 +1591,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and wolfconfig.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t\tlen = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \n \t\tif(file == NULL)""}<_**next**_>{""sha"": ""e591d9890c74ee974af303dae0be35f1236d5473"", ""filename"": ""SP/code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/sys/sys_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -499,6 +499,13 @@ from executable path, then fs_basepath.\n void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n+\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);""}","void CL_InitRef( void ) {
	refimport_t ri;
	refexport_t *ret;
#ifdef USE_RENDERER_DLOPEN
	GetRefAPI_t		GetRefAPI;
	char			dllName[MAX_OSPATH];
#endif

 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_sp_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
	if(!(rendererLib = Sys_LoadDll(dllName, qfalse)) && strcmp(cl_renderer->string, cl_renderer->resetString))
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Cvar_ForceReset(""cl_renderer"");

		Com_sprintf(dllName, sizeof(dllName), ""renderer_sp_opengl1_"" ARCH_STRING DLL_EXT);
		rendererLib = Sys_LoadDll(dllName, qfalse);
	}

	if(!rendererLib)
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Com_Error(ERR_FATAL, ""Failed to load renderer"");
	}

	GetRefAPI = Sys_LoadFunction(rendererLib, ""GetRefAPI"");
	if(!GetRefAPI)
	{
		Com_Error(ERR_FATAL, ""Can't load symbol GetRefAPI: '%s'"",  Sys_LibraryError());
	}
#endif

	ri.Cmd_AddCommand = Cmd_AddCommand;
	ri.Cmd_RemoveCommand = Cmd_RemoveCommand;
	ri.Cmd_Argc = Cmd_Argc;
	ri.Cmd_Argv = Cmd_Argv;
	ri.Cmd_ExecuteText = Cbuf_ExecuteText;
	ri.Printf = CL_RefPrintf;
	ri.Error = Com_Error;
	ri.Milliseconds = CL_ScaledMilliseconds;

	ri.Z_Malloc = Z_Malloc;
	ri.Free = Z_Free;
	ri.Hunk_Clear = Hunk_ClearToMark;
#ifdef HUNK_DEBUG
	ri.Hunk_AllocDebug = Hunk_AllocDebug;
#else
	ri.Hunk_Alloc = Hunk_Alloc;
#endif
	ri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory;
	ri.Hunk_FreeTempMemory = Hunk_FreeTempMemory;

	ri.CM_ClusterPVS = CM_ClusterPVS;
	ri.CM_DrawDebugSurface = CM_DrawDebugSurface;
	ri.FS_ReadFile = FS_ReadFile;
	ri.FS_FreeFile = FS_FreeFile;
	ri.FS_WriteFile = FS_WriteFile;
	ri.FS_FreeFileList = FS_FreeFileList;
	ri.FS_ListFiles = FS_ListFiles;
	ri.FS_FileIsInPAK = FS_FileIsInPAK;
	ri.FS_FileExists = FS_FileExists;
	ri.Cvar_Get = Cvar_Get;
	ri.Cvar_Set = Cvar_Set;
	ri.Cvar_SetValue = Cvar_SetValue;
	ri.Cvar_CheckRange = Cvar_CheckRange;
	ri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue;


	ri.CIN_UploadCinematic = CIN_UploadCinematic;
	ri.CIN_PlayCinematic = CIN_PlayCinematic;
	ri.CIN_RunCinematic = CIN_RunCinematic;

	ri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame;

	ri.IN_Init = IN_Init;
	ri.IN_Shutdown = IN_Shutdown;
	ri.IN_Restart = IN_Restart;

	ri.ftol = Q_ftol;

	ri.Sys_SetEnv = Sys_SetEnv;
	ri.Sys_GLimpSafeInit = Sys_GLimpSafeInit;
	ri.Sys_GLimpInit = Sys_GLimpInit;
	ri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory;

	ret = GetRefAPI( REF_API_VERSION, &ri );

	if ( !ret ) {
		Com_Error( ERR_FATAL, ""Couldn't initialize refresh"" );
	}

	re = *ret;

	Com_Printf( ""---- Renderer Initialization Complete ----\n"" );

	Cvar_Set( ""cl_paused"", ""0"" );
}
","void CL_InitRef( void ) {
	refimport_t ri;
	refexport_t *ret;
#ifdef USE_RENDERER_DLOPEN
	GetRefAPI_t		GetRefAPI;
	char			dllName[MAX_OSPATH];
#endif

 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_sp_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
	if(!(rendererLib = Sys_LoadDll(dllName, qfalse)) && strcmp(cl_renderer->string, cl_renderer->resetString))
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Cvar_ForceReset(""cl_renderer"");

		Com_sprintf(dllName, sizeof(dllName), ""renderer_sp_opengl1_"" ARCH_STRING DLL_EXT);
		rendererLib = Sys_LoadDll(dllName, qfalse);
	}

	if(!rendererLib)
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Com_Error(ERR_FATAL, ""Failed to load renderer"");
	}

	GetRefAPI = Sys_LoadFunction(rendererLib, ""GetRefAPI"");
	if(!GetRefAPI)
	{
		Com_Error(ERR_FATAL, ""Can't load symbol GetRefAPI: '%s'"",  Sys_LibraryError());
	}
#endif

	ri.Cmd_AddCommand = Cmd_AddCommand;
	ri.Cmd_RemoveCommand = Cmd_RemoveCommand;
	ri.Cmd_Argc = Cmd_Argc;
	ri.Cmd_Argv = Cmd_Argv;
	ri.Cmd_ExecuteText = Cbuf_ExecuteText;
	ri.Printf = CL_RefPrintf;
	ri.Error = Com_Error;
	ri.Milliseconds = CL_ScaledMilliseconds;

	ri.Z_Malloc = Z_Malloc;
	ri.Free = Z_Free;
	ri.Hunk_Clear = Hunk_ClearToMark;
#ifdef HUNK_DEBUG
	ri.Hunk_AllocDebug = Hunk_AllocDebug;
#else
	ri.Hunk_Alloc = Hunk_Alloc;
#endif
	ri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory;
	ri.Hunk_FreeTempMemory = Hunk_FreeTempMemory;

	ri.CM_ClusterPVS = CM_ClusterPVS;
	ri.CM_DrawDebugSurface = CM_DrawDebugSurface;
	ri.FS_ReadFile = FS_ReadFile;
	ri.FS_FreeFile = FS_FreeFile;
	ri.FS_WriteFile = FS_WriteFile;
	ri.FS_FreeFileList = FS_FreeFileList;
	ri.FS_ListFiles = FS_ListFiles;
	ri.FS_FileIsInPAK = FS_FileIsInPAK;
	ri.FS_FileExists = FS_FileExists;
	ri.Cvar_Get = Cvar_Get;
	ri.Cvar_Set = Cvar_Set;
	ri.Cvar_SetValue = Cvar_SetValue;
	ri.Cvar_CheckRange = Cvar_CheckRange;
	ri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue;


	ri.CIN_UploadCinematic = CIN_UploadCinematic;
	ri.CIN_PlayCinematic = CIN_PlayCinematic;
	ri.CIN_RunCinematic = CIN_RunCinematic;

	ri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame;

	ri.IN_Init = IN_Init;
	ri.IN_Shutdown = IN_Shutdown;
	ri.IN_Restart = IN_Restart;

	ri.ftol = Q_ftol;

	ri.Sys_SetEnv = Sys_SetEnv;
	ri.Sys_GLimpSafeInit = Sys_GLimpSafeInit;
	ri.Sys_GLimpInit = Sys_GLimpInit;
	ri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory;

	ret = GetRefAPI( REF_API_VERSION, &ri );

	if ( !ret ) {
		Com_Error( ERR_FATAL, ""Couldn't initialize refresh"" );
	}

	re = *ret;

	Com_Printf( ""---- Renderer Initialization Complete ----\n"" );

	Cvar_Set( ""cl_paused"", ""0"" );
}
",C,"	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
","	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH);
",,"@@ -3348,7 +3348,7 @@ void CL_InitRef( void ) {
 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
-	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH);
+	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_sp_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
@@ -3690,7 +3690,7 @@ void CL_Init( void ) {
 
 	cl_allowDownload = Cvar_Get( ""cl_allowDownload"", ""0"", CVAR_ARCHIVE );
 #ifdef USE_CURL_DLOPEN
-	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);
+	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
 #endif
 
 	// init autoswitch so the ui will have it correctly even",OpenJK,b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,1efb19a25feace6de9b103fa3fe334fa1901b495,1,"void CL_InitRef( void ) {
	refimport_t ri;
	refexport_t *ret;
#ifdef USE_RENDERER_DLOPEN
	GetRefAPI_t		GetRefAPI;
	char			dllName[MAX_OSPATH];
#endif

 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
//flaw_line_below:
	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH);
//fix_flaw_line_below:
//	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_sp_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
	if(!(rendererLib = Sys_LoadDll(dllName, qfalse)) && strcmp(cl_renderer->string, cl_renderer->resetString))
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Cvar_ForceReset(""cl_renderer"");

		Com_sprintf(dllName, sizeof(dllName), ""renderer_sp_opengl1_"" ARCH_STRING DLL_EXT);
		rendererLib = Sys_LoadDll(dllName, qfalse);
	}

	if(!rendererLib)
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Com_Error(ERR_FATAL, ""Failed to load renderer"");
	}

	GetRefAPI = Sys_LoadFunction(rendererLib, ""GetRefAPI"");
	if(!GetRefAPI)
	{
		Com_Error(ERR_FATAL, ""Can't load symbol GetRefAPI: '%s'"",  Sys_LibraryError());
	}
#endif

	ri.Cmd_AddCommand = Cmd_AddCommand;
	ri.Cmd_RemoveCommand = Cmd_RemoveCommand;
	ri.Cmd_Argc = Cmd_Argc;
	ri.Cmd_Argv = Cmd_Argv;
	ri.Cmd_ExecuteText = Cbuf_ExecuteText;
	ri.Printf = CL_RefPrintf;
	ri.Error = Com_Error;
	ri.Milliseconds = CL_ScaledMilliseconds;

	ri.Z_Malloc = Z_Malloc;
	ri.Free = Z_Free;
	ri.Hunk_Clear = Hunk_ClearToMark;
#ifdef HUNK_DEBUG
	ri.Hunk_AllocDebug = Hunk_AllocDebug;
#else
	ri.Hunk_Alloc = Hunk_Alloc;
#endif
	ri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory;
	ri.Hunk_FreeTempMemory = Hunk_FreeTempMemory;

	ri.CM_ClusterPVS = CM_ClusterPVS;
	ri.CM_DrawDebugSurface = CM_DrawDebugSurface;
	ri.FS_ReadFile = FS_ReadFile;
	ri.FS_FreeFile = FS_FreeFile;
	ri.FS_WriteFile = FS_WriteFile;
	ri.FS_FreeFileList = FS_FreeFileList;
	ri.FS_ListFiles = FS_ListFiles;
	ri.FS_FileIsInPAK = FS_FileIsInPAK;
	ri.FS_FileExists = FS_FileExists;
	ri.Cvar_Get = Cvar_Get;
	ri.Cvar_Set = Cvar_Set;
	ri.Cvar_SetValue = Cvar_SetValue;
	ri.Cvar_CheckRange = Cvar_CheckRange;
	ri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue;

	// cinematic stuff

	ri.CIN_UploadCinematic = CIN_UploadCinematic;
	ri.CIN_PlayCinematic = CIN_PlayCinematic;
	ri.CIN_RunCinematic = CIN_RunCinematic;

	ri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame;

	ri.IN_Init = IN_Init;
	ri.IN_Shutdown = IN_Shutdown;
	ri.IN_Restart = IN_Restart;

	ri.ftol = Q_ftol;

	ri.Sys_SetEnv = Sys_SetEnv;
	ri.Sys_GLimpSafeInit = Sys_GLimpSafeInit;
	ri.Sys_GLimpInit = Sys_GLimpInit;
	ri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory;

	ret = GetRefAPI( REF_API_VERSION, &ri );

	if ( !ret ) {
		Com_Error( ERR_FATAL, ""Couldn't initialize refresh"" );
	}

	re = *ret;

	Com_Printf( ""---- Renderer Initialization Complete ----\n"" );

	// unpause so the cgame definately gets a snapshot and renders a frame
	Cvar_Set( ""cl_paused"", ""0"" );
}
"
5523,183259,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,6,https://github.com/iortcw/iortcw/commit/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,"All: Don't load .pk3s as .dlls, and don't load user config files from .pk3s",0,SP/code/qcommon/files.c,"{""sha"": ""92675c53d7d8d4e2072a5423e471fb48daeec2c6"", ""filename"": ""MP/code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/client/cl_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/client/cl_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -3674,7 +3674,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_mp_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -4014,7 +4014,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get( \""cl_allowDownload\"", \""1\"", CVAR_ARCHIVE );\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \t// init autoswitch so the ui will have it correctly even""}<_**next**_>{""sha"": ""c262e6b62003d9fa427776ce44bfa958569ecd18"", ""filename"": ""MP/code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/qcommon/files.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/qcommon/files.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -1424,12 +1424,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and wolfconfig_mp.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t        len = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \t        \n \t        if(file == NULL)""}<_**next**_>{""sha"": ""f3dc2e91909d7f1f90227e2ba68dfa2e61a40485"", ""filename"": ""MP/code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/MP/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/MP/code/sys/sys_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -499,6 +499,13 @@ from executable path, then fs_basepath.\n void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n+\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);""}<_**next**_>{""sha"": ""18c16aa973bb821e6972cf1da0c98c3007ddbfd6"", ""filename"": ""SP/code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/client/cl_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/client/cl_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -3348,7 +3348,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl1\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_sp_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -3690,7 +3690,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get( \""cl_allowDownload\"", \""0\"", CVAR_ARCHIVE );\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \t// init autoswitch so the ui will have it correctly even""}<_**next**_>{""sha"": ""15910bd5e96fec07e0fb331beba36879ea237545"", ""filename"": ""SP/code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/qcommon/files.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/qcommon/files.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -1591,12 +1591,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and wolfconfig.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t\tlen = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \n \t\tif(file == NULL)""}<_**next**_>{""sha"": ""e591d9890c74ee974af303dae0be35f1236d5473"", ""filename"": ""SP/code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/iortcw/iortcw/blob/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/iortcw/iortcw/raw/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20/SP/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/iortcw/iortcw/contents/SP/code/sys/sys_main.c?ref=b6ff2bcb1e4e6976d61e316175c6d7c99860fe20"", ""patch"": ""@@ -499,6 +499,13 @@ from executable path, then fs_basepath.\n void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n+\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);""}","long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueFILE)
 {
 	searchpath_t *search;
 	long len;
	qboolean isLocalConfig;
 
 	if(!fs_searchpaths)
 		Com_Error(ERR_FATAL, ""Filesystem call made without initialization"");
 
	isLocalConfig = !strcmp(filename, ""autoexec.cfg"") || !strcmp(filename, Q3CONFIG_CFG);
 	for(search = fs_searchpaths; search; search = search->next)
 	{
		// autoexec.cfg and wolfconfig.cfg can only be loaded outside of pk3 files.
		if (isLocalConfig && search->pack)
			continue;

 		len = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);
 
 		if(file == NULL)
		{
			if(len > 0)
				return len;
		}
		else
		{
			if(len >= 0 && *file)
				return len;
		}

	}
	
#ifdef FS_MISSING
	if(missingFiles)
		fprintf(missingFiles, ""%s\n"", filename);
#endif

	if(file)
	{
		*file = 0;
		return -1;
	}
	else
	{
		return 0;
	}
}
","long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueFILE)
 {
 	searchpath_t *search;
 	long len;
 
 	if(!fs_searchpaths)
 		Com_Error(ERR_FATAL, ""Filesystem call made without initialization"");
 
 	for(search = fs_searchpaths; search; search = search->next)
 	{
 		len = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);
 
 		if(file == NULL)
		{
			if(len > 0)
				return len;
		}
		else
		{
			if(len >= 0 && *file)
				return len;
		}

	}
	
#ifdef FS_MISSING
	if(missingFiles)
		fprintf(missingFiles, ""%s\n"", filename);
#endif

	if(file)
	{
		*file = 0;
		return -1;
	}
	else
	{
		return 0;
	}
}
",C,"	qboolean isLocalConfig;
	isLocalConfig = !strcmp(filename, ""autoexec.cfg"") || !strcmp(filename, Q3CONFIG_CFG);
		// autoexec.cfg and wolfconfig.cfg can only be loaded outside of pk3 files.
		if (isLocalConfig && search->pack)
			continue;

",,,"@@ -1591,12 +1591,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF
 {
 	searchpath_t *search;
 	long len;
+	qboolean isLocalConfig;
 
 	if(!fs_searchpaths)
 		Com_Error(ERR_FATAL, ""Filesystem call made without initialization"");
 
+	isLocalConfig = !strcmp(filename, ""autoexec.cfg"") || !strcmp(filename, Q3CONFIG_CFG);
 	for(search = fs_searchpaths; search; search = search->next)
 	{
+		// autoexec.cfg and wolfconfig.cfg can only be loaded outside of pk3 files.
+		if (isLocalConfig && search->pack)
+			continue;
+
 		len = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);
 
 		if(file == NULL)",OpenJK,b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,1efb19a25feace6de9b103fa3fe334fa1901b495,1,"long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueFILE)
 {
 	searchpath_t *search;
 	long len;
//fix_flaw_line_below:
//	qboolean isLocalConfig;
 
 	if(!fs_searchpaths)
 		Com_Error(ERR_FATAL, ""Filesystem call made without initialization"");
 
//fix_flaw_line_below:
//	isLocalConfig = !strcmp(filename, ""autoexec.cfg"") || !strcmp(filename, Q3CONFIG_CFG);
 	for(search = fs_searchpaths; search; search = search->next)
 	{
//fix_flaw_line_below:
//		// autoexec.cfg and wolfconfig.cfg can only be loaded outside of pk3 files.
//fix_flaw_line_below:
//		if (isLocalConfig && search->pack)
//fix_flaw_line_below:
//			continue;
//fix_flaw_line_below:
//
 		len = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);
 
 		if(file == NULL)
		{
			if(len > 0)
				return len;
		}
		else
		{
			if(len >= 0 && *file)
				return len;
		}

	}
	
#ifdef FS_MISSING
	if(missingFiles)
		fprintf(missingFiles, ""%s\n"", filename);
#endif

	if(file)
	{
		*file = 0;
		return -1;
	}
	else
	{
		// When file is NULL, we're querying the existance of the file
		// If we've got here, it doesn't exist
		return 0;
	}
}
"
5524,183260,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,1,https://github.com/ioquake/ioq3/commit/376267d534476a875d8b9228149c4ee18b74a4fd,376267d534476a875d8b9228149c4ee18b74a4fd,"Don't load .pk3s as .dlls, and don't load user config files from .pk3s.",1,code/client/cl_main.c,"{""sha"": ""31dd9ab78256ce40d223bf810cd731de90f7e4bd"", ""filename"": ""code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/ioquake/ioq3/blob/376267d534476a875d8b9228149c4ee18b74a4fd/code/client/cl_main.c"", ""raw_url"": ""https://github.com/ioquake/ioq3/raw/376267d534476a875d8b9228149c4ee18b74a4fd/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/ioquake/ioq3/contents/code/client/cl_main.c?ref=376267d534476a875d8b9228149c4ee18b74a4fd"", ""patch"": ""@@ -3200,7 +3200,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl2\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl2\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -3551,7 +3551,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get (\""cl_allowDownload\"", \""0\"", CVAR_ARCHIVE);\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \tcl_conXOffset = Cvar_Get (\""cl_conXOffset\"", \""0\"", 0);""}<_**next**_>{""sha"": ""27f5713de1c2944b2e972b8e784f4c80961362d3"", ""filename"": ""code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/ioquake/ioq3/blob/376267d534476a875d8b9228149c4ee18b74a4fd/code/qcommon/files.c"", ""raw_url"": ""https://github.com/ioquake/ioq3/raw/376267d534476a875d8b9228149c4ee18b74a4fd/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/ioquake/ioq3/contents/code/qcommon/files.c?ref=376267d534476a875d8b9228149c4ee18b74a4fd"", ""patch"": ""@@ -1364,12 +1364,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and q3config.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t\tlen = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \n \t\tif(file == NULL)""}<_**next**_>{""sha"": ""6d7fe7bf95841033d3df50d5f5488a5f73437a88"", ""filename"": ""code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/ioquake/ioq3/blob/376267d534476a875d8b9228149c4ee18b74a4fd/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/ioquake/ioq3/raw/376267d534476a875d8b9228149c4ee18b74a4fd/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/ioquake/ioq3/contents/code/sys/sys_main.c?ref=376267d534476a875d8b9228149c4ee18b74a4fd"", ""patch"": ""@@ -500,6 +500,13 @@ void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n \t\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n+\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);\n \t""}","void CL_Init( void ) {
	Com_Printf( ""----- Client Initialization -----\n"" );

	Con_Init ();

	if(!com_fullyInitialized)
	{
		CL_ClearState();
		clc.state = CA_DISCONNECTED;	// no longer CA_UNINITIALIZED
		cl_oldGameSet = qfalse;
	}

	cls.realtime = 0;

	CL_InitInput ();

	cl_noprint = Cvar_Get( ""cl_noprint"", ""0"", 0 );
#ifdef UPDATE_SERVER_NAME
	cl_motd = Cvar_Get (""cl_motd"", ""1"", 0);
#endif

	cl_timeout = Cvar_Get (""cl_timeout"", ""200"", 0);

	cl_timeNudge = Cvar_Get (""cl_timeNudge"", ""0"", CVAR_TEMP );
	cl_shownet = Cvar_Get (""cl_shownet"", ""0"", CVAR_TEMP );
	cl_showSend = Cvar_Get (""cl_showSend"", ""0"", CVAR_TEMP );
	cl_showTimeDelta = Cvar_Get (""cl_showTimeDelta"", ""0"", CVAR_TEMP );
	cl_freezeDemo = Cvar_Get (""cl_freezeDemo"", ""0"", CVAR_TEMP );
	rcon_client_password = Cvar_Get (""rconPassword"", """", CVAR_TEMP );
	cl_activeAction = Cvar_Get( ""activeAction"", """", CVAR_TEMP );

	cl_timedemo = Cvar_Get (""timedemo"", ""0"", 0);
	cl_timedemoLog = Cvar_Get (""cl_timedemoLog"", """", CVAR_ARCHIVE);
	cl_autoRecordDemo = Cvar_Get (""cl_autoRecordDemo"", ""0"", CVAR_ARCHIVE);
	cl_aviFrameRate = Cvar_Get (""cl_aviFrameRate"", ""25"", CVAR_ARCHIVE);
	cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE);
	cl_forceavidemo = Cvar_Get (""cl_forceavidemo"", ""0"", 0);

	rconAddress = Cvar_Get (""rconAddress"", """", 0);

	cl_yawspeed = Cvar_Get (""cl_yawspeed"", ""140"", CVAR_ARCHIVE);
	cl_pitchspeed = Cvar_Get (""cl_pitchspeed"", ""140"", CVAR_ARCHIVE);
	cl_anglespeedkey = Cvar_Get (""cl_anglespeedkey"", ""1.5"", 0);

	cl_maxpackets = Cvar_Get (""cl_maxpackets"", ""30"", CVAR_ARCHIVE );
	cl_packetdup = Cvar_Get (""cl_packetdup"", ""1"", CVAR_ARCHIVE );

	cl_run = Cvar_Get (""cl_run"", ""1"", CVAR_ARCHIVE);
	cl_sensitivity = Cvar_Get (""sensitivity"", ""5"", CVAR_ARCHIVE);
	cl_mouseAccel = Cvar_Get (""cl_mouseAccel"", ""0"", CVAR_ARCHIVE);
	cl_freelook = Cvar_Get( ""cl_freelook"", ""1"", CVAR_ARCHIVE );

	cl_mouseAccelStyle = Cvar_Get( ""cl_mouseAccelStyle"", ""0"", CVAR_ARCHIVE );
	cl_mouseAccelOffset = Cvar_Get( ""cl_mouseAccelOffset"", ""5"", CVAR_ARCHIVE );
	Cvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);

	cl_showMouseRate = Cvar_Get (""cl_showmouserate"", ""0"", 0);
 
 	cl_allowDownload = Cvar_Get (""cl_allowDownload"", ""0"", CVAR_ARCHIVE);
 #ifdef USE_CURL_DLOPEN
	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
 #endif
 
 	cl_conXOffset = Cvar_Get (""cl_conXOffset"", ""0"", 0);
#ifdef __APPLE__
	cl_inGameVideo = Cvar_Get (""r_inGameVideo"", ""0"", CVAR_ARCHIVE);
#else
	cl_inGameVideo = Cvar_Get (""r_inGameVideo"", ""1"", CVAR_ARCHIVE);
#endif

	cl_serverStatusResendTime = Cvar_Get (""cl_serverStatusResendTime"", ""750"", 0);

	Cvar_Get (""cg_autoswitch"", ""1"", CVAR_ARCHIVE);

	m_pitch = Cvar_Get (""m_pitch"", ""0.022"", CVAR_ARCHIVE);
	m_yaw = Cvar_Get (""m_yaw"", ""0.022"", CVAR_ARCHIVE);
	m_forward = Cvar_Get (""m_forward"", ""0.25"", CVAR_ARCHIVE);
	m_side = Cvar_Get (""m_side"", ""0.25"", CVAR_ARCHIVE);
#ifdef __APPLE__
	m_filter = Cvar_Get (""m_filter"", ""1"", CVAR_ARCHIVE);
#else
	m_filter = Cvar_Get (""m_filter"", ""0"", CVAR_ARCHIVE);
#endif

	j_pitch =        Cvar_Get (""j_pitch"",        ""0.022"", CVAR_ARCHIVE);
	j_yaw =          Cvar_Get (""j_yaw"",          ""-0.022"", CVAR_ARCHIVE);
	j_forward =      Cvar_Get (""j_forward"",      ""-0.25"", CVAR_ARCHIVE);
	j_side =         Cvar_Get (""j_side"",         ""0.25"", CVAR_ARCHIVE);
	j_up =           Cvar_Get (""j_up"",           ""0"", CVAR_ARCHIVE);

	j_pitch_axis =   Cvar_Get (""j_pitch_axis"",   ""3"", CVAR_ARCHIVE);
	j_yaw_axis =     Cvar_Get (""j_yaw_axis"",     ""2"", CVAR_ARCHIVE);
	j_forward_axis = Cvar_Get (""j_forward_axis"", ""1"", CVAR_ARCHIVE);
	j_side_axis =    Cvar_Get (""j_side_axis"",    ""0"", CVAR_ARCHIVE);
	j_up_axis =      Cvar_Get (""j_up_axis"",      ""4"", CVAR_ARCHIVE);

	Cvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);

	cl_motdString = Cvar_Get( ""cl_motdString"", """", CVAR_ROM );

	Cvar_Get( ""cl_maxPing"", ""800"", CVAR_ARCHIVE );

	cl_lanForcePackets = Cvar_Get (""cl_lanForcePackets"", ""1"", CVAR_ARCHIVE);

	cl_guidServerUniq = Cvar_Get (""cl_guidServerUniq"", ""1"", CVAR_ARCHIVE);

	cl_consoleKeys = Cvar_Get( ""cl_consoleKeys"", ""~ ` 0x7e 0x60"", CVAR_ARCHIVE);

	Cvar_Get (""name"", ""UnnamedPlayer"", CVAR_USERINFO | CVAR_ARCHIVE );
	cl_rate = Cvar_Get (""rate"", ""25000"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""snaps"", ""20"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""model"", ""sarge"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""headmodel"", ""sarge"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""team_model"", ""james"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""team_headmodel"", ""*james"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""g_redTeam"", ""Stroggs"", CVAR_SERVERINFO | CVAR_ARCHIVE);
	Cvar_Get (""g_blueTeam"", ""Pagans"", CVAR_SERVERINFO | CVAR_ARCHIVE);
	Cvar_Get (""color1"",  ""4"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""color2"", ""5"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""handicap"", ""100"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""teamtask"", ""0"", CVAR_USERINFO );
	Cvar_Get (""sex"", ""male"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""cl_anonymous"", ""0"", CVAR_USERINFO | CVAR_ARCHIVE );

	Cvar_Get (""password"", """", CVAR_USERINFO);
	Cvar_Get (""cg_predictItems"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE );

#ifdef USE_MUMBLE
	cl_useMumble = Cvar_Get (""cl_useMumble"", ""0"", CVAR_ARCHIVE | CVAR_LATCH);
	cl_mumbleScale = Cvar_Get (""cl_mumbleScale"", ""0.0254"", CVAR_ARCHIVE);
#endif

#ifdef USE_VOIP
	cl_voipSend = Cvar_Get (""cl_voipSend"", ""0"", 0);
	cl_voipSendTarget = Cvar_Get (""cl_voipSendTarget"", ""spatial"", 0);
	cl_voipGainDuringCapture = Cvar_Get (""cl_voipGainDuringCapture"", ""0.2"", CVAR_ARCHIVE);
	cl_voipCaptureMult = Cvar_Get (""cl_voipCaptureMult"", ""2.0"", CVAR_ARCHIVE);
	cl_voipUseVAD = Cvar_Get (""cl_voipUseVAD"", ""0"", CVAR_ARCHIVE);
	cl_voipVADThreshold = Cvar_Get (""cl_voipVADThreshold"", ""0.25"", CVAR_ARCHIVE);
	cl_voipShowMeter = Cvar_Get (""cl_voipShowMeter"", ""1"", CVAR_ARCHIVE);

	cl_voip = Cvar_Get (""cl_voip"", ""1"", CVAR_ARCHIVE);
	Cvar_CheckRange( cl_voip, 0, 1, qtrue );
	cl_voipProtocol = Cvar_Get (""cl_voipProtocol"", cl_voip->integer ? ""opus"" : """", CVAR_USERINFO | CVAR_ROM);
#endif


	Cvar_Get (""cg_viewsize"", ""100"", CVAR_ARCHIVE );
	Cvar_Get (""cg_stereoSeparation"", ""0"", CVAR_ROM);

	Cmd_AddCommand (""cmd"", CL_ForwardToServer_f);
	Cmd_AddCommand (""configstrings"", CL_Configstrings_f);
	Cmd_AddCommand (""clientinfo"", CL_Clientinfo_f);
	Cmd_AddCommand (""snd_restart"", CL_Snd_Restart_f);
	Cmd_AddCommand (""vid_restart"", CL_Vid_Restart_f);
	Cmd_AddCommand (""disconnect"", CL_Disconnect_f);
	Cmd_AddCommand (""record"", CL_Record_f);
	Cmd_AddCommand (""demo"", CL_PlayDemo_f);
	Cmd_SetCommandCompletionFunc( ""demo"", CL_CompleteDemoName );
	Cmd_AddCommand (""cinematic"", CL_PlayCinematic_f);
	Cmd_AddCommand (""stoprecord"", CL_StopRecord_f);
	Cmd_AddCommand (""connect"", CL_Connect_f);
	Cmd_AddCommand (""reconnect"", CL_Reconnect_f);
	Cmd_AddCommand (""localservers"", CL_LocalServers_f);
	Cmd_AddCommand (""globalservers"", CL_GlobalServers_f);
	Cmd_AddCommand (""rcon"", CL_Rcon_f);
	Cmd_SetCommandCompletionFunc( ""rcon"", CL_CompleteRcon );
	Cmd_AddCommand (""ping"", CL_Ping_f );
	Cmd_AddCommand (""serverstatus"", CL_ServerStatus_f );
	Cmd_AddCommand (""showip"", CL_ShowIP_f );
	Cmd_AddCommand (""fs_openedList"", CL_OpenedPK3List_f );
	Cmd_AddCommand (""fs_referencedList"", CL_ReferencedPK3List_f );
	Cmd_AddCommand (""model"", CL_SetModel_f );
	Cmd_AddCommand (""video"", CL_Video_f );
	Cmd_AddCommand (""stopvideo"", CL_StopVideo_f );
	if( !com_dedicated->integer ) {
		Cmd_AddCommand (""sayto"", CL_Sayto_f );
		Cmd_SetCommandCompletionFunc( ""sayto"", CL_CompletePlayerName );
	}
	CL_InitRef();

	SCR_Init ();


	Cvar_Set( ""cl_running"", ""1"" );

	CL_GenerateQKey();
	Cvar_Get( ""cl_guid"", """", CVAR_USERINFO | CVAR_ROM );
	CL_UpdateGUID( NULL, 0 );

	Com_Printf( ""----- Client Initialization Complete -----\n"" );
}
","void CL_Init( void ) {
	Com_Printf( ""----- Client Initialization -----\n"" );

	Con_Init ();

	if(!com_fullyInitialized)
	{
		CL_ClearState();
		clc.state = CA_DISCONNECTED;	// no longer CA_UNINITIALIZED
		cl_oldGameSet = qfalse;
	}

	cls.realtime = 0;

	CL_InitInput ();

	cl_noprint = Cvar_Get( ""cl_noprint"", ""0"", 0 );
#ifdef UPDATE_SERVER_NAME
	cl_motd = Cvar_Get (""cl_motd"", ""1"", 0);
#endif

	cl_timeout = Cvar_Get (""cl_timeout"", ""200"", 0);

	cl_timeNudge = Cvar_Get (""cl_timeNudge"", ""0"", CVAR_TEMP );
	cl_shownet = Cvar_Get (""cl_shownet"", ""0"", CVAR_TEMP );
	cl_showSend = Cvar_Get (""cl_showSend"", ""0"", CVAR_TEMP );
	cl_showTimeDelta = Cvar_Get (""cl_showTimeDelta"", ""0"", CVAR_TEMP );
	cl_freezeDemo = Cvar_Get (""cl_freezeDemo"", ""0"", CVAR_TEMP );
	rcon_client_password = Cvar_Get (""rconPassword"", """", CVAR_TEMP );
	cl_activeAction = Cvar_Get( ""activeAction"", """", CVAR_TEMP );

	cl_timedemo = Cvar_Get (""timedemo"", ""0"", 0);
	cl_timedemoLog = Cvar_Get (""cl_timedemoLog"", """", CVAR_ARCHIVE);
	cl_autoRecordDemo = Cvar_Get (""cl_autoRecordDemo"", ""0"", CVAR_ARCHIVE);
	cl_aviFrameRate = Cvar_Get (""cl_aviFrameRate"", ""25"", CVAR_ARCHIVE);
	cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE);
	cl_forceavidemo = Cvar_Get (""cl_forceavidemo"", ""0"", 0);

	rconAddress = Cvar_Get (""rconAddress"", """", 0);

	cl_yawspeed = Cvar_Get (""cl_yawspeed"", ""140"", CVAR_ARCHIVE);
	cl_pitchspeed = Cvar_Get (""cl_pitchspeed"", ""140"", CVAR_ARCHIVE);
	cl_anglespeedkey = Cvar_Get (""cl_anglespeedkey"", ""1.5"", 0);

	cl_maxpackets = Cvar_Get (""cl_maxpackets"", ""30"", CVAR_ARCHIVE );
	cl_packetdup = Cvar_Get (""cl_packetdup"", ""1"", CVAR_ARCHIVE );

	cl_run = Cvar_Get (""cl_run"", ""1"", CVAR_ARCHIVE);
	cl_sensitivity = Cvar_Get (""sensitivity"", ""5"", CVAR_ARCHIVE);
	cl_mouseAccel = Cvar_Get (""cl_mouseAccel"", ""0"", CVAR_ARCHIVE);
	cl_freelook = Cvar_Get( ""cl_freelook"", ""1"", CVAR_ARCHIVE );

	cl_mouseAccelStyle = Cvar_Get( ""cl_mouseAccelStyle"", ""0"", CVAR_ARCHIVE );
	cl_mouseAccelOffset = Cvar_Get( ""cl_mouseAccelOffset"", ""5"", CVAR_ARCHIVE );
	Cvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);

	cl_showMouseRate = Cvar_Get (""cl_showmouserate"", ""0"", 0);
 
 	cl_allowDownload = Cvar_Get (""cl_allowDownload"", ""0"", CVAR_ARCHIVE);
 #ifdef USE_CURL_DLOPEN
	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);
 #endif
 
 	cl_conXOffset = Cvar_Get (""cl_conXOffset"", ""0"", 0);
#ifdef __APPLE__
	cl_inGameVideo = Cvar_Get (""r_inGameVideo"", ""0"", CVAR_ARCHIVE);
#else
	cl_inGameVideo = Cvar_Get (""r_inGameVideo"", ""1"", CVAR_ARCHIVE);
#endif

	cl_serverStatusResendTime = Cvar_Get (""cl_serverStatusResendTime"", ""750"", 0);

	Cvar_Get (""cg_autoswitch"", ""1"", CVAR_ARCHIVE);

	m_pitch = Cvar_Get (""m_pitch"", ""0.022"", CVAR_ARCHIVE);
	m_yaw = Cvar_Get (""m_yaw"", ""0.022"", CVAR_ARCHIVE);
	m_forward = Cvar_Get (""m_forward"", ""0.25"", CVAR_ARCHIVE);
	m_side = Cvar_Get (""m_side"", ""0.25"", CVAR_ARCHIVE);
#ifdef __APPLE__
	m_filter = Cvar_Get (""m_filter"", ""1"", CVAR_ARCHIVE);
#else
	m_filter = Cvar_Get (""m_filter"", ""0"", CVAR_ARCHIVE);
#endif

	j_pitch =        Cvar_Get (""j_pitch"",        ""0.022"", CVAR_ARCHIVE);
	j_yaw =          Cvar_Get (""j_yaw"",          ""-0.022"", CVAR_ARCHIVE);
	j_forward =      Cvar_Get (""j_forward"",      ""-0.25"", CVAR_ARCHIVE);
	j_side =         Cvar_Get (""j_side"",         ""0.25"", CVAR_ARCHIVE);
	j_up =           Cvar_Get (""j_up"",           ""0"", CVAR_ARCHIVE);

	j_pitch_axis =   Cvar_Get (""j_pitch_axis"",   ""3"", CVAR_ARCHIVE);
	j_yaw_axis =     Cvar_Get (""j_yaw_axis"",     ""2"", CVAR_ARCHIVE);
	j_forward_axis = Cvar_Get (""j_forward_axis"", ""1"", CVAR_ARCHIVE);
	j_side_axis =    Cvar_Get (""j_side_axis"",    ""0"", CVAR_ARCHIVE);
	j_up_axis =      Cvar_Get (""j_up_axis"",      ""4"", CVAR_ARCHIVE);

	Cvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);

	cl_motdString = Cvar_Get( ""cl_motdString"", """", CVAR_ROM );

	Cvar_Get( ""cl_maxPing"", ""800"", CVAR_ARCHIVE );

	cl_lanForcePackets = Cvar_Get (""cl_lanForcePackets"", ""1"", CVAR_ARCHIVE);

	cl_guidServerUniq = Cvar_Get (""cl_guidServerUniq"", ""1"", CVAR_ARCHIVE);

	cl_consoleKeys = Cvar_Get( ""cl_consoleKeys"", ""~ ` 0x7e 0x60"", CVAR_ARCHIVE);

	Cvar_Get (""name"", ""UnnamedPlayer"", CVAR_USERINFO | CVAR_ARCHIVE );
	cl_rate = Cvar_Get (""rate"", ""25000"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""snaps"", ""20"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""model"", ""sarge"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""headmodel"", ""sarge"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""team_model"", ""james"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""team_headmodel"", ""*james"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""g_redTeam"", ""Stroggs"", CVAR_SERVERINFO | CVAR_ARCHIVE);
	Cvar_Get (""g_blueTeam"", ""Pagans"", CVAR_SERVERINFO | CVAR_ARCHIVE);
	Cvar_Get (""color1"",  ""4"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""color2"", ""5"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""handicap"", ""100"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""teamtask"", ""0"", CVAR_USERINFO );
	Cvar_Get (""sex"", ""male"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""cl_anonymous"", ""0"", CVAR_USERINFO | CVAR_ARCHIVE );

	Cvar_Get (""password"", """", CVAR_USERINFO);
	Cvar_Get (""cg_predictItems"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE );

#ifdef USE_MUMBLE
	cl_useMumble = Cvar_Get (""cl_useMumble"", ""0"", CVAR_ARCHIVE | CVAR_LATCH);
	cl_mumbleScale = Cvar_Get (""cl_mumbleScale"", ""0.0254"", CVAR_ARCHIVE);
#endif

#ifdef USE_VOIP
	cl_voipSend = Cvar_Get (""cl_voipSend"", ""0"", 0);
	cl_voipSendTarget = Cvar_Get (""cl_voipSendTarget"", ""spatial"", 0);
	cl_voipGainDuringCapture = Cvar_Get (""cl_voipGainDuringCapture"", ""0.2"", CVAR_ARCHIVE);
	cl_voipCaptureMult = Cvar_Get (""cl_voipCaptureMult"", ""2.0"", CVAR_ARCHIVE);
	cl_voipUseVAD = Cvar_Get (""cl_voipUseVAD"", ""0"", CVAR_ARCHIVE);
	cl_voipVADThreshold = Cvar_Get (""cl_voipVADThreshold"", ""0.25"", CVAR_ARCHIVE);
	cl_voipShowMeter = Cvar_Get (""cl_voipShowMeter"", ""1"", CVAR_ARCHIVE);

	cl_voip = Cvar_Get (""cl_voip"", ""1"", CVAR_ARCHIVE);
	Cvar_CheckRange( cl_voip, 0, 1, qtrue );
	cl_voipProtocol = Cvar_Get (""cl_voipProtocol"", cl_voip->integer ? ""opus"" : """", CVAR_USERINFO | CVAR_ROM);
#endif


	Cvar_Get (""cg_viewsize"", ""100"", CVAR_ARCHIVE );
	Cvar_Get (""cg_stereoSeparation"", ""0"", CVAR_ROM);

	Cmd_AddCommand (""cmd"", CL_ForwardToServer_f);
	Cmd_AddCommand (""configstrings"", CL_Configstrings_f);
	Cmd_AddCommand (""clientinfo"", CL_Clientinfo_f);
	Cmd_AddCommand (""snd_restart"", CL_Snd_Restart_f);
	Cmd_AddCommand (""vid_restart"", CL_Vid_Restart_f);
	Cmd_AddCommand (""disconnect"", CL_Disconnect_f);
	Cmd_AddCommand (""record"", CL_Record_f);
	Cmd_AddCommand (""demo"", CL_PlayDemo_f);
	Cmd_SetCommandCompletionFunc( ""demo"", CL_CompleteDemoName );
	Cmd_AddCommand (""cinematic"", CL_PlayCinematic_f);
	Cmd_AddCommand (""stoprecord"", CL_StopRecord_f);
	Cmd_AddCommand (""connect"", CL_Connect_f);
	Cmd_AddCommand (""reconnect"", CL_Reconnect_f);
	Cmd_AddCommand (""localservers"", CL_LocalServers_f);
	Cmd_AddCommand (""globalservers"", CL_GlobalServers_f);
	Cmd_AddCommand (""rcon"", CL_Rcon_f);
	Cmd_SetCommandCompletionFunc( ""rcon"", CL_CompleteRcon );
	Cmd_AddCommand (""ping"", CL_Ping_f );
	Cmd_AddCommand (""serverstatus"", CL_ServerStatus_f );
	Cmd_AddCommand (""showip"", CL_ShowIP_f );
	Cmd_AddCommand (""fs_openedList"", CL_OpenedPK3List_f );
	Cmd_AddCommand (""fs_referencedList"", CL_ReferencedPK3List_f );
	Cmd_AddCommand (""model"", CL_SetModel_f );
	Cmd_AddCommand (""video"", CL_Video_f );
	Cmd_AddCommand (""stopvideo"", CL_StopVideo_f );
	if( !com_dedicated->integer ) {
		Cmd_AddCommand (""sayto"", CL_Sayto_f );
		Cmd_SetCommandCompletionFunc( ""sayto"", CL_CompletePlayerName );
	}
	CL_InitRef();

	SCR_Init ();


	Cvar_Set( ""cl_running"", ""1"" );

	CL_GenerateQKey();
	Cvar_Get( ""cl_guid"", """", CVAR_USERINFO | CVAR_ROM );
	CL_UpdateGUID( NULL, 0 );

	Com_Printf( ""----- Client Initialization Complete -----\n"" );
}
",C,"	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
","	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);
",,"@@ -3200,7 +3200,7 @@ void CL_InitRef( void ) {
 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
-	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl2"", CVAR_ARCHIVE | CVAR_LATCH);
+	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl2"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
@@ -3551,7 +3551,7 @@ void CL_Init( void ) {
 
 	cl_allowDownload = Cvar_Get (""cl_allowDownload"", ""0"", CVAR_ARCHIVE);
 #ifdef USE_CURL_DLOPEN
-	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);
+	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
 #endif
 
 	cl_conXOffset = Cvar_Get (""cl_conXOffset"", ""0"", 0);",OpenJK,376267d534476a875d8b9228149c4ee18b74a4fd,cd41690fc3a9e28b5d22be473cc8ba8270a570b2,1,"void CL_Init( void ) {
	Com_Printf( ""----- Client Initialization -----\n"" );

	Con_Init ();

	if(!com_fullyInitialized)
	{
		CL_ClearState();
		clc.state = CA_DISCONNECTED;	// no longer CA_UNINITIALIZED
		cl_oldGameSet = qfalse;
	}

	cls.realtime = 0;

	CL_InitInput ();

	//
	// register our variables
	//
	cl_noprint = Cvar_Get( ""cl_noprint"", ""0"", 0 );
#ifdef UPDATE_SERVER_NAME
	cl_motd = Cvar_Get (""cl_motd"", ""1"", 0);
#endif

	cl_timeout = Cvar_Get (""cl_timeout"", ""200"", 0);

	cl_timeNudge = Cvar_Get (""cl_timeNudge"", ""0"", CVAR_TEMP );
	cl_shownet = Cvar_Get (""cl_shownet"", ""0"", CVAR_TEMP );
	cl_showSend = Cvar_Get (""cl_showSend"", ""0"", CVAR_TEMP );
	cl_showTimeDelta = Cvar_Get (""cl_showTimeDelta"", ""0"", CVAR_TEMP );
	cl_freezeDemo = Cvar_Get (""cl_freezeDemo"", ""0"", CVAR_TEMP );
	rcon_client_password = Cvar_Get (""rconPassword"", """", CVAR_TEMP );
	cl_activeAction = Cvar_Get( ""activeAction"", """", CVAR_TEMP );

	cl_timedemo = Cvar_Get (""timedemo"", ""0"", 0);
	cl_timedemoLog = Cvar_Get (""cl_timedemoLog"", """", CVAR_ARCHIVE);
	cl_autoRecordDemo = Cvar_Get (""cl_autoRecordDemo"", ""0"", CVAR_ARCHIVE);
	cl_aviFrameRate = Cvar_Get (""cl_aviFrameRate"", ""25"", CVAR_ARCHIVE);
	cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE);
	cl_forceavidemo = Cvar_Get (""cl_forceavidemo"", ""0"", 0);

	rconAddress = Cvar_Get (""rconAddress"", """", 0);

	cl_yawspeed = Cvar_Get (""cl_yawspeed"", ""140"", CVAR_ARCHIVE);
	cl_pitchspeed = Cvar_Get (""cl_pitchspeed"", ""140"", CVAR_ARCHIVE);
	cl_anglespeedkey = Cvar_Get (""cl_anglespeedkey"", ""1.5"", 0);

	cl_maxpackets = Cvar_Get (""cl_maxpackets"", ""30"", CVAR_ARCHIVE );
	cl_packetdup = Cvar_Get (""cl_packetdup"", ""1"", CVAR_ARCHIVE );

	cl_run = Cvar_Get (""cl_run"", ""1"", CVAR_ARCHIVE);
	cl_sensitivity = Cvar_Get (""sensitivity"", ""5"", CVAR_ARCHIVE);
	cl_mouseAccel = Cvar_Get (""cl_mouseAccel"", ""0"", CVAR_ARCHIVE);
	cl_freelook = Cvar_Get( ""cl_freelook"", ""1"", CVAR_ARCHIVE );

	// 0: legacy mouse acceleration
	// 1: new implementation
	cl_mouseAccelStyle = Cvar_Get( ""cl_mouseAccelStyle"", ""0"", CVAR_ARCHIVE );
	// offset for the power function (for style 1, ignored otherwise)
	// this should be set to the max rate value
	cl_mouseAccelOffset = Cvar_Get( ""cl_mouseAccelOffset"", ""5"", CVAR_ARCHIVE );
	Cvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);

	cl_showMouseRate = Cvar_Get (""cl_showmouserate"", ""0"", 0);
 
 	cl_allowDownload = Cvar_Get (""cl_allowDownload"", ""0"", CVAR_ARCHIVE);
 #ifdef USE_CURL_DLOPEN
//flaw_line_below:
	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);
//fix_flaw_line_below:
//	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
 #endif
 
 	cl_conXOffset = Cvar_Get (""cl_conXOffset"", ""0"", 0);
#ifdef __APPLE__
	// In game video is REALLY slow in Mac OS X right now due to driver slowness
	cl_inGameVideo = Cvar_Get (""r_inGameVideo"", ""0"", CVAR_ARCHIVE);
#else
	cl_inGameVideo = Cvar_Get (""r_inGameVideo"", ""1"", CVAR_ARCHIVE);
#endif

	cl_serverStatusResendTime = Cvar_Get (""cl_serverStatusResendTime"", ""750"", 0);

	// init autoswitch so the ui will have it correctly even
	// if the cgame hasn't been started
	Cvar_Get (""cg_autoswitch"", ""1"", CVAR_ARCHIVE);

	m_pitch = Cvar_Get (""m_pitch"", ""0.022"", CVAR_ARCHIVE);
	m_yaw = Cvar_Get (""m_yaw"", ""0.022"", CVAR_ARCHIVE);
	m_forward = Cvar_Get (""m_forward"", ""0.25"", CVAR_ARCHIVE);
	m_side = Cvar_Get (""m_side"", ""0.25"", CVAR_ARCHIVE);
#ifdef __APPLE__
	// Input is jittery on OS X w/o this
	m_filter = Cvar_Get (""m_filter"", ""1"", CVAR_ARCHIVE);
#else
	m_filter = Cvar_Get (""m_filter"", ""0"", CVAR_ARCHIVE);
#endif

	j_pitch =        Cvar_Get (""j_pitch"",        ""0.022"", CVAR_ARCHIVE);
	j_yaw =          Cvar_Get (""j_yaw"",          ""-0.022"", CVAR_ARCHIVE);
	j_forward =      Cvar_Get (""j_forward"",      ""-0.25"", CVAR_ARCHIVE);
	j_side =         Cvar_Get (""j_side"",         ""0.25"", CVAR_ARCHIVE);
	j_up =           Cvar_Get (""j_up"",           ""0"", CVAR_ARCHIVE);

	j_pitch_axis =   Cvar_Get (""j_pitch_axis"",   ""3"", CVAR_ARCHIVE);
	j_yaw_axis =     Cvar_Get (""j_yaw_axis"",     ""2"", CVAR_ARCHIVE);
	j_forward_axis = Cvar_Get (""j_forward_axis"", ""1"", CVAR_ARCHIVE);
	j_side_axis =    Cvar_Get (""j_side_axis"",    ""0"", CVAR_ARCHIVE);
	j_up_axis =      Cvar_Get (""j_up_axis"",      ""4"", CVAR_ARCHIVE);

	Cvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);
	Cvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);

	cl_motdString = Cvar_Get( ""cl_motdString"", """", CVAR_ROM );

	Cvar_Get( ""cl_maxPing"", ""800"", CVAR_ARCHIVE );

	cl_lanForcePackets = Cvar_Get (""cl_lanForcePackets"", ""1"", CVAR_ARCHIVE);

	cl_guidServerUniq = Cvar_Get (""cl_guidServerUniq"", ""1"", CVAR_ARCHIVE);

	// ~ and `, as keys and characters
	cl_consoleKeys = Cvar_Get( ""cl_consoleKeys"", ""~ ` 0x7e 0x60"", CVAR_ARCHIVE);

	// userinfo
	Cvar_Get (""name"", ""UnnamedPlayer"", CVAR_USERINFO | CVAR_ARCHIVE );
	cl_rate = Cvar_Get (""rate"", ""25000"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""snaps"", ""20"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""model"", ""sarge"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""headmodel"", ""sarge"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""team_model"", ""james"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""team_headmodel"", ""*james"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""g_redTeam"", ""Stroggs"", CVAR_SERVERINFO | CVAR_ARCHIVE);
	Cvar_Get (""g_blueTeam"", ""Pagans"", CVAR_SERVERINFO | CVAR_ARCHIVE);
	Cvar_Get (""color1"",  ""4"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""color2"", ""5"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""handicap"", ""100"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""teamtask"", ""0"", CVAR_USERINFO );
	Cvar_Get (""sex"", ""male"", CVAR_USERINFO | CVAR_ARCHIVE );
	Cvar_Get (""cl_anonymous"", ""0"", CVAR_USERINFO | CVAR_ARCHIVE );

	Cvar_Get (""password"", """", CVAR_USERINFO);
	Cvar_Get (""cg_predictItems"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE );

#ifdef USE_MUMBLE
	cl_useMumble = Cvar_Get (""cl_useMumble"", ""0"", CVAR_ARCHIVE | CVAR_LATCH);
	cl_mumbleScale = Cvar_Get (""cl_mumbleScale"", ""0.0254"", CVAR_ARCHIVE);
#endif

#ifdef USE_VOIP
	cl_voipSend = Cvar_Get (""cl_voipSend"", ""0"", 0);
	cl_voipSendTarget = Cvar_Get (""cl_voipSendTarget"", ""spatial"", 0);
	cl_voipGainDuringCapture = Cvar_Get (""cl_voipGainDuringCapture"", ""0.2"", CVAR_ARCHIVE);
	cl_voipCaptureMult = Cvar_Get (""cl_voipCaptureMult"", ""2.0"", CVAR_ARCHIVE);
	cl_voipUseVAD = Cvar_Get (""cl_voipUseVAD"", ""0"", CVAR_ARCHIVE);
	cl_voipVADThreshold = Cvar_Get (""cl_voipVADThreshold"", ""0.25"", CVAR_ARCHIVE);
	cl_voipShowMeter = Cvar_Get (""cl_voipShowMeter"", ""1"", CVAR_ARCHIVE);

	cl_voip = Cvar_Get (""cl_voip"", ""1"", CVAR_ARCHIVE);
	Cvar_CheckRange( cl_voip, 0, 1, qtrue );
	cl_voipProtocol = Cvar_Get (""cl_voipProtocol"", cl_voip->integer ? ""opus"" : """", CVAR_USERINFO | CVAR_ROM);
#endif


	// cgame might not be initialized before menu is used
	Cvar_Get (""cg_viewsize"", ""100"", CVAR_ARCHIVE );
	// Make sure cg_stereoSeparation is zero as that variable is deprecated and should not be used anymore.
	Cvar_Get (""cg_stereoSeparation"", ""0"", CVAR_ROM);

	//
	// register our commands
	//
	Cmd_AddCommand (""cmd"", CL_ForwardToServer_f);
	Cmd_AddCommand (""configstrings"", CL_Configstrings_f);
	Cmd_AddCommand (""clientinfo"", CL_Clientinfo_f);
	Cmd_AddCommand (""snd_restart"", CL_Snd_Restart_f);
	Cmd_AddCommand (""vid_restart"", CL_Vid_Restart_f);
	Cmd_AddCommand (""disconnect"", CL_Disconnect_f);
	Cmd_AddCommand (""record"", CL_Record_f);
	Cmd_AddCommand (""demo"", CL_PlayDemo_f);
	Cmd_SetCommandCompletionFunc( ""demo"", CL_CompleteDemoName );
	Cmd_AddCommand (""cinematic"", CL_PlayCinematic_f);
	Cmd_AddCommand (""stoprecord"", CL_StopRecord_f);
	Cmd_AddCommand (""connect"", CL_Connect_f);
	Cmd_AddCommand (""reconnect"", CL_Reconnect_f);
	Cmd_AddCommand (""localservers"", CL_LocalServers_f);
	Cmd_AddCommand (""globalservers"", CL_GlobalServers_f);
	Cmd_AddCommand (""rcon"", CL_Rcon_f);
	Cmd_SetCommandCompletionFunc( ""rcon"", CL_CompleteRcon );
	Cmd_AddCommand (""ping"", CL_Ping_f );
	Cmd_AddCommand (""serverstatus"", CL_ServerStatus_f );
	Cmd_AddCommand (""showip"", CL_ShowIP_f );
	Cmd_AddCommand (""fs_openedList"", CL_OpenedPK3List_f );
	Cmd_AddCommand (""fs_referencedList"", CL_ReferencedPK3List_f );
	Cmd_AddCommand (""model"", CL_SetModel_f );
	Cmd_AddCommand (""video"", CL_Video_f );
	Cmd_AddCommand (""stopvideo"", CL_StopVideo_f );
	if( !com_dedicated->integer ) {
		Cmd_AddCommand (""sayto"", CL_Sayto_f );
		Cmd_SetCommandCompletionFunc( ""sayto"", CL_CompletePlayerName );
	}
	CL_InitRef();

	SCR_Init ();

//	Cbuf_Execute ();

	Cvar_Set( ""cl_running"", ""1"" );

	CL_GenerateQKey();
	Cvar_Get( ""cl_guid"", """", CVAR_USERINFO | CVAR_ROM );
	CL_UpdateGUID( NULL, 0 );

	Com_Printf( ""----- Client Initialization Complete -----\n"" );
}
"
5525,183261,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,1,https://github.com/ioquake/ioq3/commit/376267d534476a875d8b9228149c4ee18b74a4fd,376267d534476a875d8b9228149c4ee18b74a4fd,"Don't load .pk3s as .dlls, and don't load user config files from .pk3s.",1,code/client/cl_main.c,"{""sha"": ""31dd9ab78256ce40d223bf810cd731de90f7e4bd"", ""filename"": ""code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/ioquake/ioq3/blob/376267d534476a875d8b9228149c4ee18b74a4fd/code/client/cl_main.c"", ""raw_url"": ""https://github.com/ioquake/ioq3/raw/376267d534476a875d8b9228149c4ee18b74a4fd/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/ioquake/ioq3/contents/code/client/cl_main.c?ref=376267d534476a875d8b9228149c4ee18b74a4fd"", ""patch"": ""@@ -3200,7 +3200,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl2\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl2\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -3551,7 +3551,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get (\""cl_allowDownload\"", \""0\"", CVAR_ARCHIVE);\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \tcl_conXOffset = Cvar_Get (\""cl_conXOffset\"", \""0\"", 0);""}<_**next**_>{""sha"": ""27f5713de1c2944b2e972b8e784f4c80961362d3"", ""filename"": ""code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/ioquake/ioq3/blob/376267d534476a875d8b9228149c4ee18b74a4fd/code/qcommon/files.c"", ""raw_url"": ""https://github.com/ioquake/ioq3/raw/376267d534476a875d8b9228149c4ee18b74a4fd/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/ioquake/ioq3/contents/code/qcommon/files.c?ref=376267d534476a875d8b9228149c4ee18b74a4fd"", ""patch"": ""@@ -1364,12 +1364,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and q3config.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t\tlen = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \n \t\tif(file == NULL)""}<_**next**_>{""sha"": ""6d7fe7bf95841033d3df50d5f5488a5f73437a88"", ""filename"": ""code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/ioquake/ioq3/blob/376267d534476a875d8b9228149c4ee18b74a4fd/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/ioquake/ioq3/raw/376267d534476a875d8b9228149c4ee18b74a4fd/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/ioquake/ioq3/contents/code/sys/sys_main.c?ref=376267d534476a875d8b9228149c4ee18b74a4fd"", ""patch"": ""@@ -500,6 +500,13 @@ void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n \t\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n+\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);\n \t""}","void CL_InitRef( void ) {
	refimport_t	ri;
	refexport_t	*ret;
#ifdef USE_RENDERER_DLOPEN
	GetRefAPI_t		GetRefAPI;
	char			dllName[MAX_OSPATH];
#endif

 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl2"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
	if(!(rendererLib = Sys_LoadDll(dllName, qfalse)) && strcmp(cl_renderer->string, cl_renderer->resetString))
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Cvar_ForceReset(""cl_renderer"");

		Com_sprintf(dllName, sizeof(dllName), ""renderer_opengl2_"" ARCH_STRING DLL_EXT);
		rendererLib = Sys_LoadDll(dllName, qfalse);
	}

	if(!rendererLib)
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Com_Error(ERR_FATAL, ""Failed to load renderer"");
	}

	GetRefAPI = Sys_LoadFunction(rendererLib, ""GetRefAPI"");
	if(!GetRefAPI)
	{
		Com_Error(ERR_FATAL, ""Can't load symbol GetRefAPI: '%s'"",  Sys_LibraryError());
	}
#endif

	ri.Cmd_AddCommand = Cmd_AddCommand;
	ri.Cmd_RemoveCommand = Cmd_RemoveCommand;
	ri.Cmd_Argc = Cmd_Argc;
	ri.Cmd_Argv = Cmd_Argv;
	ri.Cmd_ExecuteText = Cbuf_ExecuteText;
	ri.Printf = CL_RefPrintf;
	ri.Error = Com_Error;
	ri.Milliseconds = CL_ScaledMilliseconds;
	ri.Malloc = CL_RefMalloc;
	ri.Free = Z_Free;
#ifdef HUNK_DEBUG
	ri.Hunk_AllocDebug = Hunk_AllocDebug;
#else
	ri.Hunk_Alloc = Hunk_Alloc;
#endif
	ri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory;
	ri.Hunk_FreeTempMemory = Hunk_FreeTempMemory;

	ri.CM_ClusterPVS = CM_ClusterPVS;
	ri.CM_DrawDebugSurface = CM_DrawDebugSurface;

	ri.FS_ReadFile = FS_ReadFile;
	ri.FS_FreeFile = FS_FreeFile;
	ri.FS_WriteFile = FS_WriteFile;
	ri.FS_FreeFileList = FS_FreeFileList;
	ri.FS_ListFiles = FS_ListFiles;
	ri.FS_FileIsInPAK = FS_FileIsInPAK;
	ri.FS_FileExists = FS_FileExists;
	ri.Cvar_Get = Cvar_Get;
	ri.Cvar_Set = Cvar_Set;
	ri.Cvar_SetValue = Cvar_SetValue;
	ri.Cvar_CheckRange = Cvar_CheckRange;
	ri.Cvar_SetDescription = Cvar_SetDescription;
	ri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue;


	ri.CIN_UploadCinematic = CIN_UploadCinematic;
	ri.CIN_PlayCinematic = CIN_PlayCinematic;
	ri.CIN_RunCinematic = CIN_RunCinematic;
  
	ri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame;

	ri.IN_Init = IN_Init;
	ri.IN_Shutdown = IN_Shutdown;
	ri.IN_Restart = IN_Restart;

	ri.ftol = Q_ftol;

	ri.Sys_SetEnv = Sys_SetEnv;
	ri.Sys_GLimpSafeInit = Sys_GLimpSafeInit;
	ri.Sys_GLimpInit = Sys_GLimpInit;
	ri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory;

	ret = GetRefAPI( REF_API_VERSION, &ri );

#if defined __USEA3D && defined __A3D_GEOM
	hA3Dg_ExportRenderGeom (ret);
#endif

	Com_Printf( ""-------------------------------\n"");

	if ( !ret ) {
		Com_Error (ERR_FATAL, ""Couldn't initialize refresh"" );
	}

	re = *ret;

	Cvar_Set( ""cl_paused"", ""0"" );
}
","void CL_InitRef( void ) {
	refimport_t	ri;
	refexport_t	*ret;
#ifdef USE_RENDERER_DLOPEN
	GetRefAPI_t		GetRefAPI;
	char			dllName[MAX_OSPATH];
#endif

 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl2"", CVAR_ARCHIVE | CVAR_LATCH);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
	if(!(rendererLib = Sys_LoadDll(dllName, qfalse)) && strcmp(cl_renderer->string, cl_renderer->resetString))
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Cvar_ForceReset(""cl_renderer"");

		Com_sprintf(dllName, sizeof(dllName), ""renderer_opengl2_"" ARCH_STRING DLL_EXT);
		rendererLib = Sys_LoadDll(dllName, qfalse);
	}

	if(!rendererLib)
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Com_Error(ERR_FATAL, ""Failed to load renderer"");
	}

	GetRefAPI = Sys_LoadFunction(rendererLib, ""GetRefAPI"");
	if(!GetRefAPI)
	{
		Com_Error(ERR_FATAL, ""Can't load symbol GetRefAPI: '%s'"",  Sys_LibraryError());
	}
#endif

	ri.Cmd_AddCommand = Cmd_AddCommand;
	ri.Cmd_RemoveCommand = Cmd_RemoveCommand;
	ri.Cmd_Argc = Cmd_Argc;
	ri.Cmd_Argv = Cmd_Argv;
	ri.Cmd_ExecuteText = Cbuf_ExecuteText;
	ri.Printf = CL_RefPrintf;
	ri.Error = Com_Error;
	ri.Milliseconds = CL_ScaledMilliseconds;
	ri.Malloc = CL_RefMalloc;
	ri.Free = Z_Free;
#ifdef HUNK_DEBUG
	ri.Hunk_AllocDebug = Hunk_AllocDebug;
#else
	ri.Hunk_Alloc = Hunk_Alloc;
#endif
	ri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory;
	ri.Hunk_FreeTempMemory = Hunk_FreeTempMemory;

	ri.CM_ClusterPVS = CM_ClusterPVS;
	ri.CM_DrawDebugSurface = CM_DrawDebugSurface;

	ri.FS_ReadFile = FS_ReadFile;
	ri.FS_FreeFile = FS_FreeFile;
	ri.FS_WriteFile = FS_WriteFile;
	ri.FS_FreeFileList = FS_FreeFileList;
	ri.FS_ListFiles = FS_ListFiles;
	ri.FS_FileIsInPAK = FS_FileIsInPAK;
	ri.FS_FileExists = FS_FileExists;
	ri.Cvar_Get = Cvar_Get;
	ri.Cvar_Set = Cvar_Set;
	ri.Cvar_SetValue = Cvar_SetValue;
	ri.Cvar_CheckRange = Cvar_CheckRange;
	ri.Cvar_SetDescription = Cvar_SetDescription;
	ri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue;


	ri.CIN_UploadCinematic = CIN_UploadCinematic;
	ri.CIN_PlayCinematic = CIN_PlayCinematic;
	ri.CIN_RunCinematic = CIN_RunCinematic;
  
	ri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame;

	ri.IN_Init = IN_Init;
	ri.IN_Shutdown = IN_Shutdown;
	ri.IN_Restart = IN_Restart;

	ri.ftol = Q_ftol;

	ri.Sys_SetEnv = Sys_SetEnv;
	ri.Sys_GLimpSafeInit = Sys_GLimpSafeInit;
	ri.Sys_GLimpInit = Sys_GLimpInit;
	ri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory;

	ret = GetRefAPI( REF_API_VERSION, &ri );

#if defined __USEA3D && defined __A3D_GEOM
	hA3Dg_ExportRenderGeom (ret);
#endif

	Com_Printf( ""-------------------------------\n"");

	if ( !ret ) {
		Com_Error (ERR_FATAL, ""Couldn't initialize refresh"" );
	}

	re = *ret;

	Cvar_Set( ""cl_paused"", ""0"" );
}
",C,"	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl2"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
","	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl2"", CVAR_ARCHIVE | CVAR_LATCH);
",,"@@ -3200,7 +3200,7 @@ void CL_InitRef( void ) {
 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
-	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl2"", CVAR_ARCHIVE | CVAR_LATCH);
+	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl2"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
@@ -3551,7 +3551,7 @@ void CL_Init( void ) {
 
 	cl_allowDownload = Cvar_Get (""cl_allowDownload"", ""0"", CVAR_ARCHIVE);
 #ifdef USE_CURL_DLOPEN
-	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);
+	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
 #endif
 
 	cl_conXOffset = Cvar_Get (""cl_conXOffset"", ""0"", 0);",OpenJK,376267d534476a875d8b9228149c4ee18b74a4fd,cd41690fc3a9e28b5d22be473cc8ba8270a570b2,1,"void CL_InitRef( void ) {
	refimport_t	ri;
	refexport_t	*ret;
#ifdef USE_RENDERER_DLOPEN
	GetRefAPI_t		GetRefAPI;
	char			dllName[MAX_OSPATH];
#endif

 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
//flaw_line_below:
	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl2"", CVAR_ARCHIVE | CVAR_LATCH);
//fix_flaw_line_below:
//	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl2"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
	if(!(rendererLib = Sys_LoadDll(dllName, qfalse)) && strcmp(cl_renderer->string, cl_renderer->resetString))
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Cvar_ForceReset(""cl_renderer"");

		Com_sprintf(dllName, sizeof(dllName), ""renderer_opengl2_"" ARCH_STRING DLL_EXT);
		rendererLib = Sys_LoadDll(dllName, qfalse);
	}

	if(!rendererLib)
	{
		Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError());
		Com_Error(ERR_FATAL, ""Failed to load renderer"");
	}

	GetRefAPI = Sys_LoadFunction(rendererLib, ""GetRefAPI"");
	if(!GetRefAPI)
	{
		Com_Error(ERR_FATAL, ""Can't load symbol GetRefAPI: '%s'"",  Sys_LibraryError());
	}
#endif

	ri.Cmd_AddCommand = Cmd_AddCommand;
	ri.Cmd_RemoveCommand = Cmd_RemoveCommand;
	ri.Cmd_Argc = Cmd_Argc;
	ri.Cmd_Argv = Cmd_Argv;
	ri.Cmd_ExecuteText = Cbuf_ExecuteText;
	ri.Printf = CL_RefPrintf;
	ri.Error = Com_Error;
	ri.Milliseconds = CL_ScaledMilliseconds;
	ri.Malloc = CL_RefMalloc;
	ri.Free = Z_Free;
#ifdef HUNK_DEBUG
	ri.Hunk_AllocDebug = Hunk_AllocDebug;
#else
	ri.Hunk_Alloc = Hunk_Alloc;
#endif
	ri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory;
	ri.Hunk_FreeTempMemory = Hunk_FreeTempMemory;

	ri.CM_ClusterPVS = CM_ClusterPVS;
	ri.CM_DrawDebugSurface = CM_DrawDebugSurface;

	ri.FS_ReadFile = FS_ReadFile;
	ri.FS_FreeFile = FS_FreeFile;
	ri.FS_WriteFile = FS_WriteFile;
	ri.FS_FreeFileList = FS_FreeFileList;
	ri.FS_ListFiles = FS_ListFiles;
	ri.FS_FileIsInPAK = FS_FileIsInPAK;
	ri.FS_FileExists = FS_FileExists;
	ri.Cvar_Get = Cvar_Get;
	ri.Cvar_Set = Cvar_Set;
	ri.Cvar_SetValue = Cvar_SetValue;
	ri.Cvar_CheckRange = Cvar_CheckRange;
	ri.Cvar_SetDescription = Cvar_SetDescription;
	ri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue;

	// cinematic stuff

	ri.CIN_UploadCinematic = CIN_UploadCinematic;
	ri.CIN_PlayCinematic = CIN_PlayCinematic;
	ri.CIN_RunCinematic = CIN_RunCinematic;
  
	ri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame;

	ri.IN_Init = IN_Init;
	ri.IN_Shutdown = IN_Shutdown;
	ri.IN_Restart = IN_Restart;

	ri.ftol = Q_ftol;

	ri.Sys_SetEnv = Sys_SetEnv;
	ri.Sys_GLimpSafeInit = Sys_GLimpSafeInit;
	ri.Sys_GLimpInit = Sys_GLimpInit;
	ri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory;

	ret = GetRefAPI( REF_API_VERSION, &ri );

#if defined __USEA3D && defined __A3D_GEOM
	hA3Dg_ExportRenderGeom (ret);
#endif

	Com_Printf( ""-------------------------------\n"");

	if ( !ret ) {
		Com_Error (ERR_FATAL, ""Couldn't initialize refresh"" );
	}

	re = *ret;

	// unpause so the cgame definately gets a snapshot and renders a frame
	Cvar_Set( ""cl_paused"", ""0"" );
}
"
5526,183262,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,7,https://github.com/ioquake/ioq3/commit/376267d534476a875d8b9228149c4ee18b74a4fd,376267d534476a875d8b9228149c4ee18b74a4fd,"Don't load .pk3s as .dlls, and don't load user config files from .pk3s.",0,code/sys/sys_main.c,"{""sha"": ""31dd9ab78256ce40d223bf810cd731de90f7e4bd"", ""filename"": ""code/client/cl_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/ioquake/ioq3/blob/376267d534476a875d8b9228149c4ee18b74a4fd/code/client/cl_main.c"", ""raw_url"": ""https://github.com/ioquake/ioq3/raw/376267d534476a875d8b9228149c4ee18b74a4fd/code/client/cl_main.c"", ""contents_url"": ""https://api.github.com/repos/ioquake/ioq3/contents/code/client/cl_main.c?ref=376267d534476a875d8b9228149c4ee18b74a4fd"", ""patch"": ""@@ -3200,7 +3200,7 @@ void CL_InitRef( void ) {\n \tCom_Printf( \""----- Initializing Renderer ----\\n\"" );\n \n #ifdef USE_RENDERER_DLOPEN\n-\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl2\"", CVAR_ARCHIVE | CVAR_LATCH);\n+\tcl_renderer = Cvar_Get(\""cl_renderer\"", \""opengl2\"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \""renderer_%s_\"" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n@@ -3551,7 +3551,7 @@ void CL_Init( void ) {\n \n \tcl_allowDownload = Cvar_Get (\""cl_allowDownload\"", \""0\"", CVAR_ARCHIVE);\n #ifdef USE_CURL_DLOPEN\n-\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n+\tcl_cURLLib = Cvar_Get(\""cl_cURLLib\"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n \tcl_conXOffset = Cvar_Get (\""cl_conXOffset\"", \""0\"", 0);""}<_**next**_>{""sha"": ""27f5713de1c2944b2e972b8e784f4c80961362d3"", ""filename"": ""code/qcommon/files.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/ioquake/ioq3/blob/376267d534476a875d8b9228149c4ee18b74a4fd/code/qcommon/files.c"", ""raw_url"": ""https://github.com/ioquake/ioq3/raw/376267d534476a875d8b9228149c4ee18b74a4fd/code/qcommon/files.c"", ""contents_url"": ""https://api.github.com/repos/ioquake/ioq3/contents/code/qcommon/files.c?ref=376267d534476a875d8b9228149c4ee18b74a4fd"", ""patch"": ""@@ -1364,12 +1364,18 @@ long FS_FOpenFileRead(const char *filename, fileHandle_t *file, qboolean uniqueF\n {\n \tsearchpath_t *search;\n \tlong len;\n+\tqboolean isLocalConfig;\n \n \tif(!fs_searchpaths)\n \t\tCom_Error(ERR_FATAL, \""Filesystem call made without initialization\"");\n \n+\tisLocalConfig = !strcmp(filename, \""autoexec.cfg\"") || !strcmp(filename, Q3CONFIG_CFG);\n \tfor(search = fs_searchpaths; search; search = search->next)\n \t{\n+\t\t// autoexec.cfg and q3config.cfg can only be loaded outside of pk3 files.\n+\t\tif (isLocalConfig && search->pack)\n+\t\t\tcontinue;\n+\n \t\tlen = FS_FOpenFileReadDir(filename, search, file, uniqueFILE, qfalse);\n \n \t\tif(file == NULL)""}<_**next**_>{""sha"": ""6d7fe7bf95841033d3df50d5f5488a5f73437a88"", ""filename"": ""code/sys/sys_main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/ioquake/ioq3/blob/376267d534476a875d8b9228149c4ee18b74a4fd/code/sys/sys_main.c"", ""raw_url"": ""https://github.com/ioquake/ioq3/raw/376267d534476a875d8b9228149c4ee18b74a4fd/code/sys/sys_main.c"", ""contents_url"": ""https://api.github.com/repos/ioquake/ioq3/contents/code/sys/sys_main.c?ref=376267d534476a875d8b9228149c4ee18b74a4fd"", ""patch"": ""@@ -500,6 +500,13 @@ void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n \t\n+\t// Don't load any DLLs that end with the pk3 extension\n+\tif (COM_CompareExtension(name, \"".pk3\""))\n+\t{\n+\t\tCom_Printf(\""Rejecting DLL named \\\""%s\\\""\"", name);\n+\t\treturn NULL;\n+\t}\n+\n \tif(useSystemLib)\n \t\tCom_Printf(\""Trying to load \\\""%s\\\""...\\n\"", name);\n \t""}","void *Sys_LoadDll(const char *name, qboolean useSystemLib)
 {
 	void *dllhandle;
 	
	// Don't load any DLLs that end with the pk3 extension
	if (COM_CompareExtension(name, "".pk3""))
	{
		Com_Printf(""Rejecting DLL named \""%s\"""", name);
		return NULL;
	}

 	if(useSystemLib)
 		Com_Printf(""Trying to load \""%s\""...\n"", name);
 	
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);

		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	
	return dllhandle;
}
","void *Sys_LoadDll(const char *name, qboolean useSystemLib)
 {
 	void *dllhandle;
 	
 	if(useSystemLib)
 		Com_Printf(""Trying to load \""%s\""...\n"", name);
 	
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);

		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	
	return dllhandle;
}
",C,"	// Don't load any DLLs that end with the pk3 extension
	if (COM_CompareExtension(name, "".pk3""))
	{
		Com_Printf(""Rejecting DLL named \""%s\"""", name);
		return NULL;
	}

",,,"@@ -500,6 +500,13 @@ void *Sys_LoadDll(const char *name, qboolean useSystemLib)
 {
 	void *dllhandle;
 	
+	// Don't load any DLLs that end with the pk3 extension
+	if (COM_CompareExtension(name, "".pk3""))
+	{
+		Com_Printf(""Rejecting DLL named \""%s\"""", name);
+		return NULL;
+	}
+
 	if(useSystemLib)
 		Com_Printf(""Trying to load \""%s\""...\n"", name);
 	",OpenJK,376267d534476a875d8b9228149c4ee18b74a4fd,cd41690fc3a9e28b5d22be473cc8ba8270a570b2,1,"void *Sys_LoadDll(const char *name, qboolean useSystemLib)
 {
 	void *dllhandle;
 	
//fix_flaw_line_below:
//	// Don't load any DLLs that end with the pk3 extension
//fix_flaw_line_below:
//	if (COM_CompareExtension(name, "".pk3""))
//fix_flaw_line_below:
//	{
//fix_flaw_line_below:
//		Com_Printf(""Rejecting DLL named \""%s\"""", name);
//fix_flaw_line_below:
//		return NULL;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	if(useSystemLib)
 		Com_Printf(""Trying to load \""%s\""...\n"", name);
 	
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);

		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	
	return dllhandle;
}
"
5527,183263,,Local,Not required,Partial,CVE-2017-5940,https://www.cvedetails.com/cve/CVE-2017-5940/,CWE-269,Low,Partial,Partial,,2017-02-09,4.6,"Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",2019-10-02,,2,https://github.com/netblue30/firejail/commit/b8a4ff9775318ca5e679183884a6a63f3da8f863,b8a4ff9775318ca5e679183884a6a63f3da8f863,replace copy_file with copy_file_as_user,14,src/firejail/fs_home.c,"{""sha"": ""39cbe6d07d03736c9165888a48c7d0c2d9e70d0f"", ""filename"": ""src/firejail/firejail.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/netblue30/firejail/blob/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/firejail.h"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/firejail.h"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/firejail.h?ref=b8a4ff9775318ca5e679183884a6a63f3da8f863"", ""patch"": ""@@ -446,6 +446,8 @@ void logmsg(const char *msg);\n void logargs(int argc, char **argv) ;\n void logerr(const char *msg);\n int copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode);\n int is_dir(const char *fname);\n int is_link(const char *fname);\n char *line_remove_spaces(const char *buf);""}<_**next**_>{""sha"": ""d8ff636a96778eb4ab2fb1dc25b16ccb2a1d263f"", ""filename"": ""src/firejail/fs_home.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 98, ""changes"": 118, ""blob_url"": ""https://github.com/netblue30/firejail/blob/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/fs_home.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/fs_home.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/fs_home.c?ref=b8a4ff9775318ca5e679183884a6a63f3da8f863"", ""patch"": ""@@ -43,18 +43,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\""/etc/skel/.zshrc\"", &s) == 0) {\n-\t\t\tif (copy_file(\""/etc/skel/.zshrc\"", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file(\""/etc/skel/.zshrc\"", fname, u, g, 0644);\n+\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tSET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);\n-\t\t\t\tfclose(fp);\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -68,19 +62,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\""/etc/skel/.cshrc\"", &s) == 0) {\n-\t\t\tif (copy_file(\""/etc/skel/.cshrc\"", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file(\""/etc/skel/.cshrc\"", fname, u, g, 0644);\n+\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\t/* coverity[toctou] */\n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tSET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);\n-\t\t\t\tfclose(fp);\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -94,9 +81,8 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0) \n \t\t\treturn;\n \t\tif (stat(\""/etc/skel/.bashrc\"", &s) == 0) {\n-\t\t\tif (copy_file(\""/etc/skel/.bashrc\"", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n-\t\t\t}\n+\t\t\tcopy_file(\""/etc/skel/.bashrc\"", fname, u, g, 0644);\n+\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -126,24 +112,8 @@ static int store_xauthority(void) {\n \t\t\treturn 0;\n \t\t}\n \n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest, getuid(), getgid(), 0600);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t\t}\n-\t\t\t_exit(0);\n-\t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600);\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -184,24 +154,8 @@ static int store_asoundrc(void) {\n \t\t\tfree(rp);\n \t\t}\n \n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest, getuid(), getgid(), 0644);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t\t}\n-\t\t\t_exit(0);\n-\t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644);\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -221,24 +175,8 @@ static void copy_xauthority(void) {\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n+\tfs_logger2(\""clone\"", dest);\n \t\n \t// delete the temporary file\n \tunlink(src);\n@@ -257,24 +195,8 @@ static void copy_asoundrc(void) {\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n+\tfs_logger2(\""clone\"", dest);\n \n \t// delete the temporary file\n \tunlink(src);""}<_**next**_>{""sha"": ""4ef4b2d3ee4f147f071ef79ea523510b06807e82"", ""filename"": ""src/firejail/util.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 0, ""changes"": 40, ""blob_url"": ""https://github.com/netblue30/firejail/blob/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/util.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/util.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/util.c?ref=b8a4ff9775318ca5e679183884a6a63f3da8f863"", ""patch"": ""@@ -28,6 +28,7 @@\n #include <grp.h>\n #include <sys/ioctl.h>\n #include <termios.h>\n+#include <sys/wait.h>\n \n #define MAX_GROUPS 1024\n // drop privileges\n@@ -219,6 +220,45 @@ int copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, m\n \treturn 0;\n }\n \n+// return -1 if error, 0 if no error\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\t// copy, set permissions and ownership\n+\t\tint rv = copy_file(srcname, destname, uid, gid, mode);\n+\t\tif (rv)\n+\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n+\n+// return -1 if error, 0 if no error\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\tFILE *fp = fopen(fname, \""w\"");\n+\t\tif (fp) {\n+\t\t\tfprintf(fp, \""\\n\"");\n+\t\t\tSET_PERMS_STREAM(fp, uid, gid, mode);\n+\t\t\tfclose(fp);\n+\t\t}\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n \n // return 1 if the file is a directory\n int is_dir(const char *fname) {""}","static void copy_asoundrc(void) {
	char *src = RUN_ASOUNDRC_FILE ;
	char *dest;
	if (asprintf(&dest, ""%s/.asoundrc"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	if (is_link(dest)) {
		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
	fs_logger2(""clone"", dest);
 
 	unlink(src);
}
","static void copy_asoundrc(void) {
	char *src = RUN_ASOUNDRC_FILE ;
	char *dest;
	if (asprintf(&dest, ""%s/.asoundrc"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	if (is_link(dest)) {
		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
	pid_t child = fork();
	if (child < 0)
		errExit(""fork"");
	if (child == 0) {
		drop_privs(0);
		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
		if (rv)
			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
		else {
			fs_logger2(""clone"", dest);
		}
		_exit(0);
	}
	waitpid(child, NULL, 0);
 
 	unlink(src);
}
",C,"	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
	fs_logger2(""clone"", dest);
","	pid_t child = fork();
	if (child < 0)
		errExit(""fork"");
	if (child == 0) {
		drop_privs(0);
		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
		if (rv)
			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
		else {
			fs_logger2(""clone"", dest);
		}
		_exit(0);
	}
	waitpid(child, NULL, 0);
",,"@@ -43,18 +43,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
-			if (copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644) == 0) {
-				fs_logger(""clone /etc/skel/.zshrc"");
-			}
+			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);
+			fs_logger(""clone /etc/skel/.zshrc"");
 		}
-		else { // 
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
-				fclose(fp);
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -68,19 +62,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
-			if (copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644) == 0) {
-				fs_logger(""clone /etc/skel/.cshrc"");
-			}
+			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);
+			fs_logger(""clone /etc/skel/.cshrc"");
 		}
-		else { // 
-			/* coverity[toctou] */
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
-				fclose(fp);
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -94,9 +81,8 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		if (stat(fname, &s) == 0) 
 			return;
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
-			if (copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644) == 0) {
-				fs_logger(""clone /etc/skel/.bashrc"");
-			}
+			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);
+			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
 	}
@@ -126,24 +112,8 @@ static int store_xauthority(void) {
 			return 0;
 		}
 
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest, getuid(), getgid(), 0600);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
-			}
-			_exit(0);
-		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
+		copy_file_as_user(src, dest, getuid(), getgid(), 0600);
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -184,24 +154,8 @@ static int store_asoundrc(void) {
 			free(rp);
 		}
 
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest, getuid(), getgid(), 0644);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
-			}
-			_exit(0);
-		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
+		copy_file_as_user(src, dest, getuid(), getgid(), 0644);
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -221,24 +175,8 @@ static void copy_xauthority(void) {
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
+	fs_logger2(""clone"", dest);
 	
 	// delete the temporary file
 	unlink(src);
@@ -257,24 +195,8 @@ static void copy_asoundrc(void) {
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
+	fs_logger2(""clone"", dest);
 
 	// delete the temporary file
 	unlink(src);",firejail,b8a4ff9775318ca5e679183884a6a63f3da8f863,d35d25f24532746a5df4066bb37e1f9d61d4d751,1,"static void copy_asoundrc(void) {
	// copy XAUTHORITY_FILE in the new home directory
	char *src = RUN_ASOUNDRC_FILE ;
	char *dest;
	if (asprintf(&dest, ""%s/.asoundrc"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	// if destination is a symbolic link, exit the sandbox!!!
	if (is_link(dest)) {
		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
//flaw_line_below:
	pid_t child = fork();
//flaw_line_below:
	if (child < 0)
//flaw_line_below:
		errExit(""fork"");
//flaw_line_below:
	if (child == 0) {
//flaw_line_below:
		// drop privileges
//flaw_line_below:
		drop_privs(0);
//flaw_line_below:

//flaw_line_below:
		// copy, set permissions and ownership
//flaw_line_below:
		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
//flaw_line_below:
		if (rv)
//flaw_line_below:
			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
//flaw_line_below:
		else {
//flaw_line_below:
			fs_logger2(""clone"", dest);
//flaw_line_below:
		}
//flaw_line_below:
		_exit(0);
//flaw_line_below:
	}
//flaw_line_below:
	// wait for the child to finish
//flaw_line_below:
	waitpid(child, NULL, 0);
//fix_flaw_line_below:
//	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
//fix_flaw_line_below:
//	fs_logger2(""clone"", dest);
 
 	// delete the temporary file
 	unlink(src);
}
"
5528,183264,,Local,Not required,Partial,CVE-2017-5940,https://www.cvedetails.com/cve/CVE-2017-5940/,CWE-269,Low,Partial,Partial,,2017-02-09,4.6,"Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",2019-10-02,,2,https://github.com/netblue30/firejail/commit/b8a4ff9775318ca5e679183884a6a63f3da8f863,b8a4ff9775318ca5e679183884a6a63f3da8f863,replace copy_file with copy_file_as_user,14,src/firejail/fs_home.c,"{""sha"": ""39cbe6d07d03736c9165888a48c7d0c2d9e70d0f"", ""filename"": ""src/firejail/firejail.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/netblue30/firejail/blob/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/firejail.h"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/firejail.h"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/firejail.h?ref=b8a4ff9775318ca5e679183884a6a63f3da8f863"", ""patch"": ""@@ -446,6 +446,8 @@ void logmsg(const char *msg);\n void logargs(int argc, char **argv) ;\n void logerr(const char *msg);\n int copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode);\n int is_dir(const char *fname);\n int is_link(const char *fname);\n char *line_remove_spaces(const char *buf);""}<_**next**_>{""sha"": ""d8ff636a96778eb4ab2fb1dc25b16ccb2a1d263f"", ""filename"": ""src/firejail/fs_home.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 98, ""changes"": 118, ""blob_url"": ""https://github.com/netblue30/firejail/blob/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/fs_home.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/fs_home.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/fs_home.c?ref=b8a4ff9775318ca5e679183884a6a63f3da8f863"", ""patch"": ""@@ -43,18 +43,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\""/etc/skel/.zshrc\"", &s) == 0) {\n-\t\t\tif (copy_file(\""/etc/skel/.zshrc\"", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file(\""/etc/skel/.zshrc\"", fname, u, g, 0644);\n+\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tSET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);\n-\t\t\t\tfclose(fp);\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -68,19 +62,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\""/etc/skel/.cshrc\"", &s) == 0) {\n-\t\t\tif (copy_file(\""/etc/skel/.cshrc\"", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file(\""/etc/skel/.cshrc\"", fname, u, g, 0644);\n+\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\t/* coverity[toctou] */\n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tSET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);\n-\t\t\t\tfclose(fp);\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -94,9 +81,8 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0) \n \t\t\treturn;\n \t\tif (stat(\""/etc/skel/.bashrc\"", &s) == 0) {\n-\t\t\tif (copy_file(\""/etc/skel/.bashrc\"", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n-\t\t\t}\n+\t\t\tcopy_file(\""/etc/skel/.bashrc\"", fname, u, g, 0644);\n+\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -126,24 +112,8 @@ static int store_xauthority(void) {\n \t\t\treturn 0;\n \t\t}\n \n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest, getuid(), getgid(), 0600);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t\t}\n-\t\t\t_exit(0);\n-\t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600);\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -184,24 +154,8 @@ static int store_asoundrc(void) {\n \t\t\tfree(rp);\n \t\t}\n \n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest, getuid(), getgid(), 0644);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t\t}\n-\t\t\t_exit(0);\n-\t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644);\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -221,24 +175,8 @@ static void copy_xauthority(void) {\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n+\tfs_logger2(\""clone\"", dest);\n \t\n \t// delete the temporary file\n \tunlink(src);\n@@ -257,24 +195,8 @@ static void copy_asoundrc(void) {\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n+\tfs_logger2(\""clone\"", dest);\n \n \t// delete the temporary file\n \tunlink(src);""}<_**next**_>{""sha"": ""4ef4b2d3ee4f147f071ef79ea523510b06807e82"", ""filename"": ""src/firejail/util.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 0, ""changes"": 40, ""blob_url"": ""https://github.com/netblue30/firejail/blob/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/util.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/util.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/util.c?ref=b8a4ff9775318ca5e679183884a6a63f3da8f863"", ""patch"": ""@@ -28,6 +28,7 @@\n #include <grp.h>\n #include <sys/ioctl.h>\n #include <termios.h>\n+#include <sys/wait.h>\n \n #define MAX_GROUPS 1024\n // drop privileges\n@@ -219,6 +220,45 @@ int copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, m\n \treturn 0;\n }\n \n+// return -1 if error, 0 if no error\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\t// copy, set permissions and ownership\n+\t\tint rv = copy_file(srcname, destname, uid, gid, mode);\n+\t\tif (rv)\n+\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n+\n+// return -1 if error, 0 if no error\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\tFILE *fp = fopen(fname, \""w\"");\n+\t\tif (fp) {\n+\t\t\tfprintf(fp, \""\\n\"");\n+\t\t\tSET_PERMS_STREAM(fp, uid, gid, mode);\n+\t\t\tfclose(fp);\n+\t\t}\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n \n // return 1 if the file is a directory\n int is_dir(const char *fname) {""}","static void copy_xauthority(void) {
	char *src = RUN_XAUTHORITY_FILE ;
	char *dest;
	if (asprintf(&dest, ""%s/.Xauthority"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	if (is_link(dest)) {
		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
	fs_logger2(""clone"", dest);
 	
 	unlink(src);
}
","static void copy_xauthority(void) {
	char *src = RUN_XAUTHORITY_FILE ;
	char *dest;
	if (asprintf(&dest, ""%s/.Xauthority"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	if (is_link(dest)) {
		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
	pid_t child = fork();
	if (child < 0)
		errExit(""fork"");
	if (child == 0) {
		drop_privs(0);
		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
		if (rv)
			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
		else {
			fs_logger2(""clone"", dest);
		}
		_exit(0);
	}
	waitpid(child, NULL, 0);
 	
 	unlink(src);
}
",C,"	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
	fs_logger2(""clone"", dest);
","	pid_t child = fork();
	if (child < 0)
		errExit(""fork"");
	if (child == 0) {
		drop_privs(0);
		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
		if (rv)
			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
		else {
			fs_logger2(""clone"", dest);
		}
		_exit(0);
	}
	waitpid(child, NULL, 0);
",,"@@ -43,18 +43,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
-			if (copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644) == 0) {
-				fs_logger(""clone /etc/skel/.zshrc"");
-			}
+			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);
+			fs_logger(""clone /etc/skel/.zshrc"");
 		}
-		else { // 
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
-				fclose(fp);
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -68,19 +62,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
-			if (copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644) == 0) {
-				fs_logger(""clone /etc/skel/.cshrc"");
-			}
+			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);
+			fs_logger(""clone /etc/skel/.cshrc"");
 		}
-		else { // 
-			/* coverity[toctou] */
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
-				fclose(fp);
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -94,9 +81,8 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		if (stat(fname, &s) == 0) 
 			return;
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
-			if (copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644) == 0) {
-				fs_logger(""clone /etc/skel/.bashrc"");
-			}
+			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);
+			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
 	}
@@ -126,24 +112,8 @@ static int store_xauthority(void) {
 			return 0;
 		}
 
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest, getuid(), getgid(), 0600);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
-			}
-			_exit(0);
-		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
+		copy_file_as_user(src, dest, getuid(), getgid(), 0600);
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -184,24 +154,8 @@ static int store_asoundrc(void) {
 			free(rp);
 		}
 
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest, getuid(), getgid(), 0644);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
-			}
-			_exit(0);
-		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
+		copy_file_as_user(src, dest, getuid(), getgid(), 0644);
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -221,24 +175,8 @@ static void copy_xauthority(void) {
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
+	fs_logger2(""clone"", dest);
 	
 	// delete the temporary file
 	unlink(src);
@@ -257,24 +195,8 @@ static void copy_asoundrc(void) {
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
+	fs_logger2(""clone"", dest);
 
 	// delete the temporary file
 	unlink(src);",firejail,b8a4ff9775318ca5e679183884a6a63f3da8f863,d35d25f24532746a5df4066bb37e1f9d61d4d751,1,"static void copy_xauthority(void) {
	// copy XAUTHORITY_FILE in the new home directory
	char *src = RUN_XAUTHORITY_FILE ;
	char *dest;
	if (asprintf(&dest, ""%s/.Xauthority"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	// if destination is a symbolic link, exit the sandbox!!!
	if (is_link(dest)) {
		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
//flaw_line_below:
	pid_t child = fork();
//flaw_line_below:
	if (child < 0)
//flaw_line_below:
		errExit(""fork"");
//flaw_line_below:
	if (child == 0) {
//flaw_line_below:
		// drop privileges
//flaw_line_below:
		drop_privs(0);
//flaw_line_below:

//flaw_line_below:
		// copy, set permissions and ownership
//flaw_line_below:
		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
//flaw_line_below:
		if (rv)
//flaw_line_below:
			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
//flaw_line_below:
		else {
//flaw_line_below:
			fs_logger2(""clone"", dest);
//flaw_line_below:
		}
//flaw_line_below:
		_exit(0);
//flaw_line_below:
	}
//flaw_line_below:
	// wait for the child to finish
//flaw_line_below:
	waitpid(child, NULL, 0);
//fix_flaw_line_below:
//	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
//fix_flaw_line_below:
//	fs_logger2(""clone"", dest);
 	
 	// delete the temporary file
 	unlink(src);
}
"
5529,183265,,Local,Not required,Partial,CVE-2017-5940,https://www.cvedetails.com/cve/CVE-2017-5940/,CWE-269,Low,Partial,Partial,,2017-02-09,4.6,"Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",2019-10-02,,12,https://github.com/netblue30/firejail/commit/b8a4ff9775318ca5e679183884a6a63f3da8f863,b8a4ff9775318ca5e679183884a6a63f3da8f863,replace copy_file with copy_file_as_user,26,src/firejail/fs_home.c,"{""sha"": ""39cbe6d07d03736c9165888a48c7d0c2d9e70d0f"", ""filename"": ""src/firejail/firejail.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/netblue30/firejail/blob/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/firejail.h"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/firejail.h"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/firejail.h?ref=b8a4ff9775318ca5e679183884a6a63f3da8f863"", ""patch"": ""@@ -446,6 +446,8 @@ void logmsg(const char *msg);\n void logargs(int argc, char **argv) ;\n void logerr(const char *msg);\n int copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode);\n int is_dir(const char *fname);\n int is_link(const char *fname);\n char *line_remove_spaces(const char *buf);""}<_**next**_>{""sha"": ""d8ff636a96778eb4ab2fb1dc25b16ccb2a1d263f"", ""filename"": ""src/firejail/fs_home.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 98, ""changes"": 118, ""blob_url"": ""https://github.com/netblue30/firejail/blob/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/fs_home.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/fs_home.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/fs_home.c?ref=b8a4ff9775318ca5e679183884a6a63f3da8f863"", ""patch"": ""@@ -43,18 +43,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\""/etc/skel/.zshrc\"", &s) == 0) {\n-\t\t\tif (copy_file(\""/etc/skel/.zshrc\"", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file(\""/etc/skel/.zshrc\"", fname, u, g, 0644);\n+\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tSET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);\n-\t\t\t\tfclose(fp);\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -68,19 +62,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\""/etc/skel/.cshrc\"", &s) == 0) {\n-\t\t\tif (copy_file(\""/etc/skel/.cshrc\"", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file(\""/etc/skel/.cshrc\"", fname, u, g, 0644);\n+\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\t/* coverity[toctou] */\n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tSET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);\n-\t\t\t\tfclose(fp);\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -94,9 +81,8 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0) \n \t\t\treturn;\n \t\tif (stat(\""/etc/skel/.bashrc\"", &s) == 0) {\n-\t\t\tif (copy_file(\""/etc/skel/.bashrc\"", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n-\t\t\t}\n+\t\t\tcopy_file(\""/etc/skel/.bashrc\"", fname, u, g, 0644);\n+\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -126,24 +112,8 @@ static int store_xauthority(void) {\n \t\t\treturn 0;\n \t\t}\n \n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest, getuid(), getgid(), 0600);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t\t}\n-\t\t\t_exit(0);\n-\t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600);\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -184,24 +154,8 @@ static int store_asoundrc(void) {\n \t\t\tfree(rp);\n \t\t}\n \n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest, getuid(), getgid(), 0644);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t\t}\n-\t\t\t_exit(0);\n-\t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644);\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -221,24 +175,8 @@ static void copy_xauthority(void) {\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n+\tfs_logger2(\""clone\"", dest);\n \t\n \t// delete the temporary file\n \tunlink(src);\n@@ -257,24 +195,8 @@ static void copy_asoundrc(void) {\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n+\tfs_logger2(\""clone\"", dest);\n \n \t// delete the temporary file\n \tunlink(src);""}<_**next**_>{""sha"": ""4ef4b2d3ee4f147f071ef79ea523510b06807e82"", ""filename"": ""src/firejail/util.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 0, ""changes"": 40, ""blob_url"": ""https://github.com/netblue30/firejail/blob/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/util.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/util.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/util.c?ref=b8a4ff9775318ca5e679183884a6a63f3da8f863"", ""patch"": ""@@ -28,6 +28,7 @@\n #include <grp.h>\n #include <sys/ioctl.h>\n #include <termios.h>\n+#include <sys/wait.h>\n \n #define MAX_GROUPS 1024\n // drop privileges\n@@ -219,6 +220,45 @@ int copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, m\n \treturn 0;\n }\n \n+// return -1 if error, 0 if no error\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\t// copy, set permissions and ownership\n+\t\tint rv = copy_file(srcname, destname, uid, gid, mode);\n+\t\tif (rv)\n+\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n+\n+// return -1 if error, 0 if no error\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\tFILE *fp = fopen(fname, \""w\"");\n+\t\tif (fp) {\n+\t\t\tfprintf(fp, \""\\n\"");\n+\t\t\tSET_PERMS_STREAM(fp, uid, gid, mode);\n+\t\t\tfclose(fp);\n+\t\t}\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n \n // return 1 if the file is a directory\n int is_dir(const char *fname) {""}","static void skel(const char *homedir, uid_t u, gid_t g) {
	char *fname;

	if (!arg_shell_none && (strcmp(cfg.shell,""/usr/bin/zsh"") == 0 || strcmp(cfg.shell,""/bin/zsh"") == 0)) {
		if (asprintf(&fname, ""%s/.zshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);
			fs_logger(""clone /etc/skel/.zshrc"");
 		}
		else {
			touch_file_as_user(fname, u, g, 0644);
			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
	else if (!arg_shell_none && strcmp(cfg.shell,""/bin/csh"") == 0) {
		if (asprintf(&fname, ""%s/.cshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);
			fs_logger(""clone /etc/skel/.cshrc"");
 		}
		else {
			touch_file_as_user(fname, u, g, 0644);
			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
	else {
		if (asprintf(&fname, ""%s/.bashrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		if (stat(fname, &s) == 0) 
 			return;
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);
			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
 	}
}
","static void skel(const char *homedir, uid_t u, gid_t g) {
	char *fname;

	if (!arg_shell_none && (strcmp(cfg.shell,""/usr/bin/zsh"") == 0 || strcmp(cfg.shell,""/bin/zsh"") == 0)) {
		if (asprintf(&fname, ""%s/.zshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
			if (copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644) == 0) {
				fs_logger(""clone /etc/skel/.zshrc"");
			}
 		}
		else { // 
			FILE *fp = fopen(fname, ""w"");
			if (fp) {
				fprintf(fp, ""\n"");
				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
				fclose(fp);
				fs_logger2(""touch"", fname);
			}
 		}
 		free(fname);
 	}
	else if (!arg_shell_none && strcmp(cfg.shell,""/bin/csh"") == 0) {
		if (asprintf(&fname, ""%s/.cshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
			if (copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644) == 0) {
				fs_logger(""clone /etc/skel/.cshrc"");
			}
 		}
		else { // 
			/* coverity[toctou] */
			FILE *fp = fopen(fname, ""w"");
			if (fp) {
				fprintf(fp, ""\n"");
				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
				fclose(fp);
				fs_logger2(""touch"", fname);
			}
 		}
 		free(fname);
 	}
	else {
		if (asprintf(&fname, ""%s/.bashrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		if (stat(fname, &s) == 0) 
 			return;
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
			if (copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644) == 0) {
				fs_logger(""clone /etc/skel/.bashrc"");
			}
 		}
 		free(fname);
 	}
}
",C,"			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);
			fs_logger(""clone /etc/skel/.zshrc"");
		else {
			touch_file_as_user(fname, u, g, 0644);
			fs_logger2(""touch"", fname);
			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);
			fs_logger(""clone /etc/skel/.cshrc"");
		else {
			touch_file_as_user(fname, u, g, 0644);
			fs_logger2(""touch"", fname);
			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);
			fs_logger(""clone /etc/skel/.bashrc"");
","			if (copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644) == 0) {
				fs_logger(""clone /etc/skel/.zshrc"");
			}
		else { // 
			FILE *fp = fopen(fname, ""w"");
			if (fp) {
				fprintf(fp, ""\n"");
				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
				fclose(fp);
				fs_logger2(""touch"", fname);
			}
			if (copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644) == 0) {
				fs_logger(""clone /etc/skel/.cshrc"");
			}
		else { // 
			/* coverity[toctou] */
			FILE *fp = fopen(fname, ""w"");
			if (fp) {
				fprintf(fp, ""\n"");
				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
				fclose(fp);
				fs_logger2(""touch"", fname);
			}
			if (copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644) == 0) {
				fs_logger(""clone /etc/skel/.bashrc"");
			}
",,"@@ -43,18 +43,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
-			if (copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644) == 0) {
-				fs_logger(""clone /etc/skel/.zshrc"");
-			}
+			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);
+			fs_logger(""clone /etc/skel/.zshrc"");
 		}
-		else { // 
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
-				fclose(fp);
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -68,19 +62,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
-			if (copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644) == 0) {
-				fs_logger(""clone /etc/skel/.cshrc"");
-			}
+			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);
+			fs_logger(""clone /etc/skel/.cshrc"");
 		}
-		else { // 
-			/* coverity[toctou] */
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
-				fclose(fp);
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -94,9 +81,8 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		if (stat(fname, &s) == 0) 
 			return;
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
-			if (copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644) == 0) {
-				fs_logger(""clone /etc/skel/.bashrc"");
-			}
+			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);
+			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
 	}
@@ -126,24 +112,8 @@ static int store_xauthority(void) {
 			return 0;
 		}
 
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest, getuid(), getgid(), 0600);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
-			}
-			_exit(0);
-		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
+		copy_file_as_user(src, dest, getuid(), getgid(), 0600);
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -184,24 +154,8 @@ static int store_asoundrc(void) {
 			free(rp);
 		}
 
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest, getuid(), getgid(), 0644);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
-			}
-			_exit(0);
-		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
+		copy_file_as_user(src, dest, getuid(), getgid(), 0644);
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -221,24 +175,8 @@ static void copy_xauthority(void) {
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
+	fs_logger2(""clone"", dest);
 	
 	// delete the temporary file
 	unlink(src);
@@ -257,24 +195,8 @@ static void copy_asoundrc(void) {
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
+	fs_logger2(""clone"", dest);
 
 	// delete the temporary file
 	unlink(src);",firejail,b8a4ff9775318ca5e679183884a6a63f3da8f863,d35d25f24532746a5df4066bb37e1f9d61d4d751,1,"static void skel(const char *homedir, uid_t u, gid_t g) {
	char *fname;

	// zsh
	if (!arg_shell_none && (strcmp(cfg.shell,""/usr/bin/zsh"") == 0 || strcmp(cfg.shell,""/bin/zsh"") == 0)) {
		// copy skel files
		if (asprintf(&fname, ""%s/.zshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
//flaw_line_below:
			if (copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644) == 0) {
//flaw_line_below:
				fs_logger(""clone /etc/skel/.zshrc"");
//flaw_line_below:
			}
//fix_flaw_line_below:
//			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);
//fix_flaw_line_below:
//			fs_logger(""clone /etc/skel/.zshrc"");
 		}
//flaw_line_below:
		else { // 
//flaw_line_below:
			FILE *fp = fopen(fname, ""w"");
//flaw_line_below:
			if (fp) {
//flaw_line_below:
				fprintf(fp, ""\n"");
//flaw_line_below:
				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
//flaw_line_below:
				fclose(fp);
//flaw_line_below:
				fs_logger2(""touch"", fname);
//flaw_line_below:
			}
//fix_flaw_line_below:
//		else {
//fix_flaw_line_below:
//			touch_file_as_user(fname, u, g, 0644);
//fix_flaw_line_below:
//			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
	// csh
	else if (!arg_shell_none && strcmp(cfg.shell,""/bin/csh"") == 0) {
		// copy skel files
		if (asprintf(&fname, ""%s/.cshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
//flaw_line_below:
			if (copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644) == 0) {
//flaw_line_below:
				fs_logger(""clone /etc/skel/.cshrc"");
//flaw_line_below:
			}
//fix_flaw_line_below:
//			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);
//fix_flaw_line_below:
//			fs_logger(""clone /etc/skel/.cshrc"");
 		}
//flaw_line_below:
		else { // 
//flaw_line_below:
			/* coverity[toctou] */
//flaw_line_below:
			FILE *fp = fopen(fname, ""w"");
//flaw_line_below:
			if (fp) {
//flaw_line_below:
				fprintf(fp, ""\n"");
//flaw_line_below:
				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
//flaw_line_below:
				fclose(fp);
//flaw_line_below:
				fs_logger2(""touch"", fname);
//flaw_line_below:
			}
//fix_flaw_line_below:
//		else {
//fix_flaw_line_below:
//			touch_file_as_user(fname, u, g, 0644);
//fix_flaw_line_below:
//			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
	// bash etc.
	else {
		// copy skel files
		if (asprintf(&fname, ""%s/.bashrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0) 
 			return;
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
//flaw_line_below:
			if (copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644) == 0) {
//flaw_line_below:
				fs_logger(""clone /etc/skel/.bashrc"");
//flaw_line_below:
			}
//fix_flaw_line_below:
//			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);
//fix_flaw_line_below:
//			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
 	}
}
"
5530,183266,,Local,Not required,Partial,CVE-2017-5940,https://www.cvedetails.com/cve/CVE-2017-5940/,CWE-269,Low,Partial,Partial,,2017-02-09,4.6,"Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",2019-10-02,,2,https://github.com/netblue30/firejail/commit/b8a4ff9775318ca5e679183884a6a63f3da8f863,b8a4ff9775318ca5e679183884a6a63f3da8f863,replace copy_file with copy_file_as_user,14,src/firejail/fs_home.c,"{""sha"": ""39cbe6d07d03736c9165888a48c7d0c2d9e70d0f"", ""filename"": ""src/firejail/firejail.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/netblue30/firejail/blob/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/firejail.h"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/firejail.h"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/firejail.h?ref=b8a4ff9775318ca5e679183884a6a63f3da8f863"", ""patch"": ""@@ -446,6 +446,8 @@ void logmsg(const char *msg);\n void logargs(int argc, char **argv) ;\n void logerr(const char *msg);\n int copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode);\n int is_dir(const char *fname);\n int is_link(const char *fname);\n char *line_remove_spaces(const char *buf);""}<_**next**_>{""sha"": ""d8ff636a96778eb4ab2fb1dc25b16ccb2a1d263f"", ""filename"": ""src/firejail/fs_home.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 98, ""changes"": 118, ""blob_url"": ""https://github.com/netblue30/firejail/blob/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/fs_home.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/fs_home.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/fs_home.c?ref=b8a4ff9775318ca5e679183884a6a63f3da8f863"", ""patch"": ""@@ -43,18 +43,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\""/etc/skel/.zshrc\"", &s) == 0) {\n-\t\t\tif (copy_file(\""/etc/skel/.zshrc\"", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file(\""/etc/skel/.zshrc\"", fname, u, g, 0644);\n+\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tSET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);\n-\t\t\t\tfclose(fp);\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -68,19 +62,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\""/etc/skel/.cshrc\"", &s) == 0) {\n-\t\t\tif (copy_file(\""/etc/skel/.cshrc\"", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file(\""/etc/skel/.cshrc\"", fname, u, g, 0644);\n+\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\t/* coverity[toctou] */\n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tSET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);\n-\t\t\t\tfclose(fp);\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -94,9 +81,8 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0) \n \t\t\treturn;\n \t\tif (stat(\""/etc/skel/.bashrc\"", &s) == 0) {\n-\t\t\tif (copy_file(\""/etc/skel/.bashrc\"", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n-\t\t\t}\n+\t\t\tcopy_file(\""/etc/skel/.bashrc\"", fname, u, g, 0644);\n+\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -126,24 +112,8 @@ static int store_xauthority(void) {\n \t\t\treturn 0;\n \t\t}\n \n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest, getuid(), getgid(), 0600);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t\t}\n-\t\t\t_exit(0);\n-\t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600);\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -184,24 +154,8 @@ static int store_asoundrc(void) {\n \t\t\tfree(rp);\n \t\t}\n \n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest, getuid(), getgid(), 0644);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t\t}\n-\t\t\t_exit(0);\n-\t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644);\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -221,24 +175,8 @@ static void copy_xauthority(void) {\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n+\tfs_logger2(\""clone\"", dest);\n \t\n \t// delete the temporary file\n \tunlink(src);\n@@ -257,24 +195,8 @@ static void copy_asoundrc(void) {\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n+\tfs_logger2(\""clone\"", dest);\n \n \t// delete the temporary file\n \tunlink(src);""}<_**next**_>{""sha"": ""4ef4b2d3ee4f147f071ef79ea523510b06807e82"", ""filename"": ""src/firejail/util.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 0, ""changes"": 40, ""blob_url"": ""https://github.com/netblue30/firejail/blob/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/util.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/util.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/util.c?ref=b8a4ff9775318ca5e679183884a6a63f3da8f863"", ""patch"": ""@@ -28,6 +28,7 @@\n #include <grp.h>\n #include <sys/ioctl.h>\n #include <termios.h>\n+#include <sys/wait.h>\n \n #define MAX_GROUPS 1024\n // drop privileges\n@@ -219,6 +220,45 @@ int copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, m\n \treturn 0;\n }\n \n+// return -1 if error, 0 if no error\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\t// copy, set permissions and ownership\n+\t\tint rv = copy_file(srcname, destname, uid, gid, mode);\n+\t\tif (rv)\n+\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n+\n+// return -1 if error, 0 if no error\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\tFILE *fp = fopen(fname, \""w\"");\n+\t\tif (fp) {\n+\t\t\tfprintf(fp, \""\\n\"");\n+\t\t\tSET_PERMS_STREAM(fp, uid, gid, mode);\n+\t\t\tfclose(fp);\n+\t\t}\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n \n // return 1 if the file is a directory\n int is_dir(const char *fname) {""}","static int store_asoundrc(void) {
	fs_build_mnt_dir();

	char *src;
	char *dest = RUN_ASOUNDRC_FILE;
	FILE *fp = fopen(dest, ""w"");
	if (fp) {
		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0644);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat s;
	if (stat(src, &s) == 0) {
		if (is_link(src)) {
			/* coverity[toctou] */
			char* rp = realpath(src, NULL);
			if (!rp) {
				fprintf(stderr, ""Error: Cannot access %s\n"", src);
				exit(1);
			}
			if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {
				fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n"");
				exit(1);
			}
 			free(rp);
 		}
 
		copy_file_as_user(src, dest, getuid(), getgid(), 0644);
		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
	return 0;
}
","static int store_asoundrc(void) {
	fs_build_mnt_dir();

	char *src;
	char *dest = RUN_ASOUNDRC_FILE;
	FILE *fp = fopen(dest, ""w"");
	if (fp) {
		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0644);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat s;
	if (stat(src, &s) == 0) {
		if (is_link(src)) {
			/* coverity[toctou] */
			char* rp = realpath(src, NULL);
			if (!rp) {
				fprintf(stderr, ""Error: Cannot access %s\n"", src);
				exit(1);
			}
			if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {
				fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n"");
				exit(1);
			}
 			free(rp);
 		}
 
		pid_t child = fork();
		if (child < 0)
			errExit(""fork"");
		if (child == 0) {
			drop_privs(0);
			int rv = copy_file(src, dest, getuid(), getgid(), 0644);
			if (rv)
				fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
			else {
				fs_logger2(""clone"", dest);
			}
			_exit(0);
		}
		waitpid(child, NULL, 0);
 		return 1; // file copied
 	}
 	
	return 0;
}
",C,"		copy_file_as_user(src, dest, getuid(), getgid(), 0644);
		fs_logger2(""clone"", dest);
","		pid_t child = fork();
		if (child < 0)
			errExit(""fork"");
		if (child == 0) {
			drop_privs(0);
			int rv = copy_file(src, dest, getuid(), getgid(), 0644);
			if (rv)
				fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
			else {
				fs_logger2(""clone"", dest);
			}
			_exit(0);
		}
		waitpid(child, NULL, 0);
",,"@@ -43,18 +43,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
-			if (copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644) == 0) {
-				fs_logger(""clone /etc/skel/.zshrc"");
-			}
+			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);
+			fs_logger(""clone /etc/skel/.zshrc"");
 		}
-		else { // 
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
-				fclose(fp);
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -68,19 +62,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
-			if (copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644) == 0) {
-				fs_logger(""clone /etc/skel/.cshrc"");
-			}
+			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);
+			fs_logger(""clone /etc/skel/.cshrc"");
 		}
-		else { // 
-			/* coverity[toctou] */
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
-				fclose(fp);
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -94,9 +81,8 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		if (stat(fname, &s) == 0) 
 			return;
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
-			if (copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644) == 0) {
-				fs_logger(""clone /etc/skel/.bashrc"");
-			}
+			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);
+			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
 	}
@@ -126,24 +112,8 @@ static int store_xauthority(void) {
 			return 0;
 		}
 
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest, getuid(), getgid(), 0600);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
-			}
-			_exit(0);
-		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
+		copy_file_as_user(src, dest, getuid(), getgid(), 0600);
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -184,24 +154,8 @@ static int store_asoundrc(void) {
 			free(rp);
 		}
 
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest, getuid(), getgid(), 0644);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
-			}
-			_exit(0);
-		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
+		copy_file_as_user(src, dest, getuid(), getgid(), 0644);
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -221,24 +175,8 @@ static void copy_xauthority(void) {
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
+	fs_logger2(""clone"", dest);
 	
 	// delete the temporary file
 	unlink(src);
@@ -257,24 +195,8 @@ static void copy_asoundrc(void) {
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
+	fs_logger2(""clone"", dest);
 
 	// delete the temporary file
 	unlink(src);",firejail,b8a4ff9775318ca5e679183884a6a63f3da8f863,d35d25f24532746a5df4066bb37e1f9d61d4d751,1,"static int store_asoundrc(void) {
	// put a copy of .Xauthority in XAUTHORITY_FILE
	fs_build_mnt_dir();

	char *src;
	char *dest = RUN_ASOUNDRC_FILE;
	// create an empty file 
	FILE *fp = fopen(dest, ""w"");
	if (fp) {
		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0644);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat s;
	if (stat(src, &s) == 0) {
		if (is_link(src)) {
			// make sure the real path of the file is inside the home directory
			/* coverity[toctou] */
			char* rp = realpath(src, NULL);
			if (!rp) {
				fprintf(stderr, ""Error: Cannot access %s\n"", src);
				exit(1);
			}
			if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {
				fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n"");
				exit(1);
			}
 			free(rp);
 		}
 
//flaw_line_below:
		pid_t child = fork();
//flaw_line_below:
		if (child < 0)
//flaw_line_below:
			errExit(""fork"");
//flaw_line_below:
		if (child == 0) {
//flaw_line_below:
			// drop privileges
//flaw_line_below:
			drop_privs(0);
//flaw_line_below:
	
//flaw_line_below:
			// copy, set permissions and ownership
//flaw_line_below:
			int rv = copy_file(src, dest, getuid(), getgid(), 0644);
//flaw_line_below:
			if (rv)
//flaw_line_below:
				fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
//flaw_line_below:
			else {
//flaw_line_below:
				fs_logger2(""clone"", dest);
//flaw_line_below:
			}
//flaw_line_below:
			_exit(0);
//flaw_line_below:
		}
//flaw_line_below:
		// wait for the child to finish
//flaw_line_below:
		waitpid(child, NULL, 0);
//fix_flaw_line_below:
//		copy_file_as_user(src, dest, getuid(), getgid(), 0644);
//fix_flaw_line_below:
//		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
	return 0;
}
"
5531,183267,,Local,Not required,Partial,CVE-2017-5940,https://www.cvedetails.com/cve/CVE-2017-5940/,CWE-269,Low,Partial,Partial,,2017-02-09,4.6,"Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",2019-10-02,,2,https://github.com/netblue30/firejail/commit/b8a4ff9775318ca5e679183884a6a63f3da8f863,b8a4ff9775318ca5e679183884a6a63f3da8f863,replace copy_file with copy_file_as_user,14,src/firejail/fs_home.c,"{""sha"": ""39cbe6d07d03736c9165888a48c7d0c2d9e70d0f"", ""filename"": ""src/firejail/firejail.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/netblue30/firejail/blob/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/firejail.h"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/firejail.h"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/firejail.h?ref=b8a4ff9775318ca5e679183884a6a63f3da8f863"", ""patch"": ""@@ -446,6 +446,8 @@ void logmsg(const char *msg);\n void logargs(int argc, char **argv) ;\n void logerr(const char *msg);\n int copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode);\n int is_dir(const char *fname);\n int is_link(const char *fname);\n char *line_remove_spaces(const char *buf);""}<_**next**_>{""sha"": ""d8ff636a96778eb4ab2fb1dc25b16ccb2a1d263f"", ""filename"": ""src/firejail/fs_home.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 98, ""changes"": 118, ""blob_url"": ""https://github.com/netblue30/firejail/blob/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/fs_home.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/fs_home.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/fs_home.c?ref=b8a4ff9775318ca5e679183884a6a63f3da8f863"", ""patch"": ""@@ -43,18 +43,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\""/etc/skel/.zshrc\"", &s) == 0) {\n-\t\t\tif (copy_file(\""/etc/skel/.zshrc\"", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file(\""/etc/skel/.zshrc\"", fname, u, g, 0644);\n+\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tSET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);\n-\t\t\t\tfclose(fp);\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -68,19 +62,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\""/etc/skel/.cshrc\"", &s) == 0) {\n-\t\t\tif (copy_file(\""/etc/skel/.cshrc\"", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file(\""/etc/skel/.cshrc\"", fname, u, g, 0644);\n+\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\t/* coverity[toctou] */\n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tSET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);\n-\t\t\t\tfclose(fp);\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -94,9 +81,8 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0) \n \t\t\treturn;\n \t\tif (stat(\""/etc/skel/.bashrc\"", &s) == 0) {\n-\t\t\tif (copy_file(\""/etc/skel/.bashrc\"", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n-\t\t\t}\n+\t\t\tcopy_file(\""/etc/skel/.bashrc\"", fname, u, g, 0644);\n+\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -126,24 +112,8 @@ static int store_xauthority(void) {\n \t\t\treturn 0;\n \t\t}\n \n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest, getuid(), getgid(), 0600);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t\t}\n-\t\t\t_exit(0);\n-\t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600);\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -184,24 +154,8 @@ static int store_asoundrc(void) {\n \t\t\tfree(rp);\n \t\t}\n \n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest, getuid(), getgid(), 0644);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t\t}\n-\t\t\t_exit(0);\n-\t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644);\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -221,24 +175,8 @@ static void copy_xauthority(void) {\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n+\tfs_logger2(\""clone\"", dest);\n \t\n \t// delete the temporary file\n \tunlink(src);\n@@ -257,24 +195,8 @@ static void copy_asoundrc(void) {\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n+\tfs_logger2(\""clone\"", dest);\n \n \t// delete the temporary file\n \tunlink(src);""}<_**next**_>{""sha"": ""4ef4b2d3ee4f147f071ef79ea523510b06807e82"", ""filename"": ""src/firejail/util.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 0, ""changes"": 40, ""blob_url"": ""https://github.com/netblue30/firejail/blob/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/util.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/b8a4ff9775318ca5e679183884a6a63f3da8f863/src/firejail/util.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/util.c?ref=b8a4ff9775318ca5e679183884a6a63f3da8f863"", ""patch"": ""@@ -28,6 +28,7 @@\n #include <grp.h>\n #include <sys/ioctl.h>\n #include <termios.h>\n+#include <sys/wait.h>\n \n #define MAX_GROUPS 1024\n // drop privileges\n@@ -219,6 +220,45 @@ int copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, m\n \treturn 0;\n }\n \n+// return -1 if error, 0 if no error\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\t// copy, set permissions and ownership\n+\t\tint rv = copy_file(srcname, destname, uid, gid, mode);\n+\t\tif (rv)\n+\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n+\n+// return -1 if error, 0 if no error\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\tFILE *fp = fopen(fname, \""w\"");\n+\t\tif (fp) {\n+\t\t\tfprintf(fp, \""\\n\"");\n+\t\t\tSET_PERMS_STREAM(fp, uid, gid, mode);\n+\t\t\tfclose(fp);\n+\t\t}\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n \n // return 1 if the file is a directory\n int is_dir(const char *fname) {""}","static int store_xauthority(void) {
	fs_build_mnt_dir();

	char *src;
	char *dest = RUN_XAUTHORITY_FILE;
	FILE *fp = fopen(dest, ""w"");
	if (fp) {
		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat s;
	if (stat(src, &s) == 0) {
		if (is_link(src)) {
			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
 			return 0;
 		}
 
		copy_file_as_user(src, dest, getuid(), getgid(), 0600);
		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
	return 0;
}
","static int store_xauthority(void) {
	fs_build_mnt_dir();

	char *src;
	char *dest = RUN_XAUTHORITY_FILE;
	FILE *fp = fopen(dest, ""w"");
	if (fp) {
		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat s;
	if (stat(src, &s) == 0) {
		if (is_link(src)) {
			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
 			return 0;
 		}
 
		pid_t child = fork();
		if (child < 0)
			errExit(""fork"");
		if (child == 0) {
			drop_privs(0);
			int rv = copy_file(src, dest, getuid(), getgid(), 0600);
			if (rv)
				fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
			else {
				fs_logger2(""clone"", dest);
			}
			_exit(0);
		}
		waitpid(child, NULL, 0);
 		return 1; // file copied
 	}
 	
	return 0;
}
",C,"		copy_file_as_user(src, dest, getuid(), getgid(), 0600);
		fs_logger2(""clone"", dest);
","		pid_t child = fork();
		if (child < 0)
			errExit(""fork"");
		if (child == 0) {
			drop_privs(0);
			int rv = copy_file(src, dest, getuid(), getgid(), 0600);
			if (rv)
				fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
			else {
				fs_logger2(""clone"", dest);
			}
			_exit(0);
		}
		waitpid(child, NULL, 0);
",,"@@ -43,18 +43,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
-			if (copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644) == 0) {
-				fs_logger(""clone /etc/skel/.zshrc"");
-			}
+			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);
+			fs_logger(""clone /etc/skel/.zshrc"");
 		}
-		else { // 
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
-				fclose(fp);
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -68,19 +62,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
-			if (copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644) == 0) {
-				fs_logger(""clone /etc/skel/.cshrc"");
-			}
+			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);
+			fs_logger(""clone /etc/skel/.cshrc"");
 		}
-		else { // 
-			/* coverity[toctou] */
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
-				fclose(fp);
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -94,9 +81,8 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		if (stat(fname, &s) == 0) 
 			return;
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
-			if (copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644) == 0) {
-				fs_logger(""clone /etc/skel/.bashrc"");
-			}
+			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);
+			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
 	}
@@ -126,24 +112,8 @@ static int store_xauthority(void) {
 			return 0;
 		}
 
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest, getuid(), getgid(), 0600);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
-			}
-			_exit(0);
-		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
+		copy_file_as_user(src, dest, getuid(), getgid(), 0600);
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -184,24 +154,8 @@ static int store_asoundrc(void) {
 			free(rp);
 		}
 
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest, getuid(), getgid(), 0644);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
-			}
-			_exit(0);
-		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
+		copy_file_as_user(src, dest, getuid(), getgid(), 0644);
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -221,24 +175,8 @@ static void copy_xauthority(void) {
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
+	fs_logger2(""clone"", dest);
 	
 	// delete the temporary file
 	unlink(src);
@@ -257,24 +195,8 @@ static void copy_asoundrc(void) {
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
+	fs_logger2(""clone"", dest);
 
 	// delete the temporary file
 	unlink(src);",firejail,b8a4ff9775318ca5e679183884a6a63f3da8f863,d35d25f24532746a5df4066bb37e1f9d61d4d751,1,"static int store_xauthority(void) {
	// put a copy of .Xauthority in XAUTHORITY_FILE
	fs_build_mnt_dir();

	char *src;
	char *dest = RUN_XAUTHORITY_FILE;
	// create an empty file 
	FILE *fp = fopen(dest, ""w"");
	if (fp) {
		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat s;
	if (stat(src, &s) == 0) {
		if (is_link(src)) {
			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
 			return 0;
 		}
 
//flaw_line_below:
		pid_t child = fork();
//flaw_line_below:
		if (child < 0)
//flaw_line_below:
			errExit(""fork"");
//flaw_line_below:
		if (child == 0) {
//flaw_line_below:
			// drop privileges
//flaw_line_below:
			drop_privs(0);
//flaw_line_below:
	
//flaw_line_below:
			// copy, set permissions and ownership
//flaw_line_below:
			int rv = copy_file(src, dest, getuid(), getgid(), 0600);
//flaw_line_below:
			if (rv)
//flaw_line_below:
				fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
//flaw_line_below:
			else {
//flaw_line_below:
				fs_logger2(""clone"", dest);
//flaw_line_below:
			}
//flaw_line_below:
			_exit(0);
//flaw_line_below:
		}
//flaw_line_below:
		// wait for the child to finish
//flaw_line_below:
		waitpid(child, NULL, 0);
//fix_flaw_line_below:
//		copy_file_as_user(src, dest, getuid(), getgid(), 0600);
//fix_flaw_line_below:
//		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
	return 0;
}
"
5532,183268,,Local,Not required,Partial,CVE-2017-5940,https://www.cvedetails.com/cve/CVE-2017-5940/,CWE-269,Low,Partial,Partial,,2017-02-09,4.6,"Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",2019-10-02,,3,https://github.com/netblue30/firejail/commit/903fd8a0789ca3cc3c21d84cd0282481515592ef,903fd8a0789ca3cc3c21d84cd0282481515592ef,security fix,18,src/firejail/fs_home.c,"{""sha"": ""18199c12260181f2b52a11ea2b84fdea1bd4a696"", ""filename"": ""src/firejail/firejail.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/netblue30/firejail/blob/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/firejail.h"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/firejail.h"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/firejail.h?ref=903fd8a0789ca3cc3c21d84cd0282481515592ef"", ""patch"": ""@@ -389,6 +389,8 @@ void logmsg(const char *msg);\n void logargs(int argc, char **argv) ;\n void logerr(const char *msg);\n int copy_file(const char *srcname, const char *destname);\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode);\n int is_dir(const char *fname);\n int is_link(const char *fname);\n char *line_remove_spaces(const char *buf);""}<_**next**_>{""sha"": ""ac8aa0122d0c70f009c715894c22d6d39912ae10"", ""filename"": ""src/firejail/fs_home.c"", ""status"": ""modified"", ""additions"": 54, ""deletions"": 158, ""changes"": 212, ""blob_url"": ""https://github.com/netblue30/firejail/blob/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/fs_home.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/fs_home.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/fs_home.c?ref=903fd8a0789ca3cc3c21d84cd0282481515592ef"", ""patch"": ""@@ -40,28 +40,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.zshrc\"", &s) == 0) {\n-\t\t\tif (is_link(\""/etc/skel/.zshrc\"")) {\n-\t\t\t\tfprintf(stderr, \""Error: invalid /etc/skel/.zshrc file\\n\"");\n-\t\t\t\texit(1);\n-\t\t\t}\n-\t\t\tif (copy_file(\""/etc/skel/.zshrc\"", fname) == 0) {\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file_as_user(\""/etc/skel/.zshrc\"", fname, u, g, 0644); // regular user\n+\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tfclose(fp);\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tif (chmod(fname, S_IRUSR | S_IWUSR) < 0)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -74,29 +63,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.cshrc\"", &s) == 0) {\n-\t\t\tif (is_link(\""/etc/skel/.cshrc\"")) {\n-\t\t\t\tfprintf(stderr, \""Error: invalid /etc/skel/.cshrc file\\n\"");\n-\t\t\t\texit(1);\n-\t\t\t}\n-\t\t\tif (copy_file(\""/etc/skel/.cshrc\"", fname) == 0) {\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file_as_user(\""/etc/skel/.cshrc\"", fname, u, g, 0644); // regular user\n+\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\t/* coverity[toctou] */\n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tfclose(fp);\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tif (chmod(fname, S_IRUSR | S_IWUSR) < 0)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -107,19 +84,15 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t\terrExit(\""asprintf\"");\n \t\tstruct stat s;\n \t\t// don't copy it if we already have the file\n-\t\tif (stat(fname, &s) == 0)\n+\t\tif (stat(fname, &s) == 0) \n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.bashrc\"", &s) == 0) {\n-\t\t\tif (is_link(\""/etc/skel/.bashrc\"")) {\n-\t\t\t\tfprintf(stderr, \""Error: invalid /etc/skel/.bashrc file\\n\"");\n-\t\t\t\texit(1);\n-\t\t\t}\n-\t\t\tif (copy_file(\""/etc/skel/.bashrc\"", fname) == 0) {\n-\t\t\t\t/* coverity[toctou] */\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n-\t\t\t}\n+\t\t\tcopy_file_as_user(\""/etc/skel/.bashrc\"", fname, u, g, 0644); // regular user\n+\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -131,48 +104,26 @@ static int store_xauthority(void) {\n \n \tchar *src;\n \tchar *dest = RUN_XAUTHORITY_FILE;\n-\t// create an empty file \n+\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \""w\"");\n \tif (fp) {\n \t\tfprintf(fp, \""\\n\"");\n \t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n \t\tfclose(fp);\n \t}\n-\n+\t\n \tif (asprintf(&src, \""%s/.Xauthority\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n \t\n \tstruct stat s;\n \tif (stat(src, &s) == 0) {\n \t\tif (is_link(src)) {\n-\t\t\tfprintf(stderr, \""Error: invalid .Xauthority file\\n\"");\n-\t\t\texit(1);\n-\t\t}\n-\t\t\t\n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t\t}\n-\t\t\t\t\n-\t\t\t_exit(0);\n+\t\t\tfprintf(stderr, \""Warning: invalid .Xauthority file\\n\"");\n+\t\t\treturn 0;\n \t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n \n-\t\tif (chown(dest, getuid(), getgid()) == -1)\n-\t\t\terrExit(\""fchown\"");\n-\t\tif (chmod(dest, 0600) == -1)\n-\t\t\terrExit(\""fchmod\"");\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -185,47 +136,36 @@ static int store_asoundrc(void) {\n \n \tchar *src;\n \tchar *dest = RUN_ASOUNDRC_FILE;\n-\t// create an empty file \n+\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \""w\"");\n \tif (fp) {\n \t\tfprintf(fp, \""\\n\"");\n \t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n \t\tfclose(fp);\n \t}\n-\n+\t\n \tif (asprintf(&src, \""%s/.asoundrc\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n \t\n \tstruct stat s;\n-\tif (stat(src, &s) == 0) {\t\n+\tif (stat(src, &s) == 0) {\n \t\tif (is_link(src)) {\n-\t\t\tfprintf(stderr, \""Error: invalid .asoundrc file\\n\"");\n-\t\t\texit(1);\n-\t\t}\n-\n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n+\t\t\t// make sure the real path of the file is inside the home directory\n+\t\t\t/* coverity[toctou] */\n+\t\t\tchar* rp = realpath(src, NULL);\n+\t\t\tif (!rp) {\n+\t\t\t\tfprintf(stderr, \""Error: Cannot access %s\\n\"", src);\n+\t\t\t\texit(1);\n+\t\t\t}\n+\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n+\t\t\t\tfprintf(stderr, \""Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\"");\n+\t\t\t\texit(1);\n \t\t\t}\n-\t\t\t_exit(0);\n+\t\t\tfree(rp);\n \t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n \n-\t\tif (chown(dest, getuid(), getgid()) == -1)\n-\t\t\terrExit(\""fchown\"");\n-\t\tif (chmod(dest, 0644) == -1)\n-\t\t\terrExit(\""fchmod\"");\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -238,38 +178,16 @@ static void copy_xauthority(void) {\n \tchar *dest;\n \tif (asprintf(&dest, \""%s/.Xauthority\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n-\n+\t\n \t// if destination is a symbolic link, exit the sandbox!!!\n \tif (is_link(dest)) {\n \t\tfprintf(stderr, \""Error: %s is a symbolic link\\n\"", dest);\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n-\n-\t// set permissions and ownership\n-\tif (chown(dest, getuid(), getgid()) < 0)\n-\t\terrExit(\""chown\"");\n-\tif (chmod(dest, S_IRUSR | S_IWUSR) < 0)\n-\t\terrExit(\""chmod\"");\n-\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n+\tfs_logger2(\""clone\"", dest);\n+\t\n \t// delete the temporary file\n \tunlink(src);\n }\n@@ -280,37 +198,15 @@ static void copy_asoundrc(void) {\n \tchar *dest;\n \tif (asprintf(&dest, \""%s/.asoundrc\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n-\n+\t\n \t// if destination is a symbolic link, exit the sandbox!!!\n \tif (is_link(dest)) {\n \t\tfprintf(stderr, \""Error: %s is a symbolic link\\n\"", dest);\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n-\n-\t// set permissions and ownership\n-\tif (chown(dest, getuid(), getgid()) < 0)\n-\t\terrExit(\""chown\"");\n-\tif (chmod(dest, S_IRUSR | S_IWUSR) < 0)\n-\t\terrExit(\""chmod\"");\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n+\tfs_logger2(\""clone\"", dest);\n \n \t// delete the temporary file\n \tunlink(src);""}<_**next**_>{""sha"": ""21f9a73e36656963c22e96a41828a34e0c59fe14"", ""filename"": ""src/firejail/util.c"", ""status"": ""modified"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/netblue30/firejail/blob/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/util.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/util.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/util.c?ref=903fd8a0789ca3cc3c21d84cd0282481515592ef"", ""patch"": ""@@ -213,6 +213,53 @@ int copy_file(const char *srcname, const char *destname) {\n \treturn 0;\n }\n \n+// return -1 if error, 0 if no error\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\t// copy, set permissions and ownership\n+\t\tint rv = copy_file(srcname, destname); // already a regular user\n+\t\tif (rv)\n+\t\t\tfprintf(stderr, \""Warning: cannot copy %s\\n\"", srcname);\n+\t\telse {\n+\t\t\tif (chown(destname, uid, gid) == -1)\n+\t\t\t\terrExit(\""fchown\"");\n+\t\t\tif (chmod(destname, mode) == -1)\n+\t\t\t\terrExit(\""fchmod\"");\n+\t\t}\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n+\n+// return -1 if error, 0 if no error\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\tFILE *fp = fopen(fname, \""w\"");\n+\t\tif (fp) {\n+\t\t\tfprintf(fp, \""\\n\"");\n+\t\t\tSET_PERMS_STREAM(fp, uid, gid, mode);\n+\t\t\tfclose(fp);\n+\t\t}\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n+\n+\n // return 1 if the file is a directory\n int is_dir(const char *fname) {\n \tassert(fname);""}","static void copy_asoundrc(void) {
	char *src = RUN_ASOUNDRC_FILE ;
 	char *dest;
 	if (asprintf(&dest, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
	
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
	fs_logger2(""clone"", dest);
 
 	unlink(src);
}
","static void copy_asoundrc(void) {
	char *src = RUN_ASOUNDRC_FILE ;
 	char *dest;
 	if (asprintf(&dest, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
	pid_t child = fork();
	if (child < 0)
		errExit(""fork"");
	if (child == 0) {
		drop_privs(0);
		int rv = copy_file(src, dest);
		if (rv)
			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
		else {
			fs_logger2(""clone"", dest);
		}
		_exit(0);
	}
	waitpid(child, NULL, 0);
	if (chown(dest, getuid(), getgid()) < 0)
		errExit(""chown"");
	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
		errExit(""chmod"");
 
 	unlink(src);
}
",C,"	
	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
	fs_logger2(""clone"", dest);
","	pid_t child = fork();
	if (child < 0)
		errExit(""fork"");
	if (child == 0) {
		drop_privs(0);
		int rv = copy_file(src, dest);
		if (rv)
			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
		else {
			fs_logger2(""clone"", dest);
		}
		_exit(0);
	}
	waitpid(child, NULL, 0);
	if (chown(dest, getuid(), getgid()) < 0)
		errExit(""chown"");
	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
		errExit(""chmod"");
",,"@@ -40,28 +40,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
-			if (is_link(""/etc/skel/.zshrc"")) {
-				fprintf(stderr, ""Error: invalid /etc/skel/.zshrc file\n"");
-				exit(1);
-			}
-			if (copy_file(""/etc/skel/.zshrc"", fname) == 0) {
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				fs_logger(""clone /etc/skel/.zshrc"");
-			}
+			copy_file_as_user(""/etc/skel/.zshrc"", fname, u, g, 0644); // regular user
+			fs_logger(""clone /etc/skel/.zshrc"");
 		}
-		else { // 
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				fclose(fp);
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				if (chmod(fname, S_IRUSR | S_IWUSR) < 0)
-					errExit(""chown"");
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -74,29 +63,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
-			if (is_link(""/etc/skel/.cshrc"")) {
-				fprintf(stderr, ""Error: invalid /etc/skel/.cshrc file\n"");
-				exit(1);
-			}
-			if (copy_file(""/etc/skel/.cshrc"", fname) == 0) {
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				fs_logger(""clone /etc/skel/.cshrc"");
-			}
+			copy_file_as_user(""/etc/skel/.cshrc"", fname, u, g, 0644); // regular user
+			fs_logger(""clone /etc/skel/.cshrc"");
 		}
-		else { // 
-			/* coverity[toctou] */
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				fclose(fp);
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				if (chmod(fname, S_IRUSR | S_IWUSR) < 0)
-					errExit(""chown"");
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -107,19 +84,15 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 			errExit(""asprintf"");
 		struct stat s;
 		// don't copy it if we already have the file
-		if (stat(fname, &s) == 0)
+		if (stat(fname, &s) == 0) 
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
-			if (is_link(""/etc/skel/.bashrc"")) {
-				fprintf(stderr, ""Error: invalid /etc/skel/.bashrc file\n"");
-				exit(1);
-			}
-			if (copy_file(""/etc/skel/.bashrc"", fname) == 0) {
-				/* coverity[toctou] */
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				fs_logger(""clone /etc/skel/.bashrc"");
-			}
+			copy_file_as_user(""/etc/skel/.bashrc"", fname, u, g, 0644); // regular user
+			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
 	}
@@ -131,48 +104,26 @@ static int store_xauthority(void) {
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
-	// create an empty file 
+	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
 		fclose(fp);
 	}
-
+	
 	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
 	if (stat(src, &s) == 0) {
 		if (is_link(src)) {
-			fprintf(stderr, ""Error: invalid .Xauthority file\n"");
-			exit(1);
-		}
-			
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
-			}
-				
-			_exit(0);
+			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
+			return 0;
 		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
 
-		if (chown(dest, getuid(), getgid()) == -1)
-			errExit(""fchown"");
-		if (chmod(dest, 0600) == -1)
-			errExit(""fchmod"");
+		copy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -185,47 +136,36 @@ static int store_asoundrc(void) {
 
 	char *src;
 	char *dest = RUN_ASOUNDRC_FILE;
-	// create an empty file 
+	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0644);
 		fclose(fp);
 	}
-
+	
 	if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
-	if (stat(src, &s) == 0) {	
+	if (stat(src, &s) == 0) {
 		if (is_link(src)) {
-			fprintf(stderr, ""Error: invalid .asoundrc file\n"");
-			exit(1);
-		}
-
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
+			// make sure the real path of the file is inside the home directory
+			/* coverity[toctou] */
+			char* rp = realpath(src, NULL);
+			if (!rp) {
+				fprintf(stderr, ""Error: Cannot access %s\n"", src);
+				exit(1);
+			}
+			if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {
+				fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n"");
+				exit(1);
 			}
-			_exit(0);
+			free(rp);
 		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
 
-		if (chown(dest, getuid(), getgid()) == -1)
-			errExit(""fchown"");
-		if (chmod(dest, 0644) == -1)
-			errExit(""fchmod"");
+		copy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -238,38 +178,16 @@ static void copy_xauthority(void) {
 	char *dest;
 	if (asprintf(&dest, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
-
+	
 	// if destination is a symbolic link, exit the sandbox!!!
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
-
-	// set permissions and ownership
-	if (chown(dest, getuid(), getgid()) < 0)
-		errExit(""chown"");
-	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
-		errExit(""chmod"");
-
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
+	fs_logger2(""clone"", dest);
+	
 	// delete the temporary file
 	unlink(src);
 }
@@ -280,37 +198,15 @@ static void copy_asoundrc(void) {
 	char *dest;
 	if (asprintf(&dest, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
-
+	
 	// if destination is a symbolic link, exit the sandbox!!!
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
-
-	// set permissions and ownership
-	if (chown(dest, getuid(), getgid()) < 0)
-		errExit(""chown"");
-	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
-		errExit(""chmod"");
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
+	fs_logger2(""clone"", dest);
 
 	// delete the temporary file
 	unlink(src);",firejail,903fd8a0789ca3cc3c21d84cd0282481515592ef,f512491ec0e26f1c9a7f75e62f67f090f1a03c29,1,"static void copy_asoundrc(void) {
	// copy XAUTHORITY_FILE in the new home directory
	char *src = RUN_ASOUNDRC_FILE ;
 	char *dest;
 	if (asprintf(&dest, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
//flaw_line_below:

//fix_flaw_line_below:
//	
 	// if destination is a symbolic link, exit the sandbox!!!
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
//flaw_line_below:
	pid_t child = fork();
//flaw_line_below:
	if (child < 0)
//flaw_line_below:
		errExit(""fork"");
//flaw_line_below:
	if (child == 0) {
//flaw_line_below:
		// drop privileges
//flaw_line_below:
		drop_privs(0);
//flaw_line_below:

//flaw_line_below:
		// copy, set permissions and ownership
//flaw_line_below:
		int rv = copy_file(src, dest);
//flaw_line_below:
		if (rv)
//flaw_line_below:
			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
//flaw_line_below:
		else {
//flaw_line_below:
			fs_logger2(""clone"", dest);
//flaw_line_below:
		}
//flaw_line_below:
		_exit(0);
//flaw_line_below:
	}
//flaw_line_below:
	// wait for the child to finish
//flaw_line_below:
	waitpid(child, NULL, 0);
//flaw_line_below:

//flaw_line_below:
	// set permissions and ownership
//flaw_line_below:
	if (chown(dest, getuid(), getgid()) < 0)
//flaw_line_below:
		errExit(""chown"");
//flaw_line_below:
	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
//flaw_line_below:
		errExit(""chmod"");
//fix_flaw_line_below:
//	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
//fix_flaw_line_below:
//	fs_logger2(""clone"", dest);
 
 	// delete the temporary file
 	unlink(src);
}
"
5533,183269,,Local,Not required,Partial,CVE-2017-5940,https://www.cvedetails.com/cve/CVE-2017-5940/,CWE-269,Low,Partial,Partial,,2017-02-09,4.6,"Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",2019-10-02,,4,https://github.com/netblue30/firejail/commit/903fd8a0789ca3cc3c21d84cd0282481515592ef,903fd8a0789ca3cc3c21d84cd0282481515592ef,security fix,18,src/firejail/fs_home.c,"{""sha"": ""18199c12260181f2b52a11ea2b84fdea1bd4a696"", ""filename"": ""src/firejail/firejail.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/netblue30/firejail/blob/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/firejail.h"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/firejail.h"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/firejail.h?ref=903fd8a0789ca3cc3c21d84cd0282481515592ef"", ""patch"": ""@@ -389,6 +389,8 @@ void logmsg(const char *msg);\n void logargs(int argc, char **argv) ;\n void logerr(const char *msg);\n int copy_file(const char *srcname, const char *destname);\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode);\n int is_dir(const char *fname);\n int is_link(const char *fname);\n char *line_remove_spaces(const char *buf);""}<_**next**_>{""sha"": ""ac8aa0122d0c70f009c715894c22d6d39912ae10"", ""filename"": ""src/firejail/fs_home.c"", ""status"": ""modified"", ""additions"": 54, ""deletions"": 158, ""changes"": 212, ""blob_url"": ""https://github.com/netblue30/firejail/blob/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/fs_home.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/fs_home.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/fs_home.c?ref=903fd8a0789ca3cc3c21d84cd0282481515592ef"", ""patch"": ""@@ -40,28 +40,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.zshrc\"", &s) == 0) {\n-\t\t\tif (is_link(\""/etc/skel/.zshrc\"")) {\n-\t\t\t\tfprintf(stderr, \""Error: invalid /etc/skel/.zshrc file\\n\"");\n-\t\t\t\texit(1);\n-\t\t\t}\n-\t\t\tif (copy_file(\""/etc/skel/.zshrc\"", fname) == 0) {\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file_as_user(\""/etc/skel/.zshrc\"", fname, u, g, 0644); // regular user\n+\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tfclose(fp);\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tif (chmod(fname, S_IRUSR | S_IWUSR) < 0)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -74,29 +63,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.cshrc\"", &s) == 0) {\n-\t\t\tif (is_link(\""/etc/skel/.cshrc\"")) {\n-\t\t\t\tfprintf(stderr, \""Error: invalid /etc/skel/.cshrc file\\n\"");\n-\t\t\t\texit(1);\n-\t\t\t}\n-\t\t\tif (copy_file(\""/etc/skel/.cshrc\"", fname) == 0) {\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file_as_user(\""/etc/skel/.cshrc\"", fname, u, g, 0644); // regular user\n+\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\t/* coverity[toctou] */\n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tfclose(fp);\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tif (chmod(fname, S_IRUSR | S_IWUSR) < 0)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -107,19 +84,15 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t\terrExit(\""asprintf\"");\n \t\tstruct stat s;\n \t\t// don't copy it if we already have the file\n-\t\tif (stat(fname, &s) == 0)\n+\t\tif (stat(fname, &s) == 0) \n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.bashrc\"", &s) == 0) {\n-\t\t\tif (is_link(\""/etc/skel/.bashrc\"")) {\n-\t\t\t\tfprintf(stderr, \""Error: invalid /etc/skel/.bashrc file\\n\"");\n-\t\t\t\texit(1);\n-\t\t\t}\n-\t\t\tif (copy_file(\""/etc/skel/.bashrc\"", fname) == 0) {\n-\t\t\t\t/* coverity[toctou] */\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n-\t\t\t}\n+\t\t\tcopy_file_as_user(\""/etc/skel/.bashrc\"", fname, u, g, 0644); // regular user\n+\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -131,48 +104,26 @@ static int store_xauthority(void) {\n \n \tchar *src;\n \tchar *dest = RUN_XAUTHORITY_FILE;\n-\t// create an empty file \n+\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \""w\"");\n \tif (fp) {\n \t\tfprintf(fp, \""\\n\"");\n \t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n \t\tfclose(fp);\n \t}\n-\n+\t\n \tif (asprintf(&src, \""%s/.Xauthority\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n \t\n \tstruct stat s;\n \tif (stat(src, &s) == 0) {\n \t\tif (is_link(src)) {\n-\t\t\tfprintf(stderr, \""Error: invalid .Xauthority file\\n\"");\n-\t\t\texit(1);\n-\t\t}\n-\t\t\t\n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t\t}\n-\t\t\t\t\n-\t\t\t_exit(0);\n+\t\t\tfprintf(stderr, \""Warning: invalid .Xauthority file\\n\"");\n+\t\t\treturn 0;\n \t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n \n-\t\tif (chown(dest, getuid(), getgid()) == -1)\n-\t\t\terrExit(\""fchown\"");\n-\t\tif (chmod(dest, 0600) == -1)\n-\t\t\terrExit(\""fchmod\"");\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -185,47 +136,36 @@ static int store_asoundrc(void) {\n \n \tchar *src;\n \tchar *dest = RUN_ASOUNDRC_FILE;\n-\t// create an empty file \n+\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \""w\"");\n \tif (fp) {\n \t\tfprintf(fp, \""\\n\"");\n \t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n \t\tfclose(fp);\n \t}\n-\n+\t\n \tif (asprintf(&src, \""%s/.asoundrc\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n \t\n \tstruct stat s;\n-\tif (stat(src, &s) == 0) {\t\n+\tif (stat(src, &s) == 0) {\n \t\tif (is_link(src)) {\n-\t\t\tfprintf(stderr, \""Error: invalid .asoundrc file\\n\"");\n-\t\t\texit(1);\n-\t\t}\n-\n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n+\t\t\t// make sure the real path of the file is inside the home directory\n+\t\t\t/* coverity[toctou] */\n+\t\t\tchar* rp = realpath(src, NULL);\n+\t\t\tif (!rp) {\n+\t\t\t\tfprintf(stderr, \""Error: Cannot access %s\\n\"", src);\n+\t\t\t\texit(1);\n+\t\t\t}\n+\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n+\t\t\t\tfprintf(stderr, \""Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\"");\n+\t\t\t\texit(1);\n \t\t\t}\n-\t\t\t_exit(0);\n+\t\t\tfree(rp);\n \t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n \n-\t\tif (chown(dest, getuid(), getgid()) == -1)\n-\t\t\terrExit(\""fchown\"");\n-\t\tif (chmod(dest, 0644) == -1)\n-\t\t\terrExit(\""fchmod\"");\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -238,38 +178,16 @@ static void copy_xauthority(void) {\n \tchar *dest;\n \tif (asprintf(&dest, \""%s/.Xauthority\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n-\n+\t\n \t// if destination is a symbolic link, exit the sandbox!!!\n \tif (is_link(dest)) {\n \t\tfprintf(stderr, \""Error: %s is a symbolic link\\n\"", dest);\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n-\n-\t// set permissions and ownership\n-\tif (chown(dest, getuid(), getgid()) < 0)\n-\t\terrExit(\""chown\"");\n-\tif (chmod(dest, S_IRUSR | S_IWUSR) < 0)\n-\t\terrExit(\""chmod\"");\n-\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n+\tfs_logger2(\""clone\"", dest);\n+\t\n \t// delete the temporary file\n \tunlink(src);\n }\n@@ -280,37 +198,15 @@ static void copy_asoundrc(void) {\n \tchar *dest;\n \tif (asprintf(&dest, \""%s/.asoundrc\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n-\n+\t\n \t// if destination is a symbolic link, exit the sandbox!!!\n \tif (is_link(dest)) {\n \t\tfprintf(stderr, \""Error: %s is a symbolic link\\n\"", dest);\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n-\n-\t// set permissions and ownership\n-\tif (chown(dest, getuid(), getgid()) < 0)\n-\t\terrExit(\""chown\"");\n-\tif (chmod(dest, S_IRUSR | S_IWUSR) < 0)\n-\t\terrExit(\""chmod\"");\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n+\tfs_logger2(\""clone\"", dest);\n \n \t// delete the temporary file\n \tunlink(src);""}<_**next**_>{""sha"": ""21f9a73e36656963c22e96a41828a34e0c59fe14"", ""filename"": ""src/firejail/util.c"", ""status"": ""modified"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/netblue30/firejail/blob/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/util.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/util.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/util.c?ref=903fd8a0789ca3cc3c21d84cd0282481515592ef"", ""patch"": ""@@ -213,6 +213,53 @@ int copy_file(const char *srcname, const char *destname) {\n \treturn 0;\n }\n \n+// return -1 if error, 0 if no error\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\t// copy, set permissions and ownership\n+\t\tint rv = copy_file(srcname, destname); // already a regular user\n+\t\tif (rv)\n+\t\t\tfprintf(stderr, \""Warning: cannot copy %s\\n\"", srcname);\n+\t\telse {\n+\t\t\tif (chown(destname, uid, gid) == -1)\n+\t\t\t\terrExit(\""fchown\"");\n+\t\t\tif (chmod(destname, mode) == -1)\n+\t\t\t\terrExit(\""fchmod\"");\n+\t\t}\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n+\n+// return -1 if error, 0 if no error\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\tFILE *fp = fopen(fname, \""w\"");\n+\t\tif (fp) {\n+\t\t\tfprintf(fp, \""\\n\"");\n+\t\t\tSET_PERMS_STREAM(fp, uid, gid, mode);\n+\t\t\tfclose(fp);\n+\t\t}\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n+\n+\n // return 1 if the file is a directory\n int is_dir(const char *fname) {\n \tassert(fname);""}","static void copy_xauthority(void) {
	char *src = RUN_XAUTHORITY_FILE ;
 	char *dest;
 	if (asprintf(&dest, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
	
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
	fs_logger2(""clone"", dest);
	
 	unlink(src);
 }
","static void copy_xauthority(void) {
	char *src = RUN_XAUTHORITY_FILE ;
 	char *dest;
 	if (asprintf(&dest, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
	pid_t child = fork();
	if (child < 0)
		errExit(""fork"");
	if (child == 0) {
		drop_privs(0);
		int rv = copy_file(src, dest);
		if (rv)
			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
		else {
			fs_logger2(""clone"", dest);
		}
		_exit(0);
	}
	waitpid(child, NULL, 0);
	if (chown(dest, getuid(), getgid()) < 0)
		errExit(""chown"");
	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
		errExit(""chmod"");
 	unlink(src);
 }
",C,"	
	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
	fs_logger2(""clone"", dest);
	
","	pid_t child = fork();
	if (child < 0)
		errExit(""fork"");
	if (child == 0) {
		drop_privs(0);
		int rv = copy_file(src, dest);
		if (rv)
			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
		else {
			fs_logger2(""clone"", dest);
		}
		_exit(0);
	}
	waitpid(child, NULL, 0);
	if (chown(dest, getuid(), getgid()) < 0)
		errExit(""chown"");
	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
		errExit(""chmod"");
",,"@@ -40,28 +40,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
-			if (is_link(""/etc/skel/.zshrc"")) {
-				fprintf(stderr, ""Error: invalid /etc/skel/.zshrc file\n"");
-				exit(1);
-			}
-			if (copy_file(""/etc/skel/.zshrc"", fname) == 0) {
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				fs_logger(""clone /etc/skel/.zshrc"");
-			}
+			copy_file_as_user(""/etc/skel/.zshrc"", fname, u, g, 0644); // regular user
+			fs_logger(""clone /etc/skel/.zshrc"");
 		}
-		else { // 
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				fclose(fp);
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				if (chmod(fname, S_IRUSR | S_IWUSR) < 0)
-					errExit(""chown"");
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -74,29 +63,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
-			if (is_link(""/etc/skel/.cshrc"")) {
-				fprintf(stderr, ""Error: invalid /etc/skel/.cshrc file\n"");
-				exit(1);
-			}
-			if (copy_file(""/etc/skel/.cshrc"", fname) == 0) {
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				fs_logger(""clone /etc/skel/.cshrc"");
-			}
+			copy_file_as_user(""/etc/skel/.cshrc"", fname, u, g, 0644); // regular user
+			fs_logger(""clone /etc/skel/.cshrc"");
 		}
-		else { // 
-			/* coverity[toctou] */
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				fclose(fp);
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				if (chmod(fname, S_IRUSR | S_IWUSR) < 0)
-					errExit(""chown"");
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -107,19 +84,15 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 			errExit(""asprintf"");
 		struct stat s;
 		// don't copy it if we already have the file
-		if (stat(fname, &s) == 0)
+		if (stat(fname, &s) == 0) 
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
-			if (is_link(""/etc/skel/.bashrc"")) {
-				fprintf(stderr, ""Error: invalid /etc/skel/.bashrc file\n"");
-				exit(1);
-			}
-			if (copy_file(""/etc/skel/.bashrc"", fname) == 0) {
-				/* coverity[toctou] */
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				fs_logger(""clone /etc/skel/.bashrc"");
-			}
+			copy_file_as_user(""/etc/skel/.bashrc"", fname, u, g, 0644); // regular user
+			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
 	}
@@ -131,48 +104,26 @@ static int store_xauthority(void) {
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
-	// create an empty file 
+	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
 		fclose(fp);
 	}
-
+	
 	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
 	if (stat(src, &s) == 0) {
 		if (is_link(src)) {
-			fprintf(stderr, ""Error: invalid .Xauthority file\n"");
-			exit(1);
-		}
-			
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
-			}
-				
-			_exit(0);
+			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
+			return 0;
 		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
 
-		if (chown(dest, getuid(), getgid()) == -1)
-			errExit(""fchown"");
-		if (chmod(dest, 0600) == -1)
-			errExit(""fchmod"");
+		copy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -185,47 +136,36 @@ static int store_asoundrc(void) {
 
 	char *src;
 	char *dest = RUN_ASOUNDRC_FILE;
-	// create an empty file 
+	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0644);
 		fclose(fp);
 	}
-
+	
 	if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
-	if (stat(src, &s) == 0) {	
+	if (stat(src, &s) == 0) {
 		if (is_link(src)) {
-			fprintf(stderr, ""Error: invalid .asoundrc file\n"");
-			exit(1);
-		}
-
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
+			// make sure the real path of the file is inside the home directory
+			/* coverity[toctou] */
+			char* rp = realpath(src, NULL);
+			if (!rp) {
+				fprintf(stderr, ""Error: Cannot access %s\n"", src);
+				exit(1);
+			}
+			if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {
+				fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n"");
+				exit(1);
 			}
-			_exit(0);
+			free(rp);
 		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
 
-		if (chown(dest, getuid(), getgid()) == -1)
-			errExit(""fchown"");
-		if (chmod(dest, 0644) == -1)
-			errExit(""fchmod"");
+		copy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -238,38 +178,16 @@ static void copy_xauthority(void) {
 	char *dest;
 	if (asprintf(&dest, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
-
+	
 	// if destination is a symbolic link, exit the sandbox!!!
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
-
-	// set permissions and ownership
-	if (chown(dest, getuid(), getgid()) < 0)
-		errExit(""chown"");
-	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
-		errExit(""chmod"");
-
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
+	fs_logger2(""clone"", dest);
+	
 	// delete the temporary file
 	unlink(src);
 }
@@ -280,37 +198,15 @@ static void copy_asoundrc(void) {
 	char *dest;
 	if (asprintf(&dest, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
-
+	
 	// if destination is a symbolic link, exit the sandbox!!!
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
-
-	// set permissions and ownership
-	if (chown(dest, getuid(), getgid()) < 0)
-		errExit(""chown"");
-	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
-		errExit(""chmod"");
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
+	fs_logger2(""clone"", dest);
 
 	// delete the temporary file
 	unlink(src);",firejail,903fd8a0789ca3cc3c21d84cd0282481515592ef,f512491ec0e26f1c9a7f75e62f67f090f1a03c29,1,"static void copy_xauthority(void) {
	// copy XAUTHORITY_FILE in the new home directory
	char *src = RUN_XAUTHORITY_FILE ;
 	char *dest;
 	if (asprintf(&dest, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
//flaw_line_below:

//fix_flaw_line_below:
//	
 	// if destination is a symbolic link, exit the sandbox!!!
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
//flaw_line_below:
	pid_t child = fork();
//flaw_line_below:
	if (child < 0)
//flaw_line_below:
		errExit(""fork"");
//flaw_line_below:
	if (child == 0) {
//flaw_line_below:
		// drop privileges
//flaw_line_below:
		drop_privs(0);
//flaw_line_below:

//flaw_line_below:
		// copy, set permissions and ownership
//flaw_line_below:
		int rv = copy_file(src, dest);
//flaw_line_below:
		if (rv)
//flaw_line_below:
			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
//flaw_line_below:
		else {
//flaw_line_below:
			fs_logger2(""clone"", dest);
//flaw_line_below:
		}
//flaw_line_below:
		_exit(0);
//flaw_line_below:
	}
//flaw_line_below:
	// wait for the child to finish
//flaw_line_below:
	waitpid(child, NULL, 0);
//flaw_line_below:

//flaw_line_below:
	// set permissions and ownership
//flaw_line_below:
	if (chown(dest, getuid(), getgid()) < 0)
//flaw_line_below:
		errExit(""chown"");
//flaw_line_below:
	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
//flaw_line_below:
		errExit(""chmod"");
//flaw_line_below:

//fix_flaw_line_below:
//	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
//fix_flaw_line_below:
//	fs_logger2(""clone"", dest);
//fix_flaw_line_below:
//	
 	// delete the temporary file
 	unlink(src);
 }
"
5534,183270,,Local,Not required,Partial,CVE-2017-5940,https://www.cvedetails.com/cve/CVE-2017-5940/,CWE-269,Low,Partial,Partial,,2017-02-09,4.6,"Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",2019-10-02,,25,https://github.com/netblue30/firejail/commit/903fd8a0789ca3cc3c21d84cd0282481515592ef,903fd8a0789ca3cc3c21d84cd0282481515592ef,security fix,52,src/firejail/fs_home.c,"{""sha"": ""18199c12260181f2b52a11ea2b84fdea1bd4a696"", ""filename"": ""src/firejail/firejail.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/netblue30/firejail/blob/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/firejail.h"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/firejail.h"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/firejail.h?ref=903fd8a0789ca3cc3c21d84cd0282481515592ef"", ""patch"": ""@@ -389,6 +389,8 @@ void logmsg(const char *msg);\n void logargs(int argc, char **argv) ;\n void logerr(const char *msg);\n int copy_file(const char *srcname, const char *destname);\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode);\n int is_dir(const char *fname);\n int is_link(const char *fname);\n char *line_remove_spaces(const char *buf);""}<_**next**_>{""sha"": ""ac8aa0122d0c70f009c715894c22d6d39912ae10"", ""filename"": ""src/firejail/fs_home.c"", ""status"": ""modified"", ""additions"": 54, ""deletions"": 158, ""changes"": 212, ""blob_url"": ""https://github.com/netblue30/firejail/blob/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/fs_home.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/fs_home.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/fs_home.c?ref=903fd8a0789ca3cc3c21d84cd0282481515592ef"", ""patch"": ""@@ -40,28 +40,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.zshrc\"", &s) == 0) {\n-\t\t\tif (is_link(\""/etc/skel/.zshrc\"")) {\n-\t\t\t\tfprintf(stderr, \""Error: invalid /etc/skel/.zshrc file\\n\"");\n-\t\t\t\texit(1);\n-\t\t\t}\n-\t\t\tif (copy_file(\""/etc/skel/.zshrc\"", fname) == 0) {\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file_as_user(\""/etc/skel/.zshrc\"", fname, u, g, 0644); // regular user\n+\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tfclose(fp);\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tif (chmod(fname, S_IRUSR | S_IWUSR) < 0)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -74,29 +63,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.cshrc\"", &s) == 0) {\n-\t\t\tif (is_link(\""/etc/skel/.cshrc\"")) {\n-\t\t\t\tfprintf(stderr, \""Error: invalid /etc/skel/.cshrc file\\n\"");\n-\t\t\t\texit(1);\n-\t\t\t}\n-\t\t\tif (copy_file(\""/etc/skel/.cshrc\"", fname) == 0) {\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file_as_user(\""/etc/skel/.cshrc\"", fname, u, g, 0644); // regular user\n+\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\t/* coverity[toctou] */\n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tfclose(fp);\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tif (chmod(fname, S_IRUSR | S_IWUSR) < 0)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -107,19 +84,15 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t\terrExit(\""asprintf\"");\n \t\tstruct stat s;\n \t\t// don't copy it if we already have the file\n-\t\tif (stat(fname, &s) == 0)\n+\t\tif (stat(fname, &s) == 0) \n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.bashrc\"", &s) == 0) {\n-\t\t\tif (is_link(\""/etc/skel/.bashrc\"")) {\n-\t\t\t\tfprintf(stderr, \""Error: invalid /etc/skel/.bashrc file\\n\"");\n-\t\t\t\texit(1);\n-\t\t\t}\n-\t\t\tif (copy_file(\""/etc/skel/.bashrc\"", fname) == 0) {\n-\t\t\t\t/* coverity[toctou] */\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n-\t\t\t}\n+\t\t\tcopy_file_as_user(\""/etc/skel/.bashrc\"", fname, u, g, 0644); // regular user\n+\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -131,48 +104,26 @@ static int store_xauthority(void) {\n \n \tchar *src;\n \tchar *dest = RUN_XAUTHORITY_FILE;\n-\t// create an empty file \n+\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \""w\"");\n \tif (fp) {\n \t\tfprintf(fp, \""\\n\"");\n \t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n \t\tfclose(fp);\n \t}\n-\n+\t\n \tif (asprintf(&src, \""%s/.Xauthority\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n \t\n \tstruct stat s;\n \tif (stat(src, &s) == 0) {\n \t\tif (is_link(src)) {\n-\t\t\tfprintf(stderr, \""Error: invalid .Xauthority file\\n\"");\n-\t\t\texit(1);\n-\t\t}\n-\t\t\t\n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t\t}\n-\t\t\t\t\n-\t\t\t_exit(0);\n+\t\t\tfprintf(stderr, \""Warning: invalid .Xauthority file\\n\"");\n+\t\t\treturn 0;\n \t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n \n-\t\tif (chown(dest, getuid(), getgid()) == -1)\n-\t\t\terrExit(\""fchown\"");\n-\t\tif (chmod(dest, 0600) == -1)\n-\t\t\terrExit(\""fchmod\"");\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -185,47 +136,36 @@ static int store_asoundrc(void) {\n \n \tchar *src;\n \tchar *dest = RUN_ASOUNDRC_FILE;\n-\t// create an empty file \n+\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \""w\"");\n \tif (fp) {\n \t\tfprintf(fp, \""\\n\"");\n \t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n \t\tfclose(fp);\n \t}\n-\n+\t\n \tif (asprintf(&src, \""%s/.asoundrc\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n \t\n \tstruct stat s;\n-\tif (stat(src, &s) == 0) {\t\n+\tif (stat(src, &s) == 0) {\n \t\tif (is_link(src)) {\n-\t\t\tfprintf(stderr, \""Error: invalid .asoundrc file\\n\"");\n-\t\t\texit(1);\n-\t\t}\n-\n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n+\t\t\t// make sure the real path of the file is inside the home directory\n+\t\t\t/* coverity[toctou] */\n+\t\t\tchar* rp = realpath(src, NULL);\n+\t\t\tif (!rp) {\n+\t\t\t\tfprintf(stderr, \""Error: Cannot access %s\\n\"", src);\n+\t\t\t\texit(1);\n+\t\t\t}\n+\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n+\t\t\t\tfprintf(stderr, \""Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\"");\n+\t\t\t\texit(1);\n \t\t\t}\n-\t\t\t_exit(0);\n+\t\t\tfree(rp);\n \t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n \n-\t\tif (chown(dest, getuid(), getgid()) == -1)\n-\t\t\terrExit(\""fchown\"");\n-\t\tif (chmod(dest, 0644) == -1)\n-\t\t\terrExit(\""fchmod\"");\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -238,38 +178,16 @@ static void copy_xauthority(void) {\n \tchar *dest;\n \tif (asprintf(&dest, \""%s/.Xauthority\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n-\n+\t\n \t// if destination is a symbolic link, exit the sandbox!!!\n \tif (is_link(dest)) {\n \t\tfprintf(stderr, \""Error: %s is a symbolic link\\n\"", dest);\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n-\n-\t// set permissions and ownership\n-\tif (chown(dest, getuid(), getgid()) < 0)\n-\t\terrExit(\""chown\"");\n-\tif (chmod(dest, S_IRUSR | S_IWUSR) < 0)\n-\t\terrExit(\""chmod\"");\n-\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n+\tfs_logger2(\""clone\"", dest);\n+\t\n \t// delete the temporary file\n \tunlink(src);\n }\n@@ -280,37 +198,15 @@ static void copy_asoundrc(void) {\n \tchar *dest;\n \tif (asprintf(&dest, \""%s/.asoundrc\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n-\n+\t\n \t// if destination is a symbolic link, exit the sandbox!!!\n \tif (is_link(dest)) {\n \t\tfprintf(stderr, \""Error: %s is a symbolic link\\n\"", dest);\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n-\n-\t// set permissions and ownership\n-\tif (chown(dest, getuid(), getgid()) < 0)\n-\t\terrExit(\""chown\"");\n-\tif (chmod(dest, S_IRUSR | S_IWUSR) < 0)\n-\t\terrExit(\""chmod\"");\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n+\tfs_logger2(\""clone\"", dest);\n \n \t// delete the temporary file\n \tunlink(src);""}<_**next**_>{""sha"": ""21f9a73e36656963c22e96a41828a34e0c59fe14"", ""filename"": ""src/firejail/util.c"", ""status"": ""modified"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/netblue30/firejail/blob/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/util.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/util.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/util.c?ref=903fd8a0789ca3cc3c21d84cd0282481515592ef"", ""patch"": ""@@ -213,6 +213,53 @@ int copy_file(const char *srcname, const char *destname) {\n \treturn 0;\n }\n \n+// return -1 if error, 0 if no error\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\t// copy, set permissions and ownership\n+\t\tint rv = copy_file(srcname, destname); // already a regular user\n+\t\tif (rv)\n+\t\t\tfprintf(stderr, \""Warning: cannot copy %s\\n\"", srcname);\n+\t\telse {\n+\t\t\tif (chown(destname, uid, gid) == -1)\n+\t\t\t\terrExit(\""fchown\"");\n+\t\t\tif (chmod(destname, mode) == -1)\n+\t\t\t\terrExit(\""fchmod\"");\n+\t\t}\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n+\n+// return -1 if error, 0 if no error\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\tFILE *fp = fopen(fname, \""w\"");\n+\t\tif (fp) {\n+\t\t\tfprintf(fp, \""\\n\"");\n+\t\t\tSET_PERMS_STREAM(fp, uid, gid, mode);\n+\t\t\tfclose(fp);\n+\t\t}\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n+\n+\n // return 1 if the file is a directory\n int is_dir(const char *fname) {\n \tassert(fname);""}","static void skel(const char *homedir, uid_t u, gid_t g) {
	char *fname;
	if (arg_zsh) {
		if (asprintf(&fname, ""%s/.zshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		if (stat(fname, &s) == 0)
 			return;
		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
			fprintf(stderr, ""Error: invalid %s file\n"", fname);
			exit(1);
		}
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
			copy_file_as_user(""/etc/skel/.zshrc"", fname, u, g, 0644); // regular user
			fs_logger(""clone /etc/skel/.zshrc"");
 		}
		else {
			touch_file_as_user(fname, u, g, 0644);
			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
	else if (arg_csh) {
		if (asprintf(&fname, ""%s/.cshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		if (stat(fname, &s) == 0)
 			return;
		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
			fprintf(stderr, ""Error: invalid %s file\n"", fname);
			exit(1);
		}
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
			copy_file_as_user(""/etc/skel/.cshrc"", fname, u, g, 0644); // regular user
			fs_logger(""clone /etc/skel/.cshrc"");
 		}
		else {
			touch_file_as_user(fname, u, g, 0644);
			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
	else {
		if (asprintf(&fname, ""%s/.bashrc"", homedir) == -1)
 			errExit(""asprintf"");
 		struct stat s;
		if (stat(fname, &s) == 0) 
 			return;
		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
			fprintf(stderr, ""Error: invalid %s file\n"", fname);
			exit(1);
		}
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
			copy_file_as_user(""/etc/skel/.bashrc"", fname, u, g, 0644); // regular user
			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
 	}
}
","static void skel(const char *homedir, uid_t u, gid_t g) {
	char *fname;
	if (arg_zsh) {
		if (asprintf(&fname, ""%s/.zshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
			if (is_link(""/etc/skel/.zshrc"")) {
				fprintf(stderr, ""Error: invalid /etc/skel/.zshrc file\n"");
				exit(1);
			}
			if (copy_file(""/etc/skel/.zshrc"", fname) == 0) {
				if (chown(fname, u, g) == -1)
					errExit(""chown"");
				fs_logger(""clone /etc/skel/.zshrc"");
			}
 		}
		else { // 
			FILE *fp = fopen(fname, ""w"");
			if (fp) {
				fprintf(fp, ""\n"");
				fclose(fp);
				if (chown(fname, u, g) == -1)
					errExit(""chown"");
				if (chmod(fname, S_IRUSR | S_IWUSR) < 0)
					errExit(""chown"");
				fs_logger2(""touch"", fname);
			}
 		}
 		free(fname);
 	}
	else if (arg_csh) {
		if (asprintf(&fname, ""%s/.cshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
			if (is_link(""/etc/skel/.cshrc"")) {
				fprintf(stderr, ""Error: invalid /etc/skel/.cshrc file\n"");
				exit(1);
			}
			if (copy_file(""/etc/skel/.cshrc"", fname) == 0) {
				if (chown(fname, u, g) == -1)
					errExit(""chown"");
				fs_logger(""clone /etc/skel/.cshrc"");
			}
 		}
		else { // 
			/* coverity[toctou] */
			FILE *fp = fopen(fname, ""w"");
			if (fp) {
				fprintf(fp, ""\n"");
				fclose(fp);
				if (chown(fname, u, g) == -1)
					errExit(""chown"");
				if (chmod(fname, S_IRUSR | S_IWUSR) < 0)
					errExit(""chown"");
				fs_logger2(""touch"", fname);
			}
 		}
 		free(fname);
 	}
	else {
		if (asprintf(&fname, ""%s/.bashrc"", homedir) == -1)
 			errExit(""asprintf"");
 		struct stat s;
		if (stat(fname, &s) == 0)
 			return;
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
			if (is_link(""/etc/skel/.bashrc"")) {
				fprintf(stderr, ""Error: invalid /etc/skel/.bashrc file\n"");
				exit(1);
			}
			if (copy_file(""/etc/skel/.bashrc"", fname) == 0) {
				/* coverity[toctou] */
				if (chown(fname, u, g) == -1)
					errExit(""chown"");
				fs_logger(""clone /etc/skel/.bashrc"");
			}
 		}
 		free(fname);
 	}
}
",C,"		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
			fprintf(stderr, ""Error: invalid %s file\n"", fname);
			exit(1);
		}
			copy_file_as_user(""/etc/skel/.zshrc"", fname, u, g, 0644); // regular user
			fs_logger(""clone /etc/skel/.zshrc"");
		else {
			touch_file_as_user(fname, u, g, 0644);
			fs_logger2(""touch"", fname);
		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
			fprintf(stderr, ""Error: invalid %s file\n"", fname);
			exit(1);
		}
			copy_file_as_user(""/etc/skel/.cshrc"", fname, u, g, 0644); // regular user
			fs_logger(""clone /etc/skel/.cshrc"");
		else {
			touch_file_as_user(fname, u, g, 0644);
			fs_logger2(""touch"", fname);
		if (stat(fname, &s) == 0) 
		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
			fprintf(stderr, ""Error: invalid %s file\n"", fname);
			exit(1);
		}
			copy_file_as_user(""/etc/skel/.bashrc"", fname, u, g, 0644); // regular user
			fs_logger(""clone /etc/skel/.bashrc"");
","			if (is_link(""/etc/skel/.zshrc"")) {
				fprintf(stderr, ""Error: invalid /etc/skel/.zshrc file\n"");
				exit(1);
			}
			if (copy_file(""/etc/skel/.zshrc"", fname) == 0) {
				if (chown(fname, u, g) == -1)
					errExit(""chown"");
				fs_logger(""clone /etc/skel/.zshrc"");
			}
		else { // 
			FILE *fp = fopen(fname, ""w"");
			if (fp) {
				fprintf(fp, ""\n"");
				fclose(fp);
				if (chown(fname, u, g) == -1)
					errExit(""chown"");
				if (chmod(fname, S_IRUSR | S_IWUSR) < 0)
					errExit(""chown"");
				fs_logger2(""touch"", fname);
			}
			if (is_link(""/etc/skel/.cshrc"")) {
				fprintf(stderr, ""Error: invalid /etc/skel/.cshrc file\n"");
				exit(1);
			}
			if (copy_file(""/etc/skel/.cshrc"", fname) == 0) {
				if (chown(fname, u, g) == -1)
					errExit(""chown"");
				fs_logger(""clone /etc/skel/.cshrc"");
			}
		else { // 
			/* coverity[toctou] */
			FILE *fp = fopen(fname, ""w"");
			if (fp) {
				fprintf(fp, ""\n"");
				fclose(fp);
				if (chown(fname, u, g) == -1)
					errExit(""chown"");
				if (chmod(fname, S_IRUSR | S_IWUSR) < 0)
					errExit(""chown"");
				fs_logger2(""touch"", fname);
			}
		if (stat(fname, &s) == 0)
			if (is_link(""/etc/skel/.bashrc"")) {
				fprintf(stderr, ""Error: invalid /etc/skel/.bashrc file\n"");
				exit(1);
			}
			if (copy_file(""/etc/skel/.bashrc"", fname) == 0) {
				/* coverity[toctou] */
				if (chown(fname, u, g) == -1)
					errExit(""chown"");
				fs_logger(""clone /etc/skel/.bashrc"");
			}
",,"@@ -40,28 +40,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
-			if (is_link(""/etc/skel/.zshrc"")) {
-				fprintf(stderr, ""Error: invalid /etc/skel/.zshrc file\n"");
-				exit(1);
-			}
-			if (copy_file(""/etc/skel/.zshrc"", fname) == 0) {
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				fs_logger(""clone /etc/skel/.zshrc"");
-			}
+			copy_file_as_user(""/etc/skel/.zshrc"", fname, u, g, 0644); // regular user
+			fs_logger(""clone /etc/skel/.zshrc"");
 		}
-		else { // 
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				fclose(fp);
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				if (chmod(fname, S_IRUSR | S_IWUSR) < 0)
-					errExit(""chown"");
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -74,29 +63,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
-			if (is_link(""/etc/skel/.cshrc"")) {
-				fprintf(stderr, ""Error: invalid /etc/skel/.cshrc file\n"");
-				exit(1);
-			}
-			if (copy_file(""/etc/skel/.cshrc"", fname) == 0) {
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				fs_logger(""clone /etc/skel/.cshrc"");
-			}
+			copy_file_as_user(""/etc/skel/.cshrc"", fname, u, g, 0644); // regular user
+			fs_logger(""clone /etc/skel/.cshrc"");
 		}
-		else { // 
-			/* coverity[toctou] */
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				fclose(fp);
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				if (chmod(fname, S_IRUSR | S_IWUSR) < 0)
-					errExit(""chown"");
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -107,19 +84,15 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 			errExit(""asprintf"");
 		struct stat s;
 		// don't copy it if we already have the file
-		if (stat(fname, &s) == 0)
+		if (stat(fname, &s) == 0) 
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
-			if (is_link(""/etc/skel/.bashrc"")) {
-				fprintf(stderr, ""Error: invalid /etc/skel/.bashrc file\n"");
-				exit(1);
-			}
-			if (copy_file(""/etc/skel/.bashrc"", fname) == 0) {
-				/* coverity[toctou] */
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				fs_logger(""clone /etc/skel/.bashrc"");
-			}
+			copy_file_as_user(""/etc/skel/.bashrc"", fname, u, g, 0644); // regular user
+			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
 	}
@@ -131,48 +104,26 @@ static int store_xauthority(void) {
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
-	// create an empty file 
+	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
 		fclose(fp);
 	}
-
+	
 	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
 	if (stat(src, &s) == 0) {
 		if (is_link(src)) {
-			fprintf(stderr, ""Error: invalid .Xauthority file\n"");
-			exit(1);
-		}
-			
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
-			}
-				
-			_exit(0);
+			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
+			return 0;
 		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
 
-		if (chown(dest, getuid(), getgid()) == -1)
-			errExit(""fchown"");
-		if (chmod(dest, 0600) == -1)
-			errExit(""fchmod"");
+		copy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -185,47 +136,36 @@ static int store_asoundrc(void) {
 
 	char *src;
 	char *dest = RUN_ASOUNDRC_FILE;
-	// create an empty file 
+	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0644);
 		fclose(fp);
 	}
-
+	
 	if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
-	if (stat(src, &s) == 0) {	
+	if (stat(src, &s) == 0) {
 		if (is_link(src)) {
-			fprintf(stderr, ""Error: invalid .asoundrc file\n"");
-			exit(1);
-		}
-
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
+			// make sure the real path of the file is inside the home directory
+			/* coverity[toctou] */
+			char* rp = realpath(src, NULL);
+			if (!rp) {
+				fprintf(stderr, ""Error: Cannot access %s\n"", src);
+				exit(1);
+			}
+			if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {
+				fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n"");
+				exit(1);
 			}
-			_exit(0);
+			free(rp);
 		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
 
-		if (chown(dest, getuid(), getgid()) == -1)
-			errExit(""fchown"");
-		if (chmod(dest, 0644) == -1)
-			errExit(""fchmod"");
+		copy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -238,38 +178,16 @@ static void copy_xauthority(void) {
 	char *dest;
 	if (asprintf(&dest, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
-
+	
 	// if destination is a symbolic link, exit the sandbox!!!
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
-
-	// set permissions and ownership
-	if (chown(dest, getuid(), getgid()) < 0)
-		errExit(""chown"");
-	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
-		errExit(""chmod"");
-
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
+	fs_logger2(""clone"", dest);
+	
 	// delete the temporary file
 	unlink(src);
 }
@@ -280,37 +198,15 @@ static void copy_asoundrc(void) {
 	char *dest;
 	if (asprintf(&dest, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
-
+	
 	// if destination is a symbolic link, exit the sandbox!!!
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
-
-	// set permissions and ownership
-	if (chown(dest, getuid(), getgid()) < 0)
-		errExit(""chown"");
-	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
-		errExit(""chmod"");
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
+	fs_logger2(""clone"", dest);
 
 	// delete the temporary file
 	unlink(src);",firejail,903fd8a0789ca3cc3c21d84cd0282481515592ef,f512491ec0e26f1c9a7f75e62f67f090f1a03c29,1,"static void skel(const char *homedir, uid_t u, gid_t g) {
	char *fname;
	// zsh
	if (arg_zsh) {
		// copy skel files
		if (asprintf(&fname, ""%s/.zshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
//fix_flaw_line_below:
//		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
//fix_flaw_line_below:
//			fprintf(stderr, ""Error: invalid %s file\n"", fname);
//fix_flaw_line_below:
//			exit(1);
//fix_flaw_line_below:
//		}
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
//flaw_line_below:
			if (is_link(""/etc/skel/.zshrc"")) {
//flaw_line_below:
				fprintf(stderr, ""Error: invalid /etc/skel/.zshrc file\n"");
//flaw_line_below:
				exit(1);
//flaw_line_below:
			}
//flaw_line_below:
			if (copy_file(""/etc/skel/.zshrc"", fname) == 0) {
//flaw_line_below:
				if (chown(fname, u, g) == -1)
//flaw_line_below:
					errExit(""chown"");
//flaw_line_below:
				fs_logger(""clone /etc/skel/.zshrc"");
//flaw_line_below:
			}
//fix_flaw_line_below:
//			copy_file_as_user(""/etc/skel/.zshrc"", fname, u, g, 0644); // regular user
//fix_flaw_line_below:
//			fs_logger(""clone /etc/skel/.zshrc"");
 		}
//flaw_line_below:
		else { // 
//flaw_line_below:
			FILE *fp = fopen(fname, ""w"");
//flaw_line_below:
			if (fp) {
//flaw_line_below:
				fprintf(fp, ""\n"");
//flaw_line_below:
				fclose(fp);
//flaw_line_below:
				if (chown(fname, u, g) == -1)
//flaw_line_below:
					errExit(""chown"");
//flaw_line_below:
				if (chmod(fname, S_IRUSR | S_IWUSR) < 0)
//flaw_line_below:
					errExit(""chown"");
//flaw_line_below:
				fs_logger2(""touch"", fname);
//flaw_line_below:
			}
//fix_flaw_line_below:
//		else {
//fix_flaw_line_below:
//			touch_file_as_user(fname, u, g, 0644);
//fix_flaw_line_below:
//			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
	// csh
	else if (arg_csh) {
		// copy skel files
		if (asprintf(&fname, ""%s/.cshrc"", homedir) == -1)
			errExit(""asprintf"");
		struct stat s;
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
//fix_flaw_line_below:
//		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
//fix_flaw_line_below:
//			fprintf(stderr, ""Error: invalid %s file\n"", fname);
//fix_flaw_line_below:
//			exit(1);
//fix_flaw_line_below:
//		}
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
//flaw_line_below:
			if (is_link(""/etc/skel/.cshrc"")) {
//flaw_line_below:
				fprintf(stderr, ""Error: invalid /etc/skel/.cshrc file\n"");
//flaw_line_below:
				exit(1);
//flaw_line_below:
			}
//flaw_line_below:
			if (copy_file(""/etc/skel/.cshrc"", fname) == 0) {
//flaw_line_below:
				if (chown(fname, u, g) == -1)
//flaw_line_below:
					errExit(""chown"");
//flaw_line_below:
				fs_logger(""clone /etc/skel/.cshrc"");
//flaw_line_below:
			}
//fix_flaw_line_below:
//			copy_file_as_user(""/etc/skel/.cshrc"", fname, u, g, 0644); // regular user
//fix_flaw_line_below:
//			fs_logger(""clone /etc/skel/.cshrc"");
 		}
//flaw_line_below:
		else { // 
//flaw_line_below:
			/* coverity[toctou] */
//flaw_line_below:
			FILE *fp = fopen(fname, ""w"");
//flaw_line_below:
			if (fp) {
//flaw_line_below:
				fprintf(fp, ""\n"");
//flaw_line_below:
				fclose(fp);
//flaw_line_below:
				if (chown(fname, u, g) == -1)
//flaw_line_below:
					errExit(""chown"");
//flaw_line_below:
				if (chmod(fname, S_IRUSR | S_IWUSR) < 0)
//flaw_line_below:
					errExit(""chown"");
//flaw_line_below:
				fs_logger2(""touch"", fname);
//flaw_line_below:
			}
//fix_flaw_line_below:
//		else {
//fix_flaw_line_below:
//			touch_file_as_user(fname, u, g, 0644);
//fix_flaw_line_below:
//			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
	// bash etc.
	else {
		// copy skel files
		if (asprintf(&fname, ""%s/.bashrc"", homedir) == -1)
 			errExit(""asprintf"");
 		struct stat s;
 		// don't copy it if we already have the file
//flaw_line_below:
		if (stat(fname, &s) == 0)
//fix_flaw_line_below:
//		if (stat(fname, &s) == 0) 
 			return;
//fix_flaw_line_below:
//		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
//fix_flaw_line_below:
//			fprintf(stderr, ""Error: invalid %s file\n"", fname);
//fix_flaw_line_below:
//			exit(1);
//fix_flaw_line_below:
//		}
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
//flaw_line_below:
			if (is_link(""/etc/skel/.bashrc"")) {
//flaw_line_below:
				fprintf(stderr, ""Error: invalid /etc/skel/.bashrc file\n"");
//flaw_line_below:
				exit(1);
//flaw_line_below:
			}
//flaw_line_below:
			if (copy_file(""/etc/skel/.bashrc"", fname) == 0) {
//flaw_line_below:
				/* coverity[toctou] */
//flaw_line_below:
				if (chown(fname, u, g) == -1)
//flaw_line_below:
					errExit(""chown"");
//flaw_line_below:
				fs_logger(""clone /etc/skel/.bashrc"");
//flaw_line_below:
			}
//fix_flaw_line_below:
//			copy_file_as_user(""/etc/skel/.bashrc"", fname, u, g, 0644); // regular user
//fix_flaw_line_below:
//			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
 	}
}
"
5535,183271,,Local,Not required,Partial,CVE-2017-5940,https://www.cvedetails.com/cve/CVE-2017-5940/,CWE-269,Low,Partial,Partial,,2017-02-09,4.6,"Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",2019-10-02,,16,https://github.com/netblue30/firejail/commit/903fd8a0789ca3cc3c21d84cd0282481515592ef,903fd8a0789ca3cc3c21d84cd0282481515592ef,security fix,20,src/firejail/fs_home.c,"{""sha"": ""18199c12260181f2b52a11ea2b84fdea1bd4a696"", ""filename"": ""src/firejail/firejail.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/netblue30/firejail/blob/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/firejail.h"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/firejail.h"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/firejail.h?ref=903fd8a0789ca3cc3c21d84cd0282481515592ef"", ""patch"": ""@@ -389,6 +389,8 @@ void logmsg(const char *msg);\n void logargs(int argc, char **argv) ;\n void logerr(const char *msg);\n int copy_file(const char *srcname, const char *destname);\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode);\n int is_dir(const char *fname);\n int is_link(const char *fname);\n char *line_remove_spaces(const char *buf);""}<_**next**_>{""sha"": ""ac8aa0122d0c70f009c715894c22d6d39912ae10"", ""filename"": ""src/firejail/fs_home.c"", ""status"": ""modified"", ""additions"": 54, ""deletions"": 158, ""changes"": 212, ""blob_url"": ""https://github.com/netblue30/firejail/blob/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/fs_home.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/fs_home.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/fs_home.c?ref=903fd8a0789ca3cc3c21d84cd0282481515592ef"", ""patch"": ""@@ -40,28 +40,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.zshrc\"", &s) == 0) {\n-\t\t\tif (is_link(\""/etc/skel/.zshrc\"")) {\n-\t\t\t\tfprintf(stderr, \""Error: invalid /etc/skel/.zshrc file\\n\"");\n-\t\t\t\texit(1);\n-\t\t\t}\n-\t\t\tif (copy_file(\""/etc/skel/.zshrc\"", fname) == 0) {\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file_as_user(\""/etc/skel/.zshrc\"", fname, u, g, 0644); // regular user\n+\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tfclose(fp);\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tif (chmod(fname, S_IRUSR | S_IWUSR) < 0)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -74,29 +63,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.cshrc\"", &s) == 0) {\n-\t\t\tif (is_link(\""/etc/skel/.cshrc\"")) {\n-\t\t\t\tfprintf(stderr, \""Error: invalid /etc/skel/.cshrc file\\n\"");\n-\t\t\t\texit(1);\n-\t\t\t}\n-\t\t\tif (copy_file(\""/etc/skel/.cshrc\"", fname) == 0) {\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file_as_user(\""/etc/skel/.cshrc\"", fname, u, g, 0644); // regular user\n+\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\t/* coverity[toctou] */\n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tfclose(fp);\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tif (chmod(fname, S_IRUSR | S_IWUSR) < 0)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -107,19 +84,15 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t\terrExit(\""asprintf\"");\n \t\tstruct stat s;\n \t\t// don't copy it if we already have the file\n-\t\tif (stat(fname, &s) == 0)\n+\t\tif (stat(fname, &s) == 0) \n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.bashrc\"", &s) == 0) {\n-\t\t\tif (is_link(\""/etc/skel/.bashrc\"")) {\n-\t\t\t\tfprintf(stderr, \""Error: invalid /etc/skel/.bashrc file\\n\"");\n-\t\t\t\texit(1);\n-\t\t\t}\n-\t\t\tif (copy_file(\""/etc/skel/.bashrc\"", fname) == 0) {\n-\t\t\t\t/* coverity[toctou] */\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n-\t\t\t}\n+\t\t\tcopy_file_as_user(\""/etc/skel/.bashrc\"", fname, u, g, 0644); // regular user\n+\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -131,48 +104,26 @@ static int store_xauthority(void) {\n \n \tchar *src;\n \tchar *dest = RUN_XAUTHORITY_FILE;\n-\t// create an empty file \n+\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \""w\"");\n \tif (fp) {\n \t\tfprintf(fp, \""\\n\"");\n \t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n \t\tfclose(fp);\n \t}\n-\n+\t\n \tif (asprintf(&src, \""%s/.Xauthority\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n \t\n \tstruct stat s;\n \tif (stat(src, &s) == 0) {\n \t\tif (is_link(src)) {\n-\t\t\tfprintf(stderr, \""Error: invalid .Xauthority file\\n\"");\n-\t\t\texit(1);\n-\t\t}\n-\t\t\t\n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t\t}\n-\t\t\t\t\n-\t\t\t_exit(0);\n+\t\t\tfprintf(stderr, \""Warning: invalid .Xauthority file\\n\"");\n+\t\t\treturn 0;\n \t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n \n-\t\tif (chown(dest, getuid(), getgid()) == -1)\n-\t\t\terrExit(\""fchown\"");\n-\t\tif (chmod(dest, 0600) == -1)\n-\t\t\terrExit(\""fchmod\"");\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -185,47 +136,36 @@ static int store_asoundrc(void) {\n \n \tchar *src;\n \tchar *dest = RUN_ASOUNDRC_FILE;\n-\t// create an empty file \n+\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \""w\"");\n \tif (fp) {\n \t\tfprintf(fp, \""\\n\"");\n \t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n \t\tfclose(fp);\n \t}\n-\n+\t\n \tif (asprintf(&src, \""%s/.asoundrc\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n \t\n \tstruct stat s;\n-\tif (stat(src, &s) == 0) {\t\n+\tif (stat(src, &s) == 0) {\n \t\tif (is_link(src)) {\n-\t\t\tfprintf(stderr, \""Error: invalid .asoundrc file\\n\"");\n-\t\t\texit(1);\n-\t\t}\n-\n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n+\t\t\t// make sure the real path of the file is inside the home directory\n+\t\t\t/* coverity[toctou] */\n+\t\t\tchar* rp = realpath(src, NULL);\n+\t\t\tif (!rp) {\n+\t\t\t\tfprintf(stderr, \""Error: Cannot access %s\\n\"", src);\n+\t\t\t\texit(1);\n+\t\t\t}\n+\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n+\t\t\t\tfprintf(stderr, \""Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\"");\n+\t\t\t\texit(1);\n \t\t\t}\n-\t\t\t_exit(0);\n+\t\t\tfree(rp);\n \t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n \n-\t\tif (chown(dest, getuid(), getgid()) == -1)\n-\t\t\terrExit(\""fchown\"");\n-\t\tif (chmod(dest, 0644) == -1)\n-\t\t\terrExit(\""fchmod\"");\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -238,38 +178,16 @@ static void copy_xauthority(void) {\n \tchar *dest;\n \tif (asprintf(&dest, \""%s/.Xauthority\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n-\n+\t\n \t// if destination is a symbolic link, exit the sandbox!!!\n \tif (is_link(dest)) {\n \t\tfprintf(stderr, \""Error: %s is a symbolic link\\n\"", dest);\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n-\n-\t// set permissions and ownership\n-\tif (chown(dest, getuid(), getgid()) < 0)\n-\t\terrExit(\""chown\"");\n-\tif (chmod(dest, S_IRUSR | S_IWUSR) < 0)\n-\t\terrExit(\""chmod\"");\n-\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n+\tfs_logger2(\""clone\"", dest);\n+\t\n \t// delete the temporary file\n \tunlink(src);\n }\n@@ -280,37 +198,15 @@ static void copy_asoundrc(void) {\n \tchar *dest;\n \tif (asprintf(&dest, \""%s/.asoundrc\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n-\n+\t\n \t// if destination is a symbolic link, exit the sandbox!!!\n \tif (is_link(dest)) {\n \t\tfprintf(stderr, \""Error: %s is a symbolic link\\n\"", dest);\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n-\n-\t// set permissions and ownership\n-\tif (chown(dest, getuid(), getgid()) < 0)\n-\t\terrExit(\""chown\"");\n-\tif (chmod(dest, S_IRUSR | S_IWUSR) < 0)\n-\t\terrExit(\""chmod\"");\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n+\tfs_logger2(\""clone\"", dest);\n \n \t// delete the temporary file\n \tunlink(src);""}<_**next**_>{""sha"": ""21f9a73e36656963c22e96a41828a34e0c59fe14"", ""filename"": ""src/firejail/util.c"", ""status"": ""modified"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/netblue30/firejail/blob/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/util.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/util.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/util.c?ref=903fd8a0789ca3cc3c21d84cd0282481515592ef"", ""patch"": ""@@ -213,6 +213,53 @@ int copy_file(const char *srcname, const char *destname) {\n \treturn 0;\n }\n \n+// return -1 if error, 0 if no error\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\t// copy, set permissions and ownership\n+\t\tint rv = copy_file(srcname, destname); // already a regular user\n+\t\tif (rv)\n+\t\t\tfprintf(stderr, \""Warning: cannot copy %s\\n\"", srcname);\n+\t\telse {\n+\t\t\tif (chown(destname, uid, gid) == -1)\n+\t\t\t\terrExit(\""fchown\"");\n+\t\t\tif (chmod(destname, mode) == -1)\n+\t\t\t\terrExit(\""fchmod\"");\n+\t\t}\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n+\n+// return -1 if error, 0 if no error\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\tFILE *fp = fopen(fname, \""w\"");\n+\t\tif (fp) {\n+\t\t\tfprintf(fp, \""\\n\"");\n+\t\t\tSET_PERMS_STREAM(fp, uid, gid, mode);\n+\t\t\tfclose(fp);\n+\t\t}\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n+\n+\n // return 1 if the file is a directory\n int is_dir(const char *fname) {\n \tassert(fname);""}","static int store_asoundrc(void) {
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_ASOUNDRC_FILE;
	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0644);
 		fclose(fp);
 	}
	
 	if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
	if (stat(src, &s) == 0) {
 		if (is_link(src)) {
			// make sure the real path of the file is inside the home directory
			/* coverity[toctou] */
			char* rp = realpath(src, NULL);
			if (!rp) {
				fprintf(stderr, ""Error: Cannot access %s\n"", src);
				exit(1);
			}
			if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {
				fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n"");
				exit(1);
 			}
			free(rp);
 		}
 
		copy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user
		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
	return 0;
}
","static int store_asoundrc(void) {
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_ASOUNDRC_FILE;
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0644);
 		fclose(fp);
 	}
 	if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
	if (stat(src, &s) == 0) {	
 		if (is_link(src)) {
			fprintf(stderr, ""Error: invalid .asoundrc file\n"");
			exit(1);
		}
		pid_t child = fork();
		if (child < 0)
			errExit(""fork"");
		if (child == 0) {
			drop_privs(0);
			int rv = copy_file(src, dest);
			if (rv)
				fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
			else {
				fs_logger2(""clone"", dest);
 			}
			_exit(0);
 		}
		waitpid(child, NULL, 0);
 
		if (chown(dest, getuid(), getgid()) == -1)
			errExit(""fchown"");
		if (chmod(dest, 0644) == -1)
			errExit(""fchmod"");
 		return 1; // file copied
 	}
 	
	return 0;
}
",C,"	// create an empty file as root, and change ownership to user
	
	if (stat(src, &s) == 0) {
			// make sure the real path of the file is inside the home directory
			/* coverity[toctou] */
			char* rp = realpath(src, NULL);
			if (!rp) {
				fprintf(stderr, ""Error: Cannot access %s\n"", src);
				exit(1);
			}
			if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {
				fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n"");
				exit(1);
			free(rp);
		copy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user
		fs_logger2(""clone"", dest);
","	if (stat(src, &s) == 0) {	
			fprintf(stderr, ""Error: invalid .asoundrc file\n"");
			exit(1);
		}
		pid_t child = fork();
		if (child < 0)
			errExit(""fork"");
		if (child == 0) {
			drop_privs(0);
			int rv = copy_file(src, dest);
			if (rv)
				fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
			else {
				fs_logger2(""clone"", dest);
			_exit(0);
		waitpid(child, NULL, 0);
		if (chown(dest, getuid(), getgid()) == -1)
			errExit(""fchown"");
		if (chmod(dest, 0644) == -1)
			errExit(""fchmod"");
",,"@@ -40,28 +40,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
-			if (is_link(""/etc/skel/.zshrc"")) {
-				fprintf(stderr, ""Error: invalid /etc/skel/.zshrc file\n"");
-				exit(1);
-			}
-			if (copy_file(""/etc/skel/.zshrc"", fname) == 0) {
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				fs_logger(""clone /etc/skel/.zshrc"");
-			}
+			copy_file_as_user(""/etc/skel/.zshrc"", fname, u, g, 0644); // regular user
+			fs_logger(""clone /etc/skel/.zshrc"");
 		}
-		else { // 
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				fclose(fp);
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				if (chmod(fname, S_IRUSR | S_IWUSR) < 0)
-					errExit(""chown"");
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -74,29 +63,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
-			if (is_link(""/etc/skel/.cshrc"")) {
-				fprintf(stderr, ""Error: invalid /etc/skel/.cshrc file\n"");
-				exit(1);
-			}
-			if (copy_file(""/etc/skel/.cshrc"", fname) == 0) {
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				fs_logger(""clone /etc/skel/.cshrc"");
-			}
+			copy_file_as_user(""/etc/skel/.cshrc"", fname, u, g, 0644); // regular user
+			fs_logger(""clone /etc/skel/.cshrc"");
 		}
-		else { // 
-			/* coverity[toctou] */
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				fclose(fp);
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				if (chmod(fname, S_IRUSR | S_IWUSR) < 0)
-					errExit(""chown"");
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -107,19 +84,15 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 			errExit(""asprintf"");
 		struct stat s;
 		// don't copy it if we already have the file
-		if (stat(fname, &s) == 0)
+		if (stat(fname, &s) == 0) 
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
-			if (is_link(""/etc/skel/.bashrc"")) {
-				fprintf(stderr, ""Error: invalid /etc/skel/.bashrc file\n"");
-				exit(1);
-			}
-			if (copy_file(""/etc/skel/.bashrc"", fname) == 0) {
-				/* coverity[toctou] */
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				fs_logger(""clone /etc/skel/.bashrc"");
-			}
+			copy_file_as_user(""/etc/skel/.bashrc"", fname, u, g, 0644); // regular user
+			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
 	}
@@ -131,48 +104,26 @@ static int store_xauthority(void) {
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
-	// create an empty file 
+	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
 		fclose(fp);
 	}
-
+	
 	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
 	if (stat(src, &s) == 0) {
 		if (is_link(src)) {
-			fprintf(stderr, ""Error: invalid .Xauthority file\n"");
-			exit(1);
-		}
-			
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
-			}
-				
-			_exit(0);
+			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
+			return 0;
 		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
 
-		if (chown(dest, getuid(), getgid()) == -1)
-			errExit(""fchown"");
-		if (chmod(dest, 0600) == -1)
-			errExit(""fchmod"");
+		copy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -185,47 +136,36 @@ static int store_asoundrc(void) {
 
 	char *src;
 	char *dest = RUN_ASOUNDRC_FILE;
-	// create an empty file 
+	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0644);
 		fclose(fp);
 	}
-
+	
 	if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
-	if (stat(src, &s) == 0) {	
+	if (stat(src, &s) == 0) {
 		if (is_link(src)) {
-			fprintf(stderr, ""Error: invalid .asoundrc file\n"");
-			exit(1);
-		}
-
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
+			// make sure the real path of the file is inside the home directory
+			/* coverity[toctou] */
+			char* rp = realpath(src, NULL);
+			if (!rp) {
+				fprintf(stderr, ""Error: Cannot access %s\n"", src);
+				exit(1);
+			}
+			if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {
+				fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n"");
+				exit(1);
 			}
-			_exit(0);
+			free(rp);
 		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
 
-		if (chown(dest, getuid(), getgid()) == -1)
-			errExit(""fchown"");
-		if (chmod(dest, 0644) == -1)
-			errExit(""fchmod"");
+		copy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -238,38 +178,16 @@ static void copy_xauthority(void) {
 	char *dest;
 	if (asprintf(&dest, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
-
+	
 	// if destination is a symbolic link, exit the sandbox!!!
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
-
-	// set permissions and ownership
-	if (chown(dest, getuid(), getgid()) < 0)
-		errExit(""chown"");
-	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
-		errExit(""chmod"");
-
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
+	fs_logger2(""clone"", dest);
+	
 	// delete the temporary file
 	unlink(src);
 }
@@ -280,37 +198,15 @@ static void copy_asoundrc(void) {
 	char *dest;
 	if (asprintf(&dest, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
-
+	
 	// if destination is a symbolic link, exit the sandbox!!!
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
-
-	// set permissions and ownership
-	if (chown(dest, getuid(), getgid()) < 0)
-		errExit(""chown"");
-	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
-		errExit(""chmod"");
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
+	fs_logger2(""clone"", dest);
 
 	// delete the temporary file
 	unlink(src);",firejail,903fd8a0789ca3cc3c21d84cd0282481515592ef,f512491ec0e26f1c9a7f75e62f67f090f1a03c29,1,"static int store_asoundrc(void) {
	// put a copy of .Xauthority in XAUTHORITY_FILE
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_ASOUNDRC_FILE;
//flaw_line_below:
	// create an empty file 
//fix_flaw_line_below:
//	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0644);
 		fclose(fp);
 	}
//flaw_line_below:

//fix_flaw_line_below:
//	
 	if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
//flaw_line_below:
	if (stat(src, &s) == 0) {	
//fix_flaw_line_below:
//	if (stat(src, &s) == 0) {
 		if (is_link(src)) {
//flaw_line_below:
			fprintf(stderr, ""Error: invalid .asoundrc file\n"");
//flaw_line_below:
			exit(1);
//flaw_line_below:
		}
//flaw_line_below:

//flaw_line_below:
		pid_t child = fork();
//flaw_line_below:
		if (child < 0)
//flaw_line_below:
			errExit(""fork"");
//flaw_line_below:
		if (child == 0) {
//flaw_line_below:
			// drop privileges
//flaw_line_below:
			drop_privs(0);
//flaw_line_below:
	
//flaw_line_below:
			// copy, set permissions and ownership
//flaw_line_below:
			int rv = copy_file(src, dest);
//flaw_line_below:
			if (rv)
//flaw_line_below:
				fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
//flaw_line_below:
			else {
//flaw_line_below:
				fs_logger2(""clone"", dest);
//fix_flaw_line_below:
//			// make sure the real path of the file is inside the home directory
//fix_flaw_line_below:
//			/* coverity[toctou] */
//fix_flaw_line_below:
//			char* rp = realpath(src, NULL);
//fix_flaw_line_below:
//			if (!rp) {
//fix_flaw_line_below:
//				fprintf(stderr, ""Error: Cannot access %s\n"", src);
//fix_flaw_line_below:
//				exit(1);
//fix_flaw_line_below:
//			}
//fix_flaw_line_below:
//			if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {
//fix_flaw_line_below:
//				fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n"");
//fix_flaw_line_below:
//				exit(1);
 			}
//flaw_line_below:
			_exit(0);
//fix_flaw_line_below:
//			free(rp);
 		}
//flaw_line_below:
		// wait for the child to finish
//flaw_line_below:
		waitpid(child, NULL, 0);
 
//flaw_line_below:
		if (chown(dest, getuid(), getgid()) == -1)
//flaw_line_below:
			errExit(""fchown"");
//flaw_line_below:
		if (chmod(dest, 0644) == -1)
//flaw_line_below:
			errExit(""fchmod"");
//fix_flaw_line_below:
//		copy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user
//fix_flaw_line_below:
//		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
	return 0;
}
"
5536,183272,,Local,Not required,Partial,CVE-2017-5940,https://www.cvedetails.com/cve/CVE-2017-5940/,CWE-269,Low,Partial,Partial,,2017-02-09,4.6,"Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",2019-10-02,,6,https://github.com/netblue30/firejail/commit/903fd8a0789ca3cc3c21d84cd0282481515592ef,903fd8a0789ca3cc3c21d84cd0282481515592ef,security fix,20,src/firejail/fs_home.c,"{""sha"": ""18199c12260181f2b52a11ea2b84fdea1bd4a696"", ""filename"": ""src/firejail/firejail.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/netblue30/firejail/blob/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/firejail.h"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/firejail.h"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/firejail.h?ref=903fd8a0789ca3cc3c21d84cd0282481515592ef"", ""patch"": ""@@ -389,6 +389,8 @@ void logmsg(const char *msg);\n void logargs(int argc, char **argv) ;\n void logerr(const char *msg);\n int copy_file(const char *srcname, const char *destname);\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode);\n int is_dir(const char *fname);\n int is_link(const char *fname);\n char *line_remove_spaces(const char *buf);""}<_**next**_>{""sha"": ""ac8aa0122d0c70f009c715894c22d6d39912ae10"", ""filename"": ""src/firejail/fs_home.c"", ""status"": ""modified"", ""additions"": 54, ""deletions"": 158, ""changes"": 212, ""blob_url"": ""https://github.com/netblue30/firejail/blob/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/fs_home.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/fs_home.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/fs_home.c?ref=903fd8a0789ca3cc3c21d84cd0282481515592ef"", ""patch"": ""@@ -40,28 +40,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.zshrc\"", &s) == 0) {\n-\t\t\tif (is_link(\""/etc/skel/.zshrc\"")) {\n-\t\t\t\tfprintf(stderr, \""Error: invalid /etc/skel/.zshrc file\\n\"");\n-\t\t\t\texit(1);\n-\t\t\t}\n-\t\t\tif (copy_file(\""/etc/skel/.zshrc\"", fname) == 0) {\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file_as_user(\""/etc/skel/.zshrc\"", fname, u, g, 0644); // regular user\n+\t\t\tfs_logger(\""clone /etc/skel/.zshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tfclose(fp);\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tif (chmod(fname, S_IRUSR | S_IWUSR) < 0)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -74,29 +63,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t// don't copy it if we already have the file\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.cshrc\"", &s) == 0) {\n-\t\t\tif (is_link(\""/etc/skel/.cshrc\"")) {\n-\t\t\t\tfprintf(stderr, \""Error: invalid /etc/skel/.cshrc file\\n\"");\n-\t\t\t\texit(1);\n-\t\t\t}\n-\t\t\tif (copy_file(\""/etc/skel/.cshrc\"", fname) == 0) {\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n-\t\t\t}\n+\t\t\tcopy_file_as_user(\""/etc/skel/.cshrc\"", fname, u, g, 0644); // regular user\n+\t\t\tfs_logger(\""clone /etc/skel/.cshrc\"");\n \t\t}\n-\t\telse { // \n-\t\t\t/* coverity[toctou] */\n-\t\t\tFILE *fp = fopen(fname, \""w\"");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \""\\n\"");\n-\t\t\t\tfclose(fp);\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tif (chmod(fname, S_IRUSR | S_IWUSR) < 0)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger2(\""touch\"", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\""touch\"", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -107,19 +84,15 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\t\terrExit(\""asprintf\"");\n \t\tstruct stat s;\n \t\t// don't copy it if we already have the file\n-\t\tif (stat(fname, &s) == 0)\n+\t\tif (stat(fname, &s) == 0) \n \t\t\treturn;\n+\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n+\t\t\tfprintf(stderr, \""Error: invalid %s file\\n\"", fname);\n+\t\t\texit(1);\n+\t\t}\n \t\tif (stat(\""/etc/skel/.bashrc\"", &s) == 0) {\n-\t\t\tif (is_link(\""/etc/skel/.bashrc\"")) {\n-\t\t\t\tfprintf(stderr, \""Error: invalid /etc/skel/.bashrc file\\n\"");\n-\t\t\t\texit(1);\n-\t\t\t}\n-\t\t\tif (copy_file(\""/etc/skel/.bashrc\"", fname) == 0) {\n-\t\t\t\t/* coverity[toctou] */\n-\t\t\t\tif (chown(fname, u, g) == -1)\n-\t\t\t\t\terrExit(\""chown\"");\n-\t\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n-\t\t\t}\n+\t\t\tcopy_file_as_user(\""/etc/skel/.bashrc\"", fname, u, g, 0644); // regular user\n+\t\t\tfs_logger(\""clone /etc/skel/.bashrc\"");\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -131,48 +104,26 @@ static int store_xauthority(void) {\n \n \tchar *src;\n \tchar *dest = RUN_XAUTHORITY_FILE;\n-\t// create an empty file \n+\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \""w\"");\n \tif (fp) {\n \t\tfprintf(fp, \""\\n\"");\n \t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n \t\tfclose(fp);\n \t}\n-\n+\t\n \tif (asprintf(&src, \""%s/.Xauthority\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n \t\n \tstruct stat s;\n \tif (stat(src, &s) == 0) {\n \t\tif (is_link(src)) {\n-\t\t\tfprintf(stderr, \""Error: invalid .Xauthority file\\n\"");\n-\t\t\texit(1);\n-\t\t}\n-\t\t\t\n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t\t}\n-\t\t\t\t\n-\t\t\t_exit(0);\n+\t\t\tfprintf(stderr, \""Warning: invalid .Xauthority file\\n\"");\n+\t\t\treturn 0;\n \t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n \n-\t\tif (chown(dest, getuid(), getgid()) == -1)\n-\t\t\terrExit(\""fchown\"");\n-\t\tif (chmod(dest, 0600) == -1)\n-\t\t\terrExit(\""fchmod\"");\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -185,47 +136,36 @@ static int store_asoundrc(void) {\n \n \tchar *src;\n \tchar *dest = RUN_ASOUNDRC_FILE;\n-\t// create an empty file \n+\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \""w\"");\n \tif (fp) {\n \t\tfprintf(fp, \""\\n\"");\n \t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n \t\tfclose(fp);\n \t}\n-\n+\t\n \tif (asprintf(&src, \""%s/.asoundrc\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n \t\n \tstruct stat s;\n-\tif (stat(src, &s) == 0) {\t\n+\tif (stat(src, &s) == 0) {\n \t\tif (is_link(src)) {\n-\t\t\tfprintf(stderr, \""Error: invalid .asoundrc file\\n\"");\n-\t\t\texit(1);\n-\t\t}\n-\n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\""fork\"");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\""clone\"", dest);\n+\t\t\t// make sure the real path of the file is inside the home directory\n+\t\t\t/* coverity[toctou] */\n+\t\t\tchar* rp = realpath(src, NULL);\n+\t\t\tif (!rp) {\n+\t\t\t\tfprintf(stderr, \""Error: Cannot access %s\\n\"", src);\n+\t\t\t\texit(1);\n+\t\t\t}\n+\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n+\t\t\t\tfprintf(stderr, \""Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\"");\n+\t\t\t\texit(1);\n \t\t\t}\n-\t\t\t_exit(0);\n+\t\t\tfree(rp);\n \t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n \n-\t\tif (chown(dest, getuid(), getgid()) == -1)\n-\t\t\terrExit(\""fchown\"");\n-\t\tif (chmod(dest, 0644) == -1)\n-\t\t\terrExit(\""fchmod\"");\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user\n+\t\tfs_logger2(\""clone\"", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -238,38 +178,16 @@ static void copy_xauthority(void) {\n \tchar *dest;\n \tif (asprintf(&dest, \""%s/.Xauthority\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n-\n+\t\n \t// if destination is a symbolic link, exit the sandbox!!!\n \tif (is_link(dest)) {\n \t\tfprintf(stderr, \""Error: %s is a symbolic link\\n\"", dest);\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .Xauthority in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n-\n-\t// set permissions and ownership\n-\tif (chown(dest, getuid(), getgid()) < 0)\n-\t\terrExit(\""chown\"");\n-\tif (chmod(dest, S_IRUSR | S_IWUSR) < 0)\n-\t\terrExit(\""chmod\"");\n-\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n+\tfs_logger2(\""clone\"", dest);\n+\t\n \t// delete the temporary file\n \tunlink(src);\n }\n@@ -280,37 +198,15 @@ static void copy_asoundrc(void) {\n \tchar *dest;\n \tif (asprintf(&dest, \""%s/.asoundrc\"", cfg.homedir) == -1)\n \t\terrExit(\""asprintf\"");\n-\n+\t\n \t// if destination is a symbolic link, exit the sandbox!!!\n \tif (is_link(dest)) {\n \t\tfprintf(stderr, \""Error: %s is a symbolic link\\n\"", dest);\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\""fork\"");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \""Warning: cannot transfer .asoundrc in private home directory\\n\"");\n-\t\telse {\n-\t\t\tfs_logger2(\""clone\"", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n-\n-\t// set permissions and ownership\n-\tif (chown(dest, getuid(), getgid()) < 0)\n-\t\terrExit(\""chown\"");\n-\tif (chmod(dest, S_IRUSR | S_IWUSR) < 0)\n-\t\terrExit(\""chmod\"");\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n+\tfs_logger2(\""clone\"", dest);\n \n \t// delete the temporary file\n \tunlink(src);""}<_**next**_>{""sha"": ""21f9a73e36656963c22e96a41828a34e0c59fe14"", ""filename"": ""src/firejail/util.c"", ""status"": ""modified"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/netblue30/firejail/blob/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/util.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/903fd8a0789ca3cc3c21d84cd0282481515592ef/src/firejail/util.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/util.c?ref=903fd8a0789ca3cc3c21d84cd0282481515592ef"", ""patch"": ""@@ -213,6 +213,53 @@ int copy_file(const char *srcname, const char *destname) {\n \treturn 0;\n }\n \n+// return -1 if error, 0 if no error\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\t// copy, set permissions and ownership\n+\t\tint rv = copy_file(srcname, destname); // already a regular user\n+\t\tif (rv)\n+\t\t\tfprintf(stderr, \""Warning: cannot copy %s\\n\"", srcname);\n+\t\telse {\n+\t\t\tif (chown(destname, uid, gid) == -1)\n+\t\t\t\terrExit(\""fchown\"");\n+\t\t\tif (chmod(destname, mode) == -1)\n+\t\t\t\terrExit(\""fchmod\"");\n+\t\t}\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n+\n+// return -1 if error, 0 if no error\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\""fork\"");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\tFILE *fp = fopen(fname, \""w\"");\n+\t\tif (fp) {\n+\t\t\tfprintf(fp, \""\\n\"");\n+\t\t\tSET_PERMS_STREAM(fp, uid, gid, mode);\n+\t\t\tfclose(fp);\n+\t\t}\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n+\n+\n // return 1 if the file is a directory\n int is_dir(const char *fname) {\n \tassert(fname);""}","static int store_xauthority(void) {
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
 		fclose(fp);
 	}
	
 	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
 	if (stat(src, &s) == 0) {
 		if (is_link(src)) {
			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
			return 0;
 		}
 
		copy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user
		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
	return 0;
}
","static int store_xauthority(void) {
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
 		fclose(fp);
 	}
 	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
 	if (stat(src, &s) == 0) {
 		if (is_link(src)) {
			fprintf(stderr, ""Error: invalid .Xauthority file\n"");
			exit(1);
		}
		pid_t child = fork();
		if (child < 0)
			errExit(""fork"");
		if (child == 0) {
			drop_privs(0);
			int rv = copy_file(src, dest);
			if (rv)
				fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
			else {
				fs_logger2(""clone"", dest);
			}
			_exit(0);
 		}
		waitpid(child, NULL, 0);
 
		if (chown(dest, getuid(), getgid()) == -1)
			errExit(""fchown"");
		if (chmod(dest, 0600) == -1)
			errExit(""fchmod"");
 		return 1; // file copied
 	}
 	
	return 0;
}
",C,"	// create an empty file as root, and change ownership to user
	
			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
			return 0;
		copy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user
		fs_logger2(""clone"", dest);
","			fprintf(stderr, ""Error: invalid .Xauthority file\n"");
			exit(1);
		}
		pid_t child = fork();
		if (child < 0)
			errExit(""fork"");
		if (child == 0) {
			drop_privs(0);
			int rv = copy_file(src, dest);
			if (rv)
				fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
			else {
				fs_logger2(""clone"", dest);
			}
			_exit(0);
		waitpid(child, NULL, 0);
		if (chown(dest, getuid(), getgid()) == -1)
			errExit(""fchown"");
		if (chmod(dest, 0600) == -1)
			errExit(""fchmod"");
",,"@@ -40,28 +40,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
-			if (is_link(""/etc/skel/.zshrc"")) {
-				fprintf(stderr, ""Error: invalid /etc/skel/.zshrc file\n"");
-				exit(1);
-			}
-			if (copy_file(""/etc/skel/.zshrc"", fname) == 0) {
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				fs_logger(""clone /etc/skel/.zshrc"");
-			}
+			copy_file_as_user(""/etc/skel/.zshrc"", fname, u, g, 0644); // regular user
+			fs_logger(""clone /etc/skel/.zshrc"");
 		}
-		else { // 
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				fclose(fp);
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				if (chmod(fname, S_IRUSR | S_IWUSR) < 0)
-					errExit(""chown"");
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -74,29 +63,17 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 		// don't copy it if we already have the file
 		if (stat(fname, &s) == 0)
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
-			if (is_link(""/etc/skel/.cshrc"")) {
-				fprintf(stderr, ""Error: invalid /etc/skel/.cshrc file\n"");
-				exit(1);
-			}
-			if (copy_file(""/etc/skel/.cshrc"", fname) == 0) {
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				fs_logger(""clone /etc/skel/.cshrc"");
-			}
+			copy_file_as_user(""/etc/skel/.cshrc"", fname, u, g, 0644); // regular user
+			fs_logger(""clone /etc/skel/.cshrc"");
 		}
-		else { // 
-			/* coverity[toctou] */
-			FILE *fp = fopen(fname, ""w"");
-			if (fp) {
-				fprintf(fp, ""\n"");
-				fclose(fp);
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				if (chmod(fname, S_IRUSR | S_IWUSR) < 0)
-					errExit(""chown"");
-				fs_logger2(""touch"", fname);
-			}
+		else {
+			touch_file_as_user(fname, u, g, 0644);
+			fs_logger2(""touch"", fname);
 		}
 		free(fname);
 	}
@@ -107,19 +84,15 @@ static void skel(const char *homedir, uid_t u, gid_t g) {
 			errExit(""asprintf"");
 		struct stat s;
 		// don't copy it if we already have the file
-		if (stat(fname, &s) == 0)
+		if (stat(fname, &s) == 0) 
 			return;
+		if (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat
+			fprintf(stderr, ""Error: invalid %s file\n"", fname);
+			exit(1);
+		}
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
-			if (is_link(""/etc/skel/.bashrc"")) {
-				fprintf(stderr, ""Error: invalid /etc/skel/.bashrc file\n"");
-				exit(1);
-			}
-			if (copy_file(""/etc/skel/.bashrc"", fname) == 0) {
-				/* coverity[toctou] */
-				if (chown(fname, u, g) == -1)
-					errExit(""chown"");
-				fs_logger(""clone /etc/skel/.bashrc"");
-			}
+			copy_file_as_user(""/etc/skel/.bashrc"", fname, u, g, 0644); // regular user
+			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
 	}
@@ -131,48 +104,26 @@ static int store_xauthority(void) {
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
-	// create an empty file 
+	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
 		fclose(fp);
 	}
-
+	
 	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
 	if (stat(src, &s) == 0) {
 		if (is_link(src)) {
-			fprintf(stderr, ""Error: invalid .Xauthority file\n"");
-			exit(1);
-		}
-			
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
-			}
-				
-			_exit(0);
+			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
+			return 0;
 		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
 
-		if (chown(dest, getuid(), getgid()) == -1)
-			errExit(""fchown"");
-		if (chmod(dest, 0600) == -1)
-			errExit(""fchmod"");
+		copy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -185,47 +136,36 @@ static int store_asoundrc(void) {
 
 	char *src;
 	char *dest = RUN_ASOUNDRC_FILE;
-	// create an empty file 
+	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0644);
 		fclose(fp);
 	}
-
+	
 	if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
-	if (stat(src, &s) == 0) {	
+	if (stat(src, &s) == 0) {
 		if (is_link(src)) {
-			fprintf(stderr, ""Error: invalid .asoundrc file\n"");
-			exit(1);
-		}
-
-		pid_t child = fork();
-		if (child < 0)
-			errExit(""fork"");
-		if (child == 0) {
-			// drop privileges
-			drop_privs(0);
-	
-			// copy, set permissions and ownership
-			int rv = copy_file(src, dest);
-			if (rv)
-				fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-			else {
-				fs_logger2(""clone"", dest);
+			// make sure the real path of the file is inside the home directory
+			/* coverity[toctou] */
+			char* rp = realpath(src, NULL);
+			if (!rp) {
+				fprintf(stderr, ""Error: Cannot access %s\n"", src);
+				exit(1);
+			}
+			if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {
+				fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n"");
+				exit(1);
 			}
-			_exit(0);
+			free(rp);
 		}
-		// wait for the child to finish
-		waitpid(child, NULL, 0);
 
-		if (chown(dest, getuid(), getgid()) == -1)
-			errExit(""fchown"");
-		if (chmod(dest, 0644) == -1)
-			errExit(""fchmod"");
+		copy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user
+		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
@@ -238,38 +178,16 @@ static void copy_xauthority(void) {
 	char *dest;
 	if (asprintf(&dest, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
-
+	
 	// if destination is a symbolic link, exit the sandbox!!!
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
-
-	// set permissions and ownership
-	if (chown(dest, getuid(), getgid()) < 0)
-		errExit(""chown"");
-	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
-		errExit(""chmod"");
-
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
+	fs_logger2(""clone"", dest);
+	
 	// delete the temporary file
 	unlink(src);
 }
@@ -280,37 +198,15 @@ static void copy_asoundrc(void) {
 	char *dest;
 	if (asprintf(&dest, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
-
+	
 	// if destination is a symbolic link, exit the sandbox!!!
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
-	pid_t child = fork();
-	if (child < 0)
-		errExit(""fork"");
-	if (child == 0) {
-		// drop privileges
-		drop_privs(0);
-
-		// copy, set permissions and ownership
-		int rv = copy_file(src, dest);
-		if (rv)
-			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
-		else {
-			fs_logger2(""clone"", dest);
-		}
-		_exit(0);
-	}
-	// wait for the child to finish
-	waitpid(child, NULL, 0);
-
-	// set permissions and ownership
-	if (chown(dest, getuid(), getgid()) < 0)
-		errExit(""chown"");
-	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
-		errExit(""chmod"");
+	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
+	fs_logger2(""clone"", dest);
 
 	// delete the temporary file
 	unlink(src);",firejail,903fd8a0789ca3cc3c21d84cd0282481515592ef,f512491ec0e26f1c9a7f75e62f67f090f1a03c29,1,"static int store_xauthority(void) {
	// put a copy of .Xauthority in XAUTHORITY_FILE
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
//flaw_line_below:
	// create an empty file 
//fix_flaw_line_below:
//	// create an empty file as root, and change ownership to user
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
 		fclose(fp);
 	}
//flaw_line_below:

//fix_flaw_line_below:
//	
 	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
 	if (stat(src, &s) == 0) {
 		if (is_link(src)) {
//flaw_line_below:
			fprintf(stderr, ""Error: invalid .Xauthority file\n"");
//flaw_line_below:
			exit(1);
//flaw_line_below:
		}
//flaw_line_below:
			
//flaw_line_below:
		pid_t child = fork();
//flaw_line_below:
		if (child < 0)
//flaw_line_below:
			errExit(""fork"");
//flaw_line_below:
		if (child == 0) {
//flaw_line_below:
			// drop privileges
//flaw_line_below:
			drop_privs(0);
//flaw_line_below:
	
//flaw_line_below:
			// copy, set permissions and ownership
//flaw_line_below:
			int rv = copy_file(src, dest);
//flaw_line_below:
			if (rv)
//flaw_line_below:
				fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
//flaw_line_below:
			else {
//flaw_line_below:
				fs_logger2(""clone"", dest);
//flaw_line_below:
			}
//flaw_line_below:
				
//flaw_line_below:
			_exit(0);
//fix_flaw_line_below:
//			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
//fix_flaw_line_below:
//			return 0;
 		}
//flaw_line_below:
		// wait for the child to finish
//flaw_line_below:
		waitpid(child, NULL, 0);
 
//flaw_line_below:
		if (chown(dest, getuid(), getgid()) == -1)
//flaw_line_below:
			errExit(""fchown"");
//flaw_line_below:
		if (chmod(dest, 0600) == -1)
//flaw_line_below:
			errExit(""fchmod"");
//fix_flaw_line_below:
//		copy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user
//fix_flaw_line_below:
//		fs_logger2(""clone"", dest);
 		return 1; // file copied
 	}
 	
	return 0;
}
"
9154,186890,,Remote,Not required,,CVE-2018-6080,https://www.cvedetails.com/cve/CVE-2018-6080/,CWE-269,Medium,Partial,,,2018-11-14,4.3,Lack of access control checks in Instrumentation in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to obtain memory metadata from privileged processes .,2019-10-02,,9,https://github.com/chromium/chromium/commit/b44e68087804e6543a99c87076ab7648d11d9b07,b44e68087804e6543a99c87076ab7648d11d9b07,"memory-infra: split up memory-infra coordinator service into two

This allows for heap profiler to use its own service with correct
capabilities and all other instances to use the existing coordinator
service.

Bug: 792028
Change-Id: I84e4ec71f5f1d00991c0516b1424ce7334bcd3cd
Reviewed-on: https://chromium-review.googlesource.com/836896
Commit-Queue: Lalit Maganti <lalitm@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: oysteine <oysteine@chromium.org>
Reviewed-by: Albert J. Wong <ajwong@chromium.org>
Reviewed-by: Hector Dearman <hjd@chromium.org>
Cr-Commit-Position: refs/heads/master@{#529059}",5,chrome/profiling/profiling_service.cc,"{""sha"": ""b3f7c3314257d54c61adbc79a81523ff3443903e"", ""filename"": ""chrome/profiling/profiling_manifest.json"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_manifest.json?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -8,7 +8,8 @@\n         \""profiling\"": [ \""profiling::mojom::ProfilingService\"" ]\n       },\n       \""requires\"": {\n-         \""*\"": [ \""app\"" ],\n+        \""*\"": [ \""app\"" ],\n+        \""resource_coordinator\"": [ \""heap_profiling\"" ],\n         \""service_manager\"": [ \""service_manager:all_users\"" ]\n       }\n     }""}<_**next**_>{""sha"": ""08afcc548d15361decac4ef2f5fb26e6f67b6d03"", ""filename"": ""chrome/profiling/profiling_service.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 7, ""changes"": 20, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_service.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -5,8 +5,11 @@\n #include \""chrome/profiling/profiling_service.h\""\n \n #include \""base/logging.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n #include \""mojo/public/cpp/system/platform_handle.h\""\n-#include \""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h\""\n+#include \""services/resource_coordinator/public/cpp/resource_coordinator_features.h\""\n+#include \""services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom.h\""\n+#include \""services/resource_coordinator/public/interfaces/service_constants.mojom.h\""\n \n namespace profiling {\n \n@@ -74,14 +77,17 @@ void ProfilingService::DumpProcessesForTracing(\n     bool keep_small_allocations,\n     bool strip_path_from_mapped_files,\n     DumpProcessesForTracingCallback callback) {\n+  if (!helper_) {\n+    context()->connector()->BindInterface(\n+        resource_coordinator::mojom::kServiceName, &helper_);\n+  }\n+\n   // Need a memory map to make sense of the dump. The dump will be triggered\n   // in the memory map global dump callback.\n-  // TODO(brettw) this should be a OnceCallback to avoid base::Passed.\n-  memory_instrumentation::MemoryInstrumentation::GetInstance()\n-      ->GetVmRegionsForHeapProfiler(base::Bind(\n-          &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n-          weak_factory_.GetWeakPtr(), keep_small_allocations,\n-          strip_path_from_mapped_files, base::Passed(&callback)));\n+  helper_->GetVmRegionsForHeapProfiler(base::Bind(\n+      &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n+      weak_factory_.GetWeakPtr(), keep_small_allocations,\n+      strip_path_from_mapped_files, base::Passed(&callback)));\n }\n \n void ProfilingService::GetProfiledPids(GetProfiledPidsCallback callback) {""}<_**next**_>{""sha"": ""d12423617b9df3ce1fb44eecc9955a90bd1b4267"", ""filename"": ""chrome/profiling/profiling_service.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_service.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -75,6 +75,7 @@ class ProfilingService : public service_manager::Service,\n   service_manager::BinderRegistry registry_;\n   mojo::BindingSet<mojom::ProfilingService> binding_set_;\n \n+  memory_instrumentation::mojom::HeapProfilerHelperPtr helper_;\n   MemlogConnectionManager connection_manager_;\n \n   // Must be last.""}<_**next**_>{""sha"": ""0dd7654dc8e598b99c0d1efabb14862dc9db86a7"", ""filename"": ""services/resource_coordinator/manifest.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/manifest.json?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -12,6 +12,7 @@\n           \""resource_coordinator::mojom::CoordinationUnitIntrospector\""\n         ],\n         \""coordination_unit\"": [ \""resource_coordinator::mojom::CoordinationUnitProvider\"" ],\n+        \""heap_profiling\"": [ \""memory_instrumentation::mojom::HeapProfilerHelper\"" ],\n         \""page_signal\"": [ \""resource_coordinator::mojom::PageSignalGenerator\"" ],\n         \""tracing\"": [ \""tracing::mojom::Coordinator\"" ],\n         \""tests\"": [ \""*\"" ]""}<_**next**_>{""sha"": ""74ae3c66dcdf52a0bd2f154e9efe9e3ff1f27501"", ""filename"": ""services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 3, ""changes"": 45, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -84,11 +84,30 @@ void CoordinatorImpl::BindCoordinatorRequest(\n   bindings_.AddBinding(this, std::move(request), source_info.identity);\n }\n \n+void CoordinatorImpl::BindHeapProfilerHelperRequest(\n+    mojom::HeapProfilerHelperRequest request,\n+    const service_manager::BindSourceInfo& source_info) {\n+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n+  bindings_heap_profiler_helper_.AddBinding(this, std::move(request),\n+                                            source_info.identity);\n+}\n+\n void CoordinatorImpl::RequestGlobalMemoryDump(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const std::vector<std::string>& allocator_dump_names,\n     const RequestGlobalMemoryDumpCallback& callback) {\n+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler\n+  // is allowed to obtain them using the special method on the different\n+  // interface.\n+  if (level_of_detail ==\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {\n+    bindings_.ReportBadMessage(\n+        \""Requested global memory dump using level of detail reserved for the \""\n+        \""heap profiler.\"");\n+    return;\n+  }\n+\n   // This merely strips out the |dump_guid| argument.\n   auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n                     bool success, uint64_t,\n@@ -122,14 +141,25 @@ void CoordinatorImpl::RequestGlobalMemoryDumpForPid(\n   QueuedRequest::Args args(\n       base::trace_event::MemoryDumpType::SUMMARY_ONLY,\n       base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND, {},\n-      false /* addToTrace */, pid);\n+      false /* add_to_trace */, pid);\n   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }\n \n void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {\n+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler\n+  // is allowed to obtain them using the special method on its own dedicated\n+  // interface (HeapProfilingHelper).\n+  if (level_of_detail ==\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {\n+    bindings_.ReportBadMessage(\n+        \""Requested global memory dump using level of detail reserved for the \""\n+        \""heap profiler.\"");\n+    return;\n+  }\n+\n   // This merely strips out the |dump_ptr| argument.\n   auto adapter =\n       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,\n@@ -143,9 +173,18 @@ void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n \n void CoordinatorImpl::GetVmRegionsForHeapProfiler(\n     const GetVmRegionsForHeapProfilerCallback& callback) {\n-  RequestGlobalMemoryDump(\n+  // This merely strips out the |dump_guid| argument.\n+  auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n+                    bool success, uint64_t dump_guid,\n+                    mojom::GlobalMemoryDumpPtr global_memory_dump) {\n+    callback.Run(success, std::move(global_memory_dump));\n+  };\n+\n+  QueuedRequest::Args args(\n       MemoryDumpType::EXPLICITLY_TRIGGERED,\n-      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {}, callback);\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {},\n+      false /* add_to_trace */, base::kNullProcessId);\n+  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }\n \n void CoordinatorImpl::RegisterClientProcess(""}<_**next**_>{""sha"": ""9bd62ddb438a2bb1cf07eb07e37b5243d5c1433e"", ""filename"": ""services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/memory_instrumentation/coordinator_impl.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -36,7 +36,9 @@ namespace memory_instrumentation {\n // - Provides global (i.e. for all processes) memory snapshots on demand.\n //   Global snapshots are obtained by requesting in-process snapshots from each\n //   registered client and aggregating them.\n-class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n+class CoordinatorImpl : public Coordinator,\n+                        public mojom::Coordinator,\n+                        public mojom::HeapProfilerHelper {\n  public:\n   // The getter of the unique instance.\n   static CoordinatorImpl* GetInstance();\n@@ -48,6 +50,10 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n       mojom::CoordinatorRequest,\n       const service_manager::BindSourceInfo& source_info) override;\n \n+  void BindHeapProfilerHelperRequest(\n+      mojom::HeapProfilerHelperRequest request,\n+      const service_manager::BindSourceInfo& source_info);\n+\n   // mojom::Coordinator implementation.\n   void RegisterClientProcess(mojom::ClientProcessPtr,\n                              mojom::ProcessType) override;\n@@ -64,6 +70,8 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n       base::trace_event::MemoryDumpType,\n       base::trace_event::MemoryDumpLevelOfDetail,\n       const RequestGlobalMemoryDumpAndAppendToTraceCallback&) override;\n+\n+  // mojom::HeapProfilerHelper implementation.\n   void GetVmRegionsForHeapProfiler(\n       const GetVmRegionsForHeapProfilerCallback&) override;\n \n@@ -135,6 +143,11 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n   // bindings_ must be closed before destroying the un-run callbacks.\n   mojo::BindingSet<mojom::Coordinator, service_manager::Identity> bindings_;\n \n+  // There may be extant callbacks in |queued_memory_dump_requests_|. The\n+  // bindings_ must be closed before destroying the un-run callbacks.\n+  mojo::BindingSet<mojom::HeapProfilerHelper, service_manager::Identity>\n+      bindings_heap_profiler_helper_;\n+\n   // Maintains a map of service_manager::Identity -> pid for registered clients.\n   std::unique_ptr<ProcessMap> process_map_;\n   uint64_t next_dump_id_;""}<_**next**_>{""sha"": ""a09d6f9be95d76038f3f1ed620fc3a6dcfd365dd"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 6, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -74,12 +74,6 @@ void MemoryInstrumentation::RequestGlobalDumpAndAppendToTrace(\n       dump_type, level_of_detail, callback);\n }\n \n-void MemoryInstrumentation::GetVmRegionsForHeapProfiler(\n-    RequestGlobalDumpCallback callback) {\n-  const auto& coordinator = GetCoordinatorBindingForCurrentThread();\n-  coordinator->GetVmRegionsForHeapProfiler(callback);\n-}\n-\n const mojom::CoordinatorPtr&\n MemoryInstrumentation::GetCoordinatorBindingForCurrentThread() {\n   mojom::CoordinatorPtr* coordinator =""}<_**next**_>{""sha"": ""045fdd3c4b0ea73dd001d27da8242b3fc707f0f8"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 9, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -81,15 +81,6 @@ class SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_EXPORT MemoryInstrumentation {\n       MemoryDumpLevelOfDetail,\n       RequestGlobalMemoryDumpAndAppendToTraceCallback);\n \n-  // Requests a global dump retrieving only the memory maps for all the client\n-  // processes registered. Does not add anything to the trace. The returned\n-  // GlobalMemoryDump will have only the |os_dump| field populated.\n-  // Returns asynchronously, via the callback argument:\n-  //  (true, global_dump) if succeeded;\n-  //  (false, nullptr) if failed.\n-  // The callback will be posted on the same thread of the caller.\n-  void GetVmRegionsForHeapProfiler(RequestGlobalDumpCallback);\n-\n  private:\n   MemoryInstrumentation(service_manager::Connector* connector,\n                         const std::string& service_name);""}<_**next**_>{""sha"": ""0d9dbcb65d0dde8e3273c24e85eebfce4c84a9a6"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -130,9 +130,6 @@ class MockCoordinator : public Coordinator, public mojom::Coordinator {\n       MemoryDumpLevelOfDetail level_of_detail,\n       const RequestGlobalMemoryDumpAndAppendToTraceCallback&) override;\n \n-  void GetVmRegionsForHeapProfiler(\n-      const GetVmRegionsForHeapProfilerCallback&) override {}\n-\n  private:\n   mojo::BindingSet<mojom::Coordinator> bindings_;\n   MemoryTracingIntegrationTest* client_;""}<_**next**_>{""sha"": ""3a917acc6010d68b89ea15223d4db5f1a3a89463"", ""filename"": ""services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -259,7 +259,10 @@ interface Coordinator {\n   RequestGlobalMemoryDumpAndAppendToTrace(DumpType dump_type,\n                                           LevelOfDetail level_of_detail) =>\n       (bool success, uint64 dump_id);\n+};\n \n+// Used by the Chrome heap profiler\n+interface HeapProfilerHelper {\n   // Broadcasts a RequestOSMemoryDump-only request for all registered client\n   // processes, retrieves only their memory maps and returns them in the field\n   // |global_memory_dump.process_dumps.os_dump.memory_maps_for_heap_profiler|.""}<_**next**_>{""sha"": ""51e296ff66185401b99e0c36b06a7492d036b6f8"", ""filename"": ""services/resource_coordinator/resource_coordinator_service.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/resource_coordinator_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/resource_coordinator_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/resource_coordinator_service.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -72,6 +72,9 @@ void ResourceCoordinatorService::OnStart() {\n   registry_.AddInterface(base::BindRepeating(\n       &memory_instrumentation::CoordinatorImpl::BindCoordinatorRequest,\n       base::Unretained(memory_instrumentation_coordinator_.get())));\n+  registry_.AddInterface(base::BindRepeating(\n+      &memory_instrumentation::CoordinatorImpl::BindHeapProfilerHelperRequest,\n+      base::Unretained(memory_instrumentation_coordinator_.get())));\n \n   tracing_agent_registry_ = std::make_unique<tracing::AgentRegistry>();\n   registry_.AddInterface(""}","void ProfilingService::DumpProcessesForTracing(
     bool keep_small_allocations,
     bool strip_path_from_mapped_files,
     DumpProcessesForTracingCallback callback) {
  if (!helper_) {
    context()->connector()->BindInterface(
        resource_coordinator::mojom::kServiceName, &helper_);
  }

  helper_->GetVmRegionsForHeapProfiler(base::Bind(
      &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,
      weak_factory_.GetWeakPtr(), keep_small_allocations,
      strip_path_from_mapped_files, base::Passed(&callback)));
 }
","void ProfilingService::DumpProcessesForTracing(
     bool keep_small_allocations,
     bool strip_path_from_mapped_files,
     DumpProcessesForTracingCallback callback) {
  memory_instrumentation::MemoryInstrumentation::GetInstance()
      ->GetVmRegionsForHeapProfiler(base::Bind(
          &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,
          weak_factory_.GetWeakPtr(), keep_small_allocations,
          strip_path_from_mapped_files, base::Passed(&callback)));
 }
",C,"  if (!helper_) {
    context()->connector()->BindInterface(
        resource_coordinator::mojom::kServiceName, &helper_);
  }

  helper_->GetVmRegionsForHeapProfiler(base::Bind(
      &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,
      weak_factory_.GetWeakPtr(), keep_small_allocations,
      strip_path_from_mapped_files, base::Passed(&callback)));
","  memory_instrumentation::MemoryInstrumentation::GetInstance()
      ->GetVmRegionsForHeapProfiler(base::Bind(
          &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,
          weak_factory_.GetWeakPtr(), keep_small_allocations,
          strip_path_from_mapped_files, base::Passed(&callback)));
",,"@@ -5,8 +5,11 @@
 #include ""chrome/profiling/profiling_service.h""
 
 #include ""base/logging.h""
+#include ""content/public/common/service_manager_connection.h""
 #include ""mojo/public/cpp/system/platform_handle.h""
-#include ""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h""
+#include ""services/resource_coordinator/public/cpp/resource_coordinator_features.h""
+#include ""services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom.h""
+#include ""services/resource_coordinator/public/interfaces/service_constants.mojom.h""
 
 namespace profiling {
 
@@ -74,14 +77,17 @@ void ProfilingService::DumpProcessesForTracing(
     bool keep_small_allocations,
     bool strip_path_from_mapped_files,
     DumpProcessesForTracingCallback callback) {
+  if (!helper_) {
+    context()->connector()->BindInterface(
+        resource_coordinator::mojom::kServiceName, &helper_);
+  }
+
   // Need a memory map to make sense of the dump. The dump will be triggered
   // in the memory map global dump callback.
-  // TODO(brettw) this should be a OnceCallback to avoid base::Passed.
-  memory_instrumentation::MemoryInstrumentation::GetInstance()
-      ->GetVmRegionsForHeapProfiler(base::Bind(
-          &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,
-          weak_factory_.GetWeakPtr(), keep_small_allocations,
-          strip_path_from_mapped_files, base::Passed(&callback)));
+  helper_->GetVmRegionsForHeapProfiler(base::Bind(
+      &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,
+      weak_factory_.GetWeakPtr(), keep_small_allocations,
+      strip_path_from_mapped_files, base::Passed(&callback)));
 }
 
 void ProfilingService::GetProfiledPids(GetProfiledPidsCallback callback) {",Chrome,b44e68087804e6543a99c87076ab7648d11d9b07,e07873b65983cf07f53e7b22dfc8a0a1b3aac586,1,"void ProfilingService::DumpProcessesForTracing(
     bool keep_small_allocations,
     bool strip_path_from_mapped_files,
     DumpProcessesForTracingCallback callback) {
//fix_flaw_line_below:
//  if (!helper_) {
//fix_flaw_line_below:
//    context()->connector()->BindInterface(
//fix_flaw_line_below:
//        resource_coordinator::mojom::kServiceName, &helper_);
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   // Need a memory map to make sense of the dump. The dump will be triggered
   // in the memory map global dump callback.
//flaw_line_below:
  // TODO(brettw) this should be a OnceCallback to avoid base::Passed.
//flaw_line_below:
  memory_instrumentation::MemoryInstrumentation::GetInstance()
//flaw_line_below:
      ->GetVmRegionsForHeapProfiler(base::Bind(
//flaw_line_below:
          &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,
//flaw_line_below:
          weak_factory_.GetWeakPtr(), keep_small_allocations,
//flaw_line_below:
          strip_path_from_mapped_files, base::Passed(&callback)));
//fix_flaw_line_below:
//  helper_->GetVmRegionsForHeapProfiler(base::Bind(
//fix_flaw_line_below:
//      &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,
//fix_flaw_line_below:
//      weak_factory_.GetWeakPtr(), keep_small_allocations,
//fix_flaw_line_below:
//      strip_path_from_mapped_files, base::Passed(&callback)));
 }
"
9155,186891,,Remote,Not required,,CVE-2018-6080,https://www.cvedetails.com/cve/CVE-2018-6080/,CWE-269,Medium,Partial,,,2018-11-14,4.3,Lack of access control checks in Instrumentation in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to obtain memory metadata from privileged processes .,2019-10-02,,11,https://github.com/chromium/chromium/commit/b44e68087804e6543a99c87076ab7648d11d9b07,b44e68087804e6543a99c87076ab7648d11d9b07,"memory-infra: split up memory-infra coordinator service into two

This allows for heap profiler to use its own service with correct
capabilities and all other instances to use the existing coordinator
service.

Bug: 792028
Change-Id: I84e4ec71f5f1d00991c0516b1424ce7334bcd3cd
Reviewed-on: https://chromium-review.googlesource.com/836896
Commit-Queue: Lalit Maganti <lalitm@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: oysteine <oysteine@chromium.org>
Reviewed-by: Albert J. Wong <ajwong@chromium.org>
Reviewed-by: Hector Dearman <hjd@chromium.org>
Cr-Commit-Position: refs/heads/master@{#529059}",2,services/resource_coordinator/memory_instrumentation/coordinator_impl.cc,"{""sha"": ""b3f7c3314257d54c61adbc79a81523ff3443903e"", ""filename"": ""chrome/profiling/profiling_manifest.json"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_manifest.json?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -8,7 +8,8 @@\n         \""profiling\"": [ \""profiling::mojom::ProfilingService\"" ]\n       },\n       \""requires\"": {\n-         \""*\"": [ \""app\"" ],\n+        \""*\"": [ \""app\"" ],\n+        \""resource_coordinator\"": [ \""heap_profiling\"" ],\n         \""service_manager\"": [ \""service_manager:all_users\"" ]\n       }\n     }""}<_**next**_>{""sha"": ""08afcc548d15361decac4ef2f5fb26e6f67b6d03"", ""filename"": ""chrome/profiling/profiling_service.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 7, ""changes"": 20, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_service.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -5,8 +5,11 @@\n #include \""chrome/profiling/profiling_service.h\""\n \n #include \""base/logging.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n #include \""mojo/public/cpp/system/platform_handle.h\""\n-#include \""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h\""\n+#include \""services/resource_coordinator/public/cpp/resource_coordinator_features.h\""\n+#include \""services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom.h\""\n+#include \""services/resource_coordinator/public/interfaces/service_constants.mojom.h\""\n \n namespace profiling {\n \n@@ -74,14 +77,17 @@ void ProfilingService::DumpProcessesForTracing(\n     bool keep_small_allocations,\n     bool strip_path_from_mapped_files,\n     DumpProcessesForTracingCallback callback) {\n+  if (!helper_) {\n+    context()->connector()->BindInterface(\n+        resource_coordinator::mojom::kServiceName, &helper_);\n+  }\n+\n   // Need a memory map to make sense of the dump. The dump will be triggered\n   // in the memory map global dump callback.\n-  // TODO(brettw) this should be a OnceCallback to avoid base::Passed.\n-  memory_instrumentation::MemoryInstrumentation::GetInstance()\n-      ->GetVmRegionsForHeapProfiler(base::Bind(\n-          &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n-          weak_factory_.GetWeakPtr(), keep_small_allocations,\n-          strip_path_from_mapped_files, base::Passed(&callback)));\n+  helper_->GetVmRegionsForHeapProfiler(base::Bind(\n+      &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n+      weak_factory_.GetWeakPtr(), keep_small_allocations,\n+      strip_path_from_mapped_files, base::Passed(&callback)));\n }\n \n void ProfilingService::GetProfiledPids(GetProfiledPidsCallback callback) {""}<_**next**_>{""sha"": ""d12423617b9df3ce1fb44eecc9955a90bd1b4267"", ""filename"": ""chrome/profiling/profiling_service.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_service.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -75,6 +75,7 @@ class ProfilingService : public service_manager::Service,\n   service_manager::BinderRegistry registry_;\n   mojo::BindingSet<mojom::ProfilingService> binding_set_;\n \n+  memory_instrumentation::mojom::HeapProfilerHelperPtr helper_;\n   MemlogConnectionManager connection_manager_;\n \n   // Must be last.""}<_**next**_>{""sha"": ""0dd7654dc8e598b99c0d1efabb14862dc9db86a7"", ""filename"": ""services/resource_coordinator/manifest.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/manifest.json?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -12,6 +12,7 @@\n           \""resource_coordinator::mojom::CoordinationUnitIntrospector\""\n         ],\n         \""coordination_unit\"": [ \""resource_coordinator::mojom::CoordinationUnitProvider\"" ],\n+        \""heap_profiling\"": [ \""memory_instrumentation::mojom::HeapProfilerHelper\"" ],\n         \""page_signal\"": [ \""resource_coordinator::mojom::PageSignalGenerator\"" ],\n         \""tracing\"": [ \""tracing::mojom::Coordinator\"" ],\n         \""tests\"": [ \""*\"" ]""}<_**next**_>{""sha"": ""74ae3c66dcdf52a0bd2f154e9efe9e3ff1f27501"", ""filename"": ""services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 3, ""changes"": 45, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -84,11 +84,30 @@ void CoordinatorImpl::BindCoordinatorRequest(\n   bindings_.AddBinding(this, std::move(request), source_info.identity);\n }\n \n+void CoordinatorImpl::BindHeapProfilerHelperRequest(\n+    mojom::HeapProfilerHelperRequest request,\n+    const service_manager::BindSourceInfo& source_info) {\n+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n+  bindings_heap_profiler_helper_.AddBinding(this, std::move(request),\n+                                            source_info.identity);\n+}\n+\n void CoordinatorImpl::RequestGlobalMemoryDump(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const std::vector<std::string>& allocator_dump_names,\n     const RequestGlobalMemoryDumpCallback& callback) {\n+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler\n+  // is allowed to obtain them using the special method on the different\n+  // interface.\n+  if (level_of_detail ==\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {\n+    bindings_.ReportBadMessage(\n+        \""Requested global memory dump using level of detail reserved for the \""\n+        \""heap profiler.\"");\n+    return;\n+  }\n+\n   // This merely strips out the |dump_guid| argument.\n   auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n                     bool success, uint64_t,\n@@ -122,14 +141,25 @@ void CoordinatorImpl::RequestGlobalMemoryDumpForPid(\n   QueuedRequest::Args args(\n       base::trace_event::MemoryDumpType::SUMMARY_ONLY,\n       base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND, {},\n-      false /* addToTrace */, pid);\n+      false /* add_to_trace */, pid);\n   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }\n \n void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {\n+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler\n+  // is allowed to obtain them using the special method on its own dedicated\n+  // interface (HeapProfilingHelper).\n+  if (level_of_detail ==\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {\n+    bindings_.ReportBadMessage(\n+        \""Requested global memory dump using level of detail reserved for the \""\n+        \""heap profiler.\"");\n+    return;\n+  }\n+\n   // This merely strips out the |dump_ptr| argument.\n   auto adapter =\n       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,\n@@ -143,9 +173,18 @@ void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n \n void CoordinatorImpl::GetVmRegionsForHeapProfiler(\n     const GetVmRegionsForHeapProfilerCallback& callback) {\n-  RequestGlobalMemoryDump(\n+  // This merely strips out the |dump_guid| argument.\n+  auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n+                    bool success, uint64_t dump_guid,\n+                    mojom::GlobalMemoryDumpPtr global_memory_dump) {\n+    callback.Run(success, std::move(global_memory_dump));\n+  };\n+\n+  QueuedRequest::Args args(\n       MemoryDumpType::EXPLICITLY_TRIGGERED,\n-      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {}, callback);\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {},\n+      false /* add_to_trace */, base::kNullProcessId);\n+  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }\n \n void CoordinatorImpl::RegisterClientProcess(""}<_**next**_>{""sha"": ""9bd62ddb438a2bb1cf07eb07e37b5243d5c1433e"", ""filename"": ""services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/memory_instrumentation/coordinator_impl.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -36,7 +36,9 @@ namespace memory_instrumentation {\n // - Provides global (i.e. for all processes) memory snapshots on demand.\n //   Global snapshots are obtained by requesting in-process snapshots from each\n //   registered client and aggregating them.\n-class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n+class CoordinatorImpl : public Coordinator,\n+                        public mojom::Coordinator,\n+                        public mojom::HeapProfilerHelper {\n  public:\n   // The getter of the unique instance.\n   static CoordinatorImpl* GetInstance();\n@@ -48,6 +50,10 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n       mojom::CoordinatorRequest,\n       const service_manager::BindSourceInfo& source_info) override;\n \n+  void BindHeapProfilerHelperRequest(\n+      mojom::HeapProfilerHelperRequest request,\n+      const service_manager::BindSourceInfo& source_info);\n+\n   // mojom::Coordinator implementation.\n   void RegisterClientProcess(mojom::ClientProcessPtr,\n                              mojom::ProcessType) override;\n@@ -64,6 +70,8 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n       base::trace_event::MemoryDumpType,\n       base::trace_event::MemoryDumpLevelOfDetail,\n       const RequestGlobalMemoryDumpAndAppendToTraceCallback&) override;\n+\n+  // mojom::HeapProfilerHelper implementation.\n   void GetVmRegionsForHeapProfiler(\n       const GetVmRegionsForHeapProfilerCallback&) override;\n \n@@ -135,6 +143,11 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n   // bindings_ must be closed before destroying the un-run callbacks.\n   mojo::BindingSet<mojom::Coordinator, service_manager::Identity> bindings_;\n \n+  // There may be extant callbacks in |queued_memory_dump_requests_|. The\n+  // bindings_ must be closed before destroying the un-run callbacks.\n+  mojo::BindingSet<mojom::HeapProfilerHelper, service_manager::Identity>\n+      bindings_heap_profiler_helper_;\n+\n   // Maintains a map of service_manager::Identity -> pid for registered clients.\n   std::unique_ptr<ProcessMap> process_map_;\n   uint64_t next_dump_id_;""}<_**next**_>{""sha"": ""a09d6f9be95d76038f3f1ed620fc3a6dcfd365dd"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 6, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -74,12 +74,6 @@ void MemoryInstrumentation::RequestGlobalDumpAndAppendToTrace(\n       dump_type, level_of_detail, callback);\n }\n \n-void MemoryInstrumentation::GetVmRegionsForHeapProfiler(\n-    RequestGlobalDumpCallback callback) {\n-  const auto& coordinator = GetCoordinatorBindingForCurrentThread();\n-  coordinator->GetVmRegionsForHeapProfiler(callback);\n-}\n-\n const mojom::CoordinatorPtr&\n MemoryInstrumentation::GetCoordinatorBindingForCurrentThread() {\n   mojom::CoordinatorPtr* coordinator =""}<_**next**_>{""sha"": ""045fdd3c4b0ea73dd001d27da8242b3fc707f0f8"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 9, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -81,15 +81,6 @@ class SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_EXPORT MemoryInstrumentation {\n       MemoryDumpLevelOfDetail,\n       RequestGlobalMemoryDumpAndAppendToTraceCallback);\n \n-  // Requests a global dump retrieving only the memory maps for all the client\n-  // processes registered. Does not add anything to the trace. The returned\n-  // GlobalMemoryDump will have only the |os_dump| field populated.\n-  // Returns asynchronously, via the callback argument:\n-  //  (true, global_dump) if succeeded;\n-  //  (false, nullptr) if failed.\n-  // The callback will be posted on the same thread of the caller.\n-  void GetVmRegionsForHeapProfiler(RequestGlobalDumpCallback);\n-\n  private:\n   MemoryInstrumentation(service_manager::Connector* connector,\n                         const std::string& service_name);""}<_**next**_>{""sha"": ""0d9dbcb65d0dde8e3273c24e85eebfce4c84a9a6"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -130,9 +130,6 @@ class MockCoordinator : public Coordinator, public mojom::Coordinator {\n       MemoryDumpLevelOfDetail level_of_detail,\n       const RequestGlobalMemoryDumpAndAppendToTraceCallback&) override;\n \n-  void GetVmRegionsForHeapProfiler(\n-      const GetVmRegionsForHeapProfilerCallback&) override {}\n-\n  private:\n   mojo::BindingSet<mojom::Coordinator> bindings_;\n   MemoryTracingIntegrationTest* client_;""}<_**next**_>{""sha"": ""3a917acc6010d68b89ea15223d4db5f1a3a89463"", ""filename"": ""services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -259,7 +259,10 @@ interface Coordinator {\n   RequestGlobalMemoryDumpAndAppendToTrace(DumpType dump_type,\n                                           LevelOfDetail level_of_detail) =>\n       (bool success, uint64 dump_id);\n+};\n \n+// Used by the Chrome heap profiler\n+interface HeapProfilerHelper {\n   // Broadcasts a RequestOSMemoryDump-only request for all registered client\n   // processes, retrieves only their memory maps and returns them in the field\n   // |global_memory_dump.process_dumps.os_dump.memory_maps_for_heap_profiler|.""}<_**next**_>{""sha"": ""51e296ff66185401b99e0c36b06a7492d036b6f8"", ""filename"": ""services/resource_coordinator/resource_coordinator_service.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/resource_coordinator_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/resource_coordinator_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/resource_coordinator_service.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -72,6 +72,9 @@ void ResourceCoordinatorService::OnStart() {\n   registry_.AddInterface(base::BindRepeating(\n       &memory_instrumentation::CoordinatorImpl::BindCoordinatorRequest,\n       base::Unretained(memory_instrumentation_coordinator_.get())));\n+  registry_.AddInterface(base::BindRepeating(\n+      &memory_instrumentation::CoordinatorImpl::BindHeapProfilerHelperRequest,\n+      base::Unretained(memory_instrumentation_coordinator_.get())));\n \n   tracing_agent_registry_ = std::make_unique<tracing::AgentRegistry>();\n   registry_.AddInterface(""}"," void CoordinatorImpl::GetVmRegionsForHeapProfiler(
     const GetVmRegionsForHeapProfilerCallback& callback) {
  // This merely strips out the |dump_guid| argument.
  auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,
                    bool success, uint64_t dump_guid,
                    mojom::GlobalMemoryDumpPtr global_memory_dump) {
    callback.Run(success, std::move(global_memory_dump));
  };

  QueuedRequest::Args args(
       MemoryDumpType::EXPLICITLY_TRIGGERED,
      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {},
      false /* add_to_trace */, base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
 }
"," void CoordinatorImpl::GetVmRegionsForHeapProfiler(
     const GetVmRegionsForHeapProfilerCallback& callback) {
  RequestGlobalMemoryDump(
       MemoryDumpType::EXPLICITLY_TRIGGERED,
      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {}, callback);
 }
",C,"  // This merely strips out the |dump_guid| argument.
  auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,
                    bool success, uint64_t dump_guid,
                    mojom::GlobalMemoryDumpPtr global_memory_dump) {
    callback.Run(success, std::move(global_memory_dump));
  };

  QueuedRequest::Args args(
      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {},
      false /* add_to_trace */, base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
","  RequestGlobalMemoryDump(
      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {}, callback);
",,"@@ -84,11 +84,30 @@ void CoordinatorImpl::BindCoordinatorRequest(
   bindings_.AddBinding(this, std::move(request), source_info.identity);
 }
 
+void CoordinatorImpl::BindHeapProfilerHelperRequest(
+    mojom::HeapProfilerHelperRequest request,
+    const service_manager::BindSourceInfo& source_info) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  bindings_heap_profiler_helper_.AddBinding(this, std::move(request),
+                                            source_info.identity);
+}
+
 void CoordinatorImpl::RequestGlobalMemoryDump(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const std::vector<std::string>& allocator_dump_names,
     const RequestGlobalMemoryDumpCallback& callback) {
+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler
+  // is allowed to obtain them using the special method on the different
+  // interface.
+  if (level_of_detail ==
+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {
+    bindings_.ReportBadMessage(
+        ""Requested global memory dump using level of detail reserved for the ""
+        ""heap profiler."");
+    return;
+  }
+
   // This merely strips out the |dump_guid| argument.
   auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,
                     bool success, uint64_t,
@@ -122,14 +141,25 @@ void CoordinatorImpl::RequestGlobalMemoryDumpForPid(
   QueuedRequest::Args args(
       base::trace_event::MemoryDumpType::SUMMARY_ONLY,
       base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND, {},
-      false /* addToTrace */, pid);
+      false /* add_to_trace */, pid);
   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
 }
 
 void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {
+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler
+  // is allowed to obtain them using the special method on its own dedicated
+  // interface (HeapProfilingHelper).
+  if (level_of_detail ==
+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {
+    bindings_.ReportBadMessage(
+        ""Requested global memory dump using level of detail reserved for the ""
+        ""heap profiler."");
+    return;
+  }
+
   // This merely strips out the |dump_ptr| argument.
   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,
@@ -143,9 +173,18 @@ void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
 
 void CoordinatorImpl::GetVmRegionsForHeapProfiler(
     const GetVmRegionsForHeapProfilerCallback& callback) {
-  RequestGlobalMemoryDump(
+  // This merely strips out the |dump_guid| argument.
+  auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,
+                    bool success, uint64_t dump_guid,
+                    mojom::GlobalMemoryDumpPtr global_memory_dump) {
+    callback.Run(success, std::move(global_memory_dump));
+  };
+
+  QueuedRequest::Args args(
       MemoryDumpType::EXPLICITLY_TRIGGERED,
-      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {}, callback);
+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {},
+      false /* add_to_trace */, base::kNullProcessId);
+  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
 }
 
 void CoordinatorImpl::RegisterClientProcess(",Chrome,b44e68087804e6543a99c87076ab7648d11d9b07,e07873b65983cf07f53e7b22dfc8a0a1b3aac586,1," void CoordinatorImpl::GetVmRegionsForHeapProfiler(
     const GetVmRegionsForHeapProfilerCallback& callback) {
//flaw_line_below:
  RequestGlobalMemoryDump(
//fix_flaw_line_below:
//  // This merely strips out the |dump_guid| argument.
//fix_flaw_line_below:
//  auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,
//fix_flaw_line_below:
//                    bool success, uint64_t dump_guid,
//fix_flaw_line_below:
//                    mojom::GlobalMemoryDumpPtr global_memory_dump) {
//fix_flaw_line_below:
//    callback.Run(success, std::move(global_memory_dump));
//fix_flaw_line_below:
//  };
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  QueuedRequest::Args args(
       MemoryDumpType::EXPLICITLY_TRIGGERED,
//flaw_line_below:
      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {}, callback);
//fix_flaw_line_below:
//      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {},
//fix_flaw_line_below:
//      false /* add_to_trace */, base::kNullProcessId);
//fix_flaw_line_below:
//  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
 }
"
9156,186892,,Remote,Not required,,CVE-2018-6080,https://www.cvedetails.com/cve/CVE-2018-6080/,CWE-269,Medium,Partial,,,2018-11-14,4.3,Lack of access control checks in Instrumentation in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to obtain memory metadata from privileged processes .,2019-10-02,,11,https://github.com/chromium/chromium/commit/b44e68087804e6543a99c87076ab7648d11d9b07,b44e68087804e6543a99c87076ab7648d11d9b07,"memory-infra: split up memory-infra coordinator service into two

This allows for heap profiler to use its own service with correct
capabilities and all other instances to use the existing coordinator
service.

Bug: 792028
Change-Id: I84e4ec71f5f1d00991c0516b1424ce7334bcd3cd
Reviewed-on: https://chromium-review.googlesource.com/836896
Commit-Queue: Lalit Maganti <lalitm@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: oysteine <oysteine@chromium.org>
Reviewed-by: Albert J. Wong <ajwong@chromium.org>
Reviewed-by: Hector Dearman <hjd@chromium.org>
Cr-Commit-Position: refs/heads/master@{#529059}",0,services/resource_coordinator/memory_instrumentation/coordinator_impl.cc,"{""sha"": ""b3f7c3314257d54c61adbc79a81523ff3443903e"", ""filename"": ""chrome/profiling/profiling_manifest.json"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_manifest.json?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -8,7 +8,8 @@\n         \""profiling\"": [ \""profiling::mojom::ProfilingService\"" ]\n       },\n       \""requires\"": {\n-         \""*\"": [ \""app\"" ],\n+        \""*\"": [ \""app\"" ],\n+        \""resource_coordinator\"": [ \""heap_profiling\"" ],\n         \""service_manager\"": [ \""service_manager:all_users\"" ]\n       }\n     }""}<_**next**_>{""sha"": ""08afcc548d15361decac4ef2f5fb26e6f67b6d03"", ""filename"": ""chrome/profiling/profiling_service.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 7, ""changes"": 20, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_service.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -5,8 +5,11 @@\n #include \""chrome/profiling/profiling_service.h\""\n \n #include \""base/logging.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n #include \""mojo/public/cpp/system/platform_handle.h\""\n-#include \""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h\""\n+#include \""services/resource_coordinator/public/cpp/resource_coordinator_features.h\""\n+#include \""services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom.h\""\n+#include \""services/resource_coordinator/public/interfaces/service_constants.mojom.h\""\n \n namespace profiling {\n \n@@ -74,14 +77,17 @@ void ProfilingService::DumpProcessesForTracing(\n     bool keep_small_allocations,\n     bool strip_path_from_mapped_files,\n     DumpProcessesForTracingCallback callback) {\n+  if (!helper_) {\n+    context()->connector()->BindInterface(\n+        resource_coordinator::mojom::kServiceName, &helper_);\n+  }\n+\n   // Need a memory map to make sense of the dump. The dump will be triggered\n   // in the memory map global dump callback.\n-  // TODO(brettw) this should be a OnceCallback to avoid base::Passed.\n-  memory_instrumentation::MemoryInstrumentation::GetInstance()\n-      ->GetVmRegionsForHeapProfiler(base::Bind(\n-          &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n-          weak_factory_.GetWeakPtr(), keep_small_allocations,\n-          strip_path_from_mapped_files, base::Passed(&callback)));\n+  helper_->GetVmRegionsForHeapProfiler(base::Bind(\n+      &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n+      weak_factory_.GetWeakPtr(), keep_small_allocations,\n+      strip_path_from_mapped_files, base::Passed(&callback)));\n }\n \n void ProfilingService::GetProfiledPids(GetProfiledPidsCallback callback) {""}<_**next**_>{""sha"": ""d12423617b9df3ce1fb44eecc9955a90bd1b4267"", ""filename"": ""chrome/profiling/profiling_service.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_service.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -75,6 +75,7 @@ class ProfilingService : public service_manager::Service,\n   service_manager::BinderRegistry registry_;\n   mojo::BindingSet<mojom::ProfilingService> binding_set_;\n \n+  memory_instrumentation::mojom::HeapProfilerHelperPtr helper_;\n   MemlogConnectionManager connection_manager_;\n \n   // Must be last.""}<_**next**_>{""sha"": ""0dd7654dc8e598b99c0d1efabb14862dc9db86a7"", ""filename"": ""services/resource_coordinator/manifest.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/manifest.json?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -12,6 +12,7 @@\n           \""resource_coordinator::mojom::CoordinationUnitIntrospector\""\n         ],\n         \""coordination_unit\"": [ \""resource_coordinator::mojom::CoordinationUnitProvider\"" ],\n+        \""heap_profiling\"": [ \""memory_instrumentation::mojom::HeapProfilerHelper\"" ],\n         \""page_signal\"": [ \""resource_coordinator::mojom::PageSignalGenerator\"" ],\n         \""tracing\"": [ \""tracing::mojom::Coordinator\"" ],\n         \""tests\"": [ \""*\"" ]""}<_**next**_>{""sha"": ""74ae3c66dcdf52a0bd2f154e9efe9e3ff1f27501"", ""filename"": ""services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 3, ""changes"": 45, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -84,11 +84,30 @@ void CoordinatorImpl::BindCoordinatorRequest(\n   bindings_.AddBinding(this, std::move(request), source_info.identity);\n }\n \n+void CoordinatorImpl::BindHeapProfilerHelperRequest(\n+    mojom::HeapProfilerHelperRequest request,\n+    const service_manager::BindSourceInfo& source_info) {\n+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n+  bindings_heap_profiler_helper_.AddBinding(this, std::move(request),\n+                                            source_info.identity);\n+}\n+\n void CoordinatorImpl::RequestGlobalMemoryDump(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const std::vector<std::string>& allocator_dump_names,\n     const RequestGlobalMemoryDumpCallback& callback) {\n+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler\n+  // is allowed to obtain them using the special method on the different\n+  // interface.\n+  if (level_of_detail ==\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {\n+    bindings_.ReportBadMessage(\n+        \""Requested global memory dump using level of detail reserved for the \""\n+        \""heap profiler.\"");\n+    return;\n+  }\n+\n   // This merely strips out the |dump_guid| argument.\n   auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n                     bool success, uint64_t,\n@@ -122,14 +141,25 @@ void CoordinatorImpl::RequestGlobalMemoryDumpForPid(\n   QueuedRequest::Args args(\n       base::trace_event::MemoryDumpType::SUMMARY_ONLY,\n       base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND, {},\n-      false /* addToTrace */, pid);\n+      false /* add_to_trace */, pid);\n   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }\n \n void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {\n+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler\n+  // is allowed to obtain them using the special method on its own dedicated\n+  // interface (HeapProfilingHelper).\n+  if (level_of_detail ==\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {\n+    bindings_.ReportBadMessage(\n+        \""Requested global memory dump using level of detail reserved for the \""\n+        \""heap profiler.\"");\n+    return;\n+  }\n+\n   // This merely strips out the |dump_ptr| argument.\n   auto adapter =\n       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,\n@@ -143,9 +173,18 @@ void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n \n void CoordinatorImpl::GetVmRegionsForHeapProfiler(\n     const GetVmRegionsForHeapProfilerCallback& callback) {\n-  RequestGlobalMemoryDump(\n+  // This merely strips out the |dump_guid| argument.\n+  auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n+                    bool success, uint64_t dump_guid,\n+                    mojom::GlobalMemoryDumpPtr global_memory_dump) {\n+    callback.Run(success, std::move(global_memory_dump));\n+  };\n+\n+  QueuedRequest::Args args(\n       MemoryDumpType::EXPLICITLY_TRIGGERED,\n-      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {}, callback);\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {},\n+      false /* add_to_trace */, base::kNullProcessId);\n+  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }\n \n void CoordinatorImpl::RegisterClientProcess(""}<_**next**_>{""sha"": ""9bd62ddb438a2bb1cf07eb07e37b5243d5c1433e"", ""filename"": ""services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/memory_instrumentation/coordinator_impl.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -36,7 +36,9 @@ namespace memory_instrumentation {\n // - Provides global (i.e. for all processes) memory snapshots on demand.\n //   Global snapshots are obtained by requesting in-process snapshots from each\n //   registered client and aggregating them.\n-class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n+class CoordinatorImpl : public Coordinator,\n+                        public mojom::Coordinator,\n+                        public mojom::HeapProfilerHelper {\n  public:\n   // The getter of the unique instance.\n   static CoordinatorImpl* GetInstance();\n@@ -48,6 +50,10 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n       mojom::CoordinatorRequest,\n       const service_manager::BindSourceInfo& source_info) override;\n \n+  void BindHeapProfilerHelperRequest(\n+      mojom::HeapProfilerHelperRequest request,\n+      const service_manager::BindSourceInfo& source_info);\n+\n   // mojom::Coordinator implementation.\n   void RegisterClientProcess(mojom::ClientProcessPtr,\n                              mojom::ProcessType) override;\n@@ -64,6 +70,8 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n       base::trace_event::MemoryDumpType,\n       base::trace_event::MemoryDumpLevelOfDetail,\n       const RequestGlobalMemoryDumpAndAppendToTraceCallback&) override;\n+\n+  // mojom::HeapProfilerHelper implementation.\n   void GetVmRegionsForHeapProfiler(\n       const GetVmRegionsForHeapProfilerCallback&) override;\n \n@@ -135,6 +143,11 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n   // bindings_ must be closed before destroying the un-run callbacks.\n   mojo::BindingSet<mojom::Coordinator, service_manager::Identity> bindings_;\n \n+  // There may be extant callbacks in |queued_memory_dump_requests_|. The\n+  // bindings_ must be closed before destroying the un-run callbacks.\n+  mojo::BindingSet<mojom::HeapProfilerHelper, service_manager::Identity>\n+      bindings_heap_profiler_helper_;\n+\n   // Maintains a map of service_manager::Identity -> pid for registered clients.\n   std::unique_ptr<ProcessMap> process_map_;\n   uint64_t next_dump_id_;""}<_**next**_>{""sha"": ""a09d6f9be95d76038f3f1ed620fc3a6dcfd365dd"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 6, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -74,12 +74,6 @@ void MemoryInstrumentation::RequestGlobalDumpAndAppendToTrace(\n       dump_type, level_of_detail, callback);\n }\n \n-void MemoryInstrumentation::GetVmRegionsForHeapProfiler(\n-    RequestGlobalDumpCallback callback) {\n-  const auto& coordinator = GetCoordinatorBindingForCurrentThread();\n-  coordinator->GetVmRegionsForHeapProfiler(callback);\n-}\n-\n const mojom::CoordinatorPtr&\n MemoryInstrumentation::GetCoordinatorBindingForCurrentThread() {\n   mojom::CoordinatorPtr* coordinator =""}<_**next**_>{""sha"": ""045fdd3c4b0ea73dd001d27da8242b3fc707f0f8"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 9, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -81,15 +81,6 @@ class SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_EXPORT MemoryInstrumentation {\n       MemoryDumpLevelOfDetail,\n       RequestGlobalMemoryDumpAndAppendToTraceCallback);\n \n-  // Requests a global dump retrieving only the memory maps for all the client\n-  // processes registered. Does not add anything to the trace. The returned\n-  // GlobalMemoryDump will have only the |os_dump| field populated.\n-  // Returns asynchronously, via the callback argument:\n-  //  (true, global_dump) if succeeded;\n-  //  (false, nullptr) if failed.\n-  // The callback will be posted on the same thread of the caller.\n-  void GetVmRegionsForHeapProfiler(RequestGlobalDumpCallback);\n-\n  private:\n   MemoryInstrumentation(service_manager::Connector* connector,\n                         const std::string& service_name);""}<_**next**_>{""sha"": ""0d9dbcb65d0dde8e3273c24e85eebfce4c84a9a6"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -130,9 +130,6 @@ class MockCoordinator : public Coordinator, public mojom::Coordinator {\n       MemoryDumpLevelOfDetail level_of_detail,\n       const RequestGlobalMemoryDumpAndAppendToTraceCallback&) override;\n \n-  void GetVmRegionsForHeapProfiler(\n-      const GetVmRegionsForHeapProfilerCallback&) override {}\n-\n  private:\n   mojo::BindingSet<mojom::Coordinator> bindings_;\n   MemoryTracingIntegrationTest* client_;""}<_**next**_>{""sha"": ""3a917acc6010d68b89ea15223d4db5f1a3a89463"", ""filename"": ""services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -259,7 +259,10 @@ interface Coordinator {\n   RequestGlobalMemoryDumpAndAppendToTrace(DumpType dump_type,\n                                           LevelOfDetail level_of_detail) =>\n       (bool success, uint64 dump_id);\n+};\n \n+// Used by the Chrome heap profiler\n+interface HeapProfilerHelper {\n   // Broadcasts a RequestOSMemoryDump-only request for all registered client\n   // processes, retrieves only their memory maps and returns them in the field\n   // |global_memory_dump.process_dumps.os_dump.memory_maps_for_heap_profiler|.""}<_**next**_>{""sha"": ""51e296ff66185401b99e0c36b06a7492d036b6f8"", ""filename"": ""services/resource_coordinator/resource_coordinator_service.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/resource_coordinator_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/resource_coordinator_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/resource_coordinator_service.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -72,6 +72,9 @@ void ResourceCoordinatorService::OnStart() {\n   registry_.AddInterface(base::BindRepeating(\n       &memory_instrumentation::CoordinatorImpl::BindCoordinatorRequest,\n       base::Unretained(memory_instrumentation_coordinator_.get())));\n+  registry_.AddInterface(base::BindRepeating(\n+      &memory_instrumentation::CoordinatorImpl::BindHeapProfilerHelperRequest,\n+      base::Unretained(memory_instrumentation_coordinator_.get())));\n \n   tracing_agent_registry_ = std::make_unique<tracing::AgentRegistry>();\n   registry_.AddInterface(""}"," void CoordinatorImpl::RequestGlobalMemoryDump(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const std::vector<std::string>& allocator_dump_names,
     const RequestGlobalMemoryDumpCallback& callback) {
  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler
  // is allowed to obtain them using the special method on the different
  // interface.
  if (level_of_detail ==
      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {
    bindings_.ReportBadMessage(
        ""Requested global memory dump using level of detail reserved for the ""
        ""heap profiler."");
    return;
  }

   auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,
                     bool success, uint64_t,
                    mojom::GlobalMemoryDumpPtr global_memory_dump) {
    callback.Run(success, std::move(global_memory_dump));
  };

  QueuedRequest::Args args(dump_type, level_of_detail, allocator_dump_names,
                           false /* add_to_trace */, base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
}
"," void CoordinatorImpl::RequestGlobalMemoryDump(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const std::vector<std::string>& allocator_dump_names,
     const RequestGlobalMemoryDumpCallback& callback) {
   auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,
                     bool success, uint64_t,
                    mojom::GlobalMemoryDumpPtr global_memory_dump) {
    callback.Run(success, std::move(global_memory_dump));
  };

  QueuedRequest::Args args(dump_type, level_of_detail, allocator_dump_names,
                           false /* add_to_trace */, base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
}
",C,"  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler
  // is allowed to obtain them using the special method on the different
  // interface.
  if (level_of_detail ==
      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {
    bindings_.ReportBadMessage(
        ""Requested global memory dump using level of detail reserved for the ""
        ""heap profiler."");
    return;
  }

",,,"@@ -84,11 +84,30 @@ void CoordinatorImpl::BindCoordinatorRequest(
   bindings_.AddBinding(this, std::move(request), source_info.identity);
 }
 
+void CoordinatorImpl::BindHeapProfilerHelperRequest(
+    mojom::HeapProfilerHelperRequest request,
+    const service_manager::BindSourceInfo& source_info) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  bindings_heap_profiler_helper_.AddBinding(this, std::move(request),
+                                            source_info.identity);
+}
+
 void CoordinatorImpl::RequestGlobalMemoryDump(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const std::vector<std::string>& allocator_dump_names,
     const RequestGlobalMemoryDumpCallback& callback) {
+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler
+  // is allowed to obtain them using the special method on the different
+  // interface.
+  if (level_of_detail ==
+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {
+    bindings_.ReportBadMessage(
+        ""Requested global memory dump using level of detail reserved for the ""
+        ""heap profiler."");
+    return;
+  }
+
   // This merely strips out the |dump_guid| argument.
   auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,
                     bool success, uint64_t,
@@ -122,14 +141,25 @@ void CoordinatorImpl::RequestGlobalMemoryDumpForPid(
   QueuedRequest::Args args(
       base::trace_event::MemoryDumpType::SUMMARY_ONLY,
       base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND, {},
-      false /* addToTrace */, pid);
+      false /* add_to_trace */, pid);
   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
 }
 
 void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {
+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler
+  // is allowed to obtain them using the special method on its own dedicated
+  // interface (HeapProfilingHelper).
+  if (level_of_detail ==
+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {
+    bindings_.ReportBadMessage(
+        ""Requested global memory dump using level of detail reserved for the ""
+        ""heap profiler."");
+    return;
+  }
+
   // This merely strips out the |dump_ptr| argument.
   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,
@@ -143,9 +173,18 @@ void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
 
 void CoordinatorImpl::GetVmRegionsForHeapProfiler(
     const GetVmRegionsForHeapProfilerCallback& callback) {
-  RequestGlobalMemoryDump(
+  // This merely strips out the |dump_guid| argument.
+  auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,
+                    bool success, uint64_t dump_guid,
+                    mojom::GlobalMemoryDumpPtr global_memory_dump) {
+    callback.Run(success, std::move(global_memory_dump));
+  };
+
+  QueuedRequest::Args args(
       MemoryDumpType::EXPLICITLY_TRIGGERED,
-      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {}, callback);
+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {},
+      false /* add_to_trace */, base::kNullProcessId);
+  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
 }
 
 void CoordinatorImpl::RegisterClientProcess(",Chrome,b44e68087804e6543a99c87076ab7648d11d9b07,e07873b65983cf07f53e7b22dfc8a0a1b3aac586,1," void CoordinatorImpl::RequestGlobalMemoryDump(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const std::vector<std::string>& allocator_dump_names,
     const RequestGlobalMemoryDumpCallback& callback) {
//fix_flaw_line_below:
//  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler
//fix_flaw_line_below:
//  // is allowed to obtain them using the special method on the different
//fix_flaw_line_below:
//  // interface.
//fix_flaw_line_below:
//  if (level_of_detail ==
//fix_flaw_line_below:
//      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {
//fix_flaw_line_below:
//    bindings_.ReportBadMessage(
//fix_flaw_line_below:
//        ""Requested global memory dump using level of detail reserved for the ""
//fix_flaw_line_below:
//        ""heap profiler."");
//fix_flaw_line_below:
//    return;
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   // This merely strips out the |dump_guid| argument.
   auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,
                     bool success, uint64_t,
                    mojom::GlobalMemoryDumpPtr global_memory_dump) {
    callback.Run(success, std::move(global_memory_dump));
  };

  QueuedRequest::Args args(dump_type, level_of_detail, allocator_dump_names,
                           false /* add_to_trace */, base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
}
"
9157,186893,,Remote,Not required,,CVE-2018-6080,https://www.cvedetails.com/cve/CVE-2018-6080/,CWE-269,Medium,Partial,,,2018-11-14,4.3,Lack of access control checks in Instrumentation in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to obtain memory metadata from privileged processes .,2019-10-02,,11,https://github.com/chromium/chromium/commit/b44e68087804e6543a99c87076ab7648d11d9b07,b44e68087804e6543a99c87076ab7648d11d9b07,"memory-infra: split up memory-infra coordinator service into two

This allows for heap profiler to use its own service with correct
capabilities and all other instances to use the existing coordinator
service.

Bug: 792028
Change-Id: I84e4ec71f5f1d00991c0516b1424ce7334bcd3cd
Reviewed-on: https://chromium-review.googlesource.com/836896
Commit-Queue: Lalit Maganti <lalitm@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: oysteine <oysteine@chromium.org>
Reviewed-by: Albert J. Wong <ajwong@chromium.org>
Reviewed-by: Hector Dearman <hjd@chromium.org>
Cr-Commit-Position: refs/heads/master@{#529059}",0,services/resource_coordinator/memory_instrumentation/coordinator_impl.cc,"{""sha"": ""b3f7c3314257d54c61adbc79a81523ff3443903e"", ""filename"": ""chrome/profiling/profiling_manifest.json"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_manifest.json?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -8,7 +8,8 @@\n         \""profiling\"": [ \""profiling::mojom::ProfilingService\"" ]\n       },\n       \""requires\"": {\n-         \""*\"": [ \""app\"" ],\n+        \""*\"": [ \""app\"" ],\n+        \""resource_coordinator\"": [ \""heap_profiling\"" ],\n         \""service_manager\"": [ \""service_manager:all_users\"" ]\n       }\n     }""}<_**next**_>{""sha"": ""08afcc548d15361decac4ef2f5fb26e6f67b6d03"", ""filename"": ""chrome/profiling/profiling_service.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 7, ""changes"": 20, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_service.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -5,8 +5,11 @@\n #include \""chrome/profiling/profiling_service.h\""\n \n #include \""base/logging.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n #include \""mojo/public/cpp/system/platform_handle.h\""\n-#include \""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h\""\n+#include \""services/resource_coordinator/public/cpp/resource_coordinator_features.h\""\n+#include \""services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom.h\""\n+#include \""services/resource_coordinator/public/interfaces/service_constants.mojom.h\""\n \n namespace profiling {\n \n@@ -74,14 +77,17 @@ void ProfilingService::DumpProcessesForTracing(\n     bool keep_small_allocations,\n     bool strip_path_from_mapped_files,\n     DumpProcessesForTracingCallback callback) {\n+  if (!helper_) {\n+    context()->connector()->BindInterface(\n+        resource_coordinator::mojom::kServiceName, &helper_);\n+  }\n+\n   // Need a memory map to make sense of the dump. The dump will be triggered\n   // in the memory map global dump callback.\n-  // TODO(brettw) this should be a OnceCallback to avoid base::Passed.\n-  memory_instrumentation::MemoryInstrumentation::GetInstance()\n-      ->GetVmRegionsForHeapProfiler(base::Bind(\n-          &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n-          weak_factory_.GetWeakPtr(), keep_small_allocations,\n-          strip_path_from_mapped_files, base::Passed(&callback)));\n+  helper_->GetVmRegionsForHeapProfiler(base::Bind(\n+      &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n+      weak_factory_.GetWeakPtr(), keep_small_allocations,\n+      strip_path_from_mapped_files, base::Passed(&callback)));\n }\n \n void ProfilingService::GetProfiledPids(GetProfiledPidsCallback callback) {""}<_**next**_>{""sha"": ""d12423617b9df3ce1fb44eecc9955a90bd1b4267"", ""filename"": ""chrome/profiling/profiling_service.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_service.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -75,6 +75,7 @@ class ProfilingService : public service_manager::Service,\n   service_manager::BinderRegistry registry_;\n   mojo::BindingSet<mojom::ProfilingService> binding_set_;\n \n+  memory_instrumentation::mojom::HeapProfilerHelperPtr helper_;\n   MemlogConnectionManager connection_manager_;\n \n   // Must be last.""}<_**next**_>{""sha"": ""0dd7654dc8e598b99c0d1efabb14862dc9db86a7"", ""filename"": ""services/resource_coordinator/manifest.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/manifest.json?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -12,6 +12,7 @@\n           \""resource_coordinator::mojom::CoordinationUnitIntrospector\""\n         ],\n         \""coordination_unit\"": [ \""resource_coordinator::mojom::CoordinationUnitProvider\"" ],\n+        \""heap_profiling\"": [ \""memory_instrumentation::mojom::HeapProfilerHelper\"" ],\n         \""page_signal\"": [ \""resource_coordinator::mojom::PageSignalGenerator\"" ],\n         \""tracing\"": [ \""tracing::mojom::Coordinator\"" ],\n         \""tests\"": [ \""*\"" ]""}<_**next**_>{""sha"": ""74ae3c66dcdf52a0bd2f154e9efe9e3ff1f27501"", ""filename"": ""services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 3, ""changes"": 45, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -84,11 +84,30 @@ void CoordinatorImpl::BindCoordinatorRequest(\n   bindings_.AddBinding(this, std::move(request), source_info.identity);\n }\n \n+void CoordinatorImpl::BindHeapProfilerHelperRequest(\n+    mojom::HeapProfilerHelperRequest request,\n+    const service_manager::BindSourceInfo& source_info) {\n+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n+  bindings_heap_profiler_helper_.AddBinding(this, std::move(request),\n+                                            source_info.identity);\n+}\n+\n void CoordinatorImpl::RequestGlobalMemoryDump(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const std::vector<std::string>& allocator_dump_names,\n     const RequestGlobalMemoryDumpCallback& callback) {\n+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler\n+  // is allowed to obtain them using the special method on the different\n+  // interface.\n+  if (level_of_detail ==\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {\n+    bindings_.ReportBadMessage(\n+        \""Requested global memory dump using level of detail reserved for the \""\n+        \""heap profiler.\"");\n+    return;\n+  }\n+\n   // This merely strips out the |dump_guid| argument.\n   auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n                     bool success, uint64_t,\n@@ -122,14 +141,25 @@ void CoordinatorImpl::RequestGlobalMemoryDumpForPid(\n   QueuedRequest::Args args(\n       base::trace_event::MemoryDumpType::SUMMARY_ONLY,\n       base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND, {},\n-      false /* addToTrace */, pid);\n+      false /* add_to_trace */, pid);\n   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }\n \n void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {\n+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler\n+  // is allowed to obtain them using the special method on its own dedicated\n+  // interface (HeapProfilingHelper).\n+  if (level_of_detail ==\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {\n+    bindings_.ReportBadMessage(\n+        \""Requested global memory dump using level of detail reserved for the \""\n+        \""heap profiler.\"");\n+    return;\n+  }\n+\n   // This merely strips out the |dump_ptr| argument.\n   auto adapter =\n       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,\n@@ -143,9 +173,18 @@ void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n \n void CoordinatorImpl::GetVmRegionsForHeapProfiler(\n     const GetVmRegionsForHeapProfilerCallback& callback) {\n-  RequestGlobalMemoryDump(\n+  // This merely strips out the |dump_guid| argument.\n+  auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n+                    bool success, uint64_t dump_guid,\n+                    mojom::GlobalMemoryDumpPtr global_memory_dump) {\n+    callback.Run(success, std::move(global_memory_dump));\n+  };\n+\n+  QueuedRequest::Args args(\n       MemoryDumpType::EXPLICITLY_TRIGGERED,\n-      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {}, callback);\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {},\n+      false /* add_to_trace */, base::kNullProcessId);\n+  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }\n \n void CoordinatorImpl::RegisterClientProcess(""}<_**next**_>{""sha"": ""9bd62ddb438a2bb1cf07eb07e37b5243d5c1433e"", ""filename"": ""services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/memory_instrumentation/coordinator_impl.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -36,7 +36,9 @@ namespace memory_instrumentation {\n // - Provides global (i.e. for all processes) memory snapshots on demand.\n //   Global snapshots are obtained by requesting in-process snapshots from each\n //   registered client and aggregating them.\n-class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n+class CoordinatorImpl : public Coordinator,\n+                        public mojom::Coordinator,\n+                        public mojom::HeapProfilerHelper {\n  public:\n   // The getter of the unique instance.\n   static CoordinatorImpl* GetInstance();\n@@ -48,6 +50,10 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n       mojom::CoordinatorRequest,\n       const service_manager::BindSourceInfo& source_info) override;\n \n+  void BindHeapProfilerHelperRequest(\n+      mojom::HeapProfilerHelperRequest request,\n+      const service_manager::BindSourceInfo& source_info);\n+\n   // mojom::Coordinator implementation.\n   void RegisterClientProcess(mojom::ClientProcessPtr,\n                              mojom::ProcessType) override;\n@@ -64,6 +70,8 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n       base::trace_event::MemoryDumpType,\n       base::trace_event::MemoryDumpLevelOfDetail,\n       const RequestGlobalMemoryDumpAndAppendToTraceCallback&) override;\n+\n+  // mojom::HeapProfilerHelper implementation.\n   void GetVmRegionsForHeapProfiler(\n       const GetVmRegionsForHeapProfilerCallback&) override;\n \n@@ -135,6 +143,11 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n   // bindings_ must be closed before destroying the un-run callbacks.\n   mojo::BindingSet<mojom::Coordinator, service_manager::Identity> bindings_;\n \n+  // There may be extant callbacks in |queued_memory_dump_requests_|. The\n+  // bindings_ must be closed before destroying the un-run callbacks.\n+  mojo::BindingSet<mojom::HeapProfilerHelper, service_manager::Identity>\n+      bindings_heap_profiler_helper_;\n+\n   // Maintains a map of service_manager::Identity -> pid for registered clients.\n   std::unique_ptr<ProcessMap> process_map_;\n   uint64_t next_dump_id_;""}<_**next**_>{""sha"": ""a09d6f9be95d76038f3f1ed620fc3a6dcfd365dd"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 6, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -74,12 +74,6 @@ void MemoryInstrumentation::RequestGlobalDumpAndAppendToTrace(\n       dump_type, level_of_detail, callback);\n }\n \n-void MemoryInstrumentation::GetVmRegionsForHeapProfiler(\n-    RequestGlobalDumpCallback callback) {\n-  const auto& coordinator = GetCoordinatorBindingForCurrentThread();\n-  coordinator->GetVmRegionsForHeapProfiler(callback);\n-}\n-\n const mojom::CoordinatorPtr&\n MemoryInstrumentation::GetCoordinatorBindingForCurrentThread() {\n   mojom::CoordinatorPtr* coordinator =""}<_**next**_>{""sha"": ""045fdd3c4b0ea73dd001d27da8242b3fc707f0f8"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 9, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -81,15 +81,6 @@ class SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_EXPORT MemoryInstrumentation {\n       MemoryDumpLevelOfDetail,\n       RequestGlobalMemoryDumpAndAppendToTraceCallback);\n \n-  // Requests a global dump retrieving only the memory maps for all the client\n-  // processes registered. Does not add anything to the trace. The returned\n-  // GlobalMemoryDump will have only the |os_dump| field populated.\n-  // Returns asynchronously, via the callback argument:\n-  //  (true, global_dump) if succeeded;\n-  //  (false, nullptr) if failed.\n-  // The callback will be posted on the same thread of the caller.\n-  void GetVmRegionsForHeapProfiler(RequestGlobalDumpCallback);\n-\n  private:\n   MemoryInstrumentation(service_manager::Connector* connector,\n                         const std::string& service_name);""}<_**next**_>{""sha"": ""0d9dbcb65d0dde8e3273c24e85eebfce4c84a9a6"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -130,9 +130,6 @@ class MockCoordinator : public Coordinator, public mojom::Coordinator {\n       MemoryDumpLevelOfDetail level_of_detail,\n       const RequestGlobalMemoryDumpAndAppendToTraceCallback&) override;\n \n-  void GetVmRegionsForHeapProfiler(\n-      const GetVmRegionsForHeapProfilerCallback&) override {}\n-\n  private:\n   mojo::BindingSet<mojom::Coordinator> bindings_;\n   MemoryTracingIntegrationTest* client_;""}<_**next**_>{""sha"": ""3a917acc6010d68b89ea15223d4db5f1a3a89463"", ""filename"": ""services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -259,7 +259,10 @@ interface Coordinator {\n   RequestGlobalMemoryDumpAndAppendToTrace(DumpType dump_type,\n                                           LevelOfDetail level_of_detail) =>\n       (bool success, uint64 dump_id);\n+};\n \n+// Used by the Chrome heap profiler\n+interface HeapProfilerHelper {\n   // Broadcasts a RequestOSMemoryDump-only request for all registered client\n   // processes, retrieves only their memory maps and returns them in the field\n   // |global_memory_dump.process_dumps.os_dump.memory_maps_for_heap_profiler|.""}<_**next**_>{""sha"": ""51e296ff66185401b99e0c36b06a7492d036b6f8"", ""filename"": ""services/resource_coordinator/resource_coordinator_service.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/resource_coordinator_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/resource_coordinator_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/resource_coordinator_service.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -72,6 +72,9 @@ void ResourceCoordinatorService::OnStart() {\n   registry_.AddInterface(base::BindRepeating(\n       &memory_instrumentation::CoordinatorImpl::BindCoordinatorRequest,\n       base::Unretained(memory_instrumentation_coordinator_.get())));\n+  registry_.AddInterface(base::BindRepeating(\n+      &memory_instrumentation::CoordinatorImpl::BindHeapProfilerHelperRequest,\n+      base::Unretained(memory_instrumentation_coordinator_.get())));\n \n   tracing_agent_registry_ = std::make_unique<tracing::AgentRegistry>();\n   registry_.AddInterface(""}"," void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {
  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler
  // is allowed to obtain them using the special method on its own dedicated
  // interface (HeapProfilingHelper).
  if (level_of_detail ==
      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {
    bindings_.ReportBadMessage(
        ""Requested global memory dump using level of detail reserved for the ""
        ""heap profiler."");
    return;
  }

   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,
         bool success, uint64_t dump_guid,
         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };

  QueuedRequest::Args args(dump_type, level_of_detail, {},
                           true /* add_to_trace */, base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
}
"," void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {
   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,
         bool success, uint64_t dump_guid,
         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };

  QueuedRequest::Args args(dump_type, level_of_detail, {},
                           true /* add_to_trace */, base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
}
",C,"  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler
  // is allowed to obtain them using the special method on its own dedicated
  // interface (HeapProfilingHelper).
  if (level_of_detail ==
      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {
    bindings_.ReportBadMessage(
        ""Requested global memory dump using level of detail reserved for the ""
        ""heap profiler."");
    return;
  }

",,,"@@ -84,11 +84,30 @@ void CoordinatorImpl::BindCoordinatorRequest(
   bindings_.AddBinding(this, std::move(request), source_info.identity);
 }
 
+void CoordinatorImpl::BindHeapProfilerHelperRequest(
+    mojom::HeapProfilerHelperRequest request,
+    const service_manager::BindSourceInfo& source_info) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  bindings_heap_profiler_helper_.AddBinding(this, std::move(request),
+                                            source_info.identity);
+}
+
 void CoordinatorImpl::RequestGlobalMemoryDump(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const std::vector<std::string>& allocator_dump_names,
     const RequestGlobalMemoryDumpCallback& callback) {
+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler
+  // is allowed to obtain them using the special method on the different
+  // interface.
+  if (level_of_detail ==
+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {
+    bindings_.ReportBadMessage(
+        ""Requested global memory dump using level of detail reserved for the ""
+        ""heap profiler."");
+    return;
+  }
+
   // This merely strips out the |dump_guid| argument.
   auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,
                     bool success, uint64_t,
@@ -122,14 +141,25 @@ void CoordinatorImpl::RequestGlobalMemoryDumpForPid(
   QueuedRequest::Args args(
       base::trace_event::MemoryDumpType::SUMMARY_ONLY,
       base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND, {},
-      false /* addToTrace */, pid);
+      false /* add_to_trace */, pid);
   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
 }
 
 void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {
+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler
+  // is allowed to obtain them using the special method on its own dedicated
+  // interface (HeapProfilingHelper).
+  if (level_of_detail ==
+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {
+    bindings_.ReportBadMessage(
+        ""Requested global memory dump using level of detail reserved for the ""
+        ""heap profiler."");
+    return;
+  }
+
   // This merely strips out the |dump_ptr| argument.
   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,
@@ -143,9 +173,18 @@ void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
 
 void CoordinatorImpl::GetVmRegionsForHeapProfiler(
     const GetVmRegionsForHeapProfilerCallback& callback) {
-  RequestGlobalMemoryDump(
+  // This merely strips out the |dump_guid| argument.
+  auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,
+                    bool success, uint64_t dump_guid,
+                    mojom::GlobalMemoryDumpPtr global_memory_dump) {
+    callback.Run(success, std::move(global_memory_dump));
+  };
+
+  QueuedRequest::Args args(
       MemoryDumpType::EXPLICITLY_TRIGGERED,
-      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {}, callback);
+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {},
+      false /* add_to_trace */, base::kNullProcessId);
+  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
 }
 
 void CoordinatorImpl::RegisterClientProcess(",Chrome,b44e68087804e6543a99c87076ab7648d11d9b07,e07873b65983cf07f53e7b22dfc8a0a1b3aac586,1," void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {
//fix_flaw_line_below:
//  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler
//fix_flaw_line_below:
//  // is allowed to obtain them using the special method on its own dedicated
//fix_flaw_line_below:
//  // interface (HeapProfilingHelper).
//fix_flaw_line_below:
//  if (level_of_detail ==
//fix_flaw_line_below:
//      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {
//fix_flaw_line_below:
//    bindings_.ReportBadMessage(
//fix_flaw_line_below:
//        ""Requested global memory dump using level of detail reserved for the ""
//fix_flaw_line_below:
//        ""heap profiler."");
//fix_flaw_line_below:
//    return;
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   // This merely strips out the |dump_ptr| argument.
   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,
         bool success, uint64_t dump_guid,
         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };

  QueuedRequest::Args args(dump_type, level_of_detail, {},
                           true /* add_to_trace */, base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
}
"
9158,186894,,Remote,Not required,,CVE-2018-6080,https://www.cvedetails.com/cve/CVE-2018-6080/,CWE-269,Medium,Partial,,,2018-11-14,4.3,Lack of access control checks in Instrumentation in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to obtain memory metadata from privileged processes .,2019-10-02,,1,https://github.com/chromium/chromium/commit/b44e68087804e6543a99c87076ab7648d11d9b07,b44e68087804e6543a99c87076ab7648d11d9b07,"memory-infra: split up memory-infra coordinator service into two

This allows for heap profiler to use its own service with correct
capabilities and all other instances to use the existing coordinator
service.

Bug: 792028
Change-Id: I84e4ec71f5f1d00991c0516b1424ce7334bcd3cd
Reviewed-on: https://chromium-review.googlesource.com/836896
Commit-Queue: Lalit Maganti <lalitm@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: oysteine <oysteine@chromium.org>
Reviewed-by: Albert J. Wong <ajwong@chromium.org>
Reviewed-by: Hector Dearman <hjd@chromium.org>
Cr-Commit-Position: refs/heads/master@{#529059}",1,services/resource_coordinator/memory_instrumentation/coordinator_impl.cc,"{""sha"": ""b3f7c3314257d54c61adbc79a81523ff3443903e"", ""filename"": ""chrome/profiling/profiling_manifest.json"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_manifest.json?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -8,7 +8,8 @@\n         \""profiling\"": [ \""profiling::mojom::ProfilingService\"" ]\n       },\n       \""requires\"": {\n-         \""*\"": [ \""app\"" ],\n+        \""*\"": [ \""app\"" ],\n+        \""resource_coordinator\"": [ \""heap_profiling\"" ],\n         \""service_manager\"": [ \""service_manager:all_users\"" ]\n       }\n     }""}<_**next**_>{""sha"": ""08afcc548d15361decac4ef2f5fb26e6f67b6d03"", ""filename"": ""chrome/profiling/profiling_service.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 7, ""changes"": 20, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_service.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -5,8 +5,11 @@\n #include \""chrome/profiling/profiling_service.h\""\n \n #include \""base/logging.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n #include \""mojo/public/cpp/system/platform_handle.h\""\n-#include \""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h\""\n+#include \""services/resource_coordinator/public/cpp/resource_coordinator_features.h\""\n+#include \""services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom.h\""\n+#include \""services/resource_coordinator/public/interfaces/service_constants.mojom.h\""\n \n namespace profiling {\n \n@@ -74,14 +77,17 @@ void ProfilingService::DumpProcessesForTracing(\n     bool keep_small_allocations,\n     bool strip_path_from_mapped_files,\n     DumpProcessesForTracingCallback callback) {\n+  if (!helper_) {\n+    context()->connector()->BindInterface(\n+        resource_coordinator::mojom::kServiceName, &helper_);\n+  }\n+\n   // Need a memory map to make sense of the dump. The dump will be triggered\n   // in the memory map global dump callback.\n-  // TODO(brettw) this should be a OnceCallback to avoid base::Passed.\n-  memory_instrumentation::MemoryInstrumentation::GetInstance()\n-      ->GetVmRegionsForHeapProfiler(base::Bind(\n-          &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n-          weak_factory_.GetWeakPtr(), keep_small_allocations,\n-          strip_path_from_mapped_files, base::Passed(&callback)));\n+  helper_->GetVmRegionsForHeapProfiler(base::Bind(\n+      &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n+      weak_factory_.GetWeakPtr(), keep_small_allocations,\n+      strip_path_from_mapped_files, base::Passed(&callback)));\n }\n \n void ProfilingService::GetProfiledPids(GetProfiledPidsCallback callback) {""}<_**next**_>{""sha"": ""d12423617b9df3ce1fb44eecc9955a90bd1b4267"", ""filename"": ""chrome/profiling/profiling_service.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_service.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -75,6 +75,7 @@ class ProfilingService : public service_manager::Service,\n   service_manager::BinderRegistry registry_;\n   mojo::BindingSet<mojom::ProfilingService> binding_set_;\n \n+  memory_instrumentation::mojom::HeapProfilerHelperPtr helper_;\n   MemlogConnectionManager connection_manager_;\n \n   // Must be last.""}<_**next**_>{""sha"": ""0dd7654dc8e598b99c0d1efabb14862dc9db86a7"", ""filename"": ""services/resource_coordinator/manifest.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/manifest.json?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -12,6 +12,7 @@\n           \""resource_coordinator::mojom::CoordinationUnitIntrospector\""\n         ],\n         \""coordination_unit\"": [ \""resource_coordinator::mojom::CoordinationUnitProvider\"" ],\n+        \""heap_profiling\"": [ \""memory_instrumentation::mojom::HeapProfilerHelper\"" ],\n         \""page_signal\"": [ \""resource_coordinator::mojom::PageSignalGenerator\"" ],\n         \""tracing\"": [ \""tracing::mojom::Coordinator\"" ],\n         \""tests\"": [ \""*\"" ]""}<_**next**_>{""sha"": ""74ae3c66dcdf52a0bd2f154e9efe9e3ff1f27501"", ""filename"": ""services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 3, ""changes"": 45, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -84,11 +84,30 @@ void CoordinatorImpl::BindCoordinatorRequest(\n   bindings_.AddBinding(this, std::move(request), source_info.identity);\n }\n \n+void CoordinatorImpl::BindHeapProfilerHelperRequest(\n+    mojom::HeapProfilerHelperRequest request,\n+    const service_manager::BindSourceInfo& source_info) {\n+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n+  bindings_heap_profiler_helper_.AddBinding(this, std::move(request),\n+                                            source_info.identity);\n+}\n+\n void CoordinatorImpl::RequestGlobalMemoryDump(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const std::vector<std::string>& allocator_dump_names,\n     const RequestGlobalMemoryDumpCallback& callback) {\n+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler\n+  // is allowed to obtain them using the special method on the different\n+  // interface.\n+  if (level_of_detail ==\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {\n+    bindings_.ReportBadMessage(\n+        \""Requested global memory dump using level of detail reserved for the \""\n+        \""heap profiler.\"");\n+    return;\n+  }\n+\n   // This merely strips out the |dump_guid| argument.\n   auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n                     bool success, uint64_t,\n@@ -122,14 +141,25 @@ void CoordinatorImpl::RequestGlobalMemoryDumpForPid(\n   QueuedRequest::Args args(\n       base::trace_event::MemoryDumpType::SUMMARY_ONLY,\n       base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND, {},\n-      false /* addToTrace */, pid);\n+      false /* add_to_trace */, pid);\n   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }\n \n void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {\n+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler\n+  // is allowed to obtain them using the special method on its own dedicated\n+  // interface (HeapProfilingHelper).\n+  if (level_of_detail ==\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {\n+    bindings_.ReportBadMessage(\n+        \""Requested global memory dump using level of detail reserved for the \""\n+        \""heap profiler.\"");\n+    return;\n+  }\n+\n   // This merely strips out the |dump_ptr| argument.\n   auto adapter =\n       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,\n@@ -143,9 +173,18 @@ void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n \n void CoordinatorImpl::GetVmRegionsForHeapProfiler(\n     const GetVmRegionsForHeapProfilerCallback& callback) {\n-  RequestGlobalMemoryDump(\n+  // This merely strips out the |dump_guid| argument.\n+  auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n+                    bool success, uint64_t dump_guid,\n+                    mojom::GlobalMemoryDumpPtr global_memory_dump) {\n+    callback.Run(success, std::move(global_memory_dump));\n+  };\n+\n+  QueuedRequest::Args args(\n       MemoryDumpType::EXPLICITLY_TRIGGERED,\n-      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {}, callback);\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {},\n+      false /* add_to_trace */, base::kNullProcessId);\n+  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }\n \n void CoordinatorImpl::RegisterClientProcess(""}<_**next**_>{""sha"": ""9bd62ddb438a2bb1cf07eb07e37b5243d5c1433e"", ""filename"": ""services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/memory_instrumentation/coordinator_impl.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -36,7 +36,9 @@ namespace memory_instrumentation {\n // - Provides global (i.e. for all processes) memory snapshots on demand.\n //   Global snapshots are obtained by requesting in-process snapshots from each\n //   registered client and aggregating them.\n-class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n+class CoordinatorImpl : public Coordinator,\n+                        public mojom::Coordinator,\n+                        public mojom::HeapProfilerHelper {\n  public:\n   // The getter of the unique instance.\n   static CoordinatorImpl* GetInstance();\n@@ -48,6 +50,10 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n       mojom::CoordinatorRequest,\n       const service_manager::BindSourceInfo& source_info) override;\n \n+  void BindHeapProfilerHelperRequest(\n+      mojom::HeapProfilerHelperRequest request,\n+      const service_manager::BindSourceInfo& source_info);\n+\n   // mojom::Coordinator implementation.\n   void RegisterClientProcess(mojom::ClientProcessPtr,\n                              mojom::ProcessType) override;\n@@ -64,6 +70,8 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n       base::trace_event::MemoryDumpType,\n       base::trace_event::MemoryDumpLevelOfDetail,\n       const RequestGlobalMemoryDumpAndAppendToTraceCallback&) override;\n+\n+  // mojom::HeapProfilerHelper implementation.\n   void GetVmRegionsForHeapProfiler(\n       const GetVmRegionsForHeapProfilerCallback&) override;\n \n@@ -135,6 +143,11 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n   // bindings_ must be closed before destroying the un-run callbacks.\n   mojo::BindingSet<mojom::Coordinator, service_manager::Identity> bindings_;\n \n+  // There may be extant callbacks in |queued_memory_dump_requests_|. The\n+  // bindings_ must be closed before destroying the un-run callbacks.\n+  mojo::BindingSet<mojom::HeapProfilerHelper, service_manager::Identity>\n+      bindings_heap_profiler_helper_;\n+\n   // Maintains a map of service_manager::Identity -> pid for registered clients.\n   std::unique_ptr<ProcessMap> process_map_;\n   uint64_t next_dump_id_;""}<_**next**_>{""sha"": ""a09d6f9be95d76038f3f1ed620fc3a6dcfd365dd"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 6, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -74,12 +74,6 @@ void MemoryInstrumentation::RequestGlobalDumpAndAppendToTrace(\n       dump_type, level_of_detail, callback);\n }\n \n-void MemoryInstrumentation::GetVmRegionsForHeapProfiler(\n-    RequestGlobalDumpCallback callback) {\n-  const auto& coordinator = GetCoordinatorBindingForCurrentThread();\n-  coordinator->GetVmRegionsForHeapProfiler(callback);\n-}\n-\n const mojom::CoordinatorPtr&\n MemoryInstrumentation::GetCoordinatorBindingForCurrentThread() {\n   mojom::CoordinatorPtr* coordinator =""}<_**next**_>{""sha"": ""045fdd3c4b0ea73dd001d27da8242b3fc707f0f8"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 9, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -81,15 +81,6 @@ class SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_EXPORT MemoryInstrumentation {\n       MemoryDumpLevelOfDetail,\n       RequestGlobalMemoryDumpAndAppendToTraceCallback);\n \n-  // Requests a global dump retrieving only the memory maps for all the client\n-  // processes registered. Does not add anything to the trace. The returned\n-  // GlobalMemoryDump will have only the |os_dump| field populated.\n-  // Returns asynchronously, via the callback argument:\n-  //  (true, global_dump) if succeeded;\n-  //  (false, nullptr) if failed.\n-  // The callback will be posted on the same thread of the caller.\n-  void GetVmRegionsForHeapProfiler(RequestGlobalDumpCallback);\n-\n  private:\n   MemoryInstrumentation(service_manager::Connector* connector,\n                         const std::string& service_name);""}<_**next**_>{""sha"": ""0d9dbcb65d0dde8e3273c24e85eebfce4c84a9a6"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -130,9 +130,6 @@ class MockCoordinator : public Coordinator, public mojom::Coordinator {\n       MemoryDumpLevelOfDetail level_of_detail,\n       const RequestGlobalMemoryDumpAndAppendToTraceCallback&) override;\n \n-  void GetVmRegionsForHeapProfiler(\n-      const GetVmRegionsForHeapProfilerCallback&) override {}\n-\n  private:\n   mojo::BindingSet<mojom::Coordinator> bindings_;\n   MemoryTracingIntegrationTest* client_;""}<_**next**_>{""sha"": ""3a917acc6010d68b89ea15223d4db5f1a3a89463"", ""filename"": ""services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -259,7 +259,10 @@ interface Coordinator {\n   RequestGlobalMemoryDumpAndAppendToTrace(DumpType dump_type,\n                                           LevelOfDetail level_of_detail) =>\n       (bool success, uint64 dump_id);\n+};\n \n+// Used by the Chrome heap profiler\n+interface HeapProfilerHelper {\n   // Broadcasts a RequestOSMemoryDump-only request for all registered client\n   // processes, retrieves only their memory maps and returns them in the field\n   // |global_memory_dump.process_dumps.os_dump.memory_maps_for_heap_profiler|.""}<_**next**_>{""sha"": ""51e296ff66185401b99e0c36b06a7492d036b6f8"", ""filename"": ""services/resource_coordinator/resource_coordinator_service.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/resource_coordinator_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/resource_coordinator_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/resource_coordinator_service.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -72,6 +72,9 @@ void ResourceCoordinatorService::OnStart() {\n   registry_.AddInterface(base::BindRepeating(\n       &memory_instrumentation::CoordinatorImpl::BindCoordinatorRequest,\n       base::Unretained(memory_instrumentation_coordinator_.get())));\n+  registry_.AddInterface(base::BindRepeating(\n+      &memory_instrumentation::CoordinatorImpl::BindHeapProfilerHelperRequest,\n+      base::Unretained(memory_instrumentation_coordinator_.get())));\n \n   tracing_agent_registry_ = std::make_unique<tracing::AgentRegistry>();\n   registry_.AddInterface(""}","void CoordinatorImpl::RequestGlobalMemoryDumpForPid(
    base::ProcessId pid,
    const RequestGlobalMemoryDumpForPidCallback& callback) {
  if (pid == base::kNullProcessId) {
    callback.Run(false, nullptr);
    return;
  }

  auto adapter = [](const RequestGlobalMemoryDumpForPidCallback& callback,
                    bool success, uint64_t,
                    mojom::GlobalMemoryDumpPtr global_memory_dump) {
    callback.Run(success, std::move(global_memory_dump));
  };

   QueuedRequest::Args args(
       base::trace_event::MemoryDumpType::SUMMARY_ONLY,
       base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND, {},
      false /* add_to_trace */, pid);
   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
 }
","void CoordinatorImpl::RequestGlobalMemoryDumpForPid(
    base::ProcessId pid,
    const RequestGlobalMemoryDumpForPidCallback& callback) {
  if (pid == base::kNullProcessId) {
    callback.Run(false, nullptr);
    return;
  }

  auto adapter = [](const RequestGlobalMemoryDumpForPidCallback& callback,
                    bool success, uint64_t,
                    mojom::GlobalMemoryDumpPtr global_memory_dump) {
    callback.Run(success, std::move(global_memory_dump));
  };

   QueuedRequest::Args args(
       base::trace_event::MemoryDumpType::SUMMARY_ONLY,
       base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND, {},
      false /* addToTrace */, pid);
   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
 }
",C,"      false /* add_to_trace */, pid);
","      false /* addToTrace */, pid);
",,"@@ -84,11 +84,30 @@ void CoordinatorImpl::BindCoordinatorRequest(
   bindings_.AddBinding(this, std::move(request), source_info.identity);
 }
 
+void CoordinatorImpl::BindHeapProfilerHelperRequest(
+    mojom::HeapProfilerHelperRequest request,
+    const service_manager::BindSourceInfo& source_info) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  bindings_heap_profiler_helper_.AddBinding(this, std::move(request),
+                                            source_info.identity);
+}
+
 void CoordinatorImpl::RequestGlobalMemoryDump(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const std::vector<std::string>& allocator_dump_names,
     const RequestGlobalMemoryDumpCallback& callback) {
+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler
+  // is allowed to obtain them using the special method on the different
+  // interface.
+  if (level_of_detail ==
+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {
+    bindings_.ReportBadMessage(
+        ""Requested global memory dump using level of detail reserved for the ""
+        ""heap profiler."");
+    return;
+  }
+
   // This merely strips out the |dump_guid| argument.
   auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,
                     bool success, uint64_t,
@@ -122,14 +141,25 @@ void CoordinatorImpl::RequestGlobalMemoryDumpForPid(
   QueuedRequest::Args args(
       base::trace_event::MemoryDumpType::SUMMARY_ONLY,
       base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND, {},
-      false /* addToTrace */, pid);
+      false /* add_to_trace */, pid);
   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
 }
 
 void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {
+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler
+  // is allowed to obtain them using the special method on its own dedicated
+  // interface (HeapProfilingHelper).
+  if (level_of_detail ==
+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {
+    bindings_.ReportBadMessage(
+        ""Requested global memory dump using level of detail reserved for the ""
+        ""heap profiler."");
+    return;
+  }
+
   // This merely strips out the |dump_ptr| argument.
   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,
@@ -143,9 +173,18 @@ void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
 
 void CoordinatorImpl::GetVmRegionsForHeapProfiler(
     const GetVmRegionsForHeapProfilerCallback& callback) {
-  RequestGlobalMemoryDump(
+  // This merely strips out the |dump_guid| argument.
+  auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,
+                    bool success, uint64_t dump_guid,
+                    mojom::GlobalMemoryDumpPtr global_memory_dump) {
+    callback.Run(success, std::move(global_memory_dump));
+  };
+
+  QueuedRequest::Args args(
       MemoryDumpType::EXPLICITLY_TRIGGERED,
-      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {}, callback);
+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {},
+      false /* add_to_trace */, base::kNullProcessId);
+  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
 }
 
 void CoordinatorImpl::RegisterClientProcess(",Chrome,b44e68087804e6543a99c87076ab7648d11d9b07,e07873b65983cf07f53e7b22dfc8a0a1b3aac586,1,"void CoordinatorImpl::RequestGlobalMemoryDumpForPid(
    base::ProcessId pid,
    const RequestGlobalMemoryDumpForPidCallback& callback) {
  // Error out early if process id is null to avoid confusing with global
  // dump for all processes case when pid is kNullProcessId.
  if (pid == base::kNullProcessId) {
    callback.Run(false, nullptr);
    return;
  }

  // This merely strips out the |dump_guid| argument; this is not relevant
  // as we are not adding to trace.
  auto adapter = [](const RequestGlobalMemoryDumpForPidCallback& callback,
                    bool success, uint64_t,
                    mojom::GlobalMemoryDumpPtr global_memory_dump) {
    callback.Run(success, std::move(global_memory_dump));
  };

   QueuedRequest::Args args(
       base::trace_event::MemoryDumpType::SUMMARY_ONLY,
       base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND, {},
//flaw_line_below:
      false /* addToTrace */, pid);
//fix_flaw_line_below:
//      false /* add_to_trace */, pid);
   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
 }
"
9159,186895,,Remote,Not required,,CVE-2018-6080,https://www.cvedetails.com/cve/CVE-2018-6080/,CWE-269,Medium,Partial,,,2018-11-14,4.3,Lack of access control checks in Instrumentation in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to obtain memory metadata from privileged processes .,2019-10-02,,0,https://github.com/chromium/chromium/commit/b44e68087804e6543a99c87076ab7648d11d9b07,b44e68087804e6543a99c87076ab7648d11d9b07,"memory-infra: split up memory-infra coordinator service into two

This allows for heap profiler to use its own service with correct
capabilities and all other instances to use the existing coordinator
service.

Bug: 792028
Change-Id: I84e4ec71f5f1d00991c0516b1424ce7334bcd3cd
Reviewed-on: https://chromium-review.googlesource.com/836896
Commit-Queue: Lalit Maganti <lalitm@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: oysteine <oysteine@chromium.org>
Reviewed-by: Albert J. Wong <ajwong@chromium.org>
Reviewed-by: Hector Dearman <hjd@chromium.org>
Cr-Commit-Position: refs/heads/master@{#529059}",4,services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc,"{""sha"": ""b3f7c3314257d54c61adbc79a81523ff3443903e"", ""filename"": ""chrome/profiling/profiling_manifest.json"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_manifest.json?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -8,7 +8,8 @@\n         \""profiling\"": [ \""profiling::mojom::ProfilingService\"" ]\n       },\n       \""requires\"": {\n-         \""*\"": [ \""app\"" ],\n+        \""*\"": [ \""app\"" ],\n+        \""resource_coordinator\"": [ \""heap_profiling\"" ],\n         \""service_manager\"": [ \""service_manager:all_users\"" ]\n       }\n     }""}<_**next**_>{""sha"": ""08afcc548d15361decac4ef2f5fb26e6f67b6d03"", ""filename"": ""chrome/profiling/profiling_service.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 7, ""changes"": 20, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_service.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -5,8 +5,11 @@\n #include \""chrome/profiling/profiling_service.h\""\n \n #include \""base/logging.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n #include \""mojo/public/cpp/system/platform_handle.h\""\n-#include \""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h\""\n+#include \""services/resource_coordinator/public/cpp/resource_coordinator_features.h\""\n+#include \""services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom.h\""\n+#include \""services/resource_coordinator/public/interfaces/service_constants.mojom.h\""\n \n namespace profiling {\n \n@@ -74,14 +77,17 @@ void ProfilingService::DumpProcessesForTracing(\n     bool keep_small_allocations,\n     bool strip_path_from_mapped_files,\n     DumpProcessesForTracingCallback callback) {\n+  if (!helper_) {\n+    context()->connector()->BindInterface(\n+        resource_coordinator::mojom::kServiceName, &helper_);\n+  }\n+\n   // Need a memory map to make sense of the dump. The dump will be triggered\n   // in the memory map global dump callback.\n-  // TODO(brettw) this should be a OnceCallback to avoid base::Passed.\n-  memory_instrumentation::MemoryInstrumentation::GetInstance()\n-      ->GetVmRegionsForHeapProfiler(base::Bind(\n-          &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n-          weak_factory_.GetWeakPtr(), keep_small_allocations,\n-          strip_path_from_mapped_files, base::Passed(&callback)));\n+  helper_->GetVmRegionsForHeapProfiler(base::Bind(\n+      &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n+      weak_factory_.GetWeakPtr(), keep_small_allocations,\n+      strip_path_from_mapped_files, base::Passed(&callback)));\n }\n \n void ProfilingService::GetProfiledPids(GetProfiledPidsCallback callback) {""}<_**next**_>{""sha"": ""d12423617b9df3ce1fb44eecc9955a90bd1b4267"", ""filename"": ""chrome/profiling/profiling_service.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_service.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -75,6 +75,7 @@ class ProfilingService : public service_manager::Service,\n   service_manager::BinderRegistry registry_;\n   mojo::BindingSet<mojom::ProfilingService> binding_set_;\n \n+  memory_instrumentation::mojom::HeapProfilerHelperPtr helper_;\n   MemlogConnectionManager connection_manager_;\n \n   // Must be last.""}<_**next**_>{""sha"": ""0dd7654dc8e598b99c0d1efabb14862dc9db86a7"", ""filename"": ""services/resource_coordinator/manifest.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/manifest.json?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -12,6 +12,7 @@\n           \""resource_coordinator::mojom::CoordinationUnitIntrospector\""\n         ],\n         \""coordination_unit\"": [ \""resource_coordinator::mojom::CoordinationUnitProvider\"" ],\n+        \""heap_profiling\"": [ \""memory_instrumentation::mojom::HeapProfilerHelper\"" ],\n         \""page_signal\"": [ \""resource_coordinator::mojom::PageSignalGenerator\"" ],\n         \""tracing\"": [ \""tracing::mojom::Coordinator\"" ],\n         \""tests\"": [ \""*\"" ]""}<_**next**_>{""sha"": ""74ae3c66dcdf52a0bd2f154e9efe9e3ff1f27501"", ""filename"": ""services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 3, ""changes"": 45, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -84,11 +84,30 @@ void CoordinatorImpl::BindCoordinatorRequest(\n   bindings_.AddBinding(this, std::move(request), source_info.identity);\n }\n \n+void CoordinatorImpl::BindHeapProfilerHelperRequest(\n+    mojom::HeapProfilerHelperRequest request,\n+    const service_manager::BindSourceInfo& source_info) {\n+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n+  bindings_heap_profiler_helper_.AddBinding(this, std::move(request),\n+                                            source_info.identity);\n+}\n+\n void CoordinatorImpl::RequestGlobalMemoryDump(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const std::vector<std::string>& allocator_dump_names,\n     const RequestGlobalMemoryDumpCallback& callback) {\n+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler\n+  // is allowed to obtain them using the special method on the different\n+  // interface.\n+  if (level_of_detail ==\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {\n+    bindings_.ReportBadMessage(\n+        \""Requested global memory dump using level of detail reserved for the \""\n+        \""heap profiler.\"");\n+    return;\n+  }\n+\n   // This merely strips out the |dump_guid| argument.\n   auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n                     bool success, uint64_t,\n@@ -122,14 +141,25 @@ void CoordinatorImpl::RequestGlobalMemoryDumpForPid(\n   QueuedRequest::Args args(\n       base::trace_event::MemoryDumpType::SUMMARY_ONLY,\n       base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND, {},\n-      false /* addToTrace */, pid);\n+      false /* add_to_trace */, pid);\n   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }\n \n void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {\n+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler\n+  // is allowed to obtain them using the special method on its own dedicated\n+  // interface (HeapProfilingHelper).\n+  if (level_of_detail ==\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {\n+    bindings_.ReportBadMessage(\n+        \""Requested global memory dump using level of detail reserved for the \""\n+        \""heap profiler.\"");\n+    return;\n+  }\n+\n   // This merely strips out the |dump_ptr| argument.\n   auto adapter =\n       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,\n@@ -143,9 +173,18 @@ void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n \n void CoordinatorImpl::GetVmRegionsForHeapProfiler(\n     const GetVmRegionsForHeapProfilerCallback& callback) {\n-  RequestGlobalMemoryDump(\n+  // This merely strips out the |dump_guid| argument.\n+  auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n+                    bool success, uint64_t dump_guid,\n+                    mojom::GlobalMemoryDumpPtr global_memory_dump) {\n+    callback.Run(success, std::move(global_memory_dump));\n+  };\n+\n+  QueuedRequest::Args args(\n       MemoryDumpType::EXPLICITLY_TRIGGERED,\n-      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {}, callback);\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {},\n+      false /* add_to_trace */, base::kNullProcessId);\n+  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }\n \n void CoordinatorImpl::RegisterClientProcess(""}<_**next**_>{""sha"": ""9bd62ddb438a2bb1cf07eb07e37b5243d5c1433e"", ""filename"": ""services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/memory_instrumentation/coordinator_impl.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -36,7 +36,9 @@ namespace memory_instrumentation {\n // - Provides global (i.e. for all processes) memory snapshots on demand.\n //   Global snapshots are obtained by requesting in-process snapshots from each\n //   registered client and aggregating them.\n-class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n+class CoordinatorImpl : public Coordinator,\n+                        public mojom::Coordinator,\n+                        public mojom::HeapProfilerHelper {\n  public:\n   // The getter of the unique instance.\n   static CoordinatorImpl* GetInstance();\n@@ -48,6 +50,10 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n       mojom::CoordinatorRequest,\n       const service_manager::BindSourceInfo& source_info) override;\n \n+  void BindHeapProfilerHelperRequest(\n+      mojom::HeapProfilerHelperRequest request,\n+      const service_manager::BindSourceInfo& source_info);\n+\n   // mojom::Coordinator implementation.\n   void RegisterClientProcess(mojom::ClientProcessPtr,\n                              mojom::ProcessType) override;\n@@ -64,6 +70,8 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n       base::trace_event::MemoryDumpType,\n       base::trace_event::MemoryDumpLevelOfDetail,\n       const RequestGlobalMemoryDumpAndAppendToTraceCallback&) override;\n+\n+  // mojom::HeapProfilerHelper implementation.\n   void GetVmRegionsForHeapProfiler(\n       const GetVmRegionsForHeapProfilerCallback&) override;\n \n@@ -135,6 +143,11 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n   // bindings_ must be closed before destroying the un-run callbacks.\n   mojo::BindingSet<mojom::Coordinator, service_manager::Identity> bindings_;\n \n+  // There may be extant callbacks in |queued_memory_dump_requests_|. The\n+  // bindings_ must be closed before destroying the un-run callbacks.\n+  mojo::BindingSet<mojom::HeapProfilerHelper, service_manager::Identity>\n+      bindings_heap_profiler_helper_;\n+\n   // Maintains a map of service_manager::Identity -> pid for registered clients.\n   std::unique_ptr<ProcessMap> process_map_;\n   uint64_t next_dump_id_;""}<_**next**_>{""sha"": ""a09d6f9be95d76038f3f1ed620fc3a6dcfd365dd"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 6, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -74,12 +74,6 @@ void MemoryInstrumentation::RequestGlobalDumpAndAppendToTrace(\n       dump_type, level_of_detail, callback);\n }\n \n-void MemoryInstrumentation::GetVmRegionsForHeapProfiler(\n-    RequestGlobalDumpCallback callback) {\n-  const auto& coordinator = GetCoordinatorBindingForCurrentThread();\n-  coordinator->GetVmRegionsForHeapProfiler(callback);\n-}\n-\n const mojom::CoordinatorPtr&\n MemoryInstrumentation::GetCoordinatorBindingForCurrentThread() {\n   mojom::CoordinatorPtr* coordinator =""}<_**next**_>{""sha"": ""045fdd3c4b0ea73dd001d27da8242b3fc707f0f8"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 9, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -81,15 +81,6 @@ class SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_EXPORT MemoryInstrumentation {\n       MemoryDumpLevelOfDetail,\n       RequestGlobalMemoryDumpAndAppendToTraceCallback);\n \n-  // Requests a global dump retrieving only the memory maps for all the client\n-  // processes registered. Does not add anything to the trace. The returned\n-  // GlobalMemoryDump will have only the |os_dump| field populated.\n-  // Returns asynchronously, via the callback argument:\n-  //  (true, global_dump) if succeeded;\n-  //  (false, nullptr) if failed.\n-  // The callback will be posted on the same thread of the caller.\n-  void GetVmRegionsForHeapProfiler(RequestGlobalDumpCallback);\n-\n  private:\n   MemoryInstrumentation(service_manager::Connector* connector,\n                         const std::string& service_name);""}<_**next**_>{""sha"": ""0d9dbcb65d0dde8e3273c24e85eebfce4c84a9a6"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -130,9 +130,6 @@ class MockCoordinator : public Coordinator, public mojom::Coordinator {\n       MemoryDumpLevelOfDetail level_of_detail,\n       const RequestGlobalMemoryDumpAndAppendToTraceCallback&) override;\n \n-  void GetVmRegionsForHeapProfiler(\n-      const GetVmRegionsForHeapProfilerCallback&) override {}\n-\n  private:\n   mojo::BindingSet<mojom::Coordinator> bindings_;\n   MemoryTracingIntegrationTest* client_;""}<_**next**_>{""sha"": ""3a917acc6010d68b89ea15223d4db5f1a3a89463"", ""filename"": ""services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -259,7 +259,10 @@ interface Coordinator {\n   RequestGlobalMemoryDumpAndAppendToTrace(DumpType dump_type,\n                                           LevelOfDetail level_of_detail) =>\n       (bool success, uint64 dump_id);\n+};\n \n+// Used by the Chrome heap profiler\n+interface HeapProfilerHelper {\n   // Broadcasts a RequestOSMemoryDump-only request for all registered client\n   // processes, retrieves only their memory maps and returns them in the field\n   // |global_memory_dump.process_dumps.os_dump.memory_maps_for_heap_profiler|.""}<_**next**_>{""sha"": ""51e296ff66185401b99e0c36b06a7492d036b6f8"", ""filename"": ""services/resource_coordinator/resource_coordinator_service.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/resource_coordinator_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/resource_coordinator_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/resource_coordinator_service.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -72,6 +72,9 @@ void ResourceCoordinatorService::OnStart() {\n   registry_.AddInterface(base::BindRepeating(\n       &memory_instrumentation::CoordinatorImpl::BindCoordinatorRequest,\n       base::Unretained(memory_instrumentation_coordinator_.get())));\n+  registry_.AddInterface(base::BindRepeating(\n+      &memory_instrumentation::CoordinatorImpl::BindHeapProfilerHelperRequest,\n+      base::Unretained(memory_instrumentation_coordinator_.get())));\n \n   tracing_agent_registry_ = std::make_unique<tracing::AgentRegistry>();\n   registry_.AddInterface(""}","void MemoryInstrumentation::GetVmRegionsForHeapProfiler(
","void MemoryInstrumentation::GetVmRegionsForHeapProfiler(
    RequestGlobalDumpCallback callback) {
  const auto& coordinator = GetCoordinatorBindingForCurrentThread();
  coordinator->GetVmRegionsForHeapProfiler(callback);
}
",C,,"    RequestGlobalDumpCallback callback) {
  const auto& coordinator = GetCoordinatorBindingForCurrentThread();
  coordinator->GetVmRegionsForHeapProfiler(callback);
}
",,"@@ -74,12 +74,6 @@ void MemoryInstrumentation::RequestGlobalDumpAndAppendToTrace(
       dump_type, level_of_detail, callback);
 }
 
-void MemoryInstrumentation::GetVmRegionsForHeapProfiler(
-    RequestGlobalDumpCallback callback) {
-  const auto& coordinator = GetCoordinatorBindingForCurrentThread();
-  coordinator->GetVmRegionsForHeapProfiler(callback);
-}
-
 const mojom::CoordinatorPtr&
 MemoryInstrumentation::GetCoordinatorBindingForCurrentThread() {
   mojom::CoordinatorPtr* coordinator =",Chrome,b44e68087804e6543a99c87076ab7648d11d9b07,e07873b65983cf07f53e7b22dfc8a0a1b3aac586,1,"void MemoryInstrumentation::GetVmRegionsForHeapProfiler(
//flaw_line_below:
    RequestGlobalDumpCallback callback) {
//flaw_line_below:
  const auto& coordinator = GetCoordinatorBindingForCurrentThread();
//flaw_line_below:
  coordinator->GetVmRegionsForHeapProfiler(callback);
//flaw_line_below:
}
"
9160,186896,,Remote,Not required,,CVE-2018-6080,https://www.cvedetails.com/cve/CVE-2018-6080/,CWE-269,Medium,Partial,,,2018-11-14,4.3,Lack of access control checks in Instrumentation in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to obtain memory metadata from privileged processes .,2019-10-02,,3,https://github.com/chromium/chromium/commit/b44e68087804e6543a99c87076ab7648d11d9b07,b44e68087804e6543a99c87076ab7648d11d9b07,"memory-infra: split up memory-infra coordinator service into two

This allows for heap profiler to use its own service with correct
capabilities and all other instances to use the existing coordinator
service.

Bug: 792028
Change-Id: I84e4ec71f5f1d00991c0516b1424ce7334bcd3cd
Reviewed-on: https://chromium-review.googlesource.com/836896
Commit-Queue: Lalit Maganti <lalitm@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: oysteine <oysteine@chromium.org>
Reviewed-by: Albert J. Wong <ajwong@chromium.org>
Reviewed-by: Hector Dearman <hjd@chromium.org>
Cr-Commit-Position: refs/heads/master@{#529059}",0,services/resource_coordinator/resource_coordinator_service.cc,"{""sha"": ""b3f7c3314257d54c61adbc79a81523ff3443903e"", ""filename"": ""chrome/profiling/profiling_manifest.json"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_manifest.json?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -8,7 +8,8 @@\n         \""profiling\"": [ \""profiling::mojom::ProfilingService\"" ]\n       },\n       \""requires\"": {\n-         \""*\"": [ \""app\"" ],\n+        \""*\"": [ \""app\"" ],\n+        \""resource_coordinator\"": [ \""heap_profiling\"" ],\n         \""service_manager\"": [ \""service_manager:all_users\"" ]\n       }\n     }""}<_**next**_>{""sha"": ""08afcc548d15361decac4ef2f5fb26e6f67b6d03"", ""filename"": ""chrome/profiling/profiling_service.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 7, ""changes"": 20, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_service.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -5,8 +5,11 @@\n #include \""chrome/profiling/profiling_service.h\""\n \n #include \""base/logging.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n #include \""mojo/public/cpp/system/platform_handle.h\""\n-#include \""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h\""\n+#include \""services/resource_coordinator/public/cpp/resource_coordinator_features.h\""\n+#include \""services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom.h\""\n+#include \""services/resource_coordinator/public/interfaces/service_constants.mojom.h\""\n \n namespace profiling {\n \n@@ -74,14 +77,17 @@ void ProfilingService::DumpProcessesForTracing(\n     bool keep_small_allocations,\n     bool strip_path_from_mapped_files,\n     DumpProcessesForTracingCallback callback) {\n+  if (!helper_) {\n+    context()->connector()->BindInterface(\n+        resource_coordinator::mojom::kServiceName, &helper_);\n+  }\n+\n   // Need a memory map to make sense of the dump. The dump will be triggered\n   // in the memory map global dump callback.\n-  // TODO(brettw) this should be a OnceCallback to avoid base::Passed.\n-  memory_instrumentation::MemoryInstrumentation::GetInstance()\n-      ->GetVmRegionsForHeapProfiler(base::Bind(\n-          &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n-          weak_factory_.GetWeakPtr(), keep_small_allocations,\n-          strip_path_from_mapped_files, base::Passed(&callback)));\n+  helper_->GetVmRegionsForHeapProfiler(base::Bind(\n+      &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n+      weak_factory_.GetWeakPtr(), keep_small_allocations,\n+      strip_path_from_mapped_files, base::Passed(&callback)));\n }\n \n void ProfilingService::GetProfiledPids(GetProfiledPidsCallback callback) {""}<_**next**_>{""sha"": ""d12423617b9df3ce1fb44eecc9955a90bd1b4267"", ""filename"": ""chrome/profiling/profiling_service.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/chrome/profiling/profiling_service.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/profiling/profiling_service.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -75,6 +75,7 @@ class ProfilingService : public service_manager::Service,\n   service_manager::BinderRegistry registry_;\n   mojo::BindingSet<mojom::ProfilingService> binding_set_;\n \n+  memory_instrumentation::mojom::HeapProfilerHelperPtr helper_;\n   MemlogConnectionManager connection_manager_;\n \n   // Must be last.""}<_**next**_>{""sha"": ""0dd7654dc8e598b99c0d1efabb14862dc9db86a7"", ""filename"": ""services/resource_coordinator/manifest.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/manifest.json?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -12,6 +12,7 @@\n           \""resource_coordinator::mojom::CoordinationUnitIntrospector\""\n         ],\n         \""coordination_unit\"": [ \""resource_coordinator::mojom::CoordinationUnitProvider\"" ],\n+        \""heap_profiling\"": [ \""memory_instrumentation::mojom::HeapProfilerHelper\"" ],\n         \""page_signal\"": [ \""resource_coordinator::mojom::PageSignalGenerator\"" ],\n         \""tracing\"": [ \""tracing::mojom::Coordinator\"" ],\n         \""tests\"": [ \""*\"" ]""}<_**next**_>{""sha"": ""74ae3c66dcdf52a0bd2f154e9efe9e3ff1f27501"", ""filename"": ""services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 3, ""changes"": 45, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -84,11 +84,30 @@ void CoordinatorImpl::BindCoordinatorRequest(\n   bindings_.AddBinding(this, std::move(request), source_info.identity);\n }\n \n+void CoordinatorImpl::BindHeapProfilerHelperRequest(\n+    mojom::HeapProfilerHelperRequest request,\n+    const service_manager::BindSourceInfo& source_info) {\n+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n+  bindings_heap_profiler_helper_.AddBinding(this, std::move(request),\n+                                            source_info.identity);\n+}\n+\n void CoordinatorImpl::RequestGlobalMemoryDump(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const std::vector<std::string>& allocator_dump_names,\n     const RequestGlobalMemoryDumpCallback& callback) {\n+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler\n+  // is allowed to obtain them using the special method on the different\n+  // interface.\n+  if (level_of_detail ==\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {\n+    bindings_.ReportBadMessage(\n+        \""Requested global memory dump using level of detail reserved for the \""\n+        \""heap profiler.\"");\n+    return;\n+  }\n+\n   // This merely strips out the |dump_guid| argument.\n   auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n                     bool success, uint64_t,\n@@ -122,14 +141,25 @@ void CoordinatorImpl::RequestGlobalMemoryDumpForPid(\n   QueuedRequest::Args args(\n       base::trace_event::MemoryDumpType::SUMMARY_ONLY,\n       base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND, {},\n-      false /* addToTrace */, pid);\n+      false /* add_to_trace */, pid);\n   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }\n \n void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {\n+  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler\n+  // is allowed to obtain them using the special method on its own dedicated\n+  // interface (HeapProfilingHelper).\n+  if (level_of_detail ==\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {\n+    bindings_.ReportBadMessage(\n+        \""Requested global memory dump using level of detail reserved for the \""\n+        \""heap profiler.\"");\n+    return;\n+  }\n+\n   // This merely strips out the |dump_ptr| argument.\n   auto adapter =\n       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,\n@@ -143,9 +173,18 @@ void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n \n void CoordinatorImpl::GetVmRegionsForHeapProfiler(\n     const GetVmRegionsForHeapProfilerCallback& callback) {\n-  RequestGlobalMemoryDump(\n+  // This merely strips out the |dump_guid| argument.\n+  auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n+                    bool success, uint64_t dump_guid,\n+                    mojom::GlobalMemoryDumpPtr global_memory_dump) {\n+    callback.Run(success, std::move(global_memory_dump));\n+  };\n+\n+  QueuedRequest::Args args(\n       MemoryDumpType::EXPLICITLY_TRIGGERED,\n-      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {}, callback);\n+      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {},\n+      false /* add_to_trace */, base::kNullProcessId);\n+  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }\n \n void CoordinatorImpl::RegisterClientProcess(""}<_**next**_>{""sha"": ""9bd62ddb438a2bb1cf07eb07e37b5243d5c1433e"", ""filename"": ""services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/memory_instrumentation/coordinator_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/memory_instrumentation/coordinator_impl.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -36,7 +36,9 @@ namespace memory_instrumentation {\n // - Provides global (i.e. for all processes) memory snapshots on demand.\n //   Global snapshots are obtained by requesting in-process snapshots from each\n //   registered client and aggregating them.\n-class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n+class CoordinatorImpl : public Coordinator,\n+                        public mojom::Coordinator,\n+                        public mojom::HeapProfilerHelper {\n  public:\n   // The getter of the unique instance.\n   static CoordinatorImpl* GetInstance();\n@@ -48,6 +50,10 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n       mojom::CoordinatorRequest,\n       const service_manager::BindSourceInfo& source_info) override;\n \n+  void BindHeapProfilerHelperRequest(\n+      mojom::HeapProfilerHelperRequest request,\n+      const service_manager::BindSourceInfo& source_info);\n+\n   // mojom::Coordinator implementation.\n   void RegisterClientProcess(mojom::ClientProcessPtr,\n                              mojom::ProcessType) override;\n@@ -64,6 +70,8 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n       base::trace_event::MemoryDumpType,\n       base::trace_event::MemoryDumpLevelOfDetail,\n       const RequestGlobalMemoryDumpAndAppendToTraceCallback&) override;\n+\n+  // mojom::HeapProfilerHelper implementation.\n   void GetVmRegionsForHeapProfiler(\n       const GetVmRegionsForHeapProfilerCallback&) override;\n \n@@ -135,6 +143,11 @@ class CoordinatorImpl : public Coordinator, public mojom::Coordinator {\n   // bindings_ must be closed before destroying the un-run callbacks.\n   mojo::BindingSet<mojom::Coordinator, service_manager::Identity> bindings_;\n \n+  // There may be extant callbacks in |queued_memory_dump_requests_|. The\n+  // bindings_ must be closed before destroying the un-run callbacks.\n+  mojo::BindingSet<mojom::HeapProfilerHelper, service_manager::Identity>\n+      bindings_heap_profiler_helper_;\n+\n   // Maintains a map of service_manager::Identity -> pid for registered clients.\n   std::unique_ptr<ProcessMap> process_map_;\n   uint64_t next_dump_id_;""}<_**next**_>{""sha"": ""a09d6f9be95d76038f3f1ed620fc3a6dcfd365dd"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 6, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -74,12 +74,6 @@ void MemoryInstrumentation::RequestGlobalDumpAndAppendToTrace(\n       dump_type, level_of_detail, callback);\n }\n \n-void MemoryInstrumentation::GetVmRegionsForHeapProfiler(\n-    RequestGlobalDumpCallback callback) {\n-  const auto& coordinator = GetCoordinatorBindingForCurrentThread();\n-  coordinator->GetVmRegionsForHeapProfiler(callback);\n-}\n-\n const mojom::CoordinatorPtr&\n MemoryInstrumentation::GetCoordinatorBindingForCurrentThread() {\n   mojom::CoordinatorPtr* coordinator =""}<_**next**_>{""sha"": ""045fdd3c4b0ea73dd001d27da8242b3fc707f0f8"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 9, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -81,15 +81,6 @@ class SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_EXPORT MemoryInstrumentation {\n       MemoryDumpLevelOfDetail,\n       RequestGlobalMemoryDumpAndAppendToTraceCallback);\n \n-  // Requests a global dump retrieving only the memory maps for all the client\n-  // processes registered. Does not add anything to the trace. The returned\n-  // GlobalMemoryDump will have only the |os_dump| field populated.\n-  // Returns asynchronously, via the callback argument:\n-  //  (true, global_dump) if succeeded;\n-  //  (false, nullptr) if failed.\n-  // The callback will be posted on the same thread of the caller.\n-  void GetVmRegionsForHeapProfiler(RequestGlobalDumpCallback);\n-\n  private:\n   MemoryInstrumentation(service_manager::Connector* connector,\n                         const std::string& service_name);""}<_**next**_>{""sha"": ""0d9dbcb65d0dde8e3273c24e85eebfce4c84a9a6"", ""filename"": ""services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_integration_unittest.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -130,9 +130,6 @@ class MockCoordinator : public Coordinator, public mojom::Coordinator {\n       MemoryDumpLevelOfDetail level_of_detail,\n       const RequestGlobalMemoryDumpAndAppendToTraceCallback&) override;\n \n-  void GetVmRegionsForHeapProfiler(\n-      const GetVmRegionsForHeapProfilerCallback&) override {}\n-\n  private:\n   mojo::BindingSet<mojom::Coordinator> bindings_;\n   MemoryTracingIntegrationTest* client_;""}<_**next**_>{""sha"": ""3a917acc6010d68b89ea15223d4db5f1a3a89463"", ""filename"": ""services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/public/interfaces/memory_instrumentation/memory_instrumentation.mojom?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -259,7 +259,10 @@ interface Coordinator {\n   RequestGlobalMemoryDumpAndAppendToTrace(DumpType dump_type,\n                                           LevelOfDetail level_of_detail) =>\n       (bool success, uint64 dump_id);\n+};\n \n+// Used by the Chrome heap profiler\n+interface HeapProfilerHelper {\n   // Broadcasts a RequestOSMemoryDump-only request for all registered client\n   // processes, retrieves only their memory maps and returns them in the field\n   // |global_memory_dump.process_dumps.os_dump.memory_maps_for_heap_profiler|.""}<_**next**_>{""sha"": ""51e296ff66185401b99e0c36b06a7492d036b6f8"", ""filename"": ""services/resource_coordinator/resource_coordinator_service.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/resource_coordinator_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b44e68087804e6543a99c87076ab7648d11d9b07/services/resource_coordinator/resource_coordinator_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/resource_coordinator/resource_coordinator_service.cc?ref=b44e68087804e6543a99c87076ab7648d11d9b07"", ""patch"": ""@@ -72,6 +72,9 @@ void ResourceCoordinatorService::OnStart() {\n   registry_.AddInterface(base::BindRepeating(\n       &memory_instrumentation::CoordinatorImpl::BindCoordinatorRequest,\n       base::Unretained(memory_instrumentation_coordinator_.get())));\n+  registry_.AddInterface(base::BindRepeating(\n+      &memory_instrumentation::CoordinatorImpl::BindHeapProfilerHelperRequest,\n+      base::Unretained(memory_instrumentation_coordinator_.get())));\n \n   tracing_agent_registry_ = std::make_unique<tracing::AgentRegistry>();\n   registry_.AddInterface(""}","void ResourceCoordinatorService::OnStart() {
  ref_factory_.reset(new service_manager::ServiceContextRefFactory(
      base::Bind(&service_manager::ServiceContext::RequestQuit,
                 base::Unretained(context()))));

  ukm_recorder_ = ukm::MojoUkmRecorder::Create(context()->connector());

  registry_.AddInterface(
      base::Bind(&CoordinationUnitIntrospectorImpl::BindToInterface,
                 base::Unretained(&introspector_)));

  auto page_signal_generator_impl = std::make_unique<PageSignalGeneratorImpl>();
  registry_.AddInterface(
      base::Bind(&PageSignalGeneratorImpl::BindToInterface,
                 base::Unretained(page_signal_generator_impl.get())));
  coordination_unit_manager_.RegisterObserver(
      std::move(page_signal_generator_impl));

  coordination_unit_manager_.RegisterObserver(
      std::make_unique<MetricsCollector>());

  coordination_unit_manager_.RegisterObserver(
      std::make_unique<IPCVolumeReporter>(
          std::make_unique<base::OneShotTimer>()));

  coordination_unit_manager_.OnStart(&registry_, ref_factory_.get());
  coordination_unit_manager_.set_ukm_recorder(ukm_recorder_.get());

  memory_instrumentation_coordinator_ =
      std::make_unique<memory_instrumentation::CoordinatorImpl>(
          context()->connector());
   registry_.AddInterface(base::BindRepeating(
       &memory_instrumentation::CoordinatorImpl::BindCoordinatorRequest,
       base::Unretained(memory_instrumentation_coordinator_.get())));
  registry_.AddInterface(base::BindRepeating(
      &memory_instrumentation::CoordinatorImpl::BindHeapProfilerHelperRequest,
      base::Unretained(memory_instrumentation_coordinator_.get())));
 
   tracing_agent_registry_ = std::make_unique<tracing::AgentRegistry>();
   registry_.AddInterface(
      base::BindRepeating(&tracing::AgentRegistry::BindAgentRegistryRequest,
                          base::Unretained(tracing_agent_registry_.get())));

  tracing_coordinator_ = std::make_unique<tracing::Coordinator>();
  registry_.AddInterface(
      base::BindRepeating(&tracing::Coordinator::BindCoordinatorRequest,
                          base::Unretained(tracing_coordinator_.get())));
}
","void ResourceCoordinatorService::OnStart() {
  ref_factory_.reset(new service_manager::ServiceContextRefFactory(
      base::Bind(&service_manager::ServiceContext::RequestQuit,
                 base::Unretained(context()))));

  ukm_recorder_ = ukm::MojoUkmRecorder::Create(context()->connector());

  registry_.AddInterface(
      base::Bind(&CoordinationUnitIntrospectorImpl::BindToInterface,
                 base::Unretained(&introspector_)));

  auto page_signal_generator_impl = std::make_unique<PageSignalGeneratorImpl>();
  registry_.AddInterface(
      base::Bind(&PageSignalGeneratorImpl::BindToInterface,
                 base::Unretained(page_signal_generator_impl.get())));
  coordination_unit_manager_.RegisterObserver(
      std::move(page_signal_generator_impl));

  coordination_unit_manager_.RegisterObserver(
      std::make_unique<MetricsCollector>());

  coordination_unit_manager_.RegisterObserver(
      std::make_unique<IPCVolumeReporter>(
          std::make_unique<base::OneShotTimer>()));

  coordination_unit_manager_.OnStart(&registry_, ref_factory_.get());
  coordination_unit_manager_.set_ukm_recorder(ukm_recorder_.get());

  memory_instrumentation_coordinator_ =
      std::make_unique<memory_instrumentation::CoordinatorImpl>(
          context()->connector());
   registry_.AddInterface(base::BindRepeating(
       &memory_instrumentation::CoordinatorImpl::BindCoordinatorRequest,
       base::Unretained(memory_instrumentation_coordinator_.get())));
 
   tracing_agent_registry_ = std::make_unique<tracing::AgentRegistry>();
   registry_.AddInterface(
      base::BindRepeating(&tracing::AgentRegistry::BindAgentRegistryRequest,
                          base::Unretained(tracing_agent_registry_.get())));

  tracing_coordinator_ = std::make_unique<tracing::Coordinator>();
  registry_.AddInterface(
      base::BindRepeating(&tracing::Coordinator::BindCoordinatorRequest,
                          base::Unretained(tracing_coordinator_.get())));
}
",C,"  registry_.AddInterface(base::BindRepeating(
      &memory_instrumentation::CoordinatorImpl::BindHeapProfilerHelperRequest,
      base::Unretained(memory_instrumentation_coordinator_.get())));
",,,"@@ -72,6 +72,9 @@ void ResourceCoordinatorService::OnStart() {
   registry_.AddInterface(base::BindRepeating(
       &memory_instrumentation::CoordinatorImpl::BindCoordinatorRequest,
       base::Unretained(memory_instrumentation_coordinator_.get())));
+  registry_.AddInterface(base::BindRepeating(
+      &memory_instrumentation::CoordinatorImpl::BindHeapProfilerHelperRequest,
+      base::Unretained(memory_instrumentation_coordinator_.get())));
 
   tracing_agent_registry_ = std::make_unique<tracing::AgentRegistry>();
   registry_.AddInterface(",Chrome,b44e68087804e6543a99c87076ab7648d11d9b07,e07873b65983cf07f53e7b22dfc8a0a1b3aac586,1,"void ResourceCoordinatorService::OnStart() {
  ref_factory_.reset(new service_manager::ServiceContextRefFactory(
      base::Bind(&service_manager::ServiceContext::RequestQuit,
                 base::Unretained(context()))));

  ukm_recorder_ = ukm::MojoUkmRecorder::Create(context()->connector());

  registry_.AddInterface(
      base::Bind(&CoordinationUnitIntrospectorImpl::BindToInterface,
                 base::Unretained(&introspector_)));

  // Register new |CoordinationUnitGraphObserver| implementations here.
  auto page_signal_generator_impl = std::make_unique<PageSignalGeneratorImpl>();
  registry_.AddInterface(
      base::Bind(&PageSignalGeneratorImpl::BindToInterface,
                 base::Unretained(page_signal_generator_impl.get())));
  coordination_unit_manager_.RegisterObserver(
      std::move(page_signal_generator_impl));

  coordination_unit_manager_.RegisterObserver(
      std::make_unique<MetricsCollector>());

  coordination_unit_manager_.RegisterObserver(
      std::make_unique<IPCVolumeReporter>(
          std::make_unique<base::OneShotTimer>()));

  coordination_unit_manager_.OnStart(&registry_, ref_factory_.get());
  coordination_unit_manager_.set_ukm_recorder(ukm_recorder_.get());

  // TODO(chiniforooshan): The abstract class Coordinator in the
  // public/cpp/memory_instrumentation directory should not be needed anymore.
  // We should be able to delete that and rename
  // memory_instrumentation::CoordinatorImpl to
  // memory_instrumentation::Coordinator.
  memory_instrumentation_coordinator_ =
      std::make_unique<memory_instrumentation::CoordinatorImpl>(
          context()->connector());
   registry_.AddInterface(base::BindRepeating(
       &memory_instrumentation::CoordinatorImpl::BindCoordinatorRequest,
       base::Unretained(memory_instrumentation_coordinator_.get())));
//fix_flaw_line_below:
//  registry_.AddInterface(base::BindRepeating(
//fix_flaw_line_below:
//      &memory_instrumentation::CoordinatorImpl::BindHeapProfilerHelperRequest,
//fix_flaw_line_below:
//      base::Unretained(memory_instrumentation_coordinator_.get())));
 
   tracing_agent_registry_ = std::make_unique<tracing::AgentRegistry>();
   registry_.AddInterface(
      base::BindRepeating(&tracing::AgentRegistry::BindAgentRegistryRequest,
                          base::Unretained(tracing_agent_registry_.get())));

  tracing_coordinator_ = std::make_unique<tracing::Coordinator>();
  registry_.AddInterface(
      base::BindRepeating(&tracing::Coordinator::BindCoordinatorRequest,
                          base::Unretained(tracing_coordinator_.get())));
}
"
