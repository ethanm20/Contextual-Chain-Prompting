,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
4285,182021,,Remote,Not required,Complete,CVE-2015-9059,https://www.cvedetails.com/cve/CVE-2015-9059/,CWE-77,Low,Complete,Complete,,2017-05-27,10.0,picocom before 2.0 has a command injection vulnerability in the 'send and receive file' command because the command line is executed by /bin/sh unsafely.,2017-06-07,Exec Code ,1,https://github.com/npat-efault/picocom/commit/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,"Do not use ""/bin/sh"" to run external commands.

Picocom no longer uses /bin/sh to run external commands for
file-transfer operations. Parsing the command line and spliting it into
arguments is now performed internally by picocom, using quoting rules
very similar to those of the Unix shell. Hopefully, this makes it
impossible to inject shell-commands when supplying filenames or
extra arguments to the send- and receive-file commands.",1,picocom.c,"{""sha"": ""b110bd59e5289f760b49b5cec9ce72ccb2b5d2ce"", ""filename"": ""Makefile"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/npat-efault/picocom/blob/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1/Makefile"", ""raw_url"": ""https://github.com/npat-efault/picocom/raw/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1/Makefile"", ""contents_url"": ""https://api.github.com/repos/npat-efault/picocom/contents/Makefile?ref=1ebc60b20fbe9a02436d5cbbf8951714e749ddb1"", ""patch"": ""@@ -33,12 +33,12 @@ CPPFLAGS += -DSEND_RECEIVE_HISTFILE=\\\""$(SEND_RECEIVE_HISTFILE)\\\"" \\\n picocom : linenoise-1.0/linenoise.o\n linenoise-1.0/linenoise.o : linenoise-1.0/linenoise.c linenoise-1.0/linenoise.h\n \n-\n-picocom : picocom.o term.o\n+picocom : picocom.o term.o split.o\n #\t$(LD) $(LDFLAGS) -o $@ $+ $(LDLIBS)\n \n picocom.o : picocom.c term.h\n term.o : term.c term.h\n+split.o : split.c split.h\n \n \n doc : picocom.8 picocom.8.html picocom.8.ps""}<_**next**_>{""sha"": ""e4e898c8e12ac7b9742ed0b4da01881663fd6162"", ""filename"": ""picocom.c"", ""status"": ""modified"", ""additions"": 33, ""deletions"": 30, ""changes"": 63, ""blob_url"": ""https://github.com/npat-efault/picocom/blob/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1/picocom.c"", ""raw_url"": ""https://github.com/npat-efault/picocom/raw/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1/picocom.c"", ""contents_url"": ""https://api.github.com/repos/npat-efault/picocom/contents/picocom.c?ref=1ebc60b20fbe9a02436d5cbbf8951714e749ddb1"", ""patch"": ""@@ -48,6 +48,7 @@\n #define _GNU_SOURCE\n #include <getopt.h>\n \n+#include \""split.h\""\n #include \""term.h\""\n #ifdef LINENOISE\n #include \""linenoise-1.0/linenoise.h\""\n@@ -721,6 +722,9 @@ show_status (int dtr_up)\n \n /**********************************************************************/\n \n+#define RUNCMD_ARGS_MAX 32\n+#define RUNCMD_EXEC_FAIL 126\n+\n void\n establish_child_signal_handlers (void)\n {\n@@ -735,10 +739,8 @@ establish_child_signal_handlers (void)\n \tsigaction (SIGTERM, &dfl_action, NULL);\n }\n \n-#define EXEC \""exec \""\n-\n int\n-run_cmd(int fd, ...)\n+run_cmd(int fd, const char *cmd, const char *args_extra)\n {\n \tpid_t pid;\n \tsigset_t sigm, sigm_old;\n@@ -781,8 +783,10 @@ run_cmd(int fd, ...)\n \t} else {\n \t\t/* child: external program */\n \t\tlong fl;\n-\t\tchar cmd[512];\n-\n+\t\tint argc;\n+\t\tchar *argv[RUNCMD_ARGS_MAX + 1];\n+\t\tint r;\n+\t\t\t\n \t\t/* unmanage terminal, and reset it to canonical mode */\n \t\tterm_remove(STI);\n \t\t/* unmanage serial port fd, without reset */\n@@ -796,37 +800,36 @@ run_cmd(int fd, ...)\n \t\tclose(STO);\n \t\tdup2(fd, STI);\n \t\tdup2(fd, STO);\n-\t\t{\n-\t\t\t/* build command-line */\n-\t\t\tchar *c, *ce;\n-\t\t\tconst char *s;\n-\t\t\tint n;\n-\t\t\tva_list vls;\n-\t\t\t\n-\t\t\tstrcpy(cmd, EXEC);\n-\t\t\tc = &cmd[sizeof(EXEC)- 1];\n-\t\t\tce = cmd + sizeof(cmd) - 1;\n-\t\t\tva_start(vls, fd);\n-\t\t\twhile ( (s = va_arg(vls, const char *)) ) {\n-\t\t\t\tn = strlen(s);\n-\t\t\t\tif ( c + n + 1 >= ce ) break;\n-\t\t\t\tmemcpy(c, s, n); c += n;\n-\t\t\t\t*c++ = ' ';\n-\t\t\t}\n-\t\t\tva_end(vls);\n-\t\t\t*c = '\\0';\n+\t\t\n+\t\t/* build command arguments vector */\n+\t\targc = 0;\n+\t\tr = split_quoted(cmd, &argc, argv, RUNCMD_ARGS_MAX);\n+\t\tif ( r < 0 ) {\n+\t\t\tfd_printf(STDERR_FILENO, \""Cannot parse command\\n\"");\n+\t\t\texit(RUNCMD_EXEC_FAIL);\n+\t\t}\n+\t\tr = split_quoted(args_extra, &argc, argv, RUNCMD_ARGS_MAX);\n+\t\tif ( r < 0 ) {\n+\t\t\tfd_printf(STDERR_FILENO, \""Cannot parse extra args\\n\"");\n+\t\t\texit(RUNCMD_EXEC_FAIL);\n \t\t}\n+\t\tif ( argc < 1 ) {\n+\t\t\tfd_printf(STDERR_FILENO, \""No command given\\n\"");\n+\t\t\texit(RUNCMD_EXEC_FAIL);\n+\t\t}\t\n+\t\targv[argc] = NULL;\n+\t\t\t\n \t\t/* run extenral command */\n-\t\tfd_printf(STDERR_FILENO, \""%s\\n\"", &cmd[sizeof(EXEC) - 1]);\n+\t\tfd_printf(STDERR_FILENO, \""$ %s %s\\n\"", cmd, args_extra);\n \t\testablish_child_signal_handlers();\n \t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n-\t\texecl(\""/bin/sh\"", \""sh\"", \""-c\"", cmd, NULL);\n-\t\texit(42);\n+\t\texecvp(argv[0], argv);\n+\n+\t\tfd_printf(STDERR_FILENO, \""exec: %s\\n\"", strerror(errno));\n+\t\texit(RUNCMD_EXEC_FAIL);\n \t}\n }\n \n-#undef EXEC\n-\n /**********************************************************************/\n \n /* Process command key. Returns non-zero if command results in picocom\n@@ -944,7 +947,7 @@ do_command (unsigned char c)\n \t\t\tfd_printf(STO, \""*** cannot read filename ***\\r\\n\"");\n \t\t\tbreak;\n \t\t}\n-\t\trun_cmd(tty_fd, xfr_cmd, fname, NULL);\n+\t\trun_cmd(tty_fd, xfr_cmd, fname);\n \t\tfree(fname);\n \t\tbreak;\n \tcase KEY_BREAK:""}","do_command (unsigned char c)
{
	static int dtr_up = 0;
	int newbaud, newflow, newparity, newbits;
	const char *xfr_cmd;
	char *fname;
	int r;

	switch (c) {
	case KEY_EXIT:
		return 1;
	case KEY_QUIT:
		term_set_hupcl(tty_fd, 0);
		term_flush(tty_fd);
		term_apply(tty_fd);
		term_erase(tty_fd);
		return 1;
	case KEY_STATUS:
		show_status(dtr_up);
		break;
	case KEY_PULSE:
		fd_printf(STO, ""\r\n*** pulse DTR ***\r\n"");
		if ( term_pulse_dtr(tty_fd) < 0 )
			fd_printf(STO, ""*** FAILED\r\n"");
		break;
	case KEY_TOGGLE:
		if ( dtr_up )
			r = term_lower_dtr(tty_fd);
		else
			r = term_raise_dtr(tty_fd);
		if ( r >= 0 ) dtr_up = ! dtr_up;
		fd_printf(STO, ""\r\n*** DTR: %s ***\r\n"", 
				  dtr_up ? ""up"" : ""down"");
		break;
	case KEY_BAUD_UP:
	case KEY_BAUD_DN:
		if (c == KEY_BAUD_UP)
			opts.baud = baud_up(opts.baud);
		else 
			opts.baud = baud_down(opts.baud);
		term_set_baudrate(tty_fd, opts.baud);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newbaud = term_get_baudrate(tty_fd, NULL);
		if ( opts.baud != newbaud ) {
			fd_printf(STO, ""\r\n*** baud: %d (%d) ***\r\n"", 
					  opts.baud, newbaud);
		} else {
			fd_printf(STO, ""\r\n*** baud: %d ***\r\n"", opts.baud);
		}
		set_tty_write_sz(newbaud);
		break;
	case KEY_FLOW:
		opts.flow = flow_next(opts.flow);
		term_set_flowcntrl(tty_fd, opts.flow);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newflow = term_get_flowcntrl(tty_fd);
		if ( opts.flow != newflow ) {
			fd_printf(STO, ""\r\n*** flow: %s (%s) ***\r\n"", 
					  flow_str[opts.flow], flow_str[newflow]);
		} else {
			fd_printf(STO, ""\r\n*** flow: %s ***\r\n"", 
					  flow_str[opts.flow]);
		}
		break;
	case KEY_PARITY:
		opts.parity = parity_next(opts.parity);
		term_set_parity(tty_fd, opts.parity);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newparity = term_get_parity(tty_fd);
		if (opts.parity != newparity ) {
			fd_printf(STO, ""\r\n*** parity: %s (%s) ***\r\n"",
					  parity_str[opts.parity], 
					  parity_str[newparity]);
		} else {
			fd_printf(STO, ""\r\n*** parity: %s ***\r\n"", 
					  parity_str[opts.parity]);
		}
		break;
	case KEY_BITS:
		opts.databits = bits_next(opts.databits);
		term_set_databits(tty_fd, opts.databits);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newbits = term_get_databits(tty_fd);
		if (opts.databits != newbits ) {
			fd_printf(STO, ""\r\n*** databits: %d (%d) ***\r\n"",
					  opts.databits, newbits);
		} else {
			fd_printf(STO, ""\r\n*** databits: %d ***\r\n"", 
					  opts.databits);
		}
		break;
	case KEY_LECHO:
		opts.lecho = ! opts.lecho;
		fd_printf(STO, ""\r\n*** local echo: %s ***\r\n"", 
				  opts.lecho ? ""yes"" : ""no"");
		break;
	case KEY_SEND:
	case KEY_RECEIVE:
		xfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;
		if ( xfr_cmd[0] == '\0' ) {
			fd_printf(STO, ""\r\n*** command disabled ***\r\n"");
			break;
		}
		fname = read_filename();
		if (fname == NULL) {
 			fd_printf(STO, ""*** cannot read filename ***\r\n"");
 			break;
 		}
		run_cmd(tty_fd, xfr_cmd, fname);
 		free(fname);
 		break;
 	case KEY_BREAK:
		term_break(tty_fd);
		fd_printf(STO, ""\r\n*** break sent ***\r\n"");
		break;
	default:
		break;
	}

	return 0;
}
","do_command (unsigned char c)
{
	static int dtr_up = 0;
	int newbaud, newflow, newparity, newbits;
	const char *xfr_cmd;
	char *fname;
	int r;

	switch (c) {
	case KEY_EXIT:
		return 1;
	case KEY_QUIT:
		term_set_hupcl(tty_fd, 0);
		term_flush(tty_fd);
		term_apply(tty_fd);
		term_erase(tty_fd);
		return 1;
	case KEY_STATUS:
		show_status(dtr_up);
		break;
	case KEY_PULSE:
		fd_printf(STO, ""\r\n*** pulse DTR ***\r\n"");
		if ( term_pulse_dtr(tty_fd) < 0 )
			fd_printf(STO, ""*** FAILED\r\n"");
		break;
	case KEY_TOGGLE:
		if ( dtr_up )
			r = term_lower_dtr(tty_fd);
		else
			r = term_raise_dtr(tty_fd);
		if ( r >= 0 ) dtr_up = ! dtr_up;
		fd_printf(STO, ""\r\n*** DTR: %s ***\r\n"", 
				  dtr_up ? ""up"" : ""down"");
		break;
	case KEY_BAUD_UP:
	case KEY_BAUD_DN:
		if (c == KEY_BAUD_UP)
			opts.baud = baud_up(opts.baud);
		else 
			opts.baud = baud_down(opts.baud);
		term_set_baudrate(tty_fd, opts.baud);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newbaud = term_get_baudrate(tty_fd, NULL);
		if ( opts.baud != newbaud ) {
			fd_printf(STO, ""\r\n*** baud: %d (%d) ***\r\n"", 
					  opts.baud, newbaud);
		} else {
			fd_printf(STO, ""\r\n*** baud: %d ***\r\n"", opts.baud);
		}
		set_tty_write_sz(newbaud);
		break;
	case KEY_FLOW:
		opts.flow = flow_next(opts.flow);
		term_set_flowcntrl(tty_fd, opts.flow);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newflow = term_get_flowcntrl(tty_fd);
		if ( opts.flow != newflow ) {
			fd_printf(STO, ""\r\n*** flow: %s (%s) ***\r\n"", 
					  flow_str[opts.flow], flow_str[newflow]);
		} else {
			fd_printf(STO, ""\r\n*** flow: %s ***\r\n"", 
					  flow_str[opts.flow]);
		}
		break;
	case KEY_PARITY:
		opts.parity = parity_next(opts.parity);
		term_set_parity(tty_fd, opts.parity);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newparity = term_get_parity(tty_fd);
		if (opts.parity != newparity ) {
			fd_printf(STO, ""\r\n*** parity: %s (%s) ***\r\n"",
					  parity_str[opts.parity], 
					  parity_str[newparity]);
		} else {
			fd_printf(STO, ""\r\n*** parity: %s ***\r\n"", 
					  parity_str[opts.parity]);
		}
		break;
	case KEY_BITS:
		opts.databits = bits_next(opts.databits);
		term_set_databits(tty_fd, opts.databits);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newbits = term_get_databits(tty_fd);
		if (opts.databits != newbits ) {
			fd_printf(STO, ""\r\n*** databits: %d (%d) ***\r\n"",
					  opts.databits, newbits);
		} else {
			fd_printf(STO, ""\r\n*** databits: %d ***\r\n"", 
					  opts.databits);
		}
		break;
	case KEY_LECHO:
		opts.lecho = ! opts.lecho;
		fd_printf(STO, ""\r\n*** local echo: %s ***\r\n"", 
				  opts.lecho ? ""yes"" : ""no"");
		break;
	case KEY_SEND:
	case KEY_RECEIVE:
		xfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;
		if ( xfr_cmd[0] == '\0' ) {
			fd_printf(STO, ""\r\n*** command disabled ***\r\n"");
			break;
		}
		fname = read_filename();
		if (fname == NULL) {
 			fd_printf(STO, ""*** cannot read filename ***\r\n"");
 			break;
 		}
		run_cmd(tty_fd, xfr_cmd, fname, NULL);
 		free(fname);
 		break;
 	case KEY_BREAK:
		term_break(tty_fd);
		fd_printf(STO, ""\r\n*** break sent ***\r\n"");
		break;
	default:
		break;
	}

	return 0;
}
",C,"		run_cmd(tty_fd, xfr_cmd, fname);
","		run_cmd(tty_fd, xfr_cmd, fname, NULL);
",,"@@ -48,6 +48,7 @@
 #define _GNU_SOURCE
 #include <getopt.h>
 
+#include ""split.h""
 #include ""term.h""
 #ifdef LINENOISE
 #include ""linenoise-1.0/linenoise.h""
@@ -721,6 +722,9 @@ show_status (int dtr_up)
 
 /**********************************************************************/
 
+#define RUNCMD_ARGS_MAX 32
+#define RUNCMD_EXEC_FAIL 126
+
 void
 establish_child_signal_handlers (void)
 {
@@ -735,10 +739,8 @@ establish_child_signal_handlers (void)
 	sigaction (SIGTERM, &dfl_action, NULL);
 }
 
-#define EXEC ""exec ""
-
 int
-run_cmd(int fd, ...)
+run_cmd(int fd, const char *cmd, const char *args_extra)
 {
 	pid_t pid;
 	sigset_t sigm, sigm_old;
@@ -781,8 +783,10 @@ run_cmd(int fd, ...)
 	} else {
 		/* child: external program */
 		long fl;
-		char cmd[512];
-
+		int argc;
+		char *argv[RUNCMD_ARGS_MAX + 1];
+		int r;
+			
 		/* unmanage terminal, and reset it to canonical mode */
 		term_remove(STI);
 		/* unmanage serial port fd, without reset */
@@ -796,37 +800,36 @@ run_cmd(int fd, ...)
 		close(STO);
 		dup2(fd, STI);
 		dup2(fd, STO);
-		{
-			/* build command-line */
-			char *c, *ce;
-			const char *s;
-			int n;
-			va_list vls;
-			
-			strcpy(cmd, EXEC);
-			c = &cmd[sizeof(EXEC)- 1];
-			ce = cmd + sizeof(cmd) - 1;
-			va_start(vls, fd);
-			while ( (s = va_arg(vls, const char *)) ) {
-				n = strlen(s);
-				if ( c + n + 1 >= ce ) break;
-				memcpy(c, s, n); c += n;
-				*c++ = ' ';
-			}
-			va_end(vls);
-			*c = '\0';
+		
+		/* build command arguments vector */
+		argc = 0;
+		r = split_quoted(cmd, &argc, argv, RUNCMD_ARGS_MAX);
+		if ( r < 0 ) {
+			fd_printf(STDERR_FILENO, ""Cannot parse command\n"");
+			exit(RUNCMD_EXEC_FAIL);
+		}
+		r = split_quoted(args_extra, &argc, argv, RUNCMD_ARGS_MAX);
+		if ( r < 0 ) {
+			fd_printf(STDERR_FILENO, ""Cannot parse extra args\n"");
+			exit(RUNCMD_EXEC_FAIL);
 		}
+		if ( argc < 1 ) {
+			fd_printf(STDERR_FILENO, ""No command given\n"");
+			exit(RUNCMD_EXEC_FAIL);
+		}	
+		argv[argc] = NULL;
+			
 		/* run extenral command */
-		fd_printf(STDERR_FILENO, ""%s\n"", &cmd[sizeof(EXEC) - 1]);
+		fd_printf(STDERR_FILENO, ""$ %s %s\n"", cmd, args_extra);
 		establish_child_signal_handlers();
 		sigprocmask(SIG_SETMASK, &sigm_old, NULL);
-		execl(""/bin/sh"", ""sh"", ""-c"", cmd, NULL);
-		exit(42);
+		execvp(argv[0], argv);
+
+		fd_printf(STDERR_FILENO, ""exec: %s\n"", strerror(errno));
+		exit(RUNCMD_EXEC_FAIL);
 	}
 }
 
-#undef EXEC
-
 /**********************************************************************/
 
 /* Process command key. Returns non-zero if command results in picocom
@@ -944,7 +947,7 @@ do_command (unsigned char c)
 			fd_printf(STO, ""*** cannot read filename ***\r\n"");
 			break;
 		}
-		run_cmd(tty_fd, xfr_cmd, fname, NULL);
+		run_cmd(tty_fd, xfr_cmd, fname);
 		free(fname);
 		break;
 	case KEY_BREAK:",picocom,1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,d06875591ec9cc76f2a9f87a99c4262eea8e0dc9,1,"do_command (unsigned char c)
{
	static int dtr_up = 0;
	int newbaud, newflow, newparity, newbits;
	const char *xfr_cmd;
	char *fname;
	int r;

	switch (c) {
	case KEY_EXIT:
		return 1;
	case KEY_QUIT:
		term_set_hupcl(tty_fd, 0);
		term_flush(tty_fd);
		term_apply(tty_fd);
		term_erase(tty_fd);
		return 1;
	case KEY_STATUS:
		show_status(dtr_up);
		break;
	case KEY_PULSE:
		fd_printf(STO, ""\r\n*** pulse DTR ***\r\n"");
		if ( term_pulse_dtr(tty_fd) < 0 )
			fd_printf(STO, ""*** FAILED\r\n"");
		break;
	case KEY_TOGGLE:
		if ( dtr_up )
			r = term_lower_dtr(tty_fd);
		else
			r = term_raise_dtr(tty_fd);
		if ( r >= 0 ) dtr_up = ! dtr_up;
		fd_printf(STO, ""\r\n*** DTR: %s ***\r\n"", 
				  dtr_up ? ""up"" : ""down"");
		break;
	case KEY_BAUD_UP:
	case KEY_BAUD_DN:
		if (c == KEY_BAUD_UP)
			opts.baud = baud_up(opts.baud);
		else 
			opts.baud = baud_down(opts.baud);
		term_set_baudrate(tty_fd, opts.baud);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newbaud = term_get_baudrate(tty_fd, NULL);
		if ( opts.baud != newbaud ) {
			fd_printf(STO, ""\r\n*** baud: %d (%d) ***\r\n"", 
					  opts.baud, newbaud);
		} else {
			fd_printf(STO, ""\r\n*** baud: %d ***\r\n"", opts.baud);
		}
		set_tty_write_sz(newbaud);
		break;
	case KEY_FLOW:
		opts.flow = flow_next(opts.flow);
		term_set_flowcntrl(tty_fd, opts.flow);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newflow = term_get_flowcntrl(tty_fd);
		if ( opts.flow != newflow ) {
			fd_printf(STO, ""\r\n*** flow: %s (%s) ***\r\n"", 
					  flow_str[opts.flow], flow_str[newflow]);
		} else {
			fd_printf(STO, ""\r\n*** flow: %s ***\r\n"", 
					  flow_str[opts.flow]);
		}
		break;
	case KEY_PARITY:
		opts.parity = parity_next(opts.parity);
		term_set_parity(tty_fd, opts.parity);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newparity = term_get_parity(tty_fd);
		if (opts.parity != newparity ) {
			fd_printf(STO, ""\r\n*** parity: %s (%s) ***\r\n"",
					  parity_str[opts.parity], 
					  parity_str[newparity]);
		} else {
			fd_printf(STO, ""\r\n*** parity: %s ***\r\n"", 
					  parity_str[opts.parity]);
		}
		break;
	case KEY_BITS:
		opts.databits = bits_next(opts.databits);
		term_set_databits(tty_fd, opts.databits);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newbits = term_get_databits(tty_fd);
		if (opts.databits != newbits ) {
			fd_printf(STO, ""\r\n*** databits: %d (%d) ***\r\n"",
					  opts.databits, newbits);
		} else {
			fd_printf(STO, ""\r\n*** databits: %d ***\r\n"", 
					  opts.databits);
		}
		break;
	case KEY_LECHO:
		opts.lecho = ! opts.lecho;
		fd_printf(STO, ""\r\n*** local echo: %s ***\r\n"", 
				  opts.lecho ? ""yes"" : ""no"");
		break;
	case KEY_SEND:
	case KEY_RECEIVE:
		xfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;
		if ( xfr_cmd[0] == '\0' ) {
			fd_printf(STO, ""\r\n*** command disabled ***\r\n"");
			break;
		}
		fname = read_filename();
		if (fname == NULL) {
 			fd_printf(STO, ""*** cannot read filename ***\r\n"");
 			break;
 		}
//flaw_line_below:
		run_cmd(tty_fd, xfr_cmd, fname, NULL);
//fix_flaw_line_below:
//		run_cmd(tty_fd, xfr_cmd, fname);
 		free(fname);
 		break;
 	case KEY_BREAK:
		term_break(tty_fd);
		fd_printf(STO, ""\r\n*** break sent ***\r\n"");
		break;
	default:
		break;
	}

	return 0;
}
"
4286,182022,,Remote,Not required,Complete,CVE-2015-9059,https://www.cvedetails.com/cve/CVE-2015-9059/,CWE-77,Low,Complete,Complete,,2017-05-27,10.0,picocom before 2.0 has a command injection vulnerability in the 'send and receive file' command because the command line is executed by /bin/sh unsafely.,2017-06-07,Exec Code ,28,https://github.com/npat-efault/picocom/commit/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,"Do not use ""/bin/sh"" to run external commands.

Picocom no longer uses /bin/sh to run external commands for
file-transfer operations. Parsing the command line and spliting it into
arguments is now performed internally by picocom, using quoting rules
very similar to those of the Unix shell. Hopefully, this makes it
impossible to inject shell-commands when supplying filenames or
extra arguments to the send- and receive-file commands.",22,picocom.c,"{""sha"": ""b110bd59e5289f760b49b5cec9ce72ccb2b5d2ce"", ""filename"": ""Makefile"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/npat-efault/picocom/blob/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1/Makefile"", ""raw_url"": ""https://github.com/npat-efault/picocom/raw/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1/Makefile"", ""contents_url"": ""https://api.github.com/repos/npat-efault/picocom/contents/Makefile?ref=1ebc60b20fbe9a02436d5cbbf8951714e749ddb1"", ""patch"": ""@@ -33,12 +33,12 @@ CPPFLAGS += -DSEND_RECEIVE_HISTFILE=\\\""$(SEND_RECEIVE_HISTFILE)\\\"" \\\n picocom : linenoise-1.0/linenoise.o\n linenoise-1.0/linenoise.o : linenoise-1.0/linenoise.c linenoise-1.0/linenoise.h\n \n-\n-picocom : picocom.o term.o\n+picocom : picocom.o term.o split.o\n #\t$(LD) $(LDFLAGS) -o $@ $+ $(LDLIBS)\n \n picocom.o : picocom.c term.h\n term.o : term.c term.h\n+split.o : split.c split.h\n \n \n doc : picocom.8 picocom.8.html picocom.8.ps""}<_**next**_>{""sha"": ""e4e898c8e12ac7b9742ed0b4da01881663fd6162"", ""filename"": ""picocom.c"", ""status"": ""modified"", ""additions"": 33, ""deletions"": 30, ""changes"": 63, ""blob_url"": ""https://github.com/npat-efault/picocom/blob/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1/picocom.c"", ""raw_url"": ""https://github.com/npat-efault/picocom/raw/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1/picocom.c"", ""contents_url"": ""https://api.github.com/repos/npat-efault/picocom/contents/picocom.c?ref=1ebc60b20fbe9a02436d5cbbf8951714e749ddb1"", ""patch"": ""@@ -48,6 +48,7 @@\n #define _GNU_SOURCE\n #include <getopt.h>\n \n+#include \""split.h\""\n #include \""term.h\""\n #ifdef LINENOISE\n #include \""linenoise-1.0/linenoise.h\""\n@@ -721,6 +722,9 @@ show_status (int dtr_up)\n \n /**********************************************************************/\n \n+#define RUNCMD_ARGS_MAX 32\n+#define RUNCMD_EXEC_FAIL 126\n+\n void\n establish_child_signal_handlers (void)\n {\n@@ -735,10 +739,8 @@ establish_child_signal_handlers (void)\n \tsigaction (SIGTERM, &dfl_action, NULL);\n }\n \n-#define EXEC \""exec \""\n-\n int\n-run_cmd(int fd, ...)\n+run_cmd(int fd, const char *cmd, const char *args_extra)\n {\n \tpid_t pid;\n \tsigset_t sigm, sigm_old;\n@@ -781,8 +783,10 @@ run_cmd(int fd, ...)\n \t} else {\n \t\t/* child: external program */\n \t\tlong fl;\n-\t\tchar cmd[512];\n-\n+\t\tint argc;\n+\t\tchar *argv[RUNCMD_ARGS_MAX + 1];\n+\t\tint r;\n+\t\t\t\n \t\t/* unmanage terminal, and reset it to canonical mode */\n \t\tterm_remove(STI);\n \t\t/* unmanage serial port fd, without reset */\n@@ -796,37 +800,36 @@ run_cmd(int fd, ...)\n \t\tclose(STO);\n \t\tdup2(fd, STI);\n \t\tdup2(fd, STO);\n-\t\t{\n-\t\t\t/* build command-line */\n-\t\t\tchar *c, *ce;\n-\t\t\tconst char *s;\n-\t\t\tint n;\n-\t\t\tva_list vls;\n-\t\t\t\n-\t\t\tstrcpy(cmd, EXEC);\n-\t\t\tc = &cmd[sizeof(EXEC)- 1];\n-\t\t\tce = cmd + sizeof(cmd) - 1;\n-\t\t\tva_start(vls, fd);\n-\t\t\twhile ( (s = va_arg(vls, const char *)) ) {\n-\t\t\t\tn = strlen(s);\n-\t\t\t\tif ( c + n + 1 >= ce ) break;\n-\t\t\t\tmemcpy(c, s, n); c += n;\n-\t\t\t\t*c++ = ' ';\n-\t\t\t}\n-\t\t\tva_end(vls);\n-\t\t\t*c = '\\0';\n+\t\t\n+\t\t/* build command arguments vector */\n+\t\targc = 0;\n+\t\tr = split_quoted(cmd, &argc, argv, RUNCMD_ARGS_MAX);\n+\t\tif ( r < 0 ) {\n+\t\t\tfd_printf(STDERR_FILENO, \""Cannot parse command\\n\"");\n+\t\t\texit(RUNCMD_EXEC_FAIL);\n+\t\t}\n+\t\tr = split_quoted(args_extra, &argc, argv, RUNCMD_ARGS_MAX);\n+\t\tif ( r < 0 ) {\n+\t\t\tfd_printf(STDERR_FILENO, \""Cannot parse extra args\\n\"");\n+\t\t\texit(RUNCMD_EXEC_FAIL);\n \t\t}\n+\t\tif ( argc < 1 ) {\n+\t\t\tfd_printf(STDERR_FILENO, \""No command given\\n\"");\n+\t\t\texit(RUNCMD_EXEC_FAIL);\n+\t\t}\t\n+\t\targv[argc] = NULL;\n+\t\t\t\n \t\t/* run extenral command */\n-\t\tfd_printf(STDERR_FILENO, \""%s\\n\"", &cmd[sizeof(EXEC) - 1]);\n+\t\tfd_printf(STDERR_FILENO, \""$ %s %s\\n\"", cmd, args_extra);\n \t\testablish_child_signal_handlers();\n \t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n-\t\texecl(\""/bin/sh\"", \""sh\"", \""-c\"", cmd, NULL);\n-\t\texit(42);\n+\t\texecvp(argv[0], argv);\n+\n+\t\tfd_printf(STDERR_FILENO, \""exec: %s\\n\"", strerror(errno));\n+\t\texit(RUNCMD_EXEC_FAIL);\n \t}\n }\n \n-#undef EXEC\n-\n /**********************************************************************/\n \n /* Process command key. Returns non-zero if command results in picocom\n@@ -944,7 +947,7 @@ do_command (unsigned char c)\n \t\t\tfd_printf(STO, \""*** cannot read filename ***\\r\\n\"");\n \t\t\tbreak;\n \t\t}\n-\t\trun_cmd(tty_fd, xfr_cmd, fname, NULL);\n+\t\trun_cmd(tty_fd, xfr_cmd, fname);\n \t\tfree(fname);\n \t\tbreak;\n \tcase KEY_BREAK:""}","run_cmd(int fd, ...)
run_cmd(int fd, const char *cmd, const char *args_extra)
 {
 	pid_t pid;
 	sigset_t sigm, sigm_old;

	/* block signals, let child establish its own handlers */
	sigemptyset(&sigm);
	sigaddset(&sigm, SIGTERM);
	sigprocmask(SIG_BLOCK, &sigm, &sigm_old);

	pid = fork();
	if ( pid < 0 ) {
		sigprocmask(SIG_SETMASK, &sigm_old, NULL);
		fd_printf(STO, ""*** cannot fork: %s ***\r\n"", strerror(errno));
		return -1;
	} else if ( pid ) {
		/* father: picocom */
		int status, r;

		/* reset the mask */
		sigprocmask(SIG_SETMASK, &sigm_old, NULL);
		/* wait for child to finish */
		do {
			r = waitpid(pid, &status, 0);
		} while ( r < 0 && errno == EINTR );
		/* reset terminal (back to raw mode) */
		term_apply(STI);
		/* check and report child return status */
		if ( WIFEXITED(status) ) { 
			fd_printf(STO, ""\r\n*** exit status: %d ***\r\n"", 
					  WEXITSTATUS(status));
			return WEXITSTATUS(status);
		} else if ( WIFSIGNALED(status) ) {
			fd_printf(STO, ""\r\n*** killed by signal: %d ***\r\n"", 
					  WTERMSIG(status));
			return -1;
		} else {
			fd_printf(STO, ""\r\n*** abnormal termination: 0x%x ***\r\n"", r);
			return -1;
		}
 	} else {
 		/* child: external program */
 		long fl;
		int argc;
		char *argv[RUNCMD_ARGS_MAX + 1];
		int r;
			
 		/* unmanage terminal, and reset it to canonical mode */
 		term_remove(STI);
 		/* unmanage serial port fd, without reset */
		term_erase(fd);
		/* set serial port fd to blocking mode */
		fl = fcntl(fd, F_GETFL); 
		fl &= ~O_NONBLOCK;
		fcntl(fd, F_SETFL, fl);
		/* connect stdin and stdout to serial port */
		close(STI);
 		close(STO);
 		dup2(fd, STI);
 		dup2(fd, STO);
		
		/* build command arguments vector */
		argc = 0;
		r = split_quoted(cmd, &argc, argv, RUNCMD_ARGS_MAX);
		if ( r < 0 ) {
			fd_printf(STDERR_FILENO, ""Cannot parse command\n"");
			exit(RUNCMD_EXEC_FAIL);
		}
		r = split_quoted(args_extra, &argc, argv, RUNCMD_ARGS_MAX);
		if ( r < 0 ) {
			fd_printf(STDERR_FILENO, ""Cannot parse extra args\n"");
			exit(RUNCMD_EXEC_FAIL);
 		}
		if ( argc < 1 ) {
			fd_printf(STDERR_FILENO, ""No command given\n"");
			exit(RUNCMD_EXEC_FAIL);
		}	
		argv[argc] = NULL;
			
 		/* run extenral command */
		fd_printf(STDERR_FILENO, ""$ %s %s\n"", cmd, args_extra);
 		establish_child_signal_handlers();
 		sigprocmask(SIG_SETMASK, &sigm_old, NULL);
		execvp(argv[0], argv);

		fd_printf(STDERR_FILENO, ""exec: %s\n"", strerror(errno));
		exit(RUNCMD_EXEC_FAIL);
 	}
 }
","run_cmd(int fd, ...)
 {
 	pid_t pid;
 	sigset_t sigm, sigm_old;

	/* block signals, let child establish its own handlers */
	sigemptyset(&sigm);
	sigaddset(&sigm, SIGTERM);
	sigprocmask(SIG_BLOCK, &sigm, &sigm_old);

	pid = fork();
	if ( pid < 0 ) {
		sigprocmask(SIG_SETMASK, &sigm_old, NULL);
		fd_printf(STO, ""*** cannot fork: %s ***\r\n"", strerror(errno));
		return -1;
	} else if ( pid ) {
		/* father: picocom */
		int status, r;

		/* reset the mask */
		sigprocmask(SIG_SETMASK, &sigm_old, NULL);
		/* wait for child to finish */
		do {
			r = waitpid(pid, &status, 0);
		} while ( r < 0 && errno == EINTR );
		/* reset terminal (back to raw mode) */
		term_apply(STI);
		/* check and report child return status */
		if ( WIFEXITED(status) ) { 
			fd_printf(STO, ""\r\n*** exit status: %d ***\r\n"", 
					  WEXITSTATUS(status));
			return WEXITSTATUS(status);
		} else if ( WIFSIGNALED(status) ) {
			fd_printf(STO, ""\r\n*** killed by signal: %d ***\r\n"", 
					  WTERMSIG(status));
			return -1;
		} else {
			fd_printf(STO, ""\r\n*** abnormal termination: 0x%x ***\r\n"", r);
			return -1;
		}
 	} else {
 		/* child: external program */
 		long fl;
		char cmd[512];
 		/* unmanage terminal, and reset it to canonical mode */
 		term_remove(STI);
 		/* unmanage serial port fd, without reset */
		term_erase(fd);
		/* set serial port fd to blocking mode */
		fl = fcntl(fd, F_GETFL); 
		fl &= ~O_NONBLOCK;
		fcntl(fd, F_SETFL, fl);
		/* connect stdin and stdout to serial port */
		close(STI);
 		close(STO);
 		dup2(fd, STI);
 		dup2(fd, STO);
		{
			/* build command-line */
			char *c, *ce;
			const char *s;
			int n;
			va_list vls;
			strcpy(cmd, EXEC);
			c = &cmd[sizeof(EXEC)- 1];
			ce = cmd + sizeof(cmd) - 1;
			va_start(vls, fd);
			while ( (s = va_arg(vls, const char *)) ) {
				n = strlen(s);
				if ( c + n + 1 >= ce ) break;
				memcpy(c, s, n); c += n;
				*c++ = ' ';
			}
			va_end(vls);
			*c = '\0';
 		}
 		/* run extenral command */
		fd_printf(STDERR_FILENO, ""%s\n"", &cmd[sizeof(EXEC) - 1]);
 		establish_child_signal_handlers();
 		sigprocmask(SIG_SETMASK, &sigm_old, NULL);
		execl(""/bin/sh"", ""sh"", ""-c"", cmd, NULL);
		exit(42);
 	}
 }
",C,"run_cmd(int fd, const char *cmd, const char *args_extra)
		int argc;
		char *argv[RUNCMD_ARGS_MAX + 1];
		int r;
			
		
		/* build command arguments vector */
		argc = 0;
		r = split_quoted(cmd, &argc, argv, RUNCMD_ARGS_MAX);
		if ( r < 0 ) {
			fd_printf(STDERR_FILENO, ""Cannot parse command\n"");
			exit(RUNCMD_EXEC_FAIL);
		}
		r = split_quoted(args_extra, &argc, argv, RUNCMD_ARGS_MAX);
		if ( r < 0 ) {
			fd_printf(STDERR_FILENO, ""Cannot parse extra args\n"");
			exit(RUNCMD_EXEC_FAIL);
		if ( argc < 1 ) {
			fd_printf(STDERR_FILENO, ""No command given\n"");
			exit(RUNCMD_EXEC_FAIL);
		}	
		argv[argc] = NULL;
			
		fd_printf(STDERR_FILENO, ""$ %s %s\n"", cmd, args_extra);
		execvp(argv[0], argv);

		fd_printf(STDERR_FILENO, ""exec: %s\n"", strerror(errno));
		exit(RUNCMD_EXEC_FAIL);
","		char cmd[512];
		{
			/* build command-line */
			char *c, *ce;
			const char *s;
			int n;
			va_list vls;
			strcpy(cmd, EXEC);
			c = &cmd[sizeof(EXEC)- 1];
			ce = cmd + sizeof(cmd) - 1;
			va_start(vls, fd);
			while ( (s = va_arg(vls, const char *)) ) {
				n = strlen(s);
				if ( c + n + 1 >= ce ) break;
				memcpy(c, s, n); c += n;
				*c++ = ' ';
			}
			va_end(vls);
			*c = '\0';
		fd_printf(STDERR_FILENO, ""%s\n"", &cmd[sizeof(EXEC) - 1]);
		execl(""/bin/sh"", ""sh"", ""-c"", cmd, NULL);
		exit(42);
",,"@@ -48,6 +48,7 @@
 #define _GNU_SOURCE
 #include <getopt.h>
 
+#include ""split.h""
 #include ""term.h""
 #ifdef LINENOISE
 #include ""linenoise-1.0/linenoise.h""
@@ -721,6 +722,9 @@ show_status (int dtr_up)
 
 /**********************************************************************/
 
+#define RUNCMD_ARGS_MAX 32
+#define RUNCMD_EXEC_FAIL 126
+
 void
 establish_child_signal_handlers (void)
 {
@@ -735,10 +739,8 @@ establish_child_signal_handlers (void)
 	sigaction (SIGTERM, &dfl_action, NULL);
 }
 
-#define EXEC ""exec ""
-
 int
-run_cmd(int fd, ...)
+run_cmd(int fd, const char *cmd, const char *args_extra)
 {
 	pid_t pid;
 	sigset_t sigm, sigm_old;
@@ -781,8 +783,10 @@ run_cmd(int fd, ...)
 	} else {
 		/* child: external program */
 		long fl;
-		char cmd[512];
-
+		int argc;
+		char *argv[RUNCMD_ARGS_MAX + 1];
+		int r;
+			
 		/* unmanage terminal, and reset it to canonical mode */
 		term_remove(STI);
 		/* unmanage serial port fd, without reset */
@@ -796,37 +800,36 @@ run_cmd(int fd, ...)
 		close(STO);
 		dup2(fd, STI);
 		dup2(fd, STO);
-		{
-			/* build command-line */
-			char *c, *ce;
-			const char *s;
-			int n;
-			va_list vls;
-			
-			strcpy(cmd, EXEC);
-			c = &cmd[sizeof(EXEC)- 1];
-			ce = cmd + sizeof(cmd) - 1;
-			va_start(vls, fd);
-			while ( (s = va_arg(vls, const char *)) ) {
-				n = strlen(s);
-				if ( c + n + 1 >= ce ) break;
-				memcpy(c, s, n); c += n;
-				*c++ = ' ';
-			}
-			va_end(vls);
-			*c = '\0';
+		
+		/* build command arguments vector */
+		argc = 0;
+		r = split_quoted(cmd, &argc, argv, RUNCMD_ARGS_MAX);
+		if ( r < 0 ) {
+			fd_printf(STDERR_FILENO, ""Cannot parse command\n"");
+			exit(RUNCMD_EXEC_FAIL);
+		}
+		r = split_quoted(args_extra, &argc, argv, RUNCMD_ARGS_MAX);
+		if ( r < 0 ) {
+			fd_printf(STDERR_FILENO, ""Cannot parse extra args\n"");
+			exit(RUNCMD_EXEC_FAIL);
 		}
+		if ( argc < 1 ) {
+			fd_printf(STDERR_FILENO, ""No command given\n"");
+			exit(RUNCMD_EXEC_FAIL);
+		}	
+		argv[argc] = NULL;
+			
 		/* run extenral command */
-		fd_printf(STDERR_FILENO, ""%s\n"", &cmd[sizeof(EXEC) - 1]);
+		fd_printf(STDERR_FILENO, ""$ %s %s\n"", cmd, args_extra);
 		establish_child_signal_handlers();
 		sigprocmask(SIG_SETMASK, &sigm_old, NULL);
-		execl(""/bin/sh"", ""sh"", ""-c"", cmd, NULL);
-		exit(42);
+		execvp(argv[0], argv);
+
+		fd_printf(STDERR_FILENO, ""exec: %s\n"", strerror(errno));
+		exit(RUNCMD_EXEC_FAIL);
 	}
 }
 
-#undef EXEC
-
 /**********************************************************************/
 
 /* Process command key. Returns non-zero if command results in picocom
@@ -944,7 +947,7 @@ do_command (unsigned char c)
 			fd_printf(STO, ""*** cannot read filename ***\r\n"");
 			break;
 		}
-		run_cmd(tty_fd, xfr_cmd, fname, NULL);
+		run_cmd(tty_fd, xfr_cmd, fname);
 		free(fname);
 		break;
 	case KEY_BREAK:",picocom,1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,d06875591ec9cc76f2a9f87a99c4262eea8e0dc9,1,"run_cmd(int fd, ...)
//fix_flaw_line_below:
//run_cmd(int fd, const char *cmd, const char *args_extra)
 {
 	pid_t pid;
 	sigset_t sigm, sigm_old;

	/* block signals, let child establish its own handlers */
	sigemptyset(&sigm);
	sigaddset(&sigm, SIGTERM);
	sigprocmask(SIG_BLOCK, &sigm, &sigm_old);

	pid = fork();
	if ( pid < 0 ) {
		sigprocmask(SIG_SETMASK, &sigm_old, NULL);
		fd_printf(STO, ""*** cannot fork: %s ***\r\n"", strerror(errno));
		return -1;
	} else if ( pid ) {
		/* father: picocom */
		int status, r;

		/* reset the mask */
		sigprocmask(SIG_SETMASK, &sigm_old, NULL);
		/* wait for child to finish */
		do {
			r = waitpid(pid, &status, 0);
		} while ( r < 0 && errno == EINTR );
		/* reset terminal (back to raw mode) */
		term_apply(STI);
		/* check and report child return status */
		if ( WIFEXITED(status) ) { 
			fd_printf(STO, ""\r\n*** exit status: %d ***\r\n"", 
					  WEXITSTATUS(status));
			return WEXITSTATUS(status);
		} else if ( WIFSIGNALED(status) ) {
			fd_printf(STO, ""\r\n*** killed by signal: %d ***\r\n"", 
					  WTERMSIG(status));
			return -1;
		} else {
			fd_printf(STO, ""\r\n*** abnormal termination: 0x%x ***\r\n"", r);
			return -1;
		}
 	} else {
 		/* child: external program */
 		long fl;
//flaw_line_below:
		char cmd[512];
//flaw_line_below:

//fix_flaw_line_below:
//		int argc;
//fix_flaw_line_below:
//		char *argv[RUNCMD_ARGS_MAX + 1];
//fix_flaw_line_below:
//		int r;
//fix_flaw_line_below:
//			
 		/* unmanage terminal, and reset it to canonical mode */
 		term_remove(STI);
 		/* unmanage serial port fd, without reset */
		term_erase(fd);
		/* set serial port fd to blocking mode */
		fl = fcntl(fd, F_GETFL); 
		fl &= ~O_NONBLOCK;
		fcntl(fd, F_SETFL, fl);
		/* connect stdin and stdout to serial port */
		close(STI);
 		close(STO);
 		dup2(fd, STI);
 		dup2(fd, STO);
//flaw_line_below:
		{
//flaw_line_below:
			/* build command-line */
//flaw_line_below:
			char *c, *ce;
//flaw_line_below:
			const char *s;
//flaw_line_below:
			int n;
//flaw_line_below:
			va_list vls;
//flaw_line_below:
			
//flaw_line_below:
			strcpy(cmd, EXEC);
//flaw_line_below:
			c = &cmd[sizeof(EXEC)- 1];
//flaw_line_below:
			ce = cmd + sizeof(cmd) - 1;
//flaw_line_below:
			va_start(vls, fd);
//flaw_line_below:
			while ( (s = va_arg(vls, const char *)) ) {
//flaw_line_below:
				n = strlen(s);
//flaw_line_below:
				if ( c + n + 1 >= ce ) break;
//flaw_line_below:
				memcpy(c, s, n); c += n;
//flaw_line_below:
				*c++ = ' ';
//flaw_line_below:
			}
//flaw_line_below:
			va_end(vls);
//flaw_line_below:
			*c = '\0';
//fix_flaw_line_below:
//		
//fix_flaw_line_below:
//		/* build command arguments vector */
//fix_flaw_line_below:
//		argc = 0;
//fix_flaw_line_below:
//		r = split_quoted(cmd, &argc, argv, RUNCMD_ARGS_MAX);
//fix_flaw_line_below:
//		if ( r < 0 ) {
//fix_flaw_line_below:
//			fd_printf(STDERR_FILENO, ""Cannot parse command\n"");
//fix_flaw_line_below:
//			exit(RUNCMD_EXEC_FAIL);
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//		r = split_quoted(args_extra, &argc, argv, RUNCMD_ARGS_MAX);
//fix_flaw_line_below:
//		if ( r < 0 ) {
//fix_flaw_line_below:
//			fd_printf(STDERR_FILENO, ""Cannot parse extra args\n"");
//fix_flaw_line_below:
//			exit(RUNCMD_EXEC_FAIL);
 		}
//fix_flaw_line_below:
//		if ( argc < 1 ) {
//fix_flaw_line_below:
//			fd_printf(STDERR_FILENO, ""No command given\n"");
//fix_flaw_line_below:
//			exit(RUNCMD_EXEC_FAIL);
//fix_flaw_line_below:
//		}	
//fix_flaw_line_below:
//		argv[argc] = NULL;
//fix_flaw_line_below:
//			
 		/* run extenral command */
//flaw_line_below:
		fd_printf(STDERR_FILENO, ""%s\n"", &cmd[sizeof(EXEC) - 1]);
//fix_flaw_line_below:
//		fd_printf(STDERR_FILENO, ""$ %s %s\n"", cmd, args_extra);
 		establish_child_signal_handlers();
 		sigprocmask(SIG_SETMASK, &sigm_old, NULL);
//flaw_line_below:
		execl(""/bin/sh"", ""sh"", ""-c"", cmd, NULL);
//flaw_line_below:
		exit(42);
//fix_flaw_line_below:
//		execvp(argv[0], argv);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//		fd_printf(STDERR_FILENO, ""exec: %s\n"", strerror(errno));
//fix_flaw_line_below:
//		exit(RUNCMD_EXEC_FAIL);
 	}
 }
"
4345,182081,,Local,Not required,Complete,CVE-2014-9114,https://www.cvedetails.com/cve/CVE-2014-9114/,CWE-77,Low,Complete,Complete,,2017-03-31,7.2,Blkid in util-linux before 2.26rc-1 allows local users to execute arbitrary code.,2019-01-04,Exec Code ,18,https://github.com/karelzak/util-linux/commit/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,"libblkid: care about unsafe chars in cache

The high-level libblkid API uses /run/blkid/blkid.tab cache to
store probing results. The cache format is

   <device NAME=""value"" ...>devname</device>

and unfortunately the cache code does not escape quotation marks:

   # mkfs.ext4 -L 'AAA""BBB'

   # cat /run/blkid/blkid.tab
   ...
   <device ... LABEL=""AAA""BBB"" ...>/dev/sdb1</device>

such string is later incorrectly parsed and blkid(8) returns
nonsenses. And for use-cases like

   # eval $(blkid -o export /dev/sdb1)

it's also insecure.

Note that mount, udevd and blkid -p are based on low-level libblkid
API, it bypass the cache and directly read data from the devices.

The current udevd upstream does not depend on blkid(8) output at all,
it's directly linked with the library and all unsafe chars are encoded by
\x<hex> notation.

   # mkfs.ext4 -L 'X""`/tmp/foo` ""' /dev/sdb1
   # udevadm info --export-db | grep LABEL
   ...
   E: ID_FS_LABEL=X__/tmp/foo___
   E: ID_FS_LABEL_ENC=X\x22\x60\x2ftmp\x2ffoo\x60\x20\x22

Signed-off-by: Karel Zak <kzak@redhat.com>",3,libblkid/src/read.c,"{""sha"": ""81ab0dfd67679505cee3f9e1fa37a2be5cb30338"", ""filename"": ""libblkid/src/read.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 3, ""changes"": 21, ""blob_url"": ""https://github.com/karelzak/util-linux/blob/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/libblkid/src/read.c"", ""raw_url"": ""https://github.com/karelzak/util-linux/raw/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/libblkid/src/read.c"", ""contents_url"": ""https://api.github.com/repos/karelzak/util-linux/contents/libblkid/src/read.c?ref=89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc"", ""patch"": ""@@ -252,15 +252,30 @@ static int parse_token(char **name, char **value, char **cp)\n \t*value = skip_over_blank(*value + 1);\n \n \tif (**value == '\""') {\n-\t\tend = strchr(*value + 1, '\""');\n-\t\tif (!end) {\n+\t\tchar *p = end = *value + 1;\n+\n+\t\t/* convert 'foo\\\""bar'  to 'foo\""bar' */\n+\t\twhile (*p) {\n+\t\t\tif (*p == '\\\\') {\n+\t\t\t\tp++;\n+\t\t\t\t*end = *p;\n+\t\t\t} else {\n+\t\t\t\t*end = *p;\n+\t\t\t\tif (*p == '\""')\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tp++;\n+\t\t\tend++;\n+\t\t}\n+\n+\t\tif (*end != '\""') {\n \t\t\tDBG(READ, ul_debug(\""unbalanced quotes at: %s\"", *value));\n \t\t\t*cp = *value;\n \t\t\treturn -BLKID_ERR_CACHE;\n \t\t}\n \t\t(*value)++;\n \t\t*end = '\\0';\n-\t\tend++;\n+\t\tend = ++p;\n \t} else {\n \t\tend = skip_over_word(*value);\n \t\tif (*end) {""}<_**next**_>{""sha"": ""5e8bbee8f96c475e0c9a330cb22e73820a1aabac"", ""filename"": ""libblkid/src/save.c"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 1, ""changes"": 22, ""blob_url"": ""https://github.com/karelzak/util-linux/blob/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/libblkid/src/save.c"", ""raw_url"": ""https://github.com/karelzak/util-linux/raw/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/libblkid/src/save.c"", ""contents_url"": ""https://api.github.com/repos/karelzak/util-linux/contents/libblkid/src/save.c?ref=89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc"", ""patch"": ""@@ -26,6 +26,21 @@\n \n #include \""blkidP.h\""\n \n+\n+static void save_quoted(const char *data, FILE *file)\n+{\n+\tconst char *p;\n+\n+\tfputc('\""', file);\n+\tfor (p = data; p && *p; p++) {\n+\t\tif ((unsigned char) *p == 0x22 ||\t\t/* \"" */\n+\t\t    (unsigned char) *p == 0x5c)\t\t\t/* \\ */\n+\t\t\tfputc('\\\\', file);\n+\n+\t\tfputc(*p, file);\n+\t}\n+\tfputc('\""', file);\n+}\n static int save_dev(blkid_dev dev, FILE *file)\n {\n \tstruct list_head *p;\n@@ -43,9 +58,14 @@ static int save_dev(blkid_dev dev, FILE *file)\n \n \tif (dev->bid_pri)\n \t\tfprintf(file, \"" PRI=\\\""%d\\\""\"", dev->bid_pri);\n+\n \tlist_for_each(p, &dev->bid_tags) {\n \t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n-\t\tfprintf(file, \"" %s=\\\""%s\\\""\"", tag->bit_name,tag->bit_val);\n+\n+\t\tfputc(' ', file);\t\t\t/* space between tags */\n+\t\tfputs(tag->bit_name, file);\t\t/* tag NAME */\n+\t\tfputc('=', file);\t\t\t/* separator between NAME and VALUE */\n+\t\tsave_quoted(tag->bit_val, file);\t/* tag \""VALUE\"" */\n \t}\n \tfprintf(file, \"">%s</device>\\n\"", dev->bid_name);\n ""}<_**next**_>{""sha"": ""c95b833dfc410aaf6b4b69e27d12508b533cc180"", ""filename"": ""misc-utils/blkid.8"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/karelzak/util-linux/blob/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/misc-utils/blkid.8"", ""raw_url"": ""https://github.com/karelzak/util-linux/raw/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/misc-utils/blkid.8"", ""contents_url"": ""https://api.github.com/repos/karelzak/util-linux/contents/misc-utils/blkid.8?ref=89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc"", ""patch"": ""@@ -200,7 +200,10 @@ partitions.  This output format is \\fBDEPRECATED\\fR.\n .TP\n .B export\n print key=value pairs for easy import into the environment; this output format\n-is automatically enabled when I/O Limits (\\fB-i\\fR option) are requested\n+is automatically enabled when I/O Limits (\\fB-i\\fR option) are requested.\n+\n+The non-printing characters are encoded by ^ and M- notation and all\n+potentially unsafe characters are escaped.\n .RE\n .TP\n .BI \\-O \"" offset\""""}<_**next**_>{""sha"": ""1bd86465676013031fce7d9fcb5794c394f3210d"", ""filename"": ""misc-utils/blkid.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/karelzak/util-linux/blob/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/misc-utils/blkid.c"", ""raw_url"": ""https://github.com/karelzak/util-linux/raw/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/misc-utils/blkid.c"", ""contents_url"": ""https://api.github.com/repos/karelzak/util-linux/contents/misc-utils/blkid.c?ref=89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc"", ""patch"": ""@@ -306,7 +306,7 @@ static void print_value(int output, int num, const char *devname,\n \t\t\tprintf(\""DEVNAME=%s\\n\"", devname);\n \t\tfputs(name, stdout);\n \t\tfputs(\""=\"", stdout);\n-\t\tsafe_print(value, valsz, NULL);\n+\t\tsafe_print(value, valsz, \"" \\\\\\\""'$`<>\"");\n \t\tfputs(\""\\n\"", stdout);\n \n \t} else {\n@@ -315,7 +315,7 @@ static void print_value(int output, int num, const char *devname,\n \t\tfputs(\"" \"", stdout);\n \t\tfputs(name, stdout);\n \t\tfputs(\""=\\\""\"", stdout);\n-\t\tsafe_print(value, valsz, \""\\\""\"");\n+\t\tsafe_print(value, valsz, \""\\\""\\\\\"");\n \t\tfputs(\""\\\""\"", stdout);\n \t}\n }""}","static int parse_token(char **name, char **value, char **cp)
{
	char *end;

	if (!name || !value || !cp)
		return -BLKID_ERR_PARAM;

	if (!(*value = strchr(*cp, '=')))
		return 0;

	**value = '\0';
	*name = strip_line(*cp);
 	*value = skip_over_blank(*value + 1);
 
 	if (**value == '""') {
		char *p = end = *value + 1;

		/* convert 'foo\""bar'  to 'foo""bar' */
		while (*p) {
			if (*p == '\\') {
				p++;
				*end = *p;
			} else {
				*end = *p;
				if (*p == '""')
					break;
			}
			p++;
			end++;
		}

		if (*end != '""') {
 			DBG(READ, ul_debug(""unbalanced quotes at: %s"", *value));
 			*cp = *value;
 			return -BLKID_ERR_CACHE;
 		}
 		(*value)++;
 		*end = '\0';
		end = ++p;
 	} else {
 		end = skip_over_word(*value);
 		if (*end) {
			*end = '\0';
			end++;
		}
	}
	*cp = end;

	return 1;
}
","static int parse_token(char **name, char **value, char **cp)
{
	char *end;

	if (!name || !value || !cp)
		return -BLKID_ERR_PARAM;

	if (!(*value = strchr(*cp, '=')))
		return 0;

	**value = '\0';
	*name = strip_line(*cp);
 	*value = skip_over_blank(*value + 1);
 
 	if (**value == '""') {
		end = strchr(*value + 1, '""');
		if (!end) {
 			DBG(READ, ul_debug(""unbalanced quotes at: %s"", *value));
 			*cp = *value;
 			return -BLKID_ERR_CACHE;
 		}
 		(*value)++;
 		*end = '\0';
		end++;
 	} else {
 		end = skip_over_word(*value);
 		if (*end) {
			*end = '\0';
			end++;
		}
	}
	*cp = end;

	return 1;
}
",C,"		char *p = end = *value + 1;

		/* convert 'foo\""bar'  to 'foo""bar' */
		while (*p) {
			if (*p == '\\') {
				p++;
				*end = *p;
			} else {
				*end = *p;
				if (*p == '""')
					break;
			}
			p++;
			end++;
		}

		if (*end != '""') {
		end = ++p;
","		end = strchr(*value + 1, '""');
		if (!end) {
		end++;
",,"@@ -252,15 +252,30 @@ static int parse_token(char **name, char **value, char **cp)
 	*value = skip_over_blank(*value + 1);
 
 	if (**value == '""') {
-		end = strchr(*value + 1, '""');
-		if (!end) {
+		char *p = end = *value + 1;
+
+		/* convert 'foo\""bar'  to 'foo""bar' */
+		while (*p) {
+			if (*p == '\\') {
+				p++;
+				*end = *p;
+			} else {
+				*end = *p;
+				if (*p == '""')
+					break;
+			}
+			p++;
+			end++;
+		}
+
+		if (*end != '""') {
 			DBG(READ, ul_debug(""unbalanced quotes at: %s"", *value));
 			*cp = *value;
 			return -BLKID_ERR_CACHE;
 		}
 		(*value)++;
 		*end = '\0';
-		end++;
+		end = ++p;
 	} else {
 		end = skip_over_word(*value);
 		if (*end) {",util-linux,89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,cca51b9e45460e05bf5da81be80a26a70a120704,1,"static int parse_token(char **name, char **value, char **cp)
{
	char *end;

	if (!name || !value || !cp)
		return -BLKID_ERR_PARAM;

	if (!(*value = strchr(*cp, '=')))
		return 0;

	**value = '\0';
	*name = strip_line(*cp);
 	*value = skip_over_blank(*value + 1);
 
 	if (**value == '""') {
//flaw_line_below:
		end = strchr(*value + 1, '""');
//flaw_line_below:
		if (!end) {
//fix_flaw_line_below:
//		char *p = end = *value + 1;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//		/* convert 'foo\""bar'  to 'foo""bar' */
//fix_flaw_line_below:
//		while (*p) {
//fix_flaw_line_below:
//			if (*p == '\\') {
//fix_flaw_line_below:
//				p++;
//fix_flaw_line_below:
//				*end = *p;
//fix_flaw_line_below:
//			} else {
//fix_flaw_line_below:
//				*end = *p;
//fix_flaw_line_below:
//				if (*p == '""')
//fix_flaw_line_below:
//					break;
//fix_flaw_line_below:
//			}
//fix_flaw_line_below:
//			p++;
//fix_flaw_line_below:
//			end++;
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//		if (*end != '""') {
 			DBG(READ, ul_debug(""unbalanced quotes at: %s"", *value));
 			*cp = *value;
 			return -BLKID_ERR_CACHE;
 		}
 		(*value)++;
 		*end = '\0';
//flaw_line_below:
		end++;
//fix_flaw_line_below:
//		end = ++p;
 	} else {
 		end = skip_over_word(*value);
 		if (*end) {
			*end = '\0';
			end++;
		}
	}
	*cp = end;

	return 1;
}
"
4346,182082,,Local,Not required,Complete,CVE-2014-9114,https://www.cvedetails.com/cve/CVE-2014-9114/,CWE-77,Low,Complete,Complete,,2017-03-31,7.2,Blkid in util-linux before 2.26rc-1 allows local users to execute arbitrary code.,2019-01-04,Exec Code ,6,https://github.com/karelzak/util-linux/commit/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,"libblkid: care about unsafe chars in cache

The high-level libblkid API uses /run/blkid/blkid.tab cache to
store probing results. The cache format is

   <device NAME=""value"" ...>devname</device>

and unfortunately the cache code does not escape quotation marks:

   # mkfs.ext4 -L 'AAA""BBB'

   # cat /run/blkid/blkid.tab
   ...
   <device ... LABEL=""AAA""BBB"" ...>/dev/sdb1</device>

such string is later incorrectly parsed and blkid(8) returns
nonsenses. And for use-cases like

   # eval $(blkid -o export /dev/sdb1)

it's also insecure.

Note that mount, udevd and blkid -p are based on low-level libblkid
API, it bypass the cache and directly read data from the devices.

The current udevd upstream does not depend on blkid(8) output at all,
it's directly linked with the library and all unsafe chars are encoded by
\x<hex> notation.

   # mkfs.ext4 -L 'X""`/tmp/foo` ""' /dev/sdb1
   # udevadm info --export-db | grep LABEL
   ...
   E: ID_FS_LABEL=X__/tmp/foo___
   E: ID_FS_LABEL_ENC=X\x22\x60\x2ftmp\x2ffoo\x60\x20\x22

Signed-off-by: Karel Zak <kzak@redhat.com>",1,libblkid/src/save.c,"{""sha"": ""81ab0dfd67679505cee3f9e1fa37a2be5cb30338"", ""filename"": ""libblkid/src/read.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 3, ""changes"": 21, ""blob_url"": ""https://github.com/karelzak/util-linux/blob/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/libblkid/src/read.c"", ""raw_url"": ""https://github.com/karelzak/util-linux/raw/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/libblkid/src/read.c"", ""contents_url"": ""https://api.github.com/repos/karelzak/util-linux/contents/libblkid/src/read.c?ref=89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc"", ""patch"": ""@@ -252,15 +252,30 @@ static int parse_token(char **name, char **value, char **cp)\n \t*value = skip_over_blank(*value + 1);\n \n \tif (**value == '\""') {\n-\t\tend = strchr(*value + 1, '\""');\n-\t\tif (!end) {\n+\t\tchar *p = end = *value + 1;\n+\n+\t\t/* convert 'foo\\\""bar'  to 'foo\""bar' */\n+\t\twhile (*p) {\n+\t\t\tif (*p == '\\\\') {\n+\t\t\t\tp++;\n+\t\t\t\t*end = *p;\n+\t\t\t} else {\n+\t\t\t\t*end = *p;\n+\t\t\t\tif (*p == '\""')\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tp++;\n+\t\t\tend++;\n+\t\t}\n+\n+\t\tif (*end != '\""') {\n \t\t\tDBG(READ, ul_debug(\""unbalanced quotes at: %s\"", *value));\n \t\t\t*cp = *value;\n \t\t\treturn -BLKID_ERR_CACHE;\n \t\t}\n \t\t(*value)++;\n \t\t*end = '\\0';\n-\t\tend++;\n+\t\tend = ++p;\n \t} else {\n \t\tend = skip_over_word(*value);\n \t\tif (*end) {""}<_**next**_>{""sha"": ""5e8bbee8f96c475e0c9a330cb22e73820a1aabac"", ""filename"": ""libblkid/src/save.c"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 1, ""changes"": 22, ""blob_url"": ""https://github.com/karelzak/util-linux/blob/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/libblkid/src/save.c"", ""raw_url"": ""https://github.com/karelzak/util-linux/raw/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/libblkid/src/save.c"", ""contents_url"": ""https://api.github.com/repos/karelzak/util-linux/contents/libblkid/src/save.c?ref=89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc"", ""patch"": ""@@ -26,6 +26,21 @@\n \n #include \""blkidP.h\""\n \n+\n+static void save_quoted(const char *data, FILE *file)\n+{\n+\tconst char *p;\n+\n+\tfputc('\""', file);\n+\tfor (p = data; p && *p; p++) {\n+\t\tif ((unsigned char) *p == 0x22 ||\t\t/* \"" */\n+\t\t    (unsigned char) *p == 0x5c)\t\t\t/* \\ */\n+\t\t\tfputc('\\\\', file);\n+\n+\t\tfputc(*p, file);\n+\t}\n+\tfputc('\""', file);\n+}\n static int save_dev(blkid_dev dev, FILE *file)\n {\n \tstruct list_head *p;\n@@ -43,9 +58,14 @@ static int save_dev(blkid_dev dev, FILE *file)\n \n \tif (dev->bid_pri)\n \t\tfprintf(file, \"" PRI=\\\""%d\\\""\"", dev->bid_pri);\n+\n \tlist_for_each(p, &dev->bid_tags) {\n \t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n-\t\tfprintf(file, \"" %s=\\\""%s\\\""\"", tag->bit_name,tag->bit_val);\n+\n+\t\tfputc(' ', file);\t\t\t/* space between tags */\n+\t\tfputs(tag->bit_name, file);\t\t/* tag NAME */\n+\t\tfputc('=', file);\t\t\t/* separator between NAME and VALUE */\n+\t\tsave_quoted(tag->bit_val, file);\t/* tag \""VALUE\"" */\n \t}\n \tfprintf(file, \"">%s</device>\\n\"", dev->bid_name);\n ""}<_**next**_>{""sha"": ""c95b833dfc410aaf6b4b69e27d12508b533cc180"", ""filename"": ""misc-utils/blkid.8"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/karelzak/util-linux/blob/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/misc-utils/blkid.8"", ""raw_url"": ""https://github.com/karelzak/util-linux/raw/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/misc-utils/blkid.8"", ""contents_url"": ""https://api.github.com/repos/karelzak/util-linux/contents/misc-utils/blkid.8?ref=89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc"", ""patch"": ""@@ -200,7 +200,10 @@ partitions.  This output format is \\fBDEPRECATED\\fR.\n .TP\n .B export\n print key=value pairs for easy import into the environment; this output format\n-is automatically enabled when I/O Limits (\\fB-i\\fR option) are requested\n+is automatically enabled when I/O Limits (\\fB-i\\fR option) are requested.\n+\n+The non-printing characters are encoded by ^ and M- notation and all\n+potentially unsafe characters are escaped.\n .RE\n .TP\n .BI \\-O \"" offset\""""}<_**next**_>{""sha"": ""1bd86465676013031fce7d9fcb5794c394f3210d"", ""filename"": ""misc-utils/blkid.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/karelzak/util-linux/blob/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/misc-utils/blkid.c"", ""raw_url"": ""https://github.com/karelzak/util-linux/raw/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/misc-utils/blkid.c"", ""contents_url"": ""https://api.github.com/repos/karelzak/util-linux/contents/misc-utils/blkid.c?ref=89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc"", ""patch"": ""@@ -306,7 +306,7 @@ static void print_value(int output, int num, const char *devname,\n \t\t\tprintf(\""DEVNAME=%s\\n\"", devname);\n \t\tfputs(name, stdout);\n \t\tfputs(\""=\"", stdout);\n-\t\tsafe_print(value, valsz, NULL);\n+\t\tsafe_print(value, valsz, \"" \\\\\\\""'$`<>\"");\n \t\tfputs(\""\\n\"", stdout);\n \n \t} else {\n@@ -315,7 +315,7 @@ static void print_value(int output, int num, const char *devname,\n \t\tfputs(\"" \"", stdout);\n \t\tfputs(name, stdout);\n \t\tfputs(\""=\\\""\"", stdout);\n-\t\tsafe_print(value, valsz, \""\\\""\"");\n+\t\tsafe_print(value, valsz, \""\\\""\\\\\"");\n \t\tfputs(\""\\\""\"", stdout);\n \t}\n }""}"," static int save_dev(blkid_dev dev, FILE *file)
 {
 	struct list_head *p;

	if (!dev || dev->bid_name[0] != '/')
		return 0;

	DBG(SAVE, ul_debug(""device %s, type %s"", dev->bid_name, dev->bid_type ?
		   dev->bid_type : ""(null)""));

	fprintf(file, ""<device DEVNO=\""0x%04lx\"" TIME=\""%ld.%ld\"""",
			(unsigned long) dev->bid_devno,
			(long) dev->bid_time,
			(long) dev->bid_utime);
 
 	if (dev->bid_pri)
 		fprintf(file, "" PRI=\""%d\"""", dev->bid_pri);

 	list_for_each(p, &dev->bid_tags) {
 		blkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);

		fputc(' ', file);			/* space between tags */
		fputs(tag->bit_name, file);		/* tag NAME */
		fputc('=', file);			/* separator between NAME and VALUE */
		save_quoted(tag->bit_val, file);	/* tag ""VALUE"" */
 	}
 	fprintf(file, "">%s</device>\n"", dev->bid_name);
 
	return 0;
}
"," static int save_dev(blkid_dev dev, FILE *file)
 {
 	struct list_head *p;

	if (!dev || dev->bid_name[0] != '/')
		return 0;

	DBG(SAVE, ul_debug(""device %s, type %s"", dev->bid_name, dev->bid_type ?
		   dev->bid_type : ""(null)""));

	fprintf(file, ""<device DEVNO=\""0x%04lx\"" TIME=\""%ld.%ld\"""",
			(unsigned long) dev->bid_devno,
			(long) dev->bid_time,
			(long) dev->bid_utime);
 
 	if (dev->bid_pri)
 		fprintf(file, "" PRI=\""%d\"""", dev->bid_pri);
 	list_for_each(p, &dev->bid_tags) {
 		blkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);
		fprintf(file, "" %s=\""%s\"""", tag->bit_name,tag->bit_val);
 	}
 	fprintf(file, "">%s</device>\n"", dev->bid_name);
 
	return 0;
}
",C,"

		fputc(' ', file);			/* space between tags */
		fputs(tag->bit_name, file);		/* tag NAME */
		fputc('=', file);			/* separator between NAME and VALUE */
		save_quoted(tag->bit_val, file);	/* tag ""VALUE"" */
","		fprintf(file, "" %s=\""%s\"""", tag->bit_name,tag->bit_val);
",,"@@ -26,6 +26,21 @@
 
 #include ""blkidP.h""
 
+
+static void save_quoted(const char *data, FILE *file)
+{
+	const char *p;
+
+	fputc('""', file);
+	for (p = data; p && *p; p++) {
+		if ((unsigned char) *p == 0x22 ||		/* "" */
+		    (unsigned char) *p == 0x5c)			/* \ */
+			fputc('\\', file);
+
+		fputc(*p, file);
+	}
+	fputc('""', file);
+}
 static int save_dev(blkid_dev dev, FILE *file)
 {
 	struct list_head *p;
@@ -43,9 +58,14 @@ static int save_dev(blkid_dev dev, FILE *file)
 
 	if (dev->bid_pri)
 		fprintf(file, "" PRI=\""%d\"""", dev->bid_pri);
+
 	list_for_each(p, &dev->bid_tags) {
 		blkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);
-		fprintf(file, "" %s=\""%s\"""", tag->bit_name,tag->bit_val);
+
+		fputc(' ', file);			/* space between tags */
+		fputs(tag->bit_name, file);		/* tag NAME */
+		fputc('=', file);			/* separator between NAME and VALUE */
+		save_quoted(tag->bit_val, file);	/* tag ""VALUE"" */
 	}
 	fprintf(file, "">%s</device>\n"", dev->bid_name);
 ",util-linux,89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,cca51b9e45460e05bf5da81be80a26a70a120704,1," static int save_dev(blkid_dev dev, FILE *file)
 {
 	struct list_head *p;

	if (!dev || dev->bid_name[0] != '/')
		return 0;

	DBG(SAVE, ul_debug(""device %s, type %s"", dev->bid_name, dev->bid_type ?
		   dev->bid_type : ""(null)""));

	fprintf(file, ""<device DEVNO=\""0x%04lx\"" TIME=\""%ld.%ld\"""",
			(unsigned long) dev->bid_devno,
			(long) dev->bid_time,
			(long) dev->bid_utime);
 
 	if (dev->bid_pri)
 		fprintf(file, "" PRI=\""%d\"""", dev->bid_pri);
//fix_flaw_line_below:
//
 	list_for_each(p, &dev->bid_tags) {
 		blkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);
//flaw_line_below:
		fprintf(file, "" %s=\""%s\"""", tag->bit_name,tag->bit_val);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//		fputc(' ', file);			/* space between tags */
//fix_flaw_line_below:
//		fputs(tag->bit_name, file);		/* tag NAME */
//fix_flaw_line_below:
//		fputc('=', file);			/* separator between NAME and VALUE */
//fix_flaw_line_below:
//		save_quoted(tag->bit_val, file);	/* tag ""VALUE"" */
 	}
 	fprintf(file, "">%s</device>\n"", dev->bid_name);
 
	return 0;
}
"
4347,182083,,Local,Not required,Complete,CVE-2014-9114,https://www.cvedetails.com/cve/CVE-2014-9114/,CWE-77,Low,Complete,Complete,,2017-03-31,7.2,Blkid in util-linux before 2.26rc-1 allows local users to execute arbitrary code.,2019-01-04,Exec Code ,2,https://github.com/karelzak/util-linux/commit/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,"libblkid: care about unsafe chars in cache

The high-level libblkid API uses /run/blkid/blkid.tab cache to
store probing results. The cache format is

   <device NAME=""value"" ...>devname</device>

and unfortunately the cache code does not escape quotation marks:

   # mkfs.ext4 -L 'AAA""BBB'

   # cat /run/blkid/blkid.tab
   ...
   <device ... LABEL=""AAA""BBB"" ...>/dev/sdb1</device>

such string is later incorrectly parsed and blkid(8) returns
nonsenses. And for use-cases like

   # eval $(blkid -o export /dev/sdb1)

it's also insecure.

Note that mount, udevd and blkid -p are based on low-level libblkid
API, it bypass the cache and directly read data from the devices.

The current udevd upstream does not depend on blkid(8) output at all,
it's directly linked with the library and all unsafe chars are encoded by
\x<hex> notation.

   # mkfs.ext4 -L 'X""`/tmp/foo` ""' /dev/sdb1
   # udevadm info --export-db | grep LABEL
   ...
   E: ID_FS_LABEL=X__/tmp/foo___
   E: ID_FS_LABEL_ENC=X\x22\x60\x2ftmp\x2ffoo\x60\x20\x22

Signed-off-by: Karel Zak <kzak@redhat.com>",2,misc-utils/blkid.c,"{""sha"": ""81ab0dfd67679505cee3f9e1fa37a2be5cb30338"", ""filename"": ""libblkid/src/read.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 3, ""changes"": 21, ""blob_url"": ""https://github.com/karelzak/util-linux/blob/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/libblkid/src/read.c"", ""raw_url"": ""https://github.com/karelzak/util-linux/raw/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/libblkid/src/read.c"", ""contents_url"": ""https://api.github.com/repos/karelzak/util-linux/contents/libblkid/src/read.c?ref=89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc"", ""patch"": ""@@ -252,15 +252,30 @@ static int parse_token(char **name, char **value, char **cp)\n \t*value = skip_over_blank(*value + 1);\n \n \tif (**value == '\""') {\n-\t\tend = strchr(*value + 1, '\""');\n-\t\tif (!end) {\n+\t\tchar *p = end = *value + 1;\n+\n+\t\t/* convert 'foo\\\""bar'  to 'foo\""bar' */\n+\t\twhile (*p) {\n+\t\t\tif (*p == '\\\\') {\n+\t\t\t\tp++;\n+\t\t\t\t*end = *p;\n+\t\t\t} else {\n+\t\t\t\t*end = *p;\n+\t\t\t\tif (*p == '\""')\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tp++;\n+\t\t\tend++;\n+\t\t}\n+\n+\t\tif (*end != '\""') {\n \t\t\tDBG(READ, ul_debug(\""unbalanced quotes at: %s\"", *value));\n \t\t\t*cp = *value;\n \t\t\treturn -BLKID_ERR_CACHE;\n \t\t}\n \t\t(*value)++;\n \t\t*end = '\\0';\n-\t\tend++;\n+\t\tend = ++p;\n \t} else {\n \t\tend = skip_over_word(*value);\n \t\tif (*end) {""}<_**next**_>{""sha"": ""5e8bbee8f96c475e0c9a330cb22e73820a1aabac"", ""filename"": ""libblkid/src/save.c"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 1, ""changes"": 22, ""blob_url"": ""https://github.com/karelzak/util-linux/blob/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/libblkid/src/save.c"", ""raw_url"": ""https://github.com/karelzak/util-linux/raw/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/libblkid/src/save.c"", ""contents_url"": ""https://api.github.com/repos/karelzak/util-linux/contents/libblkid/src/save.c?ref=89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc"", ""patch"": ""@@ -26,6 +26,21 @@\n \n #include \""blkidP.h\""\n \n+\n+static void save_quoted(const char *data, FILE *file)\n+{\n+\tconst char *p;\n+\n+\tfputc('\""', file);\n+\tfor (p = data; p && *p; p++) {\n+\t\tif ((unsigned char) *p == 0x22 ||\t\t/* \"" */\n+\t\t    (unsigned char) *p == 0x5c)\t\t\t/* \\ */\n+\t\t\tfputc('\\\\', file);\n+\n+\t\tfputc(*p, file);\n+\t}\n+\tfputc('\""', file);\n+}\n static int save_dev(blkid_dev dev, FILE *file)\n {\n \tstruct list_head *p;\n@@ -43,9 +58,14 @@ static int save_dev(blkid_dev dev, FILE *file)\n \n \tif (dev->bid_pri)\n \t\tfprintf(file, \"" PRI=\\\""%d\\\""\"", dev->bid_pri);\n+\n \tlist_for_each(p, &dev->bid_tags) {\n \t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n-\t\tfprintf(file, \"" %s=\\\""%s\\\""\"", tag->bit_name,tag->bit_val);\n+\n+\t\tfputc(' ', file);\t\t\t/* space between tags */\n+\t\tfputs(tag->bit_name, file);\t\t/* tag NAME */\n+\t\tfputc('=', file);\t\t\t/* separator between NAME and VALUE */\n+\t\tsave_quoted(tag->bit_val, file);\t/* tag \""VALUE\"" */\n \t}\n \tfprintf(file, \"">%s</device>\\n\"", dev->bid_name);\n ""}<_**next**_>{""sha"": ""c95b833dfc410aaf6b4b69e27d12508b533cc180"", ""filename"": ""misc-utils/blkid.8"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/karelzak/util-linux/blob/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/misc-utils/blkid.8"", ""raw_url"": ""https://github.com/karelzak/util-linux/raw/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/misc-utils/blkid.8"", ""contents_url"": ""https://api.github.com/repos/karelzak/util-linux/contents/misc-utils/blkid.8?ref=89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc"", ""patch"": ""@@ -200,7 +200,10 @@ partitions.  This output format is \\fBDEPRECATED\\fR.\n .TP\n .B export\n print key=value pairs for easy import into the environment; this output format\n-is automatically enabled when I/O Limits (\\fB-i\\fR option) are requested\n+is automatically enabled when I/O Limits (\\fB-i\\fR option) are requested.\n+\n+The non-printing characters are encoded by ^ and M- notation and all\n+potentially unsafe characters are escaped.\n .RE\n .TP\n .BI \\-O \"" offset\""""}<_**next**_>{""sha"": ""1bd86465676013031fce7d9fcb5794c394f3210d"", ""filename"": ""misc-utils/blkid.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/karelzak/util-linux/blob/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/misc-utils/blkid.c"", ""raw_url"": ""https://github.com/karelzak/util-linux/raw/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc/misc-utils/blkid.c"", ""contents_url"": ""https://api.github.com/repos/karelzak/util-linux/contents/misc-utils/blkid.c?ref=89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc"", ""patch"": ""@@ -306,7 +306,7 @@ static void print_value(int output, int num, const char *devname,\n \t\t\tprintf(\""DEVNAME=%s\\n\"", devname);\n \t\tfputs(name, stdout);\n \t\tfputs(\""=\"", stdout);\n-\t\tsafe_print(value, valsz, NULL);\n+\t\tsafe_print(value, valsz, \"" \\\\\\\""'$`<>\"");\n \t\tfputs(\""\\n\"", stdout);\n \n \t} else {\n@@ -315,7 +315,7 @@ static void print_value(int output, int num, const char *devname,\n \t\tfputs(\"" \"", stdout);\n \t\tfputs(name, stdout);\n \t\tfputs(\""=\\\""\"", stdout);\n-\t\tsafe_print(value, valsz, \""\\\""\"");\n+\t\tsafe_print(value, valsz, \""\\\""\\\\\"");\n \t\tfputs(\""\\\""\"", stdout);\n \t}\n }""}","static void print_value(int output, int num, const char *devname,
			const char *value, const char *name, size_t valsz)
{
	if (output & OUTPUT_VALUE_ONLY) {
		fputs(value, stdout);
		fputc('\n', stdout);

	} else if (output & OUTPUT_UDEV_LIST) {
		print_udev_format(name, value);

	} else if (output & OUTPUT_EXPORT_LIST) {
		if (num == 1 && devname)
 			printf(""DEVNAME=%s\n"", devname);
 		fputs(name, stdout);
 		fputs(""="", stdout);
		safe_print(value, valsz, "" \\\""'$`<>"");
 		fputs(""\n"", stdout);
 
 	} else {
		if (num == 1 && devname)
			printf(""%s:"", devname);
 		fputs("" "", stdout);
 		fputs(name, stdout);
 		fputs(""=\"""", stdout);
		safe_print(value, valsz, ""\""\\"");
 		fputs(""\"""", stdout);
 	}
 }
","static void print_value(int output, int num, const char *devname,
			const char *value, const char *name, size_t valsz)
{
	if (output & OUTPUT_VALUE_ONLY) {
		fputs(value, stdout);
		fputc('\n', stdout);

	} else if (output & OUTPUT_UDEV_LIST) {
		print_udev_format(name, value);

	} else if (output & OUTPUT_EXPORT_LIST) {
		if (num == 1 && devname)
 			printf(""DEVNAME=%s\n"", devname);
 		fputs(name, stdout);
 		fputs(""="", stdout);
		safe_print(value, valsz, NULL);
 		fputs(""\n"", stdout);
 
 	} else {
		if (num == 1 && devname)
			printf(""%s:"", devname);
 		fputs("" "", stdout);
 		fputs(name, stdout);
 		fputs(""=\"""", stdout);
		safe_print(value, valsz, ""\"""");
 		fputs(""\"""", stdout);
 	}
 }
",C,"		safe_print(value, valsz, "" \\\""'$`<>"");
		safe_print(value, valsz, ""\""\\"");
","		safe_print(value, valsz, NULL);
		safe_print(value, valsz, ""\"""");
",,"@@ -306,7 +306,7 @@ static void print_value(int output, int num, const char *devname,
 			printf(""DEVNAME=%s\n"", devname);
 		fputs(name, stdout);
 		fputs(""="", stdout);
-		safe_print(value, valsz, NULL);
+		safe_print(value, valsz, "" \\\""'$`<>"");
 		fputs(""\n"", stdout);
 
 	} else {
@@ -315,7 +315,7 @@ static void print_value(int output, int num, const char *devname,
 		fputs("" "", stdout);
 		fputs(name, stdout);
 		fputs(""=\"""", stdout);
-		safe_print(value, valsz, ""\"""");
+		safe_print(value, valsz, ""\""\\"");
 		fputs(""\"""", stdout);
 	}
 }",util-linux,89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,cca51b9e45460e05bf5da81be80a26a70a120704,1,"static void print_value(int output, int num, const char *devname,
			const char *value, const char *name, size_t valsz)
{
	if (output & OUTPUT_VALUE_ONLY) {
		fputs(value, stdout);
		fputc('\n', stdout);

	} else if (output & OUTPUT_UDEV_LIST) {
		print_udev_format(name, value);

	} else if (output & OUTPUT_EXPORT_LIST) {
		if (num == 1 && devname)
 			printf(""DEVNAME=%s\n"", devname);
 		fputs(name, stdout);
 		fputs(""="", stdout);
//flaw_line_below:
		safe_print(value, valsz, NULL);
//fix_flaw_line_below:
//		safe_print(value, valsz, "" \\\""'$`<>"");
 		fputs(""\n"", stdout);
 
 	} else {
		if (num == 1 && devname)
			printf(""%s:"", devname);
 		fputs("" "", stdout);
 		fputs(name, stdout);
 		fputs(""=\"""", stdout);
//flaw_line_below:
		safe_print(value, valsz, ""\"""");
//fix_flaw_line_below:
//		safe_print(value, valsz, ""\""\\"");
 		fputs(""\"""", stdout);
 	}
 }
"
4569,182305,,Remote,Not required,Partial,CVE-2018-14357,https://www.cvedetails.com/cve/CVE-2018-14357/,CWE-77,Low,Partial,Partial,,2018-07-17,7.5,"An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with an automatic subscription.",2019-10-02,Exec Code ,2,https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725,e52393740334443ae0206cab2d7caef381646725,"quote imap strings more carefully

Co-authored-by: JerikoOne <jeriko.one@gmx.us>",2,imap/auth_login.c,"{""sha"": ""0f4445b4532660e17f18a935fdacd4f492438dcf"", ""filename"": ""imap/auth_login.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/auth_login.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/auth_login.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/auth_login.c?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -65,8 +65,8 @@ enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n \n   mutt_message(_(\""Logging in...\""));\n \n-  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n-  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n+  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);\n+  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);\n \n   /* don't print the password unless we're at the ungodly debugging level\n    * of 5 or higher */""}<_**next**_>{""sha"": ""859f98727c8da58fba14c54beb6c132b8a20df85"", ""filename"": ""imap/command.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/command.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/command.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/command.c?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -499,7 +499,7 @@ static void cmd_parse_lsub(struct ImapData *idata, char *s)\n   mutt_str_strfcpy(buf, \""mailboxes \\\""\"", sizeof(buf));\n   mutt_account_tourl(&idata->conn->account, &url);\n   /* escape \\ and \"" */\n-  imap_quote_string(errstr, sizeof(errstr), list.name);\n+  imap_quote_string(errstr, sizeof(errstr), list.name, true);\n   url.path = errstr + 1;\n   url.path[strlen(url.path) - 1] = '\\0';\n   if (mutt_str_strcmp(url.user, ImapUser) == 0)""}<_**next**_>{""sha"": ""40f620a2e2bf91b34edf289784e01867ef78d830"", ""filename"": ""imap/imap.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/imap.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/imap.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/imap.c?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -464,25 +464,25 @@ static int compile_search(struct Context *ctx, const struct Pattern *pat, struct\n           return -1;\n         }\n         *delim = '\\0';\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         mutt_buffer_addch(buf, ' ');\n \n         /* and field */\n         *delim = ':';\n         delim++;\n         SKIPWS(delim);\n-        imap_quote_string(term, sizeof(term), delim);\n+        imap_quote_string(term, sizeof(term), delim, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_BODY:\n         mutt_buffer_addstr(buf, \""BODY \"");\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_WHOLE_MSG:\n         mutt_buffer_addstr(buf, \""TEXT \"");\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_SERVERSEARCH:\n@@ -495,7 +495,7 @@ static int compile_search(struct Context *ctx, const struct Pattern *pat, struct\n         }\n       }\n         mutt_buffer_addstr(buf, \""X-GM-RAW \"");\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n     }""}<_**next**_>{""sha"": ""278d4a2b13793faf7af21ea24ea6262dab32939e"", ""filename"": ""imap/imap_private.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/imap_private.h"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/imap_private.h"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/imap_private.h?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -328,7 +328,7 @@ char *imap_get_qualifier(char *buf);\n int imap_mxcmp(const char *mx1, const char *mx2);\n char *imap_next_word(char *s);\n void imap_qualify_path(char *dest, size_t len, struct ImapMbox *mx, char *path);\n-void imap_quote_string(char *dest, size_t dlen, const char *src);\n+void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick);\n void imap_unquote_string(char *s);\n void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src);\n void imap_unmunge_mbox_name(struct ImapData *idata, char *s);""}<_**next**_>{""sha"": ""614d87a5612d6769d9fdc27eb4d9557921842600"", ""filename"": ""imap/util.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/util.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/util.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/util.c?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -798,9 +798,12 @@ void imap_qualify_path(char *dest, size_t len, struct ImapMbox *mx, char *path)\n  *\n  * Surround string with quotes, escape \"" and \\ with backslash\n  */\n-void imap_quote_string(char *dest, size_t dlen, const char *src)\n+void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n {\n-  static const char quote[] = \""\\\""\\\\\"";\n+  const char *quote = \""`\\\""\\\\\"";\n+  if (!quote_backtick)\n+    quote++;\n+\n   char *pt = dest;\n   const char *s = src;\n \n@@ -874,7 +877,7 @@ void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const\n   char *buf = mutt_str_strdup(src);\n   imap_utf_encode(idata, &buf);\n \n-  imap_quote_string(dest, dlen, buf);\n+  imap_quote_string(dest, dlen, buf, false);\n \n   FREE(&buf);\n }""}","enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)
{
  char q_user[SHORT_STRING], q_pass[SHORT_STRING];
  char buf[STRING];
  int rc;

  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))
  {
    mutt_message(_(""LOGIN disabled on this server.""));
    return IMAP_AUTH_UNAVAIL;
  }

  if (mutt_account_getuser(&idata->conn->account) < 0)
    return IMAP_AUTH_FAILURE;
  if (mutt_account_getpass(&idata->conn->account) < 0)
    return IMAP_AUTH_FAILURE;
 
   mutt_message(_(""Logging in...""));
 
  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);
  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);
 
   /* don't print the password unless we're at the ungodly debugging level
    * of 5 or higher */

  if (DebugLevel < IMAP_LOG_PASS)
    mutt_debug(2, ""Sending LOGIN command for %s...\n"", idata->conn->account.user);

  snprintf(buf, sizeof(buf), ""LOGIN %s %s"", q_user, q_pass);
  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);

  if (!rc)
  {
    mutt_clear_error(); /* clear ""Logging in..."".  fixes #3524 */
    return IMAP_AUTH_SUCCESS;
  }

  mutt_error(_(""Login failed.""));
  return IMAP_AUTH_FAILURE;
}
","enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)
{
  char q_user[SHORT_STRING], q_pass[SHORT_STRING];
  char buf[STRING];
  int rc;

  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))
  {
    mutt_message(_(""LOGIN disabled on this server.""));
    return IMAP_AUTH_UNAVAIL;
  }

  if (mutt_account_getuser(&idata->conn->account) < 0)
    return IMAP_AUTH_FAILURE;
  if (mutt_account_getpass(&idata->conn->account) < 0)
    return IMAP_AUTH_FAILURE;
 
   mutt_message(_(""Logging in...""));
 
  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);
  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);
 
   /* don't print the password unless we're at the ungodly debugging level
    * of 5 or higher */

  if (DebugLevel < IMAP_LOG_PASS)
    mutt_debug(2, ""Sending LOGIN command for %s...\n"", idata->conn->account.user);

  snprintf(buf, sizeof(buf), ""LOGIN %s %s"", q_user, q_pass);
  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);

  if (!rc)
  {
    mutt_clear_error(); /* clear ""Logging in..."".  fixes #3524 */
    return IMAP_AUTH_SUCCESS;
  }

  mutt_error(_(""Login failed.""));
  return IMAP_AUTH_FAILURE;
}
",C,"  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);
  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);
","  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);
  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);
",,"@@ -65,8 +65,8 @@ enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)
 
   mutt_message(_(""Logging in...""));
 
-  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);
-  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);
+  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);
+  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);
 
   /* don't print the password unless we're at the ungodly debugging level
    * of 5 or higher */",neomutt,e52393740334443ae0206cab2d7caef381646725,9bfab35522301794483f8f9ed60820bdec9be59e,1,"enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)
{
  char q_user[SHORT_STRING], q_pass[SHORT_STRING];
  char buf[STRING];
  int rc;

  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))
  {
    mutt_message(_(""LOGIN disabled on this server.""));
    return IMAP_AUTH_UNAVAIL;
  }

  if (mutt_account_getuser(&idata->conn->account) < 0)
    return IMAP_AUTH_FAILURE;
  if (mutt_account_getpass(&idata->conn->account) < 0)
    return IMAP_AUTH_FAILURE;
 
   mutt_message(_(""Logging in...""));
 
//flaw_line_below:
  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);
//flaw_line_below:
  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);
//fix_flaw_line_below:
//  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);
//fix_flaw_line_below:
//  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);
 
   /* don't print the password unless we're at the ungodly debugging level
    * of 5 or higher */

  if (DebugLevel < IMAP_LOG_PASS)
    mutt_debug(2, ""Sending LOGIN command for %s...\n"", idata->conn->account.user);

  snprintf(buf, sizeof(buf), ""LOGIN %s %s"", q_user, q_pass);
  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);

  if (!rc)
  {
    mutt_clear_error(); /* clear ""Logging in..."".  fixes #3524 */
    return IMAP_AUTH_SUCCESS;
  }

  mutt_error(_(""Login failed.""));
  return IMAP_AUTH_FAILURE;
}
"
4570,182306,,Remote,Not required,Partial,CVE-2018-14357,https://www.cvedetails.com/cve/CVE-2018-14357/,CWE-77,Low,Partial,Partial,,2018-07-17,7.5,"An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with an automatic subscription.",2019-10-02,Exec Code ,1,https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725,e52393740334443ae0206cab2d7caef381646725,"quote imap strings more carefully

Co-authored-by: JerikoOne <jeriko.one@gmx.us>",1,imap/command.c,"{""sha"": ""0f4445b4532660e17f18a935fdacd4f492438dcf"", ""filename"": ""imap/auth_login.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/auth_login.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/auth_login.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/auth_login.c?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -65,8 +65,8 @@ enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n \n   mutt_message(_(\""Logging in...\""));\n \n-  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n-  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n+  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);\n+  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);\n \n   /* don't print the password unless we're at the ungodly debugging level\n    * of 5 or higher */""}<_**next**_>{""sha"": ""859f98727c8da58fba14c54beb6c132b8a20df85"", ""filename"": ""imap/command.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/command.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/command.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/command.c?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -499,7 +499,7 @@ static void cmd_parse_lsub(struct ImapData *idata, char *s)\n   mutt_str_strfcpy(buf, \""mailboxes \\\""\"", sizeof(buf));\n   mutt_account_tourl(&idata->conn->account, &url);\n   /* escape \\ and \"" */\n-  imap_quote_string(errstr, sizeof(errstr), list.name);\n+  imap_quote_string(errstr, sizeof(errstr), list.name, true);\n   url.path = errstr + 1;\n   url.path[strlen(url.path) - 1] = '\\0';\n   if (mutt_str_strcmp(url.user, ImapUser) == 0)""}<_**next**_>{""sha"": ""40f620a2e2bf91b34edf289784e01867ef78d830"", ""filename"": ""imap/imap.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/imap.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/imap.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/imap.c?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -464,25 +464,25 @@ static int compile_search(struct Context *ctx, const struct Pattern *pat, struct\n           return -1;\n         }\n         *delim = '\\0';\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         mutt_buffer_addch(buf, ' ');\n \n         /* and field */\n         *delim = ':';\n         delim++;\n         SKIPWS(delim);\n-        imap_quote_string(term, sizeof(term), delim);\n+        imap_quote_string(term, sizeof(term), delim, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_BODY:\n         mutt_buffer_addstr(buf, \""BODY \"");\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_WHOLE_MSG:\n         mutt_buffer_addstr(buf, \""TEXT \"");\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_SERVERSEARCH:\n@@ -495,7 +495,7 @@ static int compile_search(struct Context *ctx, const struct Pattern *pat, struct\n         }\n       }\n         mutt_buffer_addstr(buf, \""X-GM-RAW \"");\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n     }""}<_**next**_>{""sha"": ""278d4a2b13793faf7af21ea24ea6262dab32939e"", ""filename"": ""imap/imap_private.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/imap_private.h"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/imap_private.h"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/imap_private.h?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -328,7 +328,7 @@ char *imap_get_qualifier(char *buf);\n int imap_mxcmp(const char *mx1, const char *mx2);\n char *imap_next_word(char *s);\n void imap_qualify_path(char *dest, size_t len, struct ImapMbox *mx, char *path);\n-void imap_quote_string(char *dest, size_t dlen, const char *src);\n+void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick);\n void imap_unquote_string(char *s);\n void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src);\n void imap_unmunge_mbox_name(struct ImapData *idata, char *s);""}<_**next**_>{""sha"": ""614d87a5612d6769d9fdc27eb4d9557921842600"", ""filename"": ""imap/util.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/util.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/util.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/util.c?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -798,9 +798,12 @@ void imap_qualify_path(char *dest, size_t len, struct ImapMbox *mx, char *path)\n  *\n  * Surround string with quotes, escape \"" and \\ with backslash\n  */\n-void imap_quote_string(char *dest, size_t dlen, const char *src)\n+void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n {\n-  static const char quote[] = \""\\\""\\\\\"";\n+  const char *quote = \""`\\\""\\\\\"";\n+  if (!quote_backtick)\n+    quote++;\n+\n   char *pt = dest;\n   const char *s = src;\n \n@@ -874,7 +877,7 @@ void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const\n   char *buf = mutt_str_strdup(src);\n   imap_utf_encode(idata, &buf);\n \n-  imap_quote_string(dest, dlen, buf);\n+  imap_quote_string(dest, dlen, buf, false);\n \n   FREE(&buf);\n }""}","static void cmd_parse_lsub(struct ImapData *idata, char *s)
{
  char buf[STRING];
  char errstr[STRING];
  struct Buffer err, token;
  struct Url url;
  struct ImapList list;

  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)
  {
    /* caller will handle response itself */
    cmd_parse_list(idata, s);
    return;
  }

  if (!ImapCheckSubscribed)
    return;

  idata->cmdtype = IMAP_CT_LIST;
  idata->cmddata = &list;
  cmd_parse_list(idata, s);
  idata->cmddata = NULL;
  /* noselect is for a gmail quirk (#3445) */
  if (!list.name || list.noselect)
    return;

  mutt_debug(3, ""Subscribing to %s\n"", list.name);

   mutt_str_strfcpy(buf, ""mailboxes \"""", sizeof(buf));
   mutt_account_tourl(&idata->conn->account, &url);
   /* escape \ and "" */
  imap_quote_string(errstr, sizeof(errstr), list.name, true);
   url.path = errstr + 1;
   url.path[strlen(url.path) - 1] = '\0';
   if (mutt_str_strcmp(url.user, ImapUser) == 0)
    url.user = NULL;
  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);
  mutt_str_strcat(buf, sizeof(buf), ""\"""");
  mutt_buffer_init(&token);
  mutt_buffer_init(&err);
  err.data = errstr;
  err.dsize = sizeof(errstr);
  if (mutt_parse_rc_line(buf, &token, &err))
    mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
  FREE(&token.data);
}
","static void cmd_parse_lsub(struct ImapData *idata, char *s)
{
  char buf[STRING];
  char errstr[STRING];
  struct Buffer err, token;
  struct Url url;
  struct ImapList list;

  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)
  {
    /* caller will handle response itself */
    cmd_parse_list(idata, s);
    return;
  }

  if (!ImapCheckSubscribed)
    return;

  idata->cmdtype = IMAP_CT_LIST;
  idata->cmddata = &list;
  cmd_parse_list(idata, s);
  idata->cmddata = NULL;
  /* noselect is for a gmail quirk (#3445) */
  if (!list.name || list.noselect)
    return;

  mutt_debug(3, ""Subscribing to %s\n"", list.name);

   mutt_str_strfcpy(buf, ""mailboxes \"""", sizeof(buf));
   mutt_account_tourl(&idata->conn->account, &url);
   /* escape \ and "" */
  imap_quote_string(errstr, sizeof(errstr), list.name);
   url.path = errstr + 1;
   url.path[strlen(url.path) - 1] = '\0';
   if (mutt_str_strcmp(url.user, ImapUser) == 0)
    url.user = NULL;
  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);
  mutt_str_strcat(buf, sizeof(buf), ""\"""");
  mutt_buffer_init(&token);
  mutt_buffer_init(&err);
  err.data = errstr;
  err.dsize = sizeof(errstr);
  if (mutt_parse_rc_line(buf, &token, &err))
    mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
  FREE(&token.data);
}
",C,"  imap_quote_string(errstr, sizeof(errstr), list.name, true);
","  imap_quote_string(errstr, sizeof(errstr), list.name);
",,"@@ -499,7 +499,7 @@ static void cmd_parse_lsub(struct ImapData *idata, char *s)
   mutt_str_strfcpy(buf, ""mailboxes \"""", sizeof(buf));
   mutt_account_tourl(&idata->conn->account, &url);
   /* escape \ and "" */
-  imap_quote_string(errstr, sizeof(errstr), list.name);
+  imap_quote_string(errstr, sizeof(errstr), list.name, true);
   url.path = errstr + 1;
   url.path[strlen(url.path) - 1] = '\0';
   if (mutt_str_strcmp(url.user, ImapUser) == 0)",neomutt,e52393740334443ae0206cab2d7caef381646725,9bfab35522301794483f8f9ed60820bdec9be59e,1,"static void cmd_parse_lsub(struct ImapData *idata, char *s)
{
  char buf[STRING];
  char errstr[STRING];
  struct Buffer err, token;
  struct Url url;
  struct ImapList list;

  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)
  {
    /* caller will handle response itself */
    cmd_parse_list(idata, s);
    return;
  }

  if (!ImapCheckSubscribed)
    return;

  idata->cmdtype = IMAP_CT_LIST;
  idata->cmddata = &list;
  cmd_parse_list(idata, s);
  idata->cmddata = NULL;
  /* noselect is for a gmail quirk (#3445) */
  if (!list.name || list.noselect)
    return;

  mutt_debug(3, ""Subscribing to %s\n"", list.name);

   mutt_str_strfcpy(buf, ""mailboxes \"""", sizeof(buf));
   mutt_account_tourl(&idata->conn->account, &url);
   /* escape \ and "" */
//flaw_line_below:
  imap_quote_string(errstr, sizeof(errstr), list.name);
//fix_flaw_line_below:
//  imap_quote_string(errstr, sizeof(errstr), list.name, true);
   url.path = errstr + 1;
   url.path[strlen(url.path) - 1] = '\0';
   if (mutt_str_strcmp(url.user, ImapUser) == 0)
    url.user = NULL;
  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);
  mutt_str_strcat(buf, sizeof(buf), ""\"""");
  mutt_buffer_init(&token);
  mutt_buffer_init(&err);
  err.data = errstr;
  err.dsize = sizeof(errstr);
  if (mutt_parse_rc_line(buf, &token, &err))
    mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
  FREE(&token.data);
}
"
4571,182307,,Remote,Not required,Partial,CVE-2018-14357,https://www.cvedetails.com/cve/CVE-2018-14357/,CWE-77,Low,Partial,Partial,,2018-07-17,7.5,"An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with an automatic subscription.",2019-10-02,Exec Code ,5,https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725,e52393740334443ae0206cab2d7caef381646725,"quote imap strings more carefully

Co-authored-by: JerikoOne <jeriko.one@gmx.us>",5,imap/imap.c,"{""sha"": ""0f4445b4532660e17f18a935fdacd4f492438dcf"", ""filename"": ""imap/auth_login.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/auth_login.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/auth_login.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/auth_login.c?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -65,8 +65,8 @@ enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n \n   mutt_message(_(\""Logging in...\""));\n \n-  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n-  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n+  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);\n+  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);\n \n   /* don't print the password unless we're at the ungodly debugging level\n    * of 5 or higher */""}<_**next**_>{""sha"": ""859f98727c8da58fba14c54beb6c132b8a20df85"", ""filename"": ""imap/command.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/command.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/command.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/command.c?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -499,7 +499,7 @@ static void cmd_parse_lsub(struct ImapData *idata, char *s)\n   mutt_str_strfcpy(buf, \""mailboxes \\\""\"", sizeof(buf));\n   mutt_account_tourl(&idata->conn->account, &url);\n   /* escape \\ and \"" */\n-  imap_quote_string(errstr, sizeof(errstr), list.name);\n+  imap_quote_string(errstr, sizeof(errstr), list.name, true);\n   url.path = errstr + 1;\n   url.path[strlen(url.path) - 1] = '\\0';\n   if (mutt_str_strcmp(url.user, ImapUser) == 0)""}<_**next**_>{""sha"": ""40f620a2e2bf91b34edf289784e01867ef78d830"", ""filename"": ""imap/imap.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/imap.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/imap.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/imap.c?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -464,25 +464,25 @@ static int compile_search(struct Context *ctx, const struct Pattern *pat, struct\n           return -1;\n         }\n         *delim = '\\0';\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         mutt_buffer_addch(buf, ' ');\n \n         /* and field */\n         *delim = ':';\n         delim++;\n         SKIPWS(delim);\n-        imap_quote_string(term, sizeof(term), delim);\n+        imap_quote_string(term, sizeof(term), delim, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_BODY:\n         mutt_buffer_addstr(buf, \""BODY \"");\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_WHOLE_MSG:\n         mutt_buffer_addstr(buf, \""TEXT \"");\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_SERVERSEARCH:\n@@ -495,7 +495,7 @@ static int compile_search(struct Context *ctx, const struct Pattern *pat, struct\n         }\n       }\n         mutt_buffer_addstr(buf, \""X-GM-RAW \"");\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n     }""}<_**next**_>{""sha"": ""278d4a2b13793faf7af21ea24ea6262dab32939e"", ""filename"": ""imap/imap_private.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/imap_private.h"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/imap_private.h"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/imap_private.h?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -328,7 +328,7 @@ char *imap_get_qualifier(char *buf);\n int imap_mxcmp(const char *mx1, const char *mx2);\n char *imap_next_word(char *s);\n void imap_qualify_path(char *dest, size_t len, struct ImapMbox *mx, char *path);\n-void imap_quote_string(char *dest, size_t dlen, const char *src);\n+void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick);\n void imap_unquote_string(char *s);\n void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src);\n void imap_unmunge_mbox_name(struct ImapData *idata, char *s);""}<_**next**_>{""sha"": ""614d87a5612d6769d9fdc27eb4d9557921842600"", ""filename"": ""imap/util.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/e52393740334443ae0206cab2d7caef381646725/imap/util.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/e52393740334443ae0206cab2d7caef381646725/imap/util.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/util.c?ref=e52393740334443ae0206cab2d7caef381646725"", ""patch"": ""@@ -798,9 +798,12 @@ void imap_qualify_path(char *dest, size_t len, struct ImapMbox *mx, char *path)\n  *\n  * Surround string with quotes, escape \"" and \\ with backslash\n  */\n-void imap_quote_string(char *dest, size_t dlen, const char *src)\n+void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n {\n-  static const char quote[] = \""\\\""\\\\\"";\n+  const char *quote = \""`\\\""\\\\\"";\n+  if (!quote_backtick)\n+    quote++;\n+\n   char *pt = dest;\n   const char *s = src;\n \n@@ -874,7 +877,7 @@ void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const\n   char *buf = mutt_str_strdup(src);\n   imap_utf_encode(idata, &buf);\n \n-  imap_quote_string(dest, dlen, buf);\n+  imap_quote_string(dest, dlen, buf, false);\n \n   FREE(&buf);\n }""}","static int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)
{
  if (do_search(pat, 0) == 0)
    return 0;

  if (pat->not)
    mutt_buffer_addstr(buf, ""NOT "");

  if (pat->child)
  {
    int clauses;

    clauses = do_search(pat->child, 1);
    if (clauses > 0)
    {
      const struct Pattern *clause = pat->child;

      mutt_buffer_addch(buf, '(');

      while (clauses)
      {
        if (do_search(clause, 0))
        {
          if (pat->op == MUTT_OR && clauses > 1)
            mutt_buffer_addstr(buf, ""OR "");
          clauses--;

          if (compile_search(ctx, clause, buf) < 0)
            return -1;

          if (clauses)
            mutt_buffer_addch(buf, ' ');
        }
        clause = clause->next;
      }

      mutt_buffer_addch(buf, ')');
    }
  }
  else
  {
    char term[STRING];
    char *delim = NULL;

    switch (pat->op)
    {
      case MUTT_HEADER:
        mutt_buffer_addstr(buf, ""HEADER "");

        /* extract header name */
        delim = strchr(pat->p.str, ':');
        if (!delim)
        {
          mutt_error(_(""Header search without header name: %s""), pat->p.str);
           return -1;
         }
         *delim = '\0';
        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         mutt_buffer_addch(buf, ' ');
 
         /* and field */
         *delim = ':';
         delim++;
         SKIPWS(delim);
        imap_quote_string(term, sizeof(term), delim, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_BODY:
         mutt_buffer_addstr(buf, ""BODY "");
        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_WHOLE_MSG:
         mutt_buffer_addstr(buf, ""TEXT "");
        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_SERVERSEARCH:
      {
        struct ImapData *idata = ctx->data;
        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))
        {
          mutt_error(_(""Server-side custom search not supported: %s""), pat->p.str);
          return -1;
         }
       }
         mutt_buffer_addstr(buf, ""X-GM-RAW "");
        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
     }
  }

  return 0;
}
","static int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)
{
  if (do_search(pat, 0) == 0)
    return 0;

  if (pat->not)
    mutt_buffer_addstr(buf, ""NOT "");

  if (pat->child)
  {
    int clauses;

    clauses = do_search(pat->child, 1);
    if (clauses > 0)
    {
      const struct Pattern *clause = pat->child;

      mutt_buffer_addch(buf, '(');

      while (clauses)
      {
        if (do_search(clause, 0))
        {
          if (pat->op == MUTT_OR && clauses > 1)
            mutt_buffer_addstr(buf, ""OR "");
          clauses--;

          if (compile_search(ctx, clause, buf) < 0)
            return -1;

          if (clauses)
            mutt_buffer_addch(buf, ' ');
        }
        clause = clause->next;
      }

      mutt_buffer_addch(buf, ')');
    }
  }
  else
  {
    char term[STRING];
    char *delim = NULL;

    switch (pat->op)
    {
      case MUTT_HEADER:
        mutt_buffer_addstr(buf, ""HEADER "");

        /* extract header name */
        delim = strchr(pat->p.str, ':');
        if (!delim)
        {
          mutt_error(_(""Header search without header name: %s""), pat->p.str);
           return -1;
         }
         *delim = '\0';
        imap_quote_string(term, sizeof(term), pat->p.str);
         mutt_buffer_addstr(buf, term);
         mutt_buffer_addch(buf, ' ');
 
         /* and field */
         *delim = ':';
         delim++;
         SKIPWS(delim);
        imap_quote_string(term, sizeof(term), delim);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_BODY:
         mutt_buffer_addstr(buf, ""BODY "");
        imap_quote_string(term, sizeof(term), pat->p.str);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_WHOLE_MSG:
         mutt_buffer_addstr(buf, ""TEXT "");
        imap_quote_string(term, sizeof(term), pat->p.str);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_SERVERSEARCH:
      {
        struct ImapData *idata = ctx->data;
        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))
        {
          mutt_error(_(""Server-side custom search not supported: %s""), pat->p.str);
          return -1;
         }
       }
         mutt_buffer_addstr(buf, ""X-GM-RAW "");
        imap_quote_string(term, sizeof(term), pat->p.str);
         mutt_buffer_addstr(buf, term);
         break;
     }
  }

  return 0;
}
",C,"        imap_quote_string(term, sizeof(term), pat->p.str, false);
        imap_quote_string(term, sizeof(term), delim, false);
        imap_quote_string(term, sizeof(term), pat->p.str, false);
        imap_quote_string(term, sizeof(term), pat->p.str, false);
        imap_quote_string(term, sizeof(term), pat->p.str, false);
","        imap_quote_string(term, sizeof(term), pat->p.str);
        imap_quote_string(term, sizeof(term), delim);
        imap_quote_string(term, sizeof(term), pat->p.str);
        imap_quote_string(term, sizeof(term), pat->p.str);
        imap_quote_string(term, sizeof(term), pat->p.str);
",,"@@ -464,25 +464,25 @@ static int compile_search(struct Context *ctx, const struct Pattern *pat, struct
           return -1;
         }
         *delim = '\0';
-        imap_quote_string(term, sizeof(term), pat->p.str);
+        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         mutt_buffer_addch(buf, ' ');
 
         /* and field */
         *delim = ':';
         delim++;
         SKIPWS(delim);
-        imap_quote_string(term, sizeof(term), delim);
+        imap_quote_string(term, sizeof(term), delim, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_BODY:
         mutt_buffer_addstr(buf, ""BODY "");
-        imap_quote_string(term, sizeof(term), pat->p.str);
+        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_WHOLE_MSG:
         mutt_buffer_addstr(buf, ""TEXT "");
-        imap_quote_string(term, sizeof(term), pat->p.str);
+        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_SERVERSEARCH:
@@ -495,7 +495,7 @@ static int compile_search(struct Context *ctx, const struct Pattern *pat, struct
         }
       }
         mutt_buffer_addstr(buf, ""X-GM-RAW "");
-        imap_quote_string(term, sizeof(term), pat->p.str);
+        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
     }",neomutt,e52393740334443ae0206cab2d7caef381646725,9bfab35522301794483f8f9ed60820bdec9be59e,1,"static int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)
{
  if (do_search(pat, 0) == 0)
    return 0;

  if (pat->not)
    mutt_buffer_addstr(buf, ""NOT "");

  if (pat->child)
  {
    int clauses;

    clauses = do_search(pat->child, 1);
    if (clauses > 0)
    {
      const struct Pattern *clause = pat->child;

      mutt_buffer_addch(buf, '(');

      while (clauses)
      {
        if (do_search(clause, 0))
        {
          if (pat->op == MUTT_OR && clauses > 1)
            mutt_buffer_addstr(buf, ""OR "");
          clauses--;

          if (compile_search(ctx, clause, buf) < 0)
            return -1;

          if (clauses)
            mutt_buffer_addch(buf, ' ');
        }
        clause = clause->next;
      }

      mutt_buffer_addch(buf, ')');
    }
  }
  else
  {
    char term[STRING];
    char *delim = NULL;

    switch (pat->op)
    {
      case MUTT_HEADER:
        mutt_buffer_addstr(buf, ""HEADER "");

        /* extract header name */
        delim = strchr(pat->p.str, ':');
        if (!delim)
        {
          mutt_error(_(""Header search without header name: %s""), pat->p.str);
           return -1;
         }
         *delim = '\0';
//flaw_line_below:
        imap_quote_string(term, sizeof(term), pat->p.str);
//fix_flaw_line_below:
//        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         mutt_buffer_addch(buf, ' ');
 
         /* and field */
         *delim = ':';
         delim++;
         SKIPWS(delim);
//flaw_line_below:
        imap_quote_string(term, sizeof(term), delim);
//fix_flaw_line_below:
//        imap_quote_string(term, sizeof(term), delim, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_BODY:
         mutt_buffer_addstr(buf, ""BODY "");
//flaw_line_below:
        imap_quote_string(term, sizeof(term), pat->p.str);
//fix_flaw_line_below:
//        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_WHOLE_MSG:
         mutt_buffer_addstr(buf, ""TEXT "");
//flaw_line_below:
        imap_quote_string(term, sizeof(term), pat->p.str);
//fix_flaw_line_below:
//        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
       case MUTT_SERVERSEARCH:
      {
        struct ImapData *idata = ctx->data;
        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))
        {
          mutt_error(_(""Server-side custom search not supported: %s""), pat->p.str);
          return -1;
         }
       }
         mutt_buffer_addstr(buf, ""X-GM-RAW "");
//flaw_line_below:
        imap_quote_string(term, sizeof(term), pat->p.str);
//fix_flaw_line_below:
//        imap_quote_string(term, sizeof(term), pat->p.str, false);
         mutt_buffer_addstr(buf, term);
         break;
     }
  }

  return 0;
}
"
4573,182309,,Remote,Not required,Partial,CVE-2018-14354,https://www.cvedetails.com/cve/CVE-2018-14354/,CWE-77,Low,Partial,Partial,,2018-07-17,7.5,"An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with a manual subscription or unsubscription.",2019-10-02,Exec Code ,3,https://github.com/neomutt/neomutt/commit/95e80bf9ff10f68cb6443f760b85df4117cb15eb,95e80bf9ff10f68cb6443f760b85df4117cb15eb,Quote path in imap_subscribe,1,imap/imap.c,"{""sha"": ""f1706885620c7afd61bdc5bd03593557980bd0ab"", ""filename"": ""imap/imap.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/95e80bf9ff10f68cb6443f760b85df4117cb15eb/imap/imap.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/95e80bf9ff10f68cb6443f760b85df4117cb15eb/imap/imap.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/imap.c?ref=95e80bf9ff10f68cb6443f760b85df4117cb15eb"", ""patch"": ""@@ -1709,6 +1709,7 @@ int imap_subscribe(char *path, bool subscribe)\n   char errstr[STRING];\n   struct Buffer err, token;\n   struct ImapMbox mx;\n+  size_t len = 0;\n \n   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n   {\n@@ -1729,7 +1730,8 @@ int imap_subscribe(char *path, bool subscribe)\n     mutt_buffer_init(&err);\n     err.data = errstr;\n     err.dsize = sizeof(errstr);\n-    snprintf(mbox, sizeof(mbox), \""%smailboxes \\\""%s\\\""\"", subscribe ? \""\"" : \""un\"", path);\n+\tlen = snprintf(mbox, sizeof(mbox), \""%smailboxes \"", subscribe ? \""\"" : \""un\"");\n+\timap_quote_string(mbox + len, sizeof(mbox) - len, path, true);\n     if (mutt_parse_rc_line(mbox, &token, &err))\n       mutt_debug(1, \""Error adding subscribed mailbox: %s\\n\"", errstr);\n     FREE(&token.data);""}","int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
  size_t len = 0;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
","int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
",C,"  size_t len = 0;
	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
","    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
",,"@@ -1709,6 +1709,7 @@ int imap_subscribe(char *path, bool subscribe)
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
+  size_t len = 0;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
@@ -1729,7 +1730,8 @@ int imap_subscribe(char *path, bool subscribe)
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
-    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
+	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
+	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);",neomutt,95e80bf9ff10f68cb6443f760b85df4117cb15eb,51c4efb8ccae3dab550fe8909fc76fb2462f0a89,1,"int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
//fix_flaw_line_below:
//  size_t len = 0;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
//flaw_line_below:
    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
//fix_flaw_line_below:
//	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
//fix_flaw_line_below:
//	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
"
5112,182848,,Local,Not required,,CVE-2019-11884,https://www.cvedetails.com/cve/CVE-2019-11884/,CWE-77,Low,Partial,,,2019-05-10,2.1,"The do_hidp_sock_ioctl function in net/bluetooth/hidp/sock.c in the Linux kernel before 5.0.15 allows a local user to obtain potentially sensitive information from kernel stack memory via a HIDPCONNADD command, because a name field may not end with a '0' character.",2019-05-31,+Info ,1,https://github.com/torvalds/linux/commit/a1616a5ac99ede5d605047a9012481ce7ff18b16,a1616a5ac99ede5d605047a9012481ce7ff18b16,"Bluetooth: hidp: fix buffer overflow

Struct ca is copied from userspace. It is not checked whether the ""name""
field is NULL terminated, which allows local users to obtain potentially
sensitive information from kernel stack memory, via a HIDPCONNADD command.

This vulnerability is similar to CVE-2011-1079.

Signed-off-by: Young Xiao <YangX92@hotmail.com>
Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
Cc: stable@vger.kernel.org",0,net/bluetooth/hidp/sock.c,"{""sha"": ""2151913892ce8705d093a96fa65c3888e8a6dbb1"", ""filename"": ""net/bluetooth/hidp/sock.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/a1616a5ac99ede5d605047a9012481ce7ff18b16/net/bluetooth/hidp/sock.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a1616a5ac99ede5d605047a9012481ce7ff18b16/net/bluetooth/hidp/sock.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/bluetooth/hidp/sock.c?ref=a1616a5ac99ede5d605047a9012481ce7ff18b16"", ""patch"": ""@@ -75,6 +75,7 @@ static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user\n \t\t\tsockfd_put(csock);\n \t\t\treturn err;\n \t\t}\n+\t\tca.name[sizeof(ca.name)-1] = 0;\n \n \t\terr = hidp_connection_add(&ca, csock, isock);\n \t\tif (!err && copy_to_user(argp, &ca, sizeof(ca)))""}","static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
		ca.name[sizeof(ca.name)-1] = 0;
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
","static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
",C,"		ca.name[sizeof(ca.name)-1] = 0;
",,,"@@ -75,6 +75,7 @@ static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user
 			sockfd_put(csock);
 			return err;
 		}
+		ca.name[sizeof(ca.name)-1] = 0;
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))",linux,a1616a5ac99ede5d605047a9012481ce7ff18b16,73623340546cceff421c95b53abd8140d1f2b2a2,1,"static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
//fix_flaw_line_below:
//		ca.name[sizeof(ca.name)-1] = 0;
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
"
9310,187046,,Local,Not required,,CVE-2019-5804,https://www.cvedetails.com/cve/CVE-2019-5804/,CWE-77,Low,,Partial,,2019-05-23,2.1,Incorrect command line processing in Chrome in Google Chrome prior to 73.0.3683.75 allowed a local attacker to perform domain spoofing via a crafted domain name.,2019-06-28,,4,https://github.com/chromium/chromium/commit/08965161257ab9aeef9a3548c1cd1a44525dc562,08965161257ab9aeef9a3548c1cd1a44525dc562,"Ignore switches following ""--"" when parsing a command line.

BUG=933004
R=wfh@chromium.org

Change-Id: I911be4cbfc38a4d41dec85d85f7fe0f50ddca392
Reviewed-on: https://chromium-review.googlesource.com/c/1481210
Auto-Submit: Greg Thompson <grt@chromium.org>
Commit-Queue: Julian Pastarmov <pastarmovj@chromium.org>
Reviewed-by: Julian Pastarmov <pastarmovj@chromium.org>
Cr-Commit-Position: refs/heads/master@{#634604}",2,chrome/install_static/install_util.cc,"{""sha"": ""7c7b6c5343bb05ebea63212a0c00fdfbd675efc7"", ""filename"": ""chrome/install_static/install_util.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/install_static/install_util.cc?ref=08965161257ab9aeef9a3548c1cd1a44525dc562"", ""patch"": ""@@ -847,13 +847,15 @@ std::vector<std::wstring> TokenizeCommandLineToArray(\n \n std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,\n                                            const std::wstring& switch_name) {\n+  static constexpr wchar_t kSwitchTerminator[] = L\""--\"";\n   assert(!command_line.empty());\n   assert(!switch_name.empty());\n \n   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);\n   std::wstring switch_with_equal = L\""--\"" + switch_name + L\""=\"";\n-  for (size_t i = 1; i < as_array.size(); ++i) {\n-    const std::wstring& arg = as_array[i];\n+  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);\n+  for (auto scan = as_array.cbegin(); scan != end; ++scan) {\n+    const std::wstring& arg = *scan;\n     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)\n       return arg.substr(switch_with_equal.size());\n   }""}<_**next**_>{""sha"": ""27a55e3bd94ca5a377ca300fe5240874f4efdcf5"", ""filename"": ""chrome/install_static/install_util.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/install_static/install_util.h?ref=08965161257ab9aeef9a3548c1cd1a44525dc562"", ""patch"": ""@@ -275,9 +275,10 @@ std::vector<std::wstring> TokenizeString16(const std::wstring& str,\n std::vector<std::wstring> TokenizeCommandLineToArray(\n     const std::wstring& command_line);\n \n-// We assume that the command line |command_line| contains multiple switches\n-// with the format --<switch name>=<switch value>. This function returns the\n-// value of the |switch_name| passed in.\n+// Returns the value of a switch of the form \""--<switch name>=<switch value>\"" in\n+// |command_line|. An empty switch in |command_line| (\""--\"") denotes the end of\n+// switches and the beginning of args. Anything of the form --<switch\n+// name>=<switch value> following \""--\"" is ignored.\n std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,\n                                            const std::wstring& switch_name);\n ""}<_**next**_>{""sha"": ""a05794655ddd653123941c14ce20076e5c07c79d"", ""filename"": ""chrome/install_static/install_util_unittest.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/install_static/install_util_unittest.cc?ref=08965161257ab9aeef9a3548c1cd1a44525dc562"", ""patch"": ""@@ -96,6 +96,10 @@ TEST(InstallStaticTest, GetSwitchValueFromCommandLineTest) {\n   // Bad command line without closing quotes. Should not crash.\n   value = GetSwitchValueFromCommandLine(L\""\\\""blah --type=\\t\\t\\t\"", L\""type\"");\n   EXPECT_TRUE(value.empty());\n+\n+  // Anything following \""--\"" should be considered args and therfore ignored.\n+  value = GetSwitchValueFromCommandLine(L\""blah -- --type=bleh\"", L\""type\"");\n+  EXPECT_TRUE(value.empty());\n }\n \n TEST(InstallStaticTest, SpacesAndQuotesInCommandLineArguments) {""}"," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
  static constexpr wchar_t kSwitchTerminator[] = L""--"";
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
    const std::wstring& arg = *scan;
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
"," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  for (size_t i = 1; i < as_array.size(); ++i) {
    const std::wstring& arg = as_array[i];
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
",C,"  static constexpr wchar_t kSwitchTerminator[] = L""--"";
  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
    const std::wstring& arg = *scan;
","  for (size_t i = 1; i < as_array.size(); ++i) {
    const std::wstring& arg = as_array[i];
",,"@@ -847,13 +847,15 @@ std::vector<std::wstring> TokenizeCommandLineToArray(
 
 std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
+  static constexpr wchar_t kSwitchTerminator[] = L""--"";
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
-  for (size_t i = 1; i < as_array.size(); ++i) {
-    const std::wstring& arg = as_array[i];
+  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
+  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
+    const std::wstring& arg = *scan;
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }",Chrome,08965161257ab9aeef9a3548c1cd1a44525dc562,fba5eff0d4a6451e2d4a925c4f47973fbf10bb91,1," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
//fix_flaw_line_below:
//  static constexpr wchar_t kSwitchTerminator[] = L""--"";
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
//flaw_line_below:
  for (size_t i = 1; i < as_array.size(); ++i) {
//flaw_line_below:
    const std::wstring& arg = as_array[i];
//fix_flaw_line_below:
//  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
//fix_flaw_line_below:
//  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
//fix_flaw_line_below:
//    const std::wstring& arg = *scan;
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
"
