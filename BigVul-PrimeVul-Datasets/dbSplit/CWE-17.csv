,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
65,177801,,Remote,Not required,Partial,CVE-2015-6496,https://www.cvedetails.com/cve/CVE-2015-6496/,CWE-17,Low,,,,2015-08-24,5.0,"conntrackd in conntrack-tools 1.4.2 and earlier does not ensure that the optional kernel modules are loaded before using them, which allows remote attackers to cause a denial of service (crash) via a (1) DCCP, (2) SCTP, or (3) ICMPv6 packet.",2018-05-22,DoS,3,https://git.netfilter.org/conntrack-tools/commit/?id=c392c159605956c7bd4a264ab4490e2b2704c0cd,c392c159605956c7bd4a264ab4490e2b2704c0cd,,2,,," static void build_l4proto_dccp(const struct nf_conntrack *ct, struct nethdr *n)
 {
	/* DCCP is optional, make sure nf_conntrack_dccp is loaded */
 	if (!nfct_attr_is_set(ct, ATTR_DCCP_STATE))
 		return;
 
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_DCCP_STATE, n, NTA_DCCP_STATE);
 	ct_build_u8(ct, ATTR_DCCP_ROLE, n, NTA_DCCP_ROLE);
 }
"," static void build_l4proto_dccp(const struct nf_conntrack *ct, struct nethdr *n)
 {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	if (!nfct_attr_is_set(ct, ATTR_DCCP_STATE))
 		return;
 
 	ct_build_u8(ct, ATTR_DCCP_STATE, n, NTA_DCCP_STATE);
 	ct_build_u8(ct, ATTR_DCCP_ROLE, n, NTA_DCCP_ROLE);
 }
",C,"	/* DCCP is optional, make sure nf_conntrack_dccp is loaded */
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
","	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
",20ddbf33277108da86c69bb78890fac09e055627,"@@ -105,14 +105,14 @@ static enum nf_conntrack_attr nat_type[] =
 	  ATTR_ORIG_NAT_SEQ_OFFSET_AFTER, ATTR_REPL_NAT_SEQ_CORRECTION_POS,
 	  ATTR_REPL_NAT_SEQ_OFFSET_BEFORE, ATTR_REPL_NAT_SEQ_OFFSET_AFTER };
 
+/* ICMP, UDP and TCP are always loaded with nf_conntrack_ipv4 */
 static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)
 {
-	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
-		      sizeof(struct nfct_attr_grp_port));
-
 	if (!nfct_attr_is_set(ct, ATTR_TCP_STATE))
 		return;
 
+	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
+		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_TCP_STATE, n, NTA_TCP_STATE);
 	if (CONFIG(sync).tcp_window_tracking) {
 		ct_build_u8(ct, ATTR_TCP_WSCALE_ORIG, n, NTA_TCP_WSCALE_ORIG);
@@ -122,12 +122,12 @@ static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)
 
 static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 {
-	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
-		      sizeof(struct nfct_attr_grp_port));
-
+	/* SCTP is optional, make sure nf_conntrack_sctp is loaded */
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 
+	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
+		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
@@ -135,18 +135,22 @@ static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 
 static void build_l4proto_dccp(const struct nf_conntrack *ct, struct nethdr *n)
 {
-	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
-		      sizeof(struct nfct_attr_grp_port));
-
+	/* DCCP is optional, make sure nf_conntrack_dccp is loaded */
 	if (!nfct_attr_is_set(ct, ATTR_DCCP_STATE))
 		return;
 
+	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
+		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_DCCP_STATE, n, NTA_DCCP_STATE);
 	ct_build_u8(ct, ATTR_DCCP_ROLE, n, NTA_DCCP_ROLE);
 }
 
 static void build_l4proto_icmp(const struct nf_conntrack *ct, struct nethdr *n)
 {
+	/* This is also used by ICMPv6 and nf_conntrack_ipv6 is optional */
+	if (!nfct_attr_is_set(ct, ATTR_ICMP_TYPE))
+		return;
+
 	ct_build_u8(ct, ATTR_ICMP_TYPE, n, NTA_ICMP_TYPE);
 	ct_build_u8(ct, ATTR_ICMP_CODE, n, NTA_ICMP_CODE);
 	ct_build_u16(ct, ATTR_ICMP_ID, n, NTA_ICMP_ID);",netfilter,https://git.netfilter.org/conntrack-tools/tree/src/build.c?id=c392c159605956c7bd4a264ab4490e2b2704c0cd,https://git.netfilter.org/conntrack-tools/tree/src/build.c?id=20ddbf33277108da86c69bb78890fac09e055627,1," static void build_l4proto_dccp(const struct nf_conntrack *ct, struct nethdr *n)
 {
//flaw_line_below:
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
//flaw_line_below:
		      sizeof(struct nfct_attr_grp_port));
//flaw_line_below:

//fix_flaw_line_below:
//	/* DCCP is optional, make sure nf_conntrack_dccp is loaded */
 	if (!nfct_attr_is_set(ct, ATTR_DCCP_STATE))
 		return;
 
//fix_flaw_line_below:
//	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
//fix_flaw_line_below:
//		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_DCCP_STATE, n, NTA_DCCP_STATE);
 	ct_build_u8(ct, ATTR_DCCP_ROLE, n, NTA_DCCP_ROLE);
 }
"
66,177802,,Remote,Not required,Partial,CVE-2015-6496,https://www.cvedetails.com/cve/CVE-2015-6496/,CWE-17,Low,,,,2015-08-24,5.0,"conntrackd in conntrack-tools 1.4.2 and earlier does not ensure that the optional kernel modules are loaded before using them, which allows remote attackers to cause a denial of service (crash) via a (1) DCCP, (2) SCTP, or (3) ICMPv6 packet.",2018-05-22,DoS,4,https://git.netfilter.org/conntrack-tools/commit/?id=c392c159605956c7bd4a264ab4490e2b2704c0cd,c392c159605956c7bd4a264ab4490e2b2704c0cd,,0,,," static void build_l4proto_icmp(const struct nf_conntrack *ct, struct nethdr *n)
 {
	/* This is also used by ICMPv6 and nf_conntrack_ipv6 is optional */
	if (!nfct_attr_is_set(ct, ATTR_ICMP_TYPE))
		return;

 	ct_build_u8(ct, ATTR_ICMP_TYPE, n, NTA_ICMP_TYPE);
 	ct_build_u8(ct, ATTR_ICMP_CODE, n, NTA_ICMP_CODE);
 	ct_build_u16(ct, ATTR_ICMP_ID, n, NTA_ICMP_ID);
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
}
"," static void build_l4proto_icmp(const struct nf_conntrack *ct, struct nethdr *n)
 {
 	ct_build_u8(ct, ATTR_ICMP_TYPE, n, NTA_ICMP_TYPE);
 	ct_build_u8(ct, ATTR_ICMP_CODE, n, NTA_ICMP_CODE);
 	ct_build_u16(ct, ATTR_ICMP_ID, n, NTA_ICMP_ID);
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
}
",C,"	/* This is also used by ICMPv6 and nf_conntrack_ipv6 is optional */
	if (!nfct_attr_is_set(ct, ATTR_ICMP_TYPE))
		return;

",,20ddbf33277108da86c69bb78890fac09e055627,"@@ -105,14 +105,14 @@ static enum nf_conntrack_attr nat_type[] =
 	  ATTR_ORIG_NAT_SEQ_OFFSET_AFTER, ATTR_REPL_NAT_SEQ_CORRECTION_POS,
 	  ATTR_REPL_NAT_SEQ_OFFSET_BEFORE, ATTR_REPL_NAT_SEQ_OFFSET_AFTER };
 
+/* ICMP, UDP and TCP are always loaded with nf_conntrack_ipv4 */
 static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)
 {
-	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
-		      sizeof(struct nfct_attr_grp_port));
-
 	if (!nfct_attr_is_set(ct, ATTR_TCP_STATE))
 		return;
 
+	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
+		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_TCP_STATE, n, NTA_TCP_STATE);
 	if (CONFIG(sync).tcp_window_tracking) {
 		ct_build_u8(ct, ATTR_TCP_WSCALE_ORIG, n, NTA_TCP_WSCALE_ORIG);
@@ -122,12 +122,12 @@ static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)
 
 static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 {
-	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
-		      sizeof(struct nfct_attr_grp_port));
-
+	/* SCTP is optional, make sure nf_conntrack_sctp is loaded */
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 
+	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
+		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
@@ -135,18 +135,22 @@ static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 
 static void build_l4proto_dccp(const struct nf_conntrack *ct, struct nethdr *n)
 {
-	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
-		      sizeof(struct nfct_attr_grp_port));
-
+	/* DCCP is optional, make sure nf_conntrack_dccp is loaded */
 	if (!nfct_attr_is_set(ct, ATTR_DCCP_STATE))
 		return;
 
+	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
+		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_DCCP_STATE, n, NTA_DCCP_STATE);
 	ct_build_u8(ct, ATTR_DCCP_ROLE, n, NTA_DCCP_ROLE);
 }
 
 static void build_l4proto_icmp(const struct nf_conntrack *ct, struct nethdr *n)
 {
+	/* This is also used by ICMPv6 and nf_conntrack_ipv6 is optional */
+	if (!nfct_attr_is_set(ct, ATTR_ICMP_TYPE))
+		return;
+
 	ct_build_u8(ct, ATTR_ICMP_TYPE, n, NTA_ICMP_TYPE);
 	ct_build_u8(ct, ATTR_ICMP_CODE, n, NTA_ICMP_CODE);
 	ct_build_u16(ct, ATTR_ICMP_ID, n, NTA_ICMP_ID);",netfilter,https://git.netfilter.org/conntrack-tools/tree/src/build.c?id=c392c159605956c7bd4a264ab4490e2b2704c0cd,https://git.netfilter.org/conntrack-tools/tree/src/build.c?id=20ddbf33277108da86c69bb78890fac09e055627,1," static void build_l4proto_icmp(const struct nf_conntrack *ct, struct nethdr *n)
 {
//fix_flaw_line_below:
//	/* This is also used by ICMPv6 and nf_conntrack_ipv6 is optional */
//fix_flaw_line_below:
//	if (!nfct_attr_is_set(ct, ATTR_ICMP_TYPE))
//fix_flaw_line_below:
//		return;
//fix_flaw_line_below:
//
 	ct_build_u8(ct, ATTR_ICMP_TYPE, n, NTA_ICMP_TYPE);
 	ct_build_u8(ct, ATTR_ICMP_CODE, n, NTA_ICMP_CODE);
 	ct_build_u16(ct, ATTR_ICMP_ID, n, NTA_ICMP_ID);
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
}
"
67,177803,,Remote,Not required,Partial,CVE-2015-6496,https://www.cvedetails.com/cve/CVE-2015-6496/,CWE-17,Low,,,,2015-08-24,5.0,"conntrackd in conntrack-tools 1.4.2 and earlier does not ensure that the optional kernel modules are loaded before using them, which allows remote attackers to cause a denial of service (crash) via a (1) DCCP, (2) SCTP, or (3) ICMPv6 packet.",2018-05-22,DoS,3,https://git.netfilter.org/conntrack-tools/commit/?id=c392c159605956c7bd4a264ab4490e2b2704c0cd,c392c159605956c7bd4a264ab4490e2b2704c0cd,,2,,," static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 {
	/* SCTP is optional, make sure nf_conntrack_sctp is loaded */
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
}
"," static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 
 	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
}
",C,"	/* SCTP is optional, make sure nf_conntrack_sctp is loaded */
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
","	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
",20ddbf33277108da86c69bb78890fac09e055627,"@@ -105,14 +105,14 @@ static enum nf_conntrack_attr nat_type[] =
 	  ATTR_ORIG_NAT_SEQ_OFFSET_AFTER, ATTR_REPL_NAT_SEQ_CORRECTION_POS,
 	  ATTR_REPL_NAT_SEQ_OFFSET_BEFORE, ATTR_REPL_NAT_SEQ_OFFSET_AFTER };
 
+/* ICMP, UDP and TCP are always loaded with nf_conntrack_ipv4 */
 static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)
 {
-	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
-		      sizeof(struct nfct_attr_grp_port));
-
 	if (!nfct_attr_is_set(ct, ATTR_TCP_STATE))
 		return;
 
+	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
+		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_TCP_STATE, n, NTA_TCP_STATE);
 	if (CONFIG(sync).tcp_window_tracking) {
 		ct_build_u8(ct, ATTR_TCP_WSCALE_ORIG, n, NTA_TCP_WSCALE_ORIG);
@@ -122,12 +122,12 @@ static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)
 
 static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 {
-	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
-		      sizeof(struct nfct_attr_grp_port));
-
+	/* SCTP is optional, make sure nf_conntrack_sctp is loaded */
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 
+	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
+		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
@@ -135,18 +135,22 @@ static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 
 static void build_l4proto_dccp(const struct nf_conntrack *ct, struct nethdr *n)
 {
-	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
-		      sizeof(struct nfct_attr_grp_port));
-
+	/* DCCP is optional, make sure nf_conntrack_dccp is loaded */
 	if (!nfct_attr_is_set(ct, ATTR_DCCP_STATE))
 		return;
 
+	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
+		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_DCCP_STATE, n, NTA_DCCP_STATE);
 	ct_build_u8(ct, ATTR_DCCP_ROLE, n, NTA_DCCP_ROLE);
 }
 
 static void build_l4proto_icmp(const struct nf_conntrack *ct, struct nethdr *n)
 {
+	/* This is also used by ICMPv6 and nf_conntrack_ipv6 is optional */
+	if (!nfct_attr_is_set(ct, ATTR_ICMP_TYPE))
+		return;
+
 	ct_build_u8(ct, ATTR_ICMP_TYPE, n, NTA_ICMP_TYPE);
 	ct_build_u8(ct, ATTR_ICMP_CODE, n, NTA_ICMP_CODE);
 	ct_build_u16(ct, ATTR_ICMP_ID, n, NTA_ICMP_ID);",netfilter,https://git.netfilter.org/conntrack-tools/tree/src/build.c?id=c392c159605956c7bd4a264ab4490e2b2704c0cd,https://git.netfilter.org/conntrack-tools/tree/src/build.c?id=20ddbf33277108da86c69bb78890fac09e055627,1," static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 {
//flaw_line_below:
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
//flaw_line_below:
		      sizeof(struct nfct_attr_grp_port));
//flaw_line_below:

//fix_flaw_line_below:
//	/* SCTP is optional, make sure nf_conntrack_sctp is loaded */
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 
//fix_flaw_line_below:
//	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
//fix_flaw_line_below:
//		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
}
"
68,177804,,Remote,Not required,Partial,CVE-2015-6496,https://www.cvedetails.com/cve/CVE-2015-6496/,CWE-17,Low,,,,2015-08-24,5.0,"conntrackd in conntrack-tools 1.4.2 and earlier does not ensure that the optional kernel modules are loaded before using them, which allows remote attackers to cause a denial of service (crash) via a (1) DCCP, (2) SCTP, or (3) ICMPv6 packet.",2018-05-22,DoS,2,https://git.netfilter.org/conntrack-tools/commit/?id=c392c159605956c7bd4a264ab4490e2b2704c0cd,c392c159605956c7bd4a264ab4490e2b2704c0cd,,2,,," static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)
 {
 	if (!nfct_attr_is_set(ct, ATTR_TCP_STATE))
 		return;
 
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_TCP_STATE, n, NTA_TCP_STATE);
 	if (CONFIG(sync).tcp_window_tracking) {
 		ct_build_u8(ct, ATTR_TCP_WSCALE_ORIG, n, NTA_TCP_WSCALE_ORIG);
		ct_build_u8(ct, ATTR_TCP_WSCALE_REPL, n, NTA_TCP_WSCALE_REPL);
	}
}
"," static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)
 {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	if (!nfct_attr_is_set(ct, ATTR_TCP_STATE))
 		return;
 
 	ct_build_u8(ct, ATTR_TCP_STATE, n, NTA_TCP_STATE);
 	if (CONFIG(sync).tcp_window_tracking) {
 		ct_build_u8(ct, ATTR_TCP_WSCALE_ORIG, n, NTA_TCP_WSCALE_ORIG);
		ct_build_u8(ct, ATTR_TCP_WSCALE_REPL, n, NTA_TCP_WSCALE_REPL);
	}
}
",C,"	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
","	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
",20ddbf33277108da86c69bb78890fac09e055627,"@@ -105,14 +105,14 @@ static enum nf_conntrack_attr nat_type[] =
 	  ATTR_ORIG_NAT_SEQ_OFFSET_AFTER, ATTR_REPL_NAT_SEQ_CORRECTION_POS,
 	  ATTR_REPL_NAT_SEQ_OFFSET_BEFORE, ATTR_REPL_NAT_SEQ_OFFSET_AFTER };
 
+/* ICMP, UDP and TCP are always loaded with nf_conntrack_ipv4 */
 static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)
 {
-	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
-		      sizeof(struct nfct_attr_grp_port));
-
 	if (!nfct_attr_is_set(ct, ATTR_TCP_STATE))
 		return;
 
+	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
+		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_TCP_STATE, n, NTA_TCP_STATE);
 	if (CONFIG(sync).tcp_window_tracking) {
 		ct_build_u8(ct, ATTR_TCP_WSCALE_ORIG, n, NTA_TCP_WSCALE_ORIG);
@@ -122,12 +122,12 @@ static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)
 
 static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 {
-	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
-		      sizeof(struct nfct_attr_grp_port));
-
+	/* SCTP is optional, make sure nf_conntrack_sctp is loaded */
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 
+	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
+		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
@@ -135,18 +135,22 @@ static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 
 static void build_l4proto_dccp(const struct nf_conntrack *ct, struct nethdr *n)
 {
-	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
-		      sizeof(struct nfct_attr_grp_port));
-
+	/* DCCP is optional, make sure nf_conntrack_dccp is loaded */
 	if (!nfct_attr_is_set(ct, ATTR_DCCP_STATE))
 		return;
 
+	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
+		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_DCCP_STATE, n, NTA_DCCP_STATE);
 	ct_build_u8(ct, ATTR_DCCP_ROLE, n, NTA_DCCP_ROLE);
 }
 
 static void build_l4proto_icmp(const struct nf_conntrack *ct, struct nethdr *n)
 {
+	/* This is also used by ICMPv6 and nf_conntrack_ipv6 is optional */
+	if (!nfct_attr_is_set(ct, ATTR_ICMP_TYPE))
+		return;
+
 	ct_build_u8(ct, ATTR_ICMP_TYPE, n, NTA_ICMP_TYPE);
 	ct_build_u8(ct, ATTR_ICMP_CODE, n, NTA_ICMP_CODE);
 	ct_build_u16(ct, ATTR_ICMP_ID, n, NTA_ICMP_ID);",netfilter,https://git.netfilter.org/conntrack-tools/tree/src/build.c?id=c392c159605956c7bd4a264ab4490e2b2704c0cd,https://git.netfilter.org/conntrack-tools/tree/src/build.c?id=20ddbf33277108da86c69bb78890fac09e055627,1," static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)
 {
//flaw_line_below:
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
//flaw_line_below:
		      sizeof(struct nfct_attr_grp_port));
//flaw_line_below:

 	if (!nfct_attr_is_set(ct, ATTR_TCP_STATE))
 		return;
 
//fix_flaw_line_below:
//	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
//fix_flaw_line_below:
//		      sizeof(struct nfct_attr_grp_port));
 	ct_build_u8(ct, ATTR_TCP_STATE, n, NTA_TCP_STATE);
 	if (CONFIG(sync).tcp_window_tracking) {
 		ct_build_u8(ct, ATTR_TCP_WSCALE_ORIG, n, NTA_TCP_WSCALE_ORIG);
		ct_build_u8(ct, ATTR_TCP_WSCALE_REPL, n, NTA_TCP_WSCALE_REPL);
	}
}
"
242,177978,,Remote,Not required,Partial,CVE-2015-0290,https://www.cvedetails.com/cve/CVE-2015-0290/,CWE-17,Low,,,,2015-03-19,5.0,"The multi-block feature in the ssl3_write_bytes function in s3_pkt.c in OpenSSL 1.0.2 before 1.0.2a on 64-bit x86 platforms with AES NI support does not properly handle certain non-blocking I/O cases, which allows remote attackers to cause a denial of service (pointer corruption and application crash) via unspecified vectors.",2018-11-29,DoS,1,https://git.openssl.org/?p=openssl.git;a=commit;h=77c77f0a1b9f15b869ca3342186dfbedd1119d0e,77c77f0a1b9f15b869ca3342186dfbedd1119d0e,,1,,,"int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)
{
    const unsigned char *buf = buf_;
    int tot;
    unsigned int n, nw;
#if !defined(OPENSSL_NO_MULTIBLOCK) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK
    unsigned int max_send_fragment;
#endif
    SSL3_BUFFER *wb = &(s->s3->wbuf);
    int i;

    s->rwstate = SSL_NOTHING;
    OPENSSL_assert(s->s3->wnum <= INT_MAX);
    tot = s->s3->wnum;
    s->s3->wnum = 0;

    if (SSL_in_init(s) && !s->in_handshake) {
        i = s->handshake_func(s);
        if (i < 0)
            return (i);
        if (i == 0) {
            SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);
            return -1;
        }
    }

    /*
     * ensure that if we end up with a smaller value of data to write out
     * than the the original len from a write which didn't complete for
     * non-blocking I/O and also somehow ended up avoiding the check for
     * this in ssl3_write_pending/SSL_R_BAD_WRITE_RETRY as it must never be
     * possible to end up with (len-tot) as a large number that will then
     * promptly send beyond the end of the users buffer ... so we trap and
     * report the error in a way the user will notice
     */
    if (len < tot) {
        SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_BAD_LENGTH);
        return (-1);
    }

    /*
     * first check if there is a SSL3_BUFFER still being written out.  This
     * will happen with non blocking IO
     */
    if (wb->left != 0) {
        i = ssl3_write_pending(s, type, &buf[tot], s->s3->wpend_tot);
        if (i <= 0) {
            /* XXX should we ssl3_release_write_buffer if i<0? */
            s->s3->wnum = tot;
            return i;
        }
        tot += i;               /* this might be last fragment */
    }
#if !defined(OPENSSL_NO_MULTIBLOCK) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK
    /*
     * Depending on platform multi-block can deliver several *times*
     * better performance. Downside is that it has to allocate
     * jumbo buffer to accomodate up to 8 records, but the
     * compromise is considered worthy.
     */
    if (type == SSL3_RT_APPLICATION_DATA &&
        len >= 4 * (int)(max_send_fragment = s->max_send_fragment) &&
        s->compress == NULL && s->msg_callback == NULL &&
        SSL_USE_EXPLICIT_IV(s) &&
        EVP_CIPHER_flags(s->enc_write_ctx->cipher) &
        EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK) {
        unsigned char aad[13];
        EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM mb_param;
        int packlen;

        /* minimize address aliasing conflicts */
        if ((max_send_fragment & 0xfff) == 0)
            max_send_fragment -= 512;

        if (tot == 0 || wb->buf == NULL) { /* allocate jumbo buffer */
            ssl3_release_write_buffer(s);

            packlen = EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,
                                          EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE,
                                          max_send_fragment, NULL);

            if (len >= 8 * (int)max_send_fragment)
                packlen *= 8;
            else
                packlen *= 4;

            wb->buf = OPENSSL_malloc(packlen);
            if(!wb->buf) {
                SSLerr(SSL_F_SSL3_WRITE_BYTES, ERR_R_MALLOC_FAILURE);
                return -1;
            }
            wb->len = packlen;
        } else if (tot == len) { /* done? */
            OPENSSL_free(wb->buf); /* free jumbo buffer */
            wb->buf = NULL;
            return tot;
        }

        n = (len - tot);
        for (;;) {
            if (n < 4 * max_send_fragment) {
                OPENSSL_free(wb->buf); /* free jumbo buffer */
                wb->buf = NULL;
                break;
            }

            if (s->s3->alert_dispatch) {
                i = s->method->ssl_dispatch_alert(s);
                if (i <= 0) {
                    s->s3->wnum = tot;
                    return i;
                }
            }

            if (n >= 8 * max_send_fragment)
                nw = max_send_fragment * (mb_param.interleave = 8);
            else
                nw = max_send_fragment * (mb_param.interleave = 4);

            memcpy(aad, s->s3->write_sequence, 8);
            aad[8] = type;
            aad[9] = (unsigned char)(s->version >> 8);
            aad[10] = (unsigned char)(s->version);
            aad[11] = 0;
            aad[12] = 0;
            mb_param.out = NULL;
            mb_param.inp = aad;
            mb_param.len = nw;

            packlen = EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,
                                          EVP_CTRL_TLS1_1_MULTIBLOCK_AAD,
                                          sizeof(mb_param), &mb_param);

            if (packlen <= 0 || packlen > (int)wb->len) { /* never happens */
                OPENSSL_free(wb->buf); /* free jumbo buffer */
                wb->buf = NULL;
                break;
            }

            mb_param.out = wb->buf;
            mb_param.inp = &buf[tot];
            mb_param.len = nw;

            if (EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,
                                    EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT,
                                    sizeof(mb_param), &mb_param) <= 0)
                return -1;

            s->s3->write_sequence[7] += mb_param.interleave;
            if (s->s3->write_sequence[7] < mb_param.interleave) {
                int j = 6;
                while (j >= 0 && (++s->s3->write_sequence[j--]) == 0) ;
            }

            wb->offset = 0;
            wb->left = packlen;

            s->s3->wpend_tot = nw;
            s->s3->wpend_buf = &buf[tot];
            s->s3->wpend_type = type;
            s->s3->wpend_ret = nw;
 
             i = ssl3_write_pending(s, type, &buf[tot], nw);
             if (i <= 0) {
                if (i < 0 && (!s->wbio || !BIO_should_retry(s->wbio))) {
                     OPENSSL_free(wb->buf);
                     wb->buf = NULL;
                 }
                s->s3->wnum = tot;
                return i;
            }
            if (i == (int)n) {
                OPENSSL_free(wb->buf); /* free jumbo buffer */
                wb->buf = NULL;
                return tot + i;
            }
            n -= i;
            tot += i;
        }
    } else
#endif
    if (tot == len) {           /* done? */
        if (s->mode & SSL_MODE_RELEASE_BUFFERS && !SSL_IS_DTLS(s))
            ssl3_release_write_buffer(s);

        return tot;
    }

    n = (len - tot);
    for (;;) {
        if (n > s->max_send_fragment)
            nw = s->max_send_fragment;
        else
            nw = n;

        i = do_ssl3_write(s, type, &(buf[tot]), nw, 0);
        if (i <= 0) {
            /* XXX should we ssl3_release_write_buffer if i<0? */
            s->s3->wnum = tot;
            return i;
        }

        if ((i == (int)n) ||
            (type == SSL3_RT_APPLICATION_DATA &&
             (s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE))) {
            /*
             * next chunk of data should get another prepended empty fragment
             * in ciphersuites with known-IV weakness:
             */
            s->s3->empty_fragment_done = 0;

            if ((i == (int)n) && s->mode & SSL_MODE_RELEASE_BUFFERS &&
                !SSL_IS_DTLS(s))
                ssl3_release_write_buffer(s);

            return tot + i;
        }

        n -= i;
        tot += i;
    }
}
","int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)
{
    const unsigned char *buf = buf_;
    int tot;
    unsigned int n, nw;
#if !defined(OPENSSL_NO_MULTIBLOCK) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK
    unsigned int max_send_fragment;
#endif
    SSL3_BUFFER *wb = &(s->s3->wbuf);
    int i;

    s->rwstate = SSL_NOTHING;
    OPENSSL_assert(s->s3->wnum <= INT_MAX);
    tot = s->s3->wnum;
    s->s3->wnum = 0;

    if (SSL_in_init(s) && !s->in_handshake) {
        i = s->handshake_func(s);
        if (i < 0)
            return (i);
        if (i == 0) {
            SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);
            return -1;
        }
    }

    /*
     * ensure that if we end up with a smaller value of data to write out
     * than the the original len from a write which didn't complete for
     * non-blocking I/O and also somehow ended up avoiding the check for
     * this in ssl3_write_pending/SSL_R_BAD_WRITE_RETRY as it must never be
     * possible to end up with (len-tot) as a large number that will then
     * promptly send beyond the end of the users buffer ... so we trap and
     * report the error in a way the user will notice
     */
    if (len < tot) {
        SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_BAD_LENGTH);
        return (-1);
    }

    /*
     * first check if there is a SSL3_BUFFER still being written out.  This
     * will happen with non blocking IO
     */
    if (wb->left != 0) {
        i = ssl3_write_pending(s, type, &buf[tot], s->s3->wpend_tot);
        if (i <= 0) {
            /* XXX should we ssl3_release_write_buffer if i<0? */
            s->s3->wnum = tot;
            return i;
        }
        tot += i;               /* this might be last fragment */
    }
#if !defined(OPENSSL_NO_MULTIBLOCK) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK
    /*
     * Depending on platform multi-block can deliver several *times*
     * better performance. Downside is that it has to allocate
     * jumbo buffer to accomodate up to 8 records, but the
     * compromise is considered worthy.
     */
    if (type == SSL3_RT_APPLICATION_DATA &&
        len >= 4 * (int)(max_send_fragment = s->max_send_fragment) &&
        s->compress == NULL && s->msg_callback == NULL &&
        SSL_USE_EXPLICIT_IV(s) &&
        EVP_CIPHER_flags(s->enc_write_ctx->cipher) &
        EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK) {
        unsigned char aad[13];
        EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM mb_param;
        int packlen;

        /* minimize address aliasing conflicts */
        if ((max_send_fragment & 0xfff) == 0)
            max_send_fragment -= 512;

        if (tot == 0 || wb->buf == NULL) { /* allocate jumbo buffer */
            ssl3_release_write_buffer(s);

            packlen = EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,
                                          EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE,
                                          max_send_fragment, NULL);

            if (len >= 8 * (int)max_send_fragment)
                packlen *= 8;
            else
                packlen *= 4;

            wb->buf = OPENSSL_malloc(packlen);
            if(!wb->buf) {
                SSLerr(SSL_F_SSL3_WRITE_BYTES, ERR_R_MALLOC_FAILURE);
                return -1;
            }
            wb->len = packlen;
        } else if (tot == len) { /* done? */
            OPENSSL_free(wb->buf); /* free jumbo buffer */
            wb->buf = NULL;
            return tot;
        }

        n = (len - tot);
        for (;;) {
            if (n < 4 * max_send_fragment) {
                OPENSSL_free(wb->buf); /* free jumbo buffer */
                wb->buf = NULL;
                break;
            }

            if (s->s3->alert_dispatch) {
                i = s->method->ssl_dispatch_alert(s);
                if (i <= 0) {
                    s->s3->wnum = tot;
                    return i;
                }
            }

            if (n >= 8 * max_send_fragment)
                nw = max_send_fragment * (mb_param.interleave = 8);
            else
                nw = max_send_fragment * (mb_param.interleave = 4);

            memcpy(aad, s->s3->write_sequence, 8);
            aad[8] = type;
            aad[9] = (unsigned char)(s->version >> 8);
            aad[10] = (unsigned char)(s->version);
            aad[11] = 0;
            aad[12] = 0;
            mb_param.out = NULL;
            mb_param.inp = aad;
            mb_param.len = nw;

            packlen = EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,
                                          EVP_CTRL_TLS1_1_MULTIBLOCK_AAD,
                                          sizeof(mb_param), &mb_param);

            if (packlen <= 0 || packlen > (int)wb->len) { /* never happens */
                OPENSSL_free(wb->buf); /* free jumbo buffer */
                wb->buf = NULL;
                break;
            }

            mb_param.out = wb->buf;
            mb_param.inp = &buf[tot];
            mb_param.len = nw;

            if (EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,
                                    EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT,
                                    sizeof(mb_param), &mb_param) <= 0)
                return -1;

            s->s3->write_sequence[7] += mb_param.interleave;
            if (s->s3->write_sequence[7] < mb_param.interleave) {
                int j = 6;
                while (j >= 0 && (++s->s3->write_sequence[j--]) == 0) ;
            }

            wb->offset = 0;
            wb->left = packlen;

            s->s3->wpend_tot = nw;
            s->s3->wpend_buf = &buf[tot];
            s->s3->wpend_type = type;
            s->s3->wpend_ret = nw;
 
             i = ssl3_write_pending(s, type, &buf[tot], nw);
             if (i <= 0) {
                if (i < 0) {
                     OPENSSL_free(wb->buf);
                     wb->buf = NULL;
                 }
                s->s3->wnum = tot;
                return i;
            }
            if (i == (int)n) {
                OPENSSL_free(wb->buf); /* free jumbo buffer */
                wb->buf = NULL;
                return tot + i;
            }
            n -= i;
            tot += i;
        }
    } else
#endif
    if (tot == len) {           /* done? */
        if (s->mode & SSL_MODE_RELEASE_BUFFERS && !SSL_IS_DTLS(s))
            ssl3_release_write_buffer(s);

        return tot;
    }

    n = (len - tot);
    for (;;) {
        if (n > s->max_send_fragment)
            nw = s->max_send_fragment;
        else
            nw = n;

        i = do_ssl3_write(s, type, &(buf[tot]), nw, 0);
        if (i <= 0) {
            /* XXX should we ssl3_release_write_buffer if i<0? */
            s->s3->wnum = tot;
            return i;
        }

        if ((i == (int)n) ||
            (type == SSL3_RT_APPLICATION_DATA &&
             (s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE))) {
            /*
             * next chunk of data should get another prepended empty fragment
             * in ciphersuites with known-IV weakness:
             */
            s->s3->empty_fragment_done = 0;

            if ((i == (int)n) && s->mode & SSL_MODE_RELEASE_BUFFERS &&
                !SSL_IS_DTLS(s))
                ssl3_release_write_buffer(s);

            return tot + i;
        }

        n -= i;
        tot += i;
    }
}
",C,"                if (i < 0 && (!s->wbio || !BIO_should_retry(s->wbio))) {
","                if (i < 0) {
",8b84495380098592ef7bb2fa9209ccb87803bf1d,"@@ -785,7 +785,7 @@ int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)
 
             i = ssl3_write_pending(s, type, &buf[tot], nw);
             if (i <= 0) {
-                if (i < 0) {
+                if (i < 0 && (!s->wbio || !BIO_should_retry(s->wbio))) {
                     OPENSSL_free(wb->buf);
                     wb->buf = NULL;
                 }",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=ssl/s3_pkt.c;h=221ae039e99eaeb5442103268ac9e6137dba40e4;hb=221ae039e99eaeb5442103268ac9e6137dba40e4,https://git.openssl.org/?p=openssl.git;a=blob;f=ssl/s3_pkt.c;h=4e6a41bd58ebd09f1eacd0edda1500d434b3a695;hb=4e6a41bd58ebd09f1eacd0edda1500d434b3a695,1,"int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)
{
    const unsigned char *buf = buf_;
    int tot;
    unsigned int n, nw;
#if !defined(OPENSSL_NO_MULTIBLOCK) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK
    unsigned int max_send_fragment;
#endif
    SSL3_BUFFER *wb = &(s->s3->wbuf);
    int i;

    s->rwstate = SSL_NOTHING;
    OPENSSL_assert(s->s3->wnum <= INT_MAX);
    tot = s->s3->wnum;
    s->s3->wnum = 0;

    if (SSL_in_init(s) && !s->in_handshake) {
        i = s->handshake_func(s);
        if (i < 0)
            return (i);
        if (i == 0) {
            SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);
            return -1;
        }
    }

    /*
     * ensure that if we end up with a smaller value of data to write out
     * than the the original len from a write which didn't complete for
     * non-blocking I/O and also somehow ended up avoiding the check for
     * this in ssl3_write_pending/SSL_R_BAD_WRITE_RETRY as it must never be
     * possible to end up with (len-tot) as a large number that will then
     * promptly send beyond the end of the users buffer ... so we trap and
     * report the error in a way the user will notice
     */
    if (len < tot) {
        SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_BAD_LENGTH);
        return (-1);
    }

    /*
     * first check if there is a SSL3_BUFFER still being written out.  This
     * will happen with non blocking IO
     */
    if (wb->left != 0) {
        i = ssl3_write_pending(s, type, &buf[tot], s->s3->wpend_tot);
        if (i <= 0) {
            /* XXX should we ssl3_release_write_buffer if i<0? */
            s->s3->wnum = tot;
            return i;
        }
        tot += i;               /* this might be last fragment */
    }
#if !defined(OPENSSL_NO_MULTIBLOCK) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK
    /*
     * Depending on platform multi-block can deliver several *times*
     * better performance. Downside is that it has to allocate
     * jumbo buffer to accomodate up to 8 records, but the
     * compromise is considered worthy.
     */
    if (type == SSL3_RT_APPLICATION_DATA &&
        len >= 4 * (int)(max_send_fragment = s->max_send_fragment) &&
        s->compress == NULL && s->msg_callback == NULL &&
        SSL_USE_EXPLICIT_IV(s) &&
        EVP_CIPHER_flags(s->enc_write_ctx->cipher) &
        EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK) {
        unsigned char aad[13];
        EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM mb_param;
        int packlen;

        /* minimize address aliasing conflicts */
        if ((max_send_fragment & 0xfff) == 0)
            max_send_fragment -= 512;

        if (tot == 0 || wb->buf == NULL) { /* allocate jumbo buffer */
            ssl3_release_write_buffer(s);

            packlen = EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,
                                          EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE,
                                          max_send_fragment, NULL);

            if (len >= 8 * (int)max_send_fragment)
                packlen *= 8;
            else
                packlen *= 4;

            wb->buf = OPENSSL_malloc(packlen);
            if(!wb->buf) {
                SSLerr(SSL_F_SSL3_WRITE_BYTES, ERR_R_MALLOC_FAILURE);
                return -1;
            }
            wb->len = packlen;
        } else if (tot == len) { /* done? */
            OPENSSL_free(wb->buf); /* free jumbo buffer */
            wb->buf = NULL;
            return tot;
        }

        n = (len - tot);
        for (;;) {
            if (n < 4 * max_send_fragment) {
                OPENSSL_free(wb->buf); /* free jumbo buffer */
                wb->buf = NULL;
                break;
            }

            if (s->s3->alert_dispatch) {
                i = s->method->ssl_dispatch_alert(s);
                if (i <= 0) {
                    s->s3->wnum = tot;
                    return i;
                }
            }

            if (n >= 8 * max_send_fragment)
                nw = max_send_fragment * (mb_param.interleave = 8);
            else
                nw = max_send_fragment * (mb_param.interleave = 4);

            memcpy(aad, s->s3->write_sequence, 8);
            aad[8] = type;
            aad[9] = (unsigned char)(s->version >> 8);
            aad[10] = (unsigned char)(s->version);
            aad[11] = 0;
            aad[12] = 0;
            mb_param.out = NULL;
            mb_param.inp = aad;
            mb_param.len = nw;

            packlen = EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,
                                          EVP_CTRL_TLS1_1_MULTIBLOCK_AAD,
                                          sizeof(mb_param), &mb_param);

            if (packlen <= 0 || packlen > (int)wb->len) { /* never happens */
                OPENSSL_free(wb->buf); /* free jumbo buffer */
                wb->buf = NULL;
                break;
            }

            mb_param.out = wb->buf;
            mb_param.inp = &buf[tot];
            mb_param.len = nw;

            if (EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,
                                    EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT,
                                    sizeof(mb_param), &mb_param) <= 0)
                return -1;

            s->s3->write_sequence[7] += mb_param.interleave;
            if (s->s3->write_sequence[7] < mb_param.interleave) {
                int j = 6;
                while (j >= 0 && (++s->s3->write_sequence[j--]) == 0) ;
            }

            wb->offset = 0;
            wb->left = packlen;

            s->s3->wpend_tot = nw;
            s->s3->wpend_buf = &buf[tot];
            s->s3->wpend_type = type;
            s->s3->wpend_ret = nw;
 
             i = ssl3_write_pending(s, type, &buf[tot], nw);
             if (i <= 0) {
//flaw_line_below:
                if (i < 0) {
//fix_flaw_line_below:
//                if (i < 0 && (!s->wbio || !BIO_should_retry(s->wbio))) {
                     OPENSSL_free(wb->buf);
                     wb->buf = NULL;
                 }
                s->s3->wnum = tot;
                return i;
            }
            if (i == (int)n) {
                OPENSSL_free(wb->buf); /* free jumbo buffer */
                wb->buf = NULL;
                return tot + i;
            }
            n -= i;
            tot += i;
        }
    } else
#endif
    if (tot == len) {           /* done? */
        if (s->mode & SSL_MODE_RELEASE_BUFFERS && !SSL_IS_DTLS(s))
            ssl3_release_write_buffer(s);

        return tot;
    }

    n = (len - tot);
    for (;;) {
        if (n > s->max_send_fragment)
            nw = s->max_send_fragment;
        else
            nw = n;

        i = do_ssl3_write(s, type, &(buf[tot]), nw, 0);
        if (i <= 0) {
            /* XXX should we ssl3_release_write_buffer if i<0? */
            s->s3->wnum = tot;
            return i;
        }

        if ((i == (int)n) ||
            (type == SSL3_RT_APPLICATION_DATA &&
             (s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE))) {
            /*
             * next chunk of data should get another prepended empty fragment
             * in ciphersuites with known-IV weakness:
             */
            s->s3->empty_fragment_done = 0;

            if ((i == (int)n) && s->mode & SSL_MODE_RELEASE_BUFFERS &&
                !SSL_IS_DTLS(s))
                ssl3_release_write_buffer(s);

            return tot + i;
        }

        n -= i;
        tot += i;
    }
}
"
246,177982,,Remote,Not required,Partial,CVE-2015-0287,https://www.cvedetails.com/cve/CVE-2015-0287/,CWE-17,Low,,,,2015-03-19,5.0,"The ASN1_item_ex_d2i function in crypto/asn1/tasn_dec.c in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a does not reinitialize CHOICE and ADB data structures, which might allow attackers to cause a denial of service (invalid write operation and memory corruption) by leveraging an application that relies on ASN.1 structure reuse.",2017-11-14,DoS Mem. Corr.,21,https://git.openssl.org/?p=openssl.git;a=commit;h=b717b083073b6cacc0a5e2397b661678aff7ae7f,b717b083073b6cacc0a5e2397b661678aff7ae7f,,2,,,"int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
                     const ASN1_ITEM *it,
                     int tag, int aclass, char opt, ASN1_TLC *ctx)
{
    const ASN1_TEMPLATE *tt, *errtt = NULL;
    const ASN1_COMPAT_FUNCS *cf;
    const ASN1_EXTERN_FUNCS *ef;
    const ASN1_AUX *aux = it->funcs;
    ASN1_aux_cb *asn1_cb;
    const unsigned char *p = NULL, *q;
    unsigned char *wp = NULL;   /* BIG FAT WARNING! BREAKS CONST WHERE USED */
    unsigned char imphack = 0, oclass;
    char seq_eoc, seq_nolen, cst, isopt;
    long tmplen;
    int i;
    int otag;
    int ret = 0;
    ASN1_VALUE **pchptr, *ptmpval;
    if (!pval)
        return 0;
    if (aux && aux->asn1_cb)
        asn1_cb = aux->asn1_cb;
    else
        asn1_cb = 0;

    switch (it->itype) {
    case ASN1_ITYPE_PRIMITIVE:
        if (it->templates) {
            /*
             * tagging or OPTIONAL is currently illegal on an item template
             * because the flags can't get passed down. In practice this
             * isn't a problem: we include the relevant flags from the item
             * template in the template itself.
             */
            if ((tag != -1) || opt) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
                        ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
                goto err;
            }
            return asn1_template_ex_d2i(pval, in, len,
                                        it->templates, opt, ctx);
        }
        return asn1_d2i_ex_primitive(pval, in, len, it,
                                     tag, aclass, opt, ctx);
        break;

    case ASN1_ITYPE_MSTRING:
        p = *in;
        /* Just read in tag and class */
        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,
                              &p, len, -1, 0, 1, ctx);
        if (!ret) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        /* Must be UNIVERSAL class */
        if (oclass != V_ASN1_UNIVERSAL) {
            /* If OPTIONAL, assume this is OK */
            if (opt)
                return -1;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);
            goto err;
        }
        /* Check tag matches bit map */
        if (!(ASN1_tag2bit(otag) & it->utype)) {
            /* If OPTIONAL, assume this is OK */
            if (opt)
                return -1;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_WRONG_TAG);
            goto err;
        }
        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);

    case ASN1_ITYPE_EXTERN:
        /* Use new style d2i */
        ef = it->funcs;
        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);

    case ASN1_ITYPE_COMPAT:
        /* we must resort to old style evil hackery */
        cf = it->funcs;

        /* If OPTIONAL see if it is there */
        if (opt) {
            int exptag;
            p = *in;
            if (tag == -1)
                exptag = it->utype;
            else
                exptag = tag;
            /*
             * Don't care about anything other than presence of expected tag
             */

            ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,
                                  &p, len, exptag, aclass, 1, ctx);
            if (!ret) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                goto err;
            }
            if (ret == -1)
                return -1;
        }

        /*
         * This is the old style evil hack IMPLICIT handling: since the
         * underlying code is expecting a tag and class other than the one
         * present we change the buffer temporarily then change it back
         * afterwards. This doesn't and never did work for tags > 30. Yes
         * this is *horrible* but it is only needed for old style d2i which
         * will hopefully not be around for much longer. FIXME: should copy
         * the buffer then modify it so the input buffer can be const: we
         * should *always* copy because the old style d2i might modify the
         * buffer.
         */

        if (tag != -1) {
            wp = *(unsigned char **)in;
            imphack = *wp;
            if (p == NULL) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                goto err;
            }
            *wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)
                                  | it->utype);
        }

        ptmpval = cf->asn1_d2i(pval, in, len);

        if (tag != -1)
            *wp = imphack;

        if (ptmpval)
            return 1;

        ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
        goto err;

     case ASN1_ITYPE_CHOICE:
         if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
             goto auxerr;
        if (*pval) {
            /* Free up and zero CHOICE value if initialised */
            i = asn1_get_choice_selector(pval, it);
            if ((i >= 0) && (i < it->tcount)) {
                tt = it->templates + i;
                pchptr = asn1_get_field_ptr(pval, tt);
                ASN1_template_free(pchptr, tt);
                asn1_set_choice_selector(pval, -1, it);
            }
        } else if (!ASN1_item_ex_new(pval, it)) {
             ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         }
            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);
            /* If field not present, try the next one */
            if (ret == -1)
                continue;
            /* If positive return, read OK, break loop */
            if (ret > 0)
                break;
            /* Otherwise must be an ASN1 parsing error */
            errtt = tt;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        /* Did we fall off the end without reading anything? */
        if (i == it->tcount) {
            /* If OPTIONAL, this is OK */
            if (opt) {
                /* Free and zero it */
                ASN1_item_ex_free(pval, it);
                return -1;
            }
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);
            goto err;
        }

        asn1_set_choice_selector(pval, i, it);
        *in = p;
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
            goto auxerr;
        return 1;

    case ASN1_ITYPE_NDEF_SEQUENCE:
    case ASN1_ITYPE_SEQUENCE:
        p = *in;
        tmplen = len;

        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */
        if (tag == -1) {
            tag = V_ASN1_SEQUENCE;
            aclass = V_ASN1_UNIVERSAL;
        }
        /* Get SEQUENCE length and update len, p */
        ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,
                              &p, len, tag, aclass, opt, ctx);
        if (!ret) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        } else if (ret == -1)
            return -1;
        if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {
            len = tmplen - (p - *in);
            seq_nolen = 1;
        }
        /* If indefinite we don't do a length check */
        else
            seq_nolen = seq_eoc;
        if (!cst) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
            goto err;
        }

        if (!*pval && !ASN1_item_ex_new(pval, it)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
            goto auxerr;

        /* Get each field entry */
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            const ASN1_TEMPLATE *seqtt;
            ASN1_VALUE **pseqval;
         if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
             goto auxerr;
 
        /* Free up and zero any ADB found */
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            if (tt->flags & ASN1_TFLG_ADB_MASK) {
                const ASN1_TEMPLATE *seqtt;
                ASN1_VALUE **pseqval;
                seqtt = asn1_do_adb(pval, tt, 1);
                pseqval = asn1_get_field_ptr(pval, seqtt);
                ASN1_template_free(pseqval, seqtt);
            }
        }

         /* Get each field entry */
         for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
             const ASN1_TEMPLATE *seqtt;
            }
            /*
             * This determines the OPTIONAL flag value. The field cannot be
             * omitted if it is the last of a SEQUENCE and there is still
             * data to be read. This isn't strictly necessary but it
             * increases efficiency in some cases.
             */
            if (i == (it->tcount - 1))
                isopt = 0;
            else
                isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);
            /*
             * attempt to read in field, allowing each to be OPTIONAL
             */

            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);
            if (!ret) {
                errtt = seqtt;
                goto err;
            } else if (ret == -1) {
                /*
                 * OPTIONAL component absent. Free and zero the field.
                 */
                ASN1_template_free(pseqval, seqtt);
                continue;
            }
            /* Update length */
            len -= p - q;
        }

        /* Check for EOC if expecting one */
        if (seq_eoc && !asn1_check_eoc(&p, len)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);
            goto err;
        }
        /* Check all data read */
        if (!seq_nolen && len) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
            goto err;
        }

        /*
         * If we get here we've got no more data in the SEQUENCE, however we
         * may not have read all fields so check all remaining are OPTIONAL
         * and clear any that are.
         */
        for (; i < it->tcount; tt++, i++) {
            const ASN1_TEMPLATE *seqtt;
            seqtt = asn1_do_adb(pval, tt, 1);
            if (!seqtt)
                goto err;
            if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
                ASN1_VALUE **pseqval;
                pseqval = asn1_get_field_ptr(pval, seqtt);
                ASN1_template_free(pseqval, seqtt);
            } else {
                errtt = seqtt;
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_FIELD_MISSING);
                goto err;
            }
        }
        /* Save encoding */
        if (!asn1_enc_save(pval, *in, p - *in, it))
            goto auxerr;
        *in = p;
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
            goto auxerr;
        return 1;

    default:
        return 0;
    }
","int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
                     const ASN1_ITEM *it,
                     int tag, int aclass, char opt, ASN1_TLC *ctx)
{
    const ASN1_TEMPLATE *tt, *errtt = NULL;
    const ASN1_COMPAT_FUNCS *cf;
    const ASN1_EXTERN_FUNCS *ef;
    const ASN1_AUX *aux = it->funcs;
    ASN1_aux_cb *asn1_cb;
    const unsigned char *p = NULL, *q;
    unsigned char *wp = NULL;   /* BIG FAT WARNING! BREAKS CONST WHERE USED */
    unsigned char imphack = 0, oclass;
    char seq_eoc, seq_nolen, cst, isopt;
    long tmplen;
    int i;
    int otag;
    int ret = 0;
    ASN1_VALUE **pchptr, *ptmpval;
    if (!pval)
        return 0;
    if (aux && aux->asn1_cb)
        asn1_cb = aux->asn1_cb;
    else
        asn1_cb = 0;

    switch (it->itype) {
    case ASN1_ITYPE_PRIMITIVE:
        if (it->templates) {
            /*
             * tagging or OPTIONAL is currently illegal on an item template
             * because the flags can't get passed down. In practice this
             * isn't a problem: we include the relevant flags from the item
             * template in the template itself.
             */
            if ((tag != -1) || opt) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
                        ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
                goto err;
            }
            return asn1_template_ex_d2i(pval, in, len,
                                        it->templates, opt, ctx);
        }
        return asn1_d2i_ex_primitive(pval, in, len, it,
                                     tag, aclass, opt, ctx);
        break;

    case ASN1_ITYPE_MSTRING:
        p = *in;
        /* Just read in tag and class */
        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,
                              &p, len, -1, 0, 1, ctx);
        if (!ret) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        /* Must be UNIVERSAL class */
        if (oclass != V_ASN1_UNIVERSAL) {
            /* If OPTIONAL, assume this is OK */
            if (opt)
                return -1;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);
            goto err;
        }
        /* Check tag matches bit map */
        if (!(ASN1_tag2bit(otag) & it->utype)) {
            /* If OPTIONAL, assume this is OK */
            if (opt)
                return -1;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_WRONG_TAG);
            goto err;
        }
        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);

    case ASN1_ITYPE_EXTERN:
        /* Use new style d2i */
        ef = it->funcs;
        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);

    case ASN1_ITYPE_COMPAT:
        /* we must resort to old style evil hackery */
        cf = it->funcs;

        /* If OPTIONAL see if it is there */
        if (opt) {
            int exptag;
            p = *in;
            if (tag == -1)
                exptag = it->utype;
            else
                exptag = tag;
            /*
             * Don't care about anything other than presence of expected tag
             */

            ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,
                                  &p, len, exptag, aclass, 1, ctx);
            if (!ret) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                goto err;
            }
            if (ret == -1)
                return -1;
        }

        /*
         * This is the old style evil hack IMPLICIT handling: since the
         * underlying code is expecting a tag and class other than the one
         * present we change the buffer temporarily then change it back
         * afterwards. This doesn't and never did work for tags > 30. Yes
         * this is *horrible* but it is only needed for old style d2i which
         * will hopefully not be around for much longer. FIXME: should copy
         * the buffer then modify it so the input buffer can be const: we
         * should *always* copy because the old style d2i might modify the
         * buffer.
         */

        if (tag != -1) {
            wp = *(unsigned char **)in;
            imphack = *wp;
            if (p == NULL) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                goto err;
            }
            *wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)
                                  | it->utype);
        }

        ptmpval = cf->asn1_d2i(pval, in, len);

        if (tag != -1)
            *wp = imphack;

        if (ptmpval)
            return 1;

        ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
        goto err;

     case ASN1_ITYPE_CHOICE:
         if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
             goto auxerr;
        /* Allocate structure */
        if (!*pval && !ASN1_item_ex_new(pval, it)) {
             ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         }
            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);
            /* If field not present, try the next one */
            if (ret == -1)
                continue;
            /* If positive return, read OK, break loop */
            if (ret > 0)
                break;
            /* Otherwise must be an ASN1 parsing error */
            errtt = tt;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        /* Did we fall off the end without reading anything? */
        if (i == it->tcount) {
            /* If OPTIONAL, this is OK */
            if (opt) {
                /* Free and zero it */
                ASN1_item_ex_free(pval, it);
                return -1;
            }
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);
            goto err;
        }

        asn1_set_choice_selector(pval, i, it);
        *in = p;
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
            goto auxerr;
        return 1;

    case ASN1_ITYPE_NDEF_SEQUENCE:
    case ASN1_ITYPE_SEQUENCE:
        p = *in;
        tmplen = len;

        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */
        if (tag == -1) {
            tag = V_ASN1_SEQUENCE;
            aclass = V_ASN1_UNIVERSAL;
        }
        /* Get SEQUENCE length and update len, p */
        ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,
                              &p, len, tag, aclass, opt, ctx);
        if (!ret) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        } else if (ret == -1)
            return -1;
        if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {
            len = tmplen - (p - *in);
            seq_nolen = 1;
        }
        /* If indefinite we don't do a length check */
        else
            seq_nolen = seq_eoc;
        if (!cst) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
            goto err;
        }

        if (!*pval && !ASN1_item_ex_new(pval, it)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
            goto auxerr;

        /* Get each field entry */
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            const ASN1_TEMPLATE *seqtt;
            ASN1_VALUE **pseqval;
         if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
             goto auxerr;
 
         /* Get each field entry */
         for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
             const ASN1_TEMPLATE *seqtt;
            }
            /*
             * This determines the OPTIONAL flag value. The field cannot be
             * omitted if it is the last of a SEQUENCE and there is still
             * data to be read. This isn't strictly necessary but it
             * increases efficiency in some cases.
             */
            if (i == (it->tcount - 1))
                isopt = 0;
            else
                isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);
            /*
             * attempt to read in field, allowing each to be OPTIONAL
             */

            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);
            if (!ret) {
                errtt = seqtt;
                goto err;
            } else if (ret == -1) {
                /*
                 * OPTIONAL component absent. Free and zero the field.
                 */
                ASN1_template_free(pseqval, seqtt);
                continue;
            }
            /* Update length */
            len -= p - q;
        }

        /* Check for EOC if expecting one */
        if (seq_eoc && !asn1_check_eoc(&p, len)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);
            goto err;
        }
        /* Check all data read */
        if (!seq_nolen && len) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
            goto err;
        }

        /*
         * If we get here we've got no more data in the SEQUENCE, however we
         * may not have read all fields so check all remaining are OPTIONAL
         * and clear any that are.
         */
        for (; i < it->tcount; tt++, i++) {
            const ASN1_TEMPLATE *seqtt;
            seqtt = asn1_do_adb(pval, tt, 1);
            if (!seqtt)
                goto err;
            if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
                ASN1_VALUE **pseqval;
                pseqval = asn1_get_field_ptr(pval, seqtt);
                ASN1_template_free(pseqval, seqtt);
            } else {
                errtt = seqtt;
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_FIELD_MISSING);
                goto err;
            }
        }
        /* Save encoding */
        if (!asn1_enc_save(pval, *in, p - *in, it))
            goto auxerr;
        *in = p;
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
            goto auxerr;
        return 1;

    default:
        return 0;
    }
",C,"        if (*pval) {
            /* Free up and zero CHOICE value if initialised */
            i = asn1_get_choice_selector(pval, it);
            if ((i >= 0) && (i < it->tcount)) {
                tt = it->templates + i;
                pchptr = asn1_get_field_ptr(pval, tt);
                ASN1_template_free(pchptr, tt);
                asn1_set_choice_selector(pval, -1, it);
            }
        } else if (!ASN1_item_ex_new(pval, it)) {
        /* Free up and zero any ADB found */
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            if (tt->flags & ASN1_TFLG_ADB_MASK) {
                const ASN1_TEMPLATE *seqtt;
                ASN1_VALUE **pseqval;
                seqtt = asn1_do_adb(pval, tt, 1);
                pseqval = asn1_get_field_ptr(pval, seqtt);
                ASN1_template_free(pseqval, seqtt);
            }
        }

","        /* Allocate structure */
        if (!*pval && !ASN1_item_ex_new(pval, it)) {
",819418110b6fff4a7b96f01a5d68f71df3e3b736,"@@ -304,9 +304,16 @@ int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
     case ASN1_ITYPE_CHOICE:
         if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
             goto auxerr;
-
-        /* Allocate structure */
-        if (!*pval && !ASN1_item_ex_new(pval, it)) {
+        if (*pval) {
+            /* Free up and zero CHOICE value if initialised */
+            i = asn1_get_choice_selector(pval, it);
+            if ((i >= 0) && (i < it->tcount)) {
+                tt = it->templates + i;
+                pchptr = asn1_get_field_ptr(pval, tt);
+                ASN1_template_free(pchptr, tt);
+                asn1_set_choice_selector(pval, -1, it);
+            }
+        } else if (!ASN1_item_ex_new(pval, it)) {
             ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         }
@@ -386,6 +393,17 @@ int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
         if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
             goto auxerr;
 
+        /* Free up and zero any ADB found */
+        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
+            if (tt->flags & ASN1_TFLG_ADB_MASK) {
+                const ASN1_TEMPLATE *seqtt;
+                ASN1_VALUE **pseqval;
+                seqtt = asn1_do_adb(pval, tt, 1);
+                pseqval = asn1_get_field_ptr(pval, seqtt);
+                ASN1_template_free(pseqval, seqtt);
+            }
+        }
+
         /* Get each field entry */
         for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
             const ASN1_TEMPLATE *seqtt;",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/asn1/tasn_dec.c;h=7fd336a402268b3e32bea77d331bf66b2f061f2a;hb=7fd336a402268b3e32bea77d331bf66b2f061f2a,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/asn1/tasn_dec.c;h=4595664409c9b91118e0ac0dee35ddfc670edfe3;hb=4595664409c9b91118e0ac0dee35ddfc670edfe3,1,"int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
                     const ASN1_ITEM *it,
                     int tag, int aclass, char opt, ASN1_TLC *ctx)
{
    const ASN1_TEMPLATE *tt, *errtt = NULL;
    const ASN1_COMPAT_FUNCS *cf;
    const ASN1_EXTERN_FUNCS *ef;
    const ASN1_AUX *aux = it->funcs;
    ASN1_aux_cb *asn1_cb;
    const unsigned char *p = NULL, *q;
    unsigned char *wp = NULL;   /* BIG FAT WARNING! BREAKS CONST WHERE USED */
    unsigned char imphack = 0, oclass;
    char seq_eoc, seq_nolen, cst, isopt;
    long tmplen;
    int i;
    int otag;
    int ret = 0;
    ASN1_VALUE **pchptr, *ptmpval;
    if (!pval)
        return 0;
    if (aux && aux->asn1_cb)
        asn1_cb = aux->asn1_cb;
    else
        asn1_cb = 0;

    switch (it->itype) {
    case ASN1_ITYPE_PRIMITIVE:
        if (it->templates) {
            /*
             * tagging or OPTIONAL is currently illegal on an item template
             * because the flags can't get passed down. In practice this
             * isn't a problem: we include the relevant flags from the item
             * template in the template itself.
             */
            if ((tag != -1) || opt) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
                        ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
                goto err;
            }
            return asn1_template_ex_d2i(pval, in, len,
                                        it->templates, opt, ctx);
        }
        return asn1_d2i_ex_primitive(pval, in, len, it,
                                     tag, aclass, opt, ctx);
        break;

    case ASN1_ITYPE_MSTRING:
        p = *in;
        /* Just read in tag and class */
        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,
                              &p, len, -1, 0, 1, ctx);
        if (!ret) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        /* Must be UNIVERSAL class */
        if (oclass != V_ASN1_UNIVERSAL) {
            /* If OPTIONAL, assume this is OK */
            if (opt)
                return -1;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);
            goto err;
        }
        /* Check tag matches bit map */
        if (!(ASN1_tag2bit(otag) & it->utype)) {
            /* If OPTIONAL, assume this is OK */
            if (opt)
                return -1;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_WRONG_TAG);
            goto err;
        }
        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);

    case ASN1_ITYPE_EXTERN:
        /* Use new style d2i */
        ef = it->funcs;
        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);

    case ASN1_ITYPE_COMPAT:
        /* we must resort to old style evil hackery */
        cf = it->funcs;

        /* If OPTIONAL see if it is there */
        if (opt) {
            int exptag;
            p = *in;
            if (tag == -1)
                exptag = it->utype;
            else
                exptag = tag;
            /*
             * Don't care about anything other than presence of expected tag
             */

            ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,
                                  &p, len, exptag, aclass, 1, ctx);
            if (!ret) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                goto err;
            }
            if (ret == -1)
                return -1;
        }

        /*
         * This is the old style evil hack IMPLICIT handling: since the
         * underlying code is expecting a tag and class other than the one
         * present we change the buffer temporarily then change it back
         * afterwards. This doesn't and never did work for tags > 30. Yes
         * this is *horrible* but it is only needed for old style d2i which
         * will hopefully not be around for much longer. FIXME: should copy
         * the buffer then modify it so the input buffer can be const: we
         * should *always* copy because the old style d2i might modify the
         * buffer.
         */

        if (tag != -1) {
            wp = *(unsigned char **)in;
            imphack = *wp;
            if (p == NULL) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                goto err;
            }
            *wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)
                                  | it->utype);
        }

        ptmpval = cf->asn1_d2i(pval, in, len);

        if (tag != -1)
            *wp = imphack;

        if (ptmpval)
            return 1;

        ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
        goto err;

     case ASN1_ITYPE_CHOICE:
         if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
             goto auxerr;
//flaw_line_below:

//flaw_line_below:
        /* Allocate structure */
//flaw_line_below:
        if (!*pval && !ASN1_item_ex_new(pval, it)) {
//fix_flaw_line_below:
//        if (*pval) {
//fix_flaw_line_below:
//            /* Free up and zero CHOICE value if initialised */
//fix_flaw_line_below:
//            i = asn1_get_choice_selector(pval, it);
//fix_flaw_line_below:
//            if ((i >= 0) && (i < it->tcount)) {
//fix_flaw_line_below:
//                tt = it->templates + i;
//fix_flaw_line_below:
//                pchptr = asn1_get_field_ptr(pval, tt);
//fix_flaw_line_below:
//                ASN1_template_free(pchptr, tt);
//fix_flaw_line_below:
//                asn1_set_choice_selector(pval, -1, it);
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//        } else if (!ASN1_item_ex_new(pval, it)) {
             ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         }
            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);
            /* If field not present, try the next one */
            if (ret == -1)
                continue;
            /* If positive return, read OK, break loop */
            if (ret > 0)
                break;
            /* Otherwise must be an ASN1 parsing error */
            errtt = tt;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        /* Did we fall off the end without reading anything? */
        if (i == it->tcount) {
            /* If OPTIONAL, this is OK */
            if (opt) {
                /* Free and zero it */
                ASN1_item_ex_free(pval, it);
                return -1;
            }
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);
            goto err;
        }

        asn1_set_choice_selector(pval, i, it);
        *in = p;
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
            goto auxerr;
        return 1;

    case ASN1_ITYPE_NDEF_SEQUENCE:
    case ASN1_ITYPE_SEQUENCE:
        p = *in;
        tmplen = len;

        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */
        if (tag == -1) {
            tag = V_ASN1_SEQUENCE;
            aclass = V_ASN1_UNIVERSAL;
        }
        /* Get SEQUENCE length and update len, p */
        ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,
                              &p, len, tag, aclass, opt, ctx);
        if (!ret) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        } else if (ret == -1)
            return -1;
        if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {
            len = tmplen - (p - *in);
            seq_nolen = 1;
        }
        /* If indefinite we don't do a length check */
        else
            seq_nolen = seq_eoc;
        if (!cst) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
            goto err;
        }

        if (!*pval && !ASN1_item_ex_new(pval, it)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
            goto auxerr;

        /* Get each field entry */
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            const ASN1_TEMPLATE *seqtt;
            ASN1_VALUE **pseqval;
         if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
             goto auxerr;
 
//fix_flaw_line_below:
//        /* Free up and zero any ADB found */
//fix_flaw_line_below:
//        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
//fix_flaw_line_below:
//            if (tt->flags & ASN1_TFLG_ADB_MASK) {
//fix_flaw_line_below:
//                const ASN1_TEMPLATE *seqtt;
//fix_flaw_line_below:
//                ASN1_VALUE **pseqval;
//fix_flaw_line_below:
//                seqtt = asn1_do_adb(pval, tt, 1);
//fix_flaw_line_below:
//                pseqval = asn1_get_field_ptr(pval, seqtt);
//fix_flaw_line_below:
//                ASN1_template_free(pseqval, seqtt);
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//
         /* Get each field entry */
         for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
             const ASN1_TEMPLATE *seqtt;
            }
            /*
             * This determines the OPTIONAL flag value. The field cannot be
             * omitted if it is the last of a SEQUENCE and there is still
             * data to be read. This isn't strictly necessary but it
             * increases efficiency in some cases.
             */
            if (i == (it->tcount - 1))
                isopt = 0;
            else
                isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);
            /*
             * attempt to read in field, allowing each to be OPTIONAL
             */

            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);
            if (!ret) {
                errtt = seqtt;
                goto err;
            } else if (ret == -1) {
                /*
                 * OPTIONAL component absent. Free and zero the field.
                 */
                ASN1_template_free(pseqval, seqtt);
                continue;
            }
            /* Update length */
            len -= p - q;
        }

        /* Check for EOC if expecting one */
        if (seq_eoc && !asn1_check_eoc(&p, len)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);
            goto err;
        }
        /* Check all data read */
        if (!seq_nolen && len) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
            goto err;
        }

        /*
         * If we get here we've got no more data in the SEQUENCE, however we
         * may not have read all fields so check all remaining are OPTIONAL
         * and clear any that are.
         */
        for (; i < it->tcount; tt++, i++) {
            const ASN1_TEMPLATE *seqtt;
            seqtt = asn1_do_adb(pval, tt, 1);
            if (!seqtt)
                goto err;
            if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
                ASN1_VALUE **pseqval;
                pseqval = asn1_get_field_ptr(pval, seqtt);
                ASN1_template_free(pseqval, seqtt);
            } else {
                errtt = seqtt;
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_FIELD_MISSING);
                goto err;
            }
        }
        /* Save encoding */
        if (!asn1_enc_save(pval, *in, p - *in, it))
            goto auxerr;
        *in = p;
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
            goto auxerr;
        return 1;

    default:
        return 0;
    }
"
247,177983,,Remote,Not required,Partial,CVE-2015-0286,https://www.cvedetails.com/cve/CVE-2015-0286/,CWE-17,Low,,,,2015-03-19,5.0,"The ASN1_TYPE_cmp function in crypto/asn1/a_type.c in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a does not properly perform boolean-type comparisons, which allows remote attackers to cause a denial of service (invalid read operation and application crash) via a crafted X.509 certificate to an endpoint that uses the certificate-verification feature.",2018-01-04,DoS,3,https://git.openssl.org/?p=openssl.git;a=commit;h=c3c7fb07dc975dc3c9de0eddb7d8fd79fc9c67c1,c3c7fb07dc975dc3c9de0eddb7d8fd79fc9c67c1,,0,,,"int ASN1_TYPE_cmp(const ASN1_TYPE *a, const ASN1_TYPE *b)
{
    int result = -1;

    if (!a || !b || a->type != b->type)
        return -1;

    switch (a->type) {
     case V_ASN1_OBJECT:
         result = OBJ_cmp(a->value.object, b->value.object);
         break;
    case V_ASN1_BOOLEAN:
        result = a->value.boolean - b->value.boolean;
        break;
     case V_ASN1_NULL:
         result = 0;             /* They do not have content. */
         break;
    case V_ASN1_NEG_ENUMERATED:
    case V_ASN1_BIT_STRING:
    case V_ASN1_OCTET_STRING:
    case V_ASN1_SEQUENCE:
    case V_ASN1_SET:
    case V_ASN1_NUMERICSTRING:
    case V_ASN1_PRINTABLESTRING:
    case V_ASN1_T61STRING:
    case V_ASN1_VIDEOTEXSTRING:
    case V_ASN1_IA5STRING:
    case V_ASN1_UTCTIME:
    case V_ASN1_GENERALIZEDTIME:
    case V_ASN1_GRAPHICSTRING:
    case V_ASN1_VISIBLESTRING:
    case V_ASN1_GENERALSTRING:
    case V_ASN1_UNIVERSALSTRING:
    case V_ASN1_BMPSTRING:
    case V_ASN1_UTF8STRING:
    case V_ASN1_OTHER:
    default:
        result = ASN1_STRING_cmp((ASN1_STRING *)a->value.ptr,
                                 (ASN1_STRING *)b->value.ptr);
        break;
    }

    return result;
}
","int ASN1_TYPE_cmp(const ASN1_TYPE *a, const ASN1_TYPE *b)
{
    int result = -1;

    if (!a || !b || a->type != b->type)
        return -1;

    switch (a->type) {
     case V_ASN1_OBJECT:
         result = OBJ_cmp(a->value.object, b->value.object);
         break;
     case V_ASN1_NULL:
         result = 0;             /* They do not have content. */
         break;
    case V_ASN1_NEG_ENUMERATED:
    case V_ASN1_BIT_STRING:
    case V_ASN1_OCTET_STRING:
    case V_ASN1_SEQUENCE:
    case V_ASN1_SET:
    case V_ASN1_NUMERICSTRING:
    case V_ASN1_PRINTABLESTRING:
    case V_ASN1_T61STRING:
    case V_ASN1_VIDEOTEXSTRING:
    case V_ASN1_IA5STRING:
    case V_ASN1_UTCTIME:
    case V_ASN1_GENERALIZEDTIME:
    case V_ASN1_GRAPHICSTRING:
    case V_ASN1_VISIBLESTRING:
    case V_ASN1_GENERALSTRING:
    case V_ASN1_UNIVERSALSTRING:
    case V_ASN1_BMPSTRING:
    case V_ASN1_UTF8STRING:
    case V_ASN1_OTHER:
    default:
        result = ASN1_STRING_cmp((ASN1_STRING *)a->value.ptr,
                                 (ASN1_STRING *)b->value.ptr);
        break;
    }

    return result;
}
",C,"    case V_ASN1_BOOLEAN:
        result = a->value.boolean - b->value.boolean;
        break;
",,b19d8143212ae5fbc9cebfd51c01f802fabccd33,"@@ -119,6 +119,9 @@ int ASN1_TYPE_cmp(const ASN1_TYPE *a, const ASN1_TYPE *b)
     case V_ASN1_OBJECT:
         result = OBJ_cmp(a->value.object, b->value.object);
         break;
+    case V_ASN1_BOOLEAN:
+        result = a->value.boolean - b->value.boolean;
+        break;
     case V_ASN1_NULL:
         result = 0;             /* They do not have content. */
         break;",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/asn1/a_type.c;h=af795306b5bf58da19fbd53328992eee8baee44a;hb=af795306b5bf58da19fbd53328992eee8baee44a,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/asn1/a_type.c;h=4a36aff6acc099e7dd18abdf3297bce35588f307;hb=4a36aff6acc099e7dd18abdf3297bce35588f307,1,"int ASN1_TYPE_cmp(const ASN1_TYPE *a, const ASN1_TYPE *b)
{
    int result = -1;

    if (!a || !b || a->type != b->type)
        return -1;

    switch (a->type) {
     case V_ASN1_OBJECT:
         result = OBJ_cmp(a->value.object, b->value.object);
         break;
//fix_flaw_line_below:
//    case V_ASN1_BOOLEAN:
//fix_flaw_line_below:
//        result = a->value.boolean - b->value.boolean;
//fix_flaw_line_below:
//        break;
     case V_ASN1_NULL:
         result = 0;             /* They do not have content. */
         break;
    case V_ASN1_NEG_ENUMERATED:
    case V_ASN1_BIT_STRING:
    case V_ASN1_OCTET_STRING:
    case V_ASN1_SEQUENCE:
    case V_ASN1_SET:
    case V_ASN1_NUMERICSTRING:
    case V_ASN1_PRINTABLESTRING:
    case V_ASN1_T61STRING:
    case V_ASN1_VIDEOTEXSTRING:
    case V_ASN1_IA5STRING:
    case V_ASN1_UTCTIME:
    case V_ASN1_GENERALIZEDTIME:
    case V_ASN1_GRAPHICSTRING:
    case V_ASN1_VISIBLESTRING:
    case V_ASN1_GENERALSTRING:
    case V_ASN1_UNIVERSALSTRING:
    case V_ASN1_BMPSTRING:
    case V_ASN1_UTF8STRING:
    case V_ASN1_OTHER:
    default:
        result = ASN1_STRING_cmp((ASN1_STRING *)a->value.ptr,
                                 (ASN1_STRING *)b->value.ptr);
        break;
    }

    return result;
}
"
318,178054,,Remote,Not required,Partial,CVE-2014-9426,https://www.cvedetails.com/cve/CVE-2014-9426/,CWE-17,Low,Partial,Partial,,2014-12-30,7.5,"** DISPUTED ** The apprentice_load function in libmagic/apprentice.c in the Fileinfo component in PHP through 5.6.4 attempts to perform a free operation on a stack-based character array, which allows remote attackers to cause a denial of service (memory corruption or application crash) or possibly have unspecified other impact via unknown vectors.  NOTE: this is disputed by the vendor because the standard erealloc behavior makes the free operation unreachable.",2015-03-16,DoS Mem. Corr.,0,https://git.php.net/?p=php-src.git;a=commit;h=a72cd07f2983dc43a6bb35209dc4687852e53c09,a72cd07f2983dc43a6bb35209dc4687852e53c09,,1,,,"apprentice_load(struct magic_set *ms, const char *fn, int action)
{
	int errs = 0;
	uint32_t i, j;
	size_t files = 0, maxfiles = 0;
	char **filearr = NULL;
	struct stat st;
	struct magic_map *map;
	struct magic_entry_set mset[MAGIC_SETS];
	php_stream *dir;
	php_stream_dirent d;
 
	TSRMLS_FETCH();

	memset(mset, 0, sizeof(mset));
	ms->flags |= MAGIC_CHECK;	/* Enable checks for parsed files */


	if ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL)
	{
		file_oomem(ms, sizeof(*map));
		return NULL;
	}

	/* print silly verbose header for USG compat. */
	if (action == FILE_CHECK)
		(void)fprintf(stderr, ""%s\n"", usg_hdr);

	/* load directory or file */
	/* FIXME: Read file names and sort them to prevent
	   non-determinism. See Debian bug #488562. */
	if (php_sys_stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {
		int mflen;
		char mfn[MAXPATHLEN];

		dir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL);
		if (!dir) {
			errs++;
			goto out;
		}
		while (php_stream_readdir(dir, &d)) {
			if ((mflen = snprintf(mfn, sizeof(mfn), ""%s/%s"", fn, d.d_name)) < 0) {
				file_oomem(ms,
				strlen(fn) + strlen(d.d_name) + 2);
				errs++;
				php_stream_closedir(dir);
				goto out;
			}
			if (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) {
				continue;
			}
			if (files >= maxfiles) {
				size_t mlen;
				maxfiles = (maxfiles + 1) * 2;
				mlen = maxfiles * sizeof(*filearr);
                                if ((filearr = CAST(char **,
                                    erealloc(filearr, mlen))) == NULL) {
                                        file_oomem(ms, mlen);
                                        php_stream_closedir(dir);
                                        errs++;
                                        goto out;
					goto out;
				}
			}
			filearr[files++] = estrndup(mfn, (mflen > sizeof(mfn) - 1)? sizeof(mfn) - 1: mflen);
		}
		php_stream_closedir(dir);
		qsort(filearr, files, sizeof(*filearr), cmpstrp);
		for (i = 0; i < files; i++) {
			load_1(ms, action, filearr[i], &errs, mset);
			efree(filearr[i]);
		}
		efree(filearr);
	} else
		load_1(ms, action, fn, &errs, mset);
	if (errs)
		goto out;

	for (j = 0; j < MAGIC_SETS; j++) {
		/* Set types of tests */
		for (i = 0; i < mset[j].count; ) {
			if (mset[j].me[i].mp->cont_level != 0) {
				i++;
				continue;
			}
			i = set_text_binary(ms, mset[j].me, mset[j].count, i);
		}
		qsort(mset[j].me, mset[j].count, sizeof(*mset[j].me),
		    apprentice_sort);

		/*
		 * Make sure that any level 0 ""default"" line is last
		 * (if one exists).
		 */
		set_last_default(ms, mset[j].me, mset[j].count);

		/* coalesce per file arrays into a single one */
		if (coalesce_entries(ms, mset[j].me, mset[j].count,
		    &map->magic[j], &map->nmagic[j]) == -1) {
			errs++;
			goto out;
		}
	}

out:
	for (j = 0; j < MAGIC_SETS; j++)
		magic_entry_free(mset[j].me, mset[j].count);

	if (errs) {
		for (j = 0; j < MAGIC_SETS; j++) {
			if (map->magic[j])
				efree(map->magic[j]);
		}
		efree(map);
		return NULL;
	}
	return map;
}
","apprentice_load(struct magic_set *ms, const char *fn, int action)
{
	int errs = 0;
	uint32_t i, j;
	size_t files = 0, maxfiles = 0;
	char **filearr = NULL;
	struct stat st;
	struct magic_map *map;
	struct magic_entry_set mset[MAGIC_SETS];
	php_stream *dir;
	php_stream_dirent d;
 
	TSRMLS_FETCH();

	memset(mset, 0, sizeof(mset));
	ms->flags |= MAGIC_CHECK;	/* Enable checks for parsed files */


	if ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL)
	{
		file_oomem(ms, sizeof(*map));
		return NULL;
	}

	/* print silly verbose header for USG compat. */
	if (action == FILE_CHECK)
		(void)fprintf(stderr, ""%s\n"", usg_hdr);

	/* load directory or file */
	/* FIXME: Read file names and sort them to prevent
	   non-determinism. See Debian bug #488562. */
	if (php_sys_stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {
		int mflen;
		char mfn[MAXPATHLEN];

		dir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL);
		if (!dir) {
			errs++;
			goto out;
		}
		while (php_stream_readdir(dir, &d)) {
			if ((mflen = snprintf(mfn, sizeof(mfn), ""%s/%s"", fn, d.d_name)) < 0) {
				file_oomem(ms,
				strlen(fn) + strlen(d.d_name) + 2);
				errs++;
				php_stream_closedir(dir);
				goto out;
			}
			if (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) {
				continue;
			}
			if (files >= maxfiles) {
				size_t mlen;
				maxfiles = (maxfiles + 1) * 2;
				mlen = maxfiles * sizeof(*filearr);
                                if ((filearr = CAST(char **,
                                    erealloc(filearr, mlen))) == NULL) {
                                        file_oomem(ms, mlen);
                                       efree(mfn);
                                        php_stream_closedir(dir);
                                        errs++;
                                        goto out;
					goto out;
				}
			}
			filearr[files++] = estrndup(mfn, (mflen > sizeof(mfn) - 1)? sizeof(mfn) - 1: mflen);
		}
		php_stream_closedir(dir);
		qsort(filearr, files, sizeof(*filearr), cmpstrp);
		for (i = 0; i < files; i++) {
			load_1(ms, action, filearr[i], &errs, mset);
			efree(filearr[i]);
		}
		efree(filearr);
	} else
		load_1(ms, action, fn, &errs, mset);
	if (errs)
		goto out;

	for (j = 0; j < MAGIC_SETS; j++) {
		/* Set types of tests */
		for (i = 0; i < mset[j].count; ) {
			if (mset[j].me[i].mp->cont_level != 0) {
				i++;
				continue;
			}
			i = set_text_binary(ms, mset[j].me, mset[j].count, i);
		}
		qsort(mset[j].me, mset[j].count, sizeof(*mset[j].me),
		    apprentice_sort);

		/*
		 * Make sure that any level 0 ""default"" line is last
		 * (if one exists).
		 */
		set_last_default(ms, mset[j].me, mset[j].count);

		/* coalesce per file arrays into a single one */
		if (coalesce_entries(ms, mset[j].me, mset[j].count,
		    &map->magic[j], &map->nmagic[j]) == -1) {
			errs++;
			goto out;
		}
	}

out:
	for (j = 0; j < MAGIC_SETS; j++)
		magic_entry_free(mset[j].me, mset[j].count);

	if (errs) {
		for (j = 0; j < MAGIC_SETS; j++) {
			if (map->magic[j])
				efree(map->magic[j]);
		}
		efree(map);
		return NULL;
	}
	return map;
}
",C,,"                                       efree(mfn);
",83e55478279f8bb366e5f5a482619c5e47731980,"@@ -1197,7 +1197,6 @@ apprentice_load(struct magic_set *ms, const char *fn, int action)
                                if ((filearr = CAST(char **,
                                    erealloc(filearr, mlen))) == NULL) {
                                        file_oomem(ms, mlen);
-                                       efree(mfn);
                                        php_stream_closedir(dir);
                                        errs++;
                                        goto out;",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/fileinfo/libmagic/apprentice.c;h=e7d0a619c6ac73ff60e96b0ee62eead85cd8fab2;hb=a72cd07f2983dc43a6bb35209dc4687852e53c09,https://git.php.net/?p=php-src.git;a=blob;f=ext/fileinfo/libmagic/apprentice.c;h=543bce50885ecdfb9a976f18277e79ee250a2f23,1,"apprentice_load(struct magic_set *ms, const char *fn, int action)
{
	int errs = 0;
	uint32_t i, j;
	size_t files = 0, maxfiles = 0;
	char **filearr = NULL;
	struct stat st;
	struct magic_map *map;
	struct magic_entry_set mset[MAGIC_SETS];
	php_stream *dir;
	php_stream_dirent d;
 
	TSRMLS_FETCH();

	memset(mset, 0, sizeof(mset));
	ms->flags |= MAGIC_CHECK;	/* Enable checks for parsed files */


	if ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL)
	{
		file_oomem(ms, sizeof(*map));
		return NULL;
	}

	/* print silly verbose header for USG compat. */
	if (action == FILE_CHECK)
		(void)fprintf(stderr, ""%s\n"", usg_hdr);

	/* load directory or file */
	/* FIXME: Read file names and sort them to prevent
	   non-determinism. See Debian bug #488562. */
	if (php_sys_stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {
		int mflen;
		char mfn[MAXPATHLEN];

		dir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL);
		if (!dir) {
			errs++;
			goto out;
		}
		while (php_stream_readdir(dir, &d)) {
			if ((mflen = snprintf(mfn, sizeof(mfn), ""%s/%s"", fn, d.d_name)) < 0) {
				file_oomem(ms,
				strlen(fn) + strlen(d.d_name) + 2);
				errs++;
				php_stream_closedir(dir);
				goto out;
			}
			if (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) {
				continue;
			}
			if (files >= maxfiles) {
				size_t mlen;
				maxfiles = (maxfiles + 1) * 2;
				mlen = maxfiles * sizeof(*filearr);
                                if ((filearr = CAST(char **,
                                    erealloc(filearr, mlen))) == NULL) {
                                        file_oomem(ms, mlen);
//flaw_line_below:
                                       efree(mfn);
                                        php_stream_closedir(dir);
                                        errs++;
                                        goto out;
					goto out;
				}
			}
			filearr[files++] = estrndup(mfn, (mflen > sizeof(mfn) - 1)? sizeof(mfn) - 1: mflen);
		}
		php_stream_closedir(dir);
		qsort(filearr, files, sizeof(*filearr), cmpstrp);
		for (i = 0; i < files; i++) {
			load_1(ms, action, filearr[i], &errs, mset);
			efree(filearr[i]);
		}
		efree(filearr);
	} else
		load_1(ms, action, fn, &errs, mset);
	if (errs)
		goto out;

	for (j = 0; j < MAGIC_SETS; j++) {
		/* Set types of tests */
		for (i = 0; i < mset[j].count; ) {
			if (mset[j].me[i].mp->cont_level != 0) {
				i++;
				continue;
			}
			i = set_text_binary(ms, mset[j].me, mset[j].count, i);
		}
		qsort(mset[j].me, mset[j].count, sizeof(*mset[j].me),
		    apprentice_sort);

		/*
		 * Make sure that any level 0 ""default"" line is last
		 * (if one exists).
		 */
		set_last_default(ms, mset[j].me, mset[j].count);

		/* coalesce per file arrays into a single one */
		if (coalesce_entries(ms, mset[j].me, mset[j].count,
		    &map->magic[j], &map->nmagic[j]) == -1) {
			errs++;
			goto out;
		}
	}

out:
	for (j = 0; j < MAGIC_SETS; j++)
		magic_entry_free(mset[j].me, mset[j].count);

	if (errs) {
		for (j = 0; j < MAGIC_SETS; j++) {
			if (map->magic[j])
				efree(map->magic[j]);
		}
		efree(map);
		return NULL;
	}
	return map;
}
"
2047,179783,,Local,Not required,Complete,CVE-2015-4700,https://www.cvedetails.com/cve/CVE-2015-4700/,CWE-17,Low,,,,2015-08-31,4.9,The bpf_int_jit_compile function in arch/x86/net/bpf_jit_comp.c in the Linux kernel before 4.0.6 allows local users to cause a denial of service (system crash) by creating a packet filter and then loading crafted BPF instructions that trigger late convergence by the JIT compiler.,2019-04-08,DoS ,6,https://github.com/torvalds/linux/commit/3f7352bf21f8fd7ba3e2fcef9488756f188e12be,3f7352bf21f8fd7ba3e2fcef9488756f188e12be,"x86: bpf_jit: fix compilation of large bpf programs

x86 has variable length encoding. x86 JIT compiler is trying
to pick the shortest encoding for given bpf instruction.
While doing so the jump targets are changing, so JIT is doing
multiple passes over the program. Typical program needs 3 passes.
Some very short programs converge with 2 passes. Large programs
may need 4 or 5. But specially crafted bpf programs may hit the
pass limit and if the program converges on the last iteration
the JIT compiler will be producing an image full of 'int 3' insns.
Fix this corner case by doing final iteration over bpf program.

Fixes: 0a14842f5a3c (""net: filter: Just In Time compiler for x86-64"")
Reported-by: Daniel Borkmann <daniel@iogearbox.net>
Signed-off-by: Alexei Starovoitov <ast@plumgrid.com>
Tested-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Daniel Borkmann <daniel@iogearbox.net>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,arch/x86/net/bpf_jit_comp.c,"{""sha"": ""ddeff4844a100de83b52ef9dae9f42974666dc23"", ""filename"": ""arch/x86/net/bpf_jit_comp.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/3f7352bf21f8fd7ba3e2fcef9488756f188e12be/arch/x86/net/bpf_jit_comp.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3f7352bf21f8fd7ba3e2fcef9488756f188e12be/arch/x86/net/bpf_jit_comp.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/net/bpf_jit_comp.c?ref=3f7352bf21f8fd7ba3e2fcef9488756f188e12be"", ""patch"": ""@@ -966,7 +966,12 @@ void bpf_int_jit_compile(struct bpf_prog *prog)\n \t}\n \tctx.cleanup_addr = proglen;\n \n-\tfor (pass = 0; pass < 10; pass++) {\n+\t/* JITed image shrinks with every pass and the loop iterates\n+\t * until the image stops shrinking. Very large bpf programs\n+\t * may converge on the last pass. In such case do one more\n+\t * pass to emit the final image\n+\t */\n+\tfor (pass = 0; pass < 10 || image; pass++) {\n \t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);\n \t\tif (proglen <= 0) {\n \t\t\timage = NULL;""}","void bpf_int_jit_compile(struct bpf_prog *prog)
{
	struct bpf_binary_header *header = NULL;
	int proglen, oldproglen = 0;
	struct jit_context ctx = {};
	u8 *image = NULL;
	int *addrs;
	int pass;
	int i;

	if (!bpf_jit_enable)
		return;

	if (!prog || !prog->len)
		return;

	addrs = kmalloc(prog->len * sizeof(*addrs), GFP_KERNEL);
	if (!addrs)
		return;

	/* Before first pass, make a rough estimation of addrs[]
	 * each bpf instruction is translated to less than 64 bytes
	 */
	for (proglen = 0, i = 0; i < prog->len; i++) {
		proglen += 64;
		addrs[i] = proglen;
 	}
 	ctx.cleanup_addr = proglen;
 
	/* JITed image shrinks with every pass and the loop iterates
	 * until the image stops shrinking. Very large bpf programs
	 * may converge on the last pass. In such case do one more
	 * pass to emit the final image
	 */
	for (pass = 0; pass < 10 || image; pass++) {
 		proglen = do_jit(prog, addrs, image, oldproglen, &ctx);
 		if (proglen <= 0) {
 			image = NULL;
			if (header)
				bpf_jit_binary_free(header);
			goto out;
		}
		if (image) {
			if (proglen != oldproglen) {
				pr_err(""bpf_jit: proglen=%d != oldproglen=%d\n"",
				       proglen, oldproglen);
				goto out;
			}
			break;
		}
		if (proglen == oldproglen) {
			header = bpf_jit_binary_alloc(proglen, &image,
						      1, jit_fill_hole);
			if (!header)
				goto out;
		}
		oldproglen = proglen;
	}

	if (bpf_jit_enable > 1)
		bpf_jit_dump(prog->len, proglen, 0, image);

	if (image) {
		bpf_flush_icache(header, image + proglen);
		set_memory_ro((unsigned long)header, header->pages);
		prog->bpf_func = (void *)image;
		prog->jited = true;
	}
out:
	kfree(addrs);
}
","void bpf_int_jit_compile(struct bpf_prog *prog)
{
	struct bpf_binary_header *header = NULL;
	int proglen, oldproglen = 0;
	struct jit_context ctx = {};
	u8 *image = NULL;
	int *addrs;
	int pass;
	int i;

	if (!bpf_jit_enable)
		return;

	if (!prog || !prog->len)
		return;

	addrs = kmalloc(prog->len * sizeof(*addrs), GFP_KERNEL);
	if (!addrs)
		return;

	/* Before first pass, make a rough estimation of addrs[]
	 * each bpf instruction is translated to less than 64 bytes
	 */
	for (proglen = 0, i = 0; i < prog->len; i++) {
		proglen += 64;
		addrs[i] = proglen;
 	}
 	ctx.cleanup_addr = proglen;
 
	for (pass = 0; pass < 10; pass++) {
 		proglen = do_jit(prog, addrs, image, oldproglen, &ctx);
 		if (proglen <= 0) {
 			image = NULL;
			if (header)
				bpf_jit_binary_free(header);
			goto out;
		}
		if (image) {
			if (proglen != oldproglen) {
				pr_err(""bpf_jit: proglen=%d != oldproglen=%d\n"",
				       proglen, oldproglen);
				goto out;
			}
			break;
		}
		if (proglen == oldproglen) {
			header = bpf_jit_binary_alloc(proglen, &image,
						      1, jit_fill_hole);
			if (!header)
				goto out;
		}
		oldproglen = proglen;
	}

	if (bpf_jit_enable > 1)
		bpf_jit_dump(prog->len, proglen, 0, image);

	if (image) {
		bpf_flush_icache(header, image + proglen);
		set_memory_ro((unsigned long)header, header->pages);
		prog->bpf_func = (void *)image;
		prog->jited = true;
	}
out:
	kfree(addrs);
}
",C,"	/* JITed image shrinks with every pass and the loop iterates
	 * until the image stops shrinking. Very large bpf programs
	 * may converge on the last pass. In such case do one more
	 * pass to emit the final image
	 */
	for (pass = 0; pass < 10 || image; pass++) {
","	for (pass = 0; pass < 10; pass++) {
",,"@@ -966,7 +966,12 @@ void bpf_int_jit_compile(struct bpf_prog *prog)
 	}
 	ctx.cleanup_addr = proglen;
 
-	for (pass = 0; pass < 10; pass++) {
+	/* JITed image shrinks with every pass and the loop iterates
+	 * until the image stops shrinking. Very large bpf programs
+	 * may converge on the last pass. In such case do one more
+	 * pass to emit the final image
+	 */
+	for (pass = 0; pass < 10 || image; pass++) {
 		proglen = do_jit(prog, addrs, image, oldproglen, &ctx);
 		if (proglen <= 0) {
 			image = NULL;",linux,3f7352bf21f8fd7ba3e2fcef9488756f188e12be,cc4a84c3da6f9dd6a297dc81fe4437643a60fe03,1,"void bpf_int_jit_compile(struct bpf_prog *prog)
{
	struct bpf_binary_header *header = NULL;
	int proglen, oldproglen = 0;
	struct jit_context ctx = {};
	u8 *image = NULL;
	int *addrs;
	int pass;
	int i;

	if (!bpf_jit_enable)
		return;

	if (!prog || !prog->len)
		return;

	addrs = kmalloc(prog->len * sizeof(*addrs), GFP_KERNEL);
	if (!addrs)
		return;

	/* Before first pass, make a rough estimation of addrs[]
	 * each bpf instruction is translated to less than 64 bytes
	 */
	for (proglen = 0, i = 0; i < prog->len; i++) {
		proglen += 64;
		addrs[i] = proglen;
 	}
 	ctx.cleanup_addr = proglen;
 
//flaw_line_below:
	for (pass = 0; pass < 10; pass++) {
//fix_flaw_line_below:
//	/* JITed image shrinks with every pass and the loop iterates
//fix_flaw_line_below:
//	 * until the image stops shrinking. Very large bpf programs
//fix_flaw_line_below:
//	 * may converge on the last pass. In such case do one more
//fix_flaw_line_below:
//	 * pass to emit the final image
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	for (pass = 0; pass < 10 || image; pass++) {
 		proglen = do_jit(prog, addrs, image, oldproglen, &ctx);
 		if (proglen <= 0) {
 			image = NULL;
			if (header)
				bpf_jit_binary_free(header);
			goto out;
		}
		if (image) {
			if (proglen != oldproglen) {
				pr_err(""bpf_jit: proglen=%d != oldproglen=%d\n"",
				       proglen, oldproglen);
				goto out;
			}
			break;
		}
		if (proglen == oldproglen) {
			header = bpf_jit_binary_alloc(proglen, &image,
						      1, jit_fill_hole);
			if (!header)
				goto out;
		}
		oldproglen = proglen;
	}

	if (bpf_jit_enable > 1)
		bpf_jit_dump(prog->len, proglen, 0, image);

	if (image) {
		bpf_flush_icache(header, image + proglen);
		set_memory_ro((unsigned long)header, header->pages);
		prog->bpf_func = (void *)image;
		prog->jited = true;
	}
out:
	kfree(addrs);
}
"
2049,179785,,Remote,Not required,Complete,CVE-2015-4335,https://www.cvedetails.com/cve/CVE-2015-4335/,CWE-17,Low,Complete,Complete,,2015-06-09,10.0,Redis before 2.8.21 and 3.x before 3.0.2 allows remote attackers to execute arbitrary Lua bytecode via the eval command.,2018-08-13,Exec Code ,1,https://github.com/antirez/redis/commit/fdf9d455098f54f7666c702ae464e6ea21e25411,fdf9d455098f54f7666c702ae464e6ea21e25411,disable loading lua bytecode,1,deps/lua/src/ldo.c,"{""sha"": ""514f7a2a31f6b9dadbefb7f7983e7a395c4d0643"", ""filename"": ""deps/lua/src/ldo.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/antirez/redis/blob/fdf9d455098f54f7666c702ae464e6ea21e25411/deps/lua/src/ldo.c"", ""raw_url"": ""https://github.com/antirez/redis/raw/fdf9d455098f54f7666c702ae464e6ea21e25411/deps/lua/src/ldo.c"", ""contents_url"": ""https://api.github.com/repos/antirez/redis/contents/deps/lua/src/ldo.c?ref=fdf9d455098f54f7666c702ae464e6ea21e25411"", ""patch"": ""@@ -495,7 +495,7 @@ static void f_parser (lua_State *L, void *ud) {\n   struct SParser *p = cast(struct SParser *, ud);\n   int c = luaZ_lookahead(p->z);\n   luaC_checkGC(L);\n-  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z,\n+  tf = (luaY_parser)(L, p->z,\n                                                              &p->buff, p->name);\n   cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L)));\n   cl->l.p = tf;""}","static void f_parser (lua_State *L, void *ud) {
  int i;
  Proto *tf;
  Closure *cl;
   struct SParser *p = cast(struct SParser *, ud);
   int c = luaZ_lookahead(p->z);
   luaC_checkGC(L);
  tf = (luaY_parser)(L, p->z,
                                                              &p->buff, p->name);
   cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L)));
   cl->l.p = tf;
  for (i = 0; i < tf->nups; i++)  /* initialize eventual upvalues */
    cl->l.upvals[i] = luaF_newupval(L);
  setclvalue(L, L->top, cl);
  incr_top(L);
}
","static void f_parser (lua_State *L, void *ud) {
  int i;
  Proto *tf;
  Closure *cl;
   struct SParser *p = cast(struct SParser *, ud);
   int c = luaZ_lookahead(p->z);
   luaC_checkGC(L);
  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z,
                                                              &p->buff, p->name);
   cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L)));
   cl->l.p = tf;
  for (i = 0; i < tf->nups; i++)  /* initialize eventual upvalues */
    cl->l.upvals[i] = luaF_newupval(L);
  setclvalue(L, L->top, cl);
  incr_top(L);
}
",C,"  tf = (luaY_parser)(L, p->z,
","  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z,
",,"@@ -495,7 +495,7 @@ static void f_parser (lua_State *L, void *ud) {
   struct SParser *p = cast(struct SParser *, ud);
   int c = luaZ_lookahead(p->z);
   luaC_checkGC(L);
-  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z,
+  tf = (luaY_parser)(L, p->z,
                                                              &p->buff, p->name);
   cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L)));
   cl->l.p = tf;",redis,fdf9d455098f54f7666c702ae464e6ea21e25411,357a40c4fc1f5ad3c143e6afbb0ada8d68432221,1,"static void f_parser (lua_State *L, void *ud) {
  int i;
  Proto *tf;
  Closure *cl;
   struct SParser *p = cast(struct SParser *, ud);
   int c = luaZ_lookahead(p->z);
   luaC_checkGC(L);
//flaw_line_below:
  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z,
//fix_flaw_line_below:
//  tf = (luaY_parser)(L, p->z,
                                                              &p->buff, p->name);
   cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L)));
   cl->l.p = tf;
  for (i = 0; i < tf->nups; i++)  /* initialize eventual upvalues */
    cl->l.upvals[i] = luaF_newupval(L);
  setclvalue(L, L->top, cl);
  incr_top(L);
}
"
2074,179810,,Local Network,Not required,Partial,CVE-2015-2922,https://www.cvedetails.com/cve/CVE-2015-2922/,CWE-17,Low,,,,2015-05-27,3.3,The ndisc_router_discovery function in net/ipv6/ndisc.c in the Neighbor Discovery (ND) protocol implementation in the IPv6 stack in the Linux kernel before 3.19.6 allows remote attackers to reconfigure a hop-limit setting via a small hop_limit value in a Router Advertisement (RA) message.,2018-01-04,,8,https://github.com/torvalds/linux/commit/6fd99094de2b83d1d4c8457f2c83483b2828e75a,6fd99094de2b83d1d4c8457f2c83483b2828e75a,"ipv6: Don't reduce hop limit for an interface

A local route may have a lower hop_limit set than global routes do.

RFC 3756, Section 4.2.7, ""Parameter Spoofing""

>   1.  The attacker includes a Current Hop Limit of one or another small
>       number which the attacker knows will cause legitimate packets to
>       be dropped before they reach their destination.

>   As an example, one possible approach to mitigate this threat is to
>   ignore very small hop limits.  The nodes could implement a
>   configurable minimum hop limit, and ignore attempts to set it below
>   said limit.

Signed-off-by: D.S. Ljungmark <ljungmark@modio.se>
Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/ipv6/ndisc.c,"{""sha"": ""14ecdaf06bf7497dc71199fc5638b49592a24655"", ""filename"": ""net/ipv6/ndisc.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/6fd99094de2b83d1d4c8457f2c83483b2828e75a/net/ipv6/ndisc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/6fd99094de2b83d1d4c8457f2c83483b2828e75a/net/ipv6/ndisc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/ndisc.c?ref=6fd99094de2b83d1d4c8457f2c83483b2828e75a"", ""patch"": ""@@ -1218,7 +1218,14 @@ static void ndisc_router_discovery(struct sk_buff *skb)\n \tif (rt)\n \t\trt6_set_expires(rt, jiffies + (HZ * lifetime));\n \tif (ra_msg->icmph.icmp6_hop_limit) {\n-\t\tin6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;\n+\t\t/* Only set hop_limit on the interface if it is higher than\n+\t\t * the current hop_limit.\n+\t\t */\n+\t\tif (in6_dev->cnf.hop_limit < ra_msg->icmph.icmp6_hop_limit) {\n+\t\t\tin6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;\n+\t\t} else {\n+\t\t\tND_PRINTK(2, warn, \""RA: Got route advertisement with lower hop_limit than current\\n\"");\n+\t\t}\n \t\tif (rt)\n \t\t\tdst_metric_set(&rt->dst, RTAX_HOPLIMIT,\n \t\t\t\t       ra_msg->icmph.icmp6_hop_limit);""}","static void ndisc_router_discovery(struct sk_buff *skb)
{
	struct ra_msg *ra_msg = (struct ra_msg *)skb_transport_header(skb);
	struct neighbour *neigh = NULL;
	struct inet6_dev *in6_dev;
	struct rt6_info *rt = NULL;
	int lifetime;
	struct ndisc_options ndopts;
	int optlen;
	unsigned int pref = 0;

	__u8 *opt = (__u8 *)(ra_msg + 1);

	optlen = (skb_tail_pointer(skb) - skb_transport_header(skb)) -
		sizeof(struct ra_msg);

	ND_PRINTK(2, info,
		  ""RA: %s, dev: %s\n"",
		  __func__, skb->dev->name);
	if (!(ipv6_addr_type(&ipv6_hdr(skb)->saddr) & IPV6_ADDR_LINKLOCAL)) {
		ND_PRINTK(2, warn, ""RA: source address is not link-local\n"");
		return;
	}
	if (optlen < 0) {
		ND_PRINTK(2, warn, ""RA: packet too short\n"");
		return;
	}

#ifdef CONFIG_IPV6_NDISC_NODETYPE
	if (skb->ndisc_nodetype == NDISC_NODETYPE_HOST) {
		ND_PRINTK(2, warn, ""RA: from host or unauthorized router\n"");
		return;
	}
#endif

	/*
	 *	set the RA_RECV flag in the interface
	 */

	in6_dev = __in6_dev_get(skb->dev);
	if (in6_dev == NULL) {
		ND_PRINTK(0, err, ""RA: can't find inet6 device for %s\n"",
			  skb->dev->name);
		return;
	}

	if (!ndisc_parse_options(opt, optlen, &ndopts)) {
		ND_PRINTK(2, warn, ""RA: invalid ND options\n"");
		return;
	}

	if (!ipv6_accept_ra(in6_dev)) {
		ND_PRINTK(2, info,
			  ""RA: %s, did not accept ra for dev: %s\n"",
			  __func__, skb->dev->name);
		goto skip_linkparms;
	}

#ifdef CONFIG_IPV6_NDISC_NODETYPE
	/* skip link-specific parameters from interior routers */
	if (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT) {
		ND_PRINTK(2, info,
			  ""RA: %s, nodetype is NODEFAULT, dev: %s\n"",
			  __func__, skb->dev->name);
		goto skip_linkparms;
	}
#endif

	if (in6_dev->if_flags & IF_RS_SENT) {
		/*
		 *	flag that an RA was received after an RS was sent
		 *	out on this interface.
		 */
		in6_dev->if_flags |= IF_RA_RCVD;
	}

	/*
	 * Remember the managed/otherconf flags from most recently
	 * received RA message (RFC 2462) -- yoshfuji
	 */
	in6_dev->if_flags = (in6_dev->if_flags & ~(IF_RA_MANAGED |
				IF_RA_OTHERCONF)) |
				(ra_msg->icmph.icmp6_addrconf_managed ?
					IF_RA_MANAGED : 0) |
				(ra_msg->icmph.icmp6_addrconf_other ?
					IF_RA_OTHERCONF : 0);

	if (!in6_dev->cnf.accept_ra_defrtr) {
		ND_PRINTK(2, info,
			  ""RA: %s, defrtr is false for dev: %s\n"",
			  __func__, skb->dev->name);
		goto skip_defrtr;
	}

	/* Do not accept RA with source-addr found on local machine unless
	 * accept_ra_from_local is set to true.
	 */
	if (!in6_dev->cnf.accept_ra_from_local &&
	    ipv6_chk_addr(dev_net(in6_dev->dev), &ipv6_hdr(skb)->saddr,
			  NULL, 0)) {
		ND_PRINTK(2, info,
			  ""RA from local address detected on dev: %s: default router ignored\n"",
			  skb->dev->name);
		goto skip_defrtr;
	}

	lifetime = ntohs(ra_msg->icmph.icmp6_rt_lifetime);

#ifdef CONFIG_IPV6_ROUTER_PREF
	pref = ra_msg->icmph.icmp6_router_pref;
	/* 10b is handled as if it were 00b (medium) */
	if (pref == ICMPV6_ROUTER_PREF_INVALID ||
	    !in6_dev->cnf.accept_ra_rtr_pref)
		pref = ICMPV6_ROUTER_PREF_MEDIUM;
#endif

	rt = rt6_get_dflt_router(&ipv6_hdr(skb)->saddr, skb->dev);

	if (rt) {
		neigh = dst_neigh_lookup(&rt->dst, &ipv6_hdr(skb)->saddr);
		if (!neigh) {
			ND_PRINTK(0, err,
				  ""RA: %s got default router without neighbour\n"",
				  __func__);
			ip6_rt_put(rt);
			return;
		}
	}
	if (rt && lifetime == 0) {
		ip6_del_rt(rt);
		rt = NULL;
	}

	ND_PRINTK(3, info, ""RA: rt: %p  lifetime: %d, for dev: %s\n"",
		  rt, lifetime, skb->dev->name);
	if (rt == NULL && lifetime) {
		ND_PRINTK(3, info, ""RA: adding default router\n"");

		rt = rt6_add_dflt_router(&ipv6_hdr(skb)->saddr, skb->dev, pref);
		if (rt == NULL) {
			ND_PRINTK(0, err,
				  ""RA: %s failed to add default route\n"",
				  __func__);
			return;
		}

		neigh = dst_neigh_lookup(&rt->dst, &ipv6_hdr(skb)->saddr);
		if (neigh == NULL) {
			ND_PRINTK(0, err,
				  ""RA: %s got default router without neighbour\n"",
				  __func__);
			ip6_rt_put(rt);
			return;
		}
		neigh->flags |= NTF_ROUTER;
	} else if (rt) {
		rt->rt6i_flags = (rt->rt6i_flags & ~RTF_PREF_MASK) | RTF_PREF(pref);
	}

 	if (rt)
 		rt6_set_expires(rt, jiffies + (HZ * lifetime));
 	if (ra_msg->icmph.icmp6_hop_limit) {
		/* Only set hop_limit on the interface if it is higher than
		 * the current hop_limit.
		 */
		if (in6_dev->cnf.hop_limit < ra_msg->icmph.icmp6_hop_limit) {
			in6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;
		} else {
			ND_PRINTK(2, warn, ""RA: Got route advertisement with lower hop_limit than current\n"");
		}
 		if (rt)
 			dst_metric_set(&rt->dst, RTAX_HOPLIMIT,
 				       ra_msg->icmph.icmp6_hop_limit);
	}

skip_defrtr:

	/*
	 *	Update Reachable Time and Retrans Timer
	 */

	if (in6_dev->nd_parms) {
		unsigned long rtime = ntohl(ra_msg->retrans_timer);

		if (rtime && rtime/1000 < MAX_SCHEDULE_TIMEOUT/HZ) {
			rtime = (rtime*HZ)/1000;
			if (rtime < HZ/10)
				rtime = HZ/10;
			NEIGH_VAR_SET(in6_dev->nd_parms, RETRANS_TIME, rtime);
			in6_dev->tstamp = jiffies;
			inet6_ifinfo_notify(RTM_NEWLINK, in6_dev);
		}

		rtime = ntohl(ra_msg->reachable_time);
		if (rtime && rtime/1000 < MAX_SCHEDULE_TIMEOUT/(3*HZ)) {
			rtime = (rtime*HZ)/1000;

			if (rtime < HZ/10)
				rtime = HZ/10;

			if (rtime != NEIGH_VAR(in6_dev->nd_parms, BASE_REACHABLE_TIME)) {
				NEIGH_VAR_SET(in6_dev->nd_parms,
					      BASE_REACHABLE_TIME, rtime);
				NEIGH_VAR_SET(in6_dev->nd_parms,
					      GC_STALETIME, 3 * rtime);
				in6_dev->nd_parms->reachable_time = neigh_rand_reach_time(rtime);
				in6_dev->tstamp = jiffies;
				inet6_ifinfo_notify(RTM_NEWLINK, in6_dev);
			}
		}
	}

skip_linkparms:

	/*
	 *	Process options.
	 */

	if (!neigh)
		neigh = __neigh_lookup(&nd_tbl, &ipv6_hdr(skb)->saddr,
				       skb->dev, 1);
	if (neigh) {
		u8 *lladdr = NULL;
		if (ndopts.nd_opts_src_lladdr) {
			lladdr = ndisc_opt_addr_data(ndopts.nd_opts_src_lladdr,
						     skb->dev);
			if (!lladdr) {
				ND_PRINTK(2, warn,
					  ""RA: invalid link-layer address length\n"");
				goto out;
			}
		}
		neigh_update(neigh, lladdr, NUD_STALE,
			     NEIGH_UPDATE_F_WEAK_OVERRIDE|
			     NEIGH_UPDATE_F_OVERRIDE|
			     NEIGH_UPDATE_F_OVERRIDE_ISROUTER|
			     NEIGH_UPDATE_F_ISROUTER);
	}

	if (!ipv6_accept_ra(in6_dev)) {
		ND_PRINTK(2, info,
			  ""RA: %s, accept_ra is false for dev: %s\n"",
			  __func__, skb->dev->name);
		goto out;
	}

#ifdef CONFIG_IPV6_ROUTE_INFO
	if (!in6_dev->cnf.accept_ra_from_local &&
	    ipv6_chk_addr(dev_net(in6_dev->dev), &ipv6_hdr(skb)->saddr,
			  NULL, 0)) {
		ND_PRINTK(2, info,
			  ""RA from local address detected on dev: %s: router info ignored.\n"",
			  skb->dev->name);
		goto skip_routeinfo;
	}

	if (in6_dev->cnf.accept_ra_rtr_pref && ndopts.nd_opts_ri) {
		struct nd_opt_hdr *p;
		for (p = ndopts.nd_opts_ri;
		     p;
		     p = ndisc_next_option(p, ndopts.nd_opts_ri_end)) {
			struct route_info *ri = (struct route_info *)p;
#ifdef CONFIG_IPV6_NDISC_NODETYPE
			if (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT &&
			    ri->prefix_len == 0)
				continue;
#endif
			if (ri->prefix_len == 0 &&
			    !in6_dev->cnf.accept_ra_defrtr)
				continue;
			if (ri->prefix_len > in6_dev->cnf.accept_ra_rt_info_max_plen)
				continue;
			rt6_route_rcv(skb->dev, (u8 *)p, (p->nd_opt_len) << 3,
				      &ipv6_hdr(skb)->saddr);
		}
	}

skip_routeinfo:
#endif

#ifdef CONFIG_IPV6_NDISC_NODETYPE
	/* skip link-specific ndopts from interior routers */
	if (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT) {
		ND_PRINTK(2, info,
			  ""RA: %s, nodetype is NODEFAULT (interior routes), dev: %s\n"",
			  __func__, skb->dev->name);
		goto out;
	}
#endif

	if (in6_dev->cnf.accept_ra_pinfo && ndopts.nd_opts_pi) {
		struct nd_opt_hdr *p;
		for (p = ndopts.nd_opts_pi;
		     p;
		     p = ndisc_next_option(p, ndopts.nd_opts_pi_end)) {
			addrconf_prefix_rcv(skb->dev, (u8 *)p,
					    (p->nd_opt_len) << 3,
					    ndopts.nd_opts_src_lladdr != NULL);
		}
	}

	if (ndopts.nd_opts_mtu && in6_dev->cnf.accept_ra_mtu) {
		__be32 n;
		u32 mtu;

		memcpy(&n, ((u8 *)(ndopts.nd_opts_mtu+1))+2, sizeof(mtu));
		mtu = ntohl(n);

		if (mtu < IPV6_MIN_MTU || mtu > skb->dev->mtu) {
			ND_PRINTK(2, warn, ""RA: invalid mtu: %d\n"", mtu);
		} else if (in6_dev->cnf.mtu6 != mtu) {
			in6_dev->cnf.mtu6 = mtu;

			if (rt)
				dst_metric_set(&rt->dst, RTAX_MTU, mtu);

			rt6_mtu_change(skb->dev, mtu);
		}
	}

	if (ndopts.nd_useropts) {
		struct nd_opt_hdr *p;
		for (p = ndopts.nd_useropts;
		     p;
		     p = ndisc_next_useropt(p, ndopts.nd_useropts_end)) {
			ndisc_ra_useropt(skb, p);
		}
	}

	if (ndopts.nd_opts_tgt_lladdr || ndopts.nd_opts_rh) {
		ND_PRINTK(2, warn, ""RA: invalid RA options\n"");
	}
out:
	ip6_rt_put(rt);
	if (neigh)
		neigh_release(neigh);
}
","static void ndisc_router_discovery(struct sk_buff *skb)
{
	struct ra_msg *ra_msg = (struct ra_msg *)skb_transport_header(skb);
	struct neighbour *neigh = NULL;
	struct inet6_dev *in6_dev;
	struct rt6_info *rt = NULL;
	int lifetime;
	struct ndisc_options ndopts;
	int optlen;
	unsigned int pref = 0;

	__u8 *opt = (__u8 *)(ra_msg + 1);

	optlen = (skb_tail_pointer(skb) - skb_transport_header(skb)) -
		sizeof(struct ra_msg);

	ND_PRINTK(2, info,
		  ""RA: %s, dev: %s\n"",
		  __func__, skb->dev->name);
	if (!(ipv6_addr_type(&ipv6_hdr(skb)->saddr) & IPV6_ADDR_LINKLOCAL)) {
		ND_PRINTK(2, warn, ""RA: source address is not link-local\n"");
		return;
	}
	if (optlen < 0) {
		ND_PRINTK(2, warn, ""RA: packet too short\n"");
		return;
	}

#ifdef CONFIG_IPV6_NDISC_NODETYPE
	if (skb->ndisc_nodetype == NDISC_NODETYPE_HOST) {
		ND_PRINTK(2, warn, ""RA: from host or unauthorized router\n"");
		return;
	}
#endif

	/*
	 *	set the RA_RECV flag in the interface
	 */

	in6_dev = __in6_dev_get(skb->dev);
	if (in6_dev == NULL) {
		ND_PRINTK(0, err, ""RA: can't find inet6 device for %s\n"",
			  skb->dev->name);
		return;
	}

	if (!ndisc_parse_options(opt, optlen, &ndopts)) {
		ND_PRINTK(2, warn, ""RA: invalid ND options\n"");
		return;
	}

	if (!ipv6_accept_ra(in6_dev)) {
		ND_PRINTK(2, info,
			  ""RA: %s, did not accept ra for dev: %s\n"",
			  __func__, skb->dev->name);
		goto skip_linkparms;
	}

#ifdef CONFIG_IPV6_NDISC_NODETYPE
	/* skip link-specific parameters from interior routers */
	if (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT) {
		ND_PRINTK(2, info,
			  ""RA: %s, nodetype is NODEFAULT, dev: %s\n"",
			  __func__, skb->dev->name);
		goto skip_linkparms;
	}
#endif

	if (in6_dev->if_flags & IF_RS_SENT) {
		/*
		 *	flag that an RA was received after an RS was sent
		 *	out on this interface.
		 */
		in6_dev->if_flags |= IF_RA_RCVD;
	}

	/*
	 * Remember the managed/otherconf flags from most recently
	 * received RA message (RFC 2462) -- yoshfuji
	 */
	in6_dev->if_flags = (in6_dev->if_flags & ~(IF_RA_MANAGED |
				IF_RA_OTHERCONF)) |
				(ra_msg->icmph.icmp6_addrconf_managed ?
					IF_RA_MANAGED : 0) |
				(ra_msg->icmph.icmp6_addrconf_other ?
					IF_RA_OTHERCONF : 0);

	if (!in6_dev->cnf.accept_ra_defrtr) {
		ND_PRINTK(2, info,
			  ""RA: %s, defrtr is false for dev: %s\n"",
			  __func__, skb->dev->name);
		goto skip_defrtr;
	}

	/* Do not accept RA with source-addr found on local machine unless
	 * accept_ra_from_local is set to true.
	 */
	if (!in6_dev->cnf.accept_ra_from_local &&
	    ipv6_chk_addr(dev_net(in6_dev->dev), &ipv6_hdr(skb)->saddr,
			  NULL, 0)) {
		ND_PRINTK(2, info,
			  ""RA from local address detected on dev: %s: default router ignored\n"",
			  skb->dev->name);
		goto skip_defrtr;
	}

	lifetime = ntohs(ra_msg->icmph.icmp6_rt_lifetime);

#ifdef CONFIG_IPV6_ROUTER_PREF
	pref = ra_msg->icmph.icmp6_router_pref;
	/* 10b is handled as if it were 00b (medium) */
	if (pref == ICMPV6_ROUTER_PREF_INVALID ||
	    !in6_dev->cnf.accept_ra_rtr_pref)
		pref = ICMPV6_ROUTER_PREF_MEDIUM;
#endif

	rt = rt6_get_dflt_router(&ipv6_hdr(skb)->saddr, skb->dev);

	if (rt) {
		neigh = dst_neigh_lookup(&rt->dst, &ipv6_hdr(skb)->saddr);
		if (!neigh) {
			ND_PRINTK(0, err,
				  ""RA: %s got default router without neighbour\n"",
				  __func__);
			ip6_rt_put(rt);
			return;
		}
	}
	if (rt && lifetime == 0) {
		ip6_del_rt(rt);
		rt = NULL;
	}

	ND_PRINTK(3, info, ""RA: rt: %p  lifetime: %d, for dev: %s\n"",
		  rt, lifetime, skb->dev->name);
	if (rt == NULL && lifetime) {
		ND_PRINTK(3, info, ""RA: adding default router\n"");

		rt = rt6_add_dflt_router(&ipv6_hdr(skb)->saddr, skb->dev, pref);
		if (rt == NULL) {
			ND_PRINTK(0, err,
				  ""RA: %s failed to add default route\n"",
				  __func__);
			return;
		}

		neigh = dst_neigh_lookup(&rt->dst, &ipv6_hdr(skb)->saddr);
		if (neigh == NULL) {
			ND_PRINTK(0, err,
				  ""RA: %s got default router without neighbour\n"",
				  __func__);
			ip6_rt_put(rt);
			return;
		}
		neigh->flags |= NTF_ROUTER;
	} else if (rt) {
		rt->rt6i_flags = (rt->rt6i_flags & ~RTF_PREF_MASK) | RTF_PREF(pref);
	}

 	if (rt)
 		rt6_set_expires(rt, jiffies + (HZ * lifetime));
 	if (ra_msg->icmph.icmp6_hop_limit) {
		in6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;
 		if (rt)
 			dst_metric_set(&rt->dst, RTAX_HOPLIMIT,
 				       ra_msg->icmph.icmp6_hop_limit);
	}

skip_defrtr:

	/*
	 *	Update Reachable Time and Retrans Timer
	 */

	if (in6_dev->nd_parms) {
		unsigned long rtime = ntohl(ra_msg->retrans_timer);

		if (rtime && rtime/1000 < MAX_SCHEDULE_TIMEOUT/HZ) {
			rtime = (rtime*HZ)/1000;
			if (rtime < HZ/10)
				rtime = HZ/10;
			NEIGH_VAR_SET(in6_dev->nd_parms, RETRANS_TIME, rtime);
			in6_dev->tstamp = jiffies;
			inet6_ifinfo_notify(RTM_NEWLINK, in6_dev);
		}

		rtime = ntohl(ra_msg->reachable_time);
		if (rtime && rtime/1000 < MAX_SCHEDULE_TIMEOUT/(3*HZ)) {
			rtime = (rtime*HZ)/1000;

			if (rtime < HZ/10)
				rtime = HZ/10;

			if (rtime != NEIGH_VAR(in6_dev->nd_parms, BASE_REACHABLE_TIME)) {
				NEIGH_VAR_SET(in6_dev->nd_parms,
					      BASE_REACHABLE_TIME, rtime);
				NEIGH_VAR_SET(in6_dev->nd_parms,
					      GC_STALETIME, 3 * rtime);
				in6_dev->nd_parms->reachable_time = neigh_rand_reach_time(rtime);
				in6_dev->tstamp = jiffies;
				inet6_ifinfo_notify(RTM_NEWLINK, in6_dev);
			}
		}
	}

skip_linkparms:

	/*
	 *	Process options.
	 */

	if (!neigh)
		neigh = __neigh_lookup(&nd_tbl, &ipv6_hdr(skb)->saddr,
				       skb->dev, 1);
	if (neigh) {
		u8 *lladdr = NULL;
		if (ndopts.nd_opts_src_lladdr) {
			lladdr = ndisc_opt_addr_data(ndopts.nd_opts_src_lladdr,
						     skb->dev);
			if (!lladdr) {
				ND_PRINTK(2, warn,
					  ""RA: invalid link-layer address length\n"");
				goto out;
			}
		}
		neigh_update(neigh, lladdr, NUD_STALE,
			     NEIGH_UPDATE_F_WEAK_OVERRIDE|
			     NEIGH_UPDATE_F_OVERRIDE|
			     NEIGH_UPDATE_F_OVERRIDE_ISROUTER|
			     NEIGH_UPDATE_F_ISROUTER);
	}

	if (!ipv6_accept_ra(in6_dev)) {
		ND_PRINTK(2, info,
			  ""RA: %s, accept_ra is false for dev: %s\n"",
			  __func__, skb->dev->name);
		goto out;
	}

#ifdef CONFIG_IPV6_ROUTE_INFO
	if (!in6_dev->cnf.accept_ra_from_local &&
	    ipv6_chk_addr(dev_net(in6_dev->dev), &ipv6_hdr(skb)->saddr,
			  NULL, 0)) {
		ND_PRINTK(2, info,
			  ""RA from local address detected on dev: %s: router info ignored.\n"",
			  skb->dev->name);
		goto skip_routeinfo;
	}

	if (in6_dev->cnf.accept_ra_rtr_pref && ndopts.nd_opts_ri) {
		struct nd_opt_hdr *p;
		for (p = ndopts.nd_opts_ri;
		     p;
		     p = ndisc_next_option(p, ndopts.nd_opts_ri_end)) {
			struct route_info *ri = (struct route_info *)p;
#ifdef CONFIG_IPV6_NDISC_NODETYPE
			if (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT &&
			    ri->prefix_len == 0)
				continue;
#endif
			if (ri->prefix_len == 0 &&
			    !in6_dev->cnf.accept_ra_defrtr)
				continue;
			if (ri->prefix_len > in6_dev->cnf.accept_ra_rt_info_max_plen)
				continue;
			rt6_route_rcv(skb->dev, (u8 *)p, (p->nd_opt_len) << 3,
				      &ipv6_hdr(skb)->saddr);
		}
	}

skip_routeinfo:
#endif

#ifdef CONFIG_IPV6_NDISC_NODETYPE
	/* skip link-specific ndopts from interior routers */
	if (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT) {
		ND_PRINTK(2, info,
			  ""RA: %s, nodetype is NODEFAULT (interior routes), dev: %s\n"",
			  __func__, skb->dev->name);
		goto out;
	}
#endif

	if (in6_dev->cnf.accept_ra_pinfo && ndopts.nd_opts_pi) {
		struct nd_opt_hdr *p;
		for (p = ndopts.nd_opts_pi;
		     p;
		     p = ndisc_next_option(p, ndopts.nd_opts_pi_end)) {
			addrconf_prefix_rcv(skb->dev, (u8 *)p,
					    (p->nd_opt_len) << 3,
					    ndopts.nd_opts_src_lladdr != NULL);
		}
	}

	if (ndopts.nd_opts_mtu && in6_dev->cnf.accept_ra_mtu) {
		__be32 n;
		u32 mtu;

		memcpy(&n, ((u8 *)(ndopts.nd_opts_mtu+1))+2, sizeof(mtu));
		mtu = ntohl(n);

		if (mtu < IPV6_MIN_MTU || mtu > skb->dev->mtu) {
			ND_PRINTK(2, warn, ""RA: invalid mtu: %d\n"", mtu);
		} else if (in6_dev->cnf.mtu6 != mtu) {
			in6_dev->cnf.mtu6 = mtu;

			if (rt)
				dst_metric_set(&rt->dst, RTAX_MTU, mtu);

			rt6_mtu_change(skb->dev, mtu);
		}
	}

	if (ndopts.nd_useropts) {
		struct nd_opt_hdr *p;
		for (p = ndopts.nd_useropts;
		     p;
		     p = ndisc_next_useropt(p, ndopts.nd_useropts_end)) {
			ndisc_ra_useropt(skb, p);
		}
	}

	if (ndopts.nd_opts_tgt_lladdr || ndopts.nd_opts_rh) {
		ND_PRINTK(2, warn, ""RA: invalid RA options\n"");
	}
out:
	ip6_rt_put(rt);
	if (neigh)
		neigh_release(neigh);
}
",C,"		/* Only set hop_limit on the interface if it is higher than
		 * the current hop_limit.
		 */
		if (in6_dev->cnf.hop_limit < ra_msg->icmph.icmp6_hop_limit) {
			in6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;
		} else {
			ND_PRINTK(2, warn, ""RA: Got route advertisement with lower hop_limit than current\n"");
		}
","		in6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;
",,"@@ -1218,7 +1218,14 @@ static void ndisc_router_discovery(struct sk_buff *skb)
 	if (rt)
 		rt6_set_expires(rt, jiffies + (HZ * lifetime));
 	if (ra_msg->icmph.icmp6_hop_limit) {
-		in6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;
+		/* Only set hop_limit on the interface if it is higher than
+		 * the current hop_limit.
+		 */
+		if (in6_dev->cnf.hop_limit < ra_msg->icmph.icmp6_hop_limit) {
+			in6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;
+		} else {
+			ND_PRINTK(2, warn, ""RA: Got route advertisement with lower hop_limit than current\n"");
+		}
 		if (rt)
 			dst_metric_set(&rt->dst, RTAX_HOPLIMIT,
 				       ra_msg->icmph.icmp6_hop_limit);",linux,6fd99094de2b83d1d4c8457f2c83483b2828e75a,1452db764c279f8b329f1b3b9469bd01d9e21afd,1,"static void ndisc_router_discovery(struct sk_buff *skb)
{
	struct ra_msg *ra_msg = (struct ra_msg *)skb_transport_header(skb);
	struct neighbour *neigh = NULL;
	struct inet6_dev *in6_dev;
	struct rt6_info *rt = NULL;
	int lifetime;
	struct ndisc_options ndopts;
	int optlen;
	unsigned int pref = 0;

	__u8 *opt = (__u8 *)(ra_msg + 1);

	optlen = (skb_tail_pointer(skb) - skb_transport_header(skb)) -
		sizeof(struct ra_msg);

	ND_PRINTK(2, info,
		  ""RA: %s, dev: %s\n"",
		  __func__, skb->dev->name);
	if (!(ipv6_addr_type(&ipv6_hdr(skb)->saddr) & IPV6_ADDR_LINKLOCAL)) {
		ND_PRINTK(2, warn, ""RA: source address is not link-local\n"");
		return;
	}
	if (optlen < 0) {
		ND_PRINTK(2, warn, ""RA: packet too short\n"");
		return;
	}

#ifdef CONFIG_IPV6_NDISC_NODETYPE
	if (skb->ndisc_nodetype == NDISC_NODETYPE_HOST) {
		ND_PRINTK(2, warn, ""RA: from host or unauthorized router\n"");
		return;
	}
#endif

	/*
	 *	set the RA_RECV flag in the interface
	 */

	in6_dev = __in6_dev_get(skb->dev);
	if (in6_dev == NULL) {
		ND_PRINTK(0, err, ""RA: can't find inet6 device for %s\n"",
			  skb->dev->name);
		return;
	}

	if (!ndisc_parse_options(opt, optlen, &ndopts)) {
		ND_PRINTK(2, warn, ""RA: invalid ND options\n"");
		return;
	}

	if (!ipv6_accept_ra(in6_dev)) {
		ND_PRINTK(2, info,
			  ""RA: %s, did not accept ra for dev: %s\n"",
			  __func__, skb->dev->name);
		goto skip_linkparms;
	}

#ifdef CONFIG_IPV6_NDISC_NODETYPE
	/* skip link-specific parameters from interior routers */
	if (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT) {
		ND_PRINTK(2, info,
			  ""RA: %s, nodetype is NODEFAULT, dev: %s\n"",
			  __func__, skb->dev->name);
		goto skip_linkparms;
	}
#endif

	if (in6_dev->if_flags & IF_RS_SENT) {
		/*
		 *	flag that an RA was received after an RS was sent
		 *	out on this interface.
		 */
		in6_dev->if_flags |= IF_RA_RCVD;
	}

	/*
	 * Remember the managed/otherconf flags from most recently
	 * received RA message (RFC 2462) -- yoshfuji
	 */
	in6_dev->if_flags = (in6_dev->if_flags & ~(IF_RA_MANAGED |
				IF_RA_OTHERCONF)) |
				(ra_msg->icmph.icmp6_addrconf_managed ?
					IF_RA_MANAGED : 0) |
				(ra_msg->icmph.icmp6_addrconf_other ?
					IF_RA_OTHERCONF : 0);

	if (!in6_dev->cnf.accept_ra_defrtr) {
		ND_PRINTK(2, info,
			  ""RA: %s, defrtr is false for dev: %s\n"",
			  __func__, skb->dev->name);
		goto skip_defrtr;
	}

	/* Do not accept RA with source-addr found on local machine unless
	 * accept_ra_from_local is set to true.
	 */
	if (!in6_dev->cnf.accept_ra_from_local &&
	    ipv6_chk_addr(dev_net(in6_dev->dev), &ipv6_hdr(skb)->saddr,
			  NULL, 0)) {
		ND_PRINTK(2, info,
			  ""RA from local address detected on dev: %s: default router ignored\n"",
			  skb->dev->name);
		goto skip_defrtr;
	}

	lifetime = ntohs(ra_msg->icmph.icmp6_rt_lifetime);

#ifdef CONFIG_IPV6_ROUTER_PREF
	pref = ra_msg->icmph.icmp6_router_pref;
	/* 10b is handled as if it were 00b (medium) */
	if (pref == ICMPV6_ROUTER_PREF_INVALID ||
	    !in6_dev->cnf.accept_ra_rtr_pref)
		pref = ICMPV6_ROUTER_PREF_MEDIUM;
#endif

	rt = rt6_get_dflt_router(&ipv6_hdr(skb)->saddr, skb->dev);

	if (rt) {
		neigh = dst_neigh_lookup(&rt->dst, &ipv6_hdr(skb)->saddr);
		if (!neigh) {
			ND_PRINTK(0, err,
				  ""RA: %s got default router without neighbour\n"",
				  __func__);
			ip6_rt_put(rt);
			return;
		}
	}
	if (rt && lifetime == 0) {
		ip6_del_rt(rt);
		rt = NULL;
	}

	ND_PRINTK(3, info, ""RA: rt: %p  lifetime: %d, for dev: %s\n"",
		  rt, lifetime, skb->dev->name);
	if (rt == NULL && lifetime) {
		ND_PRINTK(3, info, ""RA: adding default router\n"");

		rt = rt6_add_dflt_router(&ipv6_hdr(skb)->saddr, skb->dev, pref);
		if (rt == NULL) {
			ND_PRINTK(0, err,
				  ""RA: %s failed to add default route\n"",
				  __func__);
			return;
		}

		neigh = dst_neigh_lookup(&rt->dst, &ipv6_hdr(skb)->saddr);
		if (neigh == NULL) {
			ND_PRINTK(0, err,
				  ""RA: %s got default router without neighbour\n"",
				  __func__);
			ip6_rt_put(rt);
			return;
		}
		neigh->flags |= NTF_ROUTER;
	} else if (rt) {
		rt->rt6i_flags = (rt->rt6i_flags & ~RTF_PREF_MASK) | RTF_PREF(pref);
	}

 	if (rt)
 		rt6_set_expires(rt, jiffies + (HZ * lifetime));
 	if (ra_msg->icmph.icmp6_hop_limit) {
//flaw_line_below:
		in6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;
//fix_flaw_line_below:
//		/* Only set hop_limit on the interface if it is higher than
//fix_flaw_line_below:
//		 * the current hop_limit.
//fix_flaw_line_below:
//		 */
//fix_flaw_line_below:
//		if (in6_dev->cnf.hop_limit < ra_msg->icmph.icmp6_hop_limit) {
//fix_flaw_line_below:
//			in6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;
//fix_flaw_line_below:
//		} else {
//fix_flaw_line_below:
//			ND_PRINTK(2, warn, ""RA: Got route advertisement with lower hop_limit than current\n"");
//fix_flaw_line_below:
//		}
 		if (rt)
 			dst_metric_set(&rt->dst, RTAX_HOPLIMIT,
 				       ra_msg->icmph.icmp6_hop_limit);
	}

skip_defrtr:

	/*
	 *	Update Reachable Time and Retrans Timer
	 */

	if (in6_dev->nd_parms) {
		unsigned long rtime = ntohl(ra_msg->retrans_timer);

		if (rtime && rtime/1000 < MAX_SCHEDULE_TIMEOUT/HZ) {
			rtime = (rtime*HZ)/1000;
			if (rtime < HZ/10)
				rtime = HZ/10;
			NEIGH_VAR_SET(in6_dev->nd_parms, RETRANS_TIME, rtime);
			in6_dev->tstamp = jiffies;
			inet6_ifinfo_notify(RTM_NEWLINK, in6_dev);
		}

		rtime = ntohl(ra_msg->reachable_time);
		if (rtime && rtime/1000 < MAX_SCHEDULE_TIMEOUT/(3*HZ)) {
			rtime = (rtime*HZ)/1000;

			if (rtime < HZ/10)
				rtime = HZ/10;

			if (rtime != NEIGH_VAR(in6_dev->nd_parms, BASE_REACHABLE_TIME)) {
				NEIGH_VAR_SET(in6_dev->nd_parms,
					      BASE_REACHABLE_TIME, rtime);
				NEIGH_VAR_SET(in6_dev->nd_parms,
					      GC_STALETIME, 3 * rtime);
				in6_dev->nd_parms->reachable_time = neigh_rand_reach_time(rtime);
				in6_dev->tstamp = jiffies;
				inet6_ifinfo_notify(RTM_NEWLINK, in6_dev);
			}
		}
	}

skip_linkparms:

	/*
	 *	Process options.
	 */

	if (!neigh)
		neigh = __neigh_lookup(&nd_tbl, &ipv6_hdr(skb)->saddr,
				       skb->dev, 1);
	if (neigh) {
		u8 *lladdr = NULL;
		if (ndopts.nd_opts_src_lladdr) {
			lladdr = ndisc_opt_addr_data(ndopts.nd_opts_src_lladdr,
						     skb->dev);
			if (!lladdr) {
				ND_PRINTK(2, warn,
					  ""RA: invalid link-layer address length\n"");
				goto out;
			}
		}
		neigh_update(neigh, lladdr, NUD_STALE,
			     NEIGH_UPDATE_F_WEAK_OVERRIDE|
			     NEIGH_UPDATE_F_OVERRIDE|
			     NEIGH_UPDATE_F_OVERRIDE_ISROUTER|
			     NEIGH_UPDATE_F_ISROUTER);
	}

	if (!ipv6_accept_ra(in6_dev)) {
		ND_PRINTK(2, info,
			  ""RA: %s, accept_ra is false for dev: %s\n"",
			  __func__, skb->dev->name);
		goto out;
	}

#ifdef CONFIG_IPV6_ROUTE_INFO
	if (!in6_dev->cnf.accept_ra_from_local &&
	    ipv6_chk_addr(dev_net(in6_dev->dev), &ipv6_hdr(skb)->saddr,
			  NULL, 0)) {
		ND_PRINTK(2, info,
			  ""RA from local address detected on dev: %s: router info ignored.\n"",
			  skb->dev->name);
		goto skip_routeinfo;
	}

	if (in6_dev->cnf.accept_ra_rtr_pref && ndopts.nd_opts_ri) {
		struct nd_opt_hdr *p;
		for (p = ndopts.nd_opts_ri;
		     p;
		     p = ndisc_next_option(p, ndopts.nd_opts_ri_end)) {
			struct route_info *ri = (struct route_info *)p;
#ifdef CONFIG_IPV6_NDISC_NODETYPE
			if (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT &&
			    ri->prefix_len == 0)
				continue;
#endif
			if (ri->prefix_len == 0 &&
			    !in6_dev->cnf.accept_ra_defrtr)
				continue;
			if (ri->prefix_len > in6_dev->cnf.accept_ra_rt_info_max_plen)
				continue;
			rt6_route_rcv(skb->dev, (u8 *)p, (p->nd_opt_len) << 3,
				      &ipv6_hdr(skb)->saddr);
		}
	}

skip_routeinfo:
#endif

#ifdef CONFIG_IPV6_NDISC_NODETYPE
	/* skip link-specific ndopts from interior routers */
	if (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT) {
		ND_PRINTK(2, info,
			  ""RA: %s, nodetype is NODEFAULT (interior routes), dev: %s\n"",
			  __func__, skb->dev->name);
		goto out;
	}
#endif

	if (in6_dev->cnf.accept_ra_pinfo && ndopts.nd_opts_pi) {
		struct nd_opt_hdr *p;
		for (p = ndopts.nd_opts_pi;
		     p;
		     p = ndisc_next_option(p, ndopts.nd_opts_pi_end)) {
			addrconf_prefix_rcv(skb->dev, (u8 *)p,
					    (p->nd_opt_len) << 3,
					    ndopts.nd_opts_src_lladdr != NULL);
		}
	}

	if (ndopts.nd_opts_mtu && in6_dev->cnf.accept_ra_mtu) {
		__be32 n;
		u32 mtu;

		memcpy(&n, ((u8 *)(ndopts.nd_opts_mtu+1))+2, sizeof(mtu));
		mtu = ntohl(n);

		if (mtu < IPV6_MIN_MTU || mtu > skb->dev->mtu) {
			ND_PRINTK(2, warn, ""RA: invalid mtu: %d\n"", mtu);
		} else if (in6_dev->cnf.mtu6 != mtu) {
			in6_dev->cnf.mtu6 = mtu;

			if (rt)
				dst_metric_set(&rt->dst, RTAX_MTU, mtu);

			rt6_mtu_change(skb->dev, mtu);
		}
	}

	if (ndopts.nd_useropts) {
		struct nd_opt_hdr *p;
		for (p = ndopts.nd_useropts;
		     p;
		     p = ndisc_next_useropt(p, ndopts.nd_useropts_end)) {
			ndisc_ra_useropt(skb, p);
		}
	}

	if (ndopts.nd_opts_tgt_lladdr || ndopts.nd_opts_rh) {
		ND_PRINTK(2, warn, ""RA: invalid RA options\n"");
	}
out:
	ip6_rt_put(rt);
	if (neigh)
		neigh_release(neigh);
}
"
2121,179857,,Local,Not required,Complete,CVE-2015-1805,https://www.cvedetails.com/cve/CVE-2015-1805/,CWE-17,Low,Complete,Complete,,2015-08-08,7.2,"The (1) pipe_read and (2) pipe_write implementations in fs/pipe.c in the Linux kernel before 3.16 do not properly consider the side effects of failed __copy_to_user_inatomic and __copy_from_user_inatomic calls, which allows local users to cause a denial of service (system crash) or possibly gain privileges via a crafted application, aka an *I/O vector array overrun.*",2018-01-04,DoS +Priv ,0,https://github.com/torvalds/linux/commit/f0d1bec9d58d4c038d0ac958c9af82be6eb18045,f0d1bec9d58d4c038d0ac958c9af82be6eb18045,"new helper: copy_page_from_iter()

parallel to copy_page_to_iter().  pipe_write() switched to it (and became
->write_iter()).

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",11,fs/pipe.c,"{""sha"": ""21981e58e2a634c09b9ebb9b327860d849fb6b53"", ""filename"": ""fs/pipe.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 110, ""changes"": 129, ""blob_url"": ""https://github.com/torvalds/linux/blob/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/fs/pipe.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/fs/pipe.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pipe.c?ref=f0d1bec9d58d4c038d0ac958c9af82be6eb18045"", ""patch"": ""@@ -116,50 +116,6 @@ void pipe_wait(struct pipe_inode_info *pipe)\n \tpipe_lock(pipe);\n }\n \n-static int\n-pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,\n-\t\t\tint atomic)\n-{\n-\tunsigned long copy;\n-\n-\twhile (len > 0) {\n-\t\twhile (!iov->iov_len)\n-\t\t\tiov++;\n-\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n-\n-\t\tif (atomic) {\n-\t\t\tif (__copy_from_user_inatomic(to, iov->iov_base, copy))\n-\t\t\t\treturn -EFAULT;\n-\t\t} else {\n-\t\t\tif (copy_from_user(to, iov->iov_base, copy))\n-\t\t\t\treturn -EFAULT;\n-\t\t}\n-\t\tto += copy;\n-\t\tlen -= copy;\n-\t\tiov->iov_base += copy;\n-\t\tiov->iov_len -= copy;\n-\t}\n-\treturn 0;\n-}\n-\n-/*\n- * Pre-fault in the user memory, so we can use atomic copies.\n- */\n-static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)\n-{\n-\twhile (!iov->iov_len)\n-\t\tiov++;\n-\n-\twhile (len > 0) {\n-\t\tunsigned long this_len;\n-\n-\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n-\t\tfault_in_pages_readable(iov->iov_base, this_len);\n-\t\tlen -= this_len;\n-\t\tiov++;\n-\t}\n-}\n-\n static void anon_pipe_buf_release(struct pipe_inode_info *pipe,\n \t\t\t\t  struct pipe_buffer *buf)\n {\n@@ -380,24 +336,19 @@ static inline int is_packetized(struct file *file)\n }\n \n static ssize_t\n-pipe_write(struct kiocb *iocb, const struct iovec *_iov,\n-\t    unsigned long nr_segs, loff_t ppos)\n+pipe_write(struct kiocb *iocb, struct iov_iter *from)\n {\n \tstruct file *filp = iocb->ki_filp;\n \tstruct pipe_inode_info *pipe = filp->private_data;\n-\tssize_t ret;\n-\tint do_wakeup;\n-\tstruct iovec *iov = (struct iovec *)_iov;\n-\tsize_t total_len;\n+\tssize_t ret = 0;\n+\tint do_wakeup = 0;\n+\tsize_t total_len = iov_iter_count(from);\n \tssize_t chars;\n \n-\ttotal_len = iov_length(iov, nr_segs);\n \t/* Null write succeeds. */\n \tif (unlikely(total_len == 0))\n \t\treturn 0;\n \n-\tdo_wakeup = 0;\n-\tret = 0;\n \t__pipe_lock(pipe);\n \n \tif (!pipe->readers) {\n@@ -416,38 +367,19 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,\n \t\tint offset = buf->offset + buf->len;\n \n \t\tif (ops->can_merge && offset + chars <= PAGE_SIZE) {\n-\t\t\tint error, atomic = 1;\n-\t\t\tvoid *addr;\n-\n-\t\t\terror = ops->confirm(pipe, buf);\n+\t\t\tint error = ops->confirm(pipe, buf);\n \t\t\tif (error)\n \t\t\t\tgoto out;\n \n-\t\t\tiov_fault_in_pages_read(iov, chars);\n-redo1:\n-\t\t\tif (atomic)\n-\t\t\t\taddr = kmap_atomic(buf->page);\n-\t\t\telse\n-\t\t\t\taddr = kmap(buf->page);\n-\t\t\terror = pipe_iov_copy_from_user(offset + addr, iov,\n-\t\t\t\t\t\t\tchars, atomic);\n-\t\t\tif (atomic)\n-\t\t\t\tkunmap_atomic(addr);\n-\t\t\telse\n-\t\t\t\tkunmap(buf->page);\n-\t\t\tret = error;\n-\t\t\tdo_wakeup = 1;\n-\t\t\tif (error) {\n-\t\t\t\tif (atomic) {\n-\t\t\t\t\tatomic = 0;\n-\t\t\t\t\tgoto redo1;\n-\t\t\t\t}\n+\t\t\tret = copy_page_from_iter(buf->page, offset, chars, from);\n+\t\t\tif (unlikely(ret < chars)) {\n+\t\t\t\terror = -EFAULT;\n \t\t\t\tgoto out;\n \t\t\t}\n+\t\t\tdo_wakeup = 1;\n \t\t\tbuf->len += chars;\n-\t\t\ttotal_len -= chars;\n \t\t\tret = chars;\n-\t\t\tif (!total_len)\n+\t\t\tif (!iov_iter_count(from))\n \t\t\t\tgoto out;\n \t\t}\n \t}\n@@ -466,8 +398,7 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,\n \t\t\tint newbuf = (pipe->curbuf + bufs) & (pipe->buffers-1);\n \t\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n \t\t\tstruct page *page = pipe->tmp_page;\n-\t\t\tchar *src;\n-\t\t\tint error, atomic = 1;\n+\t\t\tint copied;\n \n \t\t\tif (!page) {\n \t\t\t\tpage = alloc_page(GFP_HIGHUSER);\n@@ -483,40 +414,19 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,\n \t\t\t * FIXME! Is this really true?\n \t\t\t */\n \t\t\tdo_wakeup = 1;\n-\t\t\tchars = PAGE_SIZE;\n-\t\t\tif (chars > total_len)\n-\t\t\t\tchars = total_len;\n-\n-\t\t\tiov_fault_in_pages_read(iov, chars);\n-redo2:\n-\t\t\tif (atomic)\n-\t\t\t\tsrc = kmap_atomic(page);\n-\t\t\telse\n-\t\t\t\tsrc = kmap(page);\n-\n-\t\t\terror = pipe_iov_copy_from_user(src, iov, chars,\n-\t\t\t\t\t\t\tatomic);\n-\t\t\tif (atomic)\n-\t\t\t\tkunmap_atomic(src);\n-\t\t\telse\n-\t\t\t\tkunmap(page);\n-\n-\t\t\tif (unlikely(error)) {\n-\t\t\t\tif (atomic) {\n-\t\t\t\t\tatomic = 0;\n-\t\t\t\t\tgoto redo2;\n-\t\t\t\t}\n+\t\t\tcopied = copy_page_from_iter(page, 0, PAGE_SIZE, from);\n+\t\t\tif (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {\n \t\t\t\tif (!ret)\n-\t\t\t\t\tret = error;\n+\t\t\t\t\tret = -EFAULT;\n \t\t\t\tbreak;\n \t\t\t}\n-\t\t\tret += chars;\n+\t\t\tret += copied;\n \n \t\t\t/* Insert it into the buffer array */\n \t\t\tbuf->page = page;\n \t\t\tbuf->ops = &anon_pipe_buf_ops;\n \t\t\tbuf->offset = 0;\n-\t\t\tbuf->len = chars;\n+\t\t\tbuf->len = copied;\n \t\t\tbuf->flags = 0;\n \t\t\tif (is_packetized(filp)) {\n \t\t\t\tbuf->ops = &packet_pipe_buf_ops;\n@@ -525,8 +435,7 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,\n \t\t\tpipe->nrbufs = ++bufs;\n \t\t\tpipe->tmp_page = NULL;\n \n-\t\t\ttotal_len -= chars;\n-\t\t\tif (!total_len)\n+\t\t\tif (!iov_iter_count(from))\n \t\t\t\tbreak;\n \t\t}\n \t\tif (bufs < pipe->buffers)\n@@ -1040,8 +949,8 @@ const struct file_operations pipefifo_fops = {\n \t.llseek\t\t= no_llseek,\n \t.read\t\t= new_sync_read,\n \t.read_iter\t= pipe_read,\n-\t.write\t\t= do_sync_write,\n-\t.aio_write\t= pipe_write,\n+\t.write\t\t= new_sync_write,\n+\t.write_iter\t= pipe_write,\n \t.poll\t\t= pipe_poll,\n \t.unlocked_ioctl\t= pipe_ioctl,\n \t.release\t= pipe_release,""}<_**next**_>{""sha"": ""66012352d333ae019fd4b8c58a4d7ec1a93cb0b5"", ""filename"": ""include/linux/uio.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/include/linux/uio.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/include/linux/uio.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/uio.h?ref=f0d1bec9d58d4c038d0ac958c9af82be6eb18045"", ""patch"": ""@@ -68,6 +68,8 @@ int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);\n size_t iov_iter_single_seg_count(const struct iov_iter *i);\n size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,\n \t\t\t struct iov_iter *i);\n+size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,\n+\t\t\t struct iov_iter *i);\n unsigned long iov_iter_alignment(const struct iov_iter *i);\n void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,\n \t\t\tunsigned long nr_segs, size_t count);""}<_**next**_>{""sha"": ""081e3273085bb6a9971f29d91defc90baac1f489"", ""filename"": ""mm/iov_iter.c"", ""status"": ""modified"", ""additions"": 78, ""deletions"": 0, ""changes"": 78, ""blob_url"": ""https://github.com/torvalds/linux/blob/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/mm/iov_iter.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/mm/iov_iter.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/iov_iter.c?ref=f0d1bec9d58d4c038d0ac958c9af82be6eb18045"", ""patch"": ""@@ -82,6 +82,84 @@ size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,\n }\n EXPORT_SYMBOL(copy_page_to_iter);\n \n+size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,\n+\t\t\t struct iov_iter *i)\n+{\n+\tsize_t skip, copy, left, wanted;\n+\tconst struct iovec *iov;\n+\tchar __user *buf;\n+\tvoid *kaddr, *to;\n+\n+\tif (unlikely(bytes > i->count))\n+\t\tbytes = i->count;\n+\n+\tif (unlikely(!bytes))\n+\t\treturn 0;\n+\n+\twanted = bytes;\n+\tiov = i->iov;\n+\tskip = i->iov_offset;\n+\tbuf = iov->iov_base + skip;\n+\tcopy = min(bytes, iov->iov_len - skip);\n+\n+\tif (!fault_in_pages_readable(buf, copy)) {\n+\t\tkaddr = kmap_atomic(page);\n+\t\tto = kaddr + offset;\n+\n+\t\t/* first chunk, usually the only one */\n+\t\tleft = __copy_from_user_inatomic(to, buf, copy);\n+\t\tcopy -= left;\n+\t\tskip += copy;\n+\t\tto += copy;\n+\t\tbytes -= copy;\n+\n+\t\twhile (unlikely(!left && bytes)) {\n+\t\t\tiov++;\n+\t\t\tbuf = iov->iov_base;\n+\t\t\tcopy = min(bytes, iov->iov_len);\n+\t\t\tleft = __copy_from_user_inatomic(to, buf, copy);\n+\t\t\tcopy -= left;\n+\t\t\tskip = copy;\n+\t\t\tto += copy;\n+\t\t\tbytes -= copy;\n+\t\t}\n+\t\tif (likely(!bytes)) {\n+\t\t\tkunmap_atomic(kaddr);\n+\t\t\tgoto done;\n+\t\t}\n+\t\toffset = to - kaddr;\n+\t\tbuf += copy;\n+\t\tkunmap_atomic(kaddr);\n+\t\tcopy = min(bytes, iov->iov_len - skip);\n+\t}\n+\t/* Too bad - revert to non-atomic kmap */\n+\tkaddr = kmap(page);\n+\tto = kaddr + offset;\n+\tleft = __copy_from_user(to, buf, copy);\n+\tcopy -= left;\n+\tskip += copy;\n+\tto += copy;\n+\tbytes -= copy;\n+\twhile (unlikely(!left && bytes)) {\n+\t\tiov++;\n+\t\tbuf = iov->iov_base;\n+\t\tcopy = min(bytes, iov->iov_len);\n+\t\tleft = __copy_from_user(to, buf, copy);\n+\t\tcopy -= left;\n+\t\tskip = copy;\n+\t\tto += copy;\n+\t\tbytes -= copy;\n+\t}\n+\tkunmap(page);\n+done:\n+\ti->count -= wanted - bytes;\n+\ti->nr_segs -= iov - i->iov;\n+\ti->iov = iov;\n+\ti->iov_offset = skip;\n+\treturn wanted - bytes;\n+}\n+EXPORT_SYMBOL(copy_page_from_iter);\n+\n static size_t __iovec_copy_from_user_inatomic(char *vaddr,\n \t\t\tconst struct iovec *iov, size_t base, size_t bytes)\n {""}","static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)
","static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)
{
	while (!iov->iov_len)
		iov++;
	while (len > 0) {
		unsigned long this_len;
		this_len = min_t(unsigned long, len, iov->iov_len);
		fault_in_pages_readable(iov->iov_base, this_len);
		len -= this_len;
		iov++;
	}
}
",C,,"{
	while (!iov->iov_len)
		iov++;
	while (len > 0) {
		unsigned long this_len;
		this_len = min_t(unsigned long, len, iov->iov_len);
		fault_in_pages_readable(iov->iov_base, this_len);
		len -= this_len;
		iov++;
	}
}
",,"@@ -116,50 +116,6 @@ void pipe_wait(struct pipe_inode_info *pipe)
 	pipe_lock(pipe);
 }
 
-static int
-pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,
-			int atomic)
-{
-	unsigned long copy;
-
-	while (len > 0) {
-		while (!iov->iov_len)
-			iov++;
-		copy = min_t(unsigned long, len, iov->iov_len);
-
-		if (atomic) {
-			if (__copy_from_user_inatomic(to, iov->iov_base, copy))
-				return -EFAULT;
-		} else {
-			if (copy_from_user(to, iov->iov_base, copy))
-				return -EFAULT;
-		}
-		to += copy;
-		len -= copy;
-		iov->iov_base += copy;
-		iov->iov_len -= copy;
-	}
-	return 0;
-}
-
-/*
- * Pre-fault in the user memory, so we can use atomic copies.
- */
-static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)
-{
-	while (!iov->iov_len)
-		iov++;
-
-	while (len > 0) {
-		unsigned long this_len;
-
-		this_len = min_t(unsigned long, len, iov->iov_len);
-		fault_in_pages_readable(iov->iov_base, this_len);
-		len -= this_len;
-		iov++;
-	}
-}
-
 static void anon_pipe_buf_release(struct pipe_inode_info *pipe,
 				  struct pipe_buffer *buf)
 {
@@ -380,24 +336,19 @@ static inline int is_packetized(struct file *file)
 }
 
 static ssize_t
-pipe_write(struct kiocb *iocb, const struct iovec *_iov,
-	    unsigned long nr_segs, loff_t ppos)
+pipe_write(struct kiocb *iocb, struct iov_iter *from)
 {
 	struct file *filp = iocb->ki_filp;
 	struct pipe_inode_info *pipe = filp->private_data;
-	ssize_t ret;
-	int do_wakeup;
-	struct iovec *iov = (struct iovec *)_iov;
-	size_t total_len;
+	ssize_t ret = 0;
+	int do_wakeup = 0;
+	size_t total_len = iov_iter_count(from);
 	ssize_t chars;
 
-	total_len = iov_length(iov, nr_segs);
 	/* Null write succeeds. */
 	if (unlikely(total_len == 0))
 		return 0;
 
-	do_wakeup = 0;
-	ret = 0;
 	__pipe_lock(pipe);
 
 	if (!pipe->readers) {
@@ -416,38 +367,19 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 		int offset = buf->offset + buf->len;
 
 		if (ops->can_merge && offset + chars <= PAGE_SIZE) {
-			int error, atomic = 1;
-			void *addr;
-
-			error = ops->confirm(pipe, buf);
+			int error = ops->confirm(pipe, buf);
 			if (error)
 				goto out;
 
-			iov_fault_in_pages_read(iov, chars);
-redo1:
-			if (atomic)
-				addr = kmap_atomic(buf->page);
-			else
-				addr = kmap(buf->page);
-			error = pipe_iov_copy_from_user(offset + addr, iov,
-							chars, atomic);
-			if (atomic)
-				kunmap_atomic(addr);
-			else
-				kunmap(buf->page);
-			ret = error;
-			do_wakeup = 1;
-			if (error) {
-				if (atomic) {
-					atomic = 0;
-					goto redo1;
-				}
+			ret = copy_page_from_iter(buf->page, offset, chars, from);
+			if (unlikely(ret < chars)) {
+				error = -EFAULT;
 				goto out;
 			}
+			do_wakeup = 1;
 			buf->len += chars;
-			total_len -= chars;
 			ret = chars;
-			if (!total_len)
+			if (!iov_iter_count(from))
 				goto out;
 		}
 	}
@@ -466,8 +398,7 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 			int newbuf = (pipe->curbuf + bufs) & (pipe->buffers-1);
 			struct pipe_buffer *buf = pipe->bufs + newbuf;
 			struct page *page = pipe->tmp_page;
-			char *src;
-			int error, atomic = 1;
+			int copied;
 
 			if (!page) {
 				page = alloc_page(GFP_HIGHUSER);
@@ -483,40 +414,19 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 			 * FIXME! Is this really true?
 			 */
 			do_wakeup = 1;
-			chars = PAGE_SIZE;
-			if (chars > total_len)
-				chars = total_len;
-
-			iov_fault_in_pages_read(iov, chars);
-redo2:
-			if (atomic)
-				src = kmap_atomic(page);
-			else
-				src = kmap(page);
-
-			error = pipe_iov_copy_from_user(src, iov, chars,
-							atomic);
-			if (atomic)
-				kunmap_atomic(src);
-			else
-				kunmap(page);
-
-			if (unlikely(error)) {
-				if (atomic) {
-					atomic = 0;
-					goto redo2;
-				}
+			copied = copy_page_from_iter(page, 0, PAGE_SIZE, from);
+			if (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {
 				if (!ret)
-					ret = error;
+					ret = -EFAULT;
 				break;
 			}
-			ret += chars;
+			ret += copied;
 
 			/* Insert it into the buffer array */
 			buf->page = page;
 			buf->ops = &anon_pipe_buf_ops;
 			buf->offset = 0;
-			buf->len = chars;
+			buf->len = copied;
 			buf->flags = 0;
 			if (is_packetized(filp)) {
 				buf->ops = &packet_pipe_buf_ops;
@@ -525,8 +435,7 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 			pipe->nrbufs = ++bufs;
 			pipe->tmp_page = NULL;
 
-			total_len -= chars;
-			if (!total_len)
+			if (!iov_iter_count(from))
 				break;
 		}
 		if (bufs < pipe->buffers)
@@ -1040,8 +949,8 @@ const struct file_operations pipefifo_fops = {
 	.llseek		= no_llseek,
 	.read		= new_sync_read,
 	.read_iter	= pipe_read,
-	.write		= do_sync_write,
-	.aio_write	= pipe_write,
+	.write		= new_sync_write,
+	.write_iter	= pipe_write,
 	.poll		= pipe_poll,
 	.unlocked_ioctl	= pipe_ioctl,
 	.release	= pipe_release,",linux,f0d1bec9d58d4c038d0ac958c9af82be6eb18045,84c3d55cc474f9c234c023c92e2769f940d5548c,1,"static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)
//flaw_line_below:
{
//flaw_line_below:
	while (!iov->iov_len)
//flaw_line_below:
		iov++;
//flaw_line_below:

//flaw_line_below:
	while (len > 0) {
//flaw_line_below:
		unsigned long this_len;
//flaw_line_below:

//flaw_line_below:
		this_len = min_t(unsigned long, len, iov->iov_len);
//flaw_line_below:
		fault_in_pages_readable(iov->iov_base, this_len);
//flaw_line_below:
		len -= this_len;
//flaw_line_below:
		iov++;
//flaw_line_below:
	}
//flaw_line_below:
}
"
2122,179858,,Local,Not required,Complete,CVE-2015-1805,https://www.cvedetails.com/cve/CVE-2015-1805/,CWE-17,Low,Complete,Complete,,2015-08-08,7.2,"The (1) pipe_read and (2) pipe_write implementations in fs/pipe.c in the Linux kernel before 3.16 do not properly consider the side effects of failed __copy_to_user_inatomic and __copy_from_user_inatomic calls, which allows local users to cause a denial of service (system crash) or possibly gain privileges via a crafted application, aka an *I/O vector array overrun.*",2018-01-04,DoS +Priv ,0,https://github.com/torvalds/linux/commit/f0d1bec9d58d4c038d0ac958c9af82be6eb18045,f0d1bec9d58d4c038d0ac958c9af82be6eb18045,"new helper: copy_page_from_iter()

parallel to copy_page_to_iter().  pipe_write() switched to it (and became
->write_iter()).

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",21,fs/pipe.c,"{""sha"": ""21981e58e2a634c09b9ebb9b327860d849fb6b53"", ""filename"": ""fs/pipe.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 110, ""changes"": 129, ""blob_url"": ""https://github.com/torvalds/linux/blob/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/fs/pipe.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/fs/pipe.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pipe.c?ref=f0d1bec9d58d4c038d0ac958c9af82be6eb18045"", ""patch"": ""@@ -116,50 +116,6 @@ void pipe_wait(struct pipe_inode_info *pipe)\n \tpipe_lock(pipe);\n }\n \n-static int\n-pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,\n-\t\t\tint atomic)\n-{\n-\tunsigned long copy;\n-\n-\twhile (len > 0) {\n-\t\twhile (!iov->iov_len)\n-\t\t\tiov++;\n-\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n-\n-\t\tif (atomic) {\n-\t\t\tif (__copy_from_user_inatomic(to, iov->iov_base, copy))\n-\t\t\t\treturn -EFAULT;\n-\t\t} else {\n-\t\t\tif (copy_from_user(to, iov->iov_base, copy))\n-\t\t\t\treturn -EFAULT;\n-\t\t}\n-\t\tto += copy;\n-\t\tlen -= copy;\n-\t\tiov->iov_base += copy;\n-\t\tiov->iov_len -= copy;\n-\t}\n-\treturn 0;\n-}\n-\n-/*\n- * Pre-fault in the user memory, so we can use atomic copies.\n- */\n-static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)\n-{\n-\twhile (!iov->iov_len)\n-\t\tiov++;\n-\n-\twhile (len > 0) {\n-\t\tunsigned long this_len;\n-\n-\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n-\t\tfault_in_pages_readable(iov->iov_base, this_len);\n-\t\tlen -= this_len;\n-\t\tiov++;\n-\t}\n-}\n-\n static void anon_pipe_buf_release(struct pipe_inode_info *pipe,\n \t\t\t\t  struct pipe_buffer *buf)\n {\n@@ -380,24 +336,19 @@ static inline int is_packetized(struct file *file)\n }\n \n static ssize_t\n-pipe_write(struct kiocb *iocb, const struct iovec *_iov,\n-\t    unsigned long nr_segs, loff_t ppos)\n+pipe_write(struct kiocb *iocb, struct iov_iter *from)\n {\n \tstruct file *filp = iocb->ki_filp;\n \tstruct pipe_inode_info *pipe = filp->private_data;\n-\tssize_t ret;\n-\tint do_wakeup;\n-\tstruct iovec *iov = (struct iovec *)_iov;\n-\tsize_t total_len;\n+\tssize_t ret = 0;\n+\tint do_wakeup = 0;\n+\tsize_t total_len = iov_iter_count(from);\n \tssize_t chars;\n \n-\ttotal_len = iov_length(iov, nr_segs);\n \t/* Null write succeeds. */\n \tif (unlikely(total_len == 0))\n \t\treturn 0;\n \n-\tdo_wakeup = 0;\n-\tret = 0;\n \t__pipe_lock(pipe);\n \n \tif (!pipe->readers) {\n@@ -416,38 +367,19 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,\n \t\tint offset = buf->offset + buf->len;\n \n \t\tif (ops->can_merge && offset + chars <= PAGE_SIZE) {\n-\t\t\tint error, atomic = 1;\n-\t\t\tvoid *addr;\n-\n-\t\t\terror = ops->confirm(pipe, buf);\n+\t\t\tint error = ops->confirm(pipe, buf);\n \t\t\tif (error)\n \t\t\t\tgoto out;\n \n-\t\t\tiov_fault_in_pages_read(iov, chars);\n-redo1:\n-\t\t\tif (atomic)\n-\t\t\t\taddr = kmap_atomic(buf->page);\n-\t\t\telse\n-\t\t\t\taddr = kmap(buf->page);\n-\t\t\terror = pipe_iov_copy_from_user(offset + addr, iov,\n-\t\t\t\t\t\t\tchars, atomic);\n-\t\t\tif (atomic)\n-\t\t\t\tkunmap_atomic(addr);\n-\t\t\telse\n-\t\t\t\tkunmap(buf->page);\n-\t\t\tret = error;\n-\t\t\tdo_wakeup = 1;\n-\t\t\tif (error) {\n-\t\t\t\tif (atomic) {\n-\t\t\t\t\tatomic = 0;\n-\t\t\t\t\tgoto redo1;\n-\t\t\t\t}\n+\t\t\tret = copy_page_from_iter(buf->page, offset, chars, from);\n+\t\t\tif (unlikely(ret < chars)) {\n+\t\t\t\terror = -EFAULT;\n \t\t\t\tgoto out;\n \t\t\t}\n+\t\t\tdo_wakeup = 1;\n \t\t\tbuf->len += chars;\n-\t\t\ttotal_len -= chars;\n \t\t\tret = chars;\n-\t\t\tif (!total_len)\n+\t\t\tif (!iov_iter_count(from))\n \t\t\t\tgoto out;\n \t\t}\n \t}\n@@ -466,8 +398,7 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,\n \t\t\tint newbuf = (pipe->curbuf + bufs) & (pipe->buffers-1);\n \t\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n \t\t\tstruct page *page = pipe->tmp_page;\n-\t\t\tchar *src;\n-\t\t\tint error, atomic = 1;\n+\t\t\tint copied;\n \n \t\t\tif (!page) {\n \t\t\t\tpage = alloc_page(GFP_HIGHUSER);\n@@ -483,40 +414,19 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,\n \t\t\t * FIXME! Is this really true?\n \t\t\t */\n \t\t\tdo_wakeup = 1;\n-\t\t\tchars = PAGE_SIZE;\n-\t\t\tif (chars > total_len)\n-\t\t\t\tchars = total_len;\n-\n-\t\t\tiov_fault_in_pages_read(iov, chars);\n-redo2:\n-\t\t\tif (atomic)\n-\t\t\t\tsrc = kmap_atomic(page);\n-\t\t\telse\n-\t\t\t\tsrc = kmap(page);\n-\n-\t\t\terror = pipe_iov_copy_from_user(src, iov, chars,\n-\t\t\t\t\t\t\tatomic);\n-\t\t\tif (atomic)\n-\t\t\t\tkunmap_atomic(src);\n-\t\t\telse\n-\t\t\t\tkunmap(page);\n-\n-\t\t\tif (unlikely(error)) {\n-\t\t\t\tif (atomic) {\n-\t\t\t\t\tatomic = 0;\n-\t\t\t\t\tgoto redo2;\n-\t\t\t\t}\n+\t\t\tcopied = copy_page_from_iter(page, 0, PAGE_SIZE, from);\n+\t\t\tif (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {\n \t\t\t\tif (!ret)\n-\t\t\t\t\tret = error;\n+\t\t\t\t\tret = -EFAULT;\n \t\t\t\tbreak;\n \t\t\t}\n-\t\t\tret += chars;\n+\t\t\tret += copied;\n \n \t\t\t/* Insert it into the buffer array */\n \t\t\tbuf->page = page;\n \t\t\tbuf->ops = &anon_pipe_buf_ops;\n \t\t\tbuf->offset = 0;\n-\t\t\tbuf->len = chars;\n+\t\t\tbuf->len = copied;\n \t\t\tbuf->flags = 0;\n \t\t\tif (is_packetized(filp)) {\n \t\t\t\tbuf->ops = &packet_pipe_buf_ops;\n@@ -525,8 +435,7 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,\n \t\t\tpipe->nrbufs = ++bufs;\n \t\t\tpipe->tmp_page = NULL;\n \n-\t\t\ttotal_len -= chars;\n-\t\t\tif (!total_len)\n+\t\t\tif (!iov_iter_count(from))\n \t\t\t\tbreak;\n \t\t}\n \t\tif (bufs < pipe->buffers)\n@@ -1040,8 +949,8 @@ const struct file_operations pipefifo_fops = {\n \t.llseek\t\t= no_llseek,\n \t.read\t\t= new_sync_read,\n \t.read_iter\t= pipe_read,\n-\t.write\t\t= do_sync_write,\n-\t.aio_write\t= pipe_write,\n+\t.write\t\t= new_sync_write,\n+\t.write_iter\t= pipe_write,\n \t.poll\t\t= pipe_poll,\n \t.unlocked_ioctl\t= pipe_ioctl,\n \t.release\t= pipe_release,""}<_**next**_>{""sha"": ""66012352d333ae019fd4b8c58a4d7ec1a93cb0b5"", ""filename"": ""include/linux/uio.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/include/linux/uio.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/include/linux/uio.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/uio.h?ref=f0d1bec9d58d4c038d0ac958c9af82be6eb18045"", ""patch"": ""@@ -68,6 +68,8 @@ int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);\n size_t iov_iter_single_seg_count(const struct iov_iter *i);\n size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,\n \t\t\t struct iov_iter *i);\n+size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,\n+\t\t\t struct iov_iter *i);\n unsigned long iov_iter_alignment(const struct iov_iter *i);\n void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,\n \t\t\tunsigned long nr_segs, size_t count);""}<_**next**_>{""sha"": ""081e3273085bb6a9971f29d91defc90baac1f489"", ""filename"": ""mm/iov_iter.c"", ""status"": ""modified"", ""additions"": 78, ""deletions"": 0, ""changes"": 78, ""blob_url"": ""https://github.com/torvalds/linux/blob/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/mm/iov_iter.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/mm/iov_iter.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/iov_iter.c?ref=f0d1bec9d58d4c038d0ac958c9af82be6eb18045"", ""patch"": ""@@ -82,6 +82,84 @@ size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,\n }\n EXPORT_SYMBOL(copy_page_to_iter);\n \n+size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,\n+\t\t\t struct iov_iter *i)\n+{\n+\tsize_t skip, copy, left, wanted;\n+\tconst struct iovec *iov;\n+\tchar __user *buf;\n+\tvoid *kaddr, *to;\n+\n+\tif (unlikely(bytes > i->count))\n+\t\tbytes = i->count;\n+\n+\tif (unlikely(!bytes))\n+\t\treturn 0;\n+\n+\twanted = bytes;\n+\tiov = i->iov;\n+\tskip = i->iov_offset;\n+\tbuf = iov->iov_base + skip;\n+\tcopy = min(bytes, iov->iov_len - skip);\n+\n+\tif (!fault_in_pages_readable(buf, copy)) {\n+\t\tkaddr = kmap_atomic(page);\n+\t\tto = kaddr + offset;\n+\n+\t\t/* first chunk, usually the only one */\n+\t\tleft = __copy_from_user_inatomic(to, buf, copy);\n+\t\tcopy -= left;\n+\t\tskip += copy;\n+\t\tto += copy;\n+\t\tbytes -= copy;\n+\n+\t\twhile (unlikely(!left && bytes)) {\n+\t\t\tiov++;\n+\t\t\tbuf = iov->iov_base;\n+\t\t\tcopy = min(bytes, iov->iov_len);\n+\t\t\tleft = __copy_from_user_inatomic(to, buf, copy);\n+\t\t\tcopy -= left;\n+\t\t\tskip = copy;\n+\t\t\tto += copy;\n+\t\t\tbytes -= copy;\n+\t\t}\n+\t\tif (likely(!bytes)) {\n+\t\t\tkunmap_atomic(kaddr);\n+\t\t\tgoto done;\n+\t\t}\n+\t\toffset = to - kaddr;\n+\t\tbuf += copy;\n+\t\tkunmap_atomic(kaddr);\n+\t\tcopy = min(bytes, iov->iov_len - skip);\n+\t}\n+\t/* Too bad - revert to non-atomic kmap */\n+\tkaddr = kmap(page);\n+\tto = kaddr + offset;\n+\tleft = __copy_from_user(to, buf, copy);\n+\tcopy -= left;\n+\tskip += copy;\n+\tto += copy;\n+\tbytes -= copy;\n+\twhile (unlikely(!left && bytes)) {\n+\t\tiov++;\n+\t\tbuf = iov->iov_base;\n+\t\tcopy = min(bytes, iov->iov_len);\n+\t\tleft = __copy_from_user(to, buf, copy);\n+\t\tcopy -= left;\n+\t\tskip = copy;\n+\t\tto += copy;\n+\t\tbytes -= copy;\n+\t}\n+\tkunmap(page);\n+done:\n+\ti->count -= wanted - bytes;\n+\ti->nr_segs -= iov - i->iov;\n+\ti->iov = iov;\n+\ti->iov_offset = skip;\n+\treturn wanted - bytes;\n+}\n+EXPORT_SYMBOL(copy_page_from_iter);\n+\n static size_t __iovec_copy_from_user_inatomic(char *vaddr,\n \t\t\tconst struct iovec *iov, size_t base, size_t bytes)\n {""}","pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,
","pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,
			int atomic)
{
	unsigned long copy;
	while (len > 0) {
		while (!iov->iov_len)
			iov++;
		copy = min_t(unsigned long, len, iov->iov_len);
		if (atomic) {
			if (__copy_from_user_inatomic(to, iov->iov_base, copy))
				return -EFAULT;
		} else {
			if (copy_from_user(to, iov->iov_base, copy))
				return -EFAULT;
		}
		to += copy;
		len -= copy;
		iov->iov_base += copy;
		iov->iov_len -= copy;
	}
	return 0;
}
",C,,"			int atomic)
{
	unsigned long copy;
	while (len > 0) {
		while (!iov->iov_len)
			iov++;
		copy = min_t(unsigned long, len, iov->iov_len);
		if (atomic) {
			if (__copy_from_user_inatomic(to, iov->iov_base, copy))
				return -EFAULT;
		} else {
			if (copy_from_user(to, iov->iov_base, copy))
				return -EFAULT;
		}
		to += copy;
		len -= copy;
		iov->iov_base += copy;
		iov->iov_len -= copy;
	}
	return 0;
}
",,"@@ -116,50 +116,6 @@ void pipe_wait(struct pipe_inode_info *pipe)
 	pipe_lock(pipe);
 }
 
-static int
-pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,
-			int atomic)
-{
-	unsigned long copy;
-
-	while (len > 0) {
-		while (!iov->iov_len)
-			iov++;
-		copy = min_t(unsigned long, len, iov->iov_len);
-
-		if (atomic) {
-			if (__copy_from_user_inatomic(to, iov->iov_base, copy))
-				return -EFAULT;
-		} else {
-			if (copy_from_user(to, iov->iov_base, copy))
-				return -EFAULT;
-		}
-		to += copy;
-		len -= copy;
-		iov->iov_base += copy;
-		iov->iov_len -= copy;
-	}
-	return 0;
-}
-
-/*
- * Pre-fault in the user memory, so we can use atomic copies.
- */
-static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)
-{
-	while (!iov->iov_len)
-		iov++;
-
-	while (len > 0) {
-		unsigned long this_len;
-
-		this_len = min_t(unsigned long, len, iov->iov_len);
-		fault_in_pages_readable(iov->iov_base, this_len);
-		len -= this_len;
-		iov++;
-	}
-}
-
 static void anon_pipe_buf_release(struct pipe_inode_info *pipe,
 				  struct pipe_buffer *buf)
 {
@@ -380,24 +336,19 @@ static inline int is_packetized(struct file *file)
 }
 
 static ssize_t
-pipe_write(struct kiocb *iocb, const struct iovec *_iov,
-	    unsigned long nr_segs, loff_t ppos)
+pipe_write(struct kiocb *iocb, struct iov_iter *from)
 {
 	struct file *filp = iocb->ki_filp;
 	struct pipe_inode_info *pipe = filp->private_data;
-	ssize_t ret;
-	int do_wakeup;
-	struct iovec *iov = (struct iovec *)_iov;
-	size_t total_len;
+	ssize_t ret = 0;
+	int do_wakeup = 0;
+	size_t total_len = iov_iter_count(from);
 	ssize_t chars;
 
-	total_len = iov_length(iov, nr_segs);
 	/* Null write succeeds. */
 	if (unlikely(total_len == 0))
 		return 0;
 
-	do_wakeup = 0;
-	ret = 0;
 	__pipe_lock(pipe);
 
 	if (!pipe->readers) {
@@ -416,38 +367,19 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 		int offset = buf->offset + buf->len;
 
 		if (ops->can_merge && offset + chars <= PAGE_SIZE) {
-			int error, atomic = 1;
-			void *addr;
-
-			error = ops->confirm(pipe, buf);
+			int error = ops->confirm(pipe, buf);
 			if (error)
 				goto out;
 
-			iov_fault_in_pages_read(iov, chars);
-redo1:
-			if (atomic)
-				addr = kmap_atomic(buf->page);
-			else
-				addr = kmap(buf->page);
-			error = pipe_iov_copy_from_user(offset + addr, iov,
-							chars, atomic);
-			if (atomic)
-				kunmap_atomic(addr);
-			else
-				kunmap(buf->page);
-			ret = error;
-			do_wakeup = 1;
-			if (error) {
-				if (atomic) {
-					atomic = 0;
-					goto redo1;
-				}
+			ret = copy_page_from_iter(buf->page, offset, chars, from);
+			if (unlikely(ret < chars)) {
+				error = -EFAULT;
 				goto out;
 			}
+			do_wakeup = 1;
 			buf->len += chars;
-			total_len -= chars;
 			ret = chars;
-			if (!total_len)
+			if (!iov_iter_count(from))
 				goto out;
 		}
 	}
@@ -466,8 +398,7 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 			int newbuf = (pipe->curbuf + bufs) & (pipe->buffers-1);
 			struct pipe_buffer *buf = pipe->bufs + newbuf;
 			struct page *page = pipe->tmp_page;
-			char *src;
-			int error, atomic = 1;
+			int copied;
 
 			if (!page) {
 				page = alloc_page(GFP_HIGHUSER);
@@ -483,40 +414,19 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 			 * FIXME! Is this really true?
 			 */
 			do_wakeup = 1;
-			chars = PAGE_SIZE;
-			if (chars > total_len)
-				chars = total_len;
-
-			iov_fault_in_pages_read(iov, chars);
-redo2:
-			if (atomic)
-				src = kmap_atomic(page);
-			else
-				src = kmap(page);
-
-			error = pipe_iov_copy_from_user(src, iov, chars,
-							atomic);
-			if (atomic)
-				kunmap_atomic(src);
-			else
-				kunmap(page);
-
-			if (unlikely(error)) {
-				if (atomic) {
-					atomic = 0;
-					goto redo2;
-				}
+			copied = copy_page_from_iter(page, 0, PAGE_SIZE, from);
+			if (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {
 				if (!ret)
-					ret = error;
+					ret = -EFAULT;
 				break;
 			}
-			ret += chars;
+			ret += copied;
 
 			/* Insert it into the buffer array */
 			buf->page = page;
 			buf->ops = &anon_pipe_buf_ops;
 			buf->offset = 0;
-			buf->len = chars;
+			buf->len = copied;
 			buf->flags = 0;
 			if (is_packetized(filp)) {
 				buf->ops = &packet_pipe_buf_ops;
@@ -525,8 +435,7 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 			pipe->nrbufs = ++bufs;
 			pipe->tmp_page = NULL;
 
-			total_len -= chars;
-			if (!total_len)
+			if (!iov_iter_count(from))
 				break;
 		}
 		if (bufs < pipe->buffers)
@@ -1040,8 +949,8 @@ const struct file_operations pipefifo_fops = {
 	.llseek		= no_llseek,
 	.read		= new_sync_read,
 	.read_iter	= pipe_read,
-	.write		= do_sync_write,
-	.aio_write	= pipe_write,
+	.write		= new_sync_write,
+	.write_iter	= pipe_write,
 	.poll		= pipe_poll,
 	.unlocked_ioctl	= pipe_ioctl,
 	.release	= pipe_release,",linux,f0d1bec9d58d4c038d0ac958c9af82be6eb18045,84c3d55cc474f9c234c023c92e2769f940d5548c,1,"pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,
//flaw_line_below:
			int atomic)
//flaw_line_below:
{
//flaw_line_below:
	unsigned long copy;
//flaw_line_below:

//flaw_line_below:
	while (len > 0) {
//flaw_line_below:
		while (!iov->iov_len)
//flaw_line_below:
			iov++;
//flaw_line_below:
		copy = min_t(unsigned long, len, iov->iov_len);
//flaw_line_below:

//flaw_line_below:
		if (atomic) {
//flaw_line_below:
			if (__copy_from_user_inatomic(to, iov->iov_base, copy))
//flaw_line_below:
				return -EFAULT;
//flaw_line_below:
		} else {
//flaw_line_below:
			if (copy_from_user(to, iov->iov_base, copy))
//flaw_line_below:
				return -EFAULT;
//flaw_line_below:
		}
//flaw_line_below:
		to += copy;
//flaw_line_below:
		len -= copy;
//flaw_line_below:
		iov->iov_base += copy;
//flaw_line_below:
		iov->iov_len -= copy;
//flaw_line_below:
	}
//flaw_line_below:
	return 0;
//flaw_line_below:
}
"
2123,179859,,Local,Not required,Complete,CVE-2015-1805,https://www.cvedetails.com/cve/CVE-2015-1805/,CWE-17,Low,Complete,Complete,,2015-08-08,7.2,"The (1) pipe_read and (2) pipe_write implementations in fs/pipe.c in the Linux kernel before 3.16 do not properly consider the side effects of failed __copy_to_user_inatomic and __copy_from_user_inatomic calls, which allows local users to cause a denial of service (system crash) or possibly gain privileges via a crafted application, aka an *I/O vector array overrun.*",2018-01-04,DoS +Priv ,17,https://github.com/torvalds/linux/commit/f0d1bec9d58d4c038d0ac958c9af82be6eb18045,f0d1bec9d58d4c038d0ac958c9af82be6eb18045,"new helper: copy_page_from_iter()

parallel to copy_page_to_iter().  pipe_write() switched to it (and became
->write_iter()).

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",59,fs/pipe.c,"{""sha"": ""21981e58e2a634c09b9ebb9b327860d849fb6b53"", ""filename"": ""fs/pipe.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 110, ""changes"": 129, ""blob_url"": ""https://github.com/torvalds/linux/blob/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/fs/pipe.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/fs/pipe.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pipe.c?ref=f0d1bec9d58d4c038d0ac958c9af82be6eb18045"", ""patch"": ""@@ -116,50 +116,6 @@ void pipe_wait(struct pipe_inode_info *pipe)\n \tpipe_lock(pipe);\n }\n \n-static int\n-pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,\n-\t\t\tint atomic)\n-{\n-\tunsigned long copy;\n-\n-\twhile (len > 0) {\n-\t\twhile (!iov->iov_len)\n-\t\t\tiov++;\n-\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n-\n-\t\tif (atomic) {\n-\t\t\tif (__copy_from_user_inatomic(to, iov->iov_base, copy))\n-\t\t\t\treturn -EFAULT;\n-\t\t} else {\n-\t\t\tif (copy_from_user(to, iov->iov_base, copy))\n-\t\t\t\treturn -EFAULT;\n-\t\t}\n-\t\tto += copy;\n-\t\tlen -= copy;\n-\t\tiov->iov_base += copy;\n-\t\tiov->iov_len -= copy;\n-\t}\n-\treturn 0;\n-}\n-\n-/*\n- * Pre-fault in the user memory, so we can use atomic copies.\n- */\n-static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)\n-{\n-\twhile (!iov->iov_len)\n-\t\tiov++;\n-\n-\twhile (len > 0) {\n-\t\tunsigned long this_len;\n-\n-\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n-\t\tfault_in_pages_readable(iov->iov_base, this_len);\n-\t\tlen -= this_len;\n-\t\tiov++;\n-\t}\n-}\n-\n static void anon_pipe_buf_release(struct pipe_inode_info *pipe,\n \t\t\t\t  struct pipe_buffer *buf)\n {\n@@ -380,24 +336,19 @@ static inline int is_packetized(struct file *file)\n }\n \n static ssize_t\n-pipe_write(struct kiocb *iocb, const struct iovec *_iov,\n-\t    unsigned long nr_segs, loff_t ppos)\n+pipe_write(struct kiocb *iocb, struct iov_iter *from)\n {\n \tstruct file *filp = iocb->ki_filp;\n \tstruct pipe_inode_info *pipe = filp->private_data;\n-\tssize_t ret;\n-\tint do_wakeup;\n-\tstruct iovec *iov = (struct iovec *)_iov;\n-\tsize_t total_len;\n+\tssize_t ret = 0;\n+\tint do_wakeup = 0;\n+\tsize_t total_len = iov_iter_count(from);\n \tssize_t chars;\n \n-\ttotal_len = iov_length(iov, nr_segs);\n \t/* Null write succeeds. */\n \tif (unlikely(total_len == 0))\n \t\treturn 0;\n \n-\tdo_wakeup = 0;\n-\tret = 0;\n \t__pipe_lock(pipe);\n \n \tif (!pipe->readers) {\n@@ -416,38 +367,19 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,\n \t\tint offset = buf->offset + buf->len;\n \n \t\tif (ops->can_merge && offset + chars <= PAGE_SIZE) {\n-\t\t\tint error, atomic = 1;\n-\t\t\tvoid *addr;\n-\n-\t\t\terror = ops->confirm(pipe, buf);\n+\t\t\tint error = ops->confirm(pipe, buf);\n \t\t\tif (error)\n \t\t\t\tgoto out;\n \n-\t\t\tiov_fault_in_pages_read(iov, chars);\n-redo1:\n-\t\t\tif (atomic)\n-\t\t\t\taddr = kmap_atomic(buf->page);\n-\t\t\telse\n-\t\t\t\taddr = kmap(buf->page);\n-\t\t\terror = pipe_iov_copy_from_user(offset + addr, iov,\n-\t\t\t\t\t\t\tchars, atomic);\n-\t\t\tif (atomic)\n-\t\t\t\tkunmap_atomic(addr);\n-\t\t\telse\n-\t\t\t\tkunmap(buf->page);\n-\t\t\tret = error;\n-\t\t\tdo_wakeup = 1;\n-\t\t\tif (error) {\n-\t\t\t\tif (atomic) {\n-\t\t\t\t\tatomic = 0;\n-\t\t\t\t\tgoto redo1;\n-\t\t\t\t}\n+\t\t\tret = copy_page_from_iter(buf->page, offset, chars, from);\n+\t\t\tif (unlikely(ret < chars)) {\n+\t\t\t\terror = -EFAULT;\n \t\t\t\tgoto out;\n \t\t\t}\n+\t\t\tdo_wakeup = 1;\n \t\t\tbuf->len += chars;\n-\t\t\ttotal_len -= chars;\n \t\t\tret = chars;\n-\t\t\tif (!total_len)\n+\t\t\tif (!iov_iter_count(from))\n \t\t\t\tgoto out;\n \t\t}\n \t}\n@@ -466,8 +398,7 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,\n \t\t\tint newbuf = (pipe->curbuf + bufs) & (pipe->buffers-1);\n \t\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n \t\t\tstruct page *page = pipe->tmp_page;\n-\t\t\tchar *src;\n-\t\t\tint error, atomic = 1;\n+\t\t\tint copied;\n \n \t\t\tif (!page) {\n \t\t\t\tpage = alloc_page(GFP_HIGHUSER);\n@@ -483,40 +414,19 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,\n \t\t\t * FIXME! Is this really true?\n \t\t\t */\n \t\t\tdo_wakeup = 1;\n-\t\t\tchars = PAGE_SIZE;\n-\t\t\tif (chars > total_len)\n-\t\t\t\tchars = total_len;\n-\n-\t\t\tiov_fault_in_pages_read(iov, chars);\n-redo2:\n-\t\t\tif (atomic)\n-\t\t\t\tsrc = kmap_atomic(page);\n-\t\t\telse\n-\t\t\t\tsrc = kmap(page);\n-\n-\t\t\terror = pipe_iov_copy_from_user(src, iov, chars,\n-\t\t\t\t\t\t\tatomic);\n-\t\t\tif (atomic)\n-\t\t\t\tkunmap_atomic(src);\n-\t\t\telse\n-\t\t\t\tkunmap(page);\n-\n-\t\t\tif (unlikely(error)) {\n-\t\t\t\tif (atomic) {\n-\t\t\t\t\tatomic = 0;\n-\t\t\t\t\tgoto redo2;\n-\t\t\t\t}\n+\t\t\tcopied = copy_page_from_iter(page, 0, PAGE_SIZE, from);\n+\t\t\tif (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {\n \t\t\t\tif (!ret)\n-\t\t\t\t\tret = error;\n+\t\t\t\t\tret = -EFAULT;\n \t\t\t\tbreak;\n \t\t\t}\n-\t\t\tret += chars;\n+\t\t\tret += copied;\n \n \t\t\t/* Insert it into the buffer array */\n \t\t\tbuf->page = page;\n \t\t\tbuf->ops = &anon_pipe_buf_ops;\n \t\t\tbuf->offset = 0;\n-\t\t\tbuf->len = chars;\n+\t\t\tbuf->len = copied;\n \t\t\tbuf->flags = 0;\n \t\t\tif (is_packetized(filp)) {\n \t\t\t\tbuf->ops = &packet_pipe_buf_ops;\n@@ -525,8 +435,7 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,\n \t\t\tpipe->nrbufs = ++bufs;\n \t\t\tpipe->tmp_page = NULL;\n \n-\t\t\ttotal_len -= chars;\n-\t\t\tif (!total_len)\n+\t\t\tif (!iov_iter_count(from))\n \t\t\t\tbreak;\n \t\t}\n \t\tif (bufs < pipe->buffers)\n@@ -1040,8 +949,8 @@ const struct file_operations pipefifo_fops = {\n \t.llseek\t\t= no_llseek,\n \t.read\t\t= new_sync_read,\n \t.read_iter\t= pipe_read,\n-\t.write\t\t= do_sync_write,\n-\t.aio_write\t= pipe_write,\n+\t.write\t\t= new_sync_write,\n+\t.write_iter\t= pipe_write,\n \t.poll\t\t= pipe_poll,\n \t.unlocked_ioctl\t= pipe_ioctl,\n \t.release\t= pipe_release,""}<_**next**_>{""sha"": ""66012352d333ae019fd4b8c58a4d7ec1a93cb0b5"", ""filename"": ""include/linux/uio.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/include/linux/uio.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/include/linux/uio.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/uio.h?ref=f0d1bec9d58d4c038d0ac958c9af82be6eb18045"", ""patch"": ""@@ -68,6 +68,8 @@ int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);\n size_t iov_iter_single_seg_count(const struct iov_iter *i);\n size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,\n \t\t\t struct iov_iter *i);\n+size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,\n+\t\t\t struct iov_iter *i);\n unsigned long iov_iter_alignment(const struct iov_iter *i);\n void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,\n \t\t\tunsigned long nr_segs, size_t count);""}<_**next**_>{""sha"": ""081e3273085bb6a9971f29d91defc90baac1f489"", ""filename"": ""mm/iov_iter.c"", ""status"": ""modified"", ""additions"": 78, ""deletions"": 0, ""changes"": 78, ""blob_url"": ""https://github.com/torvalds/linux/blob/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/mm/iov_iter.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f0d1bec9d58d4c038d0ac958c9af82be6eb18045/mm/iov_iter.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/iov_iter.c?ref=f0d1bec9d58d4c038d0ac958c9af82be6eb18045"", ""patch"": ""@@ -82,6 +82,84 @@ size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,\n }\n EXPORT_SYMBOL(copy_page_to_iter);\n \n+size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,\n+\t\t\t struct iov_iter *i)\n+{\n+\tsize_t skip, copy, left, wanted;\n+\tconst struct iovec *iov;\n+\tchar __user *buf;\n+\tvoid *kaddr, *to;\n+\n+\tif (unlikely(bytes > i->count))\n+\t\tbytes = i->count;\n+\n+\tif (unlikely(!bytes))\n+\t\treturn 0;\n+\n+\twanted = bytes;\n+\tiov = i->iov;\n+\tskip = i->iov_offset;\n+\tbuf = iov->iov_base + skip;\n+\tcopy = min(bytes, iov->iov_len - skip);\n+\n+\tif (!fault_in_pages_readable(buf, copy)) {\n+\t\tkaddr = kmap_atomic(page);\n+\t\tto = kaddr + offset;\n+\n+\t\t/* first chunk, usually the only one */\n+\t\tleft = __copy_from_user_inatomic(to, buf, copy);\n+\t\tcopy -= left;\n+\t\tskip += copy;\n+\t\tto += copy;\n+\t\tbytes -= copy;\n+\n+\t\twhile (unlikely(!left && bytes)) {\n+\t\t\tiov++;\n+\t\t\tbuf = iov->iov_base;\n+\t\t\tcopy = min(bytes, iov->iov_len);\n+\t\t\tleft = __copy_from_user_inatomic(to, buf, copy);\n+\t\t\tcopy -= left;\n+\t\t\tskip = copy;\n+\t\t\tto += copy;\n+\t\t\tbytes -= copy;\n+\t\t}\n+\t\tif (likely(!bytes)) {\n+\t\t\tkunmap_atomic(kaddr);\n+\t\t\tgoto done;\n+\t\t}\n+\t\toffset = to - kaddr;\n+\t\tbuf += copy;\n+\t\tkunmap_atomic(kaddr);\n+\t\tcopy = min(bytes, iov->iov_len - skip);\n+\t}\n+\t/* Too bad - revert to non-atomic kmap */\n+\tkaddr = kmap(page);\n+\tto = kaddr + offset;\n+\tleft = __copy_from_user(to, buf, copy);\n+\tcopy -= left;\n+\tskip += copy;\n+\tto += copy;\n+\tbytes -= copy;\n+\twhile (unlikely(!left && bytes)) {\n+\t\tiov++;\n+\t\tbuf = iov->iov_base;\n+\t\tcopy = min(bytes, iov->iov_len);\n+\t\tleft = __copy_from_user(to, buf, copy);\n+\t\tcopy -= left;\n+\t\tskip = copy;\n+\t\tto += copy;\n+\t\tbytes -= copy;\n+\t}\n+\tkunmap(page);\n+done:\n+\ti->count -= wanted - bytes;\n+\ti->nr_segs -= iov - i->iov;\n+\ti->iov = iov;\n+\ti->iov_offset = skip;\n+\treturn wanted - bytes;\n+}\n+EXPORT_SYMBOL(copy_page_from_iter);\n+\n static size_t __iovec_copy_from_user_inatomic(char *vaddr,\n \t\t\tconst struct iovec *iov, size_t base, size_t bytes)\n {""}","pipe_write(struct kiocb *iocb, const struct iovec *_iov,
pipe_write(struct kiocb *iocb, struct iov_iter *from)
 {
 	struct file *filp = iocb->ki_filp;
 	struct pipe_inode_info *pipe = filp->private_data;
	ssize_t ret = 0;
	int do_wakeup = 0;
	size_t total_len = iov_iter_count(from);
 	ssize_t chars;
 
 	/* Null write succeeds. */
 	if (unlikely(total_len == 0))
 		return 0;
 
 	__pipe_lock(pipe);
 
 	if (!pipe->readers) {
		send_sig(SIGPIPE, current, 0);
		ret = -EPIPE;
		goto out;
	}

	/* We try to merge small writes */
	chars = total_len & (PAGE_SIZE-1); /* size of the last buffer */
	if (pipe->nrbufs && chars != 0) {
		int lastbuf = (pipe->curbuf + pipe->nrbufs - 1) &
							(pipe->buffers - 1);
		struct pipe_buffer *buf = pipe->bufs + lastbuf;
		const struct pipe_buf_operations *ops = buf->ops;
 		int offset = buf->offset + buf->len;
 
 		if (ops->can_merge && offset + chars <= PAGE_SIZE) {
			int error = ops->confirm(pipe, buf);
 			if (error)
 				goto out;
 
			ret = copy_page_from_iter(buf->page, offset, chars, from);
			if (unlikely(ret < chars)) {
				error = -EFAULT;
 				goto out;
 			}
			do_wakeup = 1;
 			buf->len += chars;
 			ret = chars;
			if (!iov_iter_count(from))
 				goto out;
 		}
 	}

	for (;;) {
		int bufs;

		if (!pipe->readers) {
			send_sig(SIGPIPE, current, 0);
			if (!ret)
				ret = -EPIPE;
			break;
		}
		bufs = pipe->nrbufs;
		if (bufs < pipe->buffers) {
 			int newbuf = (pipe->curbuf + bufs) & (pipe->buffers-1);
 			struct pipe_buffer *buf = pipe->bufs + newbuf;
 			struct page *page = pipe->tmp_page;
			int copied;
 
 			if (!page) {
 				page = alloc_page(GFP_HIGHUSER);
				if (unlikely(!page)) {
					ret = ret ? : -ENOMEM;
					break;
				}
				pipe->tmp_page = page;
			}
			/* Always wake up, even if the copy fails. Otherwise
			 * we lock up (O_NONBLOCK-)readers that sleep due to
			 * syscall merging.
 			 * FIXME! Is this really true?
 			 */
 			do_wakeup = 1;
			copied = copy_page_from_iter(page, 0, PAGE_SIZE, from);
			if (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {
 				if (!ret)
					ret = -EFAULT;
 				break;
 			}
			ret += copied;
 
 			/* Insert it into the buffer array */
 			buf->page = page;
 			buf->ops = &anon_pipe_buf_ops;
 			buf->offset = 0;
			buf->len = copied;
 			buf->flags = 0;
 			if (is_packetized(filp)) {
 				buf->ops = &packet_pipe_buf_ops;
				buf->flags = PIPE_BUF_FLAG_PACKET;
			}
 			pipe->nrbufs = ++bufs;
 			pipe->tmp_page = NULL;
 
			if (!iov_iter_count(from))
 				break;
 		}
 		if (bufs < pipe->buffers)
			continue;
		if (filp->f_flags & O_NONBLOCK) {
			if (!ret)
				ret = -EAGAIN;
			break;
		}
		if (signal_pending(current)) {
			if (!ret)
				ret = -ERESTARTSYS;
			break;
		}
		if (do_wakeup) {
			wake_up_interruptible_sync_poll(&pipe->wait, POLLIN | POLLRDNORM);
			kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
			do_wakeup = 0;
		}
		pipe->waiting_writers++;
		pipe_wait(pipe);
		pipe->waiting_writers--;
	}
out:
	__pipe_unlock(pipe);
	if (do_wakeup) {
		wake_up_interruptible_sync_poll(&pipe->wait, POLLIN | POLLRDNORM);
		kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
	}
	if (ret > 0 && sb_start_write_trylock(file_inode(filp)->i_sb)) {
		int err = file_update_time(filp);
		if (err)
			ret = err;
		sb_end_write(file_inode(filp)->i_sb);
	}
	return ret;
}
","pipe_write(struct kiocb *iocb, const struct iovec *_iov,
	    unsigned long nr_segs, loff_t ppos)
 {
 	struct file *filp = iocb->ki_filp;
 	struct pipe_inode_info *pipe = filp->private_data;
	ssize_t ret;
	int do_wakeup;
	struct iovec *iov = (struct iovec *)_iov;
	size_t total_len;
 	ssize_t chars;
 
	total_len = iov_length(iov, nr_segs);
 	/* Null write succeeds. */
 	if (unlikely(total_len == 0))
 		return 0;
 
	do_wakeup = 0;
	ret = 0;
 	__pipe_lock(pipe);
 
 	if (!pipe->readers) {
		send_sig(SIGPIPE, current, 0);
		ret = -EPIPE;
		goto out;
	}

	/* We try to merge small writes */
	chars = total_len & (PAGE_SIZE-1); /* size of the last buffer */
	if (pipe->nrbufs && chars != 0) {
		int lastbuf = (pipe->curbuf + pipe->nrbufs - 1) &
							(pipe->buffers - 1);
		struct pipe_buffer *buf = pipe->bufs + lastbuf;
		const struct pipe_buf_operations *ops = buf->ops;
 		int offset = buf->offset + buf->len;
 
 		if (ops->can_merge && offset + chars <= PAGE_SIZE) {
			int error, atomic = 1;
			void *addr;
			error = ops->confirm(pipe, buf);
 			if (error)
 				goto out;
 
			iov_fault_in_pages_read(iov, chars);
redo1:
			if (atomic)
				addr = kmap_atomic(buf->page);
			else
				addr = kmap(buf->page);
			error = pipe_iov_copy_from_user(offset + addr, iov,
							chars, atomic);
			if (atomic)
				kunmap_atomic(addr);
			else
				kunmap(buf->page);
			ret = error;
			do_wakeup = 1;
			if (error) {
				if (atomic) {
					atomic = 0;
					goto redo1;
				}
 				goto out;
 			}
 			buf->len += chars;
			total_len -= chars;
 			ret = chars;
			if (!total_len)
 				goto out;
 		}
 	}

	for (;;) {
		int bufs;

		if (!pipe->readers) {
			send_sig(SIGPIPE, current, 0);
			if (!ret)
				ret = -EPIPE;
			break;
		}
		bufs = pipe->nrbufs;
		if (bufs < pipe->buffers) {
 			int newbuf = (pipe->curbuf + bufs) & (pipe->buffers-1);
 			struct pipe_buffer *buf = pipe->bufs + newbuf;
 			struct page *page = pipe->tmp_page;
			char *src;
			int error, atomic = 1;
 
 			if (!page) {
 				page = alloc_page(GFP_HIGHUSER);
				if (unlikely(!page)) {
					ret = ret ? : -ENOMEM;
					break;
				}
				pipe->tmp_page = page;
			}
			/* Always wake up, even if the copy fails. Otherwise
			 * we lock up (O_NONBLOCK-)readers that sleep due to
			 * syscall merging.
 			 * FIXME! Is this really true?
 			 */
 			do_wakeup = 1;
			chars = PAGE_SIZE;
			if (chars > total_len)
				chars = total_len;
			iov_fault_in_pages_read(iov, chars);
redo2:
			if (atomic)
				src = kmap_atomic(page);
			else
				src = kmap(page);
			error = pipe_iov_copy_from_user(src, iov, chars,
							atomic);
			if (atomic)
				kunmap_atomic(src);
			else
				kunmap(page);
			if (unlikely(error)) {
				if (atomic) {
					atomic = 0;
					goto redo2;
				}
 				if (!ret)
					ret = error;
 				break;
 			}
			ret += chars;
 
 			/* Insert it into the buffer array */
 			buf->page = page;
 			buf->ops = &anon_pipe_buf_ops;
 			buf->offset = 0;
			buf->len = chars;
 			buf->flags = 0;
 			if (is_packetized(filp)) {
 				buf->ops = &packet_pipe_buf_ops;
				buf->flags = PIPE_BUF_FLAG_PACKET;
			}
 			pipe->nrbufs = ++bufs;
 			pipe->tmp_page = NULL;
 
			total_len -= chars;
			if (!total_len)
 				break;
 		}
 		if (bufs < pipe->buffers)
			continue;
		if (filp->f_flags & O_NONBLOCK) {
			if (!ret)
				ret = -EAGAIN;
			break;
		}
		if (signal_pending(current)) {
			if (!ret)
				ret = -ERESTARTSYS;
			break;
		}
		if (do_wakeup) {
			wake_up_interruptible_sync_poll(&pipe->wait, POLLIN | POLLRDNORM);
			kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
			do_wakeup = 0;
		}
		pipe->waiting_writers++;
		pipe_wait(pipe);
		pipe->waiting_writers--;
	}
out:
	__pipe_unlock(pipe);
	if (do_wakeup) {
		wake_up_interruptible_sync_poll(&pipe->wait, POLLIN | POLLRDNORM);
		kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
	}
	if (ret > 0 && sb_start_write_trylock(file_inode(filp)->i_sb)) {
		int err = file_update_time(filp);
		if (err)
			ret = err;
		sb_end_write(file_inode(filp)->i_sb);
	}
	return ret;
}
",C,"pipe_write(struct kiocb *iocb, struct iov_iter *from)
	ssize_t ret = 0;
	int do_wakeup = 0;
	size_t total_len = iov_iter_count(from);
			int error = ops->confirm(pipe, buf);
			ret = copy_page_from_iter(buf->page, offset, chars, from);
			if (unlikely(ret < chars)) {
				error = -EFAULT;
			do_wakeup = 1;
			if (!iov_iter_count(from))
			int copied;
			copied = copy_page_from_iter(page, 0, PAGE_SIZE, from);
			if (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {
					ret = -EFAULT;
			ret += copied;
			buf->len = copied;
			if (!iov_iter_count(from))
","	    unsigned long nr_segs, loff_t ppos)
	ssize_t ret;
	int do_wakeup;
	struct iovec *iov = (struct iovec *)_iov;
	size_t total_len;
	total_len = iov_length(iov, nr_segs);
	do_wakeup = 0;
	ret = 0;
			int error, atomic = 1;
			void *addr;
			error = ops->confirm(pipe, buf);
			iov_fault_in_pages_read(iov, chars);
redo1:
			if (atomic)
				addr = kmap_atomic(buf->page);
			else
				addr = kmap(buf->page);
			error = pipe_iov_copy_from_user(offset + addr, iov,
							chars, atomic);
			if (atomic)
				kunmap_atomic(addr);
			else
				kunmap(buf->page);
			ret = error;
			do_wakeup = 1;
			if (error) {
				if (atomic) {
					atomic = 0;
					goto redo1;
				}
			total_len -= chars;
			if (!total_len)
			char *src;
			int error, atomic = 1;
			chars = PAGE_SIZE;
			if (chars > total_len)
				chars = total_len;
			iov_fault_in_pages_read(iov, chars);
redo2:
			if (atomic)
				src = kmap_atomic(page);
			else
				src = kmap(page);
			error = pipe_iov_copy_from_user(src, iov, chars,
							atomic);
			if (atomic)
				kunmap_atomic(src);
			else
				kunmap(page);
			if (unlikely(error)) {
				if (atomic) {
					atomic = 0;
					goto redo2;
				}
					ret = error;
			ret += chars;
			buf->len = chars;
			total_len -= chars;
			if (!total_len)
",,"@@ -116,50 +116,6 @@ void pipe_wait(struct pipe_inode_info *pipe)
 	pipe_lock(pipe);
 }
 
-static int
-pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,
-			int atomic)
-{
-	unsigned long copy;
-
-	while (len > 0) {
-		while (!iov->iov_len)
-			iov++;
-		copy = min_t(unsigned long, len, iov->iov_len);
-
-		if (atomic) {
-			if (__copy_from_user_inatomic(to, iov->iov_base, copy))
-				return -EFAULT;
-		} else {
-			if (copy_from_user(to, iov->iov_base, copy))
-				return -EFAULT;
-		}
-		to += copy;
-		len -= copy;
-		iov->iov_base += copy;
-		iov->iov_len -= copy;
-	}
-	return 0;
-}
-
-/*
- * Pre-fault in the user memory, so we can use atomic copies.
- */
-static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)
-{
-	while (!iov->iov_len)
-		iov++;
-
-	while (len > 0) {
-		unsigned long this_len;
-
-		this_len = min_t(unsigned long, len, iov->iov_len);
-		fault_in_pages_readable(iov->iov_base, this_len);
-		len -= this_len;
-		iov++;
-	}
-}
-
 static void anon_pipe_buf_release(struct pipe_inode_info *pipe,
 				  struct pipe_buffer *buf)
 {
@@ -380,24 +336,19 @@ static inline int is_packetized(struct file *file)
 }
 
 static ssize_t
-pipe_write(struct kiocb *iocb, const struct iovec *_iov,
-	    unsigned long nr_segs, loff_t ppos)
+pipe_write(struct kiocb *iocb, struct iov_iter *from)
 {
 	struct file *filp = iocb->ki_filp;
 	struct pipe_inode_info *pipe = filp->private_data;
-	ssize_t ret;
-	int do_wakeup;
-	struct iovec *iov = (struct iovec *)_iov;
-	size_t total_len;
+	ssize_t ret = 0;
+	int do_wakeup = 0;
+	size_t total_len = iov_iter_count(from);
 	ssize_t chars;
 
-	total_len = iov_length(iov, nr_segs);
 	/* Null write succeeds. */
 	if (unlikely(total_len == 0))
 		return 0;
 
-	do_wakeup = 0;
-	ret = 0;
 	__pipe_lock(pipe);
 
 	if (!pipe->readers) {
@@ -416,38 +367,19 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 		int offset = buf->offset + buf->len;
 
 		if (ops->can_merge && offset + chars <= PAGE_SIZE) {
-			int error, atomic = 1;
-			void *addr;
-
-			error = ops->confirm(pipe, buf);
+			int error = ops->confirm(pipe, buf);
 			if (error)
 				goto out;
 
-			iov_fault_in_pages_read(iov, chars);
-redo1:
-			if (atomic)
-				addr = kmap_atomic(buf->page);
-			else
-				addr = kmap(buf->page);
-			error = pipe_iov_copy_from_user(offset + addr, iov,
-							chars, atomic);
-			if (atomic)
-				kunmap_atomic(addr);
-			else
-				kunmap(buf->page);
-			ret = error;
-			do_wakeup = 1;
-			if (error) {
-				if (atomic) {
-					atomic = 0;
-					goto redo1;
-				}
+			ret = copy_page_from_iter(buf->page, offset, chars, from);
+			if (unlikely(ret < chars)) {
+				error = -EFAULT;
 				goto out;
 			}
+			do_wakeup = 1;
 			buf->len += chars;
-			total_len -= chars;
 			ret = chars;
-			if (!total_len)
+			if (!iov_iter_count(from))
 				goto out;
 		}
 	}
@@ -466,8 +398,7 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 			int newbuf = (pipe->curbuf + bufs) & (pipe->buffers-1);
 			struct pipe_buffer *buf = pipe->bufs + newbuf;
 			struct page *page = pipe->tmp_page;
-			char *src;
-			int error, atomic = 1;
+			int copied;
 
 			if (!page) {
 				page = alloc_page(GFP_HIGHUSER);
@@ -483,40 +414,19 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 			 * FIXME! Is this really true?
 			 */
 			do_wakeup = 1;
-			chars = PAGE_SIZE;
-			if (chars > total_len)
-				chars = total_len;
-
-			iov_fault_in_pages_read(iov, chars);
-redo2:
-			if (atomic)
-				src = kmap_atomic(page);
-			else
-				src = kmap(page);
-
-			error = pipe_iov_copy_from_user(src, iov, chars,
-							atomic);
-			if (atomic)
-				kunmap_atomic(src);
-			else
-				kunmap(page);
-
-			if (unlikely(error)) {
-				if (atomic) {
-					atomic = 0;
-					goto redo2;
-				}
+			copied = copy_page_from_iter(page, 0, PAGE_SIZE, from);
+			if (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {
 				if (!ret)
-					ret = error;
+					ret = -EFAULT;
 				break;
 			}
-			ret += chars;
+			ret += copied;
 
 			/* Insert it into the buffer array */
 			buf->page = page;
 			buf->ops = &anon_pipe_buf_ops;
 			buf->offset = 0;
-			buf->len = chars;
+			buf->len = copied;
 			buf->flags = 0;
 			if (is_packetized(filp)) {
 				buf->ops = &packet_pipe_buf_ops;
@@ -525,8 +435,7 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 			pipe->nrbufs = ++bufs;
 			pipe->tmp_page = NULL;
 
-			total_len -= chars;
-			if (!total_len)
+			if (!iov_iter_count(from))
 				break;
 		}
 		if (bufs < pipe->buffers)
@@ -1040,8 +949,8 @@ const struct file_operations pipefifo_fops = {
 	.llseek		= no_llseek,
 	.read		= new_sync_read,
 	.read_iter	= pipe_read,
-	.write		= do_sync_write,
-	.aio_write	= pipe_write,
+	.write		= new_sync_write,
+	.write_iter	= pipe_write,
 	.poll		= pipe_poll,
 	.unlocked_ioctl	= pipe_ioctl,
 	.release	= pipe_release,",linux,f0d1bec9d58d4c038d0ac958c9af82be6eb18045,84c3d55cc474f9c234c023c92e2769f940d5548c,1,"pipe_write(struct kiocb *iocb, const struct iovec *_iov,
//flaw_line_below:
	    unsigned long nr_segs, loff_t ppos)
//fix_flaw_line_below:
//pipe_write(struct kiocb *iocb, struct iov_iter *from)
 {
 	struct file *filp = iocb->ki_filp;
 	struct pipe_inode_info *pipe = filp->private_data;
//flaw_line_below:
	ssize_t ret;
//flaw_line_below:
	int do_wakeup;
//flaw_line_below:
	struct iovec *iov = (struct iovec *)_iov;
//flaw_line_below:
	size_t total_len;
//fix_flaw_line_below:
//	ssize_t ret = 0;
//fix_flaw_line_below:
//	int do_wakeup = 0;
//fix_flaw_line_below:
//	size_t total_len = iov_iter_count(from);
 	ssize_t chars;
 
//flaw_line_below:
	total_len = iov_length(iov, nr_segs);
 	/* Null write succeeds. */
 	if (unlikely(total_len == 0))
 		return 0;
 
//flaw_line_below:
	do_wakeup = 0;
//flaw_line_below:
	ret = 0;
 	__pipe_lock(pipe);
 
 	if (!pipe->readers) {
		send_sig(SIGPIPE, current, 0);
		ret = -EPIPE;
		goto out;
	}

	/* We try to merge small writes */
	chars = total_len & (PAGE_SIZE-1); /* size of the last buffer */
	if (pipe->nrbufs && chars != 0) {
		int lastbuf = (pipe->curbuf + pipe->nrbufs - 1) &
							(pipe->buffers - 1);
		struct pipe_buffer *buf = pipe->bufs + lastbuf;
		const struct pipe_buf_operations *ops = buf->ops;
 		int offset = buf->offset + buf->len;
 
 		if (ops->can_merge && offset + chars <= PAGE_SIZE) {
//flaw_line_below:
			int error, atomic = 1;
//flaw_line_below:
			void *addr;
//flaw_line_below:

//flaw_line_below:
			error = ops->confirm(pipe, buf);
//fix_flaw_line_below:
//			int error = ops->confirm(pipe, buf);
 			if (error)
 				goto out;
 
//flaw_line_below:
			iov_fault_in_pages_read(iov, chars);
//flaw_line_below:
redo1:
//flaw_line_below:
			if (atomic)
//flaw_line_below:
				addr = kmap_atomic(buf->page);
//flaw_line_below:
			else
//flaw_line_below:
				addr = kmap(buf->page);
//flaw_line_below:
			error = pipe_iov_copy_from_user(offset + addr, iov,
//flaw_line_below:
							chars, atomic);
//flaw_line_below:
			if (atomic)
//flaw_line_below:
				kunmap_atomic(addr);
//flaw_line_below:
			else
//flaw_line_below:
				kunmap(buf->page);
//flaw_line_below:
			ret = error;
//flaw_line_below:
			do_wakeup = 1;
//flaw_line_below:
			if (error) {
//flaw_line_below:
				if (atomic) {
//flaw_line_below:
					atomic = 0;
//flaw_line_below:
					goto redo1;
//flaw_line_below:
				}
//fix_flaw_line_below:
//			ret = copy_page_from_iter(buf->page, offset, chars, from);
//fix_flaw_line_below:
//			if (unlikely(ret < chars)) {
//fix_flaw_line_below:
//				error = -EFAULT;
 				goto out;
 			}
//fix_flaw_line_below:
//			do_wakeup = 1;
 			buf->len += chars;
//flaw_line_below:
			total_len -= chars;
 			ret = chars;
//flaw_line_below:
			if (!total_len)
//fix_flaw_line_below:
//			if (!iov_iter_count(from))
 				goto out;
 		}
 	}

	for (;;) {
		int bufs;

		if (!pipe->readers) {
			send_sig(SIGPIPE, current, 0);
			if (!ret)
				ret = -EPIPE;
			break;
		}
		bufs = pipe->nrbufs;
		if (bufs < pipe->buffers) {
 			int newbuf = (pipe->curbuf + bufs) & (pipe->buffers-1);
 			struct pipe_buffer *buf = pipe->bufs + newbuf;
 			struct page *page = pipe->tmp_page;
//flaw_line_below:
			char *src;
//flaw_line_below:
			int error, atomic = 1;
//fix_flaw_line_below:
//			int copied;
 
 			if (!page) {
 				page = alloc_page(GFP_HIGHUSER);
				if (unlikely(!page)) {
					ret = ret ? : -ENOMEM;
					break;
				}
				pipe->tmp_page = page;
			}
			/* Always wake up, even if the copy fails. Otherwise
			 * we lock up (O_NONBLOCK-)readers that sleep due to
			 * syscall merging.
 			 * FIXME! Is this really true?
 			 */
 			do_wakeup = 1;
//flaw_line_below:
			chars = PAGE_SIZE;
//flaw_line_below:
			if (chars > total_len)
//flaw_line_below:
				chars = total_len;
//flaw_line_below:

//flaw_line_below:
			iov_fault_in_pages_read(iov, chars);
//flaw_line_below:
redo2:
//flaw_line_below:
			if (atomic)
//flaw_line_below:
				src = kmap_atomic(page);
//flaw_line_below:
			else
//flaw_line_below:
				src = kmap(page);
//flaw_line_below:

//flaw_line_below:
			error = pipe_iov_copy_from_user(src, iov, chars,
//flaw_line_below:
							atomic);
//flaw_line_below:
			if (atomic)
//flaw_line_below:
				kunmap_atomic(src);
//flaw_line_below:
			else
//flaw_line_below:
				kunmap(page);
//flaw_line_below:

//flaw_line_below:
			if (unlikely(error)) {
//flaw_line_below:
				if (atomic) {
//flaw_line_below:
					atomic = 0;
//flaw_line_below:
					goto redo2;
//flaw_line_below:
				}
//fix_flaw_line_below:
//			copied = copy_page_from_iter(page, 0, PAGE_SIZE, from);
//fix_flaw_line_below:
//			if (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {
 				if (!ret)
//flaw_line_below:
					ret = error;
//fix_flaw_line_below:
//					ret = -EFAULT;
 				break;
 			}
//flaw_line_below:
			ret += chars;
//fix_flaw_line_below:
//			ret += copied;
 
 			/* Insert it into the buffer array */
 			buf->page = page;
 			buf->ops = &anon_pipe_buf_ops;
 			buf->offset = 0;
//flaw_line_below:
			buf->len = chars;
//fix_flaw_line_below:
//			buf->len = copied;
 			buf->flags = 0;
 			if (is_packetized(filp)) {
 				buf->ops = &packet_pipe_buf_ops;
				buf->flags = PIPE_BUF_FLAG_PACKET;
			}
 			pipe->nrbufs = ++bufs;
 			pipe->tmp_page = NULL;
 
//flaw_line_below:
			total_len -= chars;
//flaw_line_below:
			if (!total_len)
//fix_flaw_line_below:
//			if (!iov_iter_count(from))
 				break;
 		}
 		if (bufs < pipe->buffers)
			continue;
		if (filp->f_flags & O_NONBLOCK) {
			if (!ret)
				ret = -EAGAIN;
			break;
		}
		if (signal_pending(current)) {
			if (!ret)
				ret = -ERESTARTSYS;
			break;
		}
		if (do_wakeup) {
			wake_up_interruptible_sync_poll(&pipe->wait, POLLIN | POLLRDNORM);
			kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
			do_wakeup = 0;
		}
		pipe->waiting_writers++;
		pipe_wait(pipe);
		pipe->waiting_writers--;
	}
out:
	__pipe_unlock(pipe);
	if (do_wakeup) {
		wake_up_interruptible_sync_poll(&pipe->wait, POLLIN | POLLRDNORM);
		kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
	}
	if (ret > 0 && sb_start_write_trylock(file_inode(filp)->i_sb)) {
		int err = file_update_time(filp);
		if (err)
			ret = err;
		sb_end_write(file_inode(filp)->i_sb);
	}
	return ret;
}
"
2133,179869,,Remote,Not required,Complete,CVE-2015-1465,https://www.cvedetails.com/cve/CVE-2015-1465/,CWE-17,Low,,,,2015-04-05,7.8,"The IPv4 implementation in the Linux kernel before 3.18.8 does not properly consider the length of the Read-Copy Update (RCU) grace period for redirecting lookups in the absence of caching, which allows remote attackers to cause a denial of service (memory consumption or system crash) via a flood of packets.",2017-08-12,DoS ,2,https://github.com/torvalds/linux/commit/df4d92549f23e1c037e83323aff58a21b3de7fe0,df4d92549f23e1c037e83323aff58a21b3de7fe0,"ipv4: try to cache dst_entries which would cause a redirect

Not caching dst_entries which cause redirects could be exploited by hosts
on the same subnet, causing a severe DoS attack. This effect aggravated
since commit f88649721268999 (""ipv4: fix dst race in sk_dst_get()"").

Lookups causing redirects will be allocated with DST_NOCACHE set which
will force dst_release to free them via RCU.  Unfortunately waiting for
RCU grace period just takes too long, we can end up with >1M dst_entries
waiting to be released and the system will run OOM. rcuos threads cannot
catch up under high softirq load.

Attaching the flag to emit a redirect later on to the specific skb allows
us to cache those dst_entries thus reducing the pressure on allocation
and deallocation.

This issue was discovered by Marcelo Leitner.

Cc: Julian Anastasov <ja@ssi.bg>
Signed-off-by: Marcelo Leitner <mleitner@redhat.com>
Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: Julian Anastasov <ja@ssi.bg>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/ipv4/ip_forward.c,"{""sha"": ""f7cbd703d15d24edca61cf9e159cb1ce3857cb5b"", ""filename"": ""include/net/ip.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 5, ""changes"": 11, ""blob_url"": ""https://github.com/torvalds/linux/blob/df4d92549f23e1c037e83323aff58a21b3de7fe0/include/net/ip.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/df4d92549f23e1c037e83323aff58a21b3de7fe0/include/net/ip.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/net/ip.h?ref=df4d92549f23e1c037e83323aff58a21b3de7fe0"", ""patch"": ""@@ -39,11 +39,12 @@ struct inet_skb_parm {\n \tstruct ip_options\topt;\t\t/* Compiled IP options\t\t*/\n \tunsigned char\t\tflags;\n \n-#define IPSKB_FORWARDED\t\t1\n-#define IPSKB_XFRM_TUNNEL_SIZE\t2\n-#define IPSKB_XFRM_TRANSFORMED\t4\n-#define IPSKB_FRAG_COMPLETE\t8\n-#define IPSKB_REROUTED\t\t16\n+#define IPSKB_FORWARDED\t\tBIT(0)\n+#define IPSKB_XFRM_TUNNEL_SIZE\tBIT(1)\n+#define IPSKB_XFRM_TRANSFORMED\tBIT(2)\n+#define IPSKB_FRAG_COMPLETE\tBIT(3)\n+#define IPSKB_REROUTED\t\tBIT(4)\n+#define IPSKB_DOREDIRECT\tBIT(5)\n \n \tu16\t\t\tfrag_max_size;\n };""}<_**next**_>{""sha"": ""787b3c294ce672244ce08c5426c03bbd1f71c0f3"", ""filename"": ""net/ipv4/ip_forward.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/df4d92549f23e1c037e83323aff58a21b3de7fe0/net/ipv4/ip_forward.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/df4d92549f23e1c037e83323aff58a21b3de7fe0/net/ipv4/ip_forward.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ip_forward.c?ref=df4d92549f23e1c037e83323aff58a21b3de7fe0"", ""patch"": ""@@ -129,7 +129,8 @@ int ip_forward(struct sk_buff *skb)\n \t *\tWe now generate an ICMP HOST REDIRECT giving the route\n \t *\twe calculated.\n \t */\n-\tif (rt->rt_flags&RTCF_DOREDIRECT && !opt->srr && !skb_sec_path(skb))\n+\tif (IPCB(skb)->flags & IPSKB_DOREDIRECT && !opt->srr &&\n+\t    !skb_sec_path(skb))\n \t\tip_rt_send_redirect(skb);\n \n \tskb->priority = rt_tos2priority(iph->tos);""}<_**next**_>{""sha"": ""d58dd0ec3e5302c2862c8fe53bfd43ca05a3e669"", ""filename"": ""net/ipv4/route.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/df4d92549f23e1c037e83323aff58a21b3de7fe0/net/ipv4/route.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/df4d92549f23e1c037e83323aff58a21b3de7fe0/net/ipv4/route.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/route.c?ref=df4d92549f23e1c037e83323aff58a21b3de7fe0"", ""patch"": ""@@ -1554,11 +1554,10 @@ static int __mkroute_input(struct sk_buff *skb,\n \n \tdo_cache = res->fi && !itag;\n \tif (out_dev == in_dev && err && IN_DEV_TX_REDIRECTS(out_dev) &&\n+\t    skb->protocol == htons(ETH_P_IP) &&\n \t    (IN_DEV_SHARED_MEDIA(out_dev) ||\n-\t     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res)))) {\n-\t\tflags |= RTCF_DOREDIRECT;\n-\t\tdo_cache = false;\n-\t}\n+\t     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res))))\n+\t\tIPCB(skb)->flags |= IPSKB_DOREDIRECT;\n \n \tif (skb->protocol != htons(ETH_P_IP)) {\n \t\t/* Not IP (i.e. ARP). Do not create route, if it is\n@@ -2303,6 +2302,8 @@ static int rt_fill_info(struct net *net,  __be32 dst, __be32 src,\n \tr->rtm_flags\t= (rt->rt_flags & ~0xFFFF) | RTM_F_CLONED;\n \tif (rt->rt_flags & RTCF_NOTIFY)\n \t\tr->rtm_flags |= RTM_F_NOTIFY;\n+\tif (IPCB(skb)->flags & IPSKB_DOREDIRECT)\n+\t\tr->rtm_flags |= RTCF_DOREDIRECT;\n \n \tif (nla_put_be32(skb, RTA_DST, dst))\n \t\tgoto nla_put_failure;""}","int ip_forward(struct sk_buff *skb)
{
	u32 mtu;
	struct iphdr *iph;	/* Our header */
	struct rtable *rt;	/* Route we use */
	struct ip_options *opt	= &(IPCB(skb)->opt);

	/* that should never happen */
	if (skb->pkt_type != PACKET_HOST)
		goto drop;

	if (skb_warn_if_lro(skb))
		goto drop;

	if (!xfrm4_policy_check(NULL, XFRM_POLICY_FWD, skb))
		goto drop;

	if (IPCB(skb)->opt.router_alert && ip_call_ra_chain(skb))
		return NET_RX_SUCCESS;

	skb_forward_csum(skb);

	/*
	 *	According to the RFC, we must first decrease the TTL field. If
	 *	that reaches zero, we must reply an ICMP control message telling
	 *	that the packet's lifetime expired.
	 */
	if (ip_hdr(skb)->ttl <= 1)
		goto too_many_hops;

	if (!xfrm4_route_forward(skb))
		goto drop;

	rt = skb_rtable(skb);

	if (opt->is_strictroute && rt->rt_uses_gateway)
		goto sr_failed;

	IPCB(skb)->flags |= IPSKB_FORWARDED;
	mtu = ip_dst_mtu_maybe_forward(&rt->dst, true);
	if (!ip_may_fragment(skb) && ip_exceeds_mtu(skb, mtu)) {
		IP_INC_STATS(dev_net(rt->dst.dev), IPSTATS_MIB_FRAGFAILS);
		icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
			  htonl(mtu));
		goto drop;
	}

	/* We are about to mangle packet. Copy it! */
	if (skb_cow(skb, LL_RESERVED_SPACE(rt->dst.dev)+rt->dst.header_len))
		goto drop;
	iph = ip_hdr(skb);

	/* Decrease ttl after skb cow done */
	ip_decrease_ttl(iph);

	/*
 	 *	We now generate an ICMP HOST REDIRECT giving the route
 	 *	we calculated.
 	 */
	if (IPCB(skb)->flags & IPSKB_DOREDIRECT && !opt->srr &&
	    !skb_sec_path(skb))
 		ip_rt_send_redirect(skb);
 
 	skb->priority = rt_tos2priority(iph->tos);

	return NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD, skb, skb->dev,
		       rt->dst.dev, ip_forward_finish);

sr_failed:
	/*
	 *	Strict routing permits no gatewaying
	 */
	 icmp_send(skb, ICMP_DEST_UNREACH, ICMP_SR_FAILED, 0);
	 goto drop;

too_many_hops:
	/* Tell the sender its packet died... */
	IP_INC_STATS_BH(dev_net(skb_dst(skb)->dev), IPSTATS_MIB_INHDRERRORS);
	icmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);
drop:
	kfree_skb(skb);
	return NET_RX_DROP;
}
","int ip_forward(struct sk_buff *skb)
{
	u32 mtu;
	struct iphdr *iph;	/* Our header */
	struct rtable *rt;	/* Route we use */
	struct ip_options *opt	= &(IPCB(skb)->opt);

	/* that should never happen */
	if (skb->pkt_type != PACKET_HOST)
		goto drop;

	if (skb_warn_if_lro(skb))
		goto drop;

	if (!xfrm4_policy_check(NULL, XFRM_POLICY_FWD, skb))
		goto drop;

	if (IPCB(skb)->opt.router_alert && ip_call_ra_chain(skb))
		return NET_RX_SUCCESS;

	skb_forward_csum(skb);

	/*
	 *	According to the RFC, we must first decrease the TTL field. If
	 *	that reaches zero, we must reply an ICMP control message telling
	 *	that the packet's lifetime expired.
	 */
	if (ip_hdr(skb)->ttl <= 1)
		goto too_many_hops;

	if (!xfrm4_route_forward(skb))
		goto drop;

	rt = skb_rtable(skb);

	if (opt->is_strictroute && rt->rt_uses_gateway)
		goto sr_failed;

	IPCB(skb)->flags |= IPSKB_FORWARDED;
	mtu = ip_dst_mtu_maybe_forward(&rt->dst, true);
	if (!ip_may_fragment(skb) && ip_exceeds_mtu(skb, mtu)) {
		IP_INC_STATS(dev_net(rt->dst.dev), IPSTATS_MIB_FRAGFAILS);
		icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
			  htonl(mtu));
		goto drop;
	}

	/* We are about to mangle packet. Copy it! */
	if (skb_cow(skb, LL_RESERVED_SPACE(rt->dst.dev)+rt->dst.header_len))
		goto drop;
	iph = ip_hdr(skb);

	/* Decrease ttl after skb cow done */
	ip_decrease_ttl(iph);

	/*
 	 *	We now generate an ICMP HOST REDIRECT giving the route
 	 *	we calculated.
 	 */
	if (rt->rt_flags&RTCF_DOREDIRECT && !opt->srr && !skb_sec_path(skb))
 		ip_rt_send_redirect(skb);
 
 	skb->priority = rt_tos2priority(iph->tos);

	return NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD, skb, skb->dev,
		       rt->dst.dev, ip_forward_finish);

sr_failed:
	/*
	 *	Strict routing permits no gatewaying
	 */
	 icmp_send(skb, ICMP_DEST_UNREACH, ICMP_SR_FAILED, 0);
	 goto drop;

too_many_hops:
	/* Tell the sender its packet died... */
	IP_INC_STATS_BH(dev_net(skb_dst(skb)->dev), IPSTATS_MIB_INHDRERRORS);
	icmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);
drop:
	kfree_skb(skb);
	return NET_RX_DROP;
}
",C,"	if (IPCB(skb)->flags & IPSKB_DOREDIRECT && !opt->srr &&
	    !skb_sec_path(skb))
","	if (rt->rt_flags&RTCF_DOREDIRECT && !opt->srr && !skb_sec_path(skb))
",,"@@ -129,7 +129,8 @@ int ip_forward(struct sk_buff *skb)
 	 *	We now generate an ICMP HOST REDIRECT giving the route
 	 *	we calculated.
 	 */
-	if (rt->rt_flags&RTCF_DOREDIRECT && !opt->srr && !skb_sec_path(skb))
+	if (IPCB(skb)->flags & IPSKB_DOREDIRECT && !opt->srr &&
+	    !skb_sec_path(skb))
 		ip_rt_send_redirect(skb);
 
 	skb->priority = rt_tos2priority(iph->tos);",linux,df4d92549f23e1c037e83323aff58a21b3de7fe0,412d2907c41531b60c7ea1f38cfe1116daf2a229,1,"int ip_forward(struct sk_buff *skb)
{
	u32 mtu;
	struct iphdr *iph;	/* Our header */
	struct rtable *rt;	/* Route we use */
	struct ip_options *opt	= &(IPCB(skb)->opt);

	/* that should never happen */
	if (skb->pkt_type != PACKET_HOST)
		goto drop;

	if (skb_warn_if_lro(skb))
		goto drop;

	if (!xfrm4_policy_check(NULL, XFRM_POLICY_FWD, skb))
		goto drop;

	if (IPCB(skb)->opt.router_alert && ip_call_ra_chain(skb))
		return NET_RX_SUCCESS;

	skb_forward_csum(skb);

	/*
	 *	According to the RFC, we must first decrease the TTL field. If
	 *	that reaches zero, we must reply an ICMP control message telling
	 *	that the packet's lifetime expired.
	 */
	if (ip_hdr(skb)->ttl <= 1)
		goto too_many_hops;

	if (!xfrm4_route_forward(skb))
		goto drop;

	rt = skb_rtable(skb);

	if (opt->is_strictroute && rt->rt_uses_gateway)
		goto sr_failed;

	IPCB(skb)->flags |= IPSKB_FORWARDED;
	mtu = ip_dst_mtu_maybe_forward(&rt->dst, true);
	if (!ip_may_fragment(skb) && ip_exceeds_mtu(skb, mtu)) {
		IP_INC_STATS(dev_net(rt->dst.dev), IPSTATS_MIB_FRAGFAILS);
		icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
			  htonl(mtu));
		goto drop;
	}

	/* We are about to mangle packet. Copy it! */
	if (skb_cow(skb, LL_RESERVED_SPACE(rt->dst.dev)+rt->dst.header_len))
		goto drop;
	iph = ip_hdr(skb);

	/* Decrease ttl after skb cow done */
	ip_decrease_ttl(iph);

	/*
 	 *	We now generate an ICMP HOST REDIRECT giving the route
 	 *	we calculated.
 	 */
//flaw_line_below:
	if (rt->rt_flags&RTCF_DOREDIRECT && !opt->srr && !skb_sec_path(skb))
//fix_flaw_line_below:
//	if (IPCB(skb)->flags & IPSKB_DOREDIRECT && !opt->srr &&
//fix_flaw_line_below:
//	    !skb_sec_path(skb))
 		ip_rt_send_redirect(skb);
 
 	skb->priority = rt_tos2priority(iph->tos);

	return NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD, skb, skb->dev,
		       rt->dst.dev, ip_forward_finish);

sr_failed:
	/*
	 *	Strict routing permits no gatewaying
	 */
	 icmp_send(skb, ICMP_DEST_UNREACH, ICMP_SR_FAILED, 0);
	 goto drop;

too_many_hops:
	/* Tell the sender its packet died... */
	IP_INC_STATS_BH(dev_net(skb_dst(skb)->dev), IPSTATS_MIB_INHDRERRORS);
	icmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);
drop:
	kfree_skb(skb);
	return NET_RX_DROP;
}
"
2134,179870,,Remote,Not required,Complete,CVE-2015-1465,https://www.cvedetails.com/cve/CVE-2015-1465/,CWE-17,Low,,,,2015-04-05,7.8,"The IPv4 implementation in the Linux kernel before 3.18.8 does not properly consider the length of the Read-Copy Update (RCU) grace period for redirecting lookups in the absence of caching, which allows remote attackers to cause a denial of service (memory consumption or system crash) via a flood of packets.",2017-08-12,DoS ,3,https://github.com/torvalds/linux/commit/df4d92549f23e1c037e83323aff58a21b3de7fe0,df4d92549f23e1c037e83323aff58a21b3de7fe0,"ipv4: try to cache dst_entries which would cause a redirect

Not caching dst_entries which cause redirects could be exploited by hosts
on the same subnet, causing a severe DoS attack. This effect aggravated
since commit f88649721268999 (""ipv4: fix dst race in sk_dst_get()"").

Lookups causing redirects will be allocated with DST_NOCACHE set which
will force dst_release to free them via RCU.  Unfortunately waiting for
RCU grace period just takes too long, we can end up with >1M dst_entries
waiting to be released and the system will run OOM. rcuos threads cannot
catch up under high softirq load.

Attaching the flag to emit a redirect later on to the specific skb allows
us to cache those dst_entries thus reducing the pressure on allocation
and deallocation.

This issue was discovered by Marcelo Leitner.

Cc: Julian Anastasov <ja@ssi.bg>
Signed-off-by: Marcelo Leitner <mleitner@redhat.com>
Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: Julian Anastasov <ja@ssi.bg>
Signed-off-by: David S. Miller <davem@davemloft.net>",4,net/ipv4/route.c,"{""sha"": ""f7cbd703d15d24edca61cf9e159cb1ce3857cb5b"", ""filename"": ""include/net/ip.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 5, ""changes"": 11, ""blob_url"": ""https://github.com/torvalds/linux/blob/df4d92549f23e1c037e83323aff58a21b3de7fe0/include/net/ip.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/df4d92549f23e1c037e83323aff58a21b3de7fe0/include/net/ip.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/net/ip.h?ref=df4d92549f23e1c037e83323aff58a21b3de7fe0"", ""patch"": ""@@ -39,11 +39,12 @@ struct inet_skb_parm {\n \tstruct ip_options\topt;\t\t/* Compiled IP options\t\t*/\n \tunsigned char\t\tflags;\n \n-#define IPSKB_FORWARDED\t\t1\n-#define IPSKB_XFRM_TUNNEL_SIZE\t2\n-#define IPSKB_XFRM_TRANSFORMED\t4\n-#define IPSKB_FRAG_COMPLETE\t8\n-#define IPSKB_REROUTED\t\t16\n+#define IPSKB_FORWARDED\t\tBIT(0)\n+#define IPSKB_XFRM_TUNNEL_SIZE\tBIT(1)\n+#define IPSKB_XFRM_TRANSFORMED\tBIT(2)\n+#define IPSKB_FRAG_COMPLETE\tBIT(3)\n+#define IPSKB_REROUTED\t\tBIT(4)\n+#define IPSKB_DOREDIRECT\tBIT(5)\n \n \tu16\t\t\tfrag_max_size;\n };""}<_**next**_>{""sha"": ""787b3c294ce672244ce08c5426c03bbd1f71c0f3"", ""filename"": ""net/ipv4/ip_forward.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/df4d92549f23e1c037e83323aff58a21b3de7fe0/net/ipv4/ip_forward.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/df4d92549f23e1c037e83323aff58a21b3de7fe0/net/ipv4/ip_forward.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ip_forward.c?ref=df4d92549f23e1c037e83323aff58a21b3de7fe0"", ""patch"": ""@@ -129,7 +129,8 @@ int ip_forward(struct sk_buff *skb)\n \t *\tWe now generate an ICMP HOST REDIRECT giving the route\n \t *\twe calculated.\n \t */\n-\tif (rt->rt_flags&RTCF_DOREDIRECT && !opt->srr && !skb_sec_path(skb))\n+\tif (IPCB(skb)->flags & IPSKB_DOREDIRECT && !opt->srr &&\n+\t    !skb_sec_path(skb))\n \t\tip_rt_send_redirect(skb);\n \n \tskb->priority = rt_tos2priority(iph->tos);""}<_**next**_>{""sha"": ""d58dd0ec3e5302c2862c8fe53bfd43ca05a3e669"", ""filename"": ""net/ipv4/route.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/df4d92549f23e1c037e83323aff58a21b3de7fe0/net/ipv4/route.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/df4d92549f23e1c037e83323aff58a21b3de7fe0/net/ipv4/route.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/route.c?ref=df4d92549f23e1c037e83323aff58a21b3de7fe0"", ""patch"": ""@@ -1554,11 +1554,10 @@ static int __mkroute_input(struct sk_buff *skb,\n \n \tdo_cache = res->fi && !itag;\n \tif (out_dev == in_dev && err && IN_DEV_TX_REDIRECTS(out_dev) &&\n+\t    skb->protocol == htons(ETH_P_IP) &&\n \t    (IN_DEV_SHARED_MEDIA(out_dev) ||\n-\t     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res)))) {\n-\t\tflags |= RTCF_DOREDIRECT;\n-\t\tdo_cache = false;\n-\t}\n+\t     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res))))\n+\t\tIPCB(skb)->flags |= IPSKB_DOREDIRECT;\n \n \tif (skb->protocol != htons(ETH_P_IP)) {\n \t\t/* Not IP (i.e. ARP). Do not create route, if it is\n@@ -2303,6 +2302,8 @@ static int rt_fill_info(struct net *net,  __be32 dst, __be32 src,\n \tr->rtm_flags\t= (rt->rt_flags & ~0xFFFF) | RTM_F_CLONED;\n \tif (rt->rt_flags & RTCF_NOTIFY)\n \t\tr->rtm_flags |= RTM_F_NOTIFY;\n+\tif (IPCB(skb)->flags & IPSKB_DOREDIRECT)\n+\t\tr->rtm_flags |= RTCF_DOREDIRECT;\n \n \tif (nla_put_be32(skb, RTA_DST, dst))\n \t\tgoto nla_put_failure;""}","static int __mkroute_input(struct sk_buff *skb,
			   const struct fib_result *res,
			   struct in_device *in_dev,
			   __be32 daddr, __be32 saddr, u32 tos)
{
	struct fib_nh_exception *fnhe;
	struct rtable *rth;
	int err;
	struct in_device *out_dev;
	unsigned int flags = 0;
	bool do_cache;
	u32 itag = 0;

	/* get a working reference to the output device */
	out_dev = __in_dev_get_rcu(FIB_RES_DEV(*res));
	if (out_dev == NULL) {
		net_crit_ratelimited(""Bug in ip_route_input_slow(). Please report.\n"");
		return -EINVAL;
	}

	err = fib_validate_source(skb, saddr, daddr, tos, FIB_RES_OIF(*res),
				  in_dev->dev, in_dev, &itag);
	if (err < 0) {
		ip_handle_martian_source(in_dev->dev, in_dev, skb, daddr,
					 saddr);

		goto cleanup;
	}
 
 	do_cache = res->fi && !itag;
 	if (out_dev == in_dev && err && IN_DEV_TX_REDIRECTS(out_dev) &&
	    skb->protocol == htons(ETH_P_IP) &&
 	    (IN_DEV_SHARED_MEDIA(out_dev) ||
	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res))))
		IPCB(skb)->flags |= IPSKB_DOREDIRECT;
 
 	if (skb->protocol != htons(ETH_P_IP)) {
 		/* Not IP (i.e. ARP). Do not create route, if it is
		 * invalid for proxy arp. DNAT routes are always valid.
		 *
		 * Proxy arp feature have been extended to allow, ARP
		 * replies back to the same interface, to support
		 * Private VLAN switch technologies. See arp.c.
		 */
		if (out_dev == in_dev &&
		    IN_DEV_PROXY_ARP_PVLAN(in_dev) == 0) {
			err = -EINVAL;
			goto cleanup;
		}
	}

	fnhe = find_exception(&FIB_RES_NH(*res), daddr);
	if (do_cache) {
		if (fnhe != NULL)
			rth = rcu_dereference(fnhe->fnhe_rth_input);
		else
			rth = rcu_dereference(FIB_RES_NH(*res).nh_rth_input);

		if (rt_cache_valid(rth)) {
			skb_dst_set_noref(skb, &rth->dst);
			goto out;
		}
	}

	rth = rt_dst_alloc(out_dev->dev,
			   IN_DEV_CONF_GET(in_dev, NOPOLICY),
			   IN_DEV_CONF_GET(out_dev, NOXFRM), do_cache);
	if (!rth) {
		err = -ENOBUFS;
		goto cleanup;
	}

	rth->rt_genid = rt_genid_ipv4(dev_net(rth->dst.dev));
	rth->rt_flags = flags;
	rth->rt_type = res->type;
	rth->rt_is_input = 1;
	rth->rt_iif 	= 0;
	rth->rt_pmtu	= 0;
	rth->rt_gateway	= 0;
	rth->rt_uses_gateway = 0;
	INIT_LIST_HEAD(&rth->rt_uncached);
	RT_CACHE_STAT_INC(in_slow_tot);

	rth->dst.input = ip_forward;
	rth->dst.output = ip_output;

	rt_set_nexthop(rth, daddr, res, fnhe, res->fi, res->type, itag);
	skb_dst_set(skb, &rth->dst);
out:
	err = 0;
 cleanup:
	return err;
}
","static int __mkroute_input(struct sk_buff *skb,
			   const struct fib_result *res,
			   struct in_device *in_dev,
			   __be32 daddr, __be32 saddr, u32 tos)
{
	struct fib_nh_exception *fnhe;
	struct rtable *rth;
	int err;
	struct in_device *out_dev;
	unsigned int flags = 0;
	bool do_cache;
	u32 itag = 0;

	/* get a working reference to the output device */
	out_dev = __in_dev_get_rcu(FIB_RES_DEV(*res));
	if (out_dev == NULL) {
		net_crit_ratelimited(""Bug in ip_route_input_slow(). Please report.\n"");
		return -EINVAL;
	}

	err = fib_validate_source(skb, saddr, daddr, tos, FIB_RES_OIF(*res),
				  in_dev->dev, in_dev, &itag);
	if (err < 0) {
		ip_handle_martian_source(in_dev->dev, in_dev, skb, daddr,
					 saddr);

		goto cleanup;
	}
 
 	do_cache = res->fi && !itag;
 	if (out_dev == in_dev && err && IN_DEV_TX_REDIRECTS(out_dev) &&
 	    (IN_DEV_SHARED_MEDIA(out_dev) ||
	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res)))) {
		flags |= RTCF_DOREDIRECT;
		do_cache = false;
	}
 
 	if (skb->protocol != htons(ETH_P_IP)) {
 		/* Not IP (i.e. ARP). Do not create route, if it is
		 * invalid for proxy arp. DNAT routes are always valid.
		 *
		 * Proxy arp feature have been extended to allow, ARP
		 * replies back to the same interface, to support
		 * Private VLAN switch technologies. See arp.c.
		 */
		if (out_dev == in_dev &&
		    IN_DEV_PROXY_ARP_PVLAN(in_dev) == 0) {
			err = -EINVAL;
			goto cleanup;
		}
	}

	fnhe = find_exception(&FIB_RES_NH(*res), daddr);
	if (do_cache) {
		if (fnhe != NULL)
			rth = rcu_dereference(fnhe->fnhe_rth_input);
		else
			rth = rcu_dereference(FIB_RES_NH(*res).nh_rth_input);

		if (rt_cache_valid(rth)) {
			skb_dst_set_noref(skb, &rth->dst);
			goto out;
		}
	}

	rth = rt_dst_alloc(out_dev->dev,
			   IN_DEV_CONF_GET(in_dev, NOPOLICY),
			   IN_DEV_CONF_GET(out_dev, NOXFRM), do_cache);
	if (!rth) {
		err = -ENOBUFS;
		goto cleanup;
	}

	rth->rt_genid = rt_genid_ipv4(dev_net(rth->dst.dev));
	rth->rt_flags = flags;
	rth->rt_type = res->type;
	rth->rt_is_input = 1;
	rth->rt_iif 	= 0;
	rth->rt_pmtu	= 0;
	rth->rt_gateway	= 0;
	rth->rt_uses_gateway = 0;
	INIT_LIST_HEAD(&rth->rt_uncached);
	RT_CACHE_STAT_INC(in_slow_tot);

	rth->dst.input = ip_forward;
	rth->dst.output = ip_output;

	rt_set_nexthop(rth, daddr, res, fnhe, res->fi, res->type, itag);
	skb_dst_set(skb, &rth->dst);
out:
	err = 0;
 cleanup:
	return err;
}
",C,"	    skb->protocol == htons(ETH_P_IP) &&
	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res))))
		IPCB(skb)->flags |= IPSKB_DOREDIRECT;
","	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res)))) {
		flags |= RTCF_DOREDIRECT;
		do_cache = false;
	}
",,"@@ -1554,11 +1554,10 @@ static int __mkroute_input(struct sk_buff *skb,
 
 	do_cache = res->fi && !itag;
 	if (out_dev == in_dev && err && IN_DEV_TX_REDIRECTS(out_dev) &&
+	    skb->protocol == htons(ETH_P_IP) &&
 	    (IN_DEV_SHARED_MEDIA(out_dev) ||
-	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res)))) {
-		flags |= RTCF_DOREDIRECT;
-		do_cache = false;
-	}
+	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res))))
+		IPCB(skb)->flags |= IPSKB_DOREDIRECT;
 
 	if (skb->protocol != htons(ETH_P_IP)) {
 		/* Not IP (i.e. ARP). Do not create route, if it is
@@ -2303,6 +2302,8 @@ static int rt_fill_info(struct net *net,  __be32 dst, __be32 src,
 	r->rtm_flags	= (rt->rt_flags & ~0xFFFF) | RTM_F_CLONED;
 	if (rt->rt_flags & RTCF_NOTIFY)
 		r->rtm_flags |= RTM_F_NOTIFY;
+	if (IPCB(skb)->flags & IPSKB_DOREDIRECT)
+		r->rtm_flags |= RTCF_DOREDIRECT;
 
 	if (nla_put_be32(skb, RTA_DST, dst))
 		goto nla_put_failure;",linux,df4d92549f23e1c037e83323aff58a21b3de7fe0,412d2907c41531b60c7ea1f38cfe1116daf2a229,1,"static int __mkroute_input(struct sk_buff *skb,
			   const struct fib_result *res,
			   struct in_device *in_dev,
			   __be32 daddr, __be32 saddr, u32 tos)
{
	struct fib_nh_exception *fnhe;
	struct rtable *rth;
	int err;
	struct in_device *out_dev;
	unsigned int flags = 0;
	bool do_cache;
	u32 itag = 0;

	/* get a working reference to the output device */
	out_dev = __in_dev_get_rcu(FIB_RES_DEV(*res));
	if (out_dev == NULL) {
		net_crit_ratelimited(""Bug in ip_route_input_slow(). Please report.\n"");
		return -EINVAL;
	}

	err = fib_validate_source(skb, saddr, daddr, tos, FIB_RES_OIF(*res),
				  in_dev->dev, in_dev, &itag);
	if (err < 0) {
		ip_handle_martian_source(in_dev->dev, in_dev, skb, daddr,
					 saddr);

		goto cleanup;
	}
 
 	do_cache = res->fi && !itag;
 	if (out_dev == in_dev && err && IN_DEV_TX_REDIRECTS(out_dev) &&
//fix_flaw_line_below:
//	    skb->protocol == htons(ETH_P_IP) &&
 	    (IN_DEV_SHARED_MEDIA(out_dev) ||
//flaw_line_below:
	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res)))) {
//flaw_line_below:
		flags |= RTCF_DOREDIRECT;
//flaw_line_below:
		do_cache = false;
//flaw_line_below:
	}
//fix_flaw_line_below:
//	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res))))
//fix_flaw_line_below:
//		IPCB(skb)->flags |= IPSKB_DOREDIRECT;
 
 	if (skb->protocol != htons(ETH_P_IP)) {
 		/* Not IP (i.e. ARP). Do not create route, if it is
		 * invalid for proxy arp. DNAT routes are always valid.
		 *
		 * Proxy arp feature have been extended to allow, ARP
		 * replies back to the same interface, to support
		 * Private VLAN switch technologies. See arp.c.
		 */
		if (out_dev == in_dev &&
		    IN_DEV_PROXY_ARP_PVLAN(in_dev) == 0) {
			err = -EINVAL;
			goto cleanup;
		}
	}

	fnhe = find_exception(&FIB_RES_NH(*res), daddr);
	if (do_cache) {
		if (fnhe != NULL)
			rth = rcu_dereference(fnhe->fnhe_rth_input);
		else
			rth = rcu_dereference(FIB_RES_NH(*res).nh_rth_input);

		if (rt_cache_valid(rth)) {
			skb_dst_set_noref(skb, &rth->dst);
			goto out;
		}
	}

	rth = rt_dst_alloc(out_dev->dev,
			   IN_DEV_CONF_GET(in_dev, NOPOLICY),
			   IN_DEV_CONF_GET(out_dev, NOXFRM), do_cache);
	if (!rth) {
		err = -ENOBUFS;
		goto cleanup;
	}

	rth->rt_genid = rt_genid_ipv4(dev_net(rth->dst.dev));
	rth->rt_flags = flags;
	rth->rt_type = res->type;
	rth->rt_is_input = 1;
	rth->rt_iif 	= 0;
	rth->rt_pmtu	= 0;
	rth->rt_gateway	= 0;
	rth->rt_uses_gateway = 0;
	INIT_LIST_HEAD(&rth->rt_uncached);
	RT_CACHE_STAT_INC(in_slow_tot);

	rth->dst.input = ip_forward;
	rth->dst.output = ip_output;

	rt_set_nexthop(rth, daddr, res, fnhe, res->fi, res->type, itag);
	skb_dst_set(skb, &rth->dst);
out:
	err = 0;
 cleanup:
	return err;
}
"
2135,179871,,Remote,Not required,Complete,CVE-2015-1465,https://www.cvedetails.com/cve/CVE-2015-1465/,CWE-17,Low,,,,2015-04-05,7.8,"The IPv4 implementation in the Linux kernel before 3.18.8 does not properly consider the length of the Read-Copy Update (RCU) grace period for redirecting lookups in the absence of caching, which allows remote attackers to cause a denial of service (memory consumption or system crash) via a flood of packets.",2017-08-12,DoS ,2,https://github.com/torvalds/linux/commit/df4d92549f23e1c037e83323aff58a21b3de7fe0,df4d92549f23e1c037e83323aff58a21b3de7fe0,"ipv4: try to cache dst_entries which would cause a redirect

Not caching dst_entries which cause redirects could be exploited by hosts
on the same subnet, causing a severe DoS attack. This effect aggravated
since commit f88649721268999 (""ipv4: fix dst race in sk_dst_get()"").

Lookups causing redirects will be allocated with DST_NOCACHE set which
will force dst_release to free them via RCU.  Unfortunately waiting for
RCU grace period just takes too long, we can end up with >1M dst_entries
waiting to be released and the system will run OOM. rcuos threads cannot
catch up under high softirq load.

Attaching the flag to emit a redirect later on to the specific skb allows
us to cache those dst_entries thus reducing the pressure on allocation
and deallocation.

This issue was discovered by Marcelo Leitner.

Cc: Julian Anastasov <ja@ssi.bg>
Signed-off-by: Marcelo Leitner <mleitner@redhat.com>
Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: Julian Anastasov <ja@ssi.bg>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/ipv4/route.c,"{""sha"": ""f7cbd703d15d24edca61cf9e159cb1ce3857cb5b"", ""filename"": ""include/net/ip.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 5, ""changes"": 11, ""blob_url"": ""https://github.com/torvalds/linux/blob/df4d92549f23e1c037e83323aff58a21b3de7fe0/include/net/ip.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/df4d92549f23e1c037e83323aff58a21b3de7fe0/include/net/ip.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/net/ip.h?ref=df4d92549f23e1c037e83323aff58a21b3de7fe0"", ""patch"": ""@@ -39,11 +39,12 @@ struct inet_skb_parm {\n \tstruct ip_options\topt;\t\t/* Compiled IP options\t\t*/\n \tunsigned char\t\tflags;\n \n-#define IPSKB_FORWARDED\t\t1\n-#define IPSKB_XFRM_TUNNEL_SIZE\t2\n-#define IPSKB_XFRM_TRANSFORMED\t4\n-#define IPSKB_FRAG_COMPLETE\t8\n-#define IPSKB_REROUTED\t\t16\n+#define IPSKB_FORWARDED\t\tBIT(0)\n+#define IPSKB_XFRM_TUNNEL_SIZE\tBIT(1)\n+#define IPSKB_XFRM_TRANSFORMED\tBIT(2)\n+#define IPSKB_FRAG_COMPLETE\tBIT(3)\n+#define IPSKB_REROUTED\t\tBIT(4)\n+#define IPSKB_DOREDIRECT\tBIT(5)\n \n \tu16\t\t\tfrag_max_size;\n };""}<_**next**_>{""sha"": ""787b3c294ce672244ce08c5426c03bbd1f71c0f3"", ""filename"": ""net/ipv4/ip_forward.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/df4d92549f23e1c037e83323aff58a21b3de7fe0/net/ipv4/ip_forward.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/df4d92549f23e1c037e83323aff58a21b3de7fe0/net/ipv4/ip_forward.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ip_forward.c?ref=df4d92549f23e1c037e83323aff58a21b3de7fe0"", ""patch"": ""@@ -129,7 +129,8 @@ int ip_forward(struct sk_buff *skb)\n \t *\tWe now generate an ICMP HOST REDIRECT giving the route\n \t *\twe calculated.\n \t */\n-\tif (rt->rt_flags&RTCF_DOREDIRECT && !opt->srr && !skb_sec_path(skb))\n+\tif (IPCB(skb)->flags & IPSKB_DOREDIRECT && !opt->srr &&\n+\t    !skb_sec_path(skb))\n \t\tip_rt_send_redirect(skb);\n \n \tskb->priority = rt_tos2priority(iph->tos);""}<_**next**_>{""sha"": ""d58dd0ec3e5302c2862c8fe53bfd43ca05a3e669"", ""filename"": ""net/ipv4/route.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/df4d92549f23e1c037e83323aff58a21b3de7fe0/net/ipv4/route.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/df4d92549f23e1c037e83323aff58a21b3de7fe0/net/ipv4/route.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/route.c?ref=df4d92549f23e1c037e83323aff58a21b3de7fe0"", ""patch"": ""@@ -1554,11 +1554,10 @@ static int __mkroute_input(struct sk_buff *skb,\n \n \tdo_cache = res->fi && !itag;\n \tif (out_dev == in_dev && err && IN_DEV_TX_REDIRECTS(out_dev) &&\n+\t    skb->protocol == htons(ETH_P_IP) &&\n \t    (IN_DEV_SHARED_MEDIA(out_dev) ||\n-\t     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res)))) {\n-\t\tflags |= RTCF_DOREDIRECT;\n-\t\tdo_cache = false;\n-\t}\n+\t     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res))))\n+\t\tIPCB(skb)->flags |= IPSKB_DOREDIRECT;\n \n \tif (skb->protocol != htons(ETH_P_IP)) {\n \t\t/* Not IP (i.e. ARP). Do not create route, if it is\n@@ -2303,6 +2302,8 @@ static int rt_fill_info(struct net *net,  __be32 dst, __be32 src,\n \tr->rtm_flags\t= (rt->rt_flags & ~0xFFFF) | RTM_F_CLONED;\n \tif (rt->rt_flags & RTCF_NOTIFY)\n \t\tr->rtm_flags |= RTM_F_NOTIFY;\n+\tif (IPCB(skb)->flags & IPSKB_DOREDIRECT)\n+\t\tr->rtm_flags |= RTCF_DOREDIRECT;\n \n \tif (nla_put_be32(skb, RTA_DST, dst))\n \t\tgoto nla_put_failure;""}","static int rt_fill_info(struct net *net,  __be32 dst, __be32 src,
			struct flowi4 *fl4, struct sk_buff *skb, u32 portid,
			u32 seq, int event, int nowait, unsigned int flags)
{
	struct rtable *rt = skb_rtable(skb);
	struct rtmsg *r;
	struct nlmsghdr *nlh;
	unsigned long expires = 0;
	u32 error;
	u32 metrics[RTAX_MAX];

	nlh = nlmsg_put(skb, portid, seq, event, sizeof(*r), flags);
	if (nlh == NULL)
		return -EMSGSIZE;

	r = nlmsg_data(nlh);
	r->rtm_family	 = AF_INET;
	r->rtm_dst_len	= 32;
	r->rtm_src_len	= 0;
	r->rtm_tos	= fl4->flowi4_tos;
	r->rtm_table	= RT_TABLE_MAIN;
	if (nla_put_u32(skb, RTA_TABLE, RT_TABLE_MAIN))
		goto nla_put_failure;
	r->rtm_type	= rt->rt_type;
	r->rtm_scope	= RT_SCOPE_UNIVERSE;
	r->rtm_protocol = RTPROT_UNSPEC;
 	r->rtm_flags	= (rt->rt_flags & ~0xFFFF) | RTM_F_CLONED;
 	if (rt->rt_flags & RTCF_NOTIFY)
 		r->rtm_flags |= RTM_F_NOTIFY;
	if (IPCB(skb)->flags & IPSKB_DOREDIRECT)
		r->rtm_flags |= RTCF_DOREDIRECT;
 
 	if (nla_put_be32(skb, RTA_DST, dst))
 		goto nla_put_failure;
	if (src) {
		r->rtm_src_len = 32;
		if (nla_put_be32(skb, RTA_SRC, src))
			goto nla_put_failure;
	}
	if (rt->dst.dev &&
	    nla_put_u32(skb, RTA_OIF, rt->dst.dev->ifindex))
		goto nla_put_failure;
#ifdef CONFIG_IP_ROUTE_CLASSID
	if (rt->dst.tclassid &&
	    nla_put_u32(skb, RTA_FLOW, rt->dst.tclassid))
		goto nla_put_failure;
#endif
	if (!rt_is_input_route(rt) &&
	    fl4->saddr != src) {
		if (nla_put_be32(skb, RTA_PREFSRC, fl4->saddr))
			goto nla_put_failure;
	}
	if (rt->rt_uses_gateway &&
	    nla_put_be32(skb, RTA_GATEWAY, rt->rt_gateway))
		goto nla_put_failure;

	expires = rt->dst.expires;
	if (expires) {
		unsigned long now = jiffies;

		if (time_before(now, expires))
			expires -= now;
		else
			expires = 0;
	}

	memcpy(metrics, dst_metrics_ptr(&rt->dst), sizeof(metrics));
	if (rt->rt_pmtu && expires)
		metrics[RTAX_MTU - 1] = rt->rt_pmtu;
	if (rtnetlink_put_metrics(skb, metrics) < 0)
		goto nla_put_failure;

	if (fl4->flowi4_mark &&
	    nla_put_u32(skb, RTA_MARK, fl4->flowi4_mark))
		goto nla_put_failure;

	error = rt->dst.error;

	if (rt_is_input_route(rt)) {
#ifdef CONFIG_IP_MROUTE
		if (ipv4_is_multicast(dst) && !ipv4_is_local_multicast(dst) &&
		    IPV4_DEVCONF_ALL(net, MC_FORWARDING)) {
			int err = ipmr_get_route(net, skb,
						 fl4->saddr, fl4->daddr,
						 r, nowait);
			if (err <= 0) {
				if (!nowait) {
					if (err == 0)
						return 0;
					goto nla_put_failure;
				} else {
					if (err == -EMSGSIZE)
						goto nla_put_failure;
					error = err;
				}
			}
		} else
#endif
			if (nla_put_u32(skb, RTA_IIF, skb->dev->ifindex))
				goto nla_put_failure;
	}

	if (rtnl_put_cacheinfo(skb, &rt->dst, 0, expires, error) < 0)
		goto nla_put_failure;

	return nlmsg_end(skb, nlh);

nla_put_failure:
	nlmsg_cancel(skb, nlh);
	return -EMSGSIZE;
}
","static int rt_fill_info(struct net *net,  __be32 dst, __be32 src,
			struct flowi4 *fl4, struct sk_buff *skb, u32 portid,
			u32 seq, int event, int nowait, unsigned int flags)
{
	struct rtable *rt = skb_rtable(skb);
	struct rtmsg *r;
	struct nlmsghdr *nlh;
	unsigned long expires = 0;
	u32 error;
	u32 metrics[RTAX_MAX];

	nlh = nlmsg_put(skb, portid, seq, event, sizeof(*r), flags);
	if (nlh == NULL)
		return -EMSGSIZE;

	r = nlmsg_data(nlh);
	r->rtm_family	 = AF_INET;
	r->rtm_dst_len	= 32;
	r->rtm_src_len	= 0;
	r->rtm_tos	= fl4->flowi4_tos;
	r->rtm_table	= RT_TABLE_MAIN;
	if (nla_put_u32(skb, RTA_TABLE, RT_TABLE_MAIN))
		goto nla_put_failure;
	r->rtm_type	= rt->rt_type;
	r->rtm_scope	= RT_SCOPE_UNIVERSE;
	r->rtm_protocol = RTPROT_UNSPEC;
 	r->rtm_flags	= (rt->rt_flags & ~0xFFFF) | RTM_F_CLONED;
 	if (rt->rt_flags & RTCF_NOTIFY)
 		r->rtm_flags |= RTM_F_NOTIFY;
 
 	if (nla_put_be32(skb, RTA_DST, dst))
 		goto nla_put_failure;
	if (src) {
		r->rtm_src_len = 32;
		if (nla_put_be32(skb, RTA_SRC, src))
			goto nla_put_failure;
	}
	if (rt->dst.dev &&
	    nla_put_u32(skb, RTA_OIF, rt->dst.dev->ifindex))
		goto nla_put_failure;
#ifdef CONFIG_IP_ROUTE_CLASSID
	if (rt->dst.tclassid &&
	    nla_put_u32(skb, RTA_FLOW, rt->dst.tclassid))
		goto nla_put_failure;
#endif
	if (!rt_is_input_route(rt) &&
	    fl4->saddr != src) {
		if (nla_put_be32(skb, RTA_PREFSRC, fl4->saddr))
			goto nla_put_failure;
	}
	if (rt->rt_uses_gateway &&
	    nla_put_be32(skb, RTA_GATEWAY, rt->rt_gateway))
		goto nla_put_failure;

	expires = rt->dst.expires;
	if (expires) {
		unsigned long now = jiffies;

		if (time_before(now, expires))
			expires -= now;
		else
			expires = 0;
	}

	memcpy(metrics, dst_metrics_ptr(&rt->dst), sizeof(metrics));
	if (rt->rt_pmtu && expires)
		metrics[RTAX_MTU - 1] = rt->rt_pmtu;
	if (rtnetlink_put_metrics(skb, metrics) < 0)
		goto nla_put_failure;

	if (fl4->flowi4_mark &&
	    nla_put_u32(skb, RTA_MARK, fl4->flowi4_mark))
		goto nla_put_failure;

	error = rt->dst.error;

	if (rt_is_input_route(rt)) {
#ifdef CONFIG_IP_MROUTE
		if (ipv4_is_multicast(dst) && !ipv4_is_local_multicast(dst) &&
		    IPV4_DEVCONF_ALL(net, MC_FORWARDING)) {
			int err = ipmr_get_route(net, skb,
						 fl4->saddr, fl4->daddr,
						 r, nowait);
			if (err <= 0) {
				if (!nowait) {
					if (err == 0)
						return 0;
					goto nla_put_failure;
				} else {
					if (err == -EMSGSIZE)
						goto nla_put_failure;
					error = err;
				}
			}
		} else
#endif
			if (nla_put_u32(skb, RTA_IIF, skb->dev->ifindex))
				goto nla_put_failure;
	}

	if (rtnl_put_cacheinfo(skb, &rt->dst, 0, expires, error) < 0)
		goto nla_put_failure;

	return nlmsg_end(skb, nlh);

nla_put_failure:
	nlmsg_cancel(skb, nlh);
	return -EMSGSIZE;
}
",C,"	if (IPCB(skb)->flags & IPSKB_DOREDIRECT)
		r->rtm_flags |= RTCF_DOREDIRECT;
",,,"@@ -1554,11 +1554,10 @@ static int __mkroute_input(struct sk_buff *skb,
 
 	do_cache = res->fi && !itag;
 	if (out_dev == in_dev && err && IN_DEV_TX_REDIRECTS(out_dev) &&
+	    skb->protocol == htons(ETH_P_IP) &&
 	    (IN_DEV_SHARED_MEDIA(out_dev) ||
-	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res)))) {
-		flags |= RTCF_DOREDIRECT;
-		do_cache = false;
-	}
+	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res))))
+		IPCB(skb)->flags |= IPSKB_DOREDIRECT;
 
 	if (skb->protocol != htons(ETH_P_IP)) {
 		/* Not IP (i.e. ARP). Do not create route, if it is
@@ -2303,6 +2302,8 @@ static int rt_fill_info(struct net *net,  __be32 dst, __be32 src,
 	r->rtm_flags	= (rt->rt_flags & ~0xFFFF) | RTM_F_CLONED;
 	if (rt->rt_flags & RTCF_NOTIFY)
 		r->rtm_flags |= RTM_F_NOTIFY;
+	if (IPCB(skb)->flags & IPSKB_DOREDIRECT)
+		r->rtm_flags |= RTCF_DOREDIRECT;
 
 	if (nla_put_be32(skb, RTA_DST, dst))
 		goto nla_put_failure;",linux,df4d92549f23e1c037e83323aff58a21b3de7fe0,412d2907c41531b60c7ea1f38cfe1116daf2a229,1,"static int rt_fill_info(struct net *net,  __be32 dst, __be32 src,
			struct flowi4 *fl4, struct sk_buff *skb, u32 portid,
			u32 seq, int event, int nowait, unsigned int flags)
{
	struct rtable *rt = skb_rtable(skb);
	struct rtmsg *r;
	struct nlmsghdr *nlh;
	unsigned long expires = 0;
	u32 error;
	u32 metrics[RTAX_MAX];

	nlh = nlmsg_put(skb, portid, seq, event, sizeof(*r), flags);
	if (nlh == NULL)
		return -EMSGSIZE;

	r = nlmsg_data(nlh);
	r->rtm_family	 = AF_INET;
	r->rtm_dst_len	= 32;
	r->rtm_src_len	= 0;
	r->rtm_tos	= fl4->flowi4_tos;
	r->rtm_table	= RT_TABLE_MAIN;
	if (nla_put_u32(skb, RTA_TABLE, RT_TABLE_MAIN))
		goto nla_put_failure;
	r->rtm_type	= rt->rt_type;
	r->rtm_scope	= RT_SCOPE_UNIVERSE;
	r->rtm_protocol = RTPROT_UNSPEC;
 	r->rtm_flags	= (rt->rt_flags & ~0xFFFF) | RTM_F_CLONED;
 	if (rt->rt_flags & RTCF_NOTIFY)
 		r->rtm_flags |= RTM_F_NOTIFY;
//fix_flaw_line_below:
//	if (IPCB(skb)->flags & IPSKB_DOREDIRECT)
//fix_flaw_line_below:
//		r->rtm_flags |= RTCF_DOREDIRECT;
 
 	if (nla_put_be32(skb, RTA_DST, dst))
 		goto nla_put_failure;
	if (src) {
		r->rtm_src_len = 32;
		if (nla_put_be32(skb, RTA_SRC, src))
			goto nla_put_failure;
	}
	if (rt->dst.dev &&
	    nla_put_u32(skb, RTA_OIF, rt->dst.dev->ifindex))
		goto nla_put_failure;
#ifdef CONFIG_IP_ROUTE_CLASSID
	if (rt->dst.tclassid &&
	    nla_put_u32(skb, RTA_FLOW, rt->dst.tclassid))
		goto nla_put_failure;
#endif
	if (!rt_is_input_route(rt) &&
	    fl4->saddr != src) {
		if (nla_put_be32(skb, RTA_PREFSRC, fl4->saddr))
			goto nla_put_failure;
	}
	if (rt->rt_uses_gateway &&
	    nla_put_be32(skb, RTA_GATEWAY, rt->rt_gateway))
		goto nla_put_failure;

	expires = rt->dst.expires;
	if (expires) {
		unsigned long now = jiffies;

		if (time_before(now, expires))
			expires -= now;
		else
			expires = 0;
	}

	memcpy(metrics, dst_metrics_ptr(&rt->dst), sizeof(metrics));
	if (rt->rt_pmtu && expires)
		metrics[RTAX_MTU - 1] = rt->rt_pmtu;
	if (rtnetlink_put_metrics(skb, metrics) < 0)
		goto nla_put_failure;

	if (fl4->flowi4_mark &&
	    nla_put_u32(skb, RTA_MARK, fl4->flowi4_mark))
		goto nla_put_failure;

	error = rt->dst.error;

	if (rt_is_input_route(rt)) {
#ifdef CONFIG_IP_MROUTE
		if (ipv4_is_multicast(dst) && !ipv4_is_local_multicast(dst) &&
		    IPV4_DEVCONF_ALL(net, MC_FORWARDING)) {
			int err = ipmr_get_route(net, skb,
						 fl4->saddr, fl4->daddr,
						 r, nowait);
			if (err <= 0) {
				if (!nowait) {
					if (err == 0)
						return 0;
					goto nla_put_failure;
				} else {
					if (err == -EMSGSIZE)
						goto nla_put_failure;
					error = err;
				}
			}
		} else
#endif
			if (nla_put_u32(skb, RTA_IIF, skb->dev->ifindex))
				goto nla_put_failure;
	}

	if (rtnl_put_cacheinfo(skb, &rt->dst, 0, expires, error) < 0)
		goto nla_put_failure;

	return nlmsg_end(skb, nlh);

nla_put_failure:
	nlmsg_cancel(skb, nlh);
	return -EMSGSIZE;
}
"
2159,179895,,Local,Not required,Partial,CVE-2015-1334,https://www.cvedetails.com/cve/CVE-2015-1334/,CWE-17,Low,Partial,Partial,,2015-08-12,4.6,"attach.c in LXC 1.1.2 and earlier uses the proc filesystem in a container, which allows local container users to escape AppArmor or SELinux confinement by mounting a proc filesystem with a crafted (1) AppArmor profile or (2) SELinux label.",2019-05-31,,6,https://github.com/lxc/lxc/commit/5c3fcae78b63ac9dd56e36075903921bd9461f9e,5c3fcae78b63ac9dd56e36075903921bd9461f9e,"CVE-2015-1334: Don't use the container's /proc during attach

A user could otherwise over-mount /proc and prevent the apparmor profile
or selinux label from being written which combined with a modified
/bin/sh or other commonly used binary would lead to unconfined code
execution.

Reported-by: Roman Fiedler
Signed-off-by: Stphane Graber <stgraber@ubuntu.com>",12,src/lxc/attach.c,"{""sha"": ""436ae7a56a9e1c031737e599620733d09b3cc3ce"", ""filename"": ""src/lxc/attach.c"", ""status"": ""modified"", ""additions"": 93, ""deletions"": 13, ""changes"": 106, ""blob_url"": ""https://github.com/lxc/lxc/blob/5c3fcae78b63ac9dd56e36075903921bd9461f9e/src/lxc/attach.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/5c3fcae78b63ac9dd56e36075903921bd9461f9e/src/lxc/attach.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/attach.c?ref=5c3fcae78b63ac9dd56e36075903921bd9461f9e"", ""patch"": ""@@ -76,6 +76,82 @@\n \n lxc_log_define(lxc_attach, lxc);\n \n+int lsm_set_label_at(int procfd, int on_exec, char* lsm_label) {\n+\tint labelfd = -1;\n+\tint ret = 0;\n+\tconst char* name;\n+\tchar* command = NULL;\n+\n+\tname = lsm_name();\n+\n+\tif (strcmp(name, \""nop\"") == 0)\n+\t\tgoto out;\n+\n+\tif (strcmp(name, \""none\"") == 0)\n+\t\tgoto out;\n+\n+\t/* We don't support on-exec with AppArmor */\n+\tif (strcmp(name, \""AppArmor\"") == 0)\n+\t\ton_exec = 0;\n+\n+\tif (on_exec) {\n+\t\tlabelfd = openat(procfd, \""self/attr/exec\"", O_RDWR);\n+\t}\n+\telse {\n+\t\tlabelfd = openat(procfd, \""self/attr/current\"", O_RDWR);\n+\t}\n+\n+\tif (labelfd < 0) {\n+\t\tSYSERROR(\""Unable to open LSM label\"");\n+\t\tret = -1;\n+\t\tgoto out;\n+\t}\n+\n+\tif (strcmp(name, \""AppArmor\"") == 0) {\n+\t\tint size;\n+\n+\t\tcommand = malloc(strlen(lsm_label) + strlen(\""changeprofile \"") + 1);\n+\t\tif (!command) {\n+\t\t\tSYSERROR(\""Failed to write apparmor profile\"");\n+\t\t\tret = -1;\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\tsize = sprintf(command, \""changeprofile %s\"", lsm_label);\n+\t\tif (size < 0) {\n+\t\t\tSYSERROR(\""Failed to write apparmor profile\"");\n+\t\t\tret = -1;\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\tif (write(labelfd, command, size + 1) < 0) {\n+\t\t\tSYSERROR(\""Unable to set LSM label\"");\n+\t\t\tret = -1;\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\telse if (strcmp(name, \""SELinux\"") == 0) {\n+\t\tif (write(labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n+\t\t\tSYSERROR(\""Unable to set LSM label\"");\n+\t\t\tret = -1;\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\telse {\n+\t\tERROR(\""Unable to restore label for unknown LSM: %s\"", name);\n+\t\tret = -1;\n+\t\tgoto out;\n+\t}\n+\n+out:\n+\tfree(command);\n+\n+\tif (labelfd != -1)\n+\t\tclose(labelfd);\n+\n+\treturn ret;\n+}\n+\n static struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)\n {\n \tstruct lxc_proc_context_info *info = calloc(1, sizeof(*info));\n@@ -570,6 +646,7 @@ struct attach_clone_payload {\n \tstruct lxc_proc_context_info* init_ctx;\n \tlxc_attach_exec_t exec_function;\n \tvoid* exec_payload;\n+\tint procfd;\n };\n \n static int attach_child_main(void* data);\n@@ -622,6 +699,7 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun\n \tchar* cwd;\n \tchar* new_cwd;\n \tint ipc_sockets[2];\n+\tint procfd;\n \tsigned long personality;\n \n \tif (!options)\n@@ -833,6 +911,13 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun\n \t\trexit(-1);\n \t}\n \n+\tprocfd = open(\""/proc\"", O_DIRECTORY | O_RDONLY);\n+\tif (procfd < 0) {\n+\t\tSYSERROR(\""Unable to open /proc\"");\n+\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n+\t\trexit(-1);\n+\t}\n+\n \t/* attach now, create another subprocess later, since pid namespaces\n \t * only really affect the children of the current process\n \t */\n@@ -860,7 +945,8 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun\n \t\t\t.options = options,\n \t\t\t.init_ctx = init_ctx,\n \t\t\t.exec_function = exec_function,\n-\t\t\t.exec_payload = exec_payload\n+\t\t\t.exec_payload = exec_payload,\n+\t\t\t.procfd = procfd\n \t\t};\n \t\t/* We use clone_parent here to make this subprocess a direct child of\n \t\t * the initial process. Then this intermediate process can exit and\n@@ -898,6 +984,7 @@ static int attach_child_main(void* data)\n {\n \tstruct attach_clone_payload* payload = (struct attach_clone_payload*)data;\n \tint ipc_socket = payload->ipc_socket;\n+\tint procfd = payload->procfd;\n \tlxc_attach_options_t* options = payload->options;\n \tstruct lxc_proc_context_info* init_ctx = payload->init_ctx;\n #if HAVE_SYS_PERSONALITY_H\n@@ -1038,21 +1125,11 @@ static int attach_child_main(void* data)\n \tclose(ipc_socket);\n \n \t/* set new apparmor profile/selinux context */\n-\tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM)) {\n+\tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {\n \t\tint on_exec;\n-\t\tint proc_mounted;\n \n \t\ton_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;\n-\t\tproc_mounted = mount_proc_if_needed(\""/\"");\n-\t\tif (proc_mounted == -1) {\n-\t\t\tERROR(\""Error mounting a sane /proc\"");\n-\t\t\trexit(-1);\n-\t\t}\n-\t\tret = lsm_process_label_set(init_ctx->lsm_label,\n-\t\t\t\tinit_ctx->container->lxc_conf, 0, on_exec);\n-\t\tif (proc_mounted)\n-\t\t\tumount(\""/proc\"");\n-\t\tif (ret < 0) {\n+\t\tif (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {\n \t\t\trexit(-1);\n \t\t}\n \t}\n@@ -1103,6 +1180,9 @@ static int attach_child_main(void* data)\n \t\t}\n \t}\n \n+\t/* we don't need proc anymore */\n+\tclose(procfd);\n+\n \t/* we're done, so we can now do whatever the user intended us to do */\n \trexit(payload->exec_function(payload->exec_payload));\n }""}","static int attach_child_main(void* data)
 {
 	struct attach_clone_payload* payload = (struct attach_clone_payload*)data;
 	int ipc_socket = payload->ipc_socket;
	int procfd = payload->procfd;
 	lxc_attach_options_t* options = payload->options;
 	struct lxc_proc_context_info* init_ctx = payload->init_ctx;
 #if HAVE_SYS_PERSONALITY_H
	long new_personality;
#endif
	int ret;
	int status;
	int expected;
	long flags;
	int fd;
	uid_t new_uid;
	gid_t new_gid;

	/* wait for the initial thread to signal us that it's ready
	 * for us to start initializing
	 */
	expected = 0;
	status = -1;
	ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);
	if (ret <= 0) {
		ERROR(""error using IPC to receive notification from initial process (0)"");
		shutdown(ipc_socket, SHUT_RDWR);
		rexit(-1);
	}

	/* A description of the purpose of this functionality is
	 * provided in the lxc-attach(1) manual page. We have to
	 * remount here and not in the parent process, otherwise
	 * /proc may not properly reflect the new pid namespace.
	 */
	if (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {
		ret = lxc_attach_remount_sys_proc();
		if (ret < 0) {
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}
	}

	/* now perform additional attachments*/
#if HAVE_SYS_PERSONALITY_H
	if (options->personality < 0)
		new_personality = init_ctx->personality;
	else
		new_personality = options->personality;

	if (options->attach_flags & LXC_ATTACH_SET_PERSONALITY) {
		ret = personality(new_personality);
		if (ret < 0) {
			SYSERROR(""could not ensure correct architecture"");
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}
	}
#endif

	if (options->attach_flags & LXC_ATTACH_DROP_CAPABILITIES) {
		ret = lxc_attach_drop_privs(init_ctx);
		if (ret < 0) {
			ERROR(""could not drop privileges"");
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}
	}

	/* always set the environment (specify (LXC_ATTACH_KEEP_ENV, NULL, NULL) if you want this to be a no-op) */
	ret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env);
	if (ret < 0) {
		ERROR(""could not set initial environment for attached process"");
		shutdown(ipc_socket, SHUT_RDWR);
		rexit(-1);
	}

	/* set user / group id */
	new_uid = 0;
	new_gid = 0;
	/* ignore errors, we will fall back to root in that case
	 * (/proc was not mounted etc.)
	 */
	if (options->namespaces & CLONE_NEWUSER)
		lxc_attach_get_init_uidgid(&new_uid, &new_gid);

	if (options->uid != (uid_t)-1)
		new_uid = options->uid;
	if (options->gid != (gid_t)-1)
		new_gid = options->gid;

	/* setup the control tty */
	if (options->stdin_fd && isatty(options->stdin_fd)) {
		if (setsid() < 0) {
			SYSERROR(""unable to setsid"");
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}

		if (ioctl(options->stdin_fd, TIOCSCTTY, (char *)NULL) < 0) {
			SYSERROR(""unable to TIOCSTTY"");
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}
	}

	/* try to set the uid/gid combination */
	if ((new_gid != 0 || options->namespaces & CLONE_NEWUSER)) {
		if (setgid(new_gid) || setgroups(0, NULL)) {
			SYSERROR(""switching to container gid"");
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}
	}
	if ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) {
		SYSERROR(""switching to container uid"");
		shutdown(ipc_socket, SHUT_RDWR);
		rexit(-1);
	}

	/* tell initial process it may now put us into the cgroups */
	status = 1;
	ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));
	if (ret != sizeof(status)) {
		ERROR(""error using IPC to notify initial process for initialization (1)"");
		shutdown(ipc_socket, SHUT_RDWR);
		rexit(-1);
	}

	/* wait for the initial thread to signal us that it has done
	 * everything for us when it comes to cgroups etc.
	 */
	expected = 2;
	status = -1;
	ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);
	if (ret <= 0) {
		ERROR(""error using IPC to receive final notification from initial process (2)"");
		shutdown(ipc_socket, SHUT_RDWR);
		rexit(-1);
	}

	shutdown(ipc_socket, SHUT_RDWR);
 	close(ipc_socket);
 
 	/* set new apparmor profile/selinux context */
	if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {
 		int on_exec;
 
 		on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;
		if (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {
 			rexit(-1);
 		}
 	}

	if (init_ctx->container && init_ctx->container->lxc_conf &&
			lxc_seccomp_load(init_ctx->container->lxc_conf) != 0) {
		ERROR(""Loading seccomp policy"");
		rexit(-1);
	}

	lxc_proc_put_context_info(init_ctx);

	/* The following is done after the communication socket is
	 * shut down. That way, all errors that might (though
	 * unlikely) occur up until this point will have their messages
	 * printed to the original stderr (if logging is so configured)
	 * and not the fd the user supplied, if any.
	 */

	/* fd handling for stdin, stdout and stderr;
	 * ignore errors here, user may want to make sure
	 * the fds are closed, for example */
	if (options->stdin_fd >= 0 && options->stdin_fd != 0)
		dup2(options->stdin_fd, 0);
	if (options->stdout_fd >= 0 && options->stdout_fd != 1)
		dup2(options->stdout_fd, 1);
	if (options->stderr_fd >= 0 && options->stderr_fd != 2)
		dup2(options->stderr_fd, 2);

	/* close the old fds */
	if (options->stdin_fd > 2)
		close(options->stdin_fd);
	if (options->stdout_fd > 2)
		close(options->stdout_fd);
	if (options->stderr_fd > 2)
		close(options->stderr_fd);

	/* try to remove CLOEXEC flag from stdin/stdout/stderr,
	 * but also here, ignore errors */
	for (fd = 0; fd <= 2; fd++) {
		flags = fcntl(fd, F_GETFL);
		if (flags < 0)
			continue;
		if (flags & FD_CLOEXEC) {
			if (fcntl(fd, F_SETFL, flags & ~FD_CLOEXEC) < 0) {
				SYSERROR(""Unable to clear CLOEXEC from fd"");
			}
 		}
 	}
 
	/* we don't need proc anymore */
	close(procfd);

 	/* we're done, so we can now do whatever the user intended us to do */
 	rexit(payload->exec_function(payload->exec_payload));
 }
","static int attach_child_main(void* data)
 {
 	struct attach_clone_payload* payload = (struct attach_clone_payload*)data;
 	int ipc_socket = payload->ipc_socket;
 	lxc_attach_options_t* options = payload->options;
 	struct lxc_proc_context_info* init_ctx = payload->init_ctx;
 #if HAVE_SYS_PERSONALITY_H
	long new_personality;
#endif
	int ret;
	int status;
	int expected;
	long flags;
	int fd;
	uid_t new_uid;
	gid_t new_gid;

	/* wait for the initial thread to signal us that it's ready
	 * for us to start initializing
	 */
	expected = 0;
	status = -1;
	ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);
	if (ret <= 0) {
		ERROR(""error using IPC to receive notification from initial process (0)"");
		shutdown(ipc_socket, SHUT_RDWR);
		rexit(-1);
	}

	/* A description of the purpose of this functionality is
	 * provided in the lxc-attach(1) manual page. We have to
	 * remount here and not in the parent process, otherwise
	 * /proc may not properly reflect the new pid namespace.
	 */
	if (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {
		ret = lxc_attach_remount_sys_proc();
		if (ret < 0) {
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}
	}

	/* now perform additional attachments*/
#if HAVE_SYS_PERSONALITY_H
	if (options->personality < 0)
		new_personality = init_ctx->personality;
	else
		new_personality = options->personality;

	if (options->attach_flags & LXC_ATTACH_SET_PERSONALITY) {
		ret = personality(new_personality);
		if (ret < 0) {
			SYSERROR(""could not ensure correct architecture"");
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}
	}
#endif

	if (options->attach_flags & LXC_ATTACH_DROP_CAPABILITIES) {
		ret = lxc_attach_drop_privs(init_ctx);
		if (ret < 0) {
			ERROR(""could not drop privileges"");
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}
	}

	/* always set the environment (specify (LXC_ATTACH_KEEP_ENV, NULL, NULL) if you want this to be a no-op) */
	ret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env);
	if (ret < 0) {
		ERROR(""could not set initial environment for attached process"");
		shutdown(ipc_socket, SHUT_RDWR);
		rexit(-1);
	}

	/* set user / group id */
	new_uid = 0;
	new_gid = 0;
	/* ignore errors, we will fall back to root in that case
	 * (/proc was not mounted etc.)
	 */
	if (options->namespaces & CLONE_NEWUSER)
		lxc_attach_get_init_uidgid(&new_uid, &new_gid);

	if (options->uid != (uid_t)-1)
		new_uid = options->uid;
	if (options->gid != (gid_t)-1)
		new_gid = options->gid;

	/* setup the control tty */
	if (options->stdin_fd && isatty(options->stdin_fd)) {
		if (setsid() < 0) {
			SYSERROR(""unable to setsid"");
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}

		if (ioctl(options->stdin_fd, TIOCSCTTY, (char *)NULL) < 0) {
			SYSERROR(""unable to TIOCSTTY"");
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}
	}

	/* try to set the uid/gid combination */
	if ((new_gid != 0 || options->namespaces & CLONE_NEWUSER)) {
		if (setgid(new_gid) || setgroups(0, NULL)) {
			SYSERROR(""switching to container gid"");
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}
	}
	if ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) {
		SYSERROR(""switching to container uid"");
		shutdown(ipc_socket, SHUT_RDWR);
		rexit(-1);
	}

	/* tell initial process it may now put us into the cgroups */
	status = 1;
	ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));
	if (ret != sizeof(status)) {
		ERROR(""error using IPC to notify initial process for initialization (1)"");
		shutdown(ipc_socket, SHUT_RDWR);
		rexit(-1);
	}

	/* wait for the initial thread to signal us that it has done
	 * everything for us when it comes to cgroups etc.
	 */
	expected = 2;
	status = -1;
	ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);
	if (ret <= 0) {
		ERROR(""error using IPC to receive final notification from initial process (2)"");
		shutdown(ipc_socket, SHUT_RDWR);
		rexit(-1);
	}

	shutdown(ipc_socket, SHUT_RDWR);
 	close(ipc_socket);
 
 	/* set new apparmor profile/selinux context */
	if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM)) {
 		int on_exec;
		int proc_mounted;
 
 		on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;
		proc_mounted = mount_proc_if_needed(""/"");
		if (proc_mounted == -1) {
			ERROR(""Error mounting a sane /proc"");
			rexit(-1);
		}
		ret = lsm_process_label_set(init_ctx->lsm_label,
				init_ctx->container->lxc_conf, 0, on_exec);
		if (proc_mounted)
			umount(""/proc"");
		if (ret < 0) {
 			rexit(-1);
 		}
 	}

	if (init_ctx->container && init_ctx->container->lxc_conf &&
			lxc_seccomp_load(init_ctx->container->lxc_conf) != 0) {
		ERROR(""Loading seccomp policy"");
		rexit(-1);
	}

	lxc_proc_put_context_info(init_ctx);

	/* The following is done after the communication socket is
	 * shut down. That way, all errors that might (though
	 * unlikely) occur up until this point will have their messages
	 * printed to the original stderr (if logging is so configured)
	 * and not the fd the user supplied, if any.
	 */

	/* fd handling for stdin, stdout and stderr;
	 * ignore errors here, user may want to make sure
	 * the fds are closed, for example */
	if (options->stdin_fd >= 0 && options->stdin_fd != 0)
		dup2(options->stdin_fd, 0);
	if (options->stdout_fd >= 0 && options->stdout_fd != 1)
		dup2(options->stdout_fd, 1);
	if (options->stderr_fd >= 0 && options->stderr_fd != 2)
		dup2(options->stderr_fd, 2);

	/* close the old fds */
	if (options->stdin_fd > 2)
		close(options->stdin_fd);
	if (options->stdout_fd > 2)
		close(options->stdout_fd);
	if (options->stderr_fd > 2)
		close(options->stderr_fd);

	/* try to remove CLOEXEC flag from stdin/stdout/stderr,
	 * but also here, ignore errors */
	for (fd = 0; fd <= 2; fd++) {
		flags = fcntl(fd, F_GETFL);
		if (flags < 0)
			continue;
		if (flags & FD_CLOEXEC) {
			if (fcntl(fd, F_SETFL, flags & ~FD_CLOEXEC) < 0) {
				SYSERROR(""Unable to clear CLOEXEC from fd"");
			}
 		}
 	}
 
 	/* we're done, so we can now do whatever the user intended us to do */
 	rexit(payload->exec_function(payload->exec_payload));
 }
",C,"	int procfd = payload->procfd;
	if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {
		if (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {
	/* we don't need proc anymore */
	close(procfd);

","	if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM)) {
		int proc_mounted;
		proc_mounted = mount_proc_if_needed(""/"");
		if (proc_mounted == -1) {
			ERROR(""Error mounting a sane /proc"");
			rexit(-1);
		}
		ret = lsm_process_label_set(init_ctx->lsm_label,
				init_ctx->container->lxc_conf, 0, on_exec);
		if (proc_mounted)
			umount(""/proc"");
		if (ret < 0) {
",,"@@ -76,6 +76,82 @@
 
 lxc_log_define(lxc_attach, lxc);
 
+int lsm_set_label_at(int procfd, int on_exec, char* lsm_label) {
+	int labelfd = -1;
+	int ret = 0;
+	const char* name;
+	char* command = NULL;
+
+	name = lsm_name();
+
+	if (strcmp(name, ""nop"") == 0)
+		goto out;
+
+	if (strcmp(name, ""none"") == 0)
+		goto out;
+
+	/* We don't support on-exec with AppArmor */
+	if (strcmp(name, ""AppArmor"") == 0)
+		on_exec = 0;
+
+	if (on_exec) {
+		labelfd = openat(procfd, ""self/attr/exec"", O_RDWR);
+	}
+	else {
+		labelfd = openat(procfd, ""self/attr/current"", O_RDWR);
+	}
+
+	if (labelfd < 0) {
+		SYSERROR(""Unable to open LSM label"");
+		ret = -1;
+		goto out;
+	}
+
+	if (strcmp(name, ""AppArmor"") == 0) {
+		int size;
+
+		command = malloc(strlen(lsm_label) + strlen(""changeprofile "") + 1);
+		if (!command) {
+			SYSERROR(""Failed to write apparmor profile"");
+			ret = -1;
+			goto out;
+		}
+
+		size = sprintf(command, ""changeprofile %s"", lsm_label);
+		if (size < 0) {
+			SYSERROR(""Failed to write apparmor profile"");
+			ret = -1;
+			goto out;
+		}
+
+		if (write(labelfd, command, size + 1) < 0) {
+			SYSERROR(""Unable to set LSM label"");
+			ret = -1;
+			goto out;
+		}
+	}
+	else if (strcmp(name, ""SELinux"") == 0) {
+		if (write(labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {
+			SYSERROR(""Unable to set LSM label"");
+			ret = -1;
+			goto out;
+		}
+	}
+	else {
+		ERROR(""Unable to restore label for unknown LSM: %s"", name);
+		ret = -1;
+		goto out;
+	}
+
+out:
+	free(command);
+
+	if (labelfd != -1)
+		close(labelfd);
+
+	return ret;
+}
+
 static struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)
 {
 	struct lxc_proc_context_info *info = calloc(1, sizeof(*info));
@@ -570,6 +646,7 @@ struct attach_clone_payload {
 	struct lxc_proc_context_info* init_ctx;
 	lxc_attach_exec_t exec_function;
 	void* exec_payload;
+	int procfd;
 };
 
 static int attach_child_main(void* data);
@@ -622,6 +699,7 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun
 	char* cwd;
 	char* new_cwd;
 	int ipc_sockets[2];
+	int procfd;
 	signed long personality;
 
 	if (!options)
@@ -833,6 +911,13 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun
 		rexit(-1);
 	}
 
+	procfd = open(""/proc"", O_DIRECTORY | O_RDONLY);
+	if (procfd < 0) {
+		SYSERROR(""Unable to open /proc"");
+		shutdown(ipc_sockets[1], SHUT_RDWR);
+		rexit(-1);
+	}
+
 	/* attach now, create another subprocess later, since pid namespaces
 	 * only really affect the children of the current process
 	 */
@@ -860,7 +945,8 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun
 			.options = options,
 			.init_ctx = init_ctx,
 			.exec_function = exec_function,
-			.exec_payload = exec_payload
+			.exec_payload = exec_payload,
+			.procfd = procfd
 		};
 		/* We use clone_parent here to make this subprocess a direct child of
 		 * the initial process. Then this intermediate process can exit and
@@ -898,6 +984,7 @@ static int attach_child_main(void* data)
 {
 	struct attach_clone_payload* payload = (struct attach_clone_payload*)data;
 	int ipc_socket = payload->ipc_socket;
+	int procfd = payload->procfd;
 	lxc_attach_options_t* options = payload->options;
 	struct lxc_proc_context_info* init_ctx = payload->init_ctx;
 #if HAVE_SYS_PERSONALITY_H
@@ -1038,21 +1125,11 @@ static int attach_child_main(void* data)
 	close(ipc_socket);
 
 	/* set new apparmor profile/selinux context */
-	if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM)) {
+	if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {
 		int on_exec;
-		int proc_mounted;
 
 		on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;
-		proc_mounted = mount_proc_if_needed(""/"");
-		if (proc_mounted == -1) {
-			ERROR(""Error mounting a sane /proc"");
-			rexit(-1);
-		}
-		ret = lsm_process_label_set(init_ctx->lsm_label,
-				init_ctx->container->lxc_conf, 0, on_exec);
-		if (proc_mounted)
-			umount(""/proc"");
-		if (ret < 0) {
+		if (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {
 			rexit(-1);
 		}
 	}
@@ -1103,6 +1180,9 @@ static int attach_child_main(void* data)
 		}
 	}
 
+	/* we don't need proc anymore */
+	close(procfd);
+
 	/* we're done, so we can now do whatever the user intended us to do */
 	rexit(payload->exec_function(payload->exec_payload));
 }",lxc,5c3fcae78b63ac9dd56e36075903921bd9461f9e,72cf81f6a3404e35028567db2c99a90406e9c6e6,1,"static int attach_child_main(void* data)
 {
 	struct attach_clone_payload* payload = (struct attach_clone_payload*)data;
 	int ipc_socket = payload->ipc_socket;
//fix_flaw_line_below:
//	int procfd = payload->procfd;
 	lxc_attach_options_t* options = payload->options;
 	struct lxc_proc_context_info* init_ctx = payload->init_ctx;
 #if HAVE_SYS_PERSONALITY_H
	long new_personality;
#endif
	int ret;
	int status;
	int expected;
	long flags;
	int fd;
	uid_t new_uid;
	gid_t new_gid;

	/* wait for the initial thread to signal us that it's ready
	 * for us to start initializing
	 */
	expected = 0;
	status = -1;
	ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);
	if (ret <= 0) {
		ERROR(""error using IPC to receive notification from initial process (0)"");
		shutdown(ipc_socket, SHUT_RDWR);
		rexit(-1);
	}

	/* A description of the purpose of this functionality is
	 * provided in the lxc-attach(1) manual page. We have to
	 * remount here and not in the parent process, otherwise
	 * /proc may not properly reflect the new pid namespace.
	 */
	if (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {
		ret = lxc_attach_remount_sys_proc();
		if (ret < 0) {
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}
	}

	/* now perform additional attachments*/
#if HAVE_SYS_PERSONALITY_H
	if (options->personality < 0)
		new_personality = init_ctx->personality;
	else
		new_personality = options->personality;

	if (options->attach_flags & LXC_ATTACH_SET_PERSONALITY) {
		ret = personality(new_personality);
		if (ret < 0) {
			SYSERROR(""could not ensure correct architecture"");
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}
	}
#endif

	if (options->attach_flags & LXC_ATTACH_DROP_CAPABILITIES) {
		ret = lxc_attach_drop_privs(init_ctx);
		if (ret < 0) {
			ERROR(""could not drop privileges"");
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}
	}

	/* always set the environment (specify (LXC_ATTACH_KEEP_ENV, NULL, NULL) if you want this to be a no-op) */
	ret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env);
	if (ret < 0) {
		ERROR(""could not set initial environment for attached process"");
		shutdown(ipc_socket, SHUT_RDWR);
		rexit(-1);
	}

	/* set user / group id */
	new_uid = 0;
	new_gid = 0;
	/* ignore errors, we will fall back to root in that case
	 * (/proc was not mounted etc.)
	 */
	if (options->namespaces & CLONE_NEWUSER)
		lxc_attach_get_init_uidgid(&new_uid, &new_gid);

	if (options->uid != (uid_t)-1)
		new_uid = options->uid;
	if (options->gid != (gid_t)-1)
		new_gid = options->gid;

	/* setup the control tty */
	if (options->stdin_fd && isatty(options->stdin_fd)) {
		if (setsid() < 0) {
			SYSERROR(""unable to setsid"");
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}

		if (ioctl(options->stdin_fd, TIOCSCTTY, (char *)NULL) < 0) {
			SYSERROR(""unable to TIOCSTTY"");
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}
	}

	/* try to set the uid/gid combination */
	if ((new_gid != 0 || options->namespaces & CLONE_NEWUSER)) {
		if (setgid(new_gid) || setgroups(0, NULL)) {
			SYSERROR(""switching to container gid"");
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}
	}
	if ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) {
		SYSERROR(""switching to container uid"");
		shutdown(ipc_socket, SHUT_RDWR);
		rexit(-1);
	}

	/* tell initial process it may now put us into the cgroups */
	status = 1;
	ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));
	if (ret != sizeof(status)) {
		ERROR(""error using IPC to notify initial process for initialization (1)"");
		shutdown(ipc_socket, SHUT_RDWR);
		rexit(-1);
	}

	/* wait for the initial thread to signal us that it has done
	 * everything for us when it comes to cgroups etc.
	 */
	expected = 2;
	status = -1;
	ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);
	if (ret <= 0) {
		ERROR(""error using IPC to receive final notification from initial process (2)"");
		shutdown(ipc_socket, SHUT_RDWR);
		rexit(-1);
	}

	shutdown(ipc_socket, SHUT_RDWR);
 	close(ipc_socket);
 
 	/* set new apparmor profile/selinux context */
//flaw_line_below:
	if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM)) {
//fix_flaw_line_below:
//	if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {
 		int on_exec;
//flaw_line_below:
		int proc_mounted;
 
 		on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;
//flaw_line_below:
		proc_mounted = mount_proc_if_needed(""/"");
//flaw_line_below:
		if (proc_mounted == -1) {
//flaw_line_below:
			ERROR(""Error mounting a sane /proc"");
//flaw_line_below:
			rexit(-1);
//flaw_line_below:
		}
//flaw_line_below:
		ret = lsm_process_label_set(init_ctx->lsm_label,
//flaw_line_below:
				init_ctx->container->lxc_conf, 0, on_exec);
//flaw_line_below:
		if (proc_mounted)
//flaw_line_below:
			umount(""/proc"");
//flaw_line_below:
		if (ret < 0) {
//fix_flaw_line_below:
//		if (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {
 			rexit(-1);
 		}
 	}

	if (init_ctx->container && init_ctx->container->lxc_conf &&
			lxc_seccomp_load(init_ctx->container->lxc_conf) != 0) {
		ERROR(""Loading seccomp policy"");
		rexit(-1);
	}

	lxc_proc_put_context_info(init_ctx);

	/* The following is done after the communication socket is
	 * shut down. That way, all errors that might (though
	 * unlikely) occur up until this point will have their messages
	 * printed to the original stderr (if logging is so configured)
	 * and not the fd the user supplied, if any.
	 */

	/* fd handling for stdin, stdout and stderr;
	 * ignore errors here, user may want to make sure
	 * the fds are closed, for example */
	if (options->stdin_fd >= 0 && options->stdin_fd != 0)
		dup2(options->stdin_fd, 0);
	if (options->stdout_fd >= 0 && options->stdout_fd != 1)
		dup2(options->stdout_fd, 1);
	if (options->stderr_fd >= 0 && options->stderr_fd != 2)
		dup2(options->stderr_fd, 2);

	/* close the old fds */
	if (options->stdin_fd > 2)
		close(options->stdin_fd);
	if (options->stdout_fd > 2)
		close(options->stdout_fd);
	if (options->stderr_fd > 2)
		close(options->stderr_fd);

	/* try to remove CLOEXEC flag from stdin/stdout/stderr,
	 * but also here, ignore errors */
	for (fd = 0; fd <= 2; fd++) {
		flags = fcntl(fd, F_GETFL);
		if (flags < 0)
			continue;
		if (flags & FD_CLOEXEC) {
			if (fcntl(fd, F_SETFL, flags & ~FD_CLOEXEC) < 0) {
				SYSERROR(""Unable to clear CLOEXEC from fd"");
			}
 		}
 	}
 
//fix_flaw_line_below:
//	/* we don't need proc anymore */
//fix_flaw_line_below:
//	close(procfd);
//fix_flaw_line_below:
//
 	/* we're done, so we can now do whatever the user intended us to do */
 	rexit(payload->exec_function(payload->exec_payload));
 }
"
2160,179896,,Local,Not required,Partial,CVE-2015-1334,https://www.cvedetails.com/cve/CVE-2015-1334/,CWE-17,Low,Partial,Partial,,2015-08-12,4.6,"attach.c in LXC 1.1.2 and earlier uses the proc filesystem in a container, which allows local container users to escape AppArmor or SELinux confinement by mounting a proc filesystem with a crafted (1) AppArmor profile or (2) SELinux label.",2019-05-31,,10,https://github.com/lxc/lxc/commit/5c3fcae78b63ac9dd56e36075903921bd9461f9e,5c3fcae78b63ac9dd56e36075903921bd9461f9e,"CVE-2015-1334: Don't use the container's /proc during attach

A user could otherwise over-mount /proc and prevent the apparmor profile
or selinux label from being written which combined with a modified
/bin/sh or other commonly used binary would lead to unconfined code
execution.

Reported-by: Roman Fiedler
Signed-off-by: Stphane Graber <stgraber@ubuntu.com>",1,src/lxc/attach.c,"{""sha"": ""436ae7a56a9e1c031737e599620733d09b3cc3ce"", ""filename"": ""src/lxc/attach.c"", ""status"": ""modified"", ""additions"": 93, ""deletions"": 13, ""changes"": 106, ""blob_url"": ""https://github.com/lxc/lxc/blob/5c3fcae78b63ac9dd56e36075903921bd9461f9e/src/lxc/attach.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/5c3fcae78b63ac9dd56e36075903921bd9461f9e/src/lxc/attach.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/attach.c?ref=5c3fcae78b63ac9dd56e36075903921bd9461f9e"", ""patch"": ""@@ -76,6 +76,82 @@\n \n lxc_log_define(lxc_attach, lxc);\n \n+int lsm_set_label_at(int procfd, int on_exec, char* lsm_label) {\n+\tint labelfd = -1;\n+\tint ret = 0;\n+\tconst char* name;\n+\tchar* command = NULL;\n+\n+\tname = lsm_name();\n+\n+\tif (strcmp(name, \""nop\"") == 0)\n+\t\tgoto out;\n+\n+\tif (strcmp(name, \""none\"") == 0)\n+\t\tgoto out;\n+\n+\t/* We don't support on-exec with AppArmor */\n+\tif (strcmp(name, \""AppArmor\"") == 0)\n+\t\ton_exec = 0;\n+\n+\tif (on_exec) {\n+\t\tlabelfd = openat(procfd, \""self/attr/exec\"", O_RDWR);\n+\t}\n+\telse {\n+\t\tlabelfd = openat(procfd, \""self/attr/current\"", O_RDWR);\n+\t}\n+\n+\tif (labelfd < 0) {\n+\t\tSYSERROR(\""Unable to open LSM label\"");\n+\t\tret = -1;\n+\t\tgoto out;\n+\t}\n+\n+\tif (strcmp(name, \""AppArmor\"") == 0) {\n+\t\tint size;\n+\n+\t\tcommand = malloc(strlen(lsm_label) + strlen(\""changeprofile \"") + 1);\n+\t\tif (!command) {\n+\t\t\tSYSERROR(\""Failed to write apparmor profile\"");\n+\t\t\tret = -1;\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\tsize = sprintf(command, \""changeprofile %s\"", lsm_label);\n+\t\tif (size < 0) {\n+\t\t\tSYSERROR(\""Failed to write apparmor profile\"");\n+\t\t\tret = -1;\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\tif (write(labelfd, command, size + 1) < 0) {\n+\t\t\tSYSERROR(\""Unable to set LSM label\"");\n+\t\t\tret = -1;\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\telse if (strcmp(name, \""SELinux\"") == 0) {\n+\t\tif (write(labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n+\t\t\tSYSERROR(\""Unable to set LSM label\"");\n+\t\t\tret = -1;\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\telse {\n+\t\tERROR(\""Unable to restore label for unknown LSM: %s\"", name);\n+\t\tret = -1;\n+\t\tgoto out;\n+\t}\n+\n+out:\n+\tfree(command);\n+\n+\tif (labelfd != -1)\n+\t\tclose(labelfd);\n+\n+\treturn ret;\n+}\n+\n static struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)\n {\n \tstruct lxc_proc_context_info *info = calloc(1, sizeof(*info));\n@@ -570,6 +646,7 @@ struct attach_clone_payload {\n \tstruct lxc_proc_context_info* init_ctx;\n \tlxc_attach_exec_t exec_function;\n \tvoid* exec_payload;\n+\tint procfd;\n };\n \n static int attach_child_main(void* data);\n@@ -622,6 +699,7 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun\n \tchar* cwd;\n \tchar* new_cwd;\n \tint ipc_sockets[2];\n+\tint procfd;\n \tsigned long personality;\n \n \tif (!options)\n@@ -833,6 +911,13 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun\n \t\trexit(-1);\n \t}\n \n+\tprocfd = open(\""/proc\"", O_DIRECTORY | O_RDONLY);\n+\tif (procfd < 0) {\n+\t\tSYSERROR(\""Unable to open /proc\"");\n+\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n+\t\trexit(-1);\n+\t}\n+\n \t/* attach now, create another subprocess later, since pid namespaces\n \t * only really affect the children of the current process\n \t */\n@@ -860,7 +945,8 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun\n \t\t\t.options = options,\n \t\t\t.init_ctx = init_ctx,\n \t\t\t.exec_function = exec_function,\n-\t\t\t.exec_payload = exec_payload\n+\t\t\t.exec_payload = exec_payload,\n+\t\t\t.procfd = procfd\n \t\t};\n \t\t/* We use clone_parent here to make this subprocess a direct child of\n \t\t * the initial process. Then this intermediate process can exit and\n@@ -898,6 +984,7 @@ static int attach_child_main(void* data)\n {\n \tstruct attach_clone_payload* payload = (struct attach_clone_payload*)data;\n \tint ipc_socket = payload->ipc_socket;\n+\tint procfd = payload->procfd;\n \tlxc_attach_options_t* options = payload->options;\n \tstruct lxc_proc_context_info* init_ctx = payload->init_ctx;\n #if HAVE_SYS_PERSONALITY_H\n@@ -1038,21 +1125,11 @@ static int attach_child_main(void* data)\n \tclose(ipc_socket);\n \n \t/* set new apparmor profile/selinux context */\n-\tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM)) {\n+\tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {\n \t\tint on_exec;\n-\t\tint proc_mounted;\n \n \t\ton_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;\n-\t\tproc_mounted = mount_proc_if_needed(\""/\"");\n-\t\tif (proc_mounted == -1) {\n-\t\t\tERROR(\""Error mounting a sane /proc\"");\n-\t\t\trexit(-1);\n-\t\t}\n-\t\tret = lsm_process_label_set(init_ctx->lsm_label,\n-\t\t\t\tinit_ctx->container->lxc_conf, 0, on_exec);\n-\t\tif (proc_mounted)\n-\t\t\tumount(\""/proc\"");\n-\t\tif (ret < 0) {\n+\t\tif (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {\n \t\t\trexit(-1);\n \t\t}\n \t}\n@@ -1103,6 +1180,9 @@ static int attach_child_main(void* data)\n \t\t}\n \t}\n \n+\t/* we don't need proc anymore */\n+\tclose(procfd);\n+\n \t/* we're done, so we can now do whatever the user intended us to do */\n \trexit(payload->exec_function(payload->exec_payload));\n }""}","int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_function, void* exec_payload, lxc_attach_options_t* options, pid_t* attached_process)
{
	int ret, status;
	pid_t init_pid, pid, attached_pid, expected;
	struct lxc_proc_context_info *init_ctx;
 	char* cwd;
 	char* new_cwd;
 	int ipc_sockets[2];
	int procfd;
 	signed long personality;
 
 	if (!options)
		options = &attach_static_default_options;

	init_pid = lxc_cmd_get_init_pid(name, lxcpath);
	if (init_pid < 0) {
		ERROR(""failed to get the init pid"");
		return -1;
	}

	init_ctx = lxc_proc_get_context_info(init_pid);
	if (!init_ctx) {
		ERROR(""failed to get context of the init process, pid = %ld"", (long)init_pid);
		return -1;
	}

	personality = get_personality(name, lxcpath);
	if (init_ctx->personality < 0) {
		ERROR(""Failed to get personality of the container"");
		lxc_proc_put_context_info(init_ctx);
		return -1;
	}
	init_ctx->personality = personality;

	if (!fetch_seccomp(name, lxcpath, init_ctx, options))
		WARN(""Failed to get seccomp policy"");

	cwd = getcwd(NULL, 0);

	/* determine which namespaces the container was created with
	 * by asking lxc-start, if necessary
	 */
	if (options->namespaces == -1) {
		options->namespaces = lxc_cmd_get_clone_flags(name, lxcpath);
		/* call failed */
		if (options->namespaces == -1) {
			ERROR(""failed to automatically determine the ""
			      ""namespaces which the container unshared"");
			free(cwd);
			lxc_proc_put_context_info(init_ctx);
			return -1;
		}
	}

	/* create a socket pair for IPC communication; set SOCK_CLOEXEC in order
	 * to make sure we don't irritate other threads that want to fork+exec away
	 *
	 * IMPORTANT: if the initial process is multithreaded and another call
	 * just fork()s away without exec'ing directly after, the socket fd will
	 * exist in the forked process from the other thread and any close() in
	 * our own child process will not really cause the socket to close properly,
	 * potentiall causing the parent to hang.
	 *
	 * For this reason, while IPC is still active, we have to use shutdown()
	 * if the child exits prematurely in order to signal that the socket
	 * is closed and cannot assume that the child exiting will automatically
	 * do that.
	 *
	 * IPC mechanism: (X is receiver)
	 *   initial process        intermediate          attached
	 *        X           <---  send pid of
	 *                          attached proc,
	 *                          then exit
	 *    send 0 ------------------------------------>    X
	 *                                              [do initialization]
	 *        X  <------------------------------------  send 1
	 *   [add to cgroup, ...]
	 *    send 2 ------------------------------------>    X
	 *   close socket                                 close socket
	 *                                                run program
	 */
	ret = socketpair(PF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, ipc_sockets);
	if (ret < 0) {
		SYSERROR(""could not set up required IPC mechanism for attaching"");
		free(cwd);
		lxc_proc_put_context_info(init_ctx);
		return -1;
	}

	/* create intermediate subprocess, three reasons:
	 *       1. runs all pthread_atfork handlers and the
	 *          child will no longer be threaded
	 *          (we can't properly setns() in a threaded process)
	 *       2. we can't setns() in the child itself, since
	 *          we want to make sure we are properly attached to
	 *          the pidns
	 *       3. also, the initial thread has to put the attached
	 *          process into the cgroup, which we can only do if
	 *          we didn't already setns() (otherwise, user
	 *          namespaces will hate us)
	 */
	pid = fork();

	if (pid < 0) {
		SYSERROR(""failed to create first subprocess"");
		free(cwd);
		lxc_proc_put_context_info(init_ctx);
		return -1;
	}

	if (pid) {
		pid_t to_cleanup_pid = pid;

		/* initial thread, we close the socket that is for the
		 * subprocesses
		 */
		close(ipc_sockets[1]);
		free(cwd);

		/* attach to cgroup, if requested */
		if (options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) {
			if (!cgroup_attach(name, lxcpath, pid))
				goto cleanup_error;
		}

		/* Let the child process know to go ahead */
		status = 0;
		ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));
		if (ret <= 0) {
			ERROR(""error using IPC to notify attached process for initialization (0)"");
			goto cleanup_error;
		}

		/* get pid from intermediate process */
		ret = lxc_read_nointr_expect(ipc_sockets[0], &attached_pid, sizeof(attached_pid), NULL);
		if (ret <= 0) {
			if (ret != 0)
				ERROR(""error using IPC to receive pid of attached process"");
			goto cleanup_error;
		}

		/* ignore SIGKILL (CTRL-C) and SIGQUIT (CTRL-\) - issue #313 */
		if (options->stdin_fd == 0) {
			signal(SIGINT, SIG_IGN);
			signal(SIGQUIT, SIG_IGN);
		}

		/* reap intermediate process */
		ret = wait_for_pid(pid);
		if (ret < 0)
			goto cleanup_error;

		/* we will always have to reap the grandchild now */
		to_cleanup_pid = attached_pid;

		/* tell attached process it may start initializing */
		status = 0;
		ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));
		if (ret <= 0) {
			ERROR(""error using IPC to notify attached process for initialization (0)"");
			goto cleanup_error;
		}

		/* wait for the attached process to finish initializing */
		expected = 1;
		ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);
		if (ret <= 0) {
			if (ret != 0)
				ERROR(""error using IPC to receive notification from attached process (1)"");
			goto cleanup_error;
		}

		/* tell attached process we're done */
		status = 2;
		ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));
		if (ret <= 0) {
			ERROR(""error using IPC to notify attached process for initialization (2)"");
			goto cleanup_error;
		}

		/* now shut down communication with child, we're done */
		shutdown(ipc_sockets[0], SHUT_RDWR);
		close(ipc_sockets[0]);
		lxc_proc_put_context_info(init_ctx);

		/* we're done, the child process should now execute whatever
		 * it is that the user requested. The parent can now track it
		 * with waitpid() or similar.
		 */

		*attached_process = attached_pid;
		return 0;

	cleanup_error:
		/* first shut down the socket, then wait for the pid,
		 * otherwise the pid we're waiting for may never exit
		 */
		shutdown(ipc_sockets[0], SHUT_RDWR);
		close(ipc_sockets[0]);
		if (to_cleanup_pid)
			(void) wait_for_pid(to_cleanup_pid);
		lxc_proc_put_context_info(init_ctx);
		return -1;
	}

	/* first subprocess begins here, we close the socket that is for the
	 * initial thread
	 */
	close(ipc_sockets[0]);

	/* Wait for the parent to have setup cgroups */
	expected = 0;
	status = -1;
	ret = lxc_read_nointr_expect(ipc_sockets[1], &status, sizeof(status), &expected);
	if (ret <= 0) {
		ERROR(""error communicating with child process"");
		shutdown(ipc_sockets[1], SHUT_RDWR);
 		rexit(-1);
 	}
 
	procfd = open(""/proc"", O_DIRECTORY | O_RDONLY);
	if (procfd < 0) {
		SYSERROR(""Unable to open /proc"");
		shutdown(ipc_sockets[1], SHUT_RDWR);
		rexit(-1);
	}

 	/* attach now, create another subprocess later, since pid namespaces
 	 * only really affect the children of the current process
 	 */
	ret = lxc_attach_to_ns(init_pid, options->namespaces);
	if (ret < 0) {
		ERROR(""failed to enter the namespace"");
		shutdown(ipc_sockets[1], SHUT_RDWR);
		rexit(-1);
	}

	/* attach succeeded, try to cwd */
	if (options->initial_cwd)
		new_cwd = options->initial_cwd;
	else
		new_cwd = cwd;
	ret = chdir(new_cwd);
	if (ret < 0)
		WARN(""could not change directory to '%s'"", new_cwd);
	free(cwd);

	/* now create the real child process */
	{
		struct attach_clone_payload payload = {
			.ipc_socket = ipc_sockets[1],
 			.options = options,
 			.init_ctx = init_ctx,
 			.exec_function = exec_function,
			.exec_payload = exec_payload,
			.procfd = procfd
 		};
 		/* We use clone_parent here to make this subprocess a direct child of
 		 * the initial process. Then this intermediate process can exit and
		 * the parent can directly track the attached process.
		 */
		pid = lxc_clone(attach_child_main, &payload, CLONE_PARENT);
	}

	/* shouldn't happen, clone() should always return positive pid */
	if (pid <= 0) {
		SYSERROR(""failed to create subprocess"");
		shutdown(ipc_sockets[1], SHUT_RDWR);
		rexit(-1);
	}

	/* tell grandparent the pid of the pid of the newly created child */
	ret = lxc_write_nointr(ipc_sockets[1], &pid, sizeof(pid));
	if (ret != sizeof(pid)) {
		/* if this really happens here, this is very unfortunate, since the
		 * parent will not know the pid of the attached process and will
		 * not be able to wait for it (and we won't either due to CLONE_PARENT)
		 * so the parent won't be able to reap it and the attached process
		 * will remain a zombie
		 */
		ERROR(""error using IPC to notify main process of pid of the attached process"");
		shutdown(ipc_sockets[1], SHUT_RDWR);
		rexit(-1);
	}

	/* the rest is in the hands of the initial and the attached process */
	rexit(0);
}
","int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_function, void* exec_payload, lxc_attach_options_t* options, pid_t* attached_process)
{
	int ret, status;
	pid_t init_pid, pid, attached_pid, expected;
	struct lxc_proc_context_info *init_ctx;
 	char* cwd;
 	char* new_cwd;
 	int ipc_sockets[2];
 	signed long personality;
 
 	if (!options)
		options = &attach_static_default_options;

	init_pid = lxc_cmd_get_init_pid(name, lxcpath);
	if (init_pid < 0) {
		ERROR(""failed to get the init pid"");
		return -1;
	}

	init_ctx = lxc_proc_get_context_info(init_pid);
	if (!init_ctx) {
		ERROR(""failed to get context of the init process, pid = %ld"", (long)init_pid);
		return -1;
	}

	personality = get_personality(name, lxcpath);
	if (init_ctx->personality < 0) {
		ERROR(""Failed to get personality of the container"");
		lxc_proc_put_context_info(init_ctx);
		return -1;
	}
	init_ctx->personality = personality;

	if (!fetch_seccomp(name, lxcpath, init_ctx, options))
		WARN(""Failed to get seccomp policy"");

	cwd = getcwd(NULL, 0);

	/* determine which namespaces the container was created with
	 * by asking lxc-start, if necessary
	 */
	if (options->namespaces == -1) {
		options->namespaces = lxc_cmd_get_clone_flags(name, lxcpath);
		/* call failed */
		if (options->namespaces == -1) {
			ERROR(""failed to automatically determine the ""
			      ""namespaces which the container unshared"");
			free(cwd);
			lxc_proc_put_context_info(init_ctx);
			return -1;
		}
	}

	/* create a socket pair for IPC communication; set SOCK_CLOEXEC in order
	 * to make sure we don't irritate other threads that want to fork+exec away
	 *
	 * IMPORTANT: if the initial process is multithreaded and another call
	 * just fork()s away without exec'ing directly after, the socket fd will
	 * exist in the forked process from the other thread and any close() in
	 * our own child process will not really cause the socket to close properly,
	 * potentiall causing the parent to hang.
	 *
	 * For this reason, while IPC is still active, we have to use shutdown()
	 * if the child exits prematurely in order to signal that the socket
	 * is closed and cannot assume that the child exiting will automatically
	 * do that.
	 *
	 * IPC mechanism: (X is receiver)
	 *   initial process        intermediate          attached
	 *        X           <---  send pid of
	 *                          attached proc,
	 *                          then exit
	 *    send 0 ------------------------------------>    X
	 *                                              [do initialization]
	 *        X  <------------------------------------  send 1
	 *   [add to cgroup, ...]
	 *    send 2 ------------------------------------>    X
	 *   close socket                                 close socket
	 *                                                run program
	 */
	ret = socketpair(PF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, ipc_sockets);
	if (ret < 0) {
		SYSERROR(""could not set up required IPC mechanism for attaching"");
		free(cwd);
		lxc_proc_put_context_info(init_ctx);
		return -1;
	}

	/* create intermediate subprocess, three reasons:
	 *       1. runs all pthread_atfork handlers and the
	 *          child will no longer be threaded
	 *          (we can't properly setns() in a threaded process)
	 *       2. we can't setns() in the child itself, since
	 *          we want to make sure we are properly attached to
	 *          the pidns
	 *       3. also, the initial thread has to put the attached
	 *          process into the cgroup, which we can only do if
	 *          we didn't already setns() (otherwise, user
	 *          namespaces will hate us)
	 */
	pid = fork();

	if (pid < 0) {
		SYSERROR(""failed to create first subprocess"");
		free(cwd);
		lxc_proc_put_context_info(init_ctx);
		return -1;
	}

	if (pid) {
		pid_t to_cleanup_pid = pid;

		/* initial thread, we close the socket that is for the
		 * subprocesses
		 */
		close(ipc_sockets[1]);
		free(cwd);

		/* attach to cgroup, if requested */
		if (options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) {
			if (!cgroup_attach(name, lxcpath, pid))
				goto cleanup_error;
		}

		/* Let the child process know to go ahead */
		status = 0;
		ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));
		if (ret <= 0) {
			ERROR(""error using IPC to notify attached process for initialization (0)"");
			goto cleanup_error;
		}

		/* get pid from intermediate process */
		ret = lxc_read_nointr_expect(ipc_sockets[0], &attached_pid, sizeof(attached_pid), NULL);
		if (ret <= 0) {
			if (ret != 0)
				ERROR(""error using IPC to receive pid of attached process"");
			goto cleanup_error;
		}

		/* ignore SIGKILL (CTRL-C) and SIGQUIT (CTRL-\) - issue #313 */
		if (options->stdin_fd == 0) {
			signal(SIGINT, SIG_IGN);
			signal(SIGQUIT, SIG_IGN);
		}

		/* reap intermediate process */
		ret = wait_for_pid(pid);
		if (ret < 0)
			goto cleanup_error;

		/* we will always have to reap the grandchild now */
		to_cleanup_pid = attached_pid;

		/* tell attached process it may start initializing */
		status = 0;
		ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));
		if (ret <= 0) {
			ERROR(""error using IPC to notify attached process for initialization (0)"");
			goto cleanup_error;
		}

		/* wait for the attached process to finish initializing */
		expected = 1;
		ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);
		if (ret <= 0) {
			if (ret != 0)
				ERROR(""error using IPC to receive notification from attached process (1)"");
			goto cleanup_error;
		}

		/* tell attached process we're done */
		status = 2;
		ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));
		if (ret <= 0) {
			ERROR(""error using IPC to notify attached process for initialization (2)"");
			goto cleanup_error;
		}

		/* now shut down communication with child, we're done */
		shutdown(ipc_sockets[0], SHUT_RDWR);
		close(ipc_sockets[0]);
		lxc_proc_put_context_info(init_ctx);

		/* we're done, the child process should now execute whatever
		 * it is that the user requested. The parent can now track it
		 * with waitpid() or similar.
		 */

		*attached_process = attached_pid;
		return 0;

	cleanup_error:
		/* first shut down the socket, then wait for the pid,
		 * otherwise the pid we're waiting for may never exit
		 */
		shutdown(ipc_sockets[0], SHUT_RDWR);
		close(ipc_sockets[0]);
		if (to_cleanup_pid)
			(void) wait_for_pid(to_cleanup_pid);
		lxc_proc_put_context_info(init_ctx);
		return -1;
	}

	/* first subprocess begins here, we close the socket that is for the
	 * initial thread
	 */
	close(ipc_sockets[0]);

	/* Wait for the parent to have setup cgroups */
	expected = 0;
	status = -1;
	ret = lxc_read_nointr_expect(ipc_sockets[1], &status, sizeof(status), &expected);
	if (ret <= 0) {
		ERROR(""error communicating with child process"");
		shutdown(ipc_sockets[1], SHUT_RDWR);
 		rexit(-1);
 	}
 
 	/* attach now, create another subprocess later, since pid namespaces
 	 * only really affect the children of the current process
 	 */
	ret = lxc_attach_to_ns(init_pid, options->namespaces);
	if (ret < 0) {
		ERROR(""failed to enter the namespace"");
		shutdown(ipc_sockets[1], SHUT_RDWR);
		rexit(-1);
	}

	/* attach succeeded, try to cwd */
	if (options->initial_cwd)
		new_cwd = options->initial_cwd;
	else
		new_cwd = cwd;
	ret = chdir(new_cwd);
	if (ret < 0)
		WARN(""could not change directory to '%s'"", new_cwd);
	free(cwd);

	/* now create the real child process */
	{
		struct attach_clone_payload payload = {
			.ipc_socket = ipc_sockets[1],
 			.options = options,
 			.init_ctx = init_ctx,
 			.exec_function = exec_function,
			.exec_payload = exec_payload
 		};
 		/* We use clone_parent here to make this subprocess a direct child of
 		 * the initial process. Then this intermediate process can exit and
		 * the parent can directly track the attached process.
		 */
		pid = lxc_clone(attach_child_main, &payload, CLONE_PARENT);
	}

	/* shouldn't happen, clone() should always return positive pid */
	if (pid <= 0) {
		SYSERROR(""failed to create subprocess"");
		shutdown(ipc_sockets[1], SHUT_RDWR);
		rexit(-1);
	}

	/* tell grandparent the pid of the pid of the newly created child */
	ret = lxc_write_nointr(ipc_sockets[1], &pid, sizeof(pid));
	if (ret != sizeof(pid)) {
		/* if this really happens here, this is very unfortunate, since the
		 * parent will not know the pid of the attached process and will
		 * not be able to wait for it (and we won't either due to CLONE_PARENT)
		 * so the parent won't be able to reap it and the attached process
		 * will remain a zombie
		 */
		ERROR(""error using IPC to notify main process of pid of the attached process"");
		shutdown(ipc_sockets[1], SHUT_RDWR);
		rexit(-1);
	}

	/* the rest is in the hands of the initial and the attached process */
	rexit(0);
}
",C,"	int procfd;
	procfd = open(""/proc"", O_DIRECTORY | O_RDONLY);
	if (procfd < 0) {
		SYSERROR(""Unable to open /proc"");
		shutdown(ipc_sockets[1], SHUT_RDWR);
		rexit(-1);
	}

			.exec_payload = exec_payload,
			.procfd = procfd
","			.exec_payload = exec_payload
",,"@@ -76,6 +76,82 @@
 
 lxc_log_define(lxc_attach, lxc);
 
+int lsm_set_label_at(int procfd, int on_exec, char* lsm_label) {
+	int labelfd = -1;
+	int ret = 0;
+	const char* name;
+	char* command = NULL;
+
+	name = lsm_name();
+
+	if (strcmp(name, ""nop"") == 0)
+		goto out;
+
+	if (strcmp(name, ""none"") == 0)
+		goto out;
+
+	/* We don't support on-exec with AppArmor */
+	if (strcmp(name, ""AppArmor"") == 0)
+		on_exec = 0;
+
+	if (on_exec) {
+		labelfd = openat(procfd, ""self/attr/exec"", O_RDWR);
+	}
+	else {
+		labelfd = openat(procfd, ""self/attr/current"", O_RDWR);
+	}
+
+	if (labelfd < 0) {
+		SYSERROR(""Unable to open LSM label"");
+		ret = -1;
+		goto out;
+	}
+
+	if (strcmp(name, ""AppArmor"") == 0) {
+		int size;
+
+		command = malloc(strlen(lsm_label) + strlen(""changeprofile "") + 1);
+		if (!command) {
+			SYSERROR(""Failed to write apparmor profile"");
+			ret = -1;
+			goto out;
+		}
+
+		size = sprintf(command, ""changeprofile %s"", lsm_label);
+		if (size < 0) {
+			SYSERROR(""Failed to write apparmor profile"");
+			ret = -1;
+			goto out;
+		}
+
+		if (write(labelfd, command, size + 1) < 0) {
+			SYSERROR(""Unable to set LSM label"");
+			ret = -1;
+			goto out;
+		}
+	}
+	else if (strcmp(name, ""SELinux"") == 0) {
+		if (write(labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {
+			SYSERROR(""Unable to set LSM label"");
+			ret = -1;
+			goto out;
+		}
+	}
+	else {
+		ERROR(""Unable to restore label for unknown LSM: %s"", name);
+		ret = -1;
+		goto out;
+	}
+
+out:
+	free(command);
+
+	if (labelfd != -1)
+		close(labelfd);
+
+	return ret;
+}
+
 static struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)
 {
 	struct lxc_proc_context_info *info = calloc(1, sizeof(*info));
@@ -570,6 +646,7 @@ struct attach_clone_payload {
 	struct lxc_proc_context_info* init_ctx;
 	lxc_attach_exec_t exec_function;
 	void* exec_payload;
+	int procfd;
 };
 
 static int attach_child_main(void* data);
@@ -622,6 +699,7 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun
 	char* cwd;
 	char* new_cwd;
 	int ipc_sockets[2];
+	int procfd;
 	signed long personality;
 
 	if (!options)
@@ -833,6 +911,13 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun
 		rexit(-1);
 	}
 
+	procfd = open(""/proc"", O_DIRECTORY | O_RDONLY);
+	if (procfd < 0) {
+		SYSERROR(""Unable to open /proc"");
+		shutdown(ipc_sockets[1], SHUT_RDWR);
+		rexit(-1);
+	}
+
 	/* attach now, create another subprocess later, since pid namespaces
 	 * only really affect the children of the current process
 	 */
@@ -860,7 +945,8 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun
 			.options = options,
 			.init_ctx = init_ctx,
 			.exec_function = exec_function,
-			.exec_payload = exec_payload
+			.exec_payload = exec_payload,
+			.procfd = procfd
 		};
 		/* We use clone_parent here to make this subprocess a direct child of
 		 * the initial process. Then this intermediate process can exit and
@@ -898,6 +984,7 @@ static int attach_child_main(void* data)
 {
 	struct attach_clone_payload* payload = (struct attach_clone_payload*)data;
 	int ipc_socket = payload->ipc_socket;
+	int procfd = payload->procfd;
 	lxc_attach_options_t* options = payload->options;
 	struct lxc_proc_context_info* init_ctx = payload->init_ctx;
 #if HAVE_SYS_PERSONALITY_H
@@ -1038,21 +1125,11 @@ static int attach_child_main(void* data)
 	close(ipc_socket);
 
 	/* set new apparmor profile/selinux context */
-	if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM)) {
+	if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {
 		int on_exec;
-		int proc_mounted;
 
 		on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;
-		proc_mounted = mount_proc_if_needed(""/"");
-		if (proc_mounted == -1) {
-			ERROR(""Error mounting a sane /proc"");
-			rexit(-1);
-		}
-		ret = lsm_process_label_set(init_ctx->lsm_label,
-				init_ctx->container->lxc_conf, 0, on_exec);
-		if (proc_mounted)
-			umount(""/proc"");
-		if (ret < 0) {
+		if (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {
 			rexit(-1);
 		}
 	}
@@ -1103,6 +1180,9 @@ static int attach_child_main(void* data)
 		}
 	}
 
+	/* we don't need proc anymore */
+	close(procfd);
+
 	/* we're done, so we can now do whatever the user intended us to do */
 	rexit(payload->exec_function(payload->exec_payload));
 }",lxc,5c3fcae78b63ac9dd56e36075903921bd9461f9e,72cf81f6a3404e35028567db2c99a90406e9c6e6,1,"int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_function, void* exec_payload, lxc_attach_options_t* options, pid_t* attached_process)
{
	int ret, status;
	pid_t init_pid, pid, attached_pid, expected;
	struct lxc_proc_context_info *init_ctx;
 	char* cwd;
 	char* new_cwd;
 	int ipc_sockets[2];
//fix_flaw_line_below:
//	int procfd;
 	signed long personality;
 
 	if (!options)
		options = &attach_static_default_options;

	init_pid = lxc_cmd_get_init_pid(name, lxcpath);
	if (init_pid < 0) {
		ERROR(""failed to get the init pid"");
		return -1;
	}

	init_ctx = lxc_proc_get_context_info(init_pid);
	if (!init_ctx) {
		ERROR(""failed to get context of the init process, pid = %ld"", (long)init_pid);
		return -1;
	}

	personality = get_personality(name, lxcpath);
	if (init_ctx->personality < 0) {
		ERROR(""Failed to get personality of the container"");
		lxc_proc_put_context_info(init_ctx);
		return -1;
	}
	init_ctx->personality = personality;

	if (!fetch_seccomp(name, lxcpath, init_ctx, options))
		WARN(""Failed to get seccomp policy"");

	cwd = getcwd(NULL, 0);

	/* determine which namespaces the container was created with
	 * by asking lxc-start, if necessary
	 */
	if (options->namespaces == -1) {
		options->namespaces = lxc_cmd_get_clone_flags(name, lxcpath);
		/* call failed */
		if (options->namespaces == -1) {
			ERROR(""failed to automatically determine the ""
			      ""namespaces which the container unshared"");
			free(cwd);
			lxc_proc_put_context_info(init_ctx);
			return -1;
		}
	}

	/* create a socket pair for IPC communication; set SOCK_CLOEXEC in order
	 * to make sure we don't irritate other threads that want to fork+exec away
	 *
	 * IMPORTANT: if the initial process is multithreaded and another call
	 * just fork()s away without exec'ing directly after, the socket fd will
	 * exist in the forked process from the other thread and any close() in
	 * our own child process will not really cause the socket to close properly,
	 * potentiall causing the parent to hang.
	 *
	 * For this reason, while IPC is still active, we have to use shutdown()
	 * if the child exits prematurely in order to signal that the socket
	 * is closed and cannot assume that the child exiting will automatically
	 * do that.
	 *
	 * IPC mechanism: (X is receiver)
	 *   initial process        intermediate          attached
	 *        X           <---  send pid of
	 *                          attached proc,
	 *                          then exit
	 *    send 0 ------------------------------------>    X
	 *                                              [do initialization]
	 *        X  <------------------------------------  send 1
	 *   [add to cgroup, ...]
	 *    send 2 ------------------------------------>    X
	 *   close socket                                 close socket
	 *                                                run program
	 */
	ret = socketpair(PF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, ipc_sockets);
	if (ret < 0) {
		SYSERROR(""could not set up required IPC mechanism for attaching"");
		free(cwd);
		lxc_proc_put_context_info(init_ctx);
		return -1;
	}

	/* create intermediate subprocess, three reasons:
	 *       1. runs all pthread_atfork handlers and the
	 *          child will no longer be threaded
	 *          (we can't properly setns() in a threaded process)
	 *       2. we can't setns() in the child itself, since
	 *          we want to make sure we are properly attached to
	 *          the pidns
	 *       3. also, the initial thread has to put the attached
	 *          process into the cgroup, which we can only do if
	 *          we didn't already setns() (otherwise, user
	 *          namespaces will hate us)
	 */
	pid = fork();

	if (pid < 0) {
		SYSERROR(""failed to create first subprocess"");
		free(cwd);
		lxc_proc_put_context_info(init_ctx);
		return -1;
	}

	if (pid) {
		pid_t to_cleanup_pid = pid;

		/* initial thread, we close the socket that is for the
		 * subprocesses
		 */
		close(ipc_sockets[1]);
		free(cwd);

		/* attach to cgroup, if requested */
		if (options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) {
			if (!cgroup_attach(name, lxcpath, pid))
				goto cleanup_error;
		}

		/* Let the child process know to go ahead */
		status = 0;
		ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));
		if (ret <= 0) {
			ERROR(""error using IPC to notify attached process for initialization (0)"");
			goto cleanup_error;
		}

		/* get pid from intermediate process */
		ret = lxc_read_nointr_expect(ipc_sockets[0], &attached_pid, sizeof(attached_pid), NULL);
		if (ret <= 0) {
			if (ret != 0)
				ERROR(""error using IPC to receive pid of attached process"");
			goto cleanup_error;
		}

		/* ignore SIGKILL (CTRL-C) and SIGQUIT (CTRL-\) - issue #313 */
		if (options->stdin_fd == 0) {
			signal(SIGINT, SIG_IGN);
			signal(SIGQUIT, SIG_IGN);
		}

		/* reap intermediate process */
		ret = wait_for_pid(pid);
		if (ret < 0)
			goto cleanup_error;

		/* we will always have to reap the grandchild now */
		to_cleanup_pid = attached_pid;

		/* tell attached process it may start initializing */
		status = 0;
		ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));
		if (ret <= 0) {
			ERROR(""error using IPC to notify attached process for initialization (0)"");
			goto cleanup_error;
		}

		/* wait for the attached process to finish initializing */
		expected = 1;
		ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);
		if (ret <= 0) {
			if (ret != 0)
				ERROR(""error using IPC to receive notification from attached process (1)"");
			goto cleanup_error;
		}

		/* tell attached process we're done */
		status = 2;
		ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));
		if (ret <= 0) {
			ERROR(""error using IPC to notify attached process for initialization (2)"");
			goto cleanup_error;
		}

		/* now shut down communication with child, we're done */
		shutdown(ipc_sockets[0], SHUT_RDWR);
		close(ipc_sockets[0]);
		lxc_proc_put_context_info(init_ctx);

		/* we're done, the child process should now execute whatever
		 * it is that the user requested. The parent can now track it
		 * with waitpid() or similar.
		 */

		*attached_process = attached_pid;
		return 0;

	cleanup_error:
		/* first shut down the socket, then wait for the pid,
		 * otherwise the pid we're waiting for may never exit
		 */
		shutdown(ipc_sockets[0], SHUT_RDWR);
		close(ipc_sockets[0]);
		if (to_cleanup_pid)
			(void) wait_for_pid(to_cleanup_pid);
		lxc_proc_put_context_info(init_ctx);
		return -1;
	}

	/* first subprocess begins here, we close the socket that is for the
	 * initial thread
	 */
	close(ipc_sockets[0]);

	/* Wait for the parent to have setup cgroups */
	expected = 0;
	status = -1;
	ret = lxc_read_nointr_expect(ipc_sockets[1], &status, sizeof(status), &expected);
	if (ret <= 0) {
		ERROR(""error communicating with child process"");
		shutdown(ipc_sockets[1], SHUT_RDWR);
 		rexit(-1);
 	}
 
//fix_flaw_line_below:
//	procfd = open(""/proc"", O_DIRECTORY | O_RDONLY);
//fix_flaw_line_below:
//	if (procfd < 0) {
//fix_flaw_line_below:
//		SYSERROR(""Unable to open /proc"");
//fix_flaw_line_below:
//		shutdown(ipc_sockets[1], SHUT_RDWR);
//fix_flaw_line_below:
//		rexit(-1);
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	/* attach now, create another subprocess later, since pid namespaces
 	 * only really affect the children of the current process
 	 */
	ret = lxc_attach_to_ns(init_pid, options->namespaces);
	if (ret < 0) {
		ERROR(""failed to enter the namespace"");
		shutdown(ipc_sockets[1], SHUT_RDWR);
		rexit(-1);
	}

	/* attach succeeded, try to cwd */
	if (options->initial_cwd)
		new_cwd = options->initial_cwd;
	else
		new_cwd = cwd;
	ret = chdir(new_cwd);
	if (ret < 0)
		WARN(""could not change directory to '%s'"", new_cwd);
	free(cwd);

	/* now create the real child process */
	{
		struct attach_clone_payload payload = {
			.ipc_socket = ipc_sockets[1],
 			.options = options,
 			.init_ctx = init_ctx,
 			.exec_function = exec_function,
//flaw_line_below:
			.exec_payload = exec_payload
//fix_flaw_line_below:
//			.exec_payload = exec_payload,
//fix_flaw_line_below:
//			.procfd = procfd
 		};
 		/* We use clone_parent here to make this subprocess a direct child of
 		 * the initial process. Then this intermediate process can exit and
		 * the parent can directly track the attached process.
		 */
		pid = lxc_clone(attach_child_main, &payload, CLONE_PARENT);
	}

	/* shouldn't happen, clone() should always return positive pid */
	if (pid <= 0) {
		SYSERROR(""failed to create subprocess"");
		shutdown(ipc_sockets[1], SHUT_RDWR);
		rexit(-1);
	}

	/* tell grandparent the pid of the pid of the newly created child */
	ret = lxc_write_nointr(ipc_sockets[1], &pid, sizeof(pid));
	if (ret != sizeof(pid)) {
		/* if this really happens here, this is very unfortunate, since the
		 * parent will not know the pid of the attached process and will
		 * not be able to wait for it (and we won't either due to CLONE_PARENT)
		 * so the parent won't be able to reap it and the attached process
		 * will remain a zombie
		 */
		ERROR(""error using IPC to notify main process of pid of the attached process"");
		shutdown(ipc_sockets[1], SHUT_RDWR);
		rexit(-1);
	}

	/* the rest is in the hands of the initial and the attached process */
	rexit(0);
}
"
2165,179901,,Local,Not required,Complete,CVE-2015-0275,https://www.cvedetails.com/cve/CVE-2015-0275/,CWE-17,Low,,,,2015-10-19,4.9,The ext4_zero_range function in fs/ext4/extents.c in the Linux kernel before 4.1 allows local users to cause a denial of service (BUG) via a crafted fallocate zero-range request.,2019-04-08,DoS ,19,https://github.com/torvalds/linux/commit/0f2af21aae11972fa924374ddcf52e88347cf5a8,0f2af21aae11972fa924374ddcf52e88347cf5a8,"ext4: allocate entire range in zero range

Currently there is a bug in zero range code which causes zero range
calls to only allocate block aligned portion of the range, while
ignoring the rest in some cases.

In some cases, namely if the end of the range is past i_size, we do
attempt to preallocate the last nonaligned block. However this might
cause kernel to BUG() in some carefully designed zero range requests
on setups where page size > block size.

Fix this problem by first preallocating the entire range, including
the nonaligned edges and converting the written extents to unwritten
in the next step. This approach will also give us the advantage of
having the range to be as linearly contiguous as possible.

Signed-off-by: Lukas Czerner <lczerner@redhat.com>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>",11,fs/ext4/extents.c,"{""sha"": ""3cc17aacc4c7d01fc3816a217654ec5d8706094e"", ""filename"": ""fs/ext4/extents.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 12, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/0f2af21aae11972fa924374ddcf52e88347cf5a8/fs/ext4/extents.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0f2af21aae11972fa924374ddcf52e88347cf5a8/fs/ext4/extents.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/extents.c?ref=0f2af21aae11972fa924374ddcf52e88347cf5a8"", ""patch"": ""@@ -4797,12 +4797,6 @@ static long ext4_zero_range(struct file *file, loff_t offset,\n \telse\n \t\tmax_blocks -= lblk;\n \n-\tflags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |\n-\t\tEXT4_GET_BLOCKS_CONVERT_UNWRITTEN |\n-\t\tEXT4_EX_NOCACHE;\n-\tif (mode & FALLOC_FL_KEEP_SIZE)\n-\t\tflags |= EXT4_GET_BLOCKS_KEEP_SIZE;\n-\n \tmutex_lock(&inode->i_mutex);\n \n \t/*\n@@ -4819,15 +4813,28 @@ static long ext4_zero_range(struct file *file, loff_t offset,\n \t\tret = inode_newsize_ok(inode, new_size);\n \t\tif (ret)\n \t\t\tgoto out_mutex;\n-\t\t/*\n-\t\t * If we have a partial block after EOF we have to allocate\n-\t\t * the entire block.\n-\t\t */\n-\t\tif (partial_end)\n-\t\t\tmax_blocks += 1;\n \t}\n \n+\tflags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;\n+\tif (mode & FALLOC_FL_KEEP_SIZE)\n+\t\tflags |= EXT4_GET_BLOCKS_KEEP_SIZE;\n+\n+\t/* Preallocate the range including the unaligned edges */\n+\tif (partial_begin || partial_end) {\n+\t\tret = ext4_alloc_file_blocks(file,\n+\t\t\t\tround_down(offset, 1 << blkbits) >> blkbits,\n+\t\t\t\t(round_up((offset + len), 1 << blkbits) -\n+\t\t\t\t round_down(offset, 1 << blkbits)) >> blkbits,\n+\t\t\t\tnew_size, flags, mode);\n+\t\tif (ret)\n+\t\t\tgoto out_mutex;\n+\n+\t}\n+\n+\t/* Zero range excluding the unaligned edges */\n \tif (max_blocks > 0) {\n+\t\tflags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |\n+\t\t\t  EXT4_EX_NOCACHE);\n \n \t\t/* Now release the pages and zero block aligned part of pages*/\n \t\ttruncate_pagecache_range(inode, start, end - 1);""}","static long ext4_zero_range(struct file *file, loff_t offset,
			    loff_t len, int mode)
{
	struct inode *inode = file_inode(file);
	handle_t *handle = NULL;
	unsigned int max_blocks;
	loff_t new_size = 0;
	int ret = 0;
	int flags;
	int credits;
	int partial_begin, partial_end;
	loff_t start, end;
	ext4_lblk_t lblk;
	struct address_space *mapping = inode->i_mapping;
	unsigned int blkbits = inode->i_blkbits;

	trace_ext4_zero_range(inode, offset, len, mode);

	if (!S_ISREG(inode->i_mode))
		return -EINVAL;

	/* Call ext4_force_commit to flush all data in case of data=journal. */
	if (ext4_should_journal_data(inode)) {
		ret = ext4_force_commit(inode->i_sb);
		if (ret)
			return ret;
	}

	/*
	 * Write out all dirty pages to avoid race conditions
	 * Then release them.
	 */
	if (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {
		ret = filemap_write_and_wait_range(mapping, offset,
						   offset + len - 1);
		if (ret)
			return ret;
	}

	/*
	 * Round up offset. This is not fallocate, we neet to zero out
	 * blocks, so convert interior block aligned part of the range to
	 * unwritten and possibly manually zero out unaligned parts of the
	 * range.
	 */
	start = round_up(offset, 1 << blkbits);
	end = round_down((offset + len), 1 << blkbits);

	if (start < offset || end > offset + len)
		return -EINVAL;
	partial_begin = offset & ((1 << blkbits) - 1);
	partial_end = (offset + len) & ((1 << blkbits) - 1);

	lblk = start >> blkbits;
	max_blocks = (end >> blkbits);
	if (max_blocks < lblk)
		max_blocks = 0;
 	else
 		max_blocks -= lblk;
 
 	mutex_lock(&inode->i_mutex);
 
 	/*
	 * Indirect files do not support unwritten extnets
	 */
	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {
		ret = -EOPNOTSUPP;
		goto out_mutex;
	}

	if (!(mode & FALLOC_FL_KEEP_SIZE) &&
	     offset + len > i_size_read(inode)) {
		new_size = offset + len;
 		ret = inode_newsize_ok(inode, new_size);
 		if (ret)
 			goto out_mutex;
 	}
 
	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;
	if (mode & FALLOC_FL_KEEP_SIZE)
		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;

	/* Preallocate the range including the unaligned edges */
	if (partial_begin || partial_end) {
		ret = ext4_alloc_file_blocks(file,
				round_down(offset, 1 << blkbits) >> blkbits,
				(round_up((offset + len), 1 << blkbits) -
				 round_down(offset, 1 << blkbits)) >> blkbits,
				new_size, flags, mode);
		if (ret)
			goto out_mutex;

	}

	/* Zero range excluding the unaligned edges */
 	if (max_blocks > 0) {
		flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |
			  EXT4_EX_NOCACHE);
 
 		/* Now release the pages and zero block aligned part of pages*/
 		truncate_pagecache_range(inode, start, end - 1);
		inode->i_mtime = inode->i_ctime = ext4_current_time(inode);

		/* Wait all existing dio workers, newcomers will block on i_mutex */
		ext4_inode_block_unlocked_dio(inode);
		inode_dio_wait(inode);

		ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,
					     flags, mode);
		if (ret)
			goto out_dio;
		/*
		 * Remove entire range from the extent status tree.
		 *
		 * ext4_es_remove_extent(inode, lblk, max_blocks) is
		 * NOT sufficient.  I'm not sure why this is the case,
		 * but let's be conservative and remove the extent
		 * status tree for the entire inode.  There should be
		 * no outstanding delalloc extents thanks to the
		 * filemap_write_and_wait_range() call above.
		 */
		ret = ext4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);
		if (ret)
			goto out_dio;
	}
	if (!partial_begin && !partial_end)
		goto out_dio;

	/*
	 * In worst case we have to writeout two nonadjacent unwritten
	 * blocks and update the inode
	 */
	credits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1;
	if (ext4_should_journal_data(inode))
		credits += 2;
	handle = ext4_journal_start(inode, EXT4_HT_MISC, credits);
	if (IS_ERR(handle)) {
		ret = PTR_ERR(handle);
		ext4_std_error(inode->i_sb, ret);
		goto out_dio;
	}

	inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
	if (new_size) {
		ext4_update_inode_size(inode, new_size);
	} else {
		/*
		* Mark that we allocate beyond EOF so the subsequent truncate
		* can proceed even if the new size is the same as i_size.
		*/
		if ((offset + len) > i_size_read(inode))
			ext4_set_inode_flag(inode, EXT4_INODE_EOFBLOCKS);
	}
	ext4_mark_inode_dirty(handle, inode);

	/* Zero out partial block at the edges of the range */
	ret = ext4_zero_partial_blocks(handle, inode, offset, len);

	if (file->f_flags & O_SYNC)
		ext4_handle_sync(handle);

	ext4_journal_stop(handle);
out_dio:
	ext4_inode_resume_unlocked_dio(inode);
out_mutex:
	mutex_unlock(&inode->i_mutex);
	return ret;
}
","static long ext4_zero_range(struct file *file, loff_t offset,
			    loff_t len, int mode)
{
	struct inode *inode = file_inode(file);
	handle_t *handle = NULL;
	unsigned int max_blocks;
	loff_t new_size = 0;
	int ret = 0;
	int flags;
	int credits;
	int partial_begin, partial_end;
	loff_t start, end;
	ext4_lblk_t lblk;
	struct address_space *mapping = inode->i_mapping;
	unsigned int blkbits = inode->i_blkbits;

	trace_ext4_zero_range(inode, offset, len, mode);

	if (!S_ISREG(inode->i_mode))
		return -EINVAL;

	/* Call ext4_force_commit to flush all data in case of data=journal. */
	if (ext4_should_journal_data(inode)) {
		ret = ext4_force_commit(inode->i_sb);
		if (ret)
			return ret;
	}

	/*
	 * Write out all dirty pages to avoid race conditions
	 * Then release them.
	 */
	if (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {
		ret = filemap_write_and_wait_range(mapping, offset,
						   offset + len - 1);
		if (ret)
			return ret;
	}

	/*
	 * Round up offset. This is not fallocate, we neet to zero out
	 * blocks, so convert interior block aligned part of the range to
	 * unwritten and possibly manually zero out unaligned parts of the
	 * range.
	 */
	start = round_up(offset, 1 << blkbits);
	end = round_down((offset + len), 1 << blkbits);

	if (start < offset || end > offset + len)
		return -EINVAL;
	partial_begin = offset & ((1 << blkbits) - 1);
	partial_end = (offset + len) & ((1 << blkbits) - 1);

	lblk = start >> blkbits;
	max_blocks = (end >> blkbits);
	if (max_blocks < lblk)
		max_blocks = 0;
 	else
 		max_blocks -= lblk;
 
	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |
		EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |
		EXT4_EX_NOCACHE;
	if (mode & FALLOC_FL_KEEP_SIZE)
		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;
 	mutex_lock(&inode->i_mutex);
 
 	/*
	 * Indirect files do not support unwritten extnets
	 */
	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {
		ret = -EOPNOTSUPP;
		goto out_mutex;
	}

	if (!(mode & FALLOC_FL_KEEP_SIZE) &&
	     offset + len > i_size_read(inode)) {
		new_size = offset + len;
 		ret = inode_newsize_ok(inode, new_size);
 		if (ret)
 			goto out_mutex;
		/*
		 * If we have a partial block after EOF we have to allocate
		 * the entire block.
		 */
		if (partial_end)
			max_blocks += 1;
 	}
 
 	if (max_blocks > 0) {
 
 		/* Now release the pages and zero block aligned part of pages*/
 		truncate_pagecache_range(inode, start, end - 1);
		inode->i_mtime = inode->i_ctime = ext4_current_time(inode);

		/* Wait all existing dio workers, newcomers will block on i_mutex */
		ext4_inode_block_unlocked_dio(inode);
		inode_dio_wait(inode);

		ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,
					     flags, mode);
		if (ret)
			goto out_dio;
		/*
		 * Remove entire range from the extent status tree.
		 *
		 * ext4_es_remove_extent(inode, lblk, max_blocks) is
		 * NOT sufficient.  I'm not sure why this is the case,
		 * but let's be conservative and remove the extent
		 * status tree for the entire inode.  There should be
		 * no outstanding delalloc extents thanks to the
		 * filemap_write_and_wait_range() call above.
		 */
		ret = ext4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);
		if (ret)
			goto out_dio;
	}
	if (!partial_begin && !partial_end)
		goto out_dio;

	/*
	 * In worst case we have to writeout two nonadjacent unwritten
	 * blocks and update the inode
	 */
	credits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1;
	if (ext4_should_journal_data(inode))
		credits += 2;
	handle = ext4_journal_start(inode, EXT4_HT_MISC, credits);
	if (IS_ERR(handle)) {
		ret = PTR_ERR(handle);
		ext4_std_error(inode->i_sb, ret);
		goto out_dio;
	}

	inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
	if (new_size) {
		ext4_update_inode_size(inode, new_size);
	} else {
		/*
		* Mark that we allocate beyond EOF so the subsequent truncate
		* can proceed even if the new size is the same as i_size.
		*/
		if ((offset + len) > i_size_read(inode))
			ext4_set_inode_flag(inode, EXT4_INODE_EOFBLOCKS);
	}
	ext4_mark_inode_dirty(handle, inode);

	/* Zero out partial block at the edges of the range */
	ret = ext4_zero_partial_blocks(handle, inode, offset, len);

	if (file->f_flags & O_SYNC)
		ext4_handle_sync(handle);

	ext4_journal_stop(handle);
out_dio:
	ext4_inode_resume_unlocked_dio(inode);
out_mutex:
	mutex_unlock(&inode->i_mutex);
	return ret;
}
",C,"	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;
	if (mode & FALLOC_FL_KEEP_SIZE)
		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;

	/* Preallocate the range including the unaligned edges */
	if (partial_begin || partial_end) {
		ret = ext4_alloc_file_blocks(file,
				round_down(offset, 1 << blkbits) >> blkbits,
				(round_up((offset + len), 1 << blkbits) -
				 round_down(offset, 1 << blkbits)) >> blkbits,
				new_size, flags, mode);
		if (ret)
			goto out_mutex;

	}

	/* Zero range excluding the unaligned edges */
		flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |
			  EXT4_EX_NOCACHE);
","	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |
		EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |
		EXT4_EX_NOCACHE;
	if (mode & FALLOC_FL_KEEP_SIZE)
		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;
		/*
		 * If we have a partial block after EOF we have to allocate
		 * the entire block.
		 */
		if (partial_end)
			max_blocks += 1;
",,"@@ -4797,12 +4797,6 @@ static long ext4_zero_range(struct file *file, loff_t offset,
 	else
 		max_blocks -= lblk;
 
-	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |
-		EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |
-		EXT4_EX_NOCACHE;
-	if (mode & FALLOC_FL_KEEP_SIZE)
-		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;
-
 	mutex_lock(&inode->i_mutex);
 
 	/*
@@ -4819,15 +4813,28 @@ static long ext4_zero_range(struct file *file, loff_t offset,
 		ret = inode_newsize_ok(inode, new_size);
 		if (ret)
 			goto out_mutex;
-		/*
-		 * If we have a partial block after EOF we have to allocate
-		 * the entire block.
-		 */
-		if (partial_end)
-			max_blocks += 1;
 	}
 
+	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;
+	if (mode & FALLOC_FL_KEEP_SIZE)
+		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;
+
+	/* Preallocate the range including the unaligned edges */
+	if (partial_begin || partial_end) {
+		ret = ext4_alloc_file_blocks(file,
+				round_down(offset, 1 << blkbits) >> blkbits,
+				(round_up((offset + len), 1 << blkbits) -
+				 round_down(offset, 1 << blkbits)) >> blkbits,
+				new_size, flags, mode);
+		if (ret)
+			goto out_mutex;
+
+	}
+
+	/* Zero range excluding the unaligned edges */
 	if (max_blocks > 0) {
+		flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |
+			  EXT4_EX_NOCACHE);
 
 		/* Now release the pages and zero block aligned part of pages*/
 		truncate_pagecache_range(inode, start, end - 1);",linux,0f2af21aae11972fa924374ddcf52e88347cf5a8,5a4f3145aa685ddc2caf424763d42d3eaaebbc6f,1,"static long ext4_zero_range(struct file *file, loff_t offset,
			    loff_t len, int mode)
{
	struct inode *inode = file_inode(file);
	handle_t *handle = NULL;
	unsigned int max_blocks;
	loff_t new_size = 0;
	int ret = 0;
	int flags;
	int credits;
	int partial_begin, partial_end;
	loff_t start, end;
	ext4_lblk_t lblk;
	struct address_space *mapping = inode->i_mapping;
	unsigned int blkbits = inode->i_blkbits;

	trace_ext4_zero_range(inode, offset, len, mode);

	if (!S_ISREG(inode->i_mode))
		return -EINVAL;

	/* Call ext4_force_commit to flush all data in case of data=journal. */
	if (ext4_should_journal_data(inode)) {
		ret = ext4_force_commit(inode->i_sb);
		if (ret)
			return ret;
	}

	/*
	 * Write out all dirty pages to avoid race conditions
	 * Then release them.
	 */
	if (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {
		ret = filemap_write_and_wait_range(mapping, offset,
						   offset + len - 1);
		if (ret)
			return ret;
	}

	/*
	 * Round up offset. This is not fallocate, we neet to zero out
	 * blocks, so convert interior block aligned part of the range to
	 * unwritten and possibly manually zero out unaligned parts of the
	 * range.
	 */
	start = round_up(offset, 1 << blkbits);
	end = round_down((offset + len), 1 << blkbits);

	if (start < offset || end > offset + len)
		return -EINVAL;
	partial_begin = offset & ((1 << blkbits) - 1);
	partial_end = (offset + len) & ((1 << blkbits) - 1);

	lblk = start >> blkbits;
	max_blocks = (end >> blkbits);
	if (max_blocks < lblk)
		max_blocks = 0;
 	else
 		max_blocks -= lblk;
 
//flaw_line_below:
	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |
//flaw_line_below:
		EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |
//flaw_line_below:
		EXT4_EX_NOCACHE;
//flaw_line_below:
	if (mode & FALLOC_FL_KEEP_SIZE)
//flaw_line_below:
		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;
//flaw_line_below:

 	mutex_lock(&inode->i_mutex);
 
 	/*
	 * Indirect files do not support unwritten extnets
	 */
	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {
		ret = -EOPNOTSUPP;
		goto out_mutex;
	}

	if (!(mode & FALLOC_FL_KEEP_SIZE) &&
	     offset + len > i_size_read(inode)) {
		new_size = offset + len;
 		ret = inode_newsize_ok(inode, new_size);
 		if (ret)
 			goto out_mutex;
//flaw_line_below:
		/*
//flaw_line_below:
		 * If we have a partial block after EOF we have to allocate
//flaw_line_below:
		 * the entire block.
//flaw_line_below:
		 */
//flaw_line_below:
		if (partial_end)
//flaw_line_below:
			max_blocks += 1;
 	}
 
//fix_flaw_line_below:
//	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;
//fix_flaw_line_below:
//	if (mode & FALLOC_FL_KEEP_SIZE)
//fix_flaw_line_below:
//		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* Preallocate the range including the unaligned edges */
//fix_flaw_line_below:
//	if (partial_begin || partial_end) {
//fix_flaw_line_below:
//		ret = ext4_alloc_file_blocks(file,
//fix_flaw_line_below:
//				round_down(offset, 1 << blkbits) >> blkbits,
//fix_flaw_line_below:
//				(round_up((offset + len), 1 << blkbits) -
//fix_flaw_line_below:
//				 round_down(offset, 1 << blkbits)) >> blkbits,
//fix_flaw_line_below:
//				new_size, flags, mode);
//fix_flaw_line_below:
//		if (ret)
//fix_flaw_line_below:
//			goto out_mutex;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* Zero range excluding the unaligned edges */
 	if (max_blocks > 0) {
//fix_flaw_line_below:
//		flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |
//fix_flaw_line_below:
//			  EXT4_EX_NOCACHE);
 
 		/* Now release the pages and zero block aligned part of pages*/
 		truncate_pagecache_range(inode, start, end - 1);
		inode->i_mtime = inode->i_ctime = ext4_current_time(inode);

		/* Wait all existing dio workers, newcomers will block on i_mutex */
		ext4_inode_block_unlocked_dio(inode);
		inode_dio_wait(inode);

		ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,
					     flags, mode);
		if (ret)
			goto out_dio;
		/*
		 * Remove entire range from the extent status tree.
		 *
		 * ext4_es_remove_extent(inode, lblk, max_blocks) is
		 * NOT sufficient.  I'm not sure why this is the case,
		 * but let's be conservative and remove the extent
		 * status tree for the entire inode.  There should be
		 * no outstanding delalloc extents thanks to the
		 * filemap_write_and_wait_range() call above.
		 */
		ret = ext4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);
		if (ret)
			goto out_dio;
	}
	if (!partial_begin && !partial_end)
		goto out_dio;

	/*
	 * In worst case we have to writeout two nonadjacent unwritten
	 * blocks and update the inode
	 */
	credits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1;
	if (ext4_should_journal_data(inode))
		credits += 2;
	handle = ext4_journal_start(inode, EXT4_HT_MISC, credits);
	if (IS_ERR(handle)) {
		ret = PTR_ERR(handle);
		ext4_std_error(inode->i_sb, ret);
		goto out_dio;
	}

	inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
	if (new_size) {
		ext4_update_inode_size(inode, new_size);
	} else {
		/*
		* Mark that we allocate beyond EOF so the subsequent truncate
		* can proceed even if the new size is the same as i_size.
		*/
		if ((offset + len) > i_size_read(inode))
			ext4_set_inode_flag(inode, EXT4_INODE_EOFBLOCKS);
	}
	ext4_mark_inode_dirty(handle, inode);

	/* Zero out partial block at the edges of the range */
	ret = ext4_zero_partial_blocks(handle, inode, offset, len);

	if (file->f_flags & O_SYNC)
		ext4_handle_sync(handle);

	ext4_journal_stop(handle);
out_dio:
	ext4_inode_resume_unlocked_dio(inode);
out_mutex:
	mutex_unlock(&inode->i_mutex);
	return ret;
}
"
2191,179927,,Local,Not required,,CVE-2014-9731,https://www.cvedetails.com/cve/CVE-2014-9731/,CWE-17,Low,Partial,,,2015-08-31,2.1,"The UDF filesystem implementation in the Linux kernel before 3.18.2 does not ensure that space is available for storing a symlink target's name along with a trailing 0 character, which allows local users to obtain sensitive information via a crafted filesystem image, related to fs/udf/symlink.c and fs/udf/unicode.c.",2017-07-12,+Info ,2,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,"udf: Check path length when reading symlink

Symlink reading code does not check whether the resulting path fits into
the page provided by the generic code. This isn't as easy as just
checking the symlink size because of various encoding conversions we
perform on path. So we have to check whether there is still enough space
in the buffer on the fly.

CC: stable@vger.kernel.org
Reported-by: Carl Henrik Lunde <chlunde@ping.uio.no>
Signed-off-by: Jan Kara <jack@suse.cz>",1,fs/udf/dir.c,"{""sha"": ""a7690b46ce0a18624b80f056b1399c9520dffeda"", ""filename"": ""fs/udf/dir.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/dir.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/dir.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/dir.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -167,7 +167,8 @@ static int udf_readdir(struct file *file, struct dir_context *ctx)\n \t\t\tcontinue;\n \t\t}\n \n-\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n+\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n+\t\t\t\t\tUDF_NAME_LEN);\n \t\tif (!flen)\n \t\t\tcontinue;\n ""}<_**next**_>{""sha"": ""6ff19b54b51f285971232e30e9d437fa3966654a"", ""filename"": ""fs/udf/namei.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/namei.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/namei.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/namei.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -233,7 +233,8 @@ static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n \t\tif (!lfi)\n \t\t\tcontinue;\n \n-\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n+\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n+\t\t\t\t\tUDF_NAME_LEN);\n \t\tif (flen && udf_match(flen, fname, child->len, child->name))\n \t\t\tgoto out_ok;\n \t}""}<_**next**_>{""sha"": ""0f1b3a2654b9459a36c4df943f1f22a3bff070af"", ""filename"": ""fs/udf/symlink.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 5, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/symlink.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/symlink.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/symlink.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -30,13 +30,16 @@\n #include <linux/buffer_head.h>\n #include \""udf_i.h\""\n \n-static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n-\t\t\t   int fromlen, unsigned char *to)\n+static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n+\t\t\t  int fromlen, unsigned char *to, int tolen)\n {\n \tstruct pathComponent *pc;\n \tint elen = 0;\n+\tint comp_len;\n \tunsigned char *p = to;\n \n+\t/* Reserve one byte for terminating \\0 */\n+\ttolen--;\n \twhile (elen < fromlen) {\n \t\tpc = (struct pathComponent *)(from + elen);\n \t\tswitch (pc->componentType) {\n@@ -49,22 +52,37 @@ static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n \t\t\t\tbreak;\n \t\t\t/* Fall through */\n \t\tcase 2:\n+\t\t\tif (tolen == 0)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tp = to;\n \t\t\t*p++ = '/';\n+\t\t\ttolen--;\n \t\t\tbreak;\n \t\tcase 3:\n+\t\t\tif (tolen < 3)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tmemcpy(p, \""../\"", 3);\n \t\t\tp += 3;\n+\t\t\ttolen -= 3;\n \t\t\tbreak;\n \t\tcase 4:\n+\t\t\tif (tolen < 2)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tmemcpy(p, \""./\"", 2);\n \t\t\tp += 2;\n+\t\t\ttolen -= 2;\n \t\t\t/* that would be . - just ignore */\n \t\t\tbreak;\n \t\tcase 5:\n-\t\t\tp += udf_get_filename(sb, pc->componentIdent, p,\n-\t\t\t\t\t      pc->lengthComponentIdent);\n+\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n+\t\t\t\t\t\t    pc->lengthComponentIdent,\n+\t\t\t\t\t\t    p, tolen);\n+\t\t\tp += comp_len;\n+\t\t\ttolen -= comp_len;\n+\t\t\tif (tolen == 0)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\t*p++ = '/';\n+\t\t\ttolen--;\n \t\t\tbreak;\n \t\t}\n \t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n@@ -73,6 +91,7 @@ static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n \t\tp[-1] = '\\0';\n \telse\n \t\tp[0] = '\\0';\n+\treturn 0;\n }\n \n static int udf_symlink_filler(struct file *file, struct page *page)\n@@ -108,8 +127,10 @@ static int udf_symlink_filler(struct file *file, struct page *page)\n \t\tsymlink = bh->b_data;\n \t}\n \n-\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n+\terr = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);\n \tbrelse(bh);\n+\tif (err)\n+\t\tgoto out_unlock_inode;\n \n \tup_read(&iinfo->i_data_sem);\n \tSetPageUptodate(page);""}<_**next**_>{""sha"": ""47bb3f5ca360d4f1be8f92036685278868ab99e3"", ""filename"": ""fs/udf/udfdecl.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/udfdecl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/udfdecl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/udfdecl.h?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -211,7 +211,8 @@ udf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n }\n \n /* unicode.c */\n-extern int udf_get_filename(struct super_block *, uint8_t *, uint8_t *, int);\n+extern int udf_get_filename(struct super_block *, uint8_t *, int, uint8_t *,\n+\t\t\t    int);\n extern int udf_put_filename(struct super_block *, const uint8_t *, uint8_t *,\n \t\t\t    int);\n extern int udf_build_ustr(struct ustr *, dstring *, int);""}<_**next**_>{""sha"": ""b84fee372734bd494ba5eb86f5ce5c8c28b99b5a"", ""filename"": ""fs/udf/unicode.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 12, ""changes"": 28, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/unicode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/unicode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/unicode.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -28,7 +28,8 @@\n \n #include \""udf_sb.h\""\n \n-static int udf_translate_to_linux(uint8_t *, uint8_t *, int, uint8_t *, int);\n+static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n+\t\t\t\t  int);\n \n static int udf_char_to_ustr(struct ustr *dest, const uint8_t *src, int strlen)\n {\n@@ -333,8 +334,8 @@ static int udf_NLStoCS0(struct nls_table *nls, dstring *ocu, struct ustr *uni,\n \treturn u_len + 1;\n }\n \n-int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n-\t\t     int flen)\n+int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,\n+\t\t     uint8_t *dname, int dlen)\n {\n \tstruct ustr *filename, *unifilename;\n \tint len = 0;\n@@ -347,7 +348,7 @@ int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n \tif (!unifilename)\n \t\tgoto out1;\n \n-\tif (udf_build_ustr_exact(unifilename, sname, flen))\n+\tif (udf_build_ustr_exact(unifilename, sname, slen))\n \t\tgoto out2;\n \n \tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n@@ -366,7 +367,8 @@ int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n \t} else\n \t\tgoto out2;\n \n-\tlen = udf_translate_to_linux(dname, filename->u_name, filename->u_len,\n+\tlen = udf_translate_to_linux(dname, dlen,\n+\t\t\t\t     filename->u_name, filename->u_len,\n \t\t\t\t     unifilename->u_name, unifilename->u_len);\n out2:\n \tkfree(unifilename);\n@@ -403,10 +405,12 @@ int udf_put_filename(struct super_block *sb, const uint8_t *sname,\n #define EXT_MARK\t\t'.'\n #define CRC_MARK\t\t'#'\n #define EXT_SIZE \t\t5\n+/* Number of chars we need to store generated CRC to make filename unique */\n+#define CRC_LEN\t\t\t5\n \n-static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n-\t\t\t\t  int udfLen, uint8_t *fidName,\n-\t\t\t\t  int fidNameLen)\n+static int udf_translate_to_linux(uint8_t *newName, int newLen,\n+\t\t\t\t  uint8_t *udfName, int udfLen,\n+\t\t\t\t  uint8_t *fidName, int fidNameLen)\n {\n \tint index, newIndex = 0, needsCRC = 0;\n \tint extIndex = 0, newExtIndex = 0, hasExt = 0;\n@@ -439,7 +443,7 @@ static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n \t\t\t\t\tnewExtIndex = newIndex;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif (newIndex < 256)\n+\t\t\tif (newIndex < newLen)\n \t\t\t\tnewName[newIndex++] = curr;\n \t\t\telse\n \t\t\t\tneedsCRC = 1;\n@@ -467,13 +471,13 @@ static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n \t\t\t\t}\n \t\t\t\text[localExtIndex++] = curr;\n \t\t\t}\n-\t\t\tmaxFilenameLen = 250 - localExtIndex;\n+\t\t\tmaxFilenameLen = newLen - CRC_LEN - localExtIndex;\n \t\t\tif (newIndex > maxFilenameLen)\n \t\t\t\tnewIndex = maxFilenameLen;\n \t\t\telse\n \t\t\t\tnewIndex = newExtIndex;\n-\t\t} else if (newIndex > 250)\n-\t\t\tnewIndex = 250;\n+\t\t} else if (newIndex > newLen - CRC_LEN)\n+\t\t\tnewIndex = newLen - CRC_LEN;\n \t\tnewName[newIndex++] = CRC_MARK;\n \t\tvalueCRC = crc_itu_t(0, fidName, fidNameLen);\n \t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);""}","static int udf_readdir(struct file *file, struct dir_context *ctx)
{
	struct inode *dir = file_inode(file);
	struct udf_inode_info *iinfo = UDF_I(dir);
	struct udf_fileident_bh fibh = { .sbh = NULL, .ebh = NULL};
	struct fileIdentDesc *fi = NULL;
	struct fileIdentDesc cfi;
	int block, iblock;
	loff_t nf_pos;
	int flen;
	unsigned char *fname = NULL;
	unsigned char *nameptr;
	uint16_t liu;
	uint8_t lfi;
	loff_t size = udf_ext0_offset(dir) + dir->i_size;
	struct buffer_head *tmp, *bha[16];
	struct kernel_lb_addr eloc;
	uint32_t elen;
	sector_t offset;
	int i, num, ret = 0;
	struct extent_position epos = { NULL, 0, {0, 0} };

	if (ctx->pos == 0) {
		if (!dir_emit_dot(file, ctx))
			return 0;
		ctx->pos = 1;
	}
	nf_pos = (ctx->pos - 1) << 2;
	if (nf_pos >= size)
		goto out;

	fname = kmalloc(UDF_NAME_LEN, GFP_NOFS);
	if (!fname) {
		ret = -ENOMEM;
		goto out;
	}

	if (nf_pos == 0)
		nf_pos = udf_ext0_offset(dir);

	fibh.soffset = fibh.eoffset = nf_pos & (dir->i_sb->s_blocksize - 1);
	if (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {
		if (inode_bmap(dir, nf_pos >> dir->i_sb->s_blocksize_bits,
		    &epos, &eloc, &elen, &offset)
		    != (EXT_RECORDED_ALLOCATED >> 30)) {
			ret = -ENOENT;
			goto out;
		}
		block = udf_get_lb_pblock(dir->i_sb, &eloc, offset);
		if ((++offset << dir->i_sb->s_blocksize_bits) < elen) {
			if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)
				epos.offset -= sizeof(struct short_ad);
			else if (iinfo->i_alloc_type ==
					ICBTAG_FLAG_AD_LONG)
				epos.offset -= sizeof(struct long_ad);
		} else {
			offset = 0;
		}

		if (!(fibh.sbh = fibh.ebh = udf_tread(dir->i_sb, block))) {
			ret = -EIO;
			goto out;
		}

		if (!(offset & ((16 >> (dir->i_sb->s_blocksize_bits - 9)) - 1))) {
			i = 16 >> (dir->i_sb->s_blocksize_bits - 9);
			if (i + offset > (elen >> dir->i_sb->s_blocksize_bits))
				i = (elen >> dir->i_sb->s_blocksize_bits) - offset;
			for (num = 0; i > 0; i--) {
				block = udf_get_lb_pblock(dir->i_sb, &eloc, offset + i);
				tmp = udf_tgetblk(dir->i_sb, block);
				if (tmp && !buffer_uptodate(tmp) && !buffer_locked(tmp))
					bha[num++] = tmp;
				else
					brelse(tmp);
			}
			if (num) {
				ll_rw_block(READA, num, bha);
				for (i = 0; i < num; i++)
					brelse(bha[i]);
			}
		}
	}

	while (nf_pos < size) {
		struct kernel_lb_addr tloc;

		ctx->pos = (nf_pos >> 2) + 1;

		fi = udf_fileident_read(dir, &nf_pos, &fibh, &cfi, &epos, &eloc,
					&elen, &offset);
		if (!fi)
			goto out;

		liu = le16_to_cpu(cfi.lengthOfImpUse);
		lfi = cfi.lengthFileIdent;

		if (fibh.sbh == fibh.ebh) {
			nameptr = fi->fileIdent + liu;
		} else {
			int poffset;	/* Unpaded ending offset */

			poffset = fibh.soffset + sizeof(struct fileIdentDesc) + liu + lfi;

			if (poffset >= lfi) {
				nameptr = (char *)(fibh.ebh->b_data + poffset - lfi);
			} else {
				nameptr = fname;
				memcpy(nameptr, fi->fileIdent + liu,
				       lfi - poffset);
				memcpy(nameptr + lfi - poffset,
				       fibh.ebh->b_data, poffset);
			}
		}

		if ((cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {
			if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))
				continue;
		}

		if ((cfi.fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {
			if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))
				continue;
		}

		if (cfi.fileCharacteristics & FID_FILE_CHAR_PARENT) {
			if (!dir_emit_dotdot(file, ctx))
				goto out;
 			continue;
 		}
 
		flen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,
					UDF_NAME_LEN);
 		if (!flen)
 			continue;
 
		tloc = lelb_to_cpu(cfi.icb.extLocation);
		iblock = udf_get_lb_pblock(dir->i_sb, &tloc, 0);
		if (!dir_emit(ctx, fname, flen, iblock, DT_UNKNOWN))
			goto out;
	} /* end while */

	ctx->pos = (nf_pos >> 2) + 1;

out:
	if (fibh.sbh != fibh.ebh)
		brelse(fibh.ebh);
	brelse(fibh.sbh);
	brelse(epos.bh);
	kfree(fname);

	return ret;
}
","static int udf_readdir(struct file *file, struct dir_context *ctx)
{
	struct inode *dir = file_inode(file);
	struct udf_inode_info *iinfo = UDF_I(dir);
	struct udf_fileident_bh fibh = { .sbh = NULL, .ebh = NULL};
	struct fileIdentDesc *fi = NULL;
	struct fileIdentDesc cfi;
	int block, iblock;
	loff_t nf_pos;
	int flen;
	unsigned char *fname = NULL;
	unsigned char *nameptr;
	uint16_t liu;
	uint8_t lfi;
	loff_t size = udf_ext0_offset(dir) + dir->i_size;
	struct buffer_head *tmp, *bha[16];
	struct kernel_lb_addr eloc;
	uint32_t elen;
	sector_t offset;
	int i, num, ret = 0;
	struct extent_position epos = { NULL, 0, {0, 0} };

	if (ctx->pos == 0) {
		if (!dir_emit_dot(file, ctx))
			return 0;
		ctx->pos = 1;
	}
	nf_pos = (ctx->pos - 1) << 2;
	if (nf_pos >= size)
		goto out;

	fname = kmalloc(UDF_NAME_LEN, GFP_NOFS);
	if (!fname) {
		ret = -ENOMEM;
		goto out;
	}

	if (nf_pos == 0)
		nf_pos = udf_ext0_offset(dir);

	fibh.soffset = fibh.eoffset = nf_pos & (dir->i_sb->s_blocksize - 1);
	if (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {
		if (inode_bmap(dir, nf_pos >> dir->i_sb->s_blocksize_bits,
		    &epos, &eloc, &elen, &offset)
		    != (EXT_RECORDED_ALLOCATED >> 30)) {
			ret = -ENOENT;
			goto out;
		}
		block = udf_get_lb_pblock(dir->i_sb, &eloc, offset);
		if ((++offset << dir->i_sb->s_blocksize_bits) < elen) {
			if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)
				epos.offset -= sizeof(struct short_ad);
			else if (iinfo->i_alloc_type ==
					ICBTAG_FLAG_AD_LONG)
				epos.offset -= sizeof(struct long_ad);
		} else {
			offset = 0;
		}

		if (!(fibh.sbh = fibh.ebh = udf_tread(dir->i_sb, block))) {
			ret = -EIO;
			goto out;
		}

		if (!(offset & ((16 >> (dir->i_sb->s_blocksize_bits - 9)) - 1))) {
			i = 16 >> (dir->i_sb->s_blocksize_bits - 9);
			if (i + offset > (elen >> dir->i_sb->s_blocksize_bits))
				i = (elen >> dir->i_sb->s_blocksize_bits) - offset;
			for (num = 0; i > 0; i--) {
				block = udf_get_lb_pblock(dir->i_sb, &eloc, offset + i);
				tmp = udf_tgetblk(dir->i_sb, block);
				if (tmp && !buffer_uptodate(tmp) && !buffer_locked(tmp))
					bha[num++] = tmp;
				else
					brelse(tmp);
			}
			if (num) {
				ll_rw_block(READA, num, bha);
				for (i = 0; i < num; i++)
					brelse(bha[i]);
			}
		}
	}

	while (nf_pos < size) {
		struct kernel_lb_addr tloc;

		ctx->pos = (nf_pos >> 2) + 1;

		fi = udf_fileident_read(dir, &nf_pos, &fibh, &cfi, &epos, &eloc,
					&elen, &offset);
		if (!fi)
			goto out;

		liu = le16_to_cpu(cfi.lengthOfImpUse);
		lfi = cfi.lengthFileIdent;

		if (fibh.sbh == fibh.ebh) {
			nameptr = fi->fileIdent + liu;
		} else {
			int poffset;	/* Unpaded ending offset */

			poffset = fibh.soffset + sizeof(struct fileIdentDesc) + liu + lfi;

			if (poffset >= lfi) {
				nameptr = (char *)(fibh.ebh->b_data + poffset - lfi);
			} else {
				nameptr = fname;
				memcpy(nameptr, fi->fileIdent + liu,
				       lfi - poffset);
				memcpy(nameptr + lfi - poffset,
				       fibh.ebh->b_data, poffset);
			}
		}

		if ((cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {
			if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))
				continue;
		}

		if ((cfi.fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {
			if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))
				continue;
		}

		if (cfi.fileCharacteristics & FID_FILE_CHAR_PARENT) {
			if (!dir_emit_dotdot(file, ctx))
				goto out;
 			continue;
 		}
 
		flen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);
 		if (!flen)
 			continue;
 
		tloc = lelb_to_cpu(cfi.icb.extLocation);
		iblock = udf_get_lb_pblock(dir->i_sb, &tloc, 0);
		if (!dir_emit(ctx, fname, flen, iblock, DT_UNKNOWN))
			goto out;
	} /* end while */

	ctx->pos = (nf_pos >> 2) + 1;

out:
	if (fibh.sbh != fibh.ebh)
		brelse(fibh.ebh);
	brelse(fibh.sbh);
	brelse(epos.bh);
	kfree(fname);

	return ret;
}
",C,"		flen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,
					UDF_NAME_LEN);
","		flen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);
",,"@@ -167,7 +167,8 @@ static int udf_readdir(struct file *file, struct dir_context *ctx)
 			continue;
 		}
 
-		flen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);
+		flen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,
+					UDF_NAME_LEN);
 		if (!flen)
 			continue;
 ",linux,0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,a1d47b262952a45aae62bd49cfaf33dd76c11a2c,1,"static int udf_readdir(struct file *file, struct dir_context *ctx)
{
	struct inode *dir = file_inode(file);
	struct udf_inode_info *iinfo = UDF_I(dir);
	struct udf_fileident_bh fibh = { .sbh = NULL, .ebh = NULL};
	struct fileIdentDesc *fi = NULL;
	struct fileIdentDesc cfi;
	int block, iblock;
	loff_t nf_pos;
	int flen;
	unsigned char *fname = NULL;
	unsigned char *nameptr;
	uint16_t liu;
	uint8_t lfi;
	loff_t size = udf_ext0_offset(dir) + dir->i_size;
	struct buffer_head *tmp, *bha[16];
	struct kernel_lb_addr eloc;
	uint32_t elen;
	sector_t offset;
	int i, num, ret = 0;
	struct extent_position epos = { NULL, 0, {0, 0} };

	if (ctx->pos == 0) {
		if (!dir_emit_dot(file, ctx))
			return 0;
		ctx->pos = 1;
	}
	nf_pos = (ctx->pos - 1) << 2;
	if (nf_pos >= size)
		goto out;

	fname = kmalloc(UDF_NAME_LEN, GFP_NOFS);
	if (!fname) {
		ret = -ENOMEM;
		goto out;
	}

	if (nf_pos == 0)
		nf_pos = udf_ext0_offset(dir);

	fibh.soffset = fibh.eoffset = nf_pos & (dir->i_sb->s_blocksize - 1);
	if (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {
		if (inode_bmap(dir, nf_pos >> dir->i_sb->s_blocksize_bits,
		    &epos, &eloc, &elen, &offset)
		    != (EXT_RECORDED_ALLOCATED >> 30)) {
			ret = -ENOENT;
			goto out;
		}
		block = udf_get_lb_pblock(dir->i_sb, &eloc, offset);
		if ((++offset << dir->i_sb->s_blocksize_bits) < elen) {
			if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)
				epos.offset -= sizeof(struct short_ad);
			else if (iinfo->i_alloc_type ==
					ICBTAG_FLAG_AD_LONG)
				epos.offset -= sizeof(struct long_ad);
		} else {
			offset = 0;
		}

		if (!(fibh.sbh = fibh.ebh = udf_tread(dir->i_sb, block))) {
			ret = -EIO;
			goto out;
		}

		if (!(offset & ((16 >> (dir->i_sb->s_blocksize_bits - 9)) - 1))) {
			i = 16 >> (dir->i_sb->s_blocksize_bits - 9);
			if (i + offset > (elen >> dir->i_sb->s_blocksize_bits))
				i = (elen >> dir->i_sb->s_blocksize_bits) - offset;
			for (num = 0; i > 0; i--) {
				block = udf_get_lb_pblock(dir->i_sb, &eloc, offset + i);
				tmp = udf_tgetblk(dir->i_sb, block);
				if (tmp && !buffer_uptodate(tmp) && !buffer_locked(tmp))
					bha[num++] = tmp;
				else
					brelse(tmp);
			}
			if (num) {
				ll_rw_block(READA, num, bha);
				for (i = 0; i < num; i++)
					brelse(bha[i]);
			}
		}
	}

	while (nf_pos < size) {
		struct kernel_lb_addr tloc;

		ctx->pos = (nf_pos >> 2) + 1;

		fi = udf_fileident_read(dir, &nf_pos, &fibh, &cfi, &epos, &eloc,
					&elen, &offset);
		if (!fi)
			goto out;

		liu = le16_to_cpu(cfi.lengthOfImpUse);
		lfi = cfi.lengthFileIdent;

		if (fibh.sbh == fibh.ebh) {
			nameptr = fi->fileIdent + liu;
		} else {
			int poffset;	/* Unpaded ending offset */

			poffset = fibh.soffset + sizeof(struct fileIdentDesc) + liu + lfi;

			if (poffset >= lfi) {
				nameptr = (char *)(fibh.ebh->b_data + poffset - lfi);
			} else {
				nameptr = fname;
				memcpy(nameptr, fi->fileIdent + liu,
				       lfi - poffset);
				memcpy(nameptr + lfi - poffset,
				       fibh.ebh->b_data, poffset);
			}
		}

		if ((cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {
			if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))
				continue;
		}

		if ((cfi.fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {
			if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))
				continue;
		}

		if (cfi.fileCharacteristics & FID_FILE_CHAR_PARENT) {
			if (!dir_emit_dotdot(file, ctx))
				goto out;
 			continue;
 		}
 
//flaw_line_below:
		flen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);
//fix_flaw_line_below:
//		flen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,
//fix_flaw_line_below:
//					UDF_NAME_LEN);
 		if (!flen)
 			continue;
 
		tloc = lelb_to_cpu(cfi.icb.extLocation);
		iblock = udf_get_lb_pblock(dir->i_sb, &tloc, 0);
		if (!dir_emit(ctx, fname, flen, iblock, DT_UNKNOWN))
			goto out;
	} /* end while */

	ctx->pos = (nf_pos >> 2) + 1;

out:
	if (fibh.sbh != fibh.ebh)
		brelse(fibh.ebh);
	brelse(fibh.sbh);
	brelse(epos.bh);
	kfree(fname);

	return ret;
}
"
2192,179928,,Local,Not required,,CVE-2014-9731,https://www.cvedetails.com/cve/CVE-2014-9731/,CWE-17,Low,Partial,,,2015-08-31,2.1,"The UDF filesystem implementation in the Linux kernel before 3.18.2 does not ensure that space is available for storing a symlink target's name along with a trailing 0 character, which allows local users to obtain sensitive information via a crafted filesystem image, related to fs/udf/symlink.c and fs/udf/unicode.c.",2017-07-12,+Info ,2,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,"udf: Check path length when reading symlink

Symlink reading code does not check whether the resulting path fits into
the page provided by the generic code. This isn't as easy as just
checking the symlink size because of various encoding conversions we
perform on path. So we have to check whether there is still enough space
in the buffer on the fly.

CC: stable@vger.kernel.org
Reported-by: Carl Henrik Lunde <chlunde@ping.uio.no>
Signed-off-by: Jan Kara <jack@suse.cz>",1,fs/udf/namei.c,"{""sha"": ""a7690b46ce0a18624b80f056b1399c9520dffeda"", ""filename"": ""fs/udf/dir.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/dir.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/dir.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/dir.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -167,7 +167,8 @@ static int udf_readdir(struct file *file, struct dir_context *ctx)\n \t\t\tcontinue;\n \t\t}\n \n-\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n+\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n+\t\t\t\t\tUDF_NAME_LEN);\n \t\tif (!flen)\n \t\t\tcontinue;\n ""}<_**next**_>{""sha"": ""6ff19b54b51f285971232e30e9d437fa3966654a"", ""filename"": ""fs/udf/namei.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/namei.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/namei.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/namei.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -233,7 +233,8 @@ static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n \t\tif (!lfi)\n \t\t\tcontinue;\n \n-\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n+\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n+\t\t\t\t\tUDF_NAME_LEN);\n \t\tif (flen && udf_match(flen, fname, child->len, child->name))\n \t\t\tgoto out_ok;\n \t}""}<_**next**_>{""sha"": ""0f1b3a2654b9459a36c4df943f1f22a3bff070af"", ""filename"": ""fs/udf/symlink.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 5, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/symlink.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/symlink.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/symlink.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -30,13 +30,16 @@\n #include <linux/buffer_head.h>\n #include \""udf_i.h\""\n \n-static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n-\t\t\t   int fromlen, unsigned char *to)\n+static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n+\t\t\t  int fromlen, unsigned char *to, int tolen)\n {\n \tstruct pathComponent *pc;\n \tint elen = 0;\n+\tint comp_len;\n \tunsigned char *p = to;\n \n+\t/* Reserve one byte for terminating \\0 */\n+\ttolen--;\n \twhile (elen < fromlen) {\n \t\tpc = (struct pathComponent *)(from + elen);\n \t\tswitch (pc->componentType) {\n@@ -49,22 +52,37 @@ static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n \t\t\t\tbreak;\n \t\t\t/* Fall through */\n \t\tcase 2:\n+\t\t\tif (tolen == 0)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tp = to;\n \t\t\t*p++ = '/';\n+\t\t\ttolen--;\n \t\t\tbreak;\n \t\tcase 3:\n+\t\t\tif (tolen < 3)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tmemcpy(p, \""../\"", 3);\n \t\t\tp += 3;\n+\t\t\ttolen -= 3;\n \t\t\tbreak;\n \t\tcase 4:\n+\t\t\tif (tolen < 2)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tmemcpy(p, \""./\"", 2);\n \t\t\tp += 2;\n+\t\t\ttolen -= 2;\n \t\t\t/* that would be . - just ignore */\n \t\t\tbreak;\n \t\tcase 5:\n-\t\t\tp += udf_get_filename(sb, pc->componentIdent, p,\n-\t\t\t\t\t      pc->lengthComponentIdent);\n+\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n+\t\t\t\t\t\t    pc->lengthComponentIdent,\n+\t\t\t\t\t\t    p, tolen);\n+\t\t\tp += comp_len;\n+\t\t\ttolen -= comp_len;\n+\t\t\tif (tolen == 0)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\t*p++ = '/';\n+\t\t\ttolen--;\n \t\t\tbreak;\n \t\t}\n \t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n@@ -73,6 +91,7 @@ static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n \t\tp[-1] = '\\0';\n \telse\n \t\tp[0] = '\\0';\n+\treturn 0;\n }\n \n static int udf_symlink_filler(struct file *file, struct page *page)\n@@ -108,8 +127,10 @@ static int udf_symlink_filler(struct file *file, struct page *page)\n \t\tsymlink = bh->b_data;\n \t}\n \n-\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n+\terr = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);\n \tbrelse(bh);\n+\tif (err)\n+\t\tgoto out_unlock_inode;\n \n \tup_read(&iinfo->i_data_sem);\n \tSetPageUptodate(page);""}<_**next**_>{""sha"": ""47bb3f5ca360d4f1be8f92036685278868ab99e3"", ""filename"": ""fs/udf/udfdecl.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/udfdecl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/udfdecl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/udfdecl.h?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -211,7 +211,8 @@ udf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n }\n \n /* unicode.c */\n-extern int udf_get_filename(struct super_block *, uint8_t *, uint8_t *, int);\n+extern int udf_get_filename(struct super_block *, uint8_t *, int, uint8_t *,\n+\t\t\t    int);\n extern int udf_put_filename(struct super_block *, const uint8_t *, uint8_t *,\n \t\t\t    int);\n extern int udf_build_ustr(struct ustr *, dstring *, int);""}<_**next**_>{""sha"": ""b84fee372734bd494ba5eb86f5ce5c8c28b99b5a"", ""filename"": ""fs/udf/unicode.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 12, ""changes"": 28, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/unicode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/unicode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/unicode.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -28,7 +28,8 @@\n \n #include \""udf_sb.h\""\n \n-static int udf_translate_to_linux(uint8_t *, uint8_t *, int, uint8_t *, int);\n+static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n+\t\t\t\t  int);\n \n static int udf_char_to_ustr(struct ustr *dest, const uint8_t *src, int strlen)\n {\n@@ -333,8 +334,8 @@ static int udf_NLStoCS0(struct nls_table *nls, dstring *ocu, struct ustr *uni,\n \treturn u_len + 1;\n }\n \n-int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n-\t\t     int flen)\n+int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,\n+\t\t     uint8_t *dname, int dlen)\n {\n \tstruct ustr *filename, *unifilename;\n \tint len = 0;\n@@ -347,7 +348,7 @@ int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n \tif (!unifilename)\n \t\tgoto out1;\n \n-\tif (udf_build_ustr_exact(unifilename, sname, flen))\n+\tif (udf_build_ustr_exact(unifilename, sname, slen))\n \t\tgoto out2;\n \n \tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n@@ -366,7 +367,8 @@ int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n \t} else\n \t\tgoto out2;\n \n-\tlen = udf_translate_to_linux(dname, filename->u_name, filename->u_len,\n+\tlen = udf_translate_to_linux(dname, dlen,\n+\t\t\t\t     filename->u_name, filename->u_len,\n \t\t\t\t     unifilename->u_name, unifilename->u_len);\n out2:\n \tkfree(unifilename);\n@@ -403,10 +405,12 @@ int udf_put_filename(struct super_block *sb, const uint8_t *sname,\n #define EXT_MARK\t\t'.'\n #define CRC_MARK\t\t'#'\n #define EXT_SIZE \t\t5\n+/* Number of chars we need to store generated CRC to make filename unique */\n+#define CRC_LEN\t\t\t5\n \n-static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n-\t\t\t\t  int udfLen, uint8_t *fidName,\n-\t\t\t\t  int fidNameLen)\n+static int udf_translate_to_linux(uint8_t *newName, int newLen,\n+\t\t\t\t  uint8_t *udfName, int udfLen,\n+\t\t\t\t  uint8_t *fidName, int fidNameLen)\n {\n \tint index, newIndex = 0, needsCRC = 0;\n \tint extIndex = 0, newExtIndex = 0, hasExt = 0;\n@@ -439,7 +443,7 @@ static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n \t\t\t\t\tnewExtIndex = newIndex;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif (newIndex < 256)\n+\t\t\tif (newIndex < newLen)\n \t\t\t\tnewName[newIndex++] = curr;\n \t\t\telse\n \t\t\t\tneedsCRC = 1;\n@@ -467,13 +471,13 @@ static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n \t\t\t\t}\n \t\t\t\text[localExtIndex++] = curr;\n \t\t\t}\n-\t\t\tmaxFilenameLen = 250 - localExtIndex;\n+\t\t\tmaxFilenameLen = newLen - CRC_LEN - localExtIndex;\n \t\t\tif (newIndex > maxFilenameLen)\n \t\t\t\tnewIndex = maxFilenameLen;\n \t\t\telse\n \t\t\t\tnewIndex = newExtIndex;\n-\t\t} else if (newIndex > 250)\n-\t\t\tnewIndex = 250;\n+\t\t} else if (newIndex > newLen - CRC_LEN)\n+\t\t\tnewIndex = newLen - CRC_LEN;\n \t\tnewName[newIndex++] = CRC_MARK;\n \t\tvalueCRC = crc_itu_t(0, fidName, fidNameLen);\n \t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);""}","static struct fileIdentDesc *udf_find_entry(struct inode *dir,
					    const struct qstr *child,
					    struct udf_fileident_bh *fibh,
					    struct fileIdentDesc *cfi)
{
	struct fileIdentDesc *fi = NULL;
	loff_t f_pos;
	int block, flen;
	unsigned char *fname = NULL;
	unsigned char *nameptr;
	uint8_t lfi;
	uint16_t liu;
	loff_t size;
	struct kernel_lb_addr eloc;
	uint32_t elen;
	sector_t offset;
	struct extent_position epos = {};
	struct udf_inode_info *dinfo = UDF_I(dir);
	int isdotdot = child->len == 2 &&
		child->name[0] == '.' && child->name[1] == '.';

	size = udf_ext0_offset(dir) + dir->i_size;
	f_pos = udf_ext0_offset(dir);

	fibh->sbh = fibh->ebh = NULL;
	fibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);
	if (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {
		if (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,
		    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))
			goto out_err;
		block = udf_get_lb_pblock(dir->i_sb, &eloc, offset);
		if ((++offset << dir->i_sb->s_blocksize_bits) < elen) {
			if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)
				epos.offset -= sizeof(struct short_ad);
			else if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)
				epos.offset -= sizeof(struct long_ad);
		} else
			offset = 0;

		fibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);
		if (!fibh->sbh)
			goto out_err;
	}

	fname = kmalloc(UDF_NAME_LEN, GFP_NOFS);
	if (!fname)
		goto out_err;

	while (f_pos < size) {
		fi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,
					&elen, &offset);
		if (!fi)
			goto out_err;

		liu = le16_to_cpu(cfi->lengthOfImpUse);
		lfi = cfi->lengthFileIdent;

		if (fibh->sbh == fibh->ebh) {
			nameptr = fi->fileIdent + liu;
		} else {
			int poffset;	/* Unpaded ending offset */

			poffset = fibh->soffset + sizeof(struct fileIdentDesc) +
					liu + lfi;

			if (poffset >= lfi)
				nameptr = (uint8_t *)(fibh->ebh->b_data +
						      poffset - lfi);
			else {
				nameptr = fname;
				memcpy(nameptr, fi->fileIdent + liu,
					lfi - poffset);
				memcpy(nameptr + lfi - poffset,
					fibh->ebh->b_data, poffset);
			}
		}

		if ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {
			if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))
				continue;
		}

		if ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {
			if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))
				continue;
		}

		if ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&
		    isdotdot)
			goto out_ok;

 		if (!lfi)
 			continue;
 
		flen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,
					UDF_NAME_LEN);
 		if (flen && udf_match(flen, fname, child->len, child->name))
 			goto out_ok;
 	}

out_err:
	fi = NULL;
	if (fibh->sbh != fibh->ebh)
		brelse(fibh->ebh);
	brelse(fibh->sbh);
out_ok:
	brelse(epos.bh);
	kfree(fname);

	return fi;
}
","static struct fileIdentDesc *udf_find_entry(struct inode *dir,
					    const struct qstr *child,
					    struct udf_fileident_bh *fibh,
					    struct fileIdentDesc *cfi)
{
	struct fileIdentDesc *fi = NULL;
	loff_t f_pos;
	int block, flen;
	unsigned char *fname = NULL;
	unsigned char *nameptr;
	uint8_t lfi;
	uint16_t liu;
	loff_t size;
	struct kernel_lb_addr eloc;
	uint32_t elen;
	sector_t offset;
	struct extent_position epos = {};
	struct udf_inode_info *dinfo = UDF_I(dir);
	int isdotdot = child->len == 2 &&
		child->name[0] == '.' && child->name[1] == '.';

	size = udf_ext0_offset(dir) + dir->i_size;
	f_pos = udf_ext0_offset(dir);

	fibh->sbh = fibh->ebh = NULL;
	fibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);
	if (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {
		if (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,
		    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))
			goto out_err;
		block = udf_get_lb_pblock(dir->i_sb, &eloc, offset);
		if ((++offset << dir->i_sb->s_blocksize_bits) < elen) {
			if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)
				epos.offset -= sizeof(struct short_ad);
			else if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)
				epos.offset -= sizeof(struct long_ad);
		} else
			offset = 0;

		fibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);
		if (!fibh->sbh)
			goto out_err;
	}

	fname = kmalloc(UDF_NAME_LEN, GFP_NOFS);
	if (!fname)
		goto out_err;

	while (f_pos < size) {
		fi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,
					&elen, &offset);
		if (!fi)
			goto out_err;

		liu = le16_to_cpu(cfi->lengthOfImpUse);
		lfi = cfi->lengthFileIdent;

		if (fibh->sbh == fibh->ebh) {
			nameptr = fi->fileIdent + liu;
		} else {
			int poffset;	/* Unpaded ending offset */

			poffset = fibh->soffset + sizeof(struct fileIdentDesc) +
					liu + lfi;

			if (poffset >= lfi)
				nameptr = (uint8_t *)(fibh->ebh->b_data +
						      poffset - lfi);
			else {
				nameptr = fname;
				memcpy(nameptr, fi->fileIdent + liu,
					lfi - poffset);
				memcpy(nameptr + lfi - poffset,
					fibh->ebh->b_data, poffset);
			}
		}

		if ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {
			if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))
				continue;
		}

		if ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {
			if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))
				continue;
		}

		if ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&
		    isdotdot)
			goto out_ok;

 		if (!lfi)
 			continue;
 
		flen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);
 		if (flen && udf_match(flen, fname, child->len, child->name))
 			goto out_ok;
 	}

out_err:
	fi = NULL;
	if (fibh->sbh != fibh->ebh)
		brelse(fibh->ebh);
	brelse(fibh->sbh);
out_ok:
	brelse(epos.bh);
	kfree(fname);

	return fi;
}
",C,"		flen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,
					UDF_NAME_LEN);
","		flen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);
",,"@@ -233,7 +233,8 @@ static struct fileIdentDesc *udf_find_entry(struct inode *dir,
 		if (!lfi)
 			continue;
 
-		flen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);
+		flen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,
+					UDF_NAME_LEN);
 		if (flen && udf_match(flen, fname, child->len, child->name))
 			goto out_ok;
 	}",linux,0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,a1d47b262952a45aae62bd49cfaf33dd76c11a2c,1,"static struct fileIdentDesc *udf_find_entry(struct inode *dir,
					    const struct qstr *child,
					    struct udf_fileident_bh *fibh,
					    struct fileIdentDesc *cfi)
{
	struct fileIdentDesc *fi = NULL;
	loff_t f_pos;
	int block, flen;
	unsigned char *fname = NULL;
	unsigned char *nameptr;
	uint8_t lfi;
	uint16_t liu;
	loff_t size;
	struct kernel_lb_addr eloc;
	uint32_t elen;
	sector_t offset;
	struct extent_position epos = {};
	struct udf_inode_info *dinfo = UDF_I(dir);
	int isdotdot = child->len == 2 &&
		child->name[0] == '.' && child->name[1] == '.';

	size = udf_ext0_offset(dir) + dir->i_size;
	f_pos = udf_ext0_offset(dir);

	fibh->sbh = fibh->ebh = NULL;
	fibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);
	if (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {
		if (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,
		    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))
			goto out_err;
		block = udf_get_lb_pblock(dir->i_sb, &eloc, offset);
		if ((++offset << dir->i_sb->s_blocksize_bits) < elen) {
			if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)
				epos.offset -= sizeof(struct short_ad);
			else if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)
				epos.offset -= sizeof(struct long_ad);
		} else
			offset = 0;

		fibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);
		if (!fibh->sbh)
			goto out_err;
	}

	fname = kmalloc(UDF_NAME_LEN, GFP_NOFS);
	if (!fname)
		goto out_err;

	while (f_pos < size) {
		fi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,
					&elen, &offset);
		if (!fi)
			goto out_err;

		liu = le16_to_cpu(cfi->lengthOfImpUse);
		lfi = cfi->lengthFileIdent;

		if (fibh->sbh == fibh->ebh) {
			nameptr = fi->fileIdent + liu;
		} else {
			int poffset;	/* Unpaded ending offset */

			poffset = fibh->soffset + sizeof(struct fileIdentDesc) +
					liu + lfi;

			if (poffset >= lfi)
				nameptr = (uint8_t *)(fibh->ebh->b_data +
						      poffset - lfi);
			else {
				nameptr = fname;
				memcpy(nameptr, fi->fileIdent + liu,
					lfi - poffset);
				memcpy(nameptr + lfi - poffset,
					fibh->ebh->b_data, poffset);
			}
		}

		if ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {
			if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))
				continue;
		}

		if ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {
			if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))
				continue;
		}

		if ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&
		    isdotdot)
			goto out_ok;

 		if (!lfi)
 			continue;
 
//flaw_line_below:
		flen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);
//fix_flaw_line_below:
//		flen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,
//fix_flaw_line_below:
//					UDF_NAME_LEN);
 		if (flen && udf_match(flen, fname, child->len, child->name))
 			goto out_ok;
 	}

out_err:
	fi = NULL;
	if (fibh->sbh != fibh->ebh)
		brelse(fibh->ebh);
	brelse(fibh->sbh);
out_ok:
	brelse(epos.bh);
	kfree(fname);

	return fi;
}
"
2193,179929,,Local,Not required,,CVE-2014-9731,https://www.cvedetails.com/cve/CVE-2014-9731/,CWE-17,Low,Partial,,,2015-08-31,2.1,"The UDF filesystem implementation in the Linux kernel before 3.18.2 does not ensure that space is available for storing a symlink target's name along with a trailing 0 character, which allows local users to obtain sensitive information via a crafted filesystem image, related to fs/udf/symlink.c and fs/udf/unicode.c.",2017-07-12,+Info ,23,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,"udf: Check path length when reading symlink

Symlink reading code does not check whether the resulting path fits into
the page provided by the generic code. This isn't as easy as just
checking the symlink size because of various encoding conversions we
perform on path. So we have to check whether there is still enough space
in the buffer on the fly.

CC: stable@vger.kernel.org
Reported-by: Carl Henrik Lunde <chlunde@ping.uio.no>
Signed-off-by: Jan Kara <jack@suse.cz>",3,fs/udf/symlink.c,"{""sha"": ""a7690b46ce0a18624b80f056b1399c9520dffeda"", ""filename"": ""fs/udf/dir.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/dir.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/dir.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/dir.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -167,7 +167,8 @@ static int udf_readdir(struct file *file, struct dir_context *ctx)\n \t\t\tcontinue;\n \t\t}\n \n-\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n+\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n+\t\t\t\t\tUDF_NAME_LEN);\n \t\tif (!flen)\n \t\t\tcontinue;\n ""}<_**next**_>{""sha"": ""6ff19b54b51f285971232e30e9d437fa3966654a"", ""filename"": ""fs/udf/namei.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/namei.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/namei.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/namei.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -233,7 +233,8 @@ static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n \t\tif (!lfi)\n \t\t\tcontinue;\n \n-\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n+\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n+\t\t\t\t\tUDF_NAME_LEN);\n \t\tif (flen && udf_match(flen, fname, child->len, child->name))\n \t\t\tgoto out_ok;\n \t}""}<_**next**_>{""sha"": ""0f1b3a2654b9459a36c4df943f1f22a3bff070af"", ""filename"": ""fs/udf/symlink.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 5, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/symlink.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/symlink.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/symlink.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -30,13 +30,16 @@\n #include <linux/buffer_head.h>\n #include \""udf_i.h\""\n \n-static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n-\t\t\t   int fromlen, unsigned char *to)\n+static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n+\t\t\t  int fromlen, unsigned char *to, int tolen)\n {\n \tstruct pathComponent *pc;\n \tint elen = 0;\n+\tint comp_len;\n \tunsigned char *p = to;\n \n+\t/* Reserve one byte for terminating \\0 */\n+\ttolen--;\n \twhile (elen < fromlen) {\n \t\tpc = (struct pathComponent *)(from + elen);\n \t\tswitch (pc->componentType) {\n@@ -49,22 +52,37 @@ static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n \t\t\t\tbreak;\n \t\t\t/* Fall through */\n \t\tcase 2:\n+\t\t\tif (tolen == 0)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tp = to;\n \t\t\t*p++ = '/';\n+\t\t\ttolen--;\n \t\t\tbreak;\n \t\tcase 3:\n+\t\t\tif (tolen < 3)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tmemcpy(p, \""../\"", 3);\n \t\t\tp += 3;\n+\t\t\ttolen -= 3;\n \t\t\tbreak;\n \t\tcase 4:\n+\t\t\tif (tolen < 2)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tmemcpy(p, \""./\"", 2);\n \t\t\tp += 2;\n+\t\t\ttolen -= 2;\n \t\t\t/* that would be . - just ignore */\n \t\t\tbreak;\n \t\tcase 5:\n-\t\t\tp += udf_get_filename(sb, pc->componentIdent, p,\n-\t\t\t\t\t      pc->lengthComponentIdent);\n+\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n+\t\t\t\t\t\t    pc->lengthComponentIdent,\n+\t\t\t\t\t\t    p, tolen);\n+\t\t\tp += comp_len;\n+\t\t\ttolen -= comp_len;\n+\t\t\tif (tolen == 0)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\t*p++ = '/';\n+\t\t\ttolen--;\n \t\t\tbreak;\n \t\t}\n \t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n@@ -73,6 +91,7 @@ static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n \t\tp[-1] = '\\0';\n \telse\n \t\tp[0] = '\\0';\n+\treturn 0;\n }\n \n static int udf_symlink_filler(struct file *file, struct page *page)\n@@ -108,8 +127,10 @@ static int udf_symlink_filler(struct file *file, struct page *page)\n \t\tsymlink = bh->b_data;\n \t}\n \n-\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n+\terr = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);\n \tbrelse(bh);\n+\tif (err)\n+\t\tgoto out_unlock_inode;\n \n \tup_read(&iinfo->i_data_sem);\n \tSetPageUptodate(page);""}<_**next**_>{""sha"": ""47bb3f5ca360d4f1be8f92036685278868ab99e3"", ""filename"": ""fs/udf/udfdecl.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/udfdecl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/udfdecl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/udfdecl.h?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -211,7 +211,8 @@ udf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n }\n \n /* unicode.c */\n-extern int udf_get_filename(struct super_block *, uint8_t *, uint8_t *, int);\n+extern int udf_get_filename(struct super_block *, uint8_t *, int, uint8_t *,\n+\t\t\t    int);\n extern int udf_put_filename(struct super_block *, const uint8_t *, uint8_t *,\n \t\t\t    int);\n extern int udf_build_ustr(struct ustr *, dstring *, int);""}<_**next**_>{""sha"": ""b84fee372734bd494ba5eb86f5ce5c8c28b99b5a"", ""filename"": ""fs/udf/unicode.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 12, ""changes"": 28, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/unicode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/unicode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/unicode.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -28,7 +28,8 @@\n \n #include \""udf_sb.h\""\n \n-static int udf_translate_to_linux(uint8_t *, uint8_t *, int, uint8_t *, int);\n+static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n+\t\t\t\t  int);\n \n static int udf_char_to_ustr(struct ustr *dest, const uint8_t *src, int strlen)\n {\n@@ -333,8 +334,8 @@ static int udf_NLStoCS0(struct nls_table *nls, dstring *ocu, struct ustr *uni,\n \treturn u_len + 1;\n }\n \n-int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n-\t\t     int flen)\n+int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,\n+\t\t     uint8_t *dname, int dlen)\n {\n \tstruct ustr *filename, *unifilename;\n \tint len = 0;\n@@ -347,7 +348,7 @@ int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n \tif (!unifilename)\n \t\tgoto out1;\n \n-\tif (udf_build_ustr_exact(unifilename, sname, flen))\n+\tif (udf_build_ustr_exact(unifilename, sname, slen))\n \t\tgoto out2;\n \n \tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n@@ -366,7 +367,8 @@ int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n \t} else\n \t\tgoto out2;\n \n-\tlen = udf_translate_to_linux(dname, filename->u_name, filename->u_len,\n+\tlen = udf_translate_to_linux(dname, dlen,\n+\t\t\t\t     filename->u_name, filename->u_len,\n \t\t\t\t     unifilename->u_name, unifilename->u_len);\n out2:\n \tkfree(unifilename);\n@@ -403,10 +405,12 @@ int udf_put_filename(struct super_block *sb, const uint8_t *sname,\n #define EXT_MARK\t\t'.'\n #define CRC_MARK\t\t'#'\n #define EXT_SIZE \t\t5\n+/* Number of chars we need to store generated CRC to make filename unique */\n+#define CRC_LEN\t\t\t5\n \n-static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n-\t\t\t\t  int udfLen, uint8_t *fidName,\n-\t\t\t\t  int fidNameLen)\n+static int udf_translate_to_linux(uint8_t *newName, int newLen,\n+\t\t\t\t  uint8_t *udfName, int udfLen,\n+\t\t\t\t  uint8_t *fidName, int fidNameLen)\n {\n \tint index, newIndex = 0, needsCRC = 0;\n \tint extIndex = 0, newExtIndex = 0, hasExt = 0;\n@@ -439,7 +443,7 @@ static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n \t\t\t\t\tnewExtIndex = newIndex;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif (newIndex < 256)\n+\t\t\tif (newIndex < newLen)\n \t\t\t\tnewName[newIndex++] = curr;\n \t\t\telse\n \t\t\t\tneedsCRC = 1;\n@@ -467,13 +471,13 @@ static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n \t\t\t\t}\n \t\t\t\text[localExtIndex++] = curr;\n \t\t\t}\n-\t\t\tmaxFilenameLen = 250 - localExtIndex;\n+\t\t\tmaxFilenameLen = newLen - CRC_LEN - localExtIndex;\n \t\t\tif (newIndex > maxFilenameLen)\n \t\t\t\tnewIndex = maxFilenameLen;\n \t\t\telse\n \t\t\t\tnewIndex = newExtIndex;\n-\t\t} else if (newIndex > 250)\n-\t\t\tnewIndex = 250;\n+\t\t} else if (newIndex > newLen - CRC_LEN)\n+\t\t\tnewIndex = newLen - CRC_LEN;\n \t\tnewName[newIndex++] = CRC_MARK;\n \t\tvalueCRC = crc_itu_t(0, fidName, fidNameLen);\n \t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);""}","static void udf_pc_to_char(struct super_block *sb, unsigned char *from,
static int udf_pc_to_char(struct super_block *sb, unsigned char *from,
			  int fromlen, unsigned char *to, int tolen)
 {
 	struct pathComponent *pc;
 	int elen = 0;
	int comp_len;
 	unsigned char *p = to;
 
	/* Reserve one byte for terminating \0 */
	tolen--;
 	while (elen < fromlen) {
 		pc = (struct pathComponent *)(from + elen);
 		switch (pc->componentType) {
		case 1:
			/*
			 * Symlink points to some place which should be agreed
 			 * upon between originator and receiver of the media. Ignore.
			 */
			if (pc->lengthComponentIdent > 0)
 				break;
 			/* Fall through */
 		case 2:
			if (tolen == 0)
				return -ENAMETOOLONG;
 			p = to;
 			*p++ = '/';
			tolen--;
 			break;
 		case 3:
			if (tolen < 3)
				return -ENAMETOOLONG;
 			memcpy(p, ""../"", 3);
 			p += 3;
			tolen -= 3;
 			break;
 		case 4:
			if (tolen < 2)
				return -ENAMETOOLONG;
 			memcpy(p, ""./"", 2);
 			p += 2;
			tolen -= 2;
 			/* that would be . - just ignore */
 			break;
 		case 5:
			comp_len = udf_get_filename(sb, pc->componentIdent,
						    pc->lengthComponentIdent,
						    p, tolen);
			p += comp_len;
			tolen -= comp_len;
			if (tolen == 0)
				return -ENAMETOOLONG;
 			*p++ = '/';
			tolen--;
 			break;
 		}
 		elen += sizeof(struct pathComponent) + pc->lengthComponentIdent;
	}
	if (p > to + 1)
 		p[-1] = '\0';
 	else
 		p[0] = '\0';
	return 0;
 }
","static void udf_pc_to_char(struct super_block *sb, unsigned char *from,
			   int fromlen, unsigned char *to)
 {
 	struct pathComponent *pc;
 	int elen = 0;
 	unsigned char *p = to;
 
 	while (elen < fromlen) {
 		pc = (struct pathComponent *)(from + elen);
 		switch (pc->componentType) {
		case 1:
			/*
			 * Symlink points to some place which should be agreed
 			 * upon between originator and receiver of the media. Ignore.
			 */
			if (pc->lengthComponentIdent > 0)
 				break;
 			/* Fall through */
 		case 2:
 			p = to;
 			*p++ = '/';
 			break;
 		case 3:
 			memcpy(p, ""../"", 3);
 			p += 3;
 			break;
 		case 4:
 			memcpy(p, ""./"", 2);
 			p += 2;
 			/* that would be . - just ignore */
 			break;
 		case 5:
			p += udf_get_filename(sb, pc->componentIdent, p,
					      pc->lengthComponentIdent);
 			*p++ = '/';
 			break;
 		}
 		elen += sizeof(struct pathComponent) + pc->lengthComponentIdent;
	}
	if (p > to + 1)
 		p[-1] = '\0';
 	else
 		p[0] = '\0';
 }
",C,"static int udf_pc_to_char(struct super_block *sb, unsigned char *from,
			  int fromlen, unsigned char *to, int tolen)
	int comp_len;
	/* Reserve one byte for terminating \0 */
	tolen--;
			if (tolen == 0)
				return -ENAMETOOLONG;
			tolen--;
			if (tolen < 3)
				return -ENAMETOOLONG;
			tolen -= 3;
			if (tolen < 2)
				return -ENAMETOOLONG;
			tolen -= 2;
			comp_len = udf_get_filename(sb, pc->componentIdent,
						    pc->lengthComponentIdent,
						    p, tolen);
			p += comp_len;
			tolen -= comp_len;
			if (tolen == 0)
				return -ENAMETOOLONG;
			tolen--;
	return 0;
","			   int fromlen, unsigned char *to)
			p += udf_get_filename(sb, pc->componentIdent, p,
					      pc->lengthComponentIdent);
",,"@@ -30,13 +30,16 @@
 #include <linux/buffer_head.h>
 #include ""udf_i.h""
 
-static void udf_pc_to_char(struct super_block *sb, unsigned char *from,
-			   int fromlen, unsigned char *to)
+static int udf_pc_to_char(struct super_block *sb, unsigned char *from,
+			  int fromlen, unsigned char *to, int tolen)
 {
 	struct pathComponent *pc;
 	int elen = 0;
+	int comp_len;
 	unsigned char *p = to;
 
+	/* Reserve one byte for terminating \0 */
+	tolen--;
 	while (elen < fromlen) {
 		pc = (struct pathComponent *)(from + elen);
 		switch (pc->componentType) {
@@ -49,22 +52,37 @@ static void udf_pc_to_char(struct super_block *sb, unsigned char *from,
 				break;
 			/* Fall through */
 		case 2:
+			if (tolen == 0)
+				return -ENAMETOOLONG;
 			p = to;
 			*p++ = '/';
+			tolen--;
 			break;
 		case 3:
+			if (tolen < 3)
+				return -ENAMETOOLONG;
 			memcpy(p, ""../"", 3);
 			p += 3;
+			tolen -= 3;
 			break;
 		case 4:
+			if (tolen < 2)
+				return -ENAMETOOLONG;
 			memcpy(p, ""./"", 2);
 			p += 2;
+			tolen -= 2;
 			/* that would be . - just ignore */
 			break;
 		case 5:
-			p += udf_get_filename(sb, pc->componentIdent, p,
-					      pc->lengthComponentIdent);
+			comp_len = udf_get_filename(sb, pc->componentIdent,
+						    pc->lengthComponentIdent,
+						    p, tolen);
+			p += comp_len;
+			tolen -= comp_len;
+			if (tolen == 0)
+				return -ENAMETOOLONG;
 			*p++ = '/';
+			tolen--;
 			break;
 		}
 		elen += sizeof(struct pathComponent) + pc->lengthComponentIdent;
@@ -73,6 +91,7 @@ static void udf_pc_to_char(struct super_block *sb, unsigned char *from,
 		p[-1] = '\0';
 	else
 		p[0] = '\0';
+	return 0;
 }
 
 static int udf_symlink_filler(struct file *file, struct page *page)
@@ -108,8 +127,10 @@ static int udf_symlink_filler(struct file *file, struct page *page)
 		symlink = bh->b_data;
 	}
 
-	udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);
+	err = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);
 	brelse(bh);
+	if (err)
+		goto out_unlock_inode;
 
 	up_read(&iinfo->i_data_sem);
 	SetPageUptodate(page);",linux,0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,a1d47b262952a45aae62bd49cfaf33dd76c11a2c,1,"static void udf_pc_to_char(struct super_block *sb, unsigned char *from,
//flaw_line_below:
			   int fromlen, unsigned char *to)
//fix_flaw_line_below:
//static int udf_pc_to_char(struct super_block *sb, unsigned char *from,
//fix_flaw_line_below:
//			  int fromlen, unsigned char *to, int tolen)
 {
 	struct pathComponent *pc;
 	int elen = 0;
//fix_flaw_line_below:
//	int comp_len;
 	unsigned char *p = to;
 
//fix_flaw_line_below:
//	/* Reserve one byte for terminating \0 */
//fix_flaw_line_below:
//	tolen--;
 	while (elen < fromlen) {
 		pc = (struct pathComponent *)(from + elen);
 		switch (pc->componentType) {
		case 1:
			/*
			 * Symlink points to some place which should be agreed
 			 * upon between originator and receiver of the media. Ignore.
			 */
			if (pc->lengthComponentIdent > 0)
 				break;
 			/* Fall through */
 		case 2:
//fix_flaw_line_below:
//			if (tolen == 0)
//fix_flaw_line_below:
//				return -ENAMETOOLONG;
 			p = to;
 			*p++ = '/';
//fix_flaw_line_below:
//			tolen--;
 			break;
 		case 3:
//fix_flaw_line_below:
//			if (tolen < 3)
//fix_flaw_line_below:
//				return -ENAMETOOLONG;
 			memcpy(p, ""../"", 3);
 			p += 3;
//fix_flaw_line_below:
//			tolen -= 3;
 			break;
 		case 4:
//fix_flaw_line_below:
//			if (tolen < 2)
//fix_flaw_line_below:
//				return -ENAMETOOLONG;
 			memcpy(p, ""./"", 2);
 			p += 2;
//fix_flaw_line_below:
//			tolen -= 2;
 			/* that would be . - just ignore */
 			break;
 		case 5:
//flaw_line_below:
			p += udf_get_filename(sb, pc->componentIdent, p,
//flaw_line_below:
					      pc->lengthComponentIdent);
//fix_flaw_line_below:
//			comp_len = udf_get_filename(sb, pc->componentIdent,
//fix_flaw_line_below:
//						    pc->lengthComponentIdent,
//fix_flaw_line_below:
//						    p, tolen);
//fix_flaw_line_below:
//			p += comp_len;
//fix_flaw_line_below:
//			tolen -= comp_len;
//fix_flaw_line_below:
//			if (tolen == 0)
//fix_flaw_line_below:
//				return -ENAMETOOLONG;
 			*p++ = '/';
//fix_flaw_line_below:
//			tolen--;
 			break;
 		}
 		elen += sizeof(struct pathComponent) + pc->lengthComponentIdent;
	}
	if (p > to + 1)
 		p[-1] = '\0';
 	else
 		p[0] = '\0';
//fix_flaw_line_below:
//	return 0;
 }
"
2194,179930,,Local,Not required,,CVE-2014-9731,https://www.cvedetails.com/cve/CVE-2014-9731/,CWE-17,Low,Partial,,,2015-08-31,2.1,"The UDF filesystem implementation in the Linux kernel before 3.18.2 does not ensure that space is available for storing a symlink target's name along with a trailing 0 character, which allows local users to obtain sensitive information via a crafted filesystem image, related to fs/udf/symlink.c and fs/udf/unicode.c.",2017-07-12,+Info ,3,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,"udf: Check path length when reading symlink

Symlink reading code does not check whether the resulting path fits into
the page provided by the generic code. This isn't as easy as just
checking the symlink size because of various encoding conversions we
perform on path. So we have to check whether there is still enough space
in the buffer on the fly.

CC: stable@vger.kernel.org
Reported-by: Carl Henrik Lunde <chlunde@ping.uio.no>
Signed-off-by: Jan Kara <jack@suse.cz>",1,fs/udf/symlink.c,"{""sha"": ""a7690b46ce0a18624b80f056b1399c9520dffeda"", ""filename"": ""fs/udf/dir.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/dir.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/dir.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/dir.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -167,7 +167,8 @@ static int udf_readdir(struct file *file, struct dir_context *ctx)\n \t\t\tcontinue;\n \t\t}\n \n-\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n+\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n+\t\t\t\t\tUDF_NAME_LEN);\n \t\tif (!flen)\n \t\t\tcontinue;\n ""}<_**next**_>{""sha"": ""6ff19b54b51f285971232e30e9d437fa3966654a"", ""filename"": ""fs/udf/namei.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/namei.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/namei.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/namei.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -233,7 +233,8 @@ static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n \t\tif (!lfi)\n \t\t\tcontinue;\n \n-\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n+\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n+\t\t\t\t\tUDF_NAME_LEN);\n \t\tif (flen && udf_match(flen, fname, child->len, child->name))\n \t\t\tgoto out_ok;\n \t}""}<_**next**_>{""sha"": ""0f1b3a2654b9459a36c4df943f1f22a3bff070af"", ""filename"": ""fs/udf/symlink.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 5, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/symlink.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/symlink.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/symlink.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -30,13 +30,16 @@\n #include <linux/buffer_head.h>\n #include \""udf_i.h\""\n \n-static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n-\t\t\t   int fromlen, unsigned char *to)\n+static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n+\t\t\t  int fromlen, unsigned char *to, int tolen)\n {\n \tstruct pathComponent *pc;\n \tint elen = 0;\n+\tint comp_len;\n \tunsigned char *p = to;\n \n+\t/* Reserve one byte for terminating \\0 */\n+\ttolen--;\n \twhile (elen < fromlen) {\n \t\tpc = (struct pathComponent *)(from + elen);\n \t\tswitch (pc->componentType) {\n@@ -49,22 +52,37 @@ static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n \t\t\t\tbreak;\n \t\t\t/* Fall through */\n \t\tcase 2:\n+\t\t\tif (tolen == 0)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tp = to;\n \t\t\t*p++ = '/';\n+\t\t\ttolen--;\n \t\t\tbreak;\n \t\tcase 3:\n+\t\t\tif (tolen < 3)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tmemcpy(p, \""../\"", 3);\n \t\t\tp += 3;\n+\t\t\ttolen -= 3;\n \t\t\tbreak;\n \t\tcase 4:\n+\t\t\tif (tolen < 2)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tmemcpy(p, \""./\"", 2);\n \t\t\tp += 2;\n+\t\t\ttolen -= 2;\n \t\t\t/* that would be . - just ignore */\n \t\t\tbreak;\n \t\tcase 5:\n-\t\t\tp += udf_get_filename(sb, pc->componentIdent, p,\n-\t\t\t\t\t      pc->lengthComponentIdent);\n+\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n+\t\t\t\t\t\t    pc->lengthComponentIdent,\n+\t\t\t\t\t\t    p, tolen);\n+\t\t\tp += comp_len;\n+\t\t\ttolen -= comp_len;\n+\t\t\tif (tolen == 0)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\t*p++ = '/';\n+\t\t\ttolen--;\n \t\t\tbreak;\n \t\t}\n \t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n@@ -73,6 +91,7 @@ static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n \t\tp[-1] = '\\0';\n \telse\n \t\tp[0] = '\\0';\n+\treturn 0;\n }\n \n static int udf_symlink_filler(struct file *file, struct page *page)\n@@ -108,8 +127,10 @@ static int udf_symlink_filler(struct file *file, struct page *page)\n \t\tsymlink = bh->b_data;\n \t}\n \n-\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n+\terr = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);\n \tbrelse(bh);\n+\tif (err)\n+\t\tgoto out_unlock_inode;\n \n \tup_read(&iinfo->i_data_sem);\n \tSetPageUptodate(page);""}<_**next**_>{""sha"": ""47bb3f5ca360d4f1be8f92036685278868ab99e3"", ""filename"": ""fs/udf/udfdecl.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/udfdecl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/udfdecl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/udfdecl.h?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -211,7 +211,8 @@ udf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n }\n \n /* unicode.c */\n-extern int udf_get_filename(struct super_block *, uint8_t *, uint8_t *, int);\n+extern int udf_get_filename(struct super_block *, uint8_t *, int, uint8_t *,\n+\t\t\t    int);\n extern int udf_put_filename(struct super_block *, const uint8_t *, uint8_t *,\n \t\t\t    int);\n extern int udf_build_ustr(struct ustr *, dstring *, int);""}<_**next**_>{""sha"": ""b84fee372734bd494ba5eb86f5ce5c8c28b99b5a"", ""filename"": ""fs/udf/unicode.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 12, ""changes"": 28, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/unicode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/unicode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/unicode.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -28,7 +28,8 @@\n \n #include \""udf_sb.h\""\n \n-static int udf_translate_to_linux(uint8_t *, uint8_t *, int, uint8_t *, int);\n+static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n+\t\t\t\t  int);\n \n static int udf_char_to_ustr(struct ustr *dest, const uint8_t *src, int strlen)\n {\n@@ -333,8 +334,8 @@ static int udf_NLStoCS0(struct nls_table *nls, dstring *ocu, struct ustr *uni,\n \treturn u_len + 1;\n }\n \n-int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n-\t\t     int flen)\n+int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,\n+\t\t     uint8_t *dname, int dlen)\n {\n \tstruct ustr *filename, *unifilename;\n \tint len = 0;\n@@ -347,7 +348,7 @@ int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n \tif (!unifilename)\n \t\tgoto out1;\n \n-\tif (udf_build_ustr_exact(unifilename, sname, flen))\n+\tif (udf_build_ustr_exact(unifilename, sname, slen))\n \t\tgoto out2;\n \n \tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n@@ -366,7 +367,8 @@ int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n \t} else\n \t\tgoto out2;\n \n-\tlen = udf_translate_to_linux(dname, filename->u_name, filename->u_len,\n+\tlen = udf_translate_to_linux(dname, dlen,\n+\t\t\t\t     filename->u_name, filename->u_len,\n \t\t\t\t     unifilename->u_name, unifilename->u_len);\n out2:\n \tkfree(unifilename);\n@@ -403,10 +405,12 @@ int udf_put_filename(struct super_block *sb, const uint8_t *sname,\n #define EXT_MARK\t\t'.'\n #define CRC_MARK\t\t'#'\n #define EXT_SIZE \t\t5\n+/* Number of chars we need to store generated CRC to make filename unique */\n+#define CRC_LEN\t\t\t5\n \n-static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n-\t\t\t\t  int udfLen, uint8_t *fidName,\n-\t\t\t\t  int fidNameLen)\n+static int udf_translate_to_linux(uint8_t *newName, int newLen,\n+\t\t\t\t  uint8_t *udfName, int udfLen,\n+\t\t\t\t  uint8_t *fidName, int fidNameLen)\n {\n \tint index, newIndex = 0, needsCRC = 0;\n \tint extIndex = 0, newExtIndex = 0, hasExt = 0;\n@@ -439,7 +443,7 @@ static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n \t\t\t\t\tnewExtIndex = newIndex;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif (newIndex < 256)\n+\t\t\tif (newIndex < newLen)\n \t\t\t\tnewName[newIndex++] = curr;\n \t\t\telse\n \t\t\t\tneedsCRC = 1;\n@@ -467,13 +471,13 @@ static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n \t\t\t\t}\n \t\t\t\text[localExtIndex++] = curr;\n \t\t\t}\n-\t\t\tmaxFilenameLen = 250 - localExtIndex;\n+\t\t\tmaxFilenameLen = newLen - CRC_LEN - localExtIndex;\n \t\t\tif (newIndex > maxFilenameLen)\n \t\t\t\tnewIndex = maxFilenameLen;\n \t\t\telse\n \t\t\t\tnewIndex = newExtIndex;\n-\t\t} else if (newIndex > 250)\n-\t\t\tnewIndex = 250;\n+\t\t} else if (newIndex > newLen - CRC_LEN)\n+\t\t\tnewIndex = newLen - CRC_LEN;\n \t\tnewName[newIndex++] = CRC_MARK;\n \t\tvalueCRC = crc_itu_t(0, fidName, fidNameLen);\n \t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);""}"," static int udf_symlink_filler(struct file *file, struct page *page)
{
	struct inode *inode = page->mapping->host;
	struct buffer_head *bh = NULL;
	unsigned char *symlink;
	int err;
	unsigned char *p = kmap(page);
	struct udf_inode_info *iinfo;
	uint32_t pos;

	/* We don't support symlinks longer than one block */
	if (inode->i_size > inode->i_sb->s_blocksize) {
		err = -ENAMETOOLONG;
		goto out_unmap;
	}

	iinfo = UDF_I(inode);
	pos = udf_block_map(inode, 0);

	down_read(&iinfo->i_data_sem);
	if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {
		symlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;
	} else {
		bh = sb_bread(inode->i_sb, pos);

		if (!bh) {
			err = -EIO;
			goto out_unlock_inode;
		}

 		symlink = bh->b_data;
 	}
 
	err = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);
 	brelse(bh);
	if (err)
		goto out_unlock_inode;
 
 	up_read(&iinfo->i_data_sem);
 	SetPageUptodate(page);
	kunmap(page);
	unlock_page(page);
	return 0;

out_unlock_inode:
	up_read(&iinfo->i_data_sem);
	SetPageError(page);
out_unmap:
	kunmap(page);
	unlock_page(page);
	return err;
}
"," static int udf_symlink_filler(struct file *file, struct page *page)
{
	struct inode *inode = page->mapping->host;
	struct buffer_head *bh = NULL;
	unsigned char *symlink;
	int err;
	unsigned char *p = kmap(page);
	struct udf_inode_info *iinfo;
	uint32_t pos;

	/* We don't support symlinks longer than one block */
	if (inode->i_size > inode->i_sb->s_blocksize) {
		err = -ENAMETOOLONG;
		goto out_unmap;
	}

	iinfo = UDF_I(inode);
	pos = udf_block_map(inode, 0);

	down_read(&iinfo->i_data_sem);
	if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {
		symlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;
	} else {
		bh = sb_bread(inode->i_sb, pos);

		if (!bh) {
			err = -EIO;
			goto out_unlock_inode;
		}

 		symlink = bh->b_data;
 	}
 
	udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);
 	brelse(bh);
 
 	up_read(&iinfo->i_data_sem);
 	SetPageUptodate(page);
	kunmap(page);
	unlock_page(page);
	return 0;

out_unlock_inode:
	up_read(&iinfo->i_data_sem);
	SetPageError(page);
out_unmap:
	kunmap(page);
	unlock_page(page);
	return err;
}
",C,"	err = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);
	if (err)
		goto out_unlock_inode;
","	udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);
",,"@@ -30,13 +30,16 @@
 #include <linux/buffer_head.h>
 #include ""udf_i.h""
 
-static void udf_pc_to_char(struct super_block *sb, unsigned char *from,
-			   int fromlen, unsigned char *to)
+static int udf_pc_to_char(struct super_block *sb, unsigned char *from,
+			  int fromlen, unsigned char *to, int tolen)
 {
 	struct pathComponent *pc;
 	int elen = 0;
+	int comp_len;
 	unsigned char *p = to;
 
+	/* Reserve one byte for terminating \0 */
+	tolen--;
 	while (elen < fromlen) {
 		pc = (struct pathComponent *)(from + elen);
 		switch (pc->componentType) {
@@ -49,22 +52,37 @@ static void udf_pc_to_char(struct super_block *sb, unsigned char *from,
 				break;
 			/* Fall through */
 		case 2:
+			if (tolen == 0)
+				return -ENAMETOOLONG;
 			p = to;
 			*p++ = '/';
+			tolen--;
 			break;
 		case 3:
+			if (tolen < 3)
+				return -ENAMETOOLONG;
 			memcpy(p, ""../"", 3);
 			p += 3;
+			tolen -= 3;
 			break;
 		case 4:
+			if (tolen < 2)
+				return -ENAMETOOLONG;
 			memcpy(p, ""./"", 2);
 			p += 2;
+			tolen -= 2;
 			/* that would be . - just ignore */
 			break;
 		case 5:
-			p += udf_get_filename(sb, pc->componentIdent, p,
-					      pc->lengthComponentIdent);
+			comp_len = udf_get_filename(sb, pc->componentIdent,
+						    pc->lengthComponentIdent,
+						    p, tolen);
+			p += comp_len;
+			tolen -= comp_len;
+			if (tolen == 0)
+				return -ENAMETOOLONG;
 			*p++ = '/';
+			tolen--;
 			break;
 		}
 		elen += sizeof(struct pathComponent) + pc->lengthComponentIdent;
@@ -73,6 +91,7 @@ static void udf_pc_to_char(struct super_block *sb, unsigned char *from,
 		p[-1] = '\0';
 	else
 		p[0] = '\0';
+	return 0;
 }
 
 static int udf_symlink_filler(struct file *file, struct page *page)
@@ -108,8 +127,10 @@ static int udf_symlink_filler(struct file *file, struct page *page)
 		symlink = bh->b_data;
 	}
 
-	udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);
+	err = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);
 	brelse(bh);
+	if (err)
+		goto out_unlock_inode;
 
 	up_read(&iinfo->i_data_sem);
 	SetPageUptodate(page);",linux,0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,a1d47b262952a45aae62bd49cfaf33dd76c11a2c,1," static int udf_symlink_filler(struct file *file, struct page *page)
{
	struct inode *inode = page->mapping->host;
	struct buffer_head *bh = NULL;
	unsigned char *symlink;
	int err;
	unsigned char *p = kmap(page);
	struct udf_inode_info *iinfo;
	uint32_t pos;

	/* We don't support symlinks longer than one block */
	if (inode->i_size > inode->i_sb->s_blocksize) {
		err = -ENAMETOOLONG;
		goto out_unmap;
	}

	iinfo = UDF_I(inode);
	pos = udf_block_map(inode, 0);

	down_read(&iinfo->i_data_sem);
	if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {
		symlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;
	} else {
		bh = sb_bread(inode->i_sb, pos);

		if (!bh) {
			err = -EIO;
			goto out_unlock_inode;
		}

 		symlink = bh->b_data;
 	}
 
//flaw_line_below:
	udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);
//fix_flaw_line_below:
//	err = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);
 	brelse(bh);
//fix_flaw_line_below:
//	if (err)
//fix_flaw_line_below:
//		goto out_unlock_inode;
 
 	up_read(&iinfo->i_data_sem);
 	SetPageUptodate(page);
	kunmap(page);
	unlock_page(page);
	return 0;

out_unlock_inode:
	up_read(&iinfo->i_data_sem);
	SetPageError(page);
out_unmap:
	kunmap(page);
	unlock_page(page);
	return err;
}
"
2195,179931,,Local,Not required,,CVE-2014-9731,https://www.cvedetails.com/cve/CVE-2014-9731/,CWE-17,Low,Partial,,,2015-08-31,2.1,"The UDF filesystem implementation in the Linux kernel before 3.18.2 does not ensure that space is available for storing a symlink target's name along with a trailing 0 character, which allows local users to obtain sensitive information via a crafted filesystem image, related to fs/udf/symlink.c and fs/udf/unicode.c.",2017-07-12,+Info ,5,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,"udf: Check path length when reading symlink

Symlink reading code does not check whether the resulting path fits into
the page provided by the generic code. This isn't as easy as just
checking the symlink size because of various encoding conversions we
perform on path. So we have to check whether there is still enough space
in the buffer on the fly.

CC: stable@vger.kernel.org
Reported-by: Carl Henrik Lunde <chlunde@ping.uio.no>
Signed-off-by: Jan Kara <jack@suse.cz>",3,fs/udf/unicode.c,"{""sha"": ""a7690b46ce0a18624b80f056b1399c9520dffeda"", ""filename"": ""fs/udf/dir.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/dir.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/dir.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/dir.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -167,7 +167,8 @@ static int udf_readdir(struct file *file, struct dir_context *ctx)\n \t\t\tcontinue;\n \t\t}\n \n-\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n+\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n+\t\t\t\t\tUDF_NAME_LEN);\n \t\tif (!flen)\n \t\t\tcontinue;\n ""}<_**next**_>{""sha"": ""6ff19b54b51f285971232e30e9d437fa3966654a"", ""filename"": ""fs/udf/namei.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/namei.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/namei.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/namei.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -233,7 +233,8 @@ static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n \t\tif (!lfi)\n \t\t\tcontinue;\n \n-\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n+\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n+\t\t\t\t\tUDF_NAME_LEN);\n \t\tif (flen && udf_match(flen, fname, child->len, child->name))\n \t\t\tgoto out_ok;\n \t}""}<_**next**_>{""sha"": ""0f1b3a2654b9459a36c4df943f1f22a3bff070af"", ""filename"": ""fs/udf/symlink.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 5, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/symlink.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/symlink.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/symlink.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -30,13 +30,16 @@\n #include <linux/buffer_head.h>\n #include \""udf_i.h\""\n \n-static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n-\t\t\t   int fromlen, unsigned char *to)\n+static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n+\t\t\t  int fromlen, unsigned char *to, int tolen)\n {\n \tstruct pathComponent *pc;\n \tint elen = 0;\n+\tint comp_len;\n \tunsigned char *p = to;\n \n+\t/* Reserve one byte for terminating \\0 */\n+\ttolen--;\n \twhile (elen < fromlen) {\n \t\tpc = (struct pathComponent *)(from + elen);\n \t\tswitch (pc->componentType) {\n@@ -49,22 +52,37 @@ static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n \t\t\t\tbreak;\n \t\t\t/* Fall through */\n \t\tcase 2:\n+\t\t\tif (tolen == 0)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tp = to;\n \t\t\t*p++ = '/';\n+\t\t\ttolen--;\n \t\t\tbreak;\n \t\tcase 3:\n+\t\t\tif (tolen < 3)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tmemcpy(p, \""../\"", 3);\n \t\t\tp += 3;\n+\t\t\ttolen -= 3;\n \t\t\tbreak;\n \t\tcase 4:\n+\t\t\tif (tolen < 2)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tmemcpy(p, \""./\"", 2);\n \t\t\tp += 2;\n+\t\t\ttolen -= 2;\n \t\t\t/* that would be . - just ignore */\n \t\t\tbreak;\n \t\tcase 5:\n-\t\t\tp += udf_get_filename(sb, pc->componentIdent, p,\n-\t\t\t\t\t      pc->lengthComponentIdent);\n+\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n+\t\t\t\t\t\t    pc->lengthComponentIdent,\n+\t\t\t\t\t\t    p, tolen);\n+\t\t\tp += comp_len;\n+\t\t\ttolen -= comp_len;\n+\t\t\tif (tolen == 0)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\t*p++ = '/';\n+\t\t\ttolen--;\n \t\t\tbreak;\n \t\t}\n \t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n@@ -73,6 +91,7 @@ static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n \t\tp[-1] = '\\0';\n \telse\n \t\tp[0] = '\\0';\n+\treturn 0;\n }\n \n static int udf_symlink_filler(struct file *file, struct page *page)\n@@ -108,8 +127,10 @@ static int udf_symlink_filler(struct file *file, struct page *page)\n \t\tsymlink = bh->b_data;\n \t}\n \n-\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n+\terr = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);\n \tbrelse(bh);\n+\tif (err)\n+\t\tgoto out_unlock_inode;\n \n \tup_read(&iinfo->i_data_sem);\n \tSetPageUptodate(page);""}<_**next**_>{""sha"": ""47bb3f5ca360d4f1be8f92036685278868ab99e3"", ""filename"": ""fs/udf/udfdecl.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/udfdecl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/udfdecl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/udfdecl.h?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -211,7 +211,8 @@ udf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n }\n \n /* unicode.c */\n-extern int udf_get_filename(struct super_block *, uint8_t *, uint8_t *, int);\n+extern int udf_get_filename(struct super_block *, uint8_t *, int, uint8_t *,\n+\t\t\t    int);\n extern int udf_put_filename(struct super_block *, const uint8_t *, uint8_t *,\n \t\t\t    int);\n extern int udf_build_ustr(struct ustr *, dstring *, int);""}<_**next**_>{""sha"": ""b84fee372734bd494ba5eb86f5ce5c8c28b99b5a"", ""filename"": ""fs/udf/unicode.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 12, ""changes"": 28, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/unicode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/unicode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/unicode.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -28,7 +28,8 @@\n \n #include \""udf_sb.h\""\n \n-static int udf_translate_to_linux(uint8_t *, uint8_t *, int, uint8_t *, int);\n+static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n+\t\t\t\t  int);\n \n static int udf_char_to_ustr(struct ustr *dest, const uint8_t *src, int strlen)\n {\n@@ -333,8 +334,8 @@ static int udf_NLStoCS0(struct nls_table *nls, dstring *ocu, struct ustr *uni,\n \treturn u_len + 1;\n }\n \n-int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n-\t\t     int flen)\n+int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,\n+\t\t     uint8_t *dname, int dlen)\n {\n \tstruct ustr *filename, *unifilename;\n \tint len = 0;\n@@ -347,7 +348,7 @@ int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n \tif (!unifilename)\n \t\tgoto out1;\n \n-\tif (udf_build_ustr_exact(unifilename, sname, flen))\n+\tif (udf_build_ustr_exact(unifilename, sname, slen))\n \t\tgoto out2;\n \n \tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n@@ -366,7 +367,8 @@ int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n \t} else\n \t\tgoto out2;\n \n-\tlen = udf_translate_to_linux(dname, filename->u_name, filename->u_len,\n+\tlen = udf_translate_to_linux(dname, dlen,\n+\t\t\t\t     filename->u_name, filename->u_len,\n \t\t\t\t     unifilename->u_name, unifilename->u_len);\n out2:\n \tkfree(unifilename);\n@@ -403,10 +405,12 @@ int udf_put_filename(struct super_block *sb, const uint8_t *sname,\n #define EXT_MARK\t\t'.'\n #define CRC_MARK\t\t'#'\n #define EXT_SIZE \t\t5\n+/* Number of chars we need to store generated CRC to make filename unique */\n+#define CRC_LEN\t\t\t5\n \n-static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n-\t\t\t\t  int udfLen, uint8_t *fidName,\n-\t\t\t\t  int fidNameLen)\n+static int udf_translate_to_linux(uint8_t *newName, int newLen,\n+\t\t\t\t  uint8_t *udfName, int udfLen,\n+\t\t\t\t  uint8_t *fidName, int fidNameLen)\n {\n \tint index, newIndex = 0, needsCRC = 0;\n \tint extIndex = 0, newExtIndex = 0, hasExt = 0;\n@@ -439,7 +443,7 @@ static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n \t\t\t\t\tnewExtIndex = newIndex;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif (newIndex < 256)\n+\t\t\tif (newIndex < newLen)\n \t\t\t\tnewName[newIndex++] = curr;\n \t\t\telse\n \t\t\t\tneedsCRC = 1;\n@@ -467,13 +471,13 @@ static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n \t\t\t\t}\n \t\t\t\text[localExtIndex++] = curr;\n \t\t\t}\n-\t\t\tmaxFilenameLen = 250 - localExtIndex;\n+\t\t\tmaxFilenameLen = newLen - CRC_LEN - localExtIndex;\n \t\t\tif (newIndex > maxFilenameLen)\n \t\t\t\tnewIndex = maxFilenameLen;\n \t\t\telse\n \t\t\t\tnewIndex = newExtIndex;\n-\t\t} else if (newIndex > 250)\n-\t\t\tnewIndex = 250;\n+\t\t} else if (newIndex > newLen - CRC_LEN)\n+\t\t\tnewIndex = newLen - CRC_LEN;\n \t\tnewName[newIndex++] = CRC_MARK;\n \t\tvalueCRC = crc_itu_t(0, fidName, fidNameLen);\n \t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);""}","int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,
int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,
		     uint8_t *dname, int dlen)
 {
 	struct ustr *filename, *unifilename;
 	int len = 0;

	filename = kmalloc(sizeof(struct ustr), GFP_NOFS);
	if (!filename)
		return 0;

	unifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);
 	if (!unifilename)
 		goto out1;
 
	if (udf_build_ustr_exact(unifilename, sname, slen))
 		goto out2;
 
 	if (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {
		if (!udf_CS0toUTF8(filename, unifilename)) {
			udf_debug(""Failed in udf_get_filename: sname = %s\n"",
				  sname);
			goto out2;
		}
	} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {
		if (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,
				  unifilename)) {
			udf_debug(""Failed in udf_get_filename: sname = %s\n"",
				  sname);
			goto out2;
		}
 	} else
 		goto out2;
 
	len = udf_translate_to_linux(dname, dlen,
				     filename->u_name, filename->u_len,
 				     unifilename->u_name, unifilename->u_len);
 out2:
 	kfree(unifilename);
out1:
	kfree(filename);
	return len;
}
","int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,
		     int flen)
 {
 	struct ustr *filename, *unifilename;
 	int len = 0;

	filename = kmalloc(sizeof(struct ustr), GFP_NOFS);
	if (!filename)
		return 0;

	unifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);
 	if (!unifilename)
 		goto out1;
 
	if (udf_build_ustr_exact(unifilename, sname, flen))
 		goto out2;
 
 	if (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {
		if (!udf_CS0toUTF8(filename, unifilename)) {
			udf_debug(""Failed in udf_get_filename: sname = %s\n"",
				  sname);
			goto out2;
		}
	} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {
		if (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,
				  unifilename)) {
			udf_debug(""Failed in udf_get_filename: sname = %s\n"",
				  sname);
			goto out2;
		}
 	} else
 		goto out2;
 
	len = udf_translate_to_linux(dname, filename->u_name, filename->u_len,
 				     unifilename->u_name, unifilename->u_len);
 out2:
 	kfree(unifilename);
out1:
	kfree(filename);
	return len;
}
",C,"int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,
		     uint8_t *dname, int dlen)
	if (udf_build_ustr_exact(unifilename, sname, slen))
	len = udf_translate_to_linux(dname, dlen,
				     filename->u_name, filename->u_len,
","		     int flen)
	if (udf_build_ustr_exact(unifilename, sname, flen))
	len = udf_translate_to_linux(dname, filename->u_name, filename->u_len,
",,"@@ -28,7 +28,8 @@
 
 #include ""udf_sb.h""
 
-static int udf_translate_to_linux(uint8_t *, uint8_t *, int, uint8_t *, int);
+static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,
+				  int);
 
 static int udf_char_to_ustr(struct ustr *dest, const uint8_t *src, int strlen)
 {
@@ -333,8 +334,8 @@ static int udf_NLStoCS0(struct nls_table *nls, dstring *ocu, struct ustr *uni,
 	return u_len + 1;
 }
 
-int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,
-		     int flen)
+int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,
+		     uint8_t *dname, int dlen)
 {
 	struct ustr *filename, *unifilename;
 	int len = 0;
@@ -347,7 +348,7 @@ int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,
 	if (!unifilename)
 		goto out1;
 
-	if (udf_build_ustr_exact(unifilename, sname, flen))
+	if (udf_build_ustr_exact(unifilename, sname, slen))
 		goto out2;
 
 	if (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {
@@ -366,7 +367,8 @@ int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,
 	} else
 		goto out2;
 
-	len = udf_translate_to_linux(dname, filename->u_name, filename->u_len,
+	len = udf_translate_to_linux(dname, dlen,
+				     filename->u_name, filename->u_len,
 				     unifilename->u_name, unifilename->u_len);
 out2:
 	kfree(unifilename);
@@ -403,10 +405,12 @@ int udf_put_filename(struct super_block *sb, const uint8_t *sname,
 #define EXT_MARK		'.'
 #define CRC_MARK		'#'
 #define EXT_SIZE 		5
+/* Number of chars we need to store generated CRC to make filename unique */
+#define CRC_LEN			5
 
-static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,
-				  int udfLen, uint8_t *fidName,
-				  int fidNameLen)
+static int udf_translate_to_linux(uint8_t *newName, int newLen,
+				  uint8_t *udfName, int udfLen,
+				  uint8_t *fidName, int fidNameLen)
 {
 	int index, newIndex = 0, needsCRC = 0;
 	int extIndex = 0, newExtIndex = 0, hasExt = 0;
@@ -439,7 +443,7 @@ static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,
 					newExtIndex = newIndex;
 				}
 			}
-			if (newIndex < 256)
+			if (newIndex < newLen)
 				newName[newIndex++] = curr;
 			else
 				needsCRC = 1;
@@ -467,13 +471,13 @@ static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,
 				}
 				ext[localExtIndex++] = curr;
 			}
-			maxFilenameLen = 250 - localExtIndex;
+			maxFilenameLen = newLen - CRC_LEN - localExtIndex;
 			if (newIndex > maxFilenameLen)
 				newIndex = maxFilenameLen;
 			else
 				newIndex = newExtIndex;
-		} else if (newIndex > 250)
-			newIndex = 250;
+		} else if (newIndex > newLen - CRC_LEN)
+			newIndex = newLen - CRC_LEN;
 		newName[newIndex++] = CRC_MARK;
 		valueCRC = crc_itu_t(0, fidName, fidNameLen);
 		newName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);",linux,0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,a1d47b262952a45aae62bd49cfaf33dd76c11a2c,1,"int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,
//flaw_line_below:
		     int flen)
//fix_flaw_line_below:
//int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,
//fix_flaw_line_below:
//		     uint8_t *dname, int dlen)
 {
 	struct ustr *filename, *unifilename;
 	int len = 0;

	filename = kmalloc(sizeof(struct ustr), GFP_NOFS);
	if (!filename)
		return 0;

	unifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);
 	if (!unifilename)
 		goto out1;
 
//flaw_line_below:
	if (udf_build_ustr_exact(unifilename, sname, flen))
//fix_flaw_line_below:
//	if (udf_build_ustr_exact(unifilename, sname, slen))
 		goto out2;
 
 	if (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {
		if (!udf_CS0toUTF8(filename, unifilename)) {
			udf_debug(""Failed in udf_get_filename: sname = %s\n"",
				  sname);
			goto out2;
		}
	} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {
		if (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,
				  unifilename)) {
			udf_debug(""Failed in udf_get_filename: sname = %s\n"",
				  sname);
			goto out2;
		}
 	} else
 		goto out2;
 
//flaw_line_below:
	len = udf_translate_to_linux(dname, filename->u_name, filename->u_len,
//fix_flaw_line_below:
//	len = udf_translate_to_linux(dname, dlen,
//fix_flaw_line_below:
//				     filename->u_name, filename->u_len,
 				     unifilename->u_name, unifilename->u_len);
 out2:
 	kfree(unifilename);
out1:
	kfree(filename);
	return len;
}
"
2196,179932,,Local,Not required,,CVE-2014-9731,https://www.cvedetails.com/cve/CVE-2014-9731/,CWE-17,Low,Partial,,,2015-08-31,2.1,"The UDF filesystem implementation in the Linux kernel before 3.18.2 does not ensure that space is available for storing a symlink target's name along with a trailing 0 character, which allows local users to obtain sensitive information via a crafted filesystem image, related to fs/udf/symlink.c and fs/udf/unicode.c.",2017-07-12,+Info ,7,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,"udf: Check path length when reading symlink

Symlink reading code does not check whether the resulting path fits into
the page provided by the generic code. This isn't as easy as just
checking the symlink size because of various encoding conversions we
perform on path. So we have to check whether there is still enough space
in the buffer on the fly.

CC: stable@vger.kernel.org
Reported-by: Carl Henrik Lunde <chlunde@ping.uio.no>
Signed-off-by: Jan Kara <jack@suse.cz>",6,fs/udf/unicode.c,"{""sha"": ""a7690b46ce0a18624b80f056b1399c9520dffeda"", ""filename"": ""fs/udf/dir.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/dir.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/dir.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/dir.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -167,7 +167,8 @@ static int udf_readdir(struct file *file, struct dir_context *ctx)\n \t\t\tcontinue;\n \t\t}\n \n-\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n+\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n+\t\t\t\t\tUDF_NAME_LEN);\n \t\tif (!flen)\n \t\t\tcontinue;\n ""}<_**next**_>{""sha"": ""6ff19b54b51f285971232e30e9d437fa3966654a"", ""filename"": ""fs/udf/namei.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/namei.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/namei.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/namei.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -233,7 +233,8 @@ static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n \t\tif (!lfi)\n \t\t\tcontinue;\n \n-\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n+\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n+\t\t\t\t\tUDF_NAME_LEN);\n \t\tif (flen && udf_match(flen, fname, child->len, child->name))\n \t\t\tgoto out_ok;\n \t}""}<_**next**_>{""sha"": ""0f1b3a2654b9459a36c4df943f1f22a3bff070af"", ""filename"": ""fs/udf/symlink.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 5, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/symlink.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/symlink.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/symlink.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -30,13 +30,16 @@\n #include <linux/buffer_head.h>\n #include \""udf_i.h\""\n \n-static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n-\t\t\t   int fromlen, unsigned char *to)\n+static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n+\t\t\t  int fromlen, unsigned char *to, int tolen)\n {\n \tstruct pathComponent *pc;\n \tint elen = 0;\n+\tint comp_len;\n \tunsigned char *p = to;\n \n+\t/* Reserve one byte for terminating \\0 */\n+\ttolen--;\n \twhile (elen < fromlen) {\n \t\tpc = (struct pathComponent *)(from + elen);\n \t\tswitch (pc->componentType) {\n@@ -49,22 +52,37 @@ static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n \t\t\t\tbreak;\n \t\t\t/* Fall through */\n \t\tcase 2:\n+\t\t\tif (tolen == 0)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tp = to;\n \t\t\t*p++ = '/';\n+\t\t\ttolen--;\n \t\t\tbreak;\n \t\tcase 3:\n+\t\t\tif (tolen < 3)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tmemcpy(p, \""../\"", 3);\n \t\t\tp += 3;\n+\t\t\ttolen -= 3;\n \t\t\tbreak;\n \t\tcase 4:\n+\t\t\tif (tolen < 2)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tmemcpy(p, \""./\"", 2);\n \t\t\tp += 2;\n+\t\t\ttolen -= 2;\n \t\t\t/* that would be . - just ignore */\n \t\t\tbreak;\n \t\tcase 5:\n-\t\t\tp += udf_get_filename(sb, pc->componentIdent, p,\n-\t\t\t\t\t      pc->lengthComponentIdent);\n+\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n+\t\t\t\t\t\t    pc->lengthComponentIdent,\n+\t\t\t\t\t\t    p, tolen);\n+\t\t\tp += comp_len;\n+\t\t\ttolen -= comp_len;\n+\t\t\tif (tolen == 0)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\t*p++ = '/';\n+\t\t\ttolen--;\n \t\t\tbreak;\n \t\t}\n \t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n@@ -73,6 +91,7 @@ static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n \t\tp[-1] = '\\0';\n \telse\n \t\tp[0] = '\\0';\n+\treturn 0;\n }\n \n static int udf_symlink_filler(struct file *file, struct page *page)\n@@ -108,8 +127,10 @@ static int udf_symlink_filler(struct file *file, struct page *page)\n \t\tsymlink = bh->b_data;\n \t}\n \n-\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n+\terr = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);\n \tbrelse(bh);\n+\tif (err)\n+\t\tgoto out_unlock_inode;\n \n \tup_read(&iinfo->i_data_sem);\n \tSetPageUptodate(page);""}<_**next**_>{""sha"": ""47bb3f5ca360d4f1be8f92036685278868ab99e3"", ""filename"": ""fs/udf/udfdecl.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/udfdecl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/udfdecl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/udfdecl.h?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -211,7 +211,8 @@ udf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n }\n \n /* unicode.c */\n-extern int udf_get_filename(struct super_block *, uint8_t *, uint8_t *, int);\n+extern int udf_get_filename(struct super_block *, uint8_t *, int, uint8_t *,\n+\t\t\t    int);\n extern int udf_put_filename(struct super_block *, const uint8_t *, uint8_t *,\n \t\t\t    int);\n extern int udf_build_ustr(struct ustr *, dstring *, int);""}<_**next**_>{""sha"": ""b84fee372734bd494ba5eb86f5ce5c8c28b99b5a"", ""filename"": ""fs/udf/unicode.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 12, ""changes"": 28, ""blob_url"": ""https://github.com/torvalds/linux/blob/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/unicode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/fs/udf/unicode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/unicode.c?ref=0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14"", ""patch"": ""@@ -28,7 +28,8 @@\n \n #include \""udf_sb.h\""\n \n-static int udf_translate_to_linux(uint8_t *, uint8_t *, int, uint8_t *, int);\n+static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n+\t\t\t\t  int);\n \n static int udf_char_to_ustr(struct ustr *dest, const uint8_t *src, int strlen)\n {\n@@ -333,8 +334,8 @@ static int udf_NLStoCS0(struct nls_table *nls, dstring *ocu, struct ustr *uni,\n \treturn u_len + 1;\n }\n \n-int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n-\t\t     int flen)\n+int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,\n+\t\t     uint8_t *dname, int dlen)\n {\n \tstruct ustr *filename, *unifilename;\n \tint len = 0;\n@@ -347,7 +348,7 @@ int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n \tif (!unifilename)\n \t\tgoto out1;\n \n-\tif (udf_build_ustr_exact(unifilename, sname, flen))\n+\tif (udf_build_ustr_exact(unifilename, sname, slen))\n \t\tgoto out2;\n \n \tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n@@ -366,7 +367,8 @@ int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n \t} else\n \t\tgoto out2;\n \n-\tlen = udf_translate_to_linux(dname, filename->u_name, filename->u_len,\n+\tlen = udf_translate_to_linux(dname, dlen,\n+\t\t\t\t     filename->u_name, filename->u_len,\n \t\t\t\t     unifilename->u_name, unifilename->u_len);\n out2:\n \tkfree(unifilename);\n@@ -403,10 +405,12 @@ int udf_put_filename(struct super_block *sb, const uint8_t *sname,\n #define EXT_MARK\t\t'.'\n #define CRC_MARK\t\t'#'\n #define EXT_SIZE \t\t5\n+/* Number of chars we need to store generated CRC to make filename unique */\n+#define CRC_LEN\t\t\t5\n \n-static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n-\t\t\t\t  int udfLen, uint8_t *fidName,\n-\t\t\t\t  int fidNameLen)\n+static int udf_translate_to_linux(uint8_t *newName, int newLen,\n+\t\t\t\t  uint8_t *udfName, int udfLen,\n+\t\t\t\t  uint8_t *fidName, int fidNameLen)\n {\n \tint index, newIndex = 0, needsCRC = 0;\n \tint extIndex = 0, newExtIndex = 0, hasExt = 0;\n@@ -439,7 +443,7 @@ static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n \t\t\t\t\tnewExtIndex = newIndex;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif (newIndex < 256)\n+\t\t\tif (newIndex < newLen)\n \t\t\t\tnewName[newIndex++] = curr;\n \t\t\telse\n \t\t\t\tneedsCRC = 1;\n@@ -467,13 +471,13 @@ static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n \t\t\t\t}\n \t\t\t\text[localExtIndex++] = curr;\n \t\t\t}\n-\t\t\tmaxFilenameLen = 250 - localExtIndex;\n+\t\t\tmaxFilenameLen = newLen - CRC_LEN - localExtIndex;\n \t\t\tif (newIndex > maxFilenameLen)\n \t\t\t\tnewIndex = maxFilenameLen;\n \t\t\telse\n \t\t\t\tnewIndex = newExtIndex;\n-\t\t} else if (newIndex > 250)\n-\t\t\tnewIndex = 250;\n+\t\t} else if (newIndex > newLen - CRC_LEN)\n+\t\t\tnewIndex = newLen - CRC_LEN;\n \t\tnewName[newIndex++] = CRC_MARK;\n \t\tvalueCRC = crc_itu_t(0, fidName, fidNameLen);\n \t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);""}","static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,
static int udf_translate_to_linux(uint8_t *newName, int newLen,
				  uint8_t *udfName, int udfLen,
				  uint8_t *fidName, int fidNameLen)
 {
 	int index, newIndex = 0, needsCRC = 0;
 	int extIndex = 0, newExtIndex = 0, hasExt = 0;
	unsigned short valueCRC;
	uint8_t curr;

	if (udfName[0] == '.' &&
	    (udfLen == 1 || (udfLen == 2 && udfName[1] == '.'))) {
		needsCRC = 1;
		newIndex = udfLen;
		memcpy(newName, udfName, udfLen);
	} else {
		for (index = 0; index < udfLen; index++) {
			curr = udfName[index];
			if (curr == '/' || curr == 0) {
				needsCRC = 1;
				curr = ILLEGAL_CHAR_MARK;
				while (index + 1 < udfLen &&
						(udfName[index + 1] == '/' ||
						 udfName[index + 1] == 0))
					index++;
			}
			if (curr == EXT_MARK &&
					(udfLen - index - 1) <= EXT_SIZE) {
				if (udfLen == index + 1)
					hasExt = 0;
				else {
					hasExt = 1;
					extIndex = index;
 					newExtIndex = newIndex;
 				}
 			}
			if (newIndex < newLen)
 				newName[newIndex++] = curr;
 			else
 				needsCRC = 1;
		}
	}
	if (needsCRC) {
		uint8_t ext[EXT_SIZE];
		int localExtIndex = 0;

		if (hasExt) {
			int maxFilenameLen;
			for (index = 0;
			     index < EXT_SIZE && extIndex + index + 1 < udfLen;
			     index++) {
				curr = udfName[extIndex + index + 1];

				if (curr == '/' || curr == 0) {
					needsCRC = 1;
					curr = ILLEGAL_CHAR_MARK;
					while (extIndex + index + 2 < udfLen &&
					      (index + 1 < EXT_SIZE &&
						(udfName[extIndex + index + 2] == '/' ||
						 udfName[extIndex + index + 2] == 0)))
						index++;
 				}
 				ext[localExtIndex++] = curr;
 			}
			maxFilenameLen = newLen - CRC_LEN - localExtIndex;
 			if (newIndex > maxFilenameLen)
 				newIndex = maxFilenameLen;
 			else
 				newIndex = newExtIndex;
		} else if (newIndex > newLen - CRC_LEN)
			newIndex = newLen - CRC_LEN;
 		newName[newIndex++] = CRC_MARK;
 		valueCRC = crc_itu_t(0, fidName, fidNameLen);
 		newName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);
		newName[newIndex++] = hex_asc_upper_lo(valueCRC >> 8);
		newName[newIndex++] = hex_asc_upper_hi(valueCRC);
		newName[newIndex++] = hex_asc_upper_lo(valueCRC);

		if (hasExt) {
			newName[newIndex++] = EXT_MARK;
			for (index = 0; index < localExtIndex; index++)
				newName[newIndex++] = ext[index];
		}
	}

	return newIndex;
}
","static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,
				  int udfLen, uint8_t *fidName,
				  int fidNameLen)
 {
 	int index, newIndex = 0, needsCRC = 0;
 	int extIndex = 0, newExtIndex = 0, hasExt = 0;
	unsigned short valueCRC;
	uint8_t curr;

	if (udfName[0] == '.' &&
	    (udfLen == 1 || (udfLen == 2 && udfName[1] == '.'))) {
		needsCRC = 1;
		newIndex = udfLen;
		memcpy(newName, udfName, udfLen);
	} else {
		for (index = 0; index < udfLen; index++) {
			curr = udfName[index];
			if (curr == '/' || curr == 0) {
				needsCRC = 1;
				curr = ILLEGAL_CHAR_MARK;
				while (index + 1 < udfLen &&
						(udfName[index + 1] == '/' ||
						 udfName[index + 1] == 0))
					index++;
			}
			if (curr == EXT_MARK &&
					(udfLen - index - 1) <= EXT_SIZE) {
				if (udfLen == index + 1)
					hasExt = 0;
				else {
					hasExt = 1;
					extIndex = index;
 					newExtIndex = newIndex;
 				}
 			}
			if (newIndex < 256)
 				newName[newIndex++] = curr;
 			else
 				needsCRC = 1;
		}
	}
	if (needsCRC) {
		uint8_t ext[EXT_SIZE];
		int localExtIndex = 0;

		if (hasExt) {
			int maxFilenameLen;
			for (index = 0;
			     index < EXT_SIZE && extIndex + index + 1 < udfLen;
			     index++) {
				curr = udfName[extIndex + index + 1];

				if (curr == '/' || curr == 0) {
					needsCRC = 1;
					curr = ILLEGAL_CHAR_MARK;
					while (extIndex + index + 2 < udfLen &&
					      (index + 1 < EXT_SIZE &&
						(udfName[extIndex + index + 2] == '/' ||
						 udfName[extIndex + index + 2] == 0)))
						index++;
 				}
 				ext[localExtIndex++] = curr;
 			}
			maxFilenameLen = 250 - localExtIndex;
 			if (newIndex > maxFilenameLen)
 				newIndex = maxFilenameLen;
 			else
 				newIndex = newExtIndex;
		} else if (newIndex > 250)
			newIndex = 250;
 		newName[newIndex++] = CRC_MARK;
 		valueCRC = crc_itu_t(0, fidName, fidNameLen);
 		newName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);
		newName[newIndex++] = hex_asc_upper_lo(valueCRC >> 8);
		newName[newIndex++] = hex_asc_upper_hi(valueCRC);
		newName[newIndex++] = hex_asc_upper_lo(valueCRC);

		if (hasExt) {
			newName[newIndex++] = EXT_MARK;
			for (index = 0; index < localExtIndex; index++)
				newName[newIndex++] = ext[index];
		}
	}

	return newIndex;
}
",C,"static int udf_translate_to_linux(uint8_t *newName, int newLen,
				  uint8_t *udfName, int udfLen,
				  uint8_t *fidName, int fidNameLen)
			if (newIndex < newLen)
			maxFilenameLen = newLen - CRC_LEN - localExtIndex;
		} else if (newIndex > newLen - CRC_LEN)
			newIndex = newLen - CRC_LEN;
","				  int udfLen, uint8_t *fidName,
				  int fidNameLen)
			if (newIndex < 256)
			maxFilenameLen = 250 - localExtIndex;
		} else if (newIndex > 250)
			newIndex = 250;
",,"@@ -28,7 +28,8 @@
 
 #include ""udf_sb.h""
 
-static int udf_translate_to_linux(uint8_t *, uint8_t *, int, uint8_t *, int);
+static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,
+				  int);
 
 static int udf_char_to_ustr(struct ustr *dest, const uint8_t *src, int strlen)
 {
@@ -333,8 +334,8 @@ static int udf_NLStoCS0(struct nls_table *nls, dstring *ocu, struct ustr *uni,
 	return u_len + 1;
 }
 
-int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,
-		     int flen)
+int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,
+		     uint8_t *dname, int dlen)
 {
 	struct ustr *filename, *unifilename;
 	int len = 0;
@@ -347,7 +348,7 @@ int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,
 	if (!unifilename)
 		goto out1;
 
-	if (udf_build_ustr_exact(unifilename, sname, flen))
+	if (udf_build_ustr_exact(unifilename, sname, slen))
 		goto out2;
 
 	if (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {
@@ -366,7 +367,8 @@ int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,
 	} else
 		goto out2;
 
-	len = udf_translate_to_linux(dname, filename->u_name, filename->u_len,
+	len = udf_translate_to_linux(dname, dlen,
+				     filename->u_name, filename->u_len,
 				     unifilename->u_name, unifilename->u_len);
 out2:
 	kfree(unifilename);
@@ -403,10 +405,12 @@ int udf_put_filename(struct super_block *sb, const uint8_t *sname,
 #define EXT_MARK		'.'
 #define CRC_MARK		'#'
 #define EXT_SIZE 		5
+/* Number of chars we need to store generated CRC to make filename unique */
+#define CRC_LEN			5
 
-static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,
-				  int udfLen, uint8_t *fidName,
-				  int fidNameLen)
+static int udf_translate_to_linux(uint8_t *newName, int newLen,
+				  uint8_t *udfName, int udfLen,
+				  uint8_t *fidName, int fidNameLen)
 {
 	int index, newIndex = 0, needsCRC = 0;
 	int extIndex = 0, newExtIndex = 0, hasExt = 0;
@@ -439,7 +443,7 @@ static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,
 					newExtIndex = newIndex;
 				}
 			}
-			if (newIndex < 256)
+			if (newIndex < newLen)
 				newName[newIndex++] = curr;
 			else
 				needsCRC = 1;
@@ -467,13 +471,13 @@ static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,
 				}
 				ext[localExtIndex++] = curr;
 			}
-			maxFilenameLen = 250 - localExtIndex;
+			maxFilenameLen = newLen - CRC_LEN - localExtIndex;
 			if (newIndex > maxFilenameLen)
 				newIndex = maxFilenameLen;
 			else
 				newIndex = newExtIndex;
-		} else if (newIndex > 250)
-			newIndex = 250;
+		} else if (newIndex > newLen - CRC_LEN)
+			newIndex = newLen - CRC_LEN;
 		newName[newIndex++] = CRC_MARK;
 		valueCRC = crc_itu_t(0, fidName, fidNameLen);
 		newName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);",linux,0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,a1d47b262952a45aae62bd49cfaf33dd76c11a2c,1,"static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,
//flaw_line_below:
				  int udfLen, uint8_t *fidName,
//flaw_line_below:
				  int fidNameLen)
//fix_flaw_line_below:
//static int udf_translate_to_linux(uint8_t *newName, int newLen,
//fix_flaw_line_below:
//				  uint8_t *udfName, int udfLen,
//fix_flaw_line_below:
//				  uint8_t *fidName, int fidNameLen)
 {
 	int index, newIndex = 0, needsCRC = 0;
 	int extIndex = 0, newExtIndex = 0, hasExt = 0;
	unsigned short valueCRC;
	uint8_t curr;

	if (udfName[0] == '.' &&
	    (udfLen == 1 || (udfLen == 2 && udfName[1] == '.'))) {
		needsCRC = 1;
		newIndex = udfLen;
		memcpy(newName, udfName, udfLen);
	} else {
		for (index = 0; index < udfLen; index++) {
			curr = udfName[index];
			if (curr == '/' || curr == 0) {
				needsCRC = 1;
				curr = ILLEGAL_CHAR_MARK;
				while (index + 1 < udfLen &&
						(udfName[index + 1] == '/' ||
						 udfName[index + 1] == 0))
					index++;
			}
			if (curr == EXT_MARK &&
					(udfLen - index - 1) <= EXT_SIZE) {
				if (udfLen == index + 1)
					hasExt = 0;
				else {
					hasExt = 1;
					extIndex = index;
 					newExtIndex = newIndex;
 				}
 			}
//flaw_line_below:
			if (newIndex < 256)
//fix_flaw_line_below:
//			if (newIndex < newLen)
 				newName[newIndex++] = curr;
 			else
 				needsCRC = 1;
		}
	}
	if (needsCRC) {
		uint8_t ext[EXT_SIZE];
		int localExtIndex = 0;

		if (hasExt) {
			int maxFilenameLen;
			for (index = 0;
			     index < EXT_SIZE && extIndex + index + 1 < udfLen;
			     index++) {
				curr = udfName[extIndex + index + 1];

				if (curr == '/' || curr == 0) {
					needsCRC = 1;
					curr = ILLEGAL_CHAR_MARK;
					while (extIndex + index + 2 < udfLen &&
					      (index + 1 < EXT_SIZE &&
						(udfName[extIndex + index + 2] == '/' ||
						 udfName[extIndex + index + 2] == 0)))
						index++;
 				}
 				ext[localExtIndex++] = curr;
 			}
//flaw_line_below:
			maxFilenameLen = 250 - localExtIndex;
//fix_flaw_line_below:
//			maxFilenameLen = newLen - CRC_LEN - localExtIndex;
 			if (newIndex > maxFilenameLen)
 				newIndex = maxFilenameLen;
 			else
 				newIndex = newExtIndex;
//flaw_line_below:
		} else if (newIndex > 250)
//flaw_line_below:
			newIndex = 250;
//fix_flaw_line_below:
//		} else if (newIndex > newLen - CRC_LEN)
//fix_flaw_line_below:
//			newIndex = newLen - CRC_LEN;
 		newName[newIndex++] = CRC_MARK;
 		valueCRC = crc_itu_t(0, fidName, fidNameLen);
 		newName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);
		newName[newIndex++] = hex_asc_upper_lo(valueCRC >> 8);
		newName[newIndex++] = hex_asc_upper_hi(valueCRC);
		newName[newIndex++] = hex_asc_upper_lo(valueCRC);

		if (hasExt) {
			newName[newIndex++] = EXT_MARK;
			for (index = 0; index < localExtIndex; index++)
				newName[newIndex++] = ext[index];
		}
	}

	return newIndex;
}
"
2231,179967,,Local,Not required,Complete,CVE-2014-8172,https://www.cvedetails.com/cve/CVE-2014-8172/,CWE-17,Low,,,,2015-03-16,4.9,"The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations.",2015-03-23,DoS ,0,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,eee5cc2702929fd41cce28058dc6d6717f723f87,"get rid of s_files and files_lock

The only thing we need it for is alt-sysrq-r (emergency remount r/o)
and these days we can do just as well without going through the
list of files.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",12,fs/file_table.c,"{""sha"": ""23b6dca03ba06f4da0553b1db70f6911098382fc"", ""filename"": ""fs/file_table.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 125, ""changes"": 125, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/file_table.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {\n \t.max_files = NR_FILE\n };\n \n-DEFINE_STATIC_LGLOCK(files_lglock);\n-\n /* SLAB cache for file structures */\n static struct kmem_cache *filp_cachep __read_mostly;\n \n@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)\n \t\treturn ERR_PTR(error);\n \t}\n \n-\tINIT_LIST_HEAD(&f->f_u.fu_list);\n \tatomic_long_set(&f->f_count, 1);\n \trwlock_init(&f->f_owner.lock);\n \tspin_lock_init(&f->f_lock);\n@@ -304,7 +301,6 @@ void fput(struct file *file)\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n \n-\t\tfile_sb_list_del(file);\n \t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n \t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n \t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n-\t\tfile_sb_list_del(file);\n \t\tBUG_ON(!(task->flags & PF_KTHREAD));\n \t\t__fput(file);\n \t}\n@@ -345,129 +340,10 @@ void put_filp(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tsecurity_file_free(file);\n-\t\tfile_sb_list_del(file);\n \t\tfile_free(file);\n \t}\n }\n \n-static inline int file_list_cpu(struct file *file)\n-{\n-#ifdef CONFIG_SMP\n-\treturn file->f_sb_list_cpu;\n-#else\n-\treturn smp_processor_id();\n-#endif\n-}\n-\n-/* helper for file_sb_list_add to reduce ifdefs */\n-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tstruct list_head *list;\n-#ifdef CONFIG_SMP\n-\tint cpu;\n-\tcpu = smp_processor_id();\n-\tfile->f_sb_list_cpu = cpu;\n-\tlist = per_cpu_ptr(sb->s_files, cpu);\n-#else\n-\tlist = &sb->s_files;\n-#endif\n-\tlist_add(&file->f_u.fu_list, list);\n-}\n-\n-/**\n- * file_sb_list_add - add a file to the sb's file list\n- * @file: file to add\n- * @sb: sb to add it to\n- *\n- * Use this function to associate a file with the superblock of the inode it\n- * refers to.\n- */\n-void file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tif (likely(!(file->f_mode & FMODE_WRITE)))\n-\t\treturn;\n-\tif (!S_ISREG(file_inode(file)->i_mode))\n-\t\treturn;\n-\tlg_local_lock(&files_lglock);\n-\t__file_sb_list_add(file, sb);\n-\tlg_local_unlock(&files_lglock);\n-}\n-\n-/**\n- * file_sb_list_del - remove a file from the sb's file list\n- * @file: file to remove\n- * @sb: sb to remove it from\n- *\n- * Use this function to remove a file from its superblock.\n- */\n-void file_sb_list_del(struct file *file)\n-{\n-\tif (!list_empty(&file->f_u.fu_list)) {\n-\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n-\t\tlist_del_init(&file->f_u.fu_list);\n-\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n-\t}\n-}\n-\n-#ifdef CONFIG_SMP\n-\n-/*\n- * These macros iterate all files on all CPUs for a given superblock.\n- * files_lglock must be held globally.\n- */\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tint i;\t\t\t\t\t\t\t\\\n-\tfor_each_possible_cpu(i) {\t\t\t\t\\\n-\t\tstruct list_head *list;\t\t\t\t\\\n-\t\tlist = per_cpu_ptr((__sb)->s_files, i);\t\t\\\n-\t\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-}\n-\n-#else\n-\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tstruct list_head *list;\t\t\t\t\t\\\n-\tlist = &(sb)->s_files;\t\t\t\t\t\\\n-\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-}\n-\n-#endif\n-\n-/**\n- *\tmark_files_ro - mark all files read-only\n- *\t@sb: superblock in question\n- *\n- *\tAll files are marked read-only.  We don't care about pending\n- *\tdelete files so this should be used in 'force' mode only.\n- */\n-void mark_files_ro(struct super_block *sb)\n-{\n-\tstruct file *f;\n-\n-\tlg_global_lock(&files_lglock);\n-\tdo_file_list_for_each_entry(sb, f) {\n-\t\tif (!file_count(f))\n-\t\t\tcontinue;\n-\t\tif (!(f->f_mode & FMODE_WRITE))\n-\t\t\tcontinue;\n-\t\tspin_lock(&f->f_lock);\n-\t\tf->f_mode &= ~FMODE_WRITE;\n-\t\tspin_unlock(&f->f_lock);\n-\t\tif (file_check_writeable(f) != 0)\n-\t\t\tcontinue;\n-\t\t__mnt_drop_write(f->f_path.mnt);\n-\t\tfile_release_write(f);\n-\t} while_file_list_for_each_entry;\n-\tlg_global_unlock(&files_lglock);\n-}\n-\n void __init files_init(unsigned long mempages)\n { \n \tunsigned long n;\n@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)\n \tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n \tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n \tfiles_defer_init();\n-\tlg_lock_init(&files_lglock, \""files_lglock\"");\n \tpercpu_counter_init(&nr_files, 0);\n } ""}<_**next**_>{""sha"": ""4657424074668dcb933c8d375244b1d3b9d72561"", ""filename"": ""fs/internal.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/internal.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -73,9 +73,6 @@ extern void chroot_fs_refs(const struct path *, const struct path *);\n /*\n  * file_table.c\n  */\n-extern void file_sb_list_add(struct file *f, struct super_block *sb);\n-extern void file_sb_list_del(struct file *f);\n-extern void mark_files_ro(struct super_block *);\n extern struct file *get_empty_filp(void);\n \n /*""}<_**next**_>{""sha"": ""fffbed40dbe9e24dc6129878cf65527e241d4d48"", ""filename"": ""fs/open.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/open.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -685,7 +685,6 @@ static int do_dentry_open(struct file *f,\n \t}\n \n \tf->f_mapping = inode->i_mapping;\n-\tfile_sb_list_add(f, inode->i_sb);\n \n \tif (unlikely(f->f_mode & FMODE_PATH)) {\n \t\tf->f_op = &empty_fops;\n@@ -724,7 +723,6 @@ static int do_dentry_open(struct file *f,\n \n cleanup_all:\n \tfops_put(f->f_op);\n-\tfile_sb_list_del(f);\n \tif (f->f_mode & FMODE_WRITE) {\n \t\tput_write_access(inode);\n \t\tif (!special_file(inode->i_mode)) {""}<_**next**_>{""sha"": ""e5f6c2cfac380a7c4503dcebb0b3e310841893f0"", ""filename"": ""fs/super.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 13, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/super.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)\n \tint i;\n \tlist_lru_destroy(&s->s_dentry_lru);\n \tlist_lru_destroy(&s->s_inode_lru);\n-#ifdef CONFIG_SMP\n-\tfree_percpu(s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n \t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n \tsecurity_sb_free(s);\n@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)\n \tif (security_sb_alloc(s))\n \t\tgoto fail;\n \n-#ifdef CONFIG_SMP\n-\ts->s_files = alloc_percpu(struct list_head);\n-\tif (!s->s_files)\n-\t\tgoto fail;\n-\tfor_each_possible_cpu(i)\n-\t\tINIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));\n-#else\n-\tINIT_LIST_HEAD(&s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n \t\tif (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)\n \t\t\tgoto fail;\n@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n-\t\t\tmark_files_ro(sb);\n+\t\t\tsb->s_readonly_remount = 1;\n+\t\t\tsmp_wmb();\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)""}<_**next**_>{""sha"": ""2b0f4e974480c353a90654e634cc6f4a6d1293c4"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 13, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -764,12 +764,7 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n #define FILE_MNT_WRITE_RELEASED\t2\n \n struct file {\n-\t/*\n-\t * fu_list becomes invalid after file_free is called and queued via\n-\t * fu_rcuhead for RCU freeing\n-\t */\n \tunion {\n-\t\tstruct list_head\tfu_list;\n \t\tstruct llist_node\tfu_llist;\n \t\tstruct rcu_head \tfu_rcuhead;\n \t} f_u;\n@@ -783,9 +778,6 @@ struct file {\n \t * Must not be taken from IRQ context.\n \t */\n \tspinlock_t\t\tf_lock;\n-#ifdef CONFIG_SMP\n-\tint\t\t\tf_sb_list_cpu;\n-#endif\n \tatomic_long_t\t\tf_count;\n \tunsigned int \t\tf_flags;\n \tfmode_t\t\t\tf_mode;\n@@ -1264,11 +1256,6 @@ struct super_block {\n \n \tstruct list_head\ts_inodes;\t/* all inodes */\n \tstruct hlist_bl_head\ts_anon;\t\t/* anonymous dentries for (nfs) exporting */\n-#ifdef CONFIG_SMP\n-\tstruct list_head __percpu *s_files;\n-#else\n-\tstruct list_head\ts_files;\n-#endif\n \tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n \tstruct block_device\t*s_bdev;\n \tstruct backing_dev_info *s_bdi;""}","static inline void __file_sb_list_add(struct file *file, struct super_block *sb)
","static inline void __file_sb_list_add(struct file *file, struct super_block *sb)
{
	struct list_head *list;
#ifdef CONFIG_SMP
	int cpu;
	cpu = smp_processor_id();
	file->f_sb_list_cpu = cpu;
	list = per_cpu_ptr(sb->s_files, cpu);
#else
	list = &sb->s_files;
#endif
	list_add(&file->f_u.fu_list, list);
}
",C,,"{
	struct list_head *list;
#ifdef CONFIG_SMP
	int cpu;
	cpu = smp_processor_id();
	file->f_sb_list_cpu = cpu;
	list = per_cpu_ptr(sb->s_files, cpu);
#else
	list = &sb->s_files;
#endif
	list_add(&file->f_u.fu_list, list);
}
",,"@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {
 	.max_files = NR_FILE
 };
 
-DEFINE_STATIC_LGLOCK(files_lglock);
-
 /* SLAB cache for file structures */
 static struct kmem_cache *filp_cachep __read_mostly;
 
@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)
 		return ERR_PTR(error);
 	}
 
-	INIT_LIST_HEAD(&f->f_u.fu_list);
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
@@ -304,7 +301,6 @@ void fput(struct file *file)
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
 
-		file_sb_list_del(file);
 		if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {
 			init_task_work(&file->f_u.fu_rcuhead, ____fput);
 			if (!task_work_add(task, &file->f_u.fu_rcuhead, true))
@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
-		file_sb_list_del(file);
 		BUG_ON(!(task->flags & PF_KTHREAD));
 		__fput(file);
 	}
@@ -345,129 +340,10 @@ void put_filp(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		security_file_free(file);
-		file_sb_list_del(file);
 		file_free(file);
 	}
 }
 
-static inline int file_list_cpu(struct file *file)
-{
-#ifdef CONFIG_SMP
-	return file->f_sb_list_cpu;
-#else
-	return smp_processor_id();
-#endif
-}
-
-/* helper for file_sb_list_add to reduce ifdefs */
-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	struct list_head *list;
-#ifdef CONFIG_SMP
-	int cpu;
-	cpu = smp_processor_id();
-	file->f_sb_list_cpu = cpu;
-	list = per_cpu_ptr(sb->s_files, cpu);
-#else
-	list = &sb->s_files;
-#endif
-	list_add(&file->f_u.fu_list, list);
-}
-
-/**
- * file_sb_list_add - add a file to the sb's file list
- * @file: file to add
- * @sb: sb to add it to
- *
- * Use this function to associate a file with the superblock of the inode it
- * refers to.
- */
-void file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	if (likely(!(file->f_mode & FMODE_WRITE)))
-		return;
-	if (!S_ISREG(file_inode(file)->i_mode))
-		return;
-	lg_local_lock(&files_lglock);
-	__file_sb_list_add(file, sb);
-	lg_local_unlock(&files_lglock);
-}
-
-/**
- * file_sb_list_del - remove a file from the sb's file list
- * @file: file to remove
- * @sb: sb to remove it from
- *
- * Use this function to remove a file from its superblock.
- */
-void file_sb_list_del(struct file *file)
-{
-	if (!list_empty(&file->f_u.fu_list)) {
-		lg_local_lock_cpu(&files_lglock, file_list_cpu(file));
-		list_del_init(&file->f_u.fu_list);
-		lg_local_unlock_cpu(&files_lglock, file_list_cpu(file));
-	}
-}
-
-#ifdef CONFIG_SMP
-
-/*
- * These macros iterate all files on all CPUs for a given superblock.
- * files_lglock must be held globally.
- */
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	int i;							\
-	for_each_possible_cpu(i) {				\
-		struct list_head *list;				\
-		list = per_cpu_ptr((__sb)->s_files, i);		\
-		list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-	}							\
-}
-
-#else
-
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	struct list_head *list;					\
-	list = &(sb)->s_files;					\
-	list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-}
-
-#endif
-
-/**
- *	mark_files_ro - mark all files read-only
- *	@sb: superblock in question
- *
- *	All files are marked read-only.  We don't care about pending
- *	delete files so this should be used in 'force' mode only.
- */
-void mark_files_ro(struct super_block *sb)
-{
-	struct file *f;
-
-	lg_global_lock(&files_lglock);
-	do_file_list_for_each_entry(sb, f) {
-		if (!file_count(f))
-			continue;
-		if (!(f->f_mode & FMODE_WRITE))
-			continue;
-		spin_lock(&f->f_lock);
-		f->f_mode &= ~FMODE_WRITE;
-		spin_unlock(&f->f_lock);
-		if (file_check_writeable(f) != 0)
-			continue;
-		__mnt_drop_write(f->f_path.mnt);
-		file_release_write(f);
-	} while_file_list_for_each_entry;
-	lg_global_unlock(&files_lglock);
-}
-
 void __init files_init(unsigned long mempages)
 { 
 	unsigned long n;
@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)
 	n = (mempages * (PAGE_SIZE / 1024)) / 10;
 	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
 	files_defer_init();
-	lg_lock_init(&files_lglock, ""files_lglock"");
 	percpu_counter_init(&nr_files, 0);
 } ",linux,eee5cc2702929fd41cce28058dc6d6717f723f87,8b61e74ffc6310e1d35a9b51c8463093851f8bcf,1,"static inline void __file_sb_list_add(struct file *file, struct super_block *sb)
//flaw_line_below:
{
//flaw_line_below:
	struct list_head *list;
//flaw_line_below:
#ifdef CONFIG_SMP
//flaw_line_below:
	int cpu;
//flaw_line_below:
	cpu = smp_processor_id();
//flaw_line_below:
	file->f_sb_list_cpu = cpu;
//flaw_line_below:
	list = per_cpu_ptr(sb->s_files, cpu);
//flaw_line_below:
#else
//flaw_line_below:
	list = &sb->s_files;
//flaw_line_below:
#endif
//flaw_line_below:
	list_add(&file->f_u.fu_list, list);
//flaw_line_below:
}
"
2232,179968,,Local,Not required,Complete,CVE-2014-8172,https://www.cvedetails.com/cve/CVE-2014-8172/,CWE-17,Low,,,,2015-03-16,4.9,"The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations.",2015-03-23,DoS ,0,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,eee5cc2702929fd41cce28058dc6d6717f723f87,"get rid of s_files and files_lock

The only thing we need it for is alt-sysrq-r (emergency remount r/o)
and these days we can do just as well without going through the
list of files.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",1,fs/file_table.c,"{""sha"": ""23b6dca03ba06f4da0553b1db70f6911098382fc"", ""filename"": ""fs/file_table.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 125, ""changes"": 125, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/file_table.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {\n \t.max_files = NR_FILE\n };\n \n-DEFINE_STATIC_LGLOCK(files_lglock);\n-\n /* SLAB cache for file structures */\n static struct kmem_cache *filp_cachep __read_mostly;\n \n@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)\n \t\treturn ERR_PTR(error);\n \t}\n \n-\tINIT_LIST_HEAD(&f->f_u.fu_list);\n \tatomic_long_set(&f->f_count, 1);\n \trwlock_init(&f->f_owner.lock);\n \tspin_lock_init(&f->f_lock);\n@@ -304,7 +301,6 @@ void fput(struct file *file)\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n \n-\t\tfile_sb_list_del(file);\n \t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n \t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n \t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n-\t\tfile_sb_list_del(file);\n \t\tBUG_ON(!(task->flags & PF_KTHREAD));\n \t\t__fput(file);\n \t}\n@@ -345,129 +340,10 @@ void put_filp(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tsecurity_file_free(file);\n-\t\tfile_sb_list_del(file);\n \t\tfile_free(file);\n \t}\n }\n \n-static inline int file_list_cpu(struct file *file)\n-{\n-#ifdef CONFIG_SMP\n-\treturn file->f_sb_list_cpu;\n-#else\n-\treturn smp_processor_id();\n-#endif\n-}\n-\n-/* helper for file_sb_list_add to reduce ifdefs */\n-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tstruct list_head *list;\n-#ifdef CONFIG_SMP\n-\tint cpu;\n-\tcpu = smp_processor_id();\n-\tfile->f_sb_list_cpu = cpu;\n-\tlist = per_cpu_ptr(sb->s_files, cpu);\n-#else\n-\tlist = &sb->s_files;\n-#endif\n-\tlist_add(&file->f_u.fu_list, list);\n-}\n-\n-/**\n- * file_sb_list_add - add a file to the sb's file list\n- * @file: file to add\n- * @sb: sb to add it to\n- *\n- * Use this function to associate a file with the superblock of the inode it\n- * refers to.\n- */\n-void file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tif (likely(!(file->f_mode & FMODE_WRITE)))\n-\t\treturn;\n-\tif (!S_ISREG(file_inode(file)->i_mode))\n-\t\treturn;\n-\tlg_local_lock(&files_lglock);\n-\t__file_sb_list_add(file, sb);\n-\tlg_local_unlock(&files_lglock);\n-}\n-\n-/**\n- * file_sb_list_del - remove a file from the sb's file list\n- * @file: file to remove\n- * @sb: sb to remove it from\n- *\n- * Use this function to remove a file from its superblock.\n- */\n-void file_sb_list_del(struct file *file)\n-{\n-\tif (!list_empty(&file->f_u.fu_list)) {\n-\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n-\t\tlist_del_init(&file->f_u.fu_list);\n-\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n-\t}\n-}\n-\n-#ifdef CONFIG_SMP\n-\n-/*\n- * These macros iterate all files on all CPUs for a given superblock.\n- * files_lglock must be held globally.\n- */\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tint i;\t\t\t\t\t\t\t\\\n-\tfor_each_possible_cpu(i) {\t\t\t\t\\\n-\t\tstruct list_head *list;\t\t\t\t\\\n-\t\tlist = per_cpu_ptr((__sb)->s_files, i);\t\t\\\n-\t\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-}\n-\n-#else\n-\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tstruct list_head *list;\t\t\t\t\t\\\n-\tlist = &(sb)->s_files;\t\t\t\t\t\\\n-\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-}\n-\n-#endif\n-\n-/**\n- *\tmark_files_ro - mark all files read-only\n- *\t@sb: superblock in question\n- *\n- *\tAll files are marked read-only.  We don't care about pending\n- *\tdelete files so this should be used in 'force' mode only.\n- */\n-void mark_files_ro(struct super_block *sb)\n-{\n-\tstruct file *f;\n-\n-\tlg_global_lock(&files_lglock);\n-\tdo_file_list_for_each_entry(sb, f) {\n-\t\tif (!file_count(f))\n-\t\t\tcontinue;\n-\t\tif (!(f->f_mode & FMODE_WRITE))\n-\t\t\tcontinue;\n-\t\tspin_lock(&f->f_lock);\n-\t\tf->f_mode &= ~FMODE_WRITE;\n-\t\tspin_unlock(&f->f_lock);\n-\t\tif (file_check_writeable(f) != 0)\n-\t\t\tcontinue;\n-\t\t__mnt_drop_write(f->f_path.mnt);\n-\t\tfile_release_write(f);\n-\t} while_file_list_for_each_entry;\n-\tlg_global_unlock(&files_lglock);\n-}\n-\n void __init files_init(unsigned long mempages)\n { \n \tunsigned long n;\n@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)\n \tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n \tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n \tfiles_defer_init();\n-\tlg_lock_init(&files_lglock, \""files_lglock\"");\n \tpercpu_counter_init(&nr_files, 0);\n } ""}<_**next**_>{""sha"": ""4657424074668dcb933c8d375244b1d3b9d72561"", ""filename"": ""fs/internal.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/internal.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -73,9 +73,6 @@ extern void chroot_fs_refs(const struct path *, const struct path *);\n /*\n  * file_table.c\n  */\n-extern void file_sb_list_add(struct file *f, struct super_block *sb);\n-extern void file_sb_list_del(struct file *f);\n-extern void mark_files_ro(struct super_block *);\n extern struct file *get_empty_filp(void);\n \n /*""}<_**next**_>{""sha"": ""fffbed40dbe9e24dc6129878cf65527e241d4d48"", ""filename"": ""fs/open.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/open.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -685,7 +685,6 @@ static int do_dentry_open(struct file *f,\n \t}\n \n \tf->f_mapping = inode->i_mapping;\n-\tfile_sb_list_add(f, inode->i_sb);\n \n \tif (unlikely(f->f_mode & FMODE_PATH)) {\n \t\tf->f_op = &empty_fops;\n@@ -724,7 +723,6 @@ static int do_dentry_open(struct file *f,\n \n cleanup_all:\n \tfops_put(f->f_op);\n-\tfile_sb_list_del(f);\n \tif (f->f_mode & FMODE_WRITE) {\n \t\tput_write_access(inode);\n \t\tif (!special_file(inode->i_mode)) {""}<_**next**_>{""sha"": ""e5f6c2cfac380a7c4503dcebb0b3e310841893f0"", ""filename"": ""fs/super.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 13, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/super.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)\n \tint i;\n \tlist_lru_destroy(&s->s_dentry_lru);\n \tlist_lru_destroy(&s->s_inode_lru);\n-#ifdef CONFIG_SMP\n-\tfree_percpu(s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n \t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n \tsecurity_sb_free(s);\n@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)\n \tif (security_sb_alloc(s))\n \t\tgoto fail;\n \n-#ifdef CONFIG_SMP\n-\ts->s_files = alloc_percpu(struct list_head);\n-\tif (!s->s_files)\n-\t\tgoto fail;\n-\tfor_each_possible_cpu(i)\n-\t\tINIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));\n-#else\n-\tINIT_LIST_HEAD(&s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n \t\tif (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)\n \t\t\tgoto fail;\n@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n-\t\t\tmark_files_ro(sb);\n+\t\t\tsb->s_readonly_remount = 1;\n+\t\t\tsmp_wmb();\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)""}<_**next**_>{""sha"": ""2b0f4e974480c353a90654e634cc6f4a6d1293c4"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 13, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -764,12 +764,7 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n #define FILE_MNT_WRITE_RELEASED\t2\n \n struct file {\n-\t/*\n-\t * fu_list becomes invalid after file_free is called and queued via\n-\t * fu_rcuhead for RCU freeing\n-\t */\n \tunion {\n-\t\tstruct list_head\tfu_list;\n \t\tstruct llist_node\tfu_llist;\n \t\tstruct rcu_head \tfu_rcuhead;\n \t} f_u;\n@@ -783,9 +778,6 @@ struct file {\n \t * Must not be taken from IRQ context.\n \t */\n \tspinlock_t\t\tf_lock;\n-#ifdef CONFIG_SMP\n-\tint\t\t\tf_sb_list_cpu;\n-#endif\n \tatomic_long_t\t\tf_count;\n \tunsigned int \t\tf_flags;\n \tfmode_t\t\t\tf_mode;\n@@ -1264,11 +1256,6 @@ struct super_block {\n \n \tstruct list_head\ts_inodes;\t/* all inodes */\n \tstruct hlist_bl_head\ts_anon;\t\t/* anonymous dentries for (nfs) exporting */\n-#ifdef CONFIG_SMP\n-\tstruct list_head __percpu *s_files;\n-#else\n-\tstruct list_head\ts_files;\n-#endif\n \tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n \tstruct block_device\t*s_bdev;\n \tstruct backing_dev_info *s_bdi;""}","void __fput_sync(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
 		BUG_ON(!(task->flags & PF_KTHREAD));
 		__fput(file);
 	}
}
","void __fput_sync(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
		file_sb_list_del(file);
 		BUG_ON(!(task->flags & PF_KTHREAD));
 		__fput(file);
 	}
}
",C,,"		file_sb_list_del(file);
",,"@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {
 	.max_files = NR_FILE
 };
 
-DEFINE_STATIC_LGLOCK(files_lglock);
-
 /* SLAB cache for file structures */
 static struct kmem_cache *filp_cachep __read_mostly;
 
@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)
 		return ERR_PTR(error);
 	}
 
-	INIT_LIST_HEAD(&f->f_u.fu_list);
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
@@ -304,7 +301,6 @@ void fput(struct file *file)
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
 
-		file_sb_list_del(file);
 		if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {
 			init_task_work(&file->f_u.fu_rcuhead, ____fput);
 			if (!task_work_add(task, &file->f_u.fu_rcuhead, true))
@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
-		file_sb_list_del(file);
 		BUG_ON(!(task->flags & PF_KTHREAD));
 		__fput(file);
 	}
@@ -345,129 +340,10 @@ void put_filp(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		security_file_free(file);
-		file_sb_list_del(file);
 		file_free(file);
 	}
 }
 
-static inline int file_list_cpu(struct file *file)
-{
-#ifdef CONFIG_SMP
-	return file->f_sb_list_cpu;
-#else
-	return smp_processor_id();
-#endif
-}
-
-/* helper for file_sb_list_add to reduce ifdefs */
-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	struct list_head *list;
-#ifdef CONFIG_SMP
-	int cpu;
-	cpu = smp_processor_id();
-	file->f_sb_list_cpu = cpu;
-	list = per_cpu_ptr(sb->s_files, cpu);
-#else
-	list = &sb->s_files;
-#endif
-	list_add(&file->f_u.fu_list, list);
-}
-
-/**
- * file_sb_list_add - add a file to the sb's file list
- * @file: file to add
- * @sb: sb to add it to
- *
- * Use this function to associate a file with the superblock of the inode it
- * refers to.
- */
-void file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	if (likely(!(file->f_mode & FMODE_WRITE)))
-		return;
-	if (!S_ISREG(file_inode(file)->i_mode))
-		return;
-	lg_local_lock(&files_lglock);
-	__file_sb_list_add(file, sb);
-	lg_local_unlock(&files_lglock);
-}
-
-/**
- * file_sb_list_del - remove a file from the sb's file list
- * @file: file to remove
- * @sb: sb to remove it from
- *
- * Use this function to remove a file from its superblock.
- */
-void file_sb_list_del(struct file *file)
-{
-	if (!list_empty(&file->f_u.fu_list)) {
-		lg_local_lock_cpu(&files_lglock, file_list_cpu(file));
-		list_del_init(&file->f_u.fu_list);
-		lg_local_unlock_cpu(&files_lglock, file_list_cpu(file));
-	}
-}
-
-#ifdef CONFIG_SMP
-
-/*
- * These macros iterate all files on all CPUs for a given superblock.
- * files_lglock must be held globally.
- */
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	int i;							\
-	for_each_possible_cpu(i) {				\
-		struct list_head *list;				\
-		list = per_cpu_ptr((__sb)->s_files, i);		\
-		list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-	}							\
-}
-
-#else
-
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	struct list_head *list;					\
-	list = &(sb)->s_files;					\
-	list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-}
-
-#endif
-
-/**
- *	mark_files_ro - mark all files read-only
- *	@sb: superblock in question
- *
- *	All files are marked read-only.  We don't care about pending
- *	delete files so this should be used in 'force' mode only.
- */
-void mark_files_ro(struct super_block *sb)
-{
-	struct file *f;
-
-	lg_global_lock(&files_lglock);
-	do_file_list_for_each_entry(sb, f) {
-		if (!file_count(f))
-			continue;
-		if (!(f->f_mode & FMODE_WRITE))
-			continue;
-		spin_lock(&f->f_lock);
-		f->f_mode &= ~FMODE_WRITE;
-		spin_unlock(&f->f_lock);
-		if (file_check_writeable(f) != 0)
-			continue;
-		__mnt_drop_write(f->f_path.mnt);
-		file_release_write(f);
-	} while_file_list_for_each_entry;
-	lg_global_unlock(&files_lglock);
-}
-
 void __init files_init(unsigned long mempages)
 { 
 	unsigned long n;
@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)
 	n = (mempages * (PAGE_SIZE / 1024)) / 10;
 	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
 	files_defer_init();
-	lg_lock_init(&files_lglock, ""files_lglock"");
 	percpu_counter_init(&nr_files, 0);
 } ",linux,eee5cc2702929fd41cce28058dc6d6717f723f87,8b61e74ffc6310e1d35a9b51c8463093851f8bcf,1,"void __fput_sync(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
//flaw_line_below:
		file_sb_list_del(file);
 		BUG_ON(!(task->flags & PF_KTHREAD));
 		__fput(file);
 	}
}
"
2233,179969,,Local,Not required,Complete,CVE-2014-8172,https://www.cvedetails.com/cve/CVE-2014-8172/,CWE-17,Low,,,,2015-03-16,4.9,"The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations.",2015-03-23,DoS ,0,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,eee5cc2702929fd41cce28058dc6d6717f723f87,"get rid of s_files and files_lock

The only thing we need it for is alt-sysrq-r (emergency remount r/o)
and these days we can do just as well without going through the
list of files.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",7,fs/file_table.c,"{""sha"": ""23b6dca03ba06f4da0553b1db70f6911098382fc"", ""filename"": ""fs/file_table.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 125, ""changes"": 125, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/file_table.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {\n \t.max_files = NR_FILE\n };\n \n-DEFINE_STATIC_LGLOCK(files_lglock);\n-\n /* SLAB cache for file structures */\n static struct kmem_cache *filp_cachep __read_mostly;\n \n@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)\n \t\treturn ERR_PTR(error);\n \t}\n \n-\tINIT_LIST_HEAD(&f->f_u.fu_list);\n \tatomic_long_set(&f->f_count, 1);\n \trwlock_init(&f->f_owner.lock);\n \tspin_lock_init(&f->f_lock);\n@@ -304,7 +301,6 @@ void fput(struct file *file)\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n \n-\t\tfile_sb_list_del(file);\n \t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n \t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n \t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n-\t\tfile_sb_list_del(file);\n \t\tBUG_ON(!(task->flags & PF_KTHREAD));\n \t\t__fput(file);\n \t}\n@@ -345,129 +340,10 @@ void put_filp(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tsecurity_file_free(file);\n-\t\tfile_sb_list_del(file);\n \t\tfile_free(file);\n \t}\n }\n \n-static inline int file_list_cpu(struct file *file)\n-{\n-#ifdef CONFIG_SMP\n-\treturn file->f_sb_list_cpu;\n-#else\n-\treturn smp_processor_id();\n-#endif\n-}\n-\n-/* helper for file_sb_list_add to reduce ifdefs */\n-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tstruct list_head *list;\n-#ifdef CONFIG_SMP\n-\tint cpu;\n-\tcpu = smp_processor_id();\n-\tfile->f_sb_list_cpu = cpu;\n-\tlist = per_cpu_ptr(sb->s_files, cpu);\n-#else\n-\tlist = &sb->s_files;\n-#endif\n-\tlist_add(&file->f_u.fu_list, list);\n-}\n-\n-/**\n- * file_sb_list_add - add a file to the sb's file list\n- * @file: file to add\n- * @sb: sb to add it to\n- *\n- * Use this function to associate a file with the superblock of the inode it\n- * refers to.\n- */\n-void file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tif (likely(!(file->f_mode & FMODE_WRITE)))\n-\t\treturn;\n-\tif (!S_ISREG(file_inode(file)->i_mode))\n-\t\treturn;\n-\tlg_local_lock(&files_lglock);\n-\t__file_sb_list_add(file, sb);\n-\tlg_local_unlock(&files_lglock);\n-}\n-\n-/**\n- * file_sb_list_del - remove a file from the sb's file list\n- * @file: file to remove\n- * @sb: sb to remove it from\n- *\n- * Use this function to remove a file from its superblock.\n- */\n-void file_sb_list_del(struct file *file)\n-{\n-\tif (!list_empty(&file->f_u.fu_list)) {\n-\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n-\t\tlist_del_init(&file->f_u.fu_list);\n-\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n-\t}\n-}\n-\n-#ifdef CONFIG_SMP\n-\n-/*\n- * These macros iterate all files on all CPUs for a given superblock.\n- * files_lglock must be held globally.\n- */\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tint i;\t\t\t\t\t\t\t\\\n-\tfor_each_possible_cpu(i) {\t\t\t\t\\\n-\t\tstruct list_head *list;\t\t\t\t\\\n-\t\tlist = per_cpu_ptr((__sb)->s_files, i);\t\t\\\n-\t\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-}\n-\n-#else\n-\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tstruct list_head *list;\t\t\t\t\t\\\n-\tlist = &(sb)->s_files;\t\t\t\t\t\\\n-\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-}\n-\n-#endif\n-\n-/**\n- *\tmark_files_ro - mark all files read-only\n- *\t@sb: superblock in question\n- *\n- *\tAll files are marked read-only.  We don't care about pending\n- *\tdelete files so this should be used in 'force' mode only.\n- */\n-void mark_files_ro(struct super_block *sb)\n-{\n-\tstruct file *f;\n-\n-\tlg_global_lock(&files_lglock);\n-\tdo_file_list_for_each_entry(sb, f) {\n-\t\tif (!file_count(f))\n-\t\t\tcontinue;\n-\t\tif (!(f->f_mode & FMODE_WRITE))\n-\t\t\tcontinue;\n-\t\tspin_lock(&f->f_lock);\n-\t\tf->f_mode &= ~FMODE_WRITE;\n-\t\tspin_unlock(&f->f_lock);\n-\t\tif (file_check_writeable(f) != 0)\n-\t\t\tcontinue;\n-\t\t__mnt_drop_write(f->f_path.mnt);\n-\t\tfile_release_write(f);\n-\t} while_file_list_for_each_entry;\n-\tlg_global_unlock(&files_lglock);\n-}\n-\n void __init files_init(unsigned long mempages)\n { \n \tunsigned long n;\n@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)\n \tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n \tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n \tfiles_defer_init();\n-\tlg_lock_init(&files_lglock, \""files_lglock\"");\n \tpercpu_counter_init(&nr_files, 0);\n } ""}<_**next**_>{""sha"": ""4657424074668dcb933c8d375244b1d3b9d72561"", ""filename"": ""fs/internal.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/internal.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -73,9 +73,6 @@ extern void chroot_fs_refs(const struct path *, const struct path *);\n /*\n  * file_table.c\n  */\n-extern void file_sb_list_add(struct file *f, struct super_block *sb);\n-extern void file_sb_list_del(struct file *f);\n-extern void mark_files_ro(struct super_block *);\n extern struct file *get_empty_filp(void);\n \n /*""}<_**next**_>{""sha"": ""fffbed40dbe9e24dc6129878cf65527e241d4d48"", ""filename"": ""fs/open.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/open.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -685,7 +685,6 @@ static int do_dentry_open(struct file *f,\n \t}\n \n \tf->f_mapping = inode->i_mapping;\n-\tfile_sb_list_add(f, inode->i_sb);\n \n \tif (unlikely(f->f_mode & FMODE_PATH)) {\n \t\tf->f_op = &empty_fops;\n@@ -724,7 +723,6 @@ static int do_dentry_open(struct file *f,\n \n cleanup_all:\n \tfops_put(f->f_op);\n-\tfile_sb_list_del(f);\n \tif (f->f_mode & FMODE_WRITE) {\n \t\tput_write_access(inode);\n \t\tif (!special_file(inode->i_mode)) {""}<_**next**_>{""sha"": ""e5f6c2cfac380a7c4503dcebb0b3e310841893f0"", ""filename"": ""fs/super.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 13, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/super.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)\n \tint i;\n \tlist_lru_destroy(&s->s_dentry_lru);\n \tlist_lru_destroy(&s->s_inode_lru);\n-#ifdef CONFIG_SMP\n-\tfree_percpu(s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n \t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n \tsecurity_sb_free(s);\n@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)\n \tif (security_sb_alloc(s))\n \t\tgoto fail;\n \n-#ifdef CONFIG_SMP\n-\ts->s_files = alloc_percpu(struct list_head);\n-\tif (!s->s_files)\n-\t\tgoto fail;\n-\tfor_each_possible_cpu(i)\n-\t\tINIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));\n-#else\n-\tINIT_LIST_HEAD(&s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n \t\tif (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)\n \t\t\tgoto fail;\n@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n-\t\t\tmark_files_ro(sb);\n+\t\t\tsb->s_readonly_remount = 1;\n+\t\t\tsmp_wmb();\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)""}<_**next**_>{""sha"": ""2b0f4e974480c353a90654e634cc6f4a6d1293c4"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 13, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -764,12 +764,7 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n #define FILE_MNT_WRITE_RELEASED\t2\n \n struct file {\n-\t/*\n-\t * fu_list becomes invalid after file_free is called and queued via\n-\t * fu_rcuhead for RCU freeing\n-\t */\n \tunion {\n-\t\tstruct list_head\tfu_list;\n \t\tstruct llist_node\tfu_llist;\n \t\tstruct rcu_head \tfu_rcuhead;\n \t} f_u;\n@@ -783,9 +778,6 @@ struct file {\n \t * Must not be taken from IRQ context.\n \t */\n \tspinlock_t\t\tf_lock;\n-#ifdef CONFIG_SMP\n-\tint\t\t\tf_sb_list_cpu;\n-#endif\n \tatomic_long_t\t\tf_count;\n \tunsigned int \t\tf_flags;\n \tfmode_t\t\t\tf_mode;\n@@ -1264,11 +1256,6 @@ struct super_block {\n \n \tstruct list_head\ts_inodes;\t/* all inodes */\n \tstruct hlist_bl_head\ts_anon;\t\t/* anonymous dentries for (nfs) exporting */\n-#ifdef CONFIG_SMP\n-\tstruct list_head __percpu *s_files;\n-#else\n-\tstruct list_head\ts_files;\n-#endif\n \tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n \tstruct block_device\t*s_bdev;\n \tstruct backing_dev_info *s_bdi;""}","static inline int file_list_cpu(struct file *file)
","static inline int file_list_cpu(struct file *file)
{
#ifdef CONFIG_SMP
	return file->f_sb_list_cpu;
#else
	return smp_processor_id();
#endif
}
",C,,"{
#ifdef CONFIG_SMP
	return file->f_sb_list_cpu;
#else
	return smp_processor_id();
#endif
}
",,"@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {
 	.max_files = NR_FILE
 };
 
-DEFINE_STATIC_LGLOCK(files_lglock);
-
 /* SLAB cache for file structures */
 static struct kmem_cache *filp_cachep __read_mostly;
 
@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)
 		return ERR_PTR(error);
 	}
 
-	INIT_LIST_HEAD(&f->f_u.fu_list);
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
@@ -304,7 +301,6 @@ void fput(struct file *file)
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
 
-		file_sb_list_del(file);
 		if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {
 			init_task_work(&file->f_u.fu_rcuhead, ____fput);
 			if (!task_work_add(task, &file->f_u.fu_rcuhead, true))
@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
-		file_sb_list_del(file);
 		BUG_ON(!(task->flags & PF_KTHREAD));
 		__fput(file);
 	}
@@ -345,129 +340,10 @@ void put_filp(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		security_file_free(file);
-		file_sb_list_del(file);
 		file_free(file);
 	}
 }
 
-static inline int file_list_cpu(struct file *file)
-{
-#ifdef CONFIG_SMP
-	return file->f_sb_list_cpu;
-#else
-	return smp_processor_id();
-#endif
-}
-
-/* helper for file_sb_list_add to reduce ifdefs */
-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	struct list_head *list;
-#ifdef CONFIG_SMP
-	int cpu;
-	cpu = smp_processor_id();
-	file->f_sb_list_cpu = cpu;
-	list = per_cpu_ptr(sb->s_files, cpu);
-#else
-	list = &sb->s_files;
-#endif
-	list_add(&file->f_u.fu_list, list);
-}
-
-/**
- * file_sb_list_add - add a file to the sb's file list
- * @file: file to add
- * @sb: sb to add it to
- *
- * Use this function to associate a file with the superblock of the inode it
- * refers to.
- */
-void file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	if (likely(!(file->f_mode & FMODE_WRITE)))
-		return;
-	if (!S_ISREG(file_inode(file)->i_mode))
-		return;
-	lg_local_lock(&files_lglock);
-	__file_sb_list_add(file, sb);
-	lg_local_unlock(&files_lglock);
-}
-
-/**
- * file_sb_list_del - remove a file from the sb's file list
- * @file: file to remove
- * @sb: sb to remove it from
- *
- * Use this function to remove a file from its superblock.
- */
-void file_sb_list_del(struct file *file)
-{
-	if (!list_empty(&file->f_u.fu_list)) {
-		lg_local_lock_cpu(&files_lglock, file_list_cpu(file));
-		list_del_init(&file->f_u.fu_list);
-		lg_local_unlock_cpu(&files_lglock, file_list_cpu(file));
-	}
-}
-
-#ifdef CONFIG_SMP
-
-/*
- * These macros iterate all files on all CPUs for a given superblock.
- * files_lglock must be held globally.
- */
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	int i;							\
-	for_each_possible_cpu(i) {				\
-		struct list_head *list;				\
-		list = per_cpu_ptr((__sb)->s_files, i);		\
-		list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-	}							\
-}
-
-#else
-
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	struct list_head *list;					\
-	list = &(sb)->s_files;					\
-	list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-}
-
-#endif
-
-/**
- *	mark_files_ro - mark all files read-only
- *	@sb: superblock in question
- *
- *	All files are marked read-only.  We don't care about pending
- *	delete files so this should be used in 'force' mode only.
- */
-void mark_files_ro(struct super_block *sb)
-{
-	struct file *f;
-
-	lg_global_lock(&files_lglock);
-	do_file_list_for_each_entry(sb, f) {
-		if (!file_count(f))
-			continue;
-		if (!(f->f_mode & FMODE_WRITE))
-			continue;
-		spin_lock(&f->f_lock);
-		f->f_mode &= ~FMODE_WRITE;
-		spin_unlock(&f->f_lock);
-		if (file_check_writeable(f) != 0)
-			continue;
-		__mnt_drop_write(f->f_path.mnt);
-		file_release_write(f);
-	} while_file_list_for_each_entry;
-	lg_global_unlock(&files_lglock);
-}
-
 void __init files_init(unsigned long mempages)
 { 
 	unsigned long n;
@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)
 	n = (mempages * (PAGE_SIZE / 1024)) / 10;
 	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
 	files_defer_init();
-	lg_lock_init(&files_lglock, ""files_lglock"");
 	percpu_counter_init(&nr_files, 0);
 } ",linux,eee5cc2702929fd41cce28058dc6d6717f723f87,8b61e74ffc6310e1d35a9b51c8463093851f8bcf,1,"static inline int file_list_cpu(struct file *file)
//flaw_line_below:
{
//flaw_line_below:
#ifdef CONFIG_SMP
//flaw_line_below:
	return file->f_sb_list_cpu;
//flaw_line_below:
#else
//flaw_line_below:
	return smp_processor_id();
//flaw_line_below:
#endif
//flaw_line_below:
}
"
2234,179970,,Local,Not required,Complete,CVE-2014-8172,https://www.cvedetails.com/cve/CVE-2014-8172/,CWE-17,Low,,,,2015-03-16,4.9,"The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations.",2015-03-23,DoS ,0,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,eee5cc2702929fd41cce28058dc6d6717f723f87,"get rid of s_files and files_lock

The only thing we need it for is alt-sysrq-r (emergency remount r/o)
and these days we can do just as well without going through the
list of files.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",9,fs/file_table.c,"{""sha"": ""23b6dca03ba06f4da0553b1db70f6911098382fc"", ""filename"": ""fs/file_table.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 125, ""changes"": 125, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/file_table.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {\n \t.max_files = NR_FILE\n };\n \n-DEFINE_STATIC_LGLOCK(files_lglock);\n-\n /* SLAB cache for file structures */\n static struct kmem_cache *filp_cachep __read_mostly;\n \n@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)\n \t\treturn ERR_PTR(error);\n \t}\n \n-\tINIT_LIST_HEAD(&f->f_u.fu_list);\n \tatomic_long_set(&f->f_count, 1);\n \trwlock_init(&f->f_owner.lock);\n \tspin_lock_init(&f->f_lock);\n@@ -304,7 +301,6 @@ void fput(struct file *file)\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n \n-\t\tfile_sb_list_del(file);\n \t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n \t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n \t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n-\t\tfile_sb_list_del(file);\n \t\tBUG_ON(!(task->flags & PF_KTHREAD));\n \t\t__fput(file);\n \t}\n@@ -345,129 +340,10 @@ void put_filp(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tsecurity_file_free(file);\n-\t\tfile_sb_list_del(file);\n \t\tfile_free(file);\n \t}\n }\n \n-static inline int file_list_cpu(struct file *file)\n-{\n-#ifdef CONFIG_SMP\n-\treturn file->f_sb_list_cpu;\n-#else\n-\treturn smp_processor_id();\n-#endif\n-}\n-\n-/* helper for file_sb_list_add to reduce ifdefs */\n-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tstruct list_head *list;\n-#ifdef CONFIG_SMP\n-\tint cpu;\n-\tcpu = smp_processor_id();\n-\tfile->f_sb_list_cpu = cpu;\n-\tlist = per_cpu_ptr(sb->s_files, cpu);\n-#else\n-\tlist = &sb->s_files;\n-#endif\n-\tlist_add(&file->f_u.fu_list, list);\n-}\n-\n-/**\n- * file_sb_list_add - add a file to the sb's file list\n- * @file: file to add\n- * @sb: sb to add it to\n- *\n- * Use this function to associate a file with the superblock of the inode it\n- * refers to.\n- */\n-void file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tif (likely(!(file->f_mode & FMODE_WRITE)))\n-\t\treturn;\n-\tif (!S_ISREG(file_inode(file)->i_mode))\n-\t\treturn;\n-\tlg_local_lock(&files_lglock);\n-\t__file_sb_list_add(file, sb);\n-\tlg_local_unlock(&files_lglock);\n-}\n-\n-/**\n- * file_sb_list_del - remove a file from the sb's file list\n- * @file: file to remove\n- * @sb: sb to remove it from\n- *\n- * Use this function to remove a file from its superblock.\n- */\n-void file_sb_list_del(struct file *file)\n-{\n-\tif (!list_empty(&file->f_u.fu_list)) {\n-\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n-\t\tlist_del_init(&file->f_u.fu_list);\n-\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n-\t}\n-}\n-\n-#ifdef CONFIG_SMP\n-\n-/*\n- * These macros iterate all files on all CPUs for a given superblock.\n- * files_lglock must be held globally.\n- */\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tint i;\t\t\t\t\t\t\t\\\n-\tfor_each_possible_cpu(i) {\t\t\t\t\\\n-\t\tstruct list_head *list;\t\t\t\t\\\n-\t\tlist = per_cpu_ptr((__sb)->s_files, i);\t\t\\\n-\t\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-}\n-\n-#else\n-\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tstruct list_head *list;\t\t\t\t\t\\\n-\tlist = &(sb)->s_files;\t\t\t\t\t\\\n-\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-}\n-\n-#endif\n-\n-/**\n- *\tmark_files_ro - mark all files read-only\n- *\t@sb: superblock in question\n- *\n- *\tAll files are marked read-only.  We don't care about pending\n- *\tdelete files so this should be used in 'force' mode only.\n- */\n-void mark_files_ro(struct super_block *sb)\n-{\n-\tstruct file *f;\n-\n-\tlg_global_lock(&files_lglock);\n-\tdo_file_list_for_each_entry(sb, f) {\n-\t\tif (!file_count(f))\n-\t\t\tcontinue;\n-\t\tif (!(f->f_mode & FMODE_WRITE))\n-\t\t\tcontinue;\n-\t\tspin_lock(&f->f_lock);\n-\t\tf->f_mode &= ~FMODE_WRITE;\n-\t\tspin_unlock(&f->f_lock);\n-\t\tif (file_check_writeable(f) != 0)\n-\t\t\tcontinue;\n-\t\t__mnt_drop_write(f->f_path.mnt);\n-\t\tfile_release_write(f);\n-\t} while_file_list_for_each_entry;\n-\tlg_global_unlock(&files_lglock);\n-}\n-\n void __init files_init(unsigned long mempages)\n { \n \tunsigned long n;\n@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)\n \tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n \tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n \tfiles_defer_init();\n-\tlg_lock_init(&files_lglock, \""files_lglock\"");\n \tpercpu_counter_init(&nr_files, 0);\n } ""}<_**next**_>{""sha"": ""4657424074668dcb933c8d375244b1d3b9d72561"", ""filename"": ""fs/internal.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/internal.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -73,9 +73,6 @@ extern void chroot_fs_refs(const struct path *, const struct path *);\n /*\n  * file_table.c\n  */\n-extern void file_sb_list_add(struct file *f, struct super_block *sb);\n-extern void file_sb_list_del(struct file *f);\n-extern void mark_files_ro(struct super_block *);\n extern struct file *get_empty_filp(void);\n \n /*""}<_**next**_>{""sha"": ""fffbed40dbe9e24dc6129878cf65527e241d4d48"", ""filename"": ""fs/open.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/open.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -685,7 +685,6 @@ static int do_dentry_open(struct file *f,\n \t}\n \n \tf->f_mapping = inode->i_mapping;\n-\tfile_sb_list_add(f, inode->i_sb);\n \n \tif (unlikely(f->f_mode & FMODE_PATH)) {\n \t\tf->f_op = &empty_fops;\n@@ -724,7 +723,6 @@ static int do_dentry_open(struct file *f,\n \n cleanup_all:\n \tfops_put(f->f_op);\n-\tfile_sb_list_del(f);\n \tif (f->f_mode & FMODE_WRITE) {\n \t\tput_write_access(inode);\n \t\tif (!special_file(inode->i_mode)) {""}<_**next**_>{""sha"": ""e5f6c2cfac380a7c4503dcebb0b3e310841893f0"", ""filename"": ""fs/super.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 13, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/super.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)\n \tint i;\n \tlist_lru_destroy(&s->s_dentry_lru);\n \tlist_lru_destroy(&s->s_inode_lru);\n-#ifdef CONFIG_SMP\n-\tfree_percpu(s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n \t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n \tsecurity_sb_free(s);\n@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)\n \tif (security_sb_alloc(s))\n \t\tgoto fail;\n \n-#ifdef CONFIG_SMP\n-\ts->s_files = alloc_percpu(struct list_head);\n-\tif (!s->s_files)\n-\t\tgoto fail;\n-\tfor_each_possible_cpu(i)\n-\t\tINIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));\n-#else\n-\tINIT_LIST_HEAD(&s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n \t\tif (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)\n \t\t\tgoto fail;\n@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n-\t\t\tmark_files_ro(sb);\n+\t\t\tsb->s_readonly_remount = 1;\n+\t\t\tsmp_wmb();\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)""}<_**next**_>{""sha"": ""2b0f4e974480c353a90654e634cc6f4a6d1293c4"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 13, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -764,12 +764,7 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n #define FILE_MNT_WRITE_RELEASED\t2\n \n struct file {\n-\t/*\n-\t * fu_list becomes invalid after file_free is called and queued via\n-\t * fu_rcuhead for RCU freeing\n-\t */\n \tunion {\n-\t\tstruct list_head\tfu_list;\n \t\tstruct llist_node\tfu_llist;\n \t\tstruct rcu_head \tfu_rcuhead;\n \t} f_u;\n@@ -783,9 +778,6 @@ struct file {\n \t * Must not be taken from IRQ context.\n \t */\n \tspinlock_t\t\tf_lock;\n-#ifdef CONFIG_SMP\n-\tint\t\t\tf_sb_list_cpu;\n-#endif\n \tatomic_long_t\t\tf_count;\n \tunsigned int \t\tf_flags;\n \tfmode_t\t\t\tf_mode;\n@@ -1264,11 +1256,6 @@ struct super_block {\n \n \tstruct list_head\ts_inodes;\t/* all inodes */\n \tstruct hlist_bl_head\ts_anon;\t\t/* anonymous dentries for (nfs) exporting */\n-#ifdef CONFIG_SMP\n-\tstruct list_head __percpu *s_files;\n-#else\n-\tstruct list_head\ts_files;\n-#endif\n \tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n \tstruct block_device\t*s_bdev;\n \tstruct backing_dev_info *s_bdi;""}","void file_sb_list_add(struct file *file, struct super_block *sb)
","void file_sb_list_add(struct file *file, struct super_block *sb)
{
	if (likely(!(file->f_mode & FMODE_WRITE)))
		return;
	if (!S_ISREG(file_inode(file)->i_mode))
		return;
	lg_local_lock(&files_lglock);
	__file_sb_list_add(file, sb);
	lg_local_unlock(&files_lglock);
}
",C,,"{
	if (likely(!(file->f_mode & FMODE_WRITE)))
		return;
	if (!S_ISREG(file_inode(file)->i_mode))
		return;
	lg_local_lock(&files_lglock);
	__file_sb_list_add(file, sb);
	lg_local_unlock(&files_lglock);
}
",,"@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {
 	.max_files = NR_FILE
 };
 
-DEFINE_STATIC_LGLOCK(files_lglock);
-
 /* SLAB cache for file structures */
 static struct kmem_cache *filp_cachep __read_mostly;
 
@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)
 		return ERR_PTR(error);
 	}
 
-	INIT_LIST_HEAD(&f->f_u.fu_list);
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
@@ -304,7 +301,6 @@ void fput(struct file *file)
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
 
-		file_sb_list_del(file);
 		if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {
 			init_task_work(&file->f_u.fu_rcuhead, ____fput);
 			if (!task_work_add(task, &file->f_u.fu_rcuhead, true))
@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
-		file_sb_list_del(file);
 		BUG_ON(!(task->flags & PF_KTHREAD));
 		__fput(file);
 	}
@@ -345,129 +340,10 @@ void put_filp(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		security_file_free(file);
-		file_sb_list_del(file);
 		file_free(file);
 	}
 }
 
-static inline int file_list_cpu(struct file *file)
-{
-#ifdef CONFIG_SMP
-	return file->f_sb_list_cpu;
-#else
-	return smp_processor_id();
-#endif
-}
-
-/* helper for file_sb_list_add to reduce ifdefs */
-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	struct list_head *list;
-#ifdef CONFIG_SMP
-	int cpu;
-	cpu = smp_processor_id();
-	file->f_sb_list_cpu = cpu;
-	list = per_cpu_ptr(sb->s_files, cpu);
-#else
-	list = &sb->s_files;
-#endif
-	list_add(&file->f_u.fu_list, list);
-}
-
-/**
- * file_sb_list_add - add a file to the sb's file list
- * @file: file to add
- * @sb: sb to add it to
- *
- * Use this function to associate a file with the superblock of the inode it
- * refers to.
- */
-void file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	if (likely(!(file->f_mode & FMODE_WRITE)))
-		return;
-	if (!S_ISREG(file_inode(file)->i_mode))
-		return;
-	lg_local_lock(&files_lglock);
-	__file_sb_list_add(file, sb);
-	lg_local_unlock(&files_lglock);
-}
-
-/**
- * file_sb_list_del - remove a file from the sb's file list
- * @file: file to remove
- * @sb: sb to remove it from
- *
- * Use this function to remove a file from its superblock.
- */
-void file_sb_list_del(struct file *file)
-{
-	if (!list_empty(&file->f_u.fu_list)) {
-		lg_local_lock_cpu(&files_lglock, file_list_cpu(file));
-		list_del_init(&file->f_u.fu_list);
-		lg_local_unlock_cpu(&files_lglock, file_list_cpu(file));
-	}
-}
-
-#ifdef CONFIG_SMP
-
-/*
- * These macros iterate all files on all CPUs for a given superblock.
- * files_lglock must be held globally.
- */
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	int i;							\
-	for_each_possible_cpu(i) {				\
-		struct list_head *list;				\
-		list = per_cpu_ptr((__sb)->s_files, i);		\
-		list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-	}							\
-}
-
-#else
-
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	struct list_head *list;					\
-	list = &(sb)->s_files;					\
-	list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-}
-
-#endif
-
-/**
- *	mark_files_ro - mark all files read-only
- *	@sb: superblock in question
- *
- *	All files are marked read-only.  We don't care about pending
- *	delete files so this should be used in 'force' mode only.
- */
-void mark_files_ro(struct super_block *sb)
-{
-	struct file *f;
-
-	lg_global_lock(&files_lglock);
-	do_file_list_for_each_entry(sb, f) {
-		if (!file_count(f))
-			continue;
-		if (!(f->f_mode & FMODE_WRITE))
-			continue;
-		spin_lock(&f->f_lock);
-		f->f_mode &= ~FMODE_WRITE;
-		spin_unlock(&f->f_lock);
-		if (file_check_writeable(f) != 0)
-			continue;
-		__mnt_drop_write(f->f_path.mnt);
-		file_release_write(f);
-	} while_file_list_for_each_entry;
-	lg_global_unlock(&files_lglock);
-}
-
 void __init files_init(unsigned long mempages)
 { 
 	unsigned long n;
@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)
 	n = (mempages * (PAGE_SIZE / 1024)) / 10;
 	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
 	files_defer_init();
-	lg_lock_init(&files_lglock, ""files_lglock"");
 	percpu_counter_init(&nr_files, 0);
 } ",linux,eee5cc2702929fd41cce28058dc6d6717f723f87,8b61e74ffc6310e1d35a9b51c8463093851f8bcf,1,"void file_sb_list_add(struct file *file, struct super_block *sb)
//flaw_line_below:
{
//flaw_line_below:
	if (likely(!(file->f_mode & FMODE_WRITE)))
//flaw_line_below:
		return;
//flaw_line_below:
	if (!S_ISREG(file_inode(file)->i_mode))
//flaw_line_below:
		return;
//flaw_line_below:
	lg_local_lock(&files_lglock);
//flaw_line_below:
	__file_sb_list_add(file, sb);
//flaw_line_below:
	lg_local_unlock(&files_lglock);
//flaw_line_below:
}
"
2235,179971,,Local,Not required,Complete,CVE-2014-8172,https://www.cvedetails.com/cve/CVE-2014-8172/,CWE-17,Low,,,,2015-03-16,4.9,"The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations.",2015-03-23,DoS ,0,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,eee5cc2702929fd41cce28058dc6d6717f723f87,"get rid of s_files and files_lock

The only thing we need it for is alt-sysrq-r (emergency remount r/o)
and these days we can do just as well without going through the
list of files.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",7,fs/file_table.c,"{""sha"": ""23b6dca03ba06f4da0553b1db70f6911098382fc"", ""filename"": ""fs/file_table.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 125, ""changes"": 125, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/file_table.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {\n \t.max_files = NR_FILE\n };\n \n-DEFINE_STATIC_LGLOCK(files_lglock);\n-\n /* SLAB cache for file structures */\n static struct kmem_cache *filp_cachep __read_mostly;\n \n@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)\n \t\treturn ERR_PTR(error);\n \t}\n \n-\tINIT_LIST_HEAD(&f->f_u.fu_list);\n \tatomic_long_set(&f->f_count, 1);\n \trwlock_init(&f->f_owner.lock);\n \tspin_lock_init(&f->f_lock);\n@@ -304,7 +301,6 @@ void fput(struct file *file)\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n \n-\t\tfile_sb_list_del(file);\n \t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n \t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n \t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n-\t\tfile_sb_list_del(file);\n \t\tBUG_ON(!(task->flags & PF_KTHREAD));\n \t\t__fput(file);\n \t}\n@@ -345,129 +340,10 @@ void put_filp(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tsecurity_file_free(file);\n-\t\tfile_sb_list_del(file);\n \t\tfile_free(file);\n \t}\n }\n \n-static inline int file_list_cpu(struct file *file)\n-{\n-#ifdef CONFIG_SMP\n-\treturn file->f_sb_list_cpu;\n-#else\n-\treturn smp_processor_id();\n-#endif\n-}\n-\n-/* helper for file_sb_list_add to reduce ifdefs */\n-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tstruct list_head *list;\n-#ifdef CONFIG_SMP\n-\tint cpu;\n-\tcpu = smp_processor_id();\n-\tfile->f_sb_list_cpu = cpu;\n-\tlist = per_cpu_ptr(sb->s_files, cpu);\n-#else\n-\tlist = &sb->s_files;\n-#endif\n-\tlist_add(&file->f_u.fu_list, list);\n-}\n-\n-/**\n- * file_sb_list_add - add a file to the sb's file list\n- * @file: file to add\n- * @sb: sb to add it to\n- *\n- * Use this function to associate a file with the superblock of the inode it\n- * refers to.\n- */\n-void file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tif (likely(!(file->f_mode & FMODE_WRITE)))\n-\t\treturn;\n-\tif (!S_ISREG(file_inode(file)->i_mode))\n-\t\treturn;\n-\tlg_local_lock(&files_lglock);\n-\t__file_sb_list_add(file, sb);\n-\tlg_local_unlock(&files_lglock);\n-}\n-\n-/**\n- * file_sb_list_del - remove a file from the sb's file list\n- * @file: file to remove\n- * @sb: sb to remove it from\n- *\n- * Use this function to remove a file from its superblock.\n- */\n-void file_sb_list_del(struct file *file)\n-{\n-\tif (!list_empty(&file->f_u.fu_list)) {\n-\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n-\t\tlist_del_init(&file->f_u.fu_list);\n-\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n-\t}\n-}\n-\n-#ifdef CONFIG_SMP\n-\n-/*\n- * These macros iterate all files on all CPUs for a given superblock.\n- * files_lglock must be held globally.\n- */\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tint i;\t\t\t\t\t\t\t\\\n-\tfor_each_possible_cpu(i) {\t\t\t\t\\\n-\t\tstruct list_head *list;\t\t\t\t\\\n-\t\tlist = per_cpu_ptr((__sb)->s_files, i);\t\t\\\n-\t\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-}\n-\n-#else\n-\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tstruct list_head *list;\t\t\t\t\t\\\n-\tlist = &(sb)->s_files;\t\t\t\t\t\\\n-\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-}\n-\n-#endif\n-\n-/**\n- *\tmark_files_ro - mark all files read-only\n- *\t@sb: superblock in question\n- *\n- *\tAll files are marked read-only.  We don't care about pending\n- *\tdelete files so this should be used in 'force' mode only.\n- */\n-void mark_files_ro(struct super_block *sb)\n-{\n-\tstruct file *f;\n-\n-\tlg_global_lock(&files_lglock);\n-\tdo_file_list_for_each_entry(sb, f) {\n-\t\tif (!file_count(f))\n-\t\t\tcontinue;\n-\t\tif (!(f->f_mode & FMODE_WRITE))\n-\t\t\tcontinue;\n-\t\tspin_lock(&f->f_lock);\n-\t\tf->f_mode &= ~FMODE_WRITE;\n-\t\tspin_unlock(&f->f_lock);\n-\t\tif (file_check_writeable(f) != 0)\n-\t\t\tcontinue;\n-\t\t__mnt_drop_write(f->f_path.mnt);\n-\t\tfile_release_write(f);\n-\t} while_file_list_for_each_entry;\n-\tlg_global_unlock(&files_lglock);\n-}\n-\n void __init files_init(unsigned long mempages)\n { \n \tunsigned long n;\n@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)\n \tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n \tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n \tfiles_defer_init();\n-\tlg_lock_init(&files_lglock, \""files_lglock\"");\n \tpercpu_counter_init(&nr_files, 0);\n } ""}<_**next**_>{""sha"": ""4657424074668dcb933c8d375244b1d3b9d72561"", ""filename"": ""fs/internal.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/internal.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -73,9 +73,6 @@ extern void chroot_fs_refs(const struct path *, const struct path *);\n /*\n  * file_table.c\n  */\n-extern void file_sb_list_add(struct file *f, struct super_block *sb);\n-extern void file_sb_list_del(struct file *f);\n-extern void mark_files_ro(struct super_block *);\n extern struct file *get_empty_filp(void);\n \n /*""}<_**next**_>{""sha"": ""fffbed40dbe9e24dc6129878cf65527e241d4d48"", ""filename"": ""fs/open.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/open.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -685,7 +685,6 @@ static int do_dentry_open(struct file *f,\n \t}\n \n \tf->f_mapping = inode->i_mapping;\n-\tfile_sb_list_add(f, inode->i_sb);\n \n \tif (unlikely(f->f_mode & FMODE_PATH)) {\n \t\tf->f_op = &empty_fops;\n@@ -724,7 +723,6 @@ static int do_dentry_open(struct file *f,\n \n cleanup_all:\n \tfops_put(f->f_op);\n-\tfile_sb_list_del(f);\n \tif (f->f_mode & FMODE_WRITE) {\n \t\tput_write_access(inode);\n \t\tif (!special_file(inode->i_mode)) {""}<_**next**_>{""sha"": ""e5f6c2cfac380a7c4503dcebb0b3e310841893f0"", ""filename"": ""fs/super.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 13, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/super.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)\n \tint i;\n \tlist_lru_destroy(&s->s_dentry_lru);\n \tlist_lru_destroy(&s->s_inode_lru);\n-#ifdef CONFIG_SMP\n-\tfree_percpu(s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n \t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n \tsecurity_sb_free(s);\n@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)\n \tif (security_sb_alloc(s))\n \t\tgoto fail;\n \n-#ifdef CONFIG_SMP\n-\ts->s_files = alloc_percpu(struct list_head);\n-\tif (!s->s_files)\n-\t\tgoto fail;\n-\tfor_each_possible_cpu(i)\n-\t\tINIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));\n-#else\n-\tINIT_LIST_HEAD(&s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n \t\tif (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)\n \t\t\tgoto fail;\n@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n-\t\t\tmark_files_ro(sb);\n+\t\t\tsb->s_readonly_remount = 1;\n+\t\t\tsmp_wmb();\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)""}<_**next**_>{""sha"": ""2b0f4e974480c353a90654e634cc6f4a6d1293c4"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 13, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -764,12 +764,7 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n #define FILE_MNT_WRITE_RELEASED\t2\n \n struct file {\n-\t/*\n-\t * fu_list becomes invalid after file_free is called and queued via\n-\t * fu_rcuhead for RCU freeing\n-\t */\n \tunion {\n-\t\tstruct list_head\tfu_list;\n \t\tstruct llist_node\tfu_llist;\n \t\tstruct rcu_head \tfu_rcuhead;\n \t} f_u;\n@@ -783,9 +778,6 @@ struct file {\n \t * Must not be taken from IRQ context.\n \t */\n \tspinlock_t\t\tf_lock;\n-#ifdef CONFIG_SMP\n-\tint\t\t\tf_sb_list_cpu;\n-#endif\n \tatomic_long_t\t\tf_count;\n \tunsigned int \t\tf_flags;\n \tfmode_t\t\t\tf_mode;\n@@ -1264,11 +1256,6 @@ struct super_block {\n \n \tstruct list_head\ts_inodes;\t/* all inodes */\n \tstruct hlist_bl_head\ts_anon;\t\t/* anonymous dentries for (nfs) exporting */\n-#ifdef CONFIG_SMP\n-\tstruct list_head __percpu *s_files;\n-#else\n-\tstruct list_head\ts_files;\n-#endif\n \tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n \tstruct block_device\t*s_bdev;\n \tstruct backing_dev_info *s_bdi;""}","void file_sb_list_del(struct file *file)
","void file_sb_list_del(struct file *file)
{
	if (!list_empty(&file->f_u.fu_list)) {
		lg_local_lock_cpu(&files_lglock, file_list_cpu(file));
		list_del_init(&file->f_u.fu_list);
		lg_local_unlock_cpu(&files_lglock, file_list_cpu(file));
	}
}
",C,,"{
	if (!list_empty(&file->f_u.fu_list)) {
		lg_local_lock_cpu(&files_lglock, file_list_cpu(file));
		list_del_init(&file->f_u.fu_list);
		lg_local_unlock_cpu(&files_lglock, file_list_cpu(file));
	}
}
",,"@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {
 	.max_files = NR_FILE
 };
 
-DEFINE_STATIC_LGLOCK(files_lglock);
-
 /* SLAB cache for file structures */
 static struct kmem_cache *filp_cachep __read_mostly;
 
@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)
 		return ERR_PTR(error);
 	}
 
-	INIT_LIST_HEAD(&f->f_u.fu_list);
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
@@ -304,7 +301,6 @@ void fput(struct file *file)
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
 
-		file_sb_list_del(file);
 		if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {
 			init_task_work(&file->f_u.fu_rcuhead, ____fput);
 			if (!task_work_add(task, &file->f_u.fu_rcuhead, true))
@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
-		file_sb_list_del(file);
 		BUG_ON(!(task->flags & PF_KTHREAD));
 		__fput(file);
 	}
@@ -345,129 +340,10 @@ void put_filp(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		security_file_free(file);
-		file_sb_list_del(file);
 		file_free(file);
 	}
 }
 
-static inline int file_list_cpu(struct file *file)
-{
-#ifdef CONFIG_SMP
-	return file->f_sb_list_cpu;
-#else
-	return smp_processor_id();
-#endif
-}
-
-/* helper for file_sb_list_add to reduce ifdefs */
-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	struct list_head *list;
-#ifdef CONFIG_SMP
-	int cpu;
-	cpu = smp_processor_id();
-	file->f_sb_list_cpu = cpu;
-	list = per_cpu_ptr(sb->s_files, cpu);
-#else
-	list = &sb->s_files;
-#endif
-	list_add(&file->f_u.fu_list, list);
-}
-
-/**
- * file_sb_list_add - add a file to the sb's file list
- * @file: file to add
- * @sb: sb to add it to
- *
- * Use this function to associate a file with the superblock of the inode it
- * refers to.
- */
-void file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	if (likely(!(file->f_mode & FMODE_WRITE)))
-		return;
-	if (!S_ISREG(file_inode(file)->i_mode))
-		return;
-	lg_local_lock(&files_lglock);
-	__file_sb_list_add(file, sb);
-	lg_local_unlock(&files_lglock);
-}
-
-/**
- * file_sb_list_del - remove a file from the sb's file list
- * @file: file to remove
- * @sb: sb to remove it from
- *
- * Use this function to remove a file from its superblock.
- */
-void file_sb_list_del(struct file *file)
-{
-	if (!list_empty(&file->f_u.fu_list)) {
-		lg_local_lock_cpu(&files_lglock, file_list_cpu(file));
-		list_del_init(&file->f_u.fu_list);
-		lg_local_unlock_cpu(&files_lglock, file_list_cpu(file));
-	}
-}
-
-#ifdef CONFIG_SMP
-
-/*
- * These macros iterate all files on all CPUs for a given superblock.
- * files_lglock must be held globally.
- */
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	int i;							\
-	for_each_possible_cpu(i) {				\
-		struct list_head *list;				\
-		list = per_cpu_ptr((__sb)->s_files, i);		\
-		list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-	}							\
-}
-
-#else
-
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	struct list_head *list;					\
-	list = &(sb)->s_files;					\
-	list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-}
-
-#endif
-
-/**
- *	mark_files_ro - mark all files read-only
- *	@sb: superblock in question
- *
- *	All files are marked read-only.  We don't care about pending
- *	delete files so this should be used in 'force' mode only.
- */
-void mark_files_ro(struct super_block *sb)
-{
-	struct file *f;
-
-	lg_global_lock(&files_lglock);
-	do_file_list_for_each_entry(sb, f) {
-		if (!file_count(f))
-			continue;
-		if (!(f->f_mode & FMODE_WRITE))
-			continue;
-		spin_lock(&f->f_lock);
-		f->f_mode &= ~FMODE_WRITE;
-		spin_unlock(&f->f_lock);
-		if (file_check_writeable(f) != 0)
-			continue;
-		__mnt_drop_write(f->f_path.mnt);
-		file_release_write(f);
-	} while_file_list_for_each_entry;
-	lg_global_unlock(&files_lglock);
-}
-
 void __init files_init(unsigned long mempages)
 { 
 	unsigned long n;
@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)
 	n = (mempages * (PAGE_SIZE / 1024)) / 10;
 	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
 	files_defer_init();
-	lg_lock_init(&files_lglock, ""files_lglock"");
 	percpu_counter_init(&nr_files, 0);
 } ",linux,eee5cc2702929fd41cce28058dc6d6717f723f87,8b61e74ffc6310e1d35a9b51c8463093851f8bcf,1,"void file_sb_list_del(struct file *file)
//flaw_line_below:
{
//flaw_line_below:
	if (!list_empty(&file->f_u.fu_list)) {
//flaw_line_below:
		lg_local_lock_cpu(&files_lglock, file_list_cpu(file));
//flaw_line_below:
		list_del_init(&file->f_u.fu_list);
//flaw_line_below:
		lg_local_unlock_cpu(&files_lglock, file_list_cpu(file));
//flaw_line_below:
	}
//flaw_line_below:
}
"
2236,179972,,Local,Not required,Complete,CVE-2014-8172,https://www.cvedetails.com/cve/CVE-2014-8172/,CWE-17,Low,,,,2015-03-16,4.9,"The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations.",2015-03-23,DoS ,0,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,eee5cc2702929fd41cce28058dc6d6717f723f87,"get rid of s_files and files_lock

The only thing we need it for is alt-sysrq-r (emergency remount r/o)
and these days we can do just as well without going through the
list of files.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",1,fs/file_table.c,"{""sha"": ""23b6dca03ba06f4da0553b1db70f6911098382fc"", ""filename"": ""fs/file_table.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 125, ""changes"": 125, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/file_table.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {\n \t.max_files = NR_FILE\n };\n \n-DEFINE_STATIC_LGLOCK(files_lglock);\n-\n /* SLAB cache for file structures */\n static struct kmem_cache *filp_cachep __read_mostly;\n \n@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)\n \t\treturn ERR_PTR(error);\n \t}\n \n-\tINIT_LIST_HEAD(&f->f_u.fu_list);\n \tatomic_long_set(&f->f_count, 1);\n \trwlock_init(&f->f_owner.lock);\n \tspin_lock_init(&f->f_lock);\n@@ -304,7 +301,6 @@ void fput(struct file *file)\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n \n-\t\tfile_sb_list_del(file);\n \t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n \t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n \t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n-\t\tfile_sb_list_del(file);\n \t\tBUG_ON(!(task->flags & PF_KTHREAD));\n \t\t__fput(file);\n \t}\n@@ -345,129 +340,10 @@ void put_filp(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tsecurity_file_free(file);\n-\t\tfile_sb_list_del(file);\n \t\tfile_free(file);\n \t}\n }\n \n-static inline int file_list_cpu(struct file *file)\n-{\n-#ifdef CONFIG_SMP\n-\treturn file->f_sb_list_cpu;\n-#else\n-\treturn smp_processor_id();\n-#endif\n-}\n-\n-/* helper for file_sb_list_add to reduce ifdefs */\n-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tstruct list_head *list;\n-#ifdef CONFIG_SMP\n-\tint cpu;\n-\tcpu = smp_processor_id();\n-\tfile->f_sb_list_cpu = cpu;\n-\tlist = per_cpu_ptr(sb->s_files, cpu);\n-#else\n-\tlist = &sb->s_files;\n-#endif\n-\tlist_add(&file->f_u.fu_list, list);\n-}\n-\n-/**\n- * file_sb_list_add - add a file to the sb's file list\n- * @file: file to add\n- * @sb: sb to add it to\n- *\n- * Use this function to associate a file with the superblock of the inode it\n- * refers to.\n- */\n-void file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tif (likely(!(file->f_mode & FMODE_WRITE)))\n-\t\treturn;\n-\tif (!S_ISREG(file_inode(file)->i_mode))\n-\t\treturn;\n-\tlg_local_lock(&files_lglock);\n-\t__file_sb_list_add(file, sb);\n-\tlg_local_unlock(&files_lglock);\n-}\n-\n-/**\n- * file_sb_list_del - remove a file from the sb's file list\n- * @file: file to remove\n- * @sb: sb to remove it from\n- *\n- * Use this function to remove a file from its superblock.\n- */\n-void file_sb_list_del(struct file *file)\n-{\n-\tif (!list_empty(&file->f_u.fu_list)) {\n-\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n-\t\tlist_del_init(&file->f_u.fu_list);\n-\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n-\t}\n-}\n-\n-#ifdef CONFIG_SMP\n-\n-/*\n- * These macros iterate all files on all CPUs for a given superblock.\n- * files_lglock must be held globally.\n- */\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tint i;\t\t\t\t\t\t\t\\\n-\tfor_each_possible_cpu(i) {\t\t\t\t\\\n-\t\tstruct list_head *list;\t\t\t\t\\\n-\t\tlist = per_cpu_ptr((__sb)->s_files, i);\t\t\\\n-\t\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-}\n-\n-#else\n-\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tstruct list_head *list;\t\t\t\t\t\\\n-\tlist = &(sb)->s_files;\t\t\t\t\t\\\n-\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-}\n-\n-#endif\n-\n-/**\n- *\tmark_files_ro - mark all files read-only\n- *\t@sb: superblock in question\n- *\n- *\tAll files are marked read-only.  We don't care about pending\n- *\tdelete files so this should be used in 'force' mode only.\n- */\n-void mark_files_ro(struct super_block *sb)\n-{\n-\tstruct file *f;\n-\n-\tlg_global_lock(&files_lglock);\n-\tdo_file_list_for_each_entry(sb, f) {\n-\t\tif (!file_count(f))\n-\t\t\tcontinue;\n-\t\tif (!(f->f_mode & FMODE_WRITE))\n-\t\t\tcontinue;\n-\t\tspin_lock(&f->f_lock);\n-\t\tf->f_mode &= ~FMODE_WRITE;\n-\t\tspin_unlock(&f->f_lock);\n-\t\tif (file_check_writeable(f) != 0)\n-\t\t\tcontinue;\n-\t\t__mnt_drop_write(f->f_path.mnt);\n-\t\tfile_release_write(f);\n-\t} while_file_list_for_each_entry;\n-\tlg_global_unlock(&files_lglock);\n-}\n-\n void __init files_init(unsigned long mempages)\n { \n \tunsigned long n;\n@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)\n \tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n \tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n \tfiles_defer_init();\n-\tlg_lock_init(&files_lglock, \""files_lglock\"");\n \tpercpu_counter_init(&nr_files, 0);\n } ""}<_**next**_>{""sha"": ""4657424074668dcb933c8d375244b1d3b9d72561"", ""filename"": ""fs/internal.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/internal.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -73,9 +73,6 @@ extern void chroot_fs_refs(const struct path *, const struct path *);\n /*\n  * file_table.c\n  */\n-extern void file_sb_list_add(struct file *f, struct super_block *sb);\n-extern void file_sb_list_del(struct file *f);\n-extern void mark_files_ro(struct super_block *);\n extern struct file *get_empty_filp(void);\n \n /*""}<_**next**_>{""sha"": ""fffbed40dbe9e24dc6129878cf65527e241d4d48"", ""filename"": ""fs/open.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/open.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -685,7 +685,6 @@ static int do_dentry_open(struct file *f,\n \t}\n \n \tf->f_mapping = inode->i_mapping;\n-\tfile_sb_list_add(f, inode->i_sb);\n \n \tif (unlikely(f->f_mode & FMODE_PATH)) {\n \t\tf->f_op = &empty_fops;\n@@ -724,7 +723,6 @@ static int do_dentry_open(struct file *f,\n \n cleanup_all:\n \tfops_put(f->f_op);\n-\tfile_sb_list_del(f);\n \tif (f->f_mode & FMODE_WRITE) {\n \t\tput_write_access(inode);\n \t\tif (!special_file(inode->i_mode)) {""}<_**next**_>{""sha"": ""e5f6c2cfac380a7c4503dcebb0b3e310841893f0"", ""filename"": ""fs/super.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 13, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/super.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)\n \tint i;\n \tlist_lru_destroy(&s->s_dentry_lru);\n \tlist_lru_destroy(&s->s_inode_lru);\n-#ifdef CONFIG_SMP\n-\tfree_percpu(s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n \t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n \tsecurity_sb_free(s);\n@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)\n \tif (security_sb_alloc(s))\n \t\tgoto fail;\n \n-#ifdef CONFIG_SMP\n-\ts->s_files = alloc_percpu(struct list_head);\n-\tif (!s->s_files)\n-\t\tgoto fail;\n-\tfor_each_possible_cpu(i)\n-\t\tINIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));\n-#else\n-\tINIT_LIST_HEAD(&s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n \t\tif (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)\n \t\t\tgoto fail;\n@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n-\t\t\tmark_files_ro(sb);\n+\t\t\tsb->s_readonly_remount = 1;\n+\t\t\tsmp_wmb();\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)""}<_**next**_>{""sha"": ""2b0f4e974480c353a90654e634cc6f4a6d1293c4"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 13, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -764,12 +764,7 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n #define FILE_MNT_WRITE_RELEASED\t2\n \n struct file {\n-\t/*\n-\t * fu_list becomes invalid after file_free is called and queued via\n-\t * fu_rcuhead for RCU freeing\n-\t */\n \tunion {\n-\t\tstruct list_head\tfu_list;\n \t\tstruct llist_node\tfu_llist;\n \t\tstruct rcu_head \tfu_rcuhead;\n \t} f_u;\n@@ -783,9 +778,6 @@ struct file {\n \t * Must not be taken from IRQ context.\n \t */\n \tspinlock_t\t\tf_lock;\n-#ifdef CONFIG_SMP\n-\tint\t\t\tf_sb_list_cpu;\n-#endif\n \tatomic_long_t\t\tf_count;\n \tunsigned int \t\tf_flags;\n \tfmode_t\t\t\tf_mode;\n@@ -1264,11 +1256,6 @@ struct super_block {\n \n \tstruct list_head\ts_inodes;\t/* all inodes */\n \tstruct hlist_bl_head\ts_anon;\t\t/* anonymous dentries for (nfs) exporting */\n-#ifdef CONFIG_SMP\n-\tstruct list_head __percpu *s_files;\n-#else\n-\tstruct list_head\ts_files;\n-#endif\n \tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n \tstruct block_device\t*s_bdev;\n \tstruct backing_dev_info *s_bdi;""}"," void __init files_init(unsigned long mempages)
 { 
 	unsigned long n;

	filp_cachep = kmem_cache_create(""filp"", sizeof(struct file), 0,
			SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);

	/*
	 * One file with associated inode and dcache is very roughly 1K.
	 * Per default don't use more than 10% of our memory for files. 
	 */ 

 	n = (mempages * (PAGE_SIZE / 1024)) / 10;
 	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
 	files_defer_init();
 	percpu_counter_init(&nr_files, 0);
 } 
"," void __init files_init(unsigned long mempages)
 { 
 	unsigned long n;

	filp_cachep = kmem_cache_create(""filp"", sizeof(struct file), 0,
			SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);

	/*
	 * One file with associated inode and dcache is very roughly 1K.
	 * Per default don't use more than 10% of our memory for files. 
	 */ 

 	n = (mempages * (PAGE_SIZE / 1024)) / 10;
 	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
 	files_defer_init();
	lg_lock_init(&files_lglock, ""files_lglock"");
 	percpu_counter_init(&nr_files, 0);
 } 
",C,,"	lg_lock_init(&files_lglock, ""files_lglock"");
",,"@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {
 	.max_files = NR_FILE
 };
 
-DEFINE_STATIC_LGLOCK(files_lglock);
-
 /* SLAB cache for file structures */
 static struct kmem_cache *filp_cachep __read_mostly;
 
@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)
 		return ERR_PTR(error);
 	}
 
-	INIT_LIST_HEAD(&f->f_u.fu_list);
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
@@ -304,7 +301,6 @@ void fput(struct file *file)
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
 
-		file_sb_list_del(file);
 		if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {
 			init_task_work(&file->f_u.fu_rcuhead, ____fput);
 			if (!task_work_add(task, &file->f_u.fu_rcuhead, true))
@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
-		file_sb_list_del(file);
 		BUG_ON(!(task->flags & PF_KTHREAD));
 		__fput(file);
 	}
@@ -345,129 +340,10 @@ void put_filp(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		security_file_free(file);
-		file_sb_list_del(file);
 		file_free(file);
 	}
 }
 
-static inline int file_list_cpu(struct file *file)
-{
-#ifdef CONFIG_SMP
-	return file->f_sb_list_cpu;
-#else
-	return smp_processor_id();
-#endif
-}
-
-/* helper for file_sb_list_add to reduce ifdefs */
-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	struct list_head *list;
-#ifdef CONFIG_SMP
-	int cpu;
-	cpu = smp_processor_id();
-	file->f_sb_list_cpu = cpu;
-	list = per_cpu_ptr(sb->s_files, cpu);
-#else
-	list = &sb->s_files;
-#endif
-	list_add(&file->f_u.fu_list, list);
-}
-
-/**
- * file_sb_list_add - add a file to the sb's file list
- * @file: file to add
- * @sb: sb to add it to
- *
- * Use this function to associate a file with the superblock of the inode it
- * refers to.
- */
-void file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	if (likely(!(file->f_mode & FMODE_WRITE)))
-		return;
-	if (!S_ISREG(file_inode(file)->i_mode))
-		return;
-	lg_local_lock(&files_lglock);
-	__file_sb_list_add(file, sb);
-	lg_local_unlock(&files_lglock);
-}
-
-/**
- * file_sb_list_del - remove a file from the sb's file list
- * @file: file to remove
- * @sb: sb to remove it from
- *
- * Use this function to remove a file from its superblock.
- */
-void file_sb_list_del(struct file *file)
-{
-	if (!list_empty(&file->f_u.fu_list)) {
-		lg_local_lock_cpu(&files_lglock, file_list_cpu(file));
-		list_del_init(&file->f_u.fu_list);
-		lg_local_unlock_cpu(&files_lglock, file_list_cpu(file));
-	}
-}
-
-#ifdef CONFIG_SMP
-
-/*
- * These macros iterate all files on all CPUs for a given superblock.
- * files_lglock must be held globally.
- */
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	int i;							\
-	for_each_possible_cpu(i) {				\
-		struct list_head *list;				\
-		list = per_cpu_ptr((__sb)->s_files, i);		\
-		list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-	}							\
-}
-
-#else
-
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	struct list_head *list;					\
-	list = &(sb)->s_files;					\
-	list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-}
-
-#endif
-
-/**
- *	mark_files_ro - mark all files read-only
- *	@sb: superblock in question
- *
- *	All files are marked read-only.  We don't care about pending
- *	delete files so this should be used in 'force' mode only.
- */
-void mark_files_ro(struct super_block *sb)
-{
-	struct file *f;
-
-	lg_global_lock(&files_lglock);
-	do_file_list_for_each_entry(sb, f) {
-		if (!file_count(f))
-			continue;
-		if (!(f->f_mode & FMODE_WRITE))
-			continue;
-		spin_lock(&f->f_lock);
-		f->f_mode &= ~FMODE_WRITE;
-		spin_unlock(&f->f_lock);
-		if (file_check_writeable(f) != 0)
-			continue;
-		__mnt_drop_write(f->f_path.mnt);
-		file_release_write(f);
-	} while_file_list_for_each_entry;
-	lg_global_unlock(&files_lglock);
-}
-
 void __init files_init(unsigned long mempages)
 { 
 	unsigned long n;
@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)
 	n = (mempages * (PAGE_SIZE / 1024)) / 10;
 	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
 	files_defer_init();
-	lg_lock_init(&files_lglock, ""files_lglock"");
 	percpu_counter_init(&nr_files, 0);
 } ",linux,eee5cc2702929fd41cce28058dc6d6717f723f87,8b61e74ffc6310e1d35a9b51c8463093851f8bcf,1," void __init files_init(unsigned long mempages)
 { 
 	unsigned long n;

	filp_cachep = kmem_cache_create(""filp"", sizeof(struct file), 0,
			SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);

	/*
	 * One file with associated inode and dcache is very roughly 1K.
	 * Per default don't use more than 10% of our memory for files. 
	 */ 

 	n = (mempages * (PAGE_SIZE / 1024)) / 10;
 	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
 	files_defer_init();
//flaw_line_below:
	lg_lock_init(&files_lglock, ""files_lglock"");
 	percpu_counter_init(&nr_files, 0);
 } 
"
2237,179973,,Local,Not required,Complete,CVE-2014-8172,https://www.cvedetails.com/cve/CVE-2014-8172/,CWE-17,Low,,,,2015-03-16,4.9,"The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations.",2015-03-23,DoS ,0,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,eee5cc2702929fd41cce28058dc6d6717f723f87,"get rid of s_files and files_lock

The only thing we need it for is alt-sysrq-r (emergency remount r/o)
and these days we can do just as well without going through the
list of files.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",1,fs/file_table.c,"{""sha"": ""23b6dca03ba06f4da0553b1db70f6911098382fc"", ""filename"": ""fs/file_table.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 125, ""changes"": 125, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/file_table.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {\n \t.max_files = NR_FILE\n };\n \n-DEFINE_STATIC_LGLOCK(files_lglock);\n-\n /* SLAB cache for file structures */\n static struct kmem_cache *filp_cachep __read_mostly;\n \n@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)\n \t\treturn ERR_PTR(error);\n \t}\n \n-\tINIT_LIST_HEAD(&f->f_u.fu_list);\n \tatomic_long_set(&f->f_count, 1);\n \trwlock_init(&f->f_owner.lock);\n \tspin_lock_init(&f->f_lock);\n@@ -304,7 +301,6 @@ void fput(struct file *file)\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n \n-\t\tfile_sb_list_del(file);\n \t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n \t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n \t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n-\t\tfile_sb_list_del(file);\n \t\tBUG_ON(!(task->flags & PF_KTHREAD));\n \t\t__fput(file);\n \t}\n@@ -345,129 +340,10 @@ void put_filp(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tsecurity_file_free(file);\n-\t\tfile_sb_list_del(file);\n \t\tfile_free(file);\n \t}\n }\n \n-static inline int file_list_cpu(struct file *file)\n-{\n-#ifdef CONFIG_SMP\n-\treturn file->f_sb_list_cpu;\n-#else\n-\treturn smp_processor_id();\n-#endif\n-}\n-\n-/* helper for file_sb_list_add to reduce ifdefs */\n-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tstruct list_head *list;\n-#ifdef CONFIG_SMP\n-\tint cpu;\n-\tcpu = smp_processor_id();\n-\tfile->f_sb_list_cpu = cpu;\n-\tlist = per_cpu_ptr(sb->s_files, cpu);\n-#else\n-\tlist = &sb->s_files;\n-#endif\n-\tlist_add(&file->f_u.fu_list, list);\n-}\n-\n-/**\n- * file_sb_list_add - add a file to the sb's file list\n- * @file: file to add\n- * @sb: sb to add it to\n- *\n- * Use this function to associate a file with the superblock of the inode it\n- * refers to.\n- */\n-void file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tif (likely(!(file->f_mode & FMODE_WRITE)))\n-\t\treturn;\n-\tif (!S_ISREG(file_inode(file)->i_mode))\n-\t\treturn;\n-\tlg_local_lock(&files_lglock);\n-\t__file_sb_list_add(file, sb);\n-\tlg_local_unlock(&files_lglock);\n-}\n-\n-/**\n- * file_sb_list_del - remove a file from the sb's file list\n- * @file: file to remove\n- * @sb: sb to remove it from\n- *\n- * Use this function to remove a file from its superblock.\n- */\n-void file_sb_list_del(struct file *file)\n-{\n-\tif (!list_empty(&file->f_u.fu_list)) {\n-\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n-\t\tlist_del_init(&file->f_u.fu_list);\n-\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n-\t}\n-}\n-\n-#ifdef CONFIG_SMP\n-\n-/*\n- * These macros iterate all files on all CPUs for a given superblock.\n- * files_lglock must be held globally.\n- */\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tint i;\t\t\t\t\t\t\t\\\n-\tfor_each_possible_cpu(i) {\t\t\t\t\\\n-\t\tstruct list_head *list;\t\t\t\t\\\n-\t\tlist = per_cpu_ptr((__sb)->s_files, i);\t\t\\\n-\t\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-}\n-\n-#else\n-\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tstruct list_head *list;\t\t\t\t\t\\\n-\tlist = &(sb)->s_files;\t\t\t\t\t\\\n-\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-}\n-\n-#endif\n-\n-/**\n- *\tmark_files_ro - mark all files read-only\n- *\t@sb: superblock in question\n- *\n- *\tAll files are marked read-only.  We don't care about pending\n- *\tdelete files so this should be used in 'force' mode only.\n- */\n-void mark_files_ro(struct super_block *sb)\n-{\n-\tstruct file *f;\n-\n-\tlg_global_lock(&files_lglock);\n-\tdo_file_list_for_each_entry(sb, f) {\n-\t\tif (!file_count(f))\n-\t\t\tcontinue;\n-\t\tif (!(f->f_mode & FMODE_WRITE))\n-\t\t\tcontinue;\n-\t\tspin_lock(&f->f_lock);\n-\t\tf->f_mode &= ~FMODE_WRITE;\n-\t\tspin_unlock(&f->f_lock);\n-\t\tif (file_check_writeable(f) != 0)\n-\t\t\tcontinue;\n-\t\t__mnt_drop_write(f->f_path.mnt);\n-\t\tfile_release_write(f);\n-\t} while_file_list_for_each_entry;\n-\tlg_global_unlock(&files_lglock);\n-}\n-\n void __init files_init(unsigned long mempages)\n { \n \tunsigned long n;\n@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)\n \tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n \tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n \tfiles_defer_init();\n-\tlg_lock_init(&files_lglock, \""files_lglock\"");\n \tpercpu_counter_init(&nr_files, 0);\n } ""}<_**next**_>{""sha"": ""4657424074668dcb933c8d375244b1d3b9d72561"", ""filename"": ""fs/internal.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/internal.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -73,9 +73,6 @@ extern void chroot_fs_refs(const struct path *, const struct path *);\n /*\n  * file_table.c\n  */\n-extern void file_sb_list_add(struct file *f, struct super_block *sb);\n-extern void file_sb_list_del(struct file *f);\n-extern void mark_files_ro(struct super_block *);\n extern struct file *get_empty_filp(void);\n \n /*""}<_**next**_>{""sha"": ""fffbed40dbe9e24dc6129878cf65527e241d4d48"", ""filename"": ""fs/open.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/open.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -685,7 +685,6 @@ static int do_dentry_open(struct file *f,\n \t}\n \n \tf->f_mapping = inode->i_mapping;\n-\tfile_sb_list_add(f, inode->i_sb);\n \n \tif (unlikely(f->f_mode & FMODE_PATH)) {\n \t\tf->f_op = &empty_fops;\n@@ -724,7 +723,6 @@ static int do_dentry_open(struct file *f,\n \n cleanup_all:\n \tfops_put(f->f_op);\n-\tfile_sb_list_del(f);\n \tif (f->f_mode & FMODE_WRITE) {\n \t\tput_write_access(inode);\n \t\tif (!special_file(inode->i_mode)) {""}<_**next**_>{""sha"": ""e5f6c2cfac380a7c4503dcebb0b3e310841893f0"", ""filename"": ""fs/super.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 13, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/super.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)\n \tint i;\n \tlist_lru_destroy(&s->s_dentry_lru);\n \tlist_lru_destroy(&s->s_inode_lru);\n-#ifdef CONFIG_SMP\n-\tfree_percpu(s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n \t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n \tsecurity_sb_free(s);\n@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)\n \tif (security_sb_alloc(s))\n \t\tgoto fail;\n \n-#ifdef CONFIG_SMP\n-\ts->s_files = alloc_percpu(struct list_head);\n-\tif (!s->s_files)\n-\t\tgoto fail;\n-\tfor_each_possible_cpu(i)\n-\t\tINIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));\n-#else\n-\tINIT_LIST_HEAD(&s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n \t\tif (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)\n \t\t\tgoto fail;\n@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n-\t\t\tmark_files_ro(sb);\n+\t\t\tsb->s_readonly_remount = 1;\n+\t\t\tsmp_wmb();\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)""}<_**next**_>{""sha"": ""2b0f4e974480c353a90654e634cc6f4a6d1293c4"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 13, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -764,12 +764,7 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n #define FILE_MNT_WRITE_RELEASED\t2\n \n struct file {\n-\t/*\n-\t * fu_list becomes invalid after file_free is called and queued via\n-\t * fu_rcuhead for RCU freeing\n-\t */\n \tunion {\n-\t\tstruct list_head\tfu_list;\n \t\tstruct llist_node\tfu_llist;\n \t\tstruct rcu_head \tfu_rcuhead;\n \t} f_u;\n@@ -783,9 +778,6 @@ struct file {\n \t * Must not be taken from IRQ context.\n \t */\n \tspinlock_t\t\tf_lock;\n-#ifdef CONFIG_SMP\n-\tint\t\t\tf_sb_list_cpu;\n-#endif\n \tatomic_long_t\t\tf_count;\n \tunsigned int \t\tf_flags;\n \tfmode_t\t\t\tf_mode;\n@@ -1264,11 +1256,6 @@ struct super_block {\n \n \tstruct list_head\ts_inodes;\t/* all inodes */\n \tstruct hlist_bl_head\ts_anon;\t\t/* anonymous dentries for (nfs) exporting */\n-#ifdef CONFIG_SMP\n-\tstruct list_head __percpu *s_files;\n-#else\n-\tstruct list_head\ts_files;\n-#endif\n \tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n \tstruct block_device\t*s_bdev;\n \tstruct backing_dev_info *s_bdi;""}","void fput(struct file *file)
{
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
 
 		if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {
 			init_task_work(&file->f_u.fu_rcuhead, ____fput);
 			if (!task_work_add(task, &file->f_u.fu_rcuhead, true))
				return;
			/*
			 * After this task has run exit_task_work(),
			 * task_work_add() will fail.  Fall through to delayed
			 * fput to avoid leaking *file.
			 */
		}

		if (llist_add(&file->f_u.fu_llist, &delayed_fput_list))
			schedule_work(&delayed_fput_work);
	}
}
","void fput(struct file *file)
{
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
 
		file_sb_list_del(file);
 		if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {
 			init_task_work(&file->f_u.fu_rcuhead, ____fput);
 			if (!task_work_add(task, &file->f_u.fu_rcuhead, true))
				return;
			/*
			 * After this task has run exit_task_work(),
			 * task_work_add() will fail.  Fall through to delayed
			 * fput to avoid leaking *file.
			 */
		}

		if (llist_add(&file->f_u.fu_llist, &delayed_fput_list))
			schedule_work(&delayed_fput_work);
	}
}
",C,,"		file_sb_list_del(file);
",,"@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {
 	.max_files = NR_FILE
 };
 
-DEFINE_STATIC_LGLOCK(files_lglock);
-
 /* SLAB cache for file structures */
 static struct kmem_cache *filp_cachep __read_mostly;
 
@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)
 		return ERR_PTR(error);
 	}
 
-	INIT_LIST_HEAD(&f->f_u.fu_list);
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
@@ -304,7 +301,6 @@ void fput(struct file *file)
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
 
-		file_sb_list_del(file);
 		if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {
 			init_task_work(&file->f_u.fu_rcuhead, ____fput);
 			if (!task_work_add(task, &file->f_u.fu_rcuhead, true))
@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
-		file_sb_list_del(file);
 		BUG_ON(!(task->flags & PF_KTHREAD));
 		__fput(file);
 	}
@@ -345,129 +340,10 @@ void put_filp(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		security_file_free(file);
-		file_sb_list_del(file);
 		file_free(file);
 	}
 }
 
-static inline int file_list_cpu(struct file *file)
-{
-#ifdef CONFIG_SMP
-	return file->f_sb_list_cpu;
-#else
-	return smp_processor_id();
-#endif
-}
-
-/* helper for file_sb_list_add to reduce ifdefs */
-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	struct list_head *list;
-#ifdef CONFIG_SMP
-	int cpu;
-	cpu = smp_processor_id();
-	file->f_sb_list_cpu = cpu;
-	list = per_cpu_ptr(sb->s_files, cpu);
-#else
-	list = &sb->s_files;
-#endif
-	list_add(&file->f_u.fu_list, list);
-}
-
-/**
- * file_sb_list_add - add a file to the sb's file list
- * @file: file to add
- * @sb: sb to add it to
- *
- * Use this function to associate a file with the superblock of the inode it
- * refers to.
- */
-void file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	if (likely(!(file->f_mode & FMODE_WRITE)))
-		return;
-	if (!S_ISREG(file_inode(file)->i_mode))
-		return;
-	lg_local_lock(&files_lglock);
-	__file_sb_list_add(file, sb);
-	lg_local_unlock(&files_lglock);
-}
-
-/**
- * file_sb_list_del - remove a file from the sb's file list
- * @file: file to remove
- * @sb: sb to remove it from
- *
- * Use this function to remove a file from its superblock.
- */
-void file_sb_list_del(struct file *file)
-{
-	if (!list_empty(&file->f_u.fu_list)) {
-		lg_local_lock_cpu(&files_lglock, file_list_cpu(file));
-		list_del_init(&file->f_u.fu_list);
-		lg_local_unlock_cpu(&files_lglock, file_list_cpu(file));
-	}
-}
-
-#ifdef CONFIG_SMP
-
-/*
- * These macros iterate all files on all CPUs for a given superblock.
- * files_lglock must be held globally.
- */
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	int i;							\
-	for_each_possible_cpu(i) {				\
-		struct list_head *list;				\
-		list = per_cpu_ptr((__sb)->s_files, i);		\
-		list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-	}							\
-}
-
-#else
-
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	struct list_head *list;					\
-	list = &(sb)->s_files;					\
-	list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-}
-
-#endif
-
-/**
- *	mark_files_ro - mark all files read-only
- *	@sb: superblock in question
- *
- *	All files are marked read-only.  We don't care about pending
- *	delete files so this should be used in 'force' mode only.
- */
-void mark_files_ro(struct super_block *sb)
-{
-	struct file *f;
-
-	lg_global_lock(&files_lglock);
-	do_file_list_for_each_entry(sb, f) {
-		if (!file_count(f))
-			continue;
-		if (!(f->f_mode & FMODE_WRITE))
-			continue;
-		spin_lock(&f->f_lock);
-		f->f_mode &= ~FMODE_WRITE;
-		spin_unlock(&f->f_lock);
-		if (file_check_writeable(f) != 0)
-			continue;
-		__mnt_drop_write(f->f_path.mnt);
-		file_release_write(f);
-	} while_file_list_for_each_entry;
-	lg_global_unlock(&files_lglock);
-}
-
 void __init files_init(unsigned long mempages)
 { 
 	unsigned long n;
@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)
 	n = (mempages * (PAGE_SIZE / 1024)) / 10;
 	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
 	files_defer_init();
-	lg_lock_init(&files_lglock, ""files_lglock"");
 	percpu_counter_init(&nr_files, 0);
 } ",linux,eee5cc2702929fd41cce28058dc6d6717f723f87,8b61e74ffc6310e1d35a9b51c8463093851f8bcf,1,"void fput(struct file *file)
{
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
 
//flaw_line_below:
		file_sb_list_del(file);
 		if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {
 			init_task_work(&file->f_u.fu_rcuhead, ____fput);
 			if (!task_work_add(task, &file->f_u.fu_rcuhead, true))
				return;
			/*
			 * After this task has run exit_task_work(),
			 * task_work_add() will fail.  Fall through to delayed
			 * fput to avoid leaking *file.
			 */
		}

		if (llist_add(&file->f_u.fu_llist, &delayed_fput_list))
			schedule_work(&delayed_fput_work);
	}
}
"
2238,179974,,Local,Not required,Complete,CVE-2014-8172,https://www.cvedetails.com/cve/CVE-2014-8172/,CWE-17,Low,,,,2015-03-16,4.9,"The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations.",2015-03-23,DoS ,0,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,eee5cc2702929fd41cce28058dc6d6717f723f87,"get rid of s_files and files_lock

The only thing we need it for is alt-sysrq-r (emergency remount r/o)
and these days we can do just as well without going through the
list of files.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",1,fs/file_table.c,"{""sha"": ""23b6dca03ba06f4da0553b1db70f6911098382fc"", ""filename"": ""fs/file_table.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 125, ""changes"": 125, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/file_table.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {\n \t.max_files = NR_FILE\n };\n \n-DEFINE_STATIC_LGLOCK(files_lglock);\n-\n /* SLAB cache for file structures */\n static struct kmem_cache *filp_cachep __read_mostly;\n \n@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)\n \t\treturn ERR_PTR(error);\n \t}\n \n-\tINIT_LIST_HEAD(&f->f_u.fu_list);\n \tatomic_long_set(&f->f_count, 1);\n \trwlock_init(&f->f_owner.lock);\n \tspin_lock_init(&f->f_lock);\n@@ -304,7 +301,6 @@ void fput(struct file *file)\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n \n-\t\tfile_sb_list_del(file);\n \t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n \t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n \t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n-\t\tfile_sb_list_del(file);\n \t\tBUG_ON(!(task->flags & PF_KTHREAD));\n \t\t__fput(file);\n \t}\n@@ -345,129 +340,10 @@ void put_filp(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tsecurity_file_free(file);\n-\t\tfile_sb_list_del(file);\n \t\tfile_free(file);\n \t}\n }\n \n-static inline int file_list_cpu(struct file *file)\n-{\n-#ifdef CONFIG_SMP\n-\treturn file->f_sb_list_cpu;\n-#else\n-\treturn smp_processor_id();\n-#endif\n-}\n-\n-/* helper for file_sb_list_add to reduce ifdefs */\n-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tstruct list_head *list;\n-#ifdef CONFIG_SMP\n-\tint cpu;\n-\tcpu = smp_processor_id();\n-\tfile->f_sb_list_cpu = cpu;\n-\tlist = per_cpu_ptr(sb->s_files, cpu);\n-#else\n-\tlist = &sb->s_files;\n-#endif\n-\tlist_add(&file->f_u.fu_list, list);\n-}\n-\n-/**\n- * file_sb_list_add - add a file to the sb's file list\n- * @file: file to add\n- * @sb: sb to add it to\n- *\n- * Use this function to associate a file with the superblock of the inode it\n- * refers to.\n- */\n-void file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tif (likely(!(file->f_mode & FMODE_WRITE)))\n-\t\treturn;\n-\tif (!S_ISREG(file_inode(file)->i_mode))\n-\t\treturn;\n-\tlg_local_lock(&files_lglock);\n-\t__file_sb_list_add(file, sb);\n-\tlg_local_unlock(&files_lglock);\n-}\n-\n-/**\n- * file_sb_list_del - remove a file from the sb's file list\n- * @file: file to remove\n- * @sb: sb to remove it from\n- *\n- * Use this function to remove a file from its superblock.\n- */\n-void file_sb_list_del(struct file *file)\n-{\n-\tif (!list_empty(&file->f_u.fu_list)) {\n-\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n-\t\tlist_del_init(&file->f_u.fu_list);\n-\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n-\t}\n-}\n-\n-#ifdef CONFIG_SMP\n-\n-/*\n- * These macros iterate all files on all CPUs for a given superblock.\n- * files_lglock must be held globally.\n- */\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tint i;\t\t\t\t\t\t\t\\\n-\tfor_each_possible_cpu(i) {\t\t\t\t\\\n-\t\tstruct list_head *list;\t\t\t\t\\\n-\t\tlist = per_cpu_ptr((__sb)->s_files, i);\t\t\\\n-\t\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-}\n-\n-#else\n-\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tstruct list_head *list;\t\t\t\t\t\\\n-\tlist = &(sb)->s_files;\t\t\t\t\t\\\n-\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-}\n-\n-#endif\n-\n-/**\n- *\tmark_files_ro - mark all files read-only\n- *\t@sb: superblock in question\n- *\n- *\tAll files are marked read-only.  We don't care about pending\n- *\tdelete files so this should be used in 'force' mode only.\n- */\n-void mark_files_ro(struct super_block *sb)\n-{\n-\tstruct file *f;\n-\n-\tlg_global_lock(&files_lglock);\n-\tdo_file_list_for_each_entry(sb, f) {\n-\t\tif (!file_count(f))\n-\t\t\tcontinue;\n-\t\tif (!(f->f_mode & FMODE_WRITE))\n-\t\t\tcontinue;\n-\t\tspin_lock(&f->f_lock);\n-\t\tf->f_mode &= ~FMODE_WRITE;\n-\t\tspin_unlock(&f->f_lock);\n-\t\tif (file_check_writeable(f) != 0)\n-\t\t\tcontinue;\n-\t\t__mnt_drop_write(f->f_path.mnt);\n-\t\tfile_release_write(f);\n-\t} while_file_list_for_each_entry;\n-\tlg_global_unlock(&files_lglock);\n-}\n-\n void __init files_init(unsigned long mempages)\n { \n \tunsigned long n;\n@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)\n \tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n \tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n \tfiles_defer_init();\n-\tlg_lock_init(&files_lglock, \""files_lglock\"");\n \tpercpu_counter_init(&nr_files, 0);\n } ""}<_**next**_>{""sha"": ""4657424074668dcb933c8d375244b1d3b9d72561"", ""filename"": ""fs/internal.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/internal.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -73,9 +73,6 @@ extern void chroot_fs_refs(const struct path *, const struct path *);\n /*\n  * file_table.c\n  */\n-extern void file_sb_list_add(struct file *f, struct super_block *sb);\n-extern void file_sb_list_del(struct file *f);\n-extern void mark_files_ro(struct super_block *);\n extern struct file *get_empty_filp(void);\n \n /*""}<_**next**_>{""sha"": ""fffbed40dbe9e24dc6129878cf65527e241d4d48"", ""filename"": ""fs/open.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/open.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -685,7 +685,6 @@ static int do_dentry_open(struct file *f,\n \t}\n \n \tf->f_mapping = inode->i_mapping;\n-\tfile_sb_list_add(f, inode->i_sb);\n \n \tif (unlikely(f->f_mode & FMODE_PATH)) {\n \t\tf->f_op = &empty_fops;\n@@ -724,7 +723,6 @@ static int do_dentry_open(struct file *f,\n \n cleanup_all:\n \tfops_put(f->f_op);\n-\tfile_sb_list_del(f);\n \tif (f->f_mode & FMODE_WRITE) {\n \t\tput_write_access(inode);\n \t\tif (!special_file(inode->i_mode)) {""}<_**next**_>{""sha"": ""e5f6c2cfac380a7c4503dcebb0b3e310841893f0"", ""filename"": ""fs/super.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 13, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/super.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)\n \tint i;\n \tlist_lru_destroy(&s->s_dentry_lru);\n \tlist_lru_destroy(&s->s_inode_lru);\n-#ifdef CONFIG_SMP\n-\tfree_percpu(s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n \t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n \tsecurity_sb_free(s);\n@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)\n \tif (security_sb_alloc(s))\n \t\tgoto fail;\n \n-#ifdef CONFIG_SMP\n-\ts->s_files = alloc_percpu(struct list_head);\n-\tif (!s->s_files)\n-\t\tgoto fail;\n-\tfor_each_possible_cpu(i)\n-\t\tINIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));\n-#else\n-\tINIT_LIST_HEAD(&s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n \t\tif (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)\n \t\t\tgoto fail;\n@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n-\t\t\tmark_files_ro(sb);\n+\t\t\tsb->s_readonly_remount = 1;\n+\t\t\tsmp_wmb();\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)""}<_**next**_>{""sha"": ""2b0f4e974480c353a90654e634cc6f4a6d1293c4"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 13, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -764,12 +764,7 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n #define FILE_MNT_WRITE_RELEASED\t2\n \n struct file {\n-\t/*\n-\t * fu_list becomes invalid after file_free is called and queued via\n-\t * fu_rcuhead for RCU freeing\n-\t */\n \tunion {\n-\t\tstruct list_head\tfu_list;\n \t\tstruct llist_node\tfu_llist;\n \t\tstruct rcu_head \tfu_rcuhead;\n \t} f_u;\n@@ -783,9 +778,6 @@ struct file {\n \t * Must not be taken from IRQ context.\n \t */\n \tspinlock_t\t\tf_lock;\n-#ifdef CONFIG_SMP\n-\tint\t\t\tf_sb_list_cpu;\n-#endif\n \tatomic_long_t\t\tf_count;\n \tunsigned int \t\tf_flags;\n \tfmode_t\t\t\tf_mode;\n@@ -1264,11 +1256,6 @@ struct super_block {\n \n \tstruct list_head\ts_inodes;\t/* all inodes */\n \tstruct hlist_bl_head\ts_anon;\t\t/* anonymous dentries for (nfs) exporting */\n-#ifdef CONFIG_SMP\n-\tstruct list_head __percpu *s_files;\n-#else\n-\tstruct list_head\ts_files;\n-#endif\n \tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n \tstruct block_device\t*s_bdev;\n \tstruct backing_dev_info *s_bdi;""}","struct file *get_empty_filp(void)
{
	const struct cred *cred = current_cred();
	static long old_max;
	struct file *f;
	int error;

	/*
	 * Privileged users can go above max_files
	 */
	if (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {
		/*
		 * percpu_counters are inaccurate.  Do an expensive check before
		 * we go and fail.
		 */
		if (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)
			goto over;
	}

	f = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);
	if (unlikely(!f))
		return ERR_PTR(-ENOMEM);

	percpu_counter_inc(&nr_files);
	f->f_cred = get_cred(cred);
	error = security_file_alloc(f);
	if (unlikely(error)) {
		file_free(f);
 		return ERR_PTR(error);
 	}
 
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
	eventpoll_init_file(f);
	/* f->f_version: 0 */
	return f;

over:
	/* Ran out of filps - report that */
	if (get_nr_files() > old_max) {
		pr_info(""VFS: file-max limit %lu reached\n"", get_max_files());
		old_max = get_nr_files();
	}
	return ERR_PTR(-ENFILE);
}
","struct file *get_empty_filp(void)
{
	const struct cred *cred = current_cred();
	static long old_max;
	struct file *f;
	int error;

	/*
	 * Privileged users can go above max_files
	 */
	if (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {
		/*
		 * percpu_counters are inaccurate.  Do an expensive check before
		 * we go and fail.
		 */
		if (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)
			goto over;
	}

	f = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);
	if (unlikely(!f))
		return ERR_PTR(-ENOMEM);

	percpu_counter_inc(&nr_files);
	f->f_cred = get_cred(cred);
	error = security_file_alloc(f);
	if (unlikely(error)) {
		file_free(f);
 		return ERR_PTR(error);
 	}
 
	INIT_LIST_HEAD(&f->f_u.fu_list);
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
	eventpoll_init_file(f);
	/* f->f_version: 0 */
	return f;

over:
	/* Ran out of filps - report that */
	if (get_nr_files() > old_max) {
		pr_info(""VFS: file-max limit %lu reached\n"", get_max_files());
		old_max = get_nr_files();
	}
	return ERR_PTR(-ENFILE);
}
",C,,"	INIT_LIST_HEAD(&f->f_u.fu_list);
",,"@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {
 	.max_files = NR_FILE
 };
 
-DEFINE_STATIC_LGLOCK(files_lglock);
-
 /* SLAB cache for file structures */
 static struct kmem_cache *filp_cachep __read_mostly;
 
@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)
 		return ERR_PTR(error);
 	}
 
-	INIT_LIST_HEAD(&f->f_u.fu_list);
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
@@ -304,7 +301,6 @@ void fput(struct file *file)
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
 
-		file_sb_list_del(file);
 		if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {
 			init_task_work(&file->f_u.fu_rcuhead, ____fput);
 			if (!task_work_add(task, &file->f_u.fu_rcuhead, true))
@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
-		file_sb_list_del(file);
 		BUG_ON(!(task->flags & PF_KTHREAD));
 		__fput(file);
 	}
@@ -345,129 +340,10 @@ void put_filp(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		security_file_free(file);
-		file_sb_list_del(file);
 		file_free(file);
 	}
 }
 
-static inline int file_list_cpu(struct file *file)
-{
-#ifdef CONFIG_SMP
-	return file->f_sb_list_cpu;
-#else
-	return smp_processor_id();
-#endif
-}
-
-/* helper for file_sb_list_add to reduce ifdefs */
-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	struct list_head *list;
-#ifdef CONFIG_SMP
-	int cpu;
-	cpu = smp_processor_id();
-	file->f_sb_list_cpu = cpu;
-	list = per_cpu_ptr(sb->s_files, cpu);
-#else
-	list = &sb->s_files;
-#endif
-	list_add(&file->f_u.fu_list, list);
-}
-
-/**
- * file_sb_list_add - add a file to the sb's file list
- * @file: file to add
- * @sb: sb to add it to
- *
- * Use this function to associate a file with the superblock of the inode it
- * refers to.
- */
-void file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	if (likely(!(file->f_mode & FMODE_WRITE)))
-		return;
-	if (!S_ISREG(file_inode(file)->i_mode))
-		return;
-	lg_local_lock(&files_lglock);
-	__file_sb_list_add(file, sb);
-	lg_local_unlock(&files_lglock);
-}
-
-/**
- * file_sb_list_del - remove a file from the sb's file list
- * @file: file to remove
- * @sb: sb to remove it from
- *
- * Use this function to remove a file from its superblock.
- */
-void file_sb_list_del(struct file *file)
-{
-	if (!list_empty(&file->f_u.fu_list)) {
-		lg_local_lock_cpu(&files_lglock, file_list_cpu(file));
-		list_del_init(&file->f_u.fu_list);
-		lg_local_unlock_cpu(&files_lglock, file_list_cpu(file));
-	}
-}
-
-#ifdef CONFIG_SMP
-
-/*
- * These macros iterate all files on all CPUs for a given superblock.
- * files_lglock must be held globally.
- */
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	int i;							\
-	for_each_possible_cpu(i) {				\
-		struct list_head *list;				\
-		list = per_cpu_ptr((__sb)->s_files, i);		\
-		list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-	}							\
-}
-
-#else
-
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	struct list_head *list;					\
-	list = &(sb)->s_files;					\
-	list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-}
-
-#endif
-
-/**
- *	mark_files_ro - mark all files read-only
- *	@sb: superblock in question
- *
- *	All files are marked read-only.  We don't care about pending
- *	delete files so this should be used in 'force' mode only.
- */
-void mark_files_ro(struct super_block *sb)
-{
-	struct file *f;
-
-	lg_global_lock(&files_lglock);
-	do_file_list_for_each_entry(sb, f) {
-		if (!file_count(f))
-			continue;
-		if (!(f->f_mode & FMODE_WRITE))
-			continue;
-		spin_lock(&f->f_lock);
-		f->f_mode &= ~FMODE_WRITE;
-		spin_unlock(&f->f_lock);
-		if (file_check_writeable(f) != 0)
-			continue;
-		__mnt_drop_write(f->f_path.mnt);
-		file_release_write(f);
-	} while_file_list_for_each_entry;
-	lg_global_unlock(&files_lglock);
-}
-
 void __init files_init(unsigned long mempages)
 { 
 	unsigned long n;
@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)
 	n = (mempages * (PAGE_SIZE / 1024)) / 10;
 	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
 	files_defer_init();
-	lg_lock_init(&files_lglock, ""files_lglock"");
 	percpu_counter_init(&nr_files, 0);
 } ",linux,eee5cc2702929fd41cce28058dc6d6717f723f87,8b61e74ffc6310e1d35a9b51c8463093851f8bcf,1,"struct file *get_empty_filp(void)
{
	const struct cred *cred = current_cred();
	static long old_max;
	struct file *f;
	int error;

	/*
	 * Privileged users can go above max_files
	 */
	if (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {
		/*
		 * percpu_counters are inaccurate.  Do an expensive check before
		 * we go and fail.
		 */
		if (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)
			goto over;
	}

	f = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);
	if (unlikely(!f))
		return ERR_PTR(-ENOMEM);

	percpu_counter_inc(&nr_files);
	f->f_cred = get_cred(cred);
	error = security_file_alloc(f);
	if (unlikely(error)) {
		file_free(f);
 		return ERR_PTR(error);
 	}
 
//flaw_line_below:
	INIT_LIST_HEAD(&f->f_u.fu_list);
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
	eventpoll_init_file(f);
	/* f->f_version: 0 */
	return f;

over:
	/* Ran out of filps - report that */
	if (get_nr_files() > old_max) {
		pr_info(""VFS: file-max limit %lu reached\n"", get_max_files());
		old_max = get_nr_files();
	}
	return ERR_PTR(-ENFILE);
}
"
2239,179975,,Local,Not required,Complete,CVE-2014-8172,https://www.cvedetails.com/cve/CVE-2014-8172/,CWE-17,Low,,,,2015-03-16,4.9,"The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations.",2015-03-23,DoS ,0,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,eee5cc2702929fd41cce28058dc6d6717f723f87,"get rid of s_files and files_lock

The only thing we need it for is alt-sysrq-r (emergency remount r/o)
and these days we can do just as well without going through the
list of files.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",18,fs/file_table.c,"{""sha"": ""23b6dca03ba06f4da0553b1db70f6911098382fc"", ""filename"": ""fs/file_table.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 125, ""changes"": 125, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/file_table.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {\n \t.max_files = NR_FILE\n };\n \n-DEFINE_STATIC_LGLOCK(files_lglock);\n-\n /* SLAB cache for file structures */\n static struct kmem_cache *filp_cachep __read_mostly;\n \n@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)\n \t\treturn ERR_PTR(error);\n \t}\n \n-\tINIT_LIST_HEAD(&f->f_u.fu_list);\n \tatomic_long_set(&f->f_count, 1);\n \trwlock_init(&f->f_owner.lock);\n \tspin_lock_init(&f->f_lock);\n@@ -304,7 +301,6 @@ void fput(struct file *file)\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n \n-\t\tfile_sb_list_del(file);\n \t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n \t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n \t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n-\t\tfile_sb_list_del(file);\n \t\tBUG_ON(!(task->flags & PF_KTHREAD));\n \t\t__fput(file);\n \t}\n@@ -345,129 +340,10 @@ void put_filp(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tsecurity_file_free(file);\n-\t\tfile_sb_list_del(file);\n \t\tfile_free(file);\n \t}\n }\n \n-static inline int file_list_cpu(struct file *file)\n-{\n-#ifdef CONFIG_SMP\n-\treturn file->f_sb_list_cpu;\n-#else\n-\treturn smp_processor_id();\n-#endif\n-}\n-\n-/* helper for file_sb_list_add to reduce ifdefs */\n-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tstruct list_head *list;\n-#ifdef CONFIG_SMP\n-\tint cpu;\n-\tcpu = smp_processor_id();\n-\tfile->f_sb_list_cpu = cpu;\n-\tlist = per_cpu_ptr(sb->s_files, cpu);\n-#else\n-\tlist = &sb->s_files;\n-#endif\n-\tlist_add(&file->f_u.fu_list, list);\n-}\n-\n-/**\n- * file_sb_list_add - add a file to the sb's file list\n- * @file: file to add\n- * @sb: sb to add it to\n- *\n- * Use this function to associate a file with the superblock of the inode it\n- * refers to.\n- */\n-void file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tif (likely(!(file->f_mode & FMODE_WRITE)))\n-\t\treturn;\n-\tif (!S_ISREG(file_inode(file)->i_mode))\n-\t\treturn;\n-\tlg_local_lock(&files_lglock);\n-\t__file_sb_list_add(file, sb);\n-\tlg_local_unlock(&files_lglock);\n-}\n-\n-/**\n- * file_sb_list_del - remove a file from the sb's file list\n- * @file: file to remove\n- * @sb: sb to remove it from\n- *\n- * Use this function to remove a file from its superblock.\n- */\n-void file_sb_list_del(struct file *file)\n-{\n-\tif (!list_empty(&file->f_u.fu_list)) {\n-\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n-\t\tlist_del_init(&file->f_u.fu_list);\n-\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n-\t}\n-}\n-\n-#ifdef CONFIG_SMP\n-\n-/*\n- * These macros iterate all files on all CPUs for a given superblock.\n- * files_lglock must be held globally.\n- */\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tint i;\t\t\t\t\t\t\t\\\n-\tfor_each_possible_cpu(i) {\t\t\t\t\\\n-\t\tstruct list_head *list;\t\t\t\t\\\n-\t\tlist = per_cpu_ptr((__sb)->s_files, i);\t\t\\\n-\t\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-}\n-\n-#else\n-\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tstruct list_head *list;\t\t\t\t\t\\\n-\tlist = &(sb)->s_files;\t\t\t\t\t\\\n-\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-}\n-\n-#endif\n-\n-/**\n- *\tmark_files_ro - mark all files read-only\n- *\t@sb: superblock in question\n- *\n- *\tAll files are marked read-only.  We don't care about pending\n- *\tdelete files so this should be used in 'force' mode only.\n- */\n-void mark_files_ro(struct super_block *sb)\n-{\n-\tstruct file *f;\n-\n-\tlg_global_lock(&files_lglock);\n-\tdo_file_list_for_each_entry(sb, f) {\n-\t\tif (!file_count(f))\n-\t\t\tcontinue;\n-\t\tif (!(f->f_mode & FMODE_WRITE))\n-\t\t\tcontinue;\n-\t\tspin_lock(&f->f_lock);\n-\t\tf->f_mode &= ~FMODE_WRITE;\n-\t\tspin_unlock(&f->f_lock);\n-\t\tif (file_check_writeable(f) != 0)\n-\t\t\tcontinue;\n-\t\t__mnt_drop_write(f->f_path.mnt);\n-\t\tfile_release_write(f);\n-\t} while_file_list_for_each_entry;\n-\tlg_global_unlock(&files_lglock);\n-}\n-\n void __init files_init(unsigned long mempages)\n { \n \tunsigned long n;\n@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)\n \tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n \tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n \tfiles_defer_init();\n-\tlg_lock_init(&files_lglock, \""files_lglock\"");\n \tpercpu_counter_init(&nr_files, 0);\n } ""}<_**next**_>{""sha"": ""4657424074668dcb933c8d375244b1d3b9d72561"", ""filename"": ""fs/internal.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/internal.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -73,9 +73,6 @@ extern void chroot_fs_refs(const struct path *, const struct path *);\n /*\n  * file_table.c\n  */\n-extern void file_sb_list_add(struct file *f, struct super_block *sb);\n-extern void file_sb_list_del(struct file *f);\n-extern void mark_files_ro(struct super_block *);\n extern struct file *get_empty_filp(void);\n \n /*""}<_**next**_>{""sha"": ""fffbed40dbe9e24dc6129878cf65527e241d4d48"", ""filename"": ""fs/open.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/open.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -685,7 +685,6 @@ static int do_dentry_open(struct file *f,\n \t}\n \n \tf->f_mapping = inode->i_mapping;\n-\tfile_sb_list_add(f, inode->i_sb);\n \n \tif (unlikely(f->f_mode & FMODE_PATH)) {\n \t\tf->f_op = &empty_fops;\n@@ -724,7 +723,6 @@ static int do_dentry_open(struct file *f,\n \n cleanup_all:\n \tfops_put(f->f_op);\n-\tfile_sb_list_del(f);\n \tif (f->f_mode & FMODE_WRITE) {\n \t\tput_write_access(inode);\n \t\tif (!special_file(inode->i_mode)) {""}<_**next**_>{""sha"": ""e5f6c2cfac380a7c4503dcebb0b3e310841893f0"", ""filename"": ""fs/super.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 13, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/super.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)\n \tint i;\n \tlist_lru_destroy(&s->s_dentry_lru);\n \tlist_lru_destroy(&s->s_inode_lru);\n-#ifdef CONFIG_SMP\n-\tfree_percpu(s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n \t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n \tsecurity_sb_free(s);\n@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)\n \tif (security_sb_alloc(s))\n \t\tgoto fail;\n \n-#ifdef CONFIG_SMP\n-\ts->s_files = alloc_percpu(struct list_head);\n-\tif (!s->s_files)\n-\t\tgoto fail;\n-\tfor_each_possible_cpu(i)\n-\t\tINIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));\n-#else\n-\tINIT_LIST_HEAD(&s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n \t\tif (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)\n \t\t\tgoto fail;\n@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n-\t\t\tmark_files_ro(sb);\n+\t\t\tsb->s_readonly_remount = 1;\n+\t\t\tsmp_wmb();\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)""}<_**next**_>{""sha"": ""2b0f4e974480c353a90654e634cc6f4a6d1293c4"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 13, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -764,12 +764,7 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n #define FILE_MNT_WRITE_RELEASED\t2\n \n struct file {\n-\t/*\n-\t * fu_list becomes invalid after file_free is called and queued via\n-\t * fu_rcuhead for RCU freeing\n-\t */\n \tunion {\n-\t\tstruct list_head\tfu_list;\n \t\tstruct llist_node\tfu_llist;\n \t\tstruct rcu_head \tfu_rcuhead;\n \t} f_u;\n@@ -783,9 +778,6 @@ struct file {\n \t * Must not be taken from IRQ context.\n \t */\n \tspinlock_t\t\tf_lock;\n-#ifdef CONFIG_SMP\n-\tint\t\t\tf_sb_list_cpu;\n-#endif\n \tatomic_long_t\t\tf_count;\n \tunsigned int \t\tf_flags;\n \tfmode_t\t\t\tf_mode;\n@@ -1264,11 +1256,6 @@ struct super_block {\n \n \tstruct list_head\ts_inodes;\t/* all inodes */\n \tstruct hlist_bl_head\ts_anon;\t\t/* anonymous dentries for (nfs) exporting */\n-#ifdef CONFIG_SMP\n-\tstruct list_head __percpu *s_files;\n-#else\n-\tstruct list_head\ts_files;\n-#endif\n \tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n \tstruct block_device\t*s_bdev;\n \tstruct backing_dev_info *s_bdi;""}","void mark_files_ro(struct super_block *sb)
","void mark_files_ro(struct super_block *sb)
{
	struct file *f;
	lg_global_lock(&files_lglock);
	do_file_list_for_each_entry(sb, f) {
		if (!file_count(f))
			continue;
		if (!(f->f_mode & FMODE_WRITE))
			continue;
		spin_lock(&f->f_lock);
		f->f_mode &= ~FMODE_WRITE;
		spin_unlock(&f->f_lock);
		if (file_check_writeable(f) != 0)
			continue;
		__mnt_drop_write(f->f_path.mnt);
		file_release_write(f);
	} while_file_list_for_each_entry;
	lg_global_unlock(&files_lglock);
}
",C,,"{
	struct file *f;
	lg_global_lock(&files_lglock);
	do_file_list_for_each_entry(sb, f) {
		if (!file_count(f))
			continue;
		if (!(f->f_mode & FMODE_WRITE))
			continue;
		spin_lock(&f->f_lock);
		f->f_mode &= ~FMODE_WRITE;
		spin_unlock(&f->f_lock);
		if (file_check_writeable(f) != 0)
			continue;
		__mnt_drop_write(f->f_path.mnt);
		file_release_write(f);
	} while_file_list_for_each_entry;
	lg_global_unlock(&files_lglock);
}
",,"@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {
 	.max_files = NR_FILE
 };
 
-DEFINE_STATIC_LGLOCK(files_lglock);
-
 /* SLAB cache for file structures */
 static struct kmem_cache *filp_cachep __read_mostly;
 
@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)
 		return ERR_PTR(error);
 	}
 
-	INIT_LIST_HEAD(&f->f_u.fu_list);
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
@@ -304,7 +301,6 @@ void fput(struct file *file)
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
 
-		file_sb_list_del(file);
 		if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {
 			init_task_work(&file->f_u.fu_rcuhead, ____fput);
 			if (!task_work_add(task, &file->f_u.fu_rcuhead, true))
@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
-		file_sb_list_del(file);
 		BUG_ON(!(task->flags & PF_KTHREAD));
 		__fput(file);
 	}
@@ -345,129 +340,10 @@ void put_filp(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		security_file_free(file);
-		file_sb_list_del(file);
 		file_free(file);
 	}
 }
 
-static inline int file_list_cpu(struct file *file)
-{
-#ifdef CONFIG_SMP
-	return file->f_sb_list_cpu;
-#else
-	return smp_processor_id();
-#endif
-}
-
-/* helper for file_sb_list_add to reduce ifdefs */
-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	struct list_head *list;
-#ifdef CONFIG_SMP
-	int cpu;
-	cpu = smp_processor_id();
-	file->f_sb_list_cpu = cpu;
-	list = per_cpu_ptr(sb->s_files, cpu);
-#else
-	list = &sb->s_files;
-#endif
-	list_add(&file->f_u.fu_list, list);
-}
-
-/**
- * file_sb_list_add - add a file to the sb's file list
- * @file: file to add
- * @sb: sb to add it to
- *
- * Use this function to associate a file with the superblock of the inode it
- * refers to.
- */
-void file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	if (likely(!(file->f_mode & FMODE_WRITE)))
-		return;
-	if (!S_ISREG(file_inode(file)->i_mode))
-		return;
-	lg_local_lock(&files_lglock);
-	__file_sb_list_add(file, sb);
-	lg_local_unlock(&files_lglock);
-}
-
-/**
- * file_sb_list_del - remove a file from the sb's file list
- * @file: file to remove
- * @sb: sb to remove it from
- *
- * Use this function to remove a file from its superblock.
- */
-void file_sb_list_del(struct file *file)
-{
-	if (!list_empty(&file->f_u.fu_list)) {
-		lg_local_lock_cpu(&files_lglock, file_list_cpu(file));
-		list_del_init(&file->f_u.fu_list);
-		lg_local_unlock_cpu(&files_lglock, file_list_cpu(file));
-	}
-}
-
-#ifdef CONFIG_SMP
-
-/*
- * These macros iterate all files on all CPUs for a given superblock.
- * files_lglock must be held globally.
- */
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	int i;							\
-	for_each_possible_cpu(i) {				\
-		struct list_head *list;				\
-		list = per_cpu_ptr((__sb)->s_files, i);		\
-		list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-	}							\
-}
-
-#else
-
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	struct list_head *list;					\
-	list = &(sb)->s_files;					\
-	list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-}
-
-#endif
-
-/**
- *	mark_files_ro - mark all files read-only
- *	@sb: superblock in question
- *
- *	All files are marked read-only.  We don't care about pending
- *	delete files so this should be used in 'force' mode only.
- */
-void mark_files_ro(struct super_block *sb)
-{
-	struct file *f;
-
-	lg_global_lock(&files_lglock);
-	do_file_list_for_each_entry(sb, f) {
-		if (!file_count(f))
-			continue;
-		if (!(f->f_mode & FMODE_WRITE))
-			continue;
-		spin_lock(&f->f_lock);
-		f->f_mode &= ~FMODE_WRITE;
-		spin_unlock(&f->f_lock);
-		if (file_check_writeable(f) != 0)
-			continue;
-		__mnt_drop_write(f->f_path.mnt);
-		file_release_write(f);
-	} while_file_list_for_each_entry;
-	lg_global_unlock(&files_lglock);
-}
-
 void __init files_init(unsigned long mempages)
 { 
 	unsigned long n;
@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)
 	n = (mempages * (PAGE_SIZE / 1024)) / 10;
 	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
 	files_defer_init();
-	lg_lock_init(&files_lglock, ""files_lglock"");
 	percpu_counter_init(&nr_files, 0);
 } ",linux,eee5cc2702929fd41cce28058dc6d6717f723f87,8b61e74ffc6310e1d35a9b51c8463093851f8bcf,1,"void mark_files_ro(struct super_block *sb)
//flaw_line_below:
{
//flaw_line_below:
	struct file *f;
//flaw_line_below:

//flaw_line_below:
	lg_global_lock(&files_lglock);
//flaw_line_below:
	do_file_list_for_each_entry(sb, f) {
//flaw_line_below:
		if (!file_count(f))
//flaw_line_below:
			continue;
//flaw_line_below:
		if (!(f->f_mode & FMODE_WRITE))
//flaw_line_below:
			continue;
//flaw_line_below:
		spin_lock(&f->f_lock);
//flaw_line_below:
		f->f_mode &= ~FMODE_WRITE;
//flaw_line_below:
		spin_unlock(&f->f_lock);
//flaw_line_below:
		if (file_check_writeable(f) != 0)
//flaw_line_below:
			continue;
//flaw_line_below:
		__mnt_drop_write(f->f_path.mnt);
//flaw_line_below:
		file_release_write(f);
//flaw_line_below:
	} while_file_list_for_each_entry;
//flaw_line_below:
	lg_global_unlock(&files_lglock);
//flaw_line_below:
}
"
2240,179976,,Local,Not required,Complete,CVE-2014-8172,https://www.cvedetails.com/cve/CVE-2014-8172/,CWE-17,Low,,,,2015-03-16,4.9,"The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations.",2015-03-23,DoS ,0,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,eee5cc2702929fd41cce28058dc6d6717f723f87,"get rid of s_files and files_lock

The only thing we need it for is alt-sysrq-r (emergency remount r/o)
and these days we can do just as well without going through the
list of files.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",1,fs/file_table.c,"{""sha"": ""23b6dca03ba06f4da0553b1db70f6911098382fc"", ""filename"": ""fs/file_table.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 125, ""changes"": 125, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/file_table.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {\n \t.max_files = NR_FILE\n };\n \n-DEFINE_STATIC_LGLOCK(files_lglock);\n-\n /* SLAB cache for file structures */\n static struct kmem_cache *filp_cachep __read_mostly;\n \n@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)\n \t\treturn ERR_PTR(error);\n \t}\n \n-\tINIT_LIST_HEAD(&f->f_u.fu_list);\n \tatomic_long_set(&f->f_count, 1);\n \trwlock_init(&f->f_owner.lock);\n \tspin_lock_init(&f->f_lock);\n@@ -304,7 +301,6 @@ void fput(struct file *file)\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n \n-\t\tfile_sb_list_del(file);\n \t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n \t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n \t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n-\t\tfile_sb_list_del(file);\n \t\tBUG_ON(!(task->flags & PF_KTHREAD));\n \t\t__fput(file);\n \t}\n@@ -345,129 +340,10 @@ void put_filp(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tsecurity_file_free(file);\n-\t\tfile_sb_list_del(file);\n \t\tfile_free(file);\n \t}\n }\n \n-static inline int file_list_cpu(struct file *file)\n-{\n-#ifdef CONFIG_SMP\n-\treturn file->f_sb_list_cpu;\n-#else\n-\treturn smp_processor_id();\n-#endif\n-}\n-\n-/* helper for file_sb_list_add to reduce ifdefs */\n-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tstruct list_head *list;\n-#ifdef CONFIG_SMP\n-\tint cpu;\n-\tcpu = smp_processor_id();\n-\tfile->f_sb_list_cpu = cpu;\n-\tlist = per_cpu_ptr(sb->s_files, cpu);\n-#else\n-\tlist = &sb->s_files;\n-#endif\n-\tlist_add(&file->f_u.fu_list, list);\n-}\n-\n-/**\n- * file_sb_list_add - add a file to the sb's file list\n- * @file: file to add\n- * @sb: sb to add it to\n- *\n- * Use this function to associate a file with the superblock of the inode it\n- * refers to.\n- */\n-void file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tif (likely(!(file->f_mode & FMODE_WRITE)))\n-\t\treturn;\n-\tif (!S_ISREG(file_inode(file)->i_mode))\n-\t\treturn;\n-\tlg_local_lock(&files_lglock);\n-\t__file_sb_list_add(file, sb);\n-\tlg_local_unlock(&files_lglock);\n-}\n-\n-/**\n- * file_sb_list_del - remove a file from the sb's file list\n- * @file: file to remove\n- * @sb: sb to remove it from\n- *\n- * Use this function to remove a file from its superblock.\n- */\n-void file_sb_list_del(struct file *file)\n-{\n-\tif (!list_empty(&file->f_u.fu_list)) {\n-\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n-\t\tlist_del_init(&file->f_u.fu_list);\n-\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n-\t}\n-}\n-\n-#ifdef CONFIG_SMP\n-\n-/*\n- * These macros iterate all files on all CPUs for a given superblock.\n- * files_lglock must be held globally.\n- */\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tint i;\t\t\t\t\t\t\t\\\n-\tfor_each_possible_cpu(i) {\t\t\t\t\\\n-\t\tstruct list_head *list;\t\t\t\t\\\n-\t\tlist = per_cpu_ptr((__sb)->s_files, i);\t\t\\\n-\t\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-}\n-\n-#else\n-\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tstruct list_head *list;\t\t\t\t\t\\\n-\tlist = &(sb)->s_files;\t\t\t\t\t\\\n-\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-}\n-\n-#endif\n-\n-/**\n- *\tmark_files_ro - mark all files read-only\n- *\t@sb: superblock in question\n- *\n- *\tAll files are marked read-only.  We don't care about pending\n- *\tdelete files so this should be used in 'force' mode only.\n- */\n-void mark_files_ro(struct super_block *sb)\n-{\n-\tstruct file *f;\n-\n-\tlg_global_lock(&files_lglock);\n-\tdo_file_list_for_each_entry(sb, f) {\n-\t\tif (!file_count(f))\n-\t\t\tcontinue;\n-\t\tif (!(f->f_mode & FMODE_WRITE))\n-\t\t\tcontinue;\n-\t\tspin_lock(&f->f_lock);\n-\t\tf->f_mode &= ~FMODE_WRITE;\n-\t\tspin_unlock(&f->f_lock);\n-\t\tif (file_check_writeable(f) != 0)\n-\t\t\tcontinue;\n-\t\t__mnt_drop_write(f->f_path.mnt);\n-\t\tfile_release_write(f);\n-\t} while_file_list_for_each_entry;\n-\tlg_global_unlock(&files_lglock);\n-}\n-\n void __init files_init(unsigned long mempages)\n { \n \tunsigned long n;\n@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)\n \tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n \tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n \tfiles_defer_init();\n-\tlg_lock_init(&files_lglock, \""files_lglock\"");\n \tpercpu_counter_init(&nr_files, 0);\n } ""}<_**next**_>{""sha"": ""4657424074668dcb933c8d375244b1d3b9d72561"", ""filename"": ""fs/internal.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/internal.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -73,9 +73,6 @@ extern void chroot_fs_refs(const struct path *, const struct path *);\n /*\n  * file_table.c\n  */\n-extern void file_sb_list_add(struct file *f, struct super_block *sb);\n-extern void file_sb_list_del(struct file *f);\n-extern void mark_files_ro(struct super_block *);\n extern struct file *get_empty_filp(void);\n \n /*""}<_**next**_>{""sha"": ""fffbed40dbe9e24dc6129878cf65527e241d4d48"", ""filename"": ""fs/open.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/open.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -685,7 +685,6 @@ static int do_dentry_open(struct file *f,\n \t}\n \n \tf->f_mapping = inode->i_mapping;\n-\tfile_sb_list_add(f, inode->i_sb);\n \n \tif (unlikely(f->f_mode & FMODE_PATH)) {\n \t\tf->f_op = &empty_fops;\n@@ -724,7 +723,6 @@ static int do_dentry_open(struct file *f,\n \n cleanup_all:\n \tfops_put(f->f_op);\n-\tfile_sb_list_del(f);\n \tif (f->f_mode & FMODE_WRITE) {\n \t\tput_write_access(inode);\n \t\tif (!special_file(inode->i_mode)) {""}<_**next**_>{""sha"": ""e5f6c2cfac380a7c4503dcebb0b3e310841893f0"", ""filename"": ""fs/super.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 13, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/super.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)\n \tint i;\n \tlist_lru_destroy(&s->s_dentry_lru);\n \tlist_lru_destroy(&s->s_inode_lru);\n-#ifdef CONFIG_SMP\n-\tfree_percpu(s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n \t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n \tsecurity_sb_free(s);\n@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)\n \tif (security_sb_alloc(s))\n \t\tgoto fail;\n \n-#ifdef CONFIG_SMP\n-\ts->s_files = alloc_percpu(struct list_head);\n-\tif (!s->s_files)\n-\t\tgoto fail;\n-\tfor_each_possible_cpu(i)\n-\t\tINIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));\n-#else\n-\tINIT_LIST_HEAD(&s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n \t\tif (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)\n \t\t\tgoto fail;\n@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n-\t\t\tmark_files_ro(sb);\n+\t\t\tsb->s_readonly_remount = 1;\n+\t\t\tsmp_wmb();\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)""}<_**next**_>{""sha"": ""2b0f4e974480c353a90654e634cc6f4a6d1293c4"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 13, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -764,12 +764,7 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n #define FILE_MNT_WRITE_RELEASED\t2\n \n struct file {\n-\t/*\n-\t * fu_list becomes invalid after file_free is called and queued via\n-\t * fu_rcuhead for RCU freeing\n-\t */\n \tunion {\n-\t\tstruct list_head\tfu_list;\n \t\tstruct llist_node\tfu_llist;\n \t\tstruct rcu_head \tfu_rcuhead;\n \t} f_u;\n@@ -783,9 +778,6 @@ struct file {\n \t * Must not be taken from IRQ context.\n \t */\n \tspinlock_t\t\tf_lock;\n-#ifdef CONFIG_SMP\n-\tint\t\t\tf_sb_list_cpu;\n-#endif\n \tatomic_long_t\t\tf_count;\n \tunsigned int \t\tf_flags;\n \tfmode_t\t\t\tf_mode;\n@@ -1264,11 +1256,6 @@ struct super_block {\n \n \tstruct list_head\ts_inodes;\t/* all inodes */\n \tstruct hlist_bl_head\ts_anon;\t\t/* anonymous dentries for (nfs) exporting */\n-#ifdef CONFIG_SMP\n-\tstruct list_head __percpu *s_files;\n-#else\n-\tstruct list_head\ts_files;\n-#endif\n \tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n \tstruct block_device\t*s_bdev;\n \tstruct backing_dev_info *s_bdi;""}","void put_filp(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		security_file_free(file);
 		file_free(file);
 	}
 }
","void put_filp(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		security_file_free(file);
		file_sb_list_del(file);
 		file_free(file);
 	}
 }
",C,,"		file_sb_list_del(file);
",,"@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {
 	.max_files = NR_FILE
 };
 
-DEFINE_STATIC_LGLOCK(files_lglock);
-
 /* SLAB cache for file structures */
 static struct kmem_cache *filp_cachep __read_mostly;
 
@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)
 		return ERR_PTR(error);
 	}
 
-	INIT_LIST_HEAD(&f->f_u.fu_list);
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
@@ -304,7 +301,6 @@ void fput(struct file *file)
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
 
-		file_sb_list_del(file);
 		if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {
 			init_task_work(&file->f_u.fu_rcuhead, ____fput);
 			if (!task_work_add(task, &file->f_u.fu_rcuhead, true))
@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
-		file_sb_list_del(file);
 		BUG_ON(!(task->flags & PF_KTHREAD));
 		__fput(file);
 	}
@@ -345,129 +340,10 @@ void put_filp(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		security_file_free(file);
-		file_sb_list_del(file);
 		file_free(file);
 	}
 }
 
-static inline int file_list_cpu(struct file *file)
-{
-#ifdef CONFIG_SMP
-	return file->f_sb_list_cpu;
-#else
-	return smp_processor_id();
-#endif
-}
-
-/* helper for file_sb_list_add to reduce ifdefs */
-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	struct list_head *list;
-#ifdef CONFIG_SMP
-	int cpu;
-	cpu = smp_processor_id();
-	file->f_sb_list_cpu = cpu;
-	list = per_cpu_ptr(sb->s_files, cpu);
-#else
-	list = &sb->s_files;
-#endif
-	list_add(&file->f_u.fu_list, list);
-}
-
-/**
- * file_sb_list_add - add a file to the sb's file list
- * @file: file to add
- * @sb: sb to add it to
- *
- * Use this function to associate a file with the superblock of the inode it
- * refers to.
- */
-void file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	if (likely(!(file->f_mode & FMODE_WRITE)))
-		return;
-	if (!S_ISREG(file_inode(file)->i_mode))
-		return;
-	lg_local_lock(&files_lglock);
-	__file_sb_list_add(file, sb);
-	lg_local_unlock(&files_lglock);
-}
-
-/**
- * file_sb_list_del - remove a file from the sb's file list
- * @file: file to remove
- * @sb: sb to remove it from
- *
- * Use this function to remove a file from its superblock.
- */
-void file_sb_list_del(struct file *file)
-{
-	if (!list_empty(&file->f_u.fu_list)) {
-		lg_local_lock_cpu(&files_lglock, file_list_cpu(file));
-		list_del_init(&file->f_u.fu_list);
-		lg_local_unlock_cpu(&files_lglock, file_list_cpu(file));
-	}
-}
-
-#ifdef CONFIG_SMP
-
-/*
- * These macros iterate all files on all CPUs for a given superblock.
- * files_lglock must be held globally.
- */
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	int i;							\
-	for_each_possible_cpu(i) {				\
-		struct list_head *list;				\
-		list = per_cpu_ptr((__sb)->s_files, i);		\
-		list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-	}							\
-}
-
-#else
-
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	struct list_head *list;					\
-	list = &(sb)->s_files;					\
-	list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-}
-
-#endif
-
-/**
- *	mark_files_ro - mark all files read-only
- *	@sb: superblock in question
- *
- *	All files are marked read-only.  We don't care about pending
- *	delete files so this should be used in 'force' mode only.
- */
-void mark_files_ro(struct super_block *sb)
-{
-	struct file *f;
-
-	lg_global_lock(&files_lglock);
-	do_file_list_for_each_entry(sb, f) {
-		if (!file_count(f))
-			continue;
-		if (!(f->f_mode & FMODE_WRITE))
-			continue;
-		spin_lock(&f->f_lock);
-		f->f_mode &= ~FMODE_WRITE;
-		spin_unlock(&f->f_lock);
-		if (file_check_writeable(f) != 0)
-			continue;
-		__mnt_drop_write(f->f_path.mnt);
-		file_release_write(f);
-	} while_file_list_for_each_entry;
-	lg_global_unlock(&files_lglock);
-}
-
 void __init files_init(unsigned long mempages)
 { 
 	unsigned long n;
@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)
 	n = (mempages * (PAGE_SIZE / 1024)) / 10;
 	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
 	files_defer_init();
-	lg_lock_init(&files_lglock, ""files_lglock"");
 	percpu_counter_init(&nr_files, 0);
 } ",linux,eee5cc2702929fd41cce28058dc6d6717f723f87,8b61e74ffc6310e1d35a9b51c8463093851f8bcf,1,"void put_filp(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		security_file_free(file);
//flaw_line_below:
		file_sb_list_del(file);
 		file_free(file);
 	}
 }
"
2241,179977,,Local,Not required,Complete,CVE-2014-8172,https://www.cvedetails.com/cve/CVE-2014-8172/,CWE-17,Low,,,,2015-03-16,4.9,"The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations.",2015-03-23,DoS ,0,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,eee5cc2702929fd41cce28058dc6d6717f723f87,"get rid of s_files and files_lock

The only thing we need it for is alt-sysrq-r (emergency remount r/o)
and these days we can do just as well without going through the
list of files.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",2,fs/open.c,"{""sha"": ""23b6dca03ba06f4da0553b1db70f6911098382fc"", ""filename"": ""fs/file_table.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 125, ""changes"": 125, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/file_table.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {\n \t.max_files = NR_FILE\n };\n \n-DEFINE_STATIC_LGLOCK(files_lglock);\n-\n /* SLAB cache for file structures */\n static struct kmem_cache *filp_cachep __read_mostly;\n \n@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)\n \t\treturn ERR_PTR(error);\n \t}\n \n-\tINIT_LIST_HEAD(&f->f_u.fu_list);\n \tatomic_long_set(&f->f_count, 1);\n \trwlock_init(&f->f_owner.lock);\n \tspin_lock_init(&f->f_lock);\n@@ -304,7 +301,6 @@ void fput(struct file *file)\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n \n-\t\tfile_sb_list_del(file);\n \t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n \t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n \t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n-\t\tfile_sb_list_del(file);\n \t\tBUG_ON(!(task->flags & PF_KTHREAD));\n \t\t__fput(file);\n \t}\n@@ -345,129 +340,10 @@ void put_filp(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tsecurity_file_free(file);\n-\t\tfile_sb_list_del(file);\n \t\tfile_free(file);\n \t}\n }\n \n-static inline int file_list_cpu(struct file *file)\n-{\n-#ifdef CONFIG_SMP\n-\treturn file->f_sb_list_cpu;\n-#else\n-\treturn smp_processor_id();\n-#endif\n-}\n-\n-/* helper for file_sb_list_add to reduce ifdefs */\n-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tstruct list_head *list;\n-#ifdef CONFIG_SMP\n-\tint cpu;\n-\tcpu = smp_processor_id();\n-\tfile->f_sb_list_cpu = cpu;\n-\tlist = per_cpu_ptr(sb->s_files, cpu);\n-#else\n-\tlist = &sb->s_files;\n-#endif\n-\tlist_add(&file->f_u.fu_list, list);\n-}\n-\n-/**\n- * file_sb_list_add - add a file to the sb's file list\n- * @file: file to add\n- * @sb: sb to add it to\n- *\n- * Use this function to associate a file with the superblock of the inode it\n- * refers to.\n- */\n-void file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tif (likely(!(file->f_mode & FMODE_WRITE)))\n-\t\treturn;\n-\tif (!S_ISREG(file_inode(file)->i_mode))\n-\t\treturn;\n-\tlg_local_lock(&files_lglock);\n-\t__file_sb_list_add(file, sb);\n-\tlg_local_unlock(&files_lglock);\n-}\n-\n-/**\n- * file_sb_list_del - remove a file from the sb's file list\n- * @file: file to remove\n- * @sb: sb to remove it from\n- *\n- * Use this function to remove a file from its superblock.\n- */\n-void file_sb_list_del(struct file *file)\n-{\n-\tif (!list_empty(&file->f_u.fu_list)) {\n-\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n-\t\tlist_del_init(&file->f_u.fu_list);\n-\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n-\t}\n-}\n-\n-#ifdef CONFIG_SMP\n-\n-/*\n- * These macros iterate all files on all CPUs for a given superblock.\n- * files_lglock must be held globally.\n- */\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tint i;\t\t\t\t\t\t\t\\\n-\tfor_each_possible_cpu(i) {\t\t\t\t\\\n-\t\tstruct list_head *list;\t\t\t\t\\\n-\t\tlist = per_cpu_ptr((__sb)->s_files, i);\t\t\\\n-\t\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-}\n-\n-#else\n-\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tstruct list_head *list;\t\t\t\t\t\\\n-\tlist = &(sb)->s_files;\t\t\t\t\t\\\n-\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-}\n-\n-#endif\n-\n-/**\n- *\tmark_files_ro - mark all files read-only\n- *\t@sb: superblock in question\n- *\n- *\tAll files are marked read-only.  We don't care about pending\n- *\tdelete files so this should be used in 'force' mode only.\n- */\n-void mark_files_ro(struct super_block *sb)\n-{\n-\tstruct file *f;\n-\n-\tlg_global_lock(&files_lglock);\n-\tdo_file_list_for_each_entry(sb, f) {\n-\t\tif (!file_count(f))\n-\t\t\tcontinue;\n-\t\tif (!(f->f_mode & FMODE_WRITE))\n-\t\t\tcontinue;\n-\t\tspin_lock(&f->f_lock);\n-\t\tf->f_mode &= ~FMODE_WRITE;\n-\t\tspin_unlock(&f->f_lock);\n-\t\tif (file_check_writeable(f) != 0)\n-\t\t\tcontinue;\n-\t\t__mnt_drop_write(f->f_path.mnt);\n-\t\tfile_release_write(f);\n-\t} while_file_list_for_each_entry;\n-\tlg_global_unlock(&files_lglock);\n-}\n-\n void __init files_init(unsigned long mempages)\n { \n \tunsigned long n;\n@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)\n \tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n \tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n \tfiles_defer_init();\n-\tlg_lock_init(&files_lglock, \""files_lglock\"");\n \tpercpu_counter_init(&nr_files, 0);\n } ""}<_**next**_>{""sha"": ""4657424074668dcb933c8d375244b1d3b9d72561"", ""filename"": ""fs/internal.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/internal.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -73,9 +73,6 @@ extern void chroot_fs_refs(const struct path *, const struct path *);\n /*\n  * file_table.c\n  */\n-extern void file_sb_list_add(struct file *f, struct super_block *sb);\n-extern void file_sb_list_del(struct file *f);\n-extern void mark_files_ro(struct super_block *);\n extern struct file *get_empty_filp(void);\n \n /*""}<_**next**_>{""sha"": ""fffbed40dbe9e24dc6129878cf65527e241d4d48"", ""filename"": ""fs/open.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/open.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -685,7 +685,6 @@ static int do_dentry_open(struct file *f,\n \t}\n \n \tf->f_mapping = inode->i_mapping;\n-\tfile_sb_list_add(f, inode->i_sb);\n \n \tif (unlikely(f->f_mode & FMODE_PATH)) {\n \t\tf->f_op = &empty_fops;\n@@ -724,7 +723,6 @@ static int do_dentry_open(struct file *f,\n \n cleanup_all:\n \tfops_put(f->f_op);\n-\tfile_sb_list_del(f);\n \tif (f->f_mode & FMODE_WRITE) {\n \t\tput_write_access(inode);\n \t\tif (!special_file(inode->i_mode)) {""}<_**next**_>{""sha"": ""e5f6c2cfac380a7c4503dcebb0b3e310841893f0"", ""filename"": ""fs/super.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 13, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/super.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)\n \tint i;\n \tlist_lru_destroy(&s->s_dentry_lru);\n \tlist_lru_destroy(&s->s_inode_lru);\n-#ifdef CONFIG_SMP\n-\tfree_percpu(s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n \t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n \tsecurity_sb_free(s);\n@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)\n \tif (security_sb_alloc(s))\n \t\tgoto fail;\n \n-#ifdef CONFIG_SMP\n-\ts->s_files = alloc_percpu(struct list_head);\n-\tif (!s->s_files)\n-\t\tgoto fail;\n-\tfor_each_possible_cpu(i)\n-\t\tINIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));\n-#else\n-\tINIT_LIST_HEAD(&s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n \t\tif (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)\n \t\t\tgoto fail;\n@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n-\t\t\tmark_files_ro(sb);\n+\t\t\tsb->s_readonly_remount = 1;\n+\t\t\tsmp_wmb();\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)""}<_**next**_>{""sha"": ""2b0f4e974480c353a90654e634cc6f4a6d1293c4"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 13, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -764,12 +764,7 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n #define FILE_MNT_WRITE_RELEASED\t2\n \n struct file {\n-\t/*\n-\t * fu_list becomes invalid after file_free is called and queued via\n-\t * fu_rcuhead for RCU freeing\n-\t */\n \tunion {\n-\t\tstruct list_head\tfu_list;\n \t\tstruct llist_node\tfu_llist;\n \t\tstruct rcu_head \tfu_rcuhead;\n \t} f_u;\n@@ -783,9 +778,6 @@ struct file {\n \t * Must not be taken from IRQ context.\n \t */\n \tspinlock_t\t\tf_lock;\n-#ifdef CONFIG_SMP\n-\tint\t\t\tf_sb_list_cpu;\n-#endif\n \tatomic_long_t\t\tf_count;\n \tunsigned int \t\tf_flags;\n \tfmode_t\t\t\tf_mode;\n@@ -1264,11 +1256,6 @@ struct super_block {\n \n \tstruct list_head\ts_inodes;\t/* all inodes */\n \tstruct hlist_bl_head\ts_anon;\t\t/* anonymous dentries for (nfs) exporting */\n-#ifdef CONFIG_SMP\n-\tstruct list_head __percpu *s_files;\n-#else\n-\tstruct list_head\ts_files;\n-#endif\n \tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n \tstruct block_device\t*s_bdev;\n \tstruct backing_dev_info *s_bdi;""}","static int do_dentry_open(struct file *f,
			  int (*open)(struct inode *, struct file *),
			  const struct cred *cred)
{
	static const struct file_operations empty_fops = {};
	struct inode *inode;
	int error;

	f->f_mode = OPEN_FMODE(f->f_flags) | FMODE_LSEEK |
				FMODE_PREAD | FMODE_PWRITE;

	if (unlikely(f->f_flags & O_PATH))
		f->f_mode = FMODE_PATH;

	path_get(&f->f_path);
	inode = f->f_inode = f->f_path.dentry->d_inode;
	if (f->f_mode & FMODE_WRITE) {
		error = __get_file_write_access(inode, f->f_path.mnt);
		if (error)
			goto cleanup_file;
		if (!special_file(inode->i_mode))
			file_take_write(f);
 	}
 
 	f->f_mapping = inode->i_mapping;
 
 	if (unlikely(f->f_mode & FMODE_PATH)) {
 		f->f_op = &empty_fops;
		return 0;
	}

	f->f_op = fops_get(inode->i_fop);
	if (unlikely(WARN_ON(!f->f_op))) {
		error = -ENODEV;
		goto cleanup_all;
	}

	error = security_file_open(f, cred);
	if (error)
		goto cleanup_all;

	error = break_lease(inode, f->f_flags);
	if (error)
		goto cleanup_all;

	if (!open)
		open = f->f_op->open;
	if (open) {
		error = open(inode, f);
		if (error)
			goto cleanup_all;
	}
	if ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)
		i_readcount_inc(inode);

	f->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);

	file_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);

	return 0;
 
 cleanup_all:
 	fops_put(f->f_op);
 	if (f->f_mode & FMODE_WRITE) {
 		put_write_access(inode);
 		if (!special_file(inode->i_mode)) {
			/*
			 * We don't consider this a real
			 * mnt_want/drop_write() pair
			 * because it all happenend right
			 * here, so just reset the state.
			 */
			file_reset_write(f);
			__mnt_drop_write(f->f_path.mnt);
		}
	}
cleanup_file:
	path_put(&f->f_path);
	f->f_path.mnt = NULL;
	f->f_path.dentry = NULL;
	f->f_inode = NULL;
	return error;
}
","static int do_dentry_open(struct file *f,
			  int (*open)(struct inode *, struct file *),
			  const struct cred *cred)
{
	static const struct file_operations empty_fops = {};
	struct inode *inode;
	int error;

	f->f_mode = OPEN_FMODE(f->f_flags) | FMODE_LSEEK |
				FMODE_PREAD | FMODE_PWRITE;

	if (unlikely(f->f_flags & O_PATH))
		f->f_mode = FMODE_PATH;

	path_get(&f->f_path);
	inode = f->f_inode = f->f_path.dentry->d_inode;
	if (f->f_mode & FMODE_WRITE) {
		error = __get_file_write_access(inode, f->f_path.mnt);
		if (error)
			goto cleanup_file;
		if (!special_file(inode->i_mode))
			file_take_write(f);
 	}
 
 	f->f_mapping = inode->i_mapping;
	file_sb_list_add(f, inode->i_sb);
 
 	if (unlikely(f->f_mode & FMODE_PATH)) {
 		f->f_op = &empty_fops;
		return 0;
	}

	f->f_op = fops_get(inode->i_fop);
	if (unlikely(WARN_ON(!f->f_op))) {
		error = -ENODEV;
		goto cleanup_all;
	}

	error = security_file_open(f, cred);
	if (error)
		goto cleanup_all;

	error = break_lease(inode, f->f_flags);
	if (error)
		goto cleanup_all;

	if (!open)
		open = f->f_op->open;
	if (open) {
		error = open(inode, f);
		if (error)
			goto cleanup_all;
	}
	if ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)
		i_readcount_inc(inode);

	f->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);

	file_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);

	return 0;
 
 cleanup_all:
 	fops_put(f->f_op);
	file_sb_list_del(f);
 	if (f->f_mode & FMODE_WRITE) {
 		put_write_access(inode);
 		if (!special_file(inode->i_mode)) {
			/*
			 * We don't consider this a real
			 * mnt_want/drop_write() pair
			 * because it all happenend right
			 * here, so just reset the state.
			 */
			file_reset_write(f);
			__mnt_drop_write(f->f_path.mnt);
		}
	}
cleanup_file:
	path_put(&f->f_path);
	f->f_path.mnt = NULL;
	f->f_path.dentry = NULL;
	f->f_inode = NULL;
	return error;
}
",C,,"	file_sb_list_add(f, inode->i_sb);
	file_sb_list_del(f);
",,"@@ -685,7 +685,6 @@ static int do_dentry_open(struct file *f,
 	}
 
 	f->f_mapping = inode->i_mapping;
-	file_sb_list_add(f, inode->i_sb);
 
 	if (unlikely(f->f_mode & FMODE_PATH)) {
 		f->f_op = &empty_fops;
@@ -724,7 +723,6 @@ static int do_dentry_open(struct file *f,
 
 cleanup_all:
 	fops_put(f->f_op);
-	file_sb_list_del(f);
 	if (f->f_mode & FMODE_WRITE) {
 		put_write_access(inode);
 		if (!special_file(inode->i_mode)) {",linux,eee5cc2702929fd41cce28058dc6d6717f723f87,8b61e74ffc6310e1d35a9b51c8463093851f8bcf,1,"static int do_dentry_open(struct file *f,
			  int (*open)(struct inode *, struct file *),
			  const struct cred *cred)
{
	static const struct file_operations empty_fops = {};
	struct inode *inode;
	int error;

	f->f_mode = OPEN_FMODE(f->f_flags) | FMODE_LSEEK |
				FMODE_PREAD | FMODE_PWRITE;

	if (unlikely(f->f_flags & O_PATH))
		f->f_mode = FMODE_PATH;

	path_get(&f->f_path);
	inode = f->f_inode = f->f_path.dentry->d_inode;
	if (f->f_mode & FMODE_WRITE) {
		error = __get_file_write_access(inode, f->f_path.mnt);
		if (error)
			goto cleanup_file;
		if (!special_file(inode->i_mode))
			file_take_write(f);
 	}
 
 	f->f_mapping = inode->i_mapping;
//flaw_line_below:
	file_sb_list_add(f, inode->i_sb);
 
 	if (unlikely(f->f_mode & FMODE_PATH)) {
 		f->f_op = &empty_fops;
		return 0;
	}

	f->f_op = fops_get(inode->i_fop);
	if (unlikely(WARN_ON(!f->f_op))) {
		error = -ENODEV;
		goto cleanup_all;
	}

	error = security_file_open(f, cred);
	if (error)
		goto cleanup_all;

	error = break_lease(inode, f->f_flags);
	if (error)
		goto cleanup_all;

	if (!open)
		open = f->f_op->open;
	if (open) {
		error = open(inode, f);
		if (error)
			goto cleanup_all;
	}
	if ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)
		i_readcount_inc(inode);

	f->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);

	file_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);

	return 0;
 
 cleanup_all:
 	fops_put(f->f_op);
//flaw_line_below:
	file_sb_list_del(f);
 	if (f->f_mode & FMODE_WRITE) {
 		put_write_access(inode);
 		if (!special_file(inode->i_mode)) {
			/*
			 * We don't consider this a real
			 * mnt_want/drop_write() pair
			 * because it all happenend right
			 * here, so just reset the state.
			 */
			file_reset_write(f);
			__mnt_drop_write(f->f_path.mnt);
		}
	}
cleanup_file:
	path_put(&f->f_path);
	f->f_path.mnt = NULL;
	f->f_path.dentry = NULL;
	f->f_inode = NULL;
	return error;
}
"
2242,179978,,Local,Not required,Complete,CVE-2014-8172,https://www.cvedetails.com/cve/CVE-2014-8172/,CWE-17,Low,,,,2015-03-16,4.9,"The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations.",2015-03-23,DoS ,0,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,eee5cc2702929fd41cce28058dc6d6717f723f87,"get rid of s_files and files_lock

The only thing we need it for is alt-sysrq-r (emergency remount r/o)
and these days we can do just as well without going through the
list of files.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",9,fs/super.c,"{""sha"": ""23b6dca03ba06f4da0553b1db70f6911098382fc"", ""filename"": ""fs/file_table.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 125, ""changes"": 125, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/file_table.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {\n \t.max_files = NR_FILE\n };\n \n-DEFINE_STATIC_LGLOCK(files_lglock);\n-\n /* SLAB cache for file structures */\n static struct kmem_cache *filp_cachep __read_mostly;\n \n@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)\n \t\treturn ERR_PTR(error);\n \t}\n \n-\tINIT_LIST_HEAD(&f->f_u.fu_list);\n \tatomic_long_set(&f->f_count, 1);\n \trwlock_init(&f->f_owner.lock);\n \tspin_lock_init(&f->f_lock);\n@@ -304,7 +301,6 @@ void fput(struct file *file)\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n \n-\t\tfile_sb_list_del(file);\n \t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n \t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n \t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n-\t\tfile_sb_list_del(file);\n \t\tBUG_ON(!(task->flags & PF_KTHREAD));\n \t\t__fput(file);\n \t}\n@@ -345,129 +340,10 @@ void put_filp(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tsecurity_file_free(file);\n-\t\tfile_sb_list_del(file);\n \t\tfile_free(file);\n \t}\n }\n \n-static inline int file_list_cpu(struct file *file)\n-{\n-#ifdef CONFIG_SMP\n-\treturn file->f_sb_list_cpu;\n-#else\n-\treturn smp_processor_id();\n-#endif\n-}\n-\n-/* helper for file_sb_list_add to reduce ifdefs */\n-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tstruct list_head *list;\n-#ifdef CONFIG_SMP\n-\tint cpu;\n-\tcpu = smp_processor_id();\n-\tfile->f_sb_list_cpu = cpu;\n-\tlist = per_cpu_ptr(sb->s_files, cpu);\n-#else\n-\tlist = &sb->s_files;\n-#endif\n-\tlist_add(&file->f_u.fu_list, list);\n-}\n-\n-/**\n- * file_sb_list_add - add a file to the sb's file list\n- * @file: file to add\n- * @sb: sb to add it to\n- *\n- * Use this function to associate a file with the superblock of the inode it\n- * refers to.\n- */\n-void file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tif (likely(!(file->f_mode & FMODE_WRITE)))\n-\t\treturn;\n-\tif (!S_ISREG(file_inode(file)->i_mode))\n-\t\treturn;\n-\tlg_local_lock(&files_lglock);\n-\t__file_sb_list_add(file, sb);\n-\tlg_local_unlock(&files_lglock);\n-}\n-\n-/**\n- * file_sb_list_del - remove a file from the sb's file list\n- * @file: file to remove\n- * @sb: sb to remove it from\n- *\n- * Use this function to remove a file from its superblock.\n- */\n-void file_sb_list_del(struct file *file)\n-{\n-\tif (!list_empty(&file->f_u.fu_list)) {\n-\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n-\t\tlist_del_init(&file->f_u.fu_list);\n-\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n-\t}\n-}\n-\n-#ifdef CONFIG_SMP\n-\n-/*\n- * These macros iterate all files on all CPUs for a given superblock.\n- * files_lglock must be held globally.\n- */\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tint i;\t\t\t\t\t\t\t\\\n-\tfor_each_possible_cpu(i) {\t\t\t\t\\\n-\t\tstruct list_head *list;\t\t\t\t\\\n-\t\tlist = per_cpu_ptr((__sb)->s_files, i);\t\t\\\n-\t\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-}\n-\n-#else\n-\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tstruct list_head *list;\t\t\t\t\t\\\n-\tlist = &(sb)->s_files;\t\t\t\t\t\\\n-\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-}\n-\n-#endif\n-\n-/**\n- *\tmark_files_ro - mark all files read-only\n- *\t@sb: superblock in question\n- *\n- *\tAll files are marked read-only.  We don't care about pending\n- *\tdelete files so this should be used in 'force' mode only.\n- */\n-void mark_files_ro(struct super_block *sb)\n-{\n-\tstruct file *f;\n-\n-\tlg_global_lock(&files_lglock);\n-\tdo_file_list_for_each_entry(sb, f) {\n-\t\tif (!file_count(f))\n-\t\t\tcontinue;\n-\t\tif (!(f->f_mode & FMODE_WRITE))\n-\t\t\tcontinue;\n-\t\tspin_lock(&f->f_lock);\n-\t\tf->f_mode &= ~FMODE_WRITE;\n-\t\tspin_unlock(&f->f_lock);\n-\t\tif (file_check_writeable(f) != 0)\n-\t\t\tcontinue;\n-\t\t__mnt_drop_write(f->f_path.mnt);\n-\t\tfile_release_write(f);\n-\t} while_file_list_for_each_entry;\n-\tlg_global_unlock(&files_lglock);\n-}\n-\n void __init files_init(unsigned long mempages)\n { \n \tunsigned long n;\n@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)\n \tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n \tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n \tfiles_defer_init();\n-\tlg_lock_init(&files_lglock, \""files_lglock\"");\n \tpercpu_counter_init(&nr_files, 0);\n } ""}<_**next**_>{""sha"": ""4657424074668dcb933c8d375244b1d3b9d72561"", ""filename"": ""fs/internal.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/internal.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -73,9 +73,6 @@ extern void chroot_fs_refs(const struct path *, const struct path *);\n /*\n  * file_table.c\n  */\n-extern void file_sb_list_add(struct file *f, struct super_block *sb);\n-extern void file_sb_list_del(struct file *f);\n-extern void mark_files_ro(struct super_block *);\n extern struct file *get_empty_filp(void);\n \n /*""}<_**next**_>{""sha"": ""fffbed40dbe9e24dc6129878cf65527e241d4d48"", ""filename"": ""fs/open.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/open.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -685,7 +685,6 @@ static int do_dentry_open(struct file *f,\n \t}\n \n \tf->f_mapping = inode->i_mapping;\n-\tfile_sb_list_add(f, inode->i_sb);\n \n \tif (unlikely(f->f_mode & FMODE_PATH)) {\n \t\tf->f_op = &empty_fops;\n@@ -724,7 +723,6 @@ static int do_dentry_open(struct file *f,\n \n cleanup_all:\n \tfops_put(f->f_op);\n-\tfile_sb_list_del(f);\n \tif (f->f_mode & FMODE_WRITE) {\n \t\tput_write_access(inode);\n \t\tif (!special_file(inode->i_mode)) {""}<_**next**_>{""sha"": ""e5f6c2cfac380a7c4503dcebb0b3e310841893f0"", ""filename"": ""fs/super.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 13, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/super.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)\n \tint i;\n \tlist_lru_destroy(&s->s_dentry_lru);\n \tlist_lru_destroy(&s->s_inode_lru);\n-#ifdef CONFIG_SMP\n-\tfree_percpu(s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n \t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n \tsecurity_sb_free(s);\n@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)\n \tif (security_sb_alloc(s))\n \t\tgoto fail;\n \n-#ifdef CONFIG_SMP\n-\ts->s_files = alloc_percpu(struct list_head);\n-\tif (!s->s_files)\n-\t\tgoto fail;\n-\tfor_each_possible_cpu(i)\n-\t\tINIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));\n-#else\n-\tINIT_LIST_HEAD(&s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n \t\tif (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)\n \t\t\tgoto fail;\n@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n-\t\t\tmark_files_ro(sb);\n+\t\t\tsb->s_readonly_remount = 1;\n+\t\t\tsmp_wmb();\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)""}<_**next**_>{""sha"": ""2b0f4e974480c353a90654e634cc6f4a6d1293c4"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 13, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -764,12 +764,7 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n #define FILE_MNT_WRITE_RELEASED\t2\n \n struct file {\n-\t/*\n-\t * fu_list becomes invalid after file_free is called and queued via\n-\t * fu_rcuhead for RCU freeing\n-\t */\n \tunion {\n-\t\tstruct list_head\tfu_list;\n \t\tstruct llist_node\tfu_llist;\n \t\tstruct rcu_head \tfu_rcuhead;\n \t} f_u;\n@@ -783,9 +778,6 @@ struct file {\n \t * Must not be taken from IRQ context.\n \t */\n \tspinlock_t\t\tf_lock;\n-#ifdef CONFIG_SMP\n-\tint\t\t\tf_sb_list_cpu;\n-#endif\n \tatomic_long_t\t\tf_count;\n \tunsigned int \t\tf_flags;\n \tfmode_t\t\t\tf_mode;\n@@ -1264,11 +1256,6 @@ struct super_block {\n \n \tstruct list_head\ts_inodes;\t/* all inodes */\n \tstruct hlist_bl_head\ts_anon;\t\t/* anonymous dentries for (nfs) exporting */\n-#ifdef CONFIG_SMP\n-\tstruct list_head __percpu *s_files;\n-#else\n-\tstruct list_head\ts_files;\n-#endif\n \tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n \tstruct block_device\t*s_bdev;\n \tstruct backing_dev_info *s_bdi;""}","static struct super_block *alloc_super(struct file_system_type *type, int flags)
{
	struct super_block *s = kzalloc(sizeof(struct super_block),  GFP_USER);
	static const struct super_operations default_op;
	int i;

	if (!s)
		return NULL;

 	if (security_sb_alloc(s))
 		goto fail;
 
 	for (i = 0; i < SB_FREEZE_LEVELS; i++) {
 		if (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)
 			goto fail;
		lockdep_init_map(&s->s_writers.lock_map[i], sb_writers_name[i],
				 &type->s_writers_key[i], 0);
	}
	init_waitqueue_head(&s->s_writers.wait);
	init_waitqueue_head(&s->s_writers.wait_unfrozen);
	s->s_flags = flags;
	s->s_bdi = &default_backing_dev_info;
	INIT_HLIST_NODE(&s->s_instances);
	INIT_HLIST_BL_HEAD(&s->s_anon);
	INIT_LIST_HEAD(&s->s_inodes);

	if (list_lru_init(&s->s_dentry_lru))
		goto fail;
	if (list_lru_init(&s->s_inode_lru))
		goto fail;

	INIT_LIST_HEAD(&s->s_mounts);
	init_rwsem(&s->s_umount);
	lockdep_set_class(&s->s_umount, &type->s_umount_key);
	/*
	 * sget() can have s_umount recursion.
	 *
	 * When it cannot find a suitable sb, it allocates a new
	 * one (this one), and tries again to find a suitable old
	 * one.
	 *
	 * In case that succeeds, it will acquire the s_umount
	 * lock of the old one. Since these are clearly distrinct
	 * locks, and this object isn't exposed yet, there's no
	 * risk of deadlocks.
	 *
	 * Annotate this by putting this lock in a different
	 * subclass.
	 */
	down_write_nested(&s->s_umount, SINGLE_DEPTH_NESTING);
	s->s_count = 1;
	atomic_set(&s->s_active, 1);
	mutex_init(&s->s_vfs_rename_mutex);
	lockdep_set_class(&s->s_vfs_rename_mutex, &type->s_vfs_rename_key);
	mutex_init(&s->s_dquot.dqio_mutex);
	mutex_init(&s->s_dquot.dqonoff_mutex);
	init_rwsem(&s->s_dquot.dqptr_sem);
	s->s_maxbytes = MAX_NON_LFS;
	s->s_op = &default_op;
	s->s_time_gran = 1000000000;
	s->cleancache_poolid = -1;

	s->s_shrink.seeks = DEFAULT_SEEKS;
	s->s_shrink.scan_objects = super_cache_scan;
	s->s_shrink.count_objects = super_cache_count;
	s->s_shrink.batch = 1024;
	s->s_shrink.flags = SHRINKER_NUMA_AWARE;
	return s;

fail:
	destroy_super(s);
	return NULL;
}
","static struct super_block *alloc_super(struct file_system_type *type, int flags)
{
	struct super_block *s = kzalloc(sizeof(struct super_block),  GFP_USER);
	static const struct super_operations default_op;
	int i;

	if (!s)
		return NULL;

 	if (security_sb_alloc(s))
 		goto fail;
 
#ifdef CONFIG_SMP
	s->s_files = alloc_percpu(struct list_head);
	if (!s->s_files)
		goto fail;
	for_each_possible_cpu(i)
		INIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));
#else
	INIT_LIST_HEAD(&s->s_files);
#endif
 	for (i = 0; i < SB_FREEZE_LEVELS; i++) {
 		if (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)
 			goto fail;
		lockdep_init_map(&s->s_writers.lock_map[i], sb_writers_name[i],
				 &type->s_writers_key[i], 0);
	}
	init_waitqueue_head(&s->s_writers.wait);
	init_waitqueue_head(&s->s_writers.wait_unfrozen);
	s->s_flags = flags;
	s->s_bdi = &default_backing_dev_info;
	INIT_HLIST_NODE(&s->s_instances);
	INIT_HLIST_BL_HEAD(&s->s_anon);
	INIT_LIST_HEAD(&s->s_inodes);

	if (list_lru_init(&s->s_dentry_lru))
		goto fail;
	if (list_lru_init(&s->s_inode_lru))
		goto fail;

	INIT_LIST_HEAD(&s->s_mounts);
	init_rwsem(&s->s_umount);
	lockdep_set_class(&s->s_umount, &type->s_umount_key);
	/*
	 * sget() can have s_umount recursion.
	 *
	 * When it cannot find a suitable sb, it allocates a new
	 * one (this one), and tries again to find a suitable old
	 * one.
	 *
	 * In case that succeeds, it will acquire the s_umount
	 * lock of the old one. Since these are clearly distrinct
	 * locks, and this object isn't exposed yet, there's no
	 * risk of deadlocks.
	 *
	 * Annotate this by putting this lock in a different
	 * subclass.
	 */
	down_write_nested(&s->s_umount, SINGLE_DEPTH_NESTING);
	s->s_count = 1;
	atomic_set(&s->s_active, 1);
	mutex_init(&s->s_vfs_rename_mutex);
	lockdep_set_class(&s->s_vfs_rename_mutex, &type->s_vfs_rename_key);
	mutex_init(&s->s_dquot.dqio_mutex);
	mutex_init(&s->s_dquot.dqonoff_mutex);
	init_rwsem(&s->s_dquot.dqptr_sem);
	s->s_maxbytes = MAX_NON_LFS;
	s->s_op = &default_op;
	s->s_time_gran = 1000000000;
	s->cleancache_poolid = -1;

	s->s_shrink.seeks = DEFAULT_SEEKS;
	s->s_shrink.scan_objects = super_cache_scan;
	s->s_shrink.count_objects = super_cache_count;
	s->s_shrink.batch = 1024;
	s->s_shrink.flags = SHRINKER_NUMA_AWARE;
	return s;

fail:
	destroy_super(s);
	return NULL;
}
",C,,"#ifdef CONFIG_SMP
	s->s_files = alloc_percpu(struct list_head);
	if (!s->s_files)
		goto fail;
	for_each_possible_cpu(i)
		INIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));
#else
	INIT_LIST_HEAD(&s->s_files);
#endif
",,"@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)
 	int i;
 	list_lru_destroy(&s->s_dentry_lru);
 	list_lru_destroy(&s->s_inode_lru);
-#ifdef CONFIG_SMP
-	free_percpu(s->s_files);
-#endif
 	for (i = 0; i < SB_FREEZE_LEVELS; i++)
 		percpu_counter_destroy(&s->s_writers.counter[i]);
 	security_sb_free(s);
@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)
 	if (security_sb_alloc(s))
 		goto fail;
 
-#ifdef CONFIG_SMP
-	s->s_files = alloc_percpu(struct list_head);
-	if (!s->s_files)
-		goto fail;
-	for_each_possible_cpu(i)
-		INIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));
-#else
-	INIT_LIST_HEAD(&s->s_files);
-#endif
 	for (i = 0; i < SB_FREEZE_LEVELS; i++) {
 		if (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)
 			goto fail;
@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)
 	   make sure there are no rw files opened */
 	if (remount_ro) {
 		if (force) {
-			mark_files_ro(sb);
+			sb->s_readonly_remount = 1;
+			smp_wmb();
 		} else {
 			retval = sb_prepare_remount_readonly(sb);
 			if (retval)",linux,eee5cc2702929fd41cce28058dc6d6717f723f87,8b61e74ffc6310e1d35a9b51c8463093851f8bcf,1,"static struct super_block *alloc_super(struct file_system_type *type, int flags)
{
	struct super_block *s = kzalloc(sizeof(struct super_block),  GFP_USER);
	static const struct super_operations default_op;
	int i;

	if (!s)
		return NULL;

 	if (security_sb_alloc(s))
 		goto fail;
 
//flaw_line_below:
#ifdef CONFIG_SMP
//flaw_line_below:
	s->s_files = alloc_percpu(struct list_head);
//flaw_line_below:
	if (!s->s_files)
//flaw_line_below:
		goto fail;
//flaw_line_below:
	for_each_possible_cpu(i)
//flaw_line_below:
		INIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));
//flaw_line_below:
#else
//flaw_line_below:
	INIT_LIST_HEAD(&s->s_files);
//flaw_line_below:
#endif
 	for (i = 0; i < SB_FREEZE_LEVELS; i++) {
 		if (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)
 			goto fail;
		lockdep_init_map(&s->s_writers.lock_map[i], sb_writers_name[i],
				 &type->s_writers_key[i], 0);
	}
	init_waitqueue_head(&s->s_writers.wait);
	init_waitqueue_head(&s->s_writers.wait_unfrozen);
	s->s_flags = flags;
	s->s_bdi = &default_backing_dev_info;
	INIT_HLIST_NODE(&s->s_instances);
	INIT_HLIST_BL_HEAD(&s->s_anon);
	INIT_LIST_HEAD(&s->s_inodes);

	if (list_lru_init(&s->s_dentry_lru))
		goto fail;
	if (list_lru_init(&s->s_inode_lru))
		goto fail;

	INIT_LIST_HEAD(&s->s_mounts);
	init_rwsem(&s->s_umount);
	lockdep_set_class(&s->s_umount, &type->s_umount_key);
	/*
	 * sget() can have s_umount recursion.
	 *
	 * When it cannot find a suitable sb, it allocates a new
	 * one (this one), and tries again to find a suitable old
	 * one.
	 *
	 * In case that succeeds, it will acquire the s_umount
	 * lock of the old one. Since these are clearly distrinct
	 * locks, and this object isn't exposed yet, there's no
	 * risk of deadlocks.
	 *
	 * Annotate this by putting this lock in a different
	 * subclass.
	 */
	down_write_nested(&s->s_umount, SINGLE_DEPTH_NESTING);
	s->s_count = 1;
	atomic_set(&s->s_active, 1);
	mutex_init(&s->s_vfs_rename_mutex);
	lockdep_set_class(&s->s_vfs_rename_mutex, &type->s_vfs_rename_key);
	mutex_init(&s->s_dquot.dqio_mutex);
	mutex_init(&s->s_dquot.dqonoff_mutex);
	init_rwsem(&s->s_dquot.dqptr_sem);
	s->s_maxbytes = MAX_NON_LFS;
	s->s_op = &default_op;
	s->s_time_gran = 1000000000;
	s->cleancache_poolid = -1;

	s->s_shrink.seeks = DEFAULT_SEEKS;
	s->s_shrink.scan_objects = super_cache_scan;
	s->s_shrink.count_objects = super_cache_count;
	s->s_shrink.batch = 1024;
	s->s_shrink.flags = SHRINKER_NUMA_AWARE;
	return s;

fail:
	destroy_super(s);
	return NULL;
}
"
2243,179979,,Local,Not required,Complete,CVE-2014-8172,https://www.cvedetails.com/cve/CVE-2014-8172/,CWE-17,Low,,,,2015-03-16,4.9,"The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations.",2015-03-23,DoS ,0,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,eee5cc2702929fd41cce28058dc6d6717f723f87,"get rid of s_files and files_lock

The only thing we need it for is alt-sysrq-r (emergency remount r/o)
and these days we can do just as well without going through the
list of files.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",3,fs/super.c,"{""sha"": ""23b6dca03ba06f4da0553b1db70f6911098382fc"", ""filename"": ""fs/file_table.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 125, ""changes"": 125, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/file_table.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {\n \t.max_files = NR_FILE\n };\n \n-DEFINE_STATIC_LGLOCK(files_lglock);\n-\n /* SLAB cache for file structures */\n static struct kmem_cache *filp_cachep __read_mostly;\n \n@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)\n \t\treturn ERR_PTR(error);\n \t}\n \n-\tINIT_LIST_HEAD(&f->f_u.fu_list);\n \tatomic_long_set(&f->f_count, 1);\n \trwlock_init(&f->f_owner.lock);\n \tspin_lock_init(&f->f_lock);\n@@ -304,7 +301,6 @@ void fput(struct file *file)\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n \n-\t\tfile_sb_list_del(file);\n \t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n \t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n \t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n-\t\tfile_sb_list_del(file);\n \t\tBUG_ON(!(task->flags & PF_KTHREAD));\n \t\t__fput(file);\n \t}\n@@ -345,129 +340,10 @@ void put_filp(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tsecurity_file_free(file);\n-\t\tfile_sb_list_del(file);\n \t\tfile_free(file);\n \t}\n }\n \n-static inline int file_list_cpu(struct file *file)\n-{\n-#ifdef CONFIG_SMP\n-\treturn file->f_sb_list_cpu;\n-#else\n-\treturn smp_processor_id();\n-#endif\n-}\n-\n-/* helper for file_sb_list_add to reduce ifdefs */\n-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tstruct list_head *list;\n-#ifdef CONFIG_SMP\n-\tint cpu;\n-\tcpu = smp_processor_id();\n-\tfile->f_sb_list_cpu = cpu;\n-\tlist = per_cpu_ptr(sb->s_files, cpu);\n-#else\n-\tlist = &sb->s_files;\n-#endif\n-\tlist_add(&file->f_u.fu_list, list);\n-}\n-\n-/**\n- * file_sb_list_add - add a file to the sb's file list\n- * @file: file to add\n- * @sb: sb to add it to\n- *\n- * Use this function to associate a file with the superblock of the inode it\n- * refers to.\n- */\n-void file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tif (likely(!(file->f_mode & FMODE_WRITE)))\n-\t\treturn;\n-\tif (!S_ISREG(file_inode(file)->i_mode))\n-\t\treturn;\n-\tlg_local_lock(&files_lglock);\n-\t__file_sb_list_add(file, sb);\n-\tlg_local_unlock(&files_lglock);\n-}\n-\n-/**\n- * file_sb_list_del - remove a file from the sb's file list\n- * @file: file to remove\n- * @sb: sb to remove it from\n- *\n- * Use this function to remove a file from its superblock.\n- */\n-void file_sb_list_del(struct file *file)\n-{\n-\tif (!list_empty(&file->f_u.fu_list)) {\n-\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n-\t\tlist_del_init(&file->f_u.fu_list);\n-\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n-\t}\n-}\n-\n-#ifdef CONFIG_SMP\n-\n-/*\n- * These macros iterate all files on all CPUs for a given superblock.\n- * files_lglock must be held globally.\n- */\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tint i;\t\t\t\t\t\t\t\\\n-\tfor_each_possible_cpu(i) {\t\t\t\t\\\n-\t\tstruct list_head *list;\t\t\t\t\\\n-\t\tlist = per_cpu_ptr((__sb)->s_files, i);\t\t\\\n-\t\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-}\n-\n-#else\n-\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tstruct list_head *list;\t\t\t\t\t\\\n-\tlist = &(sb)->s_files;\t\t\t\t\t\\\n-\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-}\n-\n-#endif\n-\n-/**\n- *\tmark_files_ro - mark all files read-only\n- *\t@sb: superblock in question\n- *\n- *\tAll files are marked read-only.  We don't care about pending\n- *\tdelete files so this should be used in 'force' mode only.\n- */\n-void mark_files_ro(struct super_block *sb)\n-{\n-\tstruct file *f;\n-\n-\tlg_global_lock(&files_lglock);\n-\tdo_file_list_for_each_entry(sb, f) {\n-\t\tif (!file_count(f))\n-\t\t\tcontinue;\n-\t\tif (!(f->f_mode & FMODE_WRITE))\n-\t\t\tcontinue;\n-\t\tspin_lock(&f->f_lock);\n-\t\tf->f_mode &= ~FMODE_WRITE;\n-\t\tspin_unlock(&f->f_lock);\n-\t\tif (file_check_writeable(f) != 0)\n-\t\t\tcontinue;\n-\t\t__mnt_drop_write(f->f_path.mnt);\n-\t\tfile_release_write(f);\n-\t} while_file_list_for_each_entry;\n-\tlg_global_unlock(&files_lglock);\n-}\n-\n void __init files_init(unsigned long mempages)\n { \n \tunsigned long n;\n@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)\n \tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n \tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n \tfiles_defer_init();\n-\tlg_lock_init(&files_lglock, \""files_lglock\"");\n \tpercpu_counter_init(&nr_files, 0);\n } ""}<_**next**_>{""sha"": ""4657424074668dcb933c8d375244b1d3b9d72561"", ""filename"": ""fs/internal.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/internal.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -73,9 +73,6 @@ extern void chroot_fs_refs(const struct path *, const struct path *);\n /*\n  * file_table.c\n  */\n-extern void file_sb_list_add(struct file *f, struct super_block *sb);\n-extern void file_sb_list_del(struct file *f);\n-extern void mark_files_ro(struct super_block *);\n extern struct file *get_empty_filp(void);\n \n /*""}<_**next**_>{""sha"": ""fffbed40dbe9e24dc6129878cf65527e241d4d48"", ""filename"": ""fs/open.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/open.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -685,7 +685,6 @@ static int do_dentry_open(struct file *f,\n \t}\n \n \tf->f_mapping = inode->i_mapping;\n-\tfile_sb_list_add(f, inode->i_sb);\n \n \tif (unlikely(f->f_mode & FMODE_PATH)) {\n \t\tf->f_op = &empty_fops;\n@@ -724,7 +723,6 @@ static int do_dentry_open(struct file *f,\n \n cleanup_all:\n \tfops_put(f->f_op);\n-\tfile_sb_list_del(f);\n \tif (f->f_mode & FMODE_WRITE) {\n \t\tput_write_access(inode);\n \t\tif (!special_file(inode->i_mode)) {""}<_**next**_>{""sha"": ""e5f6c2cfac380a7c4503dcebb0b3e310841893f0"", ""filename"": ""fs/super.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 13, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/super.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)\n \tint i;\n \tlist_lru_destroy(&s->s_dentry_lru);\n \tlist_lru_destroy(&s->s_inode_lru);\n-#ifdef CONFIG_SMP\n-\tfree_percpu(s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n \t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n \tsecurity_sb_free(s);\n@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)\n \tif (security_sb_alloc(s))\n \t\tgoto fail;\n \n-#ifdef CONFIG_SMP\n-\ts->s_files = alloc_percpu(struct list_head);\n-\tif (!s->s_files)\n-\t\tgoto fail;\n-\tfor_each_possible_cpu(i)\n-\t\tINIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));\n-#else\n-\tINIT_LIST_HEAD(&s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n \t\tif (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)\n \t\t\tgoto fail;\n@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n-\t\t\tmark_files_ro(sb);\n+\t\t\tsb->s_readonly_remount = 1;\n+\t\t\tsmp_wmb();\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)""}<_**next**_>{""sha"": ""2b0f4e974480c353a90654e634cc6f4a6d1293c4"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 13, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -764,12 +764,7 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n #define FILE_MNT_WRITE_RELEASED\t2\n \n struct file {\n-\t/*\n-\t * fu_list becomes invalid after file_free is called and queued via\n-\t * fu_rcuhead for RCU freeing\n-\t */\n \tunion {\n-\t\tstruct list_head\tfu_list;\n \t\tstruct llist_node\tfu_llist;\n \t\tstruct rcu_head \tfu_rcuhead;\n \t} f_u;\n@@ -783,9 +778,6 @@ struct file {\n \t * Must not be taken from IRQ context.\n \t */\n \tspinlock_t\t\tf_lock;\n-#ifdef CONFIG_SMP\n-\tint\t\t\tf_sb_list_cpu;\n-#endif\n \tatomic_long_t\t\tf_count;\n \tunsigned int \t\tf_flags;\n \tfmode_t\t\t\tf_mode;\n@@ -1264,11 +1256,6 @@ struct super_block {\n \n \tstruct list_head\ts_inodes;\t/* all inodes */\n \tstruct hlist_bl_head\ts_anon;\t\t/* anonymous dentries for (nfs) exporting */\n-#ifdef CONFIG_SMP\n-\tstruct list_head __percpu *s_files;\n-#else\n-\tstruct list_head\ts_files;\n-#endif\n \tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n \tstruct block_device\t*s_bdev;\n \tstruct backing_dev_info *s_bdi;""}","static void destroy_super(struct super_block *s)
{
 	int i;
 	list_lru_destroy(&s->s_dentry_lru);
 	list_lru_destroy(&s->s_inode_lru);
 	for (i = 0; i < SB_FREEZE_LEVELS; i++)
 		percpu_counter_destroy(&s->s_writers.counter[i]);
 	security_sb_free(s);
	WARN_ON(!list_empty(&s->s_mounts));
	kfree(s->s_subtype);
	kfree(s->s_options);
	kfree_rcu(s, rcu);
}
","static void destroy_super(struct super_block *s)
{
 	int i;
 	list_lru_destroy(&s->s_dentry_lru);
 	list_lru_destroy(&s->s_inode_lru);
#ifdef CONFIG_SMP
	free_percpu(s->s_files);
#endif
 	for (i = 0; i < SB_FREEZE_LEVELS; i++)
 		percpu_counter_destroy(&s->s_writers.counter[i]);
 	security_sb_free(s);
	WARN_ON(!list_empty(&s->s_mounts));
	kfree(s->s_subtype);
	kfree(s->s_options);
	kfree_rcu(s, rcu);
}
",C,,"#ifdef CONFIG_SMP
	free_percpu(s->s_files);
#endif
",,"@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)
 	int i;
 	list_lru_destroy(&s->s_dentry_lru);
 	list_lru_destroy(&s->s_inode_lru);
-#ifdef CONFIG_SMP
-	free_percpu(s->s_files);
-#endif
 	for (i = 0; i < SB_FREEZE_LEVELS; i++)
 		percpu_counter_destroy(&s->s_writers.counter[i]);
 	security_sb_free(s);
@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)
 	if (security_sb_alloc(s))
 		goto fail;
 
-#ifdef CONFIG_SMP
-	s->s_files = alloc_percpu(struct list_head);
-	if (!s->s_files)
-		goto fail;
-	for_each_possible_cpu(i)
-		INIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));
-#else
-	INIT_LIST_HEAD(&s->s_files);
-#endif
 	for (i = 0; i < SB_FREEZE_LEVELS; i++) {
 		if (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)
 			goto fail;
@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)
 	   make sure there are no rw files opened */
 	if (remount_ro) {
 		if (force) {
-			mark_files_ro(sb);
+			sb->s_readonly_remount = 1;
+			smp_wmb();
 		} else {
 			retval = sb_prepare_remount_readonly(sb);
 			if (retval)",linux,eee5cc2702929fd41cce28058dc6d6717f723f87,8b61e74ffc6310e1d35a9b51c8463093851f8bcf,1,"static void destroy_super(struct super_block *s)
{
 	int i;
 	list_lru_destroy(&s->s_dentry_lru);
 	list_lru_destroy(&s->s_inode_lru);
//flaw_line_below:
#ifdef CONFIG_SMP
//flaw_line_below:
	free_percpu(s->s_files);
//flaw_line_below:
#endif
 	for (i = 0; i < SB_FREEZE_LEVELS; i++)
 		percpu_counter_destroy(&s->s_writers.counter[i]);
 	security_sb_free(s);
	WARN_ON(!list_empty(&s->s_mounts));
	kfree(s->s_subtype);
	kfree(s->s_options);
	kfree_rcu(s, rcu);
}
"
2244,179980,,Local,Not required,Complete,CVE-2014-8172,https://www.cvedetails.com/cve/CVE-2014-8172/,CWE-17,Low,,,,2015-03-16,4.9,"The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations.",2015-03-23,DoS ,2,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,eee5cc2702929fd41cce28058dc6d6717f723f87,"get rid of s_files and files_lock

The only thing we need it for is alt-sysrq-r (emergency remount r/o)
and these days we can do just as well without going through the
list of files.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",1,fs/super.c,"{""sha"": ""23b6dca03ba06f4da0553b1db70f6911098382fc"", ""filename"": ""fs/file_table.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 125, ""changes"": 125, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/file_table.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/file_table.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {\n \t.max_files = NR_FILE\n };\n \n-DEFINE_STATIC_LGLOCK(files_lglock);\n-\n /* SLAB cache for file structures */\n static struct kmem_cache *filp_cachep __read_mostly;\n \n@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)\n \t\treturn ERR_PTR(error);\n \t}\n \n-\tINIT_LIST_HEAD(&f->f_u.fu_list);\n \tatomic_long_set(&f->f_count, 1);\n \trwlock_init(&f->f_owner.lock);\n \tspin_lock_init(&f->f_lock);\n@@ -304,7 +301,6 @@ void fput(struct file *file)\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n \n-\t\tfile_sb_list_del(file);\n \t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n \t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n \t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n@@ -333,7 +329,6 @@ void __fput_sync(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tstruct task_struct *task = current;\n-\t\tfile_sb_list_del(file);\n \t\tBUG_ON(!(task->flags & PF_KTHREAD));\n \t\t__fput(file);\n \t}\n@@ -345,129 +340,10 @@ void put_filp(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tsecurity_file_free(file);\n-\t\tfile_sb_list_del(file);\n \t\tfile_free(file);\n \t}\n }\n \n-static inline int file_list_cpu(struct file *file)\n-{\n-#ifdef CONFIG_SMP\n-\treturn file->f_sb_list_cpu;\n-#else\n-\treturn smp_processor_id();\n-#endif\n-}\n-\n-/* helper for file_sb_list_add to reduce ifdefs */\n-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tstruct list_head *list;\n-#ifdef CONFIG_SMP\n-\tint cpu;\n-\tcpu = smp_processor_id();\n-\tfile->f_sb_list_cpu = cpu;\n-\tlist = per_cpu_ptr(sb->s_files, cpu);\n-#else\n-\tlist = &sb->s_files;\n-#endif\n-\tlist_add(&file->f_u.fu_list, list);\n-}\n-\n-/**\n- * file_sb_list_add - add a file to the sb's file list\n- * @file: file to add\n- * @sb: sb to add it to\n- *\n- * Use this function to associate a file with the superblock of the inode it\n- * refers to.\n- */\n-void file_sb_list_add(struct file *file, struct super_block *sb)\n-{\n-\tif (likely(!(file->f_mode & FMODE_WRITE)))\n-\t\treturn;\n-\tif (!S_ISREG(file_inode(file)->i_mode))\n-\t\treturn;\n-\tlg_local_lock(&files_lglock);\n-\t__file_sb_list_add(file, sb);\n-\tlg_local_unlock(&files_lglock);\n-}\n-\n-/**\n- * file_sb_list_del - remove a file from the sb's file list\n- * @file: file to remove\n- * @sb: sb to remove it from\n- *\n- * Use this function to remove a file from its superblock.\n- */\n-void file_sb_list_del(struct file *file)\n-{\n-\tif (!list_empty(&file->f_u.fu_list)) {\n-\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n-\t\tlist_del_init(&file->f_u.fu_list);\n-\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n-\t}\n-}\n-\n-#ifdef CONFIG_SMP\n-\n-/*\n- * These macros iterate all files on all CPUs for a given superblock.\n- * files_lglock must be held globally.\n- */\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tint i;\t\t\t\t\t\t\t\\\n-\tfor_each_possible_cpu(i) {\t\t\t\t\\\n-\t\tstruct list_head *list;\t\t\t\t\\\n-\t\tlist = per_cpu_ptr((__sb)->s_files, i);\t\t\\\n-\t\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-}\n-\n-#else\n-\n-#define do_file_list_for_each_entry(__sb, __file)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-\tstruct list_head *list;\t\t\t\t\t\\\n-\tlist = &(sb)->s_files;\t\t\t\t\t\\\n-\tlist_for_each_entry((__file), list, f_u.fu_list)\n-\n-#define while_file_list_for_each_entry\t\t\t\t\\\n-}\n-\n-#endif\n-\n-/**\n- *\tmark_files_ro - mark all files read-only\n- *\t@sb: superblock in question\n- *\n- *\tAll files are marked read-only.  We don't care about pending\n- *\tdelete files so this should be used in 'force' mode only.\n- */\n-void mark_files_ro(struct super_block *sb)\n-{\n-\tstruct file *f;\n-\n-\tlg_global_lock(&files_lglock);\n-\tdo_file_list_for_each_entry(sb, f) {\n-\t\tif (!file_count(f))\n-\t\t\tcontinue;\n-\t\tif (!(f->f_mode & FMODE_WRITE))\n-\t\t\tcontinue;\n-\t\tspin_lock(&f->f_lock);\n-\t\tf->f_mode &= ~FMODE_WRITE;\n-\t\tspin_unlock(&f->f_lock);\n-\t\tif (file_check_writeable(f) != 0)\n-\t\t\tcontinue;\n-\t\t__mnt_drop_write(f->f_path.mnt);\n-\t\tfile_release_write(f);\n-\t} while_file_list_for_each_entry;\n-\tlg_global_unlock(&files_lglock);\n-}\n-\n void __init files_init(unsigned long mempages)\n { \n \tunsigned long n;\n@@ -483,6 +359,5 @@ void __init files_init(unsigned long mempages)\n \tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n \tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n \tfiles_defer_init();\n-\tlg_lock_init(&files_lglock, \""files_lglock\"");\n \tpercpu_counter_init(&nr_files, 0);\n } ""}<_**next**_>{""sha"": ""4657424074668dcb933c8d375244b1d3b9d72561"", ""filename"": ""fs/internal.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/internal.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -73,9 +73,6 @@ extern void chroot_fs_refs(const struct path *, const struct path *);\n /*\n  * file_table.c\n  */\n-extern void file_sb_list_add(struct file *f, struct super_block *sb);\n-extern void file_sb_list_del(struct file *f);\n-extern void mark_files_ro(struct super_block *);\n extern struct file *get_empty_filp(void);\n \n /*""}<_**next**_>{""sha"": ""fffbed40dbe9e24dc6129878cf65527e241d4d48"", ""filename"": ""fs/open.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/open.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/open.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -685,7 +685,6 @@ static int do_dentry_open(struct file *f,\n \t}\n \n \tf->f_mapping = inode->i_mapping;\n-\tfile_sb_list_add(f, inode->i_sb);\n \n \tif (unlikely(f->f_mode & FMODE_PATH)) {\n \t\tf->f_op = &empty_fops;\n@@ -724,7 +723,6 @@ static int do_dentry_open(struct file *f,\n \n cleanup_all:\n \tfops_put(f->f_op);\n-\tfile_sb_list_del(f);\n \tif (f->f_mode & FMODE_WRITE) {\n \t\tput_write_access(inode);\n \t\tif (!special_file(inode->i_mode)) {""}<_**next**_>{""sha"": ""e5f6c2cfac380a7c4503dcebb0b3e310841893f0"", ""filename"": ""fs/super.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 13, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/fs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/super.c?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)\n \tint i;\n \tlist_lru_destroy(&s->s_dentry_lru);\n \tlist_lru_destroy(&s->s_inode_lru);\n-#ifdef CONFIG_SMP\n-\tfree_percpu(s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n \t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n \tsecurity_sb_free(s);\n@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)\n \tif (security_sb_alloc(s))\n \t\tgoto fail;\n \n-#ifdef CONFIG_SMP\n-\ts->s_files = alloc_percpu(struct list_head);\n-\tif (!s->s_files)\n-\t\tgoto fail;\n-\tfor_each_possible_cpu(i)\n-\t\tINIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));\n-#else\n-\tINIT_LIST_HEAD(&s->s_files);\n-#endif\n \tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n \t\tif (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)\n \t\t\tgoto fail;\n@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n-\t\t\tmark_files_ro(sb);\n+\t\t\tsb->s_readonly_remount = 1;\n+\t\t\tsmp_wmb();\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)""}<_**next**_>{""sha"": ""2b0f4e974480c353a90654e634cc6f4a6d1293c4"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 13, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eee5cc2702929fd41cce28058dc6d6717f723f87/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=eee5cc2702929fd41cce28058dc6d6717f723f87"", ""patch"": ""@@ -764,12 +764,7 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n #define FILE_MNT_WRITE_RELEASED\t2\n \n struct file {\n-\t/*\n-\t * fu_list becomes invalid after file_free is called and queued via\n-\t * fu_rcuhead for RCU freeing\n-\t */\n \tunion {\n-\t\tstruct list_head\tfu_list;\n \t\tstruct llist_node\tfu_llist;\n \t\tstruct rcu_head \tfu_rcuhead;\n \t} f_u;\n@@ -783,9 +778,6 @@ struct file {\n \t * Must not be taken from IRQ context.\n \t */\n \tspinlock_t\t\tf_lock;\n-#ifdef CONFIG_SMP\n-\tint\t\t\tf_sb_list_cpu;\n-#endif\n \tatomic_long_t\t\tf_count;\n \tunsigned int \t\tf_flags;\n \tfmode_t\t\t\tf_mode;\n@@ -1264,11 +1256,6 @@ struct super_block {\n \n \tstruct list_head\ts_inodes;\t/* all inodes */\n \tstruct hlist_bl_head\ts_anon;\t\t/* anonymous dentries for (nfs) exporting */\n-#ifdef CONFIG_SMP\n-\tstruct list_head __percpu *s_files;\n-#else\n-\tstruct list_head\ts_files;\n-#endif\n \tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n \tstruct block_device\t*s_bdev;\n \tstruct backing_dev_info *s_bdi;""}","int do_remount_sb(struct super_block *sb, int flags, void *data, int force)
{
	int retval;
	int remount_ro;

	if (sb->s_writers.frozen != SB_UNFROZEN)
		return -EBUSY;

#ifdef CONFIG_BLOCK
	if (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))
		return -EACCES;
#endif

	if (flags & MS_RDONLY)
		acct_auto_close(sb);
	shrink_dcache_sb(sb);
	sync_filesystem(sb);

	remount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);

	/* If we are remounting RDONLY and current sb is read/write,
 	   make sure there are no rw files opened */
 	if (remount_ro) {
 		if (force) {
			sb->s_readonly_remount = 1;
			smp_wmb();
 		} else {
 			retval = sb_prepare_remount_readonly(sb);
 			if (retval)
				return retval;
		}
	}

	if (sb->s_op->remount_fs) {
		retval = sb->s_op->remount_fs(sb, &flags, data);
		if (retval) {
			if (!force)
				goto cancel_readonly;
			/* If forced remount, go ahead despite any errors */
			WARN(1, ""forced remount of a %s fs returned %i\n"",
			     sb->s_type->name, retval);
		}
	}
	sb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);
	/* Needs to be ordered wrt mnt_is_readonly() */
	smp_wmb();
	sb->s_readonly_remount = 0;

	/*
	 * Some filesystems modify their metadata via some other path than the
	 * bdev buffer cache (eg. use a private mapping, or directories in
	 * pagecache, etc). Also file data modifications go via their own
	 * mappings. So If we try to mount readonly then copy the filesystem
	 * from bdev, we could get stale data, so invalidate it to give a best
	 * effort at coherency.
	 */
	if (remount_ro && sb->s_bdev)
		invalidate_bdev(sb->s_bdev);
	return 0;

cancel_readonly:
	sb->s_readonly_remount = 0;
	return retval;
}
","int do_remount_sb(struct super_block *sb, int flags, void *data, int force)
{
	int retval;
	int remount_ro;

	if (sb->s_writers.frozen != SB_UNFROZEN)
		return -EBUSY;

#ifdef CONFIG_BLOCK
	if (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))
		return -EACCES;
#endif

	if (flags & MS_RDONLY)
		acct_auto_close(sb);
	shrink_dcache_sb(sb);
	sync_filesystem(sb);

	remount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);

	/* If we are remounting RDONLY and current sb is read/write,
 	   make sure there are no rw files opened */
 	if (remount_ro) {
 		if (force) {
			mark_files_ro(sb);
 		} else {
 			retval = sb_prepare_remount_readonly(sb);
 			if (retval)
				return retval;
		}
	}

	if (sb->s_op->remount_fs) {
		retval = sb->s_op->remount_fs(sb, &flags, data);
		if (retval) {
			if (!force)
				goto cancel_readonly;
			/* If forced remount, go ahead despite any errors */
			WARN(1, ""forced remount of a %s fs returned %i\n"",
			     sb->s_type->name, retval);
		}
	}
	sb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);
	/* Needs to be ordered wrt mnt_is_readonly() */
	smp_wmb();
	sb->s_readonly_remount = 0;

	/*
	 * Some filesystems modify their metadata via some other path than the
	 * bdev buffer cache (eg. use a private mapping, or directories in
	 * pagecache, etc). Also file data modifications go via their own
	 * mappings. So If we try to mount readonly then copy the filesystem
	 * from bdev, we could get stale data, so invalidate it to give a best
	 * effort at coherency.
	 */
	if (remount_ro && sb->s_bdev)
		invalidate_bdev(sb->s_bdev);
	return 0;

cancel_readonly:
	sb->s_readonly_remount = 0;
	return retval;
}
",C,"			sb->s_readonly_remount = 1;
			smp_wmb();
","			mark_files_ro(sb);
",,"@@ -140,9 +140,6 @@ static void destroy_super(struct super_block *s)
 	int i;
 	list_lru_destroy(&s->s_dentry_lru);
 	list_lru_destroy(&s->s_inode_lru);
-#ifdef CONFIG_SMP
-	free_percpu(s->s_files);
-#endif
 	for (i = 0; i < SB_FREEZE_LEVELS; i++)
 		percpu_counter_destroy(&s->s_writers.counter[i]);
 	security_sb_free(s);
@@ -172,15 +169,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)
 	if (security_sb_alloc(s))
 		goto fail;
 
-#ifdef CONFIG_SMP
-	s->s_files = alloc_percpu(struct list_head);
-	if (!s->s_files)
-		goto fail;
-	for_each_possible_cpu(i)
-		INIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));
-#else
-	INIT_LIST_HEAD(&s->s_files);
-#endif
 	for (i = 0; i < SB_FREEZE_LEVELS; i++) {
 		if (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)
 			goto fail;
@@ -722,7 +710,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)
 	   make sure there are no rw files opened */
 	if (remount_ro) {
 		if (force) {
-			mark_files_ro(sb);
+			sb->s_readonly_remount = 1;
+			smp_wmb();
 		} else {
 			retval = sb_prepare_remount_readonly(sb);
 			if (retval)",linux,eee5cc2702929fd41cce28058dc6d6717f723f87,8b61e74ffc6310e1d35a9b51c8463093851f8bcf,1,"int do_remount_sb(struct super_block *sb, int flags, void *data, int force)
{
	int retval;
	int remount_ro;

	if (sb->s_writers.frozen != SB_UNFROZEN)
		return -EBUSY;

#ifdef CONFIG_BLOCK
	if (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))
		return -EACCES;
#endif

	if (flags & MS_RDONLY)
		acct_auto_close(sb);
	shrink_dcache_sb(sb);
	sync_filesystem(sb);

	remount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);

	/* If we are remounting RDONLY and current sb is read/write,
 	   make sure there are no rw files opened */
 	if (remount_ro) {
 		if (force) {
//flaw_line_below:
			mark_files_ro(sb);
//fix_flaw_line_below:
//			sb->s_readonly_remount = 1;
//fix_flaw_line_below:
//			smp_wmb();
 		} else {
 			retval = sb_prepare_remount_readonly(sb);
 			if (retval)
				return retval;
		}
	}

	if (sb->s_op->remount_fs) {
		retval = sb->s_op->remount_fs(sb, &flags, data);
		if (retval) {
			if (!force)
				goto cancel_readonly;
			/* If forced remount, go ahead despite any errors */
			WARN(1, ""forced remount of a %s fs returned %i\n"",
			     sb->s_type->name, retval);
		}
	}
	sb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);
	/* Needs to be ordered wrt mnt_is_readonly() */
	smp_wmb();
	sb->s_readonly_remount = 0;

	/*
	 * Some filesystems modify their metadata via some other path than the
	 * bdev buffer cache (eg. use a private mapping, or directories in
	 * pagecache, etc). Also file data modifications go via their own
	 * mappings. So If we try to mount readonly then copy the filesystem
	 * from bdev, we could get stale data, so invalidate it to give a best
	 * effort at coherency.
	 */
	if (remount_ro && sb->s_bdev)
		invalidate_bdev(sb->s_bdev);
	return 0;

cancel_readonly:
	sb->s_readonly_remount = 0;
	return retval;
}
"
5363,183099,,Local,Not required,Complete,CVE-2015-1805,https://www.cvedetails.com/cve/CVE-2015-1805/,CWE-17,Low,Complete,Complete,,2015-08-08,7.2,"The (1) pipe_read and (2) pipe_write implementations in fs/pipe.c in the Linux kernel before 3.16 do not properly consider the side effects of failed __copy_to_user_inatomic and __copy_from_user_inatomic calls, which allows local users to cause a denial of service (system crash) or possibly gain privileges via a crafted application, aka an *I/O vector array overrun.*",2018-01-04,DoS +Priv ,0,https://github.com/torvalds/linux/commit/637b58c2887e5e57850865839cc75f59184b23d1,637b58c2887e5e57850865839cc75f59184b23d1,"switch pipe_read() to copy_page_to_iter()

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",13,fs/pipe.c,"{""sha"": ""034bffac3f9724c6121f4635ba9740d61e106d06"", ""filename"": ""fs/pipe.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 71, ""changes"": 79, ""blob_url"": ""https://github.com/torvalds/linux/blob/637b58c2887e5e57850865839cc75f59184b23d1/fs/pipe.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/637b58c2887e5e57850865839cc75f59184b23d1/fs/pipe.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pipe.c?ref=637b58c2887e5e57850865839cc75f59184b23d1"", ""patch"": ""@@ -142,55 +142,6 @@ pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,\n \treturn 0;\n }\n \n-static int\n-pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,\n-\t\t      int atomic)\n-{\n-\tunsigned long copy;\n-\n-\twhile (len > 0) {\n-\t\twhile (!iov->iov_len)\n-\t\t\tiov++;\n-\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n-\n-\t\tif (atomic) {\n-\t\t\tif (__copy_to_user_inatomic(iov->iov_base, from, copy))\n-\t\t\t\treturn -EFAULT;\n-\t\t} else {\n-\t\t\tif (copy_to_user(iov->iov_base, from, copy))\n-\t\t\t\treturn -EFAULT;\n-\t\t}\n-\t\tfrom += copy;\n-\t\tlen -= copy;\n-\t\tiov->iov_base += copy;\n-\t\tiov->iov_len -= copy;\n-\t}\n-\treturn 0;\n-}\n-\n-/*\n- * Attempt to pre-fault in the user memory, so we can use atomic copies.\n- * Returns the number of bytes not faulted in.\n- */\n-static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)\n-{\n-\twhile (!iov->iov_len)\n-\t\tiov++;\n-\n-\twhile (len > 0) {\n-\t\tunsigned long this_len;\n-\n-\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n-\t\tif (fault_in_pages_writeable(iov->iov_base, this_len))\n-\t\t\tbreak;\n-\n-\t\tlen -= this_len;\n-\t\tiov++;\n-\t}\n-\n-\treturn len;\n-}\n-\n /*\n  * Pre-fault in the user memory, so we can use atomic copies.\n  */\n@@ -329,12 +280,15 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,\n \tssize_t ret;\n \tstruct iovec *iov = (struct iovec *)_iov;\n \tsize_t total_len;\n+\tstruct iov_iter iter;\n \n \ttotal_len = iov_length(iov, nr_segs);\n \t/* Null read succeeds. */\n \tif (unlikely(total_len == 0))\n \t\treturn 0;\n \n+\tiov_iter_init(&iter, iov, nr_segs, total_len, 0);\n+\n \tdo_wakeup = 0;\n \tret = 0;\n \t__pipe_lock(pipe);\n@@ -344,9 +298,9 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,\n \t\t\tint curbuf = pipe->curbuf;\n \t\t\tstruct pipe_buffer *buf = pipe->bufs + curbuf;\n \t\t\tconst struct pipe_buf_operations *ops = buf->ops;\n-\t\t\tvoid *addr;\n \t\t\tsize_t chars = buf->len;\n-\t\t\tint error, atomic;\n+\t\t\tsize_t written;\n+\t\t\tint error;\n \n \t\t\tif (chars > total_len)\n \t\t\t\tchars = total_len;\n@@ -358,27 +312,10 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,\n \t\t\t\tbreak;\n \t\t\t}\n \n-\t\t\tatomic = !iov_fault_in_pages_write(iov, chars);\n-redo:\n-\t\t\tif (atomic)\n-\t\t\t\taddr = kmap_atomic(buf->page);\n-\t\t\telse\n-\t\t\t\taddr = kmap(buf->page);\n-\t\t\terror = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);\n-\t\t\tif (atomic)\n-\t\t\t\tkunmap_atomic(addr);\n-\t\t\telse\n-\t\t\t\tkunmap(buf->page);\n-\t\t\tif (unlikely(error)) {\n-\t\t\t\t/*\n-\t\t\t\t * Just retry with the slow path if we failed.\n-\t\t\t\t */\n-\t\t\t\tif (atomic) {\n-\t\t\t\t\tatomic = 0;\n-\t\t\t\t\tgoto redo;\n-\t\t\t\t}\n+\t\t\twritten = copy_page_to_iter(buf->page, buf->offset, chars, &iter);\n+\t\t\tif (unlikely(written < chars)) {\n \t\t\t\tif (!ret)\n-\t\t\t\t\tret = error;\n+\t\t\t\t\tret = -EFAULT;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tret += chars;""}","static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)
","static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)
{
	while (!iov->iov_len)
		iov++;
	while (len > 0) {
		unsigned long this_len;
		this_len = min_t(unsigned long, len, iov->iov_len);
		if (fault_in_pages_writeable(iov->iov_base, this_len))
			break;
		len -= this_len;
		iov++;
	}
	return len;
}
",C,,"{
	while (!iov->iov_len)
		iov++;
	while (len > 0) {
		unsigned long this_len;
		this_len = min_t(unsigned long, len, iov->iov_len);
		if (fault_in_pages_writeable(iov->iov_base, this_len))
			break;
		len -= this_len;
		iov++;
	}
	return len;
}
",,"@@ -142,55 +142,6 @@ pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,
 	return 0;
 }
 
-static int
-pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,
-		      int atomic)
-{
-	unsigned long copy;
-
-	while (len > 0) {
-		while (!iov->iov_len)
-			iov++;
-		copy = min_t(unsigned long, len, iov->iov_len);
-
-		if (atomic) {
-			if (__copy_to_user_inatomic(iov->iov_base, from, copy))
-				return -EFAULT;
-		} else {
-			if (copy_to_user(iov->iov_base, from, copy))
-				return -EFAULT;
-		}
-		from += copy;
-		len -= copy;
-		iov->iov_base += copy;
-		iov->iov_len -= copy;
-	}
-	return 0;
-}
-
-/*
- * Attempt to pre-fault in the user memory, so we can use atomic copies.
- * Returns the number of bytes not faulted in.
- */
-static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)
-{
-	while (!iov->iov_len)
-		iov++;
-
-	while (len > 0) {
-		unsigned long this_len;
-
-		this_len = min_t(unsigned long, len, iov->iov_len);
-		if (fault_in_pages_writeable(iov->iov_base, this_len))
-			break;
-
-		len -= this_len;
-		iov++;
-	}
-
-	return len;
-}
-
 /*
  * Pre-fault in the user memory, so we can use atomic copies.
  */
@@ -329,12 +280,15 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 	ssize_t ret;
 	struct iovec *iov = (struct iovec *)_iov;
 	size_t total_len;
+	struct iov_iter iter;
 
 	total_len = iov_length(iov, nr_segs);
 	/* Null read succeeds. */
 	if (unlikely(total_len == 0))
 		return 0;
 
+	iov_iter_init(&iter, iov, nr_segs, total_len, 0);
+
 	do_wakeup = 0;
 	ret = 0;
 	__pipe_lock(pipe);
@@ -344,9 +298,9 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 			int curbuf = pipe->curbuf;
 			struct pipe_buffer *buf = pipe->bufs + curbuf;
 			const struct pipe_buf_operations *ops = buf->ops;
-			void *addr;
 			size_t chars = buf->len;
-			int error, atomic;
+			size_t written;
+			int error;
 
 			if (chars > total_len)
 				chars = total_len;
@@ -358,27 +312,10 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 				break;
 			}
 
-			atomic = !iov_fault_in_pages_write(iov, chars);
-redo:
-			if (atomic)
-				addr = kmap_atomic(buf->page);
-			else
-				addr = kmap(buf->page);
-			error = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);
-			if (atomic)
-				kunmap_atomic(addr);
-			else
-				kunmap(buf->page);
-			if (unlikely(error)) {
-				/*
-				 * Just retry with the slow path if we failed.
-				 */
-				if (atomic) {
-					atomic = 0;
-					goto redo;
-				}
+			written = copy_page_to_iter(buf->page, buf->offset, chars, &iter);
+			if (unlikely(written < chars)) {
 				if (!ret)
-					ret = error;
+					ret = -EFAULT;
 				break;
 			}
 			ret += chars;",linux,637b58c2887e5e57850865839cc75f59184b23d1,74027f4a181754e917853bd1d2e21449f008ab39,1,"static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)
//flaw_line_below:
{
//flaw_line_below:
	while (!iov->iov_len)
//flaw_line_below:
		iov++;
//flaw_line_below:

//flaw_line_below:
	while (len > 0) {
//flaw_line_below:
		unsigned long this_len;
//flaw_line_below:

//flaw_line_below:
		this_len = min_t(unsigned long, len, iov->iov_len);
//flaw_line_below:
		if (fault_in_pages_writeable(iov->iov_base, this_len))
//flaw_line_below:
			break;
//flaw_line_below:

//flaw_line_below:
		len -= this_len;
//flaw_line_below:
		iov++;
//flaw_line_below:
	}
//flaw_line_below:

//flaw_line_below:
	return len;
//flaw_line_below:
}
"
5364,183100,,Local,Not required,Complete,CVE-2015-1805,https://www.cvedetails.com/cve/CVE-2015-1805/,CWE-17,Low,Complete,Complete,,2015-08-08,7.2,"The (1) pipe_read and (2) pipe_write implementations in fs/pipe.c in the Linux kernel before 3.16 do not properly consider the side effects of failed __copy_to_user_inatomic and __copy_from_user_inatomic calls, which allows local users to cause a denial of service (system crash) or possibly gain privileges via a crafted application, aka an *I/O vector array overrun.*",2018-01-04,DoS +Priv ,0,https://github.com/torvalds/linux/commit/637b58c2887e5e57850865839cc75f59184b23d1,637b58c2887e5e57850865839cc75f59184b23d1,"switch pipe_read() to copy_page_to_iter()

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",21,fs/pipe.c,"{""sha"": ""034bffac3f9724c6121f4635ba9740d61e106d06"", ""filename"": ""fs/pipe.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 71, ""changes"": 79, ""blob_url"": ""https://github.com/torvalds/linux/blob/637b58c2887e5e57850865839cc75f59184b23d1/fs/pipe.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/637b58c2887e5e57850865839cc75f59184b23d1/fs/pipe.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pipe.c?ref=637b58c2887e5e57850865839cc75f59184b23d1"", ""patch"": ""@@ -142,55 +142,6 @@ pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,\n \treturn 0;\n }\n \n-static int\n-pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,\n-\t\t      int atomic)\n-{\n-\tunsigned long copy;\n-\n-\twhile (len > 0) {\n-\t\twhile (!iov->iov_len)\n-\t\t\tiov++;\n-\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n-\n-\t\tif (atomic) {\n-\t\t\tif (__copy_to_user_inatomic(iov->iov_base, from, copy))\n-\t\t\t\treturn -EFAULT;\n-\t\t} else {\n-\t\t\tif (copy_to_user(iov->iov_base, from, copy))\n-\t\t\t\treturn -EFAULT;\n-\t\t}\n-\t\tfrom += copy;\n-\t\tlen -= copy;\n-\t\tiov->iov_base += copy;\n-\t\tiov->iov_len -= copy;\n-\t}\n-\treturn 0;\n-}\n-\n-/*\n- * Attempt to pre-fault in the user memory, so we can use atomic copies.\n- * Returns the number of bytes not faulted in.\n- */\n-static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)\n-{\n-\twhile (!iov->iov_len)\n-\t\tiov++;\n-\n-\twhile (len > 0) {\n-\t\tunsigned long this_len;\n-\n-\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n-\t\tif (fault_in_pages_writeable(iov->iov_base, this_len))\n-\t\t\tbreak;\n-\n-\t\tlen -= this_len;\n-\t\tiov++;\n-\t}\n-\n-\treturn len;\n-}\n-\n /*\n  * Pre-fault in the user memory, so we can use atomic copies.\n  */\n@@ -329,12 +280,15 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,\n \tssize_t ret;\n \tstruct iovec *iov = (struct iovec *)_iov;\n \tsize_t total_len;\n+\tstruct iov_iter iter;\n \n \ttotal_len = iov_length(iov, nr_segs);\n \t/* Null read succeeds. */\n \tif (unlikely(total_len == 0))\n \t\treturn 0;\n \n+\tiov_iter_init(&iter, iov, nr_segs, total_len, 0);\n+\n \tdo_wakeup = 0;\n \tret = 0;\n \t__pipe_lock(pipe);\n@@ -344,9 +298,9 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,\n \t\t\tint curbuf = pipe->curbuf;\n \t\t\tstruct pipe_buffer *buf = pipe->bufs + curbuf;\n \t\t\tconst struct pipe_buf_operations *ops = buf->ops;\n-\t\t\tvoid *addr;\n \t\t\tsize_t chars = buf->len;\n-\t\t\tint error, atomic;\n+\t\t\tsize_t written;\n+\t\t\tint error;\n \n \t\t\tif (chars > total_len)\n \t\t\t\tchars = total_len;\n@@ -358,27 +312,10 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,\n \t\t\t\tbreak;\n \t\t\t}\n \n-\t\t\tatomic = !iov_fault_in_pages_write(iov, chars);\n-redo:\n-\t\t\tif (atomic)\n-\t\t\t\taddr = kmap_atomic(buf->page);\n-\t\t\telse\n-\t\t\t\taddr = kmap(buf->page);\n-\t\t\terror = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);\n-\t\t\tif (atomic)\n-\t\t\t\tkunmap_atomic(addr);\n-\t\t\telse\n-\t\t\t\tkunmap(buf->page);\n-\t\t\tif (unlikely(error)) {\n-\t\t\t\t/*\n-\t\t\t\t * Just retry with the slow path if we failed.\n-\t\t\t\t */\n-\t\t\t\tif (atomic) {\n-\t\t\t\t\tatomic = 0;\n-\t\t\t\t\tgoto redo;\n-\t\t\t\t}\n+\t\t\twritten = copy_page_to_iter(buf->page, buf->offset, chars, &iter);\n+\t\t\tif (unlikely(written < chars)) {\n \t\t\t\tif (!ret)\n-\t\t\t\t\tret = error;\n+\t\t\t\t\tret = -EFAULT;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tret += chars;""}","pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,
","pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,
		      int atomic)
{
	unsigned long copy;
	while (len > 0) {
		while (!iov->iov_len)
			iov++;
		copy = min_t(unsigned long, len, iov->iov_len);
		if (atomic) {
			if (__copy_to_user_inatomic(iov->iov_base, from, copy))
				return -EFAULT;
		} else {
			if (copy_to_user(iov->iov_base, from, copy))
				return -EFAULT;
		}
		from += copy;
		len -= copy;
		iov->iov_base += copy;
		iov->iov_len -= copy;
	}
	return 0;
}
",C,,"		      int atomic)
{
	unsigned long copy;
	while (len > 0) {
		while (!iov->iov_len)
			iov++;
		copy = min_t(unsigned long, len, iov->iov_len);
		if (atomic) {
			if (__copy_to_user_inatomic(iov->iov_base, from, copy))
				return -EFAULT;
		} else {
			if (copy_to_user(iov->iov_base, from, copy))
				return -EFAULT;
		}
		from += copy;
		len -= copy;
		iov->iov_base += copy;
		iov->iov_len -= copy;
	}
	return 0;
}
",,"@@ -142,55 +142,6 @@ pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,
 	return 0;
 }
 
-static int
-pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,
-		      int atomic)
-{
-	unsigned long copy;
-
-	while (len > 0) {
-		while (!iov->iov_len)
-			iov++;
-		copy = min_t(unsigned long, len, iov->iov_len);
-
-		if (atomic) {
-			if (__copy_to_user_inatomic(iov->iov_base, from, copy))
-				return -EFAULT;
-		} else {
-			if (copy_to_user(iov->iov_base, from, copy))
-				return -EFAULT;
-		}
-		from += copy;
-		len -= copy;
-		iov->iov_base += copy;
-		iov->iov_len -= copy;
-	}
-	return 0;
-}
-
-/*
- * Attempt to pre-fault in the user memory, so we can use atomic copies.
- * Returns the number of bytes not faulted in.
- */
-static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)
-{
-	while (!iov->iov_len)
-		iov++;
-
-	while (len > 0) {
-		unsigned long this_len;
-
-		this_len = min_t(unsigned long, len, iov->iov_len);
-		if (fault_in_pages_writeable(iov->iov_base, this_len))
-			break;
-
-		len -= this_len;
-		iov++;
-	}
-
-	return len;
-}
-
 /*
  * Pre-fault in the user memory, so we can use atomic copies.
  */
@@ -329,12 +280,15 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 	ssize_t ret;
 	struct iovec *iov = (struct iovec *)_iov;
 	size_t total_len;
+	struct iov_iter iter;
 
 	total_len = iov_length(iov, nr_segs);
 	/* Null read succeeds. */
 	if (unlikely(total_len == 0))
 		return 0;
 
+	iov_iter_init(&iter, iov, nr_segs, total_len, 0);
+
 	do_wakeup = 0;
 	ret = 0;
 	__pipe_lock(pipe);
@@ -344,9 +298,9 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 			int curbuf = pipe->curbuf;
 			struct pipe_buffer *buf = pipe->bufs + curbuf;
 			const struct pipe_buf_operations *ops = buf->ops;
-			void *addr;
 			size_t chars = buf->len;
-			int error, atomic;
+			size_t written;
+			int error;
 
 			if (chars > total_len)
 				chars = total_len;
@@ -358,27 +312,10 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 				break;
 			}
 
-			atomic = !iov_fault_in_pages_write(iov, chars);
-redo:
-			if (atomic)
-				addr = kmap_atomic(buf->page);
-			else
-				addr = kmap(buf->page);
-			error = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);
-			if (atomic)
-				kunmap_atomic(addr);
-			else
-				kunmap(buf->page);
-			if (unlikely(error)) {
-				/*
-				 * Just retry with the slow path if we failed.
-				 */
-				if (atomic) {
-					atomic = 0;
-					goto redo;
-				}
+			written = copy_page_to_iter(buf->page, buf->offset, chars, &iter);
+			if (unlikely(written < chars)) {
 				if (!ret)
-					ret = error;
+					ret = -EFAULT;
 				break;
 			}
 			ret += chars;",linux,637b58c2887e5e57850865839cc75f59184b23d1,74027f4a181754e917853bd1d2e21449f008ab39,1,"pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,
//flaw_line_below:
		      int atomic)
//flaw_line_below:
{
//flaw_line_below:
	unsigned long copy;
//flaw_line_below:

//flaw_line_below:
	while (len > 0) {
//flaw_line_below:
		while (!iov->iov_len)
//flaw_line_below:
			iov++;
//flaw_line_below:
		copy = min_t(unsigned long, len, iov->iov_len);
//flaw_line_below:

//flaw_line_below:
		if (atomic) {
//flaw_line_below:
			if (__copy_to_user_inatomic(iov->iov_base, from, copy))
//flaw_line_below:
				return -EFAULT;
//flaw_line_below:
		} else {
//flaw_line_below:
			if (copy_to_user(iov->iov_base, from, copy))
//flaw_line_below:
				return -EFAULT;
//flaw_line_below:
		}
//flaw_line_below:
		from += copy;
//flaw_line_below:
		len -= copy;
//flaw_line_below:
		iov->iov_base += copy;
//flaw_line_below:
		iov->iov_len -= copy;
//flaw_line_below:
	}
//flaw_line_below:
	return 0;
//flaw_line_below:
}
"
5365,183101,,Local,Not required,Complete,CVE-2015-1805,https://www.cvedetails.com/cve/CVE-2015-1805/,CWE-17,Low,Complete,Complete,,2015-08-08,7.2,"The (1) pipe_read and (2) pipe_write implementations in fs/pipe.c in the Linux kernel before 3.16 do not properly consider the side effects of failed __copy_to_user_inatomic and __copy_from_user_inatomic calls, which allows local users to cause a denial of service (system crash) or possibly gain privileges via a crafted application, aka an *I/O vector array overrun.*",2018-01-04,DoS +Priv ,8,https://github.com/torvalds/linux/commit/637b58c2887e5e57850865839cc75f59184b23d1,637b58c2887e5e57850865839cc75f59184b23d1,"switch pipe_read() to copy_page_to_iter()

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",22,fs/pipe.c,"{""sha"": ""034bffac3f9724c6121f4635ba9740d61e106d06"", ""filename"": ""fs/pipe.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 71, ""changes"": 79, ""blob_url"": ""https://github.com/torvalds/linux/blob/637b58c2887e5e57850865839cc75f59184b23d1/fs/pipe.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/637b58c2887e5e57850865839cc75f59184b23d1/fs/pipe.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pipe.c?ref=637b58c2887e5e57850865839cc75f59184b23d1"", ""patch"": ""@@ -142,55 +142,6 @@ pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,\n \treturn 0;\n }\n \n-static int\n-pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,\n-\t\t      int atomic)\n-{\n-\tunsigned long copy;\n-\n-\twhile (len > 0) {\n-\t\twhile (!iov->iov_len)\n-\t\t\tiov++;\n-\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n-\n-\t\tif (atomic) {\n-\t\t\tif (__copy_to_user_inatomic(iov->iov_base, from, copy))\n-\t\t\t\treturn -EFAULT;\n-\t\t} else {\n-\t\t\tif (copy_to_user(iov->iov_base, from, copy))\n-\t\t\t\treturn -EFAULT;\n-\t\t}\n-\t\tfrom += copy;\n-\t\tlen -= copy;\n-\t\tiov->iov_base += copy;\n-\t\tiov->iov_len -= copy;\n-\t}\n-\treturn 0;\n-}\n-\n-/*\n- * Attempt to pre-fault in the user memory, so we can use atomic copies.\n- * Returns the number of bytes not faulted in.\n- */\n-static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)\n-{\n-\twhile (!iov->iov_len)\n-\t\tiov++;\n-\n-\twhile (len > 0) {\n-\t\tunsigned long this_len;\n-\n-\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n-\t\tif (fault_in_pages_writeable(iov->iov_base, this_len))\n-\t\t\tbreak;\n-\n-\t\tlen -= this_len;\n-\t\tiov++;\n-\t}\n-\n-\treturn len;\n-}\n-\n /*\n  * Pre-fault in the user memory, so we can use atomic copies.\n  */\n@@ -329,12 +280,15 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,\n \tssize_t ret;\n \tstruct iovec *iov = (struct iovec *)_iov;\n \tsize_t total_len;\n+\tstruct iov_iter iter;\n \n \ttotal_len = iov_length(iov, nr_segs);\n \t/* Null read succeeds. */\n \tif (unlikely(total_len == 0))\n \t\treturn 0;\n \n+\tiov_iter_init(&iter, iov, nr_segs, total_len, 0);\n+\n \tdo_wakeup = 0;\n \tret = 0;\n \t__pipe_lock(pipe);\n@@ -344,9 +298,9 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,\n \t\t\tint curbuf = pipe->curbuf;\n \t\t\tstruct pipe_buffer *buf = pipe->bufs + curbuf;\n \t\t\tconst struct pipe_buf_operations *ops = buf->ops;\n-\t\t\tvoid *addr;\n \t\t\tsize_t chars = buf->len;\n-\t\t\tint error, atomic;\n+\t\t\tsize_t written;\n+\t\t\tint error;\n \n \t\t\tif (chars > total_len)\n \t\t\t\tchars = total_len;\n@@ -358,27 +312,10 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,\n \t\t\t\tbreak;\n \t\t\t}\n \n-\t\t\tatomic = !iov_fault_in_pages_write(iov, chars);\n-redo:\n-\t\t\tif (atomic)\n-\t\t\t\taddr = kmap_atomic(buf->page);\n-\t\t\telse\n-\t\t\t\taddr = kmap(buf->page);\n-\t\t\terror = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);\n-\t\t\tif (atomic)\n-\t\t\t\tkunmap_atomic(addr);\n-\t\t\telse\n-\t\t\t\tkunmap(buf->page);\n-\t\t\tif (unlikely(error)) {\n-\t\t\t\t/*\n-\t\t\t\t * Just retry with the slow path if we failed.\n-\t\t\t\t */\n-\t\t\t\tif (atomic) {\n-\t\t\t\t\tatomic = 0;\n-\t\t\t\t\tgoto redo;\n-\t\t\t\t}\n+\t\t\twritten = copy_page_to_iter(buf->page, buf->offset, chars, &iter);\n+\t\t\tif (unlikely(written < chars)) {\n \t\t\t\tif (!ret)\n-\t\t\t\t\tret = error;\n+\t\t\t\t\tret = -EFAULT;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tret += chars;""}","pipe_read(struct kiocb *iocb, const struct iovec *_iov,
	   unsigned long nr_segs, loff_t pos)
{
	struct file *filp = iocb->ki_filp;
	struct pipe_inode_info *pipe = filp->private_data;
	int do_wakeup;
 	ssize_t ret;
 	struct iovec *iov = (struct iovec *)_iov;
 	size_t total_len;
	struct iov_iter iter;
 
 	total_len = iov_length(iov, nr_segs);
 	/* Null read succeeds. */
 	if (unlikely(total_len == 0))
 		return 0;
 
	iov_iter_init(&iter, iov, nr_segs, total_len, 0);

 	do_wakeup = 0;
 	ret = 0;
 	__pipe_lock(pipe);
	for (;;) {
		int bufs = pipe->nrbufs;
		if (bufs) {
 			int curbuf = pipe->curbuf;
 			struct pipe_buffer *buf = pipe->bufs + curbuf;
 			const struct pipe_buf_operations *ops = buf->ops;
 			size_t chars = buf->len;
			size_t written;
			int error;
 
 			if (chars > total_len)
 				chars = total_len;

			error = ops->confirm(pipe, buf);
			if (error) {
				if (!ret)
					ret = error;
 				break;
 			}
 
			written = copy_page_to_iter(buf->page, buf->offset, chars, &iter);
			if (unlikely(written < chars)) {
 				if (!ret)
					ret = -EFAULT;
 				break;
 			}
 			ret += chars;
			buf->offset += chars;
			buf->len -= chars;

			/* Was it a packet buffer? Clean up and exit */
			if (buf->flags & PIPE_BUF_FLAG_PACKET) {
				total_len = chars;
				buf->len = 0;
			}

			if (!buf->len) {
				buf->ops = NULL;
				ops->release(pipe, buf);
				curbuf = (curbuf + 1) & (pipe->buffers - 1);
				pipe->curbuf = curbuf;
				pipe->nrbufs = --bufs;
				do_wakeup = 1;
			}
			total_len -= chars;
			if (!total_len)
				break;	/* common path: read succeeded */
		}
		if (bufs)	/* More to do? */
			continue;
		if (!pipe->writers)
			break;
		if (!pipe->waiting_writers) {
			/* syscall merging: Usually we must not sleep
			 * if O_NONBLOCK is set, or if we got some data.
			 * But if a writer sleeps in kernel space, then
			 * we can wait for that data without violating POSIX.
			 */
			if (ret)
				break;
			if (filp->f_flags & O_NONBLOCK) {
				ret = -EAGAIN;
				break;
			}
		}
		if (signal_pending(current)) {
			if (!ret)
				ret = -ERESTARTSYS;
			break;
		}
		if (do_wakeup) {
			wake_up_interruptible_sync_poll(&pipe->wait, POLLOUT | POLLWRNORM);
 			kill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);
		}
		pipe_wait(pipe);
	}
	__pipe_unlock(pipe);

	/* Signal writers asynchronously that there is more room. */
	if (do_wakeup) {
		wake_up_interruptible_sync_poll(&pipe->wait, POLLOUT | POLLWRNORM);
		kill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);
	}
	if (ret > 0)
		file_accessed(filp);
	return ret;
}
","pipe_read(struct kiocb *iocb, const struct iovec *_iov,
	   unsigned long nr_segs, loff_t pos)
{
	struct file *filp = iocb->ki_filp;
	struct pipe_inode_info *pipe = filp->private_data;
	int do_wakeup;
 	ssize_t ret;
 	struct iovec *iov = (struct iovec *)_iov;
 	size_t total_len;
 
 	total_len = iov_length(iov, nr_segs);
 	/* Null read succeeds. */
 	if (unlikely(total_len == 0))
 		return 0;
 
 	do_wakeup = 0;
 	ret = 0;
 	__pipe_lock(pipe);
	for (;;) {
		int bufs = pipe->nrbufs;
		if (bufs) {
 			int curbuf = pipe->curbuf;
 			struct pipe_buffer *buf = pipe->bufs + curbuf;
 			const struct pipe_buf_operations *ops = buf->ops;
			void *addr;
 			size_t chars = buf->len;
			int error, atomic;
 
 			if (chars > total_len)
 				chars = total_len;

			error = ops->confirm(pipe, buf);
			if (error) {
				if (!ret)
					ret = error;
 				break;
 			}
 
			atomic = !iov_fault_in_pages_write(iov, chars);
redo:
			if (atomic)
				addr = kmap_atomic(buf->page);
			else
				addr = kmap(buf->page);
			error = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);
			if (atomic)
				kunmap_atomic(addr);
			else
				kunmap(buf->page);
			if (unlikely(error)) {
				/*
				 * Just retry with the slow path if we failed.
				 */
				if (atomic) {
					atomic = 0;
					goto redo;
				}
 				if (!ret)
					ret = error;
 				break;
 			}
 			ret += chars;
			buf->offset += chars;
			buf->len -= chars;

			/* Was it a packet buffer? Clean up and exit */
			if (buf->flags & PIPE_BUF_FLAG_PACKET) {
				total_len = chars;
				buf->len = 0;
			}

			if (!buf->len) {
				buf->ops = NULL;
				ops->release(pipe, buf);
				curbuf = (curbuf + 1) & (pipe->buffers - 1);
				pipe->curbuf = curbuf;
				pipe->nrbufs = --bufs;
				do_wakeup = 1;
			}
			total_len -= chars;
			if (!total_len)
				break;	/* common path: read succeeded */
		}
		if (bufs)	/* More to do? */
			continue;
		if (!pipe->writers)
			break;
		if (!pipe->waiting_writers) {
			/* syscall merging: Usually we must not sleep
			 * if O_NONBLOCK is set, or if we got some data.
			 * But if a writer sleeps in kernel space, then
			 * we can wait for that data without violating POSIX.
			 */
			if (ret)
				break;
			if (filp->f_flags & O_NONBLOCK) {
				ret = -EAGAIN;
				break;
			}
		}
		if (signal_pending(current)) {
			if (!ret)
				ret = -ERESTARTSYS;
			break;
		}
		if (do_wakeup) {
			wake_up_interruptible_sync_poll(&pipe->wait, POLLOUT | POLLWRNORM);
 			kill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);
		}
		pipe_wait(pipe);
	}
	__pipe_unlock(pipe);

	/* Signal writers asynchronously that there is more room. */
	if (do_wakeup) {
		wake_up_interruptible_sync_poll(&pipe->wait, POLLOUT | POLLWRNORM);
		kill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);
	}
	if (ret > 0)
		file_accessed(filp);
	return ret;
}
",C,"	struct iov_iter iter;
	iov_iter_init(&iter, iov, nr_segs, total_len, 0);

			size_t written;
			int error;
			written = copy_page_to_iter(buf->page, buf->offset, chars, &iter);
			if (unlikely(written < chars)) {
					ret = -EFAULT;
","			void *addr;
			int error, atomic;
			atomic = !iov_fault_in_pages_write(iov, chars);
redo:
			if (atomic)
				addr = kmap_atomic(buf->page);
			else
				addr = kmap(buf->page);
			error = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);
			if (atomic)
				kunmap_atomic(addr);
			else
				kunmap(buf->page);
			if (unlikely(error)) {
				/*
				 * Just retry with the slow path if we failed.
				 */
				if (atomic) {
					atomic = 0;
					goto redo;
				}
					ret = error;
",,"@@ -142,55 +142,6 @@ pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,
 	return 0;
 }
 
-static int
-pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,
-		      int atomic)
-{
-	unsigned long copy;
-
-	while (len > 0) {
-		while (!iov->iov_len)
-			iov++;
-		copy = min_t(unsigned long, len, iov->iov_len);
-
-		if (atomic) {
-			if (__copy_to_user_inatomic(iov->iov_base, from, copy))
-				return -EFAULT;
-		} else {
-			if (copy_to_user(iov->iov_base, from, copy))
-				return -EFAULT;
-		}
-		from += copy;
-		len -= copy;
-		iov->iov_base += copy;
-		iov->iov_len -= copy;
-	}
-	return 0;
-}
-
-/*
- * Attempt to pre-fault in the user memory, so we can use atomic copies.
- * Returns the number of bytes not faulted in.
- */
-static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)
-{
-	while (!iov->iov_len)
-		iov++;
-
-	while (len > 0) {
-		unsigned long this_len;
-
-		this_len = min_t(unsigned long, len, iov->iov_len);
-		if (fault_in_pages_writeable(iov->iov_base, this_len))
-			break;
-
-		len -= this_len;
-		iov++;
-	}
-
-	return len;
-}
-
 /*
  * Pre-fault in the user memory, so we can use atomic copies.
  */
@@ -329,12 +280,15 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 	ssize_t ret;
 	struct iovec *iov = (struct iovec *)_iov;
 	size_t total_len;
+	struct iov_iter iter;
 
 	total_len = iov_length(iov, nr_segs);
 	/* Null read succeeds. */
 	if (unlikely(total_len == 0))
 		return 0;
 
+	iov_iter_init(&iter, iov, nr_segs, total_len, 0);
+
 	do_wakeup = 0;
 	ret = 0;
 	__pipe_lock(pipe);
@@ -344,9 +298,9 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 			int curbuf = pipe->curbuf;
 			struct pipe_buffer *buf = pipe->bufs + curbuf;
 			const struct pipe_buf_operations *ops = buf->ops;
-			void *addr;
 			size_t chars = buf->len;
-			int error, atomic;
+			size_t written;
+			int error;
 
 			if (chars > total_len)
 				chars = total_len;
@@ -358,27 +312,10 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 				break;
 			}
 
-			atomic = !iov_fault_in_pages_write(iov, chars);
-redo:
-			if (atomic)
-				addr = kmap_atomic(buf->page);
-			else
-				addr = kmap(buf->page);
-			error = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);
-			if (atomic)
-				kunmap_atomic(addr);
-			else
-				kunmap(buf->page);
-			if (unlikely(error)) {
-				/*
-				 * Just retry with the slow path if we failed.
-				 */
-				if (atomic) {
-					atomic = 0;
-					goto redo;
-				}
+			written = copy_page_to_iter(buf->page, buf->offset, chars, &iter);
+			if (unlikely(written < chars)) {
 				if (!ret)
-					ret = error;
+					ret = -EFAULT;
 				break;
 			}
 			ret += chars;",linux,637b58c2887e5e57850865839cc75f59184b23d1,74027f4a181754e917853bd1d2e21449f008ab39,1,"pipe_read(struct kiocb *iocb, const struct iovec *_iov,
	   unsigned long nr_segs, loff_t pos)
{
	struct file *filp = iocb->ki_filp;
	struct pipe_inode_info *pipe = filp->private_data;
	int do_wakeup;
 	ssize_t ret;
 	struct iovec *iov = (struct iovec *)_iov;
 	size_t total_len;
//fix_flaw_line_below:
//	struct iov_iter iter;
 
 	total_len = iov_length(iov, nr_segs);
 	/* Null read succeeds. */
 	if (unlikely(total_len == 0))
 		return 0;
 
//fix_flaw_line_below:
//	iov_iter_init(&iter, iov, nr_segs, total_len, 0);
//fix_flaw_line_below:
//
 	do_wakeup = 0;
 	ret = 0;
 	__pipe_lock(pipe);
	for (;;) {
		int bufs = pipe->nrbufs;
		if (bufs) {
 			int curbuf = pipe->curbuf;
 			struct pipe_buffer *buf = pipe->bufs + curbuf;
 			const struct pipe_buf_operations *ops = buf->ops;
//flaw_line_below:
			void *addr;
 			size_t chars = buf->len;
//flaw_line_below:
			int error, atomic;
//fix_flaw_line_below:
//			size_t written;
//fix_flaw_line_below:
//			int error;
 
 			if (chars > total_len)
 				chars = total_len;

			error = ops->confirm(pipe, buf);
			if (error) {
				if (!ret)
					ret = error;
 				break;
 			}
 
//flaw_line_below:
			atomic = !iov_fault_in_pages_write(iov, chars);
//flaw_line_below:
redo:
//flaw_line_below:
			if (atomic)
//flaw_line_below:
				addr = kmap_atomic(buf->page);
//flaw_line_below:
			else
//flaw_line_below:
				addr = kmap(buf->page);
//flaw_line_below:
			error = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);
//flaw_line_below:
			if (atomic)
//flaw_line_below:
				kunmap_atomic(addr);
//flaw_line_below:
			else
//flaw_line_below:
				kunmap(buf->page);
//flaw_line_below:
			if (unlikely(error)) {
//flaw_line_below:
				/*
//flaw_line_below:
				 * Just retry with the slow path if we failed.
//flaw_line_below:
				 */
//flaw_line_below:
				if (atomic) {
//flaw_line_below:
					atomic = 0;
//flaw_line_below:
					goto redo;
//flaw_line_below:
				}
//fix_flaw_line_below:
//			written = copy_page_to_iter(buf->page, buf->offset, chars, &iter);
//fix_flaw_line_below:
//			if (unlikely(written < chars)) {
 				if (!ret)
//flaw_line_below:
					ret = error;
//fix_flaw_line_below:
//					ret = -EFAULT;
 				break;
 			}
 			ret += chars;
			buf->offset += chars;
			buf->len -= chars;

			/* Was it a packet buffer? Clean up and exit */
			if (buf->flags & PIPE_BUF_FLAG_PACKET) {
				total_len = chars;
				buf->len = 0;
			}

			if (!buf->len) {
				buf->ops = NULL;
				ops->release(pipe, buf);
				curbuf = (curbuf + 1) & (pipe->buffers - 1);
				pipe->curbuf = curbuf;
				pipe->nrbufs = --bufs;
				do_wakeup = 1;
			}
			total_len -= chars;
			if (!total_len)
				break;	/* common path: read succeeded */
		}
		if (bufs)	/* More to do? */
			continue;
		if (!pipe->writers)
			break;
		if (!pipe->waiting_writers) {
			/* syscall merging: Usually we must not sleep
			 * if O_NONBLOCK is set, or if we got some data.
			 * But if a writer sleeps in kernel space, then
			 * we can wait for that data without violating POSIX.
			 */
			if (ret)
				break;
			if (filp->f_flags & O_NONBLOCK) {
				ret = -EAGAIN;
				break;
			}
		}
		if (signal_pending(current)) {
			if (!ret)
				ret = -ERESTARTSYS;
			break;
		}
		if (do_wakeup) {
			wake_up_interruptible_sync_poll(&pipe->wait, POLLOUT | POLLWRNORM);
 			kill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);
		}
		pipe_wait(pipe);
	}
	__pipe_unlock(pipe);

	/* Signal writers asynchronously that there is more room. */
	if (do_wakeup) {
		wake_up_interruptible_sync_poll(&pipe->wait, POLLOUT | POLLWRNORM);
		kill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);
	}
	if (ret > 0)
		file_accessed(filp);
	return ret;
}
"
8198,185934,,Remote,Not required,Partial,CVE-2015-1217,https://www.cvedetails.com/cve/CVE-2015-1217/,CWE-17,Low,Partial,Partial,,2015-03-08,7.5,"The V8LazyEventListener::prepareListenerObject function in bindings/core/v8/V8LazyEventListener.cpp in the V8 bindings in Blink, as used in Google Chrome before 41.0.2272.76, does not properly compile listeners, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that leverage *type confusion.*",2016-12-21,DoS ,6,https://github.com/chromium/chromium/commit/fc81fcf38edd250876cc384a6ed5567e1b2999e4,fc81fcf38edd250876cc384a6ed5567e1b2999e4,"Turn a bunch of ASSERTs into graceful failures when compiling listeners

BUG=456192
R=yangguo@chromium.org

Review URL: https://codereview.chromium.org/906193002

git-svn-id: svn://svn.chromium.org/blink/trunk@189796 bbb929c8-8fbe-4397-9dbb-9b2b20218538",3,third_party/WebKit/Source/bindings/core/v8/V8LazyEventListener.cpp,"{""sha"": ""d136637876c237e04e342d0ac993bd3b3c9a6bd3"", ""filename"": ""third_party/WebKit/LayoutTests/security/lazy-event-listener-expected.txt"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/fc81fcf38edd250876cc384a6ed5567e1b2999e4/third_party/WebKit/LayoutTests/security/lazy-event-listener-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fc81fcf38edd250876cc384a6ed5567e1b2999e4/third_party/WebKit/LayoutTests/security/lazy-event-listener-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/security/lazy-event-listener-expected.txt?ref=fc81fcf38edd250876cc384a6ed5567e1b2999e4"", ""patch"": ""@@ -0,0 +1 @@\n+Test passes if it doesn't crash.""}<_**next**_>{""sha"": ""dae3592868e90c5d4071f8c6374004416cd226da"", ""filename"": ""third_party/WebKit/LayoutTests/security/lazy-event-listener.html"", ""status"": ""added"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/fc81fcf38edd250876cc384a6ed5567e1b2999e4/third_party/WebKit/LayoutTests/security/lazy-event-listener.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fc81fcf38edd250876cc384a6ed5567e1b2999e4/third_party/WebKit/LayoutTests/security/lazy-event-listener.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/security/lazy-event-listener.html?ref=fc81fcf38edd250876cc384a6ed5567e1b2999e4"", ""patch"": ""@@ -0,0 +1,9 @@\n+<!DOCTYPE html>\n+<html onmousedown=\""};}}}}); true?0x31337:(function() {{{{{\"">\n+Test passes if it doesn't crash.\n+<script>\n+if (window.testRunner)\n+    testRunner.dumpAsText();\n+document.documentElement.onmousedown;\n+</script>\n+</html>""}<_**next**_>{""sha"": ""1e4b11d74e758b39f3e49717e16d484d0fbc16d6"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/V8LazyEventListener.cpp"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 4, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/fc81fcf38edd250876cc384a6ed5567e1b2999e4/third_party/WebKit/Source/bindings/core/v8/V8LazyEventListener.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fc81fcf38edd250876cc384a6ed5567e1b2999e4/third_party/WebKit/Source/bindings/core/v8/V8LazyEventListener.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/V8LazyEventListener.cpp?ref=fc81fcf38edd250876cc384a6ed5567e1b2999e4"", ""patch"": ""@@ -120,16 +120,17 @@ void V8LazyEventListener::prepareListenerObject(ExecutionContext* executionConte\n     if (!scriptState->contextIsValid())\n         return;\n \n-    if (executionContext->isDocument() && !toDocument(executionContext)->allowInlineEventHandlers(m_node, this, m_sourceURL, m_position.m_line)) {\n+    if (!executionContext->isDocument())\n+        return;\n+\n+    if (!toDocument(executionContext)->allowInlineEventHandlers(m_node, this, m_sourceURL, m_position.m_line)) {\n         clearListenerObject();\n         return;\n     }\n \n     if (hasExistingListenerObject())\n         return;\n \n-    ASSERT(executionContext->isDocument());\n-\n     ScriptState::Scope scope(scriptState);\n     String listenerSource =  InspectorInstrumentation::preprocessEventListener(toDocument(executionContext)->frame(), m_code, m_sourceURL, m_functionName);\n \n@@ -166,7 +167,8 @@ void V8LazyEventListener::prepareListenerObject(ExecutionContext* executionConte\n         return;\n \n     // Call the outer function to get the inner function.\n-    ASSERT(result->IsFunction());\n+    if (!result->IsFunction())\n+        return;\n     v8::Local<v8::Function> intermediateFunction = result.As<v8::Function>();\n \n     HTMLFormElement* formElement = 0;""}","void V8LazyEventListener::prepareListenerObject(ExecutionContext* executionContext)
{
    if (!executionContext)
        return;

    v8::HandleScope handleScope(toIsolate(executionContext));
    v8::Local<v8::Context> v8Context = toV8Context(executionContext, world());
    if (v8Context.IsEmpty())
        return;
    ScriptState* scriptState = ScriptState::from(v8Context);
     if (!scriptState->contextIsValid())
         return;
 
    if (!executionContext->isDocument())
        return;

    if (!toDocument(executionContext)->allowInlineEventHandlers(m_node, this, m_sourceURL, m_position.m_line)) {
         clearListenerObject();
         return;
     }
 
     if (hasExistingListenerObject())
         return;
 
     ScriptState::Scope scope(scriptState);
     String listenerSource =  InspectorInstrumentation::preprocessEventListener(toDocument(executionContext)->frame(), m_code, m_sourceURL, m_functionName);
 
    String code = ""(function() {""
        ""with (this[2]) {""
        ""with (this[1]) {""
        ""with (this[0]) {""
            ""return function("" + m_eventParameterName + "") {"" +
                listenerSource + ""\n"" // Insert '\n' otherwise //-style comments could break the handler.
            ""};""
        ""}}}})"";

    v8::Handle<v8::String> codeExternalString = v8String(isolate(), code);

    v8::Local<v8::Value> result = V8ScriptRunner::compileAndRunInternalScript(codeExternalString, isolate(), m_sourceURL, m_position);
    if (result.IsEmpty())
         return;
 
    if (!result->IsFunction())
        return;
     v8::Local<v8::Function> intermediateFunction = result.As<v8::Function>();
 
     HTMLFormElement* formElement = 0;
    if (m_node && m_node->isHTMLElement())
        formElement = toHTMLElement(m_node)->formOwner();

    v8::Handle<v8::Object> nodeWrapper = toObjectWrapper<Node>(m_node, scriptState);
    v8::Handle<v8::Object> formWrapper = toObjectWrapper<HTMLFormElement>(formElement, scriptState);
    v8::Handle<v8::Object> documentWrapper = toObjectWrapper<Document>(m_node ? m_node->ownerDocument() : 0, scriptState);

    v8::Local<v8::Object> thisObject = v8::Object::New(isolate());
    if (thisObject.IsEmpty())
        return;
    if (!thisObject->ForceSet(v8::Integer::New(isolate(), 0), nodeWrapper))
        return;
    if (!thisObject->ForceSet(v8::Integer::New(isolate(), 1), formWrapper))
        return;
    if (!thisObject->ForceSet(v8::Integer::New(isolate(), 2), documentWrapper))
        return;

    v8::Local<v8::Value> innerValue = V8ScriptRunner::callInternalFunction(intermediateFunction, thisObject, 0, 0, isolate());
    if (innerValue.IsEmpty() || !innerValue->IsFunction())
        return;

    v8::Local<v8::Function> wrappedFunction = innerValue.As<v8::Function>();

    v8::Local<v8::Function> toStringFunction = v8::Function::New(isolate(), V8LazyEventListenerToString);
    ASSERT(!toStringFunction.IsEmpty());
    String toStringString = ""function "" + m_functionName + ""("" + m_eventParameterName + "") {\n  "" + m_code + ""\n}"";
    V8HiddenValue::setHiddenValue(isolate(), wrappedFunction, V8HiddenValue::toStringString(isolate()), v8String(isolate(), toStringString));
    wrappedFunction->Set(v8AtomicString(isolate(), ""toString""), toStringFunction);
    wrappedFunction->SetName(v8String(isolate(), m_functionName));


    setListenerObject(wrappedFunction);
}
","void V8LazyEventListener::prepareListenerObject(ExecutionContext* executionContext)
{
    if (!executionContext)
        return;

    v8::HandleScope handleScope(toIsolate(executionContext));
    v8::Local<v8::Context> v8Context = toV8Context(executionContext, world());
    if (v8Context.IsEmpty())
        return;
    ScriptState* scriptState = ScriptState::from(v8Context);
     if (!scriptState->contextIsValid())
         return;
 
    if (executionContext->isDocument() && !toDocument(executionContext)->allowInlineEventHandlers(m_node, this, m_sourceURL, m_position.m_line)) {
         clearListenerObject();
         return;
     }
 
     if (hasExistingListenerObject())
         return;
 
    ASSERT(executionContext->isDocument());
     ScriptState::Scope scope(scriptState);
     String listenerSource =  InspectorInstrumentation::preprocessEventListener(toDocument(executionContext)->frame(), m_code, m_sourceURL, m_functionName);
 
    String code = ""(function() {""
        ""with (this[2]) {""
        ""with (this[1]) {""
        ""with (this[0]) {""
            ""return function("" + m_eventParameterName + "") {"" +
                listenerSource + ""\n"" // Insert '\n' otherwise //-style comments could break the handler.
            ""};""
        ""}}}})"";

    v8::Handle<v8::String> codeExternalString = v8String(isolate(), code);

    v8::Local<v8::Value> result = V8ScriptRunner::compileAndRunInternalScript(codeExternalString, isolate(), m_sourceURL, m_position);
    if (result.IsEmpty())
         return;
 
    ASSERT(result->IsFunction());
     v8::Local<v8::Function> intermediateFunction = result.As<v8::Function>();
 
     HTMLFormElement* formElement = 0;
    if (m_node && m_node->isHTMLElement())
        formElement = toHTMLElement(m_node)->formOwner();

    v8::Handle<v8::Object> nodeWrapper = toObjectWrapper<Node>(m_node, scriptState);
    v8::Handle<v8::Object> formWrapper = toObjectWrapper<HTMLFormElement>(formElement, scriptState);
    v8::Handle<v8::Object> documentWrapper = toObjectWrapper<Document>(m_node ? m_node->ownerDocument() : 0, scriptState);

    v8::Local<v8::Object> thisObject = v8::Object::New(isolate());
    if (thisObject.IsEmpty())
        return;
    if (!thisObject->ForceSet(v8::Integer::New(isolate(), 0), nodeWrapper))
        return;
    if (!thisObject->ForceSet(v8::Integer::New(isolate(), 1), formWrapper))
        return;
    if (!thisObject->ForceSet(v8::Integer::New(isolate(), 2), documentWrapper))
        return;

    v8::Local<v8::Value> innerValue = V8ScriptRunner::callInternalFunction(intermediateFunction, thisObject, 0, 0, isolate());
    if (innerValue.IsEmpty() || !innerValue->IsFunction())
        return;

    v8::Local<v8::Function> wrappedFunction = innerValue.As<v8::Function>();

    v8::Local<v8::Function> toStringFunction = v8::Function::New(isolate(), V8LazyEventListenerToString);
    ASSERT(!toStringFunction.IsEmpty());
    String toStringString = ""function "" + m_functionName + ""("" + m_eventParameterName + "") {\n  "" + m_code + ""\n}"";
    V8HiddenValue::setHiddenValue(isolate(), wrappedFunction, V8HiddenValue::toStringString(isolate()), v8String(isolate(), toStringString));
    wrappedFunction->Set(v8AtomicString(isolate(), ""toString""), toStringFunction);
    wrappedFunction->SetName(v8String(isolate(), m_functionName));


    setListenerObject(wrappedFunction);
}
",C,"    if (!executionContext->isDocument())
        return;

    if (!toDocument(executionContext)->allowInlineEventHandlers(m_node, this, m_sourceURL, m_position.m_line)) {
    if (!result->IsFunction())
        return;
","    if (executionContext->isDocument() && !toDocument(executionContext)->allowInlineEventHandlers(m_node, this, m_sourceURL, m_position.m_line)) {
    ASSERT(executionContext->isDocument());
    ASSERT(result->IsFunction());
",,"@@ -120,16 +120,17 @@ void V8LazyEventListener::prepareListenerObject(ExecutionContext* executionConte
     if (!scriptState->contextIsValid())
         return;
 
-    if (executionContext->isDocument() && !toDocument(executionContext)->allowInlineEventHandlers(m_node, this, m_sourceURL, m_position.m_line)) {
+    if (!executionContext->isDocument())
+        return;
+
+    if (!toDocument(executionContext)->allowInlineEventHandlers(m_node, this, m_sourceURL, m_position.m_line)) {
         clearListenerObject();
         return;
     }
 
     if (hasExistingListenerObject())
         return;
 
-    ASSERT(executionContext->isDocument());
-
     ScriptState::Scope scope(scriptState);
     String listenerSource =  InspectorInstrumentation::preprocessEventListener(toDocument(executionContext)->frame(), m_code, m_sourceURL, m_functionName);
 
@@ -166,7 +167,8 @@ void V8LazyEventListener::prepareListenerObject(ExecutionContext* executionConte
         return;
 
     // Call the outer function to get the inner function.
-    ASSERT(result->IsFunction());
+    if (!result->IsFunction())
+        return;
     v8::Local<v8::Function> intermediateFunction = result.As<v8::Function>();
 
     HTMLFormElement* formElement = 0;",Chrome,fc81fcf38edd250876cc384a6ed5567e1b2999e4,5f3c7d7a87dca1b93f0e4b9018088dc7d5f90fe2,1,"void V8LazyEventListener::prepareListenerObject(ExecutionContext* executionContext)
{
    if (!executionContext)
        return;

    // A ScriptState used by the event listener needs to be calculated based on
    // the ExecutionContext that fired the the event listener and the world
    // that installed the event listener.
    v8::HandleScope handleScope(toIsolate(executionContext));
    v8::Local<v8::Context> v8Context = toV8Context(executionContext, world());
    if (v8Context.IsEmpty())
        return;
    ScriptState* scriptState = ScriptState::from(v8Context);
     if (!scriptState->contextIsValid())
         return;
 
//flaw_line_below:
    if (executionContext->isDocument() && !toDocument(executionContext)->allowInlineEventHandlers(m_node, this, m_sourceURL, m_position.m_line)) {
//fix_flaw_line_below:
//    if (!executionContext->isDocument())
//fix_flaw_line_below:
//        return;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (!toDocument(executionContext)->allowInlineEventHandlers(m_node, this, m_sourceURL, m_position.m_line)) {
         clearListenerObject();
         return;
     }
 
     if (hasExistingListenerObject())
         return;
 
//flaw_line_below:
    ASSERT(executionContext->isDocument());
//flaw_line_below:

     ScriptState::Scope scope(scriptState);
     String listenerSource =  InspectorInstrumentation::preprocessEventListener(toDocument(executionContext)->frame(), m_code, m_sourceURL, m_functionName);
 
    // FIXME: Remove the following 'with' hack.
    //
    // Nodes other than the document object, when executing inline event
    // handlers push document, form owner, and the target node on the scope chain.
    // We do this by using 'with' statement.
    // See chrome/fast/forms/form-action.html
    //     chrome/fast/forms/selected-index-value.html
    //     base/fast/overflow/onscroll-layer-self-destruct.html
    //
    // Don't use new lines so that lines in the modified handler
    // have the same numbers as in the original code.
    // FIXME: V8 does not allow us to programmatically create object environments so
    //        we have to do this hack! What if m_code escapes to run arbitrary script?
    //
    // Call with 4 arguments instead of 3, pass additional null as the last parameter.
    // By calling the function with 4 arguments, we create a setter on arguments object
    // which would shadow property ""3"" on the prototype.
    String code = ""(function() {""
        ""with (this[2]) {""
        ""with (this[1]) {""
        ""with (this[0]) {""
            ""return function("" + m_eventParameterName + "") {"" +
                listenerSource + ""\n"" // Insert '\n' otherwise //-style comments could break the handler.
            ""};""
        ""}}}})"";

    v8::Handle<v8::String> codeExternalString = v8String(isolate(), code);

    v8::Local<v8::Value> result = V8ScriptRunner::compileAndRunInternalScript(codeExternalString, isolate(), m_sourceURL, m_position);
    if (result.IsEmpty())
         return;
 
     // Call the outer function to get the inner function.
//flaw_line_below:
    ASSERT(result->IsFunction());
//fix_flaw_line_below:
//    if (!result->IsFunction())
//fix_flaw_line_below:
//        return;
     v8::Local<v8::Function> intermediateFunction = result.As<v8::Function>();
 
     HTMLFormElement* formElement = 0;
    if (m_node && m_node->isHTMLElement())
        formElement = toHTMLElement(m_node)->formOwner();

    v8::Handle<v8::Object> nodeWrapper = toObjectWrapper<Node>(m_node, scriptState);
    v8::Handle<v8::Object> formWrapper = toObjectWrapper<HTMLFormElement>(formElement, scriptState);
    v8::Handle<v8::Object> documentWrapper = toObjectWrapper<Document>(m_node ? m_node->ownerDocument() : 0, scriptState);

    v8::Local<v8::Object> thisObject = v8::Object::New(isolate());
    if (thisObject.IsEmpty())
        return;
    if (!thisObject->ForceSet(v8::Integer::New(isolate(), 0), nodeWrapper))
        return;
    if (!thisObject->ForceSet(v8::Integer::New(isolate(), 1), formWrapper))
        return;
    if (!thisObject->ForceSet(v8::Integer::New(isolate(), 2), documentWrapper))
        return;

    // FIXME: Remove this code when we stop doing the 'with' hack above.
    v8::Local<v8::Value> innerValue = V8ScriptRunner::callInternalFunction(intermediateFunction, thisObject, 0, 0, isolate());
    if (innerValue.IsEmpty() || !innerValue->IsFunction())
        return;

    v8::Local<v8::Function> wrappedFunction = innerValue.As<v8::Function>();

    // Change the toString function on the wrapper function to avoid it
    // returning the source for the actual wrapper function. Instead it
    // returns source for a clean wrapper function with the event
    // argument wrapping the event source code. The reason for this is
    // that some web sites use toString on event functions and eval the
    // source returned (sometimes a RegExp is applied as well) for some
    // other use. That fails miserably if the actual wrapper source is
    // returned.
    v8::Local<v8::Function> toStringFunction = v8::Function::New(isolate(), V8LazyEventListenerToString);
    ASSERT(!toStringFunction.IsEmpty());
    String toStringString = ""function "" + m_functionName + ""("" + m_eventParameterName + "") {\n  "" + m_code + ""\n}"";
    V8HiddenValue::setHiddenValue(isolate(), wrappedFunction, V8HiddenValue::toStringString(isolate()), v8String(isolate(), toStringString));
    wrappedFunction->Set(v8AtomicString(isolate(), ""toString""), toStringFunction);
    wrappedFunction->SetName(v8String(isolate(), m_functionName));

    // FIXME: Remove the following comment-outs.
    // See https://bugs.webkit.org/show_bug.cgi?id=85152 for more details.
    //
    // For the time being, we comment out the following code since the
    // second parsing can happen.
    // // Since we only parse once, there's no need to keep data used for parsing around anymore.
    // m_functionName = String();
    // m_code = String();
    // m_eventParameterName = String();
    // m_sourceURL = String();

    setListenerObject(wrappedFunction);
}
"
8207,185943,,Remote,Not required,Partial,CVE-2015-1224,https://www.cvedetails.com/cve/CVE-2015-1224/,CWE-17,Low,,,,2015-03-08,5.0,"The VpxVideoDecoder::VpxDecode function in media/filters/vpx_video_decoder.cc in the vpxdecoder implementation in Google Chrome before 41.0.2272.76 does not ensure that alpha-plane dimensions are identical to image dimensions, which allows remote attackers to cause a denial of service (out-of-bounds read) via crafted VPx video data.",2016-12-21,DoS ,1,https://github.com/chromium/chromium/commit/5c6e9372daae557d6857f02888e84363eeff9be9,5c6e9372daae557d6857f02888e84363eeff9be9,"Rename MostVisitedSites.MostVisitedURLsObserver to Observer.

BUG=677672

Review-Url: https://codereview.chromium.org/2697543002
Cr-Commit-Position: refs/heads/master@{#449958}",1,chrome/browser/android/ntp/most_visited_sites_bridge.cc,"{""sha"": ""53362f0082ae47e69ef165910af02383ad21831a"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/suggestions/MostVisitedSites.java"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/MostVisitedSites.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/MostVisitedSites.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/suggestions/MostVisitedSites.java?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -16,9 +16,9 @@\n     private long mNativeMostVisitedSitesBridge;\n \n     /**\n-     * Interface for receiving the list of most visited urls.\n+     * An interface for handling events in {@link MostVisitedSites}.\n      */\n-    public interface MostVisitedURLsObserver {\n+    public interface Observer {\n         /**\n          * This is called when the list of most visited URLs is initially available or updated.\n          * Parameters guaranteed to be non-null.\n@@ -31,7 +31,7 @@\n          *                           strings otherwise.\n          * @param sources For each tile, the {@code NTPTileSource} that generated the tile.\n          */\n-        @CalledByNative(\""MostVisitedURLsObserver\"")\n+        @CalledByNative(\""Observer\"")\n         void onMostVisitedURLsAvailable(\n                 String[] titles, String[] urls, String[] whitelistIconPaths, int[] sources);\n \n@@ -41,7 +41,7 @@ void onMostVisitedURLsAvailable(\n          *\n          * @param siteUrl URL of site with newly-cached icon.\n          */\n-        @CalledByNative(\""MostVisitedURLsObserver\"")\n+        @CalledByNative(\""Observer\"")\n         void onIconMadeAvailable(String siteUrl);\n     }\n \n@@ -64,16 +64,13 @@ public void destroy() {\n     }\n \n     /**\n-     * Sets the MostVisitedURLsObserver to receive the list of most visited sites now or soon, and\n-     * after any changes to the list. Note: the observer may be notified synchronously or\n-     * asynchronously.\n-     * @param observer The MostVisitedURLsObserver to be called once when the most visited sites\n-     *                 are initially available and again whenever the list of most visited sites\n-     *                 changes.\n-     * @param numSites The maximum number of most visited sites to return.\n+     * Sets the recipient for events from {@link MostVisitedSites}. The observer may be notified\n+     * synchronously or asynchronously.\n+     * @param observer The observer to be notified.\n+     * @param numSites The maximum number of sites to return.\n      */\n-    public void setMostVisitedURLsObserver(final MostVisitedURLsObserver observer, int numSites) {\n-        MostVisitedURLsObserver wrappedObserver = new MostVisitedURLsObserver() {\n+    public void setObserver(final Observer observer, int numSites) {\n+        Observer wrappedObserver = new Observer() {\n             @Override\n             public void onMostVisitedURLsAvailable(\n                     String[] titles, String[] urls, String[] whitelistIconPaths, int[] sources) {\n@@ -90,7 +87,7 @@ public void onIconMadeAvailable(String siteUrl) {\n                 }\n             }\n         };\n-        nativeSetMostVisitedURLsObserver(mNativeMostVisitedSitesBridge, wrappedObserver, numSites);\n+        nativeSetObserver(mNativeMostVisitedSitesBridge, wrappedObserver, numSites);\n     }\n \n     /**\n@@ -133,8 +130,8 @@ public void recordOpenedMostVisitedItem(\n \n     private native long nativeInit(Profile profile);\n     private native void nativeDestroy(long nativeMostVisitedSitesBridge);\n-    private native void nativeSetMostVisitedURLsObserver(\n-            long nativeMostVisitedSitesBridge, MostVisitedURLsObserver observer, int numSites);\n+    private native void nativeSetObserver(\n+            long nativeMostVisitedSitesBridge, Observer observer, int numSites);\n     private native void nativeAddOrRemoveBlacklistedUrl(\n             long nativeMostVisitedSitesBridge, String url, boolean addUrl);\n     private native void nativeRecordPageImpression(""}<_**next**_>{""sha"": ""52af27f0da072e4559e6e4a1de86c9bf752ff507"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroup.java"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroup.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroup.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroup.java?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -31,7 +31,6 @@\n import org.chromium.chrome.browser.ntp.ContextMenuManager;\n import org.chromium.chrome.browser.ntp.ContextMenuManager.ContextMenuItemId;\n import org.chromium.chrome.browser.ntp.MostVisitedTileType;\n-import org.chromium.chrome.browser.suggestions.MostVisitedSites.MostVisitedURLsObserver;\n import org.chromium.chrome.browser.widget.RoundedIconGenerator;\n import org.chromium.ui.mojom.WindowOpenDisposition;\n \n@@ -44,7 +43,7 @@\n /**\n  * The model and controller for a group of site suggestion tiles.\n  */\n-public class TileGroup implements MostVisitedURLsObserver {\n+public class TileGroup implements MostVisitedSites.Observer {\n     /**\n      * Performs work in other parts of the system that the {@link TileGroup} should not know about.\n      */\n@@ -58,7 +57,7 @@\n          * @param observer The observer to be notified with the list of sites.\n          * @param maxResults The maximum number of sites to retrieve.\n          */\n-        void setMostVisitedURLsObserver(MostVisitedURLsObserver observer, int maxResults);\n+        void setMostVisitedSitesObserver(MostVisitedSites.Observer observer, int maxResults);\n \n         /**\n          * Called when the NTP has completely finished loading (all views will be inflated\n@@ -190,7 +189,7 @@ public void onIconMadeAvailable(String siteUrl) {\n      * @param maxResults The maximum number of sites to retrieve.\n      */\n     public void startObserving(int maxResults) {\n-        mTileGroupDelegate.setMostVisitedURLsObserver(this, maxResults);\n+        mTileGroupDelegate.setMostVisitedSitesObserver(this, maxResults);\n     }\n \n     /**""}<_**next**_>{""sha"": ""3a3d8bd7d065aba3392d9dd2d18b93fccd93dbd0"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroupDelegateImpl.java"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroupDelegateImpl.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroupDelegateImpl.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroupDelegateImpl.java?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -19,7 +19,6 @@\n import org.chromium.chrome.browser.snackbar.Snackbar;\n import org.chromium.chrome.browser.snackbar.SnackbarManager;\n import org.chromium.chrome.browser.snackbar.SnackbarManager.SnackbarController;\n-import org.chromium.chrome.browser.suggestions.MostVisitedSites.MostVisitedURLsObserver;\n import org.chromium.chrome.browser.tabmodel.TabModel;\n import org.chromium.chrome.browser.tabmodel.TabModelSelector;\n import org.chromium.chrome.browser.tabmodel.TabModelUtils;\n@@ -81,10 +80,10 @@ public void openMostVisitedItem(int windowDisposition, Tile item) {\n     }\n \n     @Override\n-    public void setMostVisitedURLsObserver(MostVisitedURLsObserver observer, int maxResults) {\n+    public void setMostVisitedSitesObserver(MostVisitedSites.Observer observer, int maxResults) {\n         assert !mIsDestroyed;\n \n-        mMostVisitedSites.setMostVisitedURLsObserver(observer, maxResults);\n+        mMostVisitedSites.setObserver(observer, maxResults);\n     }\n \n     @Override""}<_**next**_>{""sha"": ""b411748dd34ebb35da14a73170f8ab20dc456f1d"", ""filename"": ""chrome/android/javatests/src/org/chromium/chrome/browser/suggestions/FakeMostVisitedSites.java"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/javatests/src/org/chromium/chrome/browser/suggestions/FakeMostVisitedSites.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/javatests/src/org/chromium/chrome/browser/suggestions/FakeMostVisitedSites.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/javatests/src/org/chromium/chrome/browser/suggestions/FakeMostVisitedSites.java?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -20,7 +20,7 @@\n     private String[] mUrls = new String[] {};\n     private String[] mWhitelistIconPaths = new String[] {};\n     private int[] mSources = new int[] {};\n-    private MostVisitedURLsObserver mObserver;\n+    private Observer mObserver;\n \n     /**\n      * @param profile The profile for which to fetch site suggestions.\n@@ -31,7 +31,7 @@ public FakeMostVisitedSites(Profile profile) {\n     }\n \n     @Override\n-    public void setMostVisitedURLsObserver(MostVisitedURLsObserver observer, int numResults) {\n+    public void setObserver(Observer observer, int numResults) {\n         mObserver = observer;\n         notifyTileSuggestionsAvailable();\n     }""}<_**next**_>{""sha"": ""7ebe858a24e24cdeee80cdc8f7a05f1ce52235f5"", ""filename"": ""chrome/browser/android/ntp/most_visited_sites_bridge.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/browser/android/ntp/most_visited_sites_bridge.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/browser/android/ntp/most_visited_sites_bridge.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/ntp/most_visited_sites_bridge.cc?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -72,7 +72,7 @@ void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(\n     whitelist_icon_paths.emplace_back(tile.whitelist_icon_path.value());\n     sources.emplace_back(static_cast<int>(tile.source));\n   }\n-  Java_MostVisitedURLsObserver_onMostVisitedURLsAvailable(\n+  Java_Observer_onMostVisitedURLsAvailable(\n       env, observer_, ToJavaArrayOfStrings(env, titles),\n       ToJavaArrayOfStrings(env, urls),\n       ToJavaArrayOfStrings(env, whitelist_icon_paths),\n@@ -82,7 +82,7 @@ void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(\n void MostVisitedSitesBridge::JavaObserver::OnIconMadeAvailable(\n     const GURL& site_url) {\n   JNIEnv* env = AttachCurrentThread();\n-  Java_MostVisitedURLsObserver_onIconMadeAvailable(\n+  Java_Observer_onIconMadeAvailable(\n       env, observer_, ConvertUTF8ToJavaString(env, site_url.spec()));\n }\n \n@@ -101,7 +101,7 @@ void MostVisitedSitesBridge::Destroy(\n   delete this;\n }\n \n-void MostVisitedSitesBridge::SetMostVisitedURLsObserver(\n+void MostVisitedSitesBridge::SetObserver(\n     JNIEnv* env,\n     const JavaParamRef<jobject>& obj,\n     const JavaParamRef<jobject>& j_observer,""}<_**next**_>{""sha"": ""730ef0cf9629271129fa5111ada49409907c74ca"", ""filename"": ""chrome/browser/android/ntp/most_visited_sites_bridge.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/browser/android/ntp/most_visited_sites_bridge.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/browser/android/ntp/most_visited_sites_bridge.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/ntp/most_visited_sites_bridge.h?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -25,11 +25,10 @@ class MostVisitedSitesBridge {\n \n   void Destroy(JNIEnv* env, const base::android::JavaParamRef<jobject>& obj);\n \n-  void SetMostVisitedURLsObserver(\n-      JNIEnv* env,\n-      const base::android::JavaParamRef<jobject>& obj,\n-      const base::android::JavaParamRef<jobject>& j_observer,\n-      jint num_sites);\n+  void SetObserver(JNIEnv* env,\n+                   const base::android::JavaParamRef<jobject>& obj,\n+                   const base::android::JavaParamRef<jobject>& j_observer,\n+                   jint num_sites);\n \n   void AddOrRemoveBlacklistedUrl(\n       JNIEnv* env,""}"," void MostVisitedSitesBridge::JavaObserver::OnIconMadeAvailable(
     const GURL& site_url) {
   JNIEnv* env = AttachCurrentThread();
  Java_Observer_onIconMadeAvailable(
       env, observer_, ConvertUTF8ToJavaString(env, site_url.spec()));
 }
"," void MostVisitedSitesBridge::JavaObserver::OnIconMadeAvailable(
     const GURL& site_url) {
   JNIEnv* env = AttachCurrentThread();
  Java_MostVisitedURLsObserver_onIconMadeAvailable(
       env, observer_, ConvertUTF8ToJavaString(env, site_url.spec()));
 }
",C,"  Java_Observer_onIconMadeAvailable(
","  Java_MostVisitedURLsObserver_onIconMadeAvailable(
",,"@@ -72,7 +72,7 @@ void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(
     whitelist_icon_paths.emplace_back(tile.whitelist_icon_path.value());
     sources.emplace_back(static_cast<int>(tile.source));
   }
-  Java_MostVisitedURLsObserver_onMostVisitedURLsAvailable(
+  Java_Observer_onMostVisitedURLsAvailable(
       env, observer_, ToJavaArrayOfStrings(env, titles),
       ToJavaArrayOfStrings(env, urls),
       ToJavaArrayOfStrings(env, whitelist_icon_paths),
@@ -82,7 +82,7 @@ void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(
 void MostVisitedSitesBridge::JavaObserver::OnIconMadeAvailable(
     const GURL& site_url) {
   JNIEnv* env = AttachCurrentThread();
-  Java_MostVisitedURLsObserver_onIconMadeAvailable(
+  Java_Observer_onIconMadeAvailable(
       env, observer_, ConvertUTF8ToJavaString(env, site_url.spec()));
 }
 
@@ -101,7 +101,7 @@ void MostVisitedSitesBridge::Destroy(
   delete this;
 }
 
-void MostVisitedSitesBridge::SetMostVisitedURLsObserver(
+void MostVisitedSitesBridge::SetObserver(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj,
     const JavaParamRef<jobject>& j_observer,",Chrome,5c6e9372daae557d6857f02888e84363eeff9be9,3a41077cf9560947e1d84ea72ba324921e4b40af,1," void MostVisitedSitesBridge::JavaObserver::OnIconMadeAvailable(
     const GURL& site_url) {
   JNIEnv* env = AttachCurrentThread();
//flaw_line_below:
  Java_MostVisitedURLsObserver_onIconMadeAvailable(
//fix_flaw_line_below:
//  Java_Observer_onIconMadeAvailable(
       env, observer_, ConvertUTF8ToJavaString(env, site_url.spec()));
 }
"
8208,185944,,Remote,Not required,Partial,CVE-2015-1224,https://www.cvedetails.com/cve/CVE-2015-1224/,CWE-17,Low,,,,2015-03-08,5.0,"The VpxVideoDecoder::VpxDecode function in media/filters/vpx_video_decoder.cc in the vpxdecoder implementation in Google Chrome before 41.0.2272.76 does not ensure that alpha-plane dimensions are identical to image dimensions, which allows remote attackers to cause a denial of service (out-of-bounds read) via crafted VPx video data.",2016-12-21,DoS ,1,https://github.com/chromium/chromium/commit/5c6e9372daae557d6857f02888e84363eeff9be9,5c6e9372daae557d6857f02888e84363eeff9be9,"Rename MostVisitedSites.MostVisitedURLsObserver to Observer.

BUG=677672

Review-Url: https://codereview.chromium.org/2697543002
Cr-Commit-Position: refs/heads/master@{#449958}",1,chrome/browser/android/ntp/most_visited_sites_bridge.cc,"{""sha"": ""53362f0082ae47e69ef165910af02383ad21831a"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/suggestions/MostVisitedSites.java"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/MostVisitedSites.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/MostVisitedSites.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/suggestions/MostVisitedSites.java?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -16,9 +16,9 @@\n     private long mNativeMostVisitedSitesBridge;\n \n     /**\n-     * Interface for receiving the list of most visited urls.\n+     * An interface for handling events in {@link MostVisitedSites}.\n      */\n-    public interface MostVisitedURLsObserver {\n+    public interface Observer {\n         /**\n          * This is called when the list of most visited URLs is initially available or updated.\n          * Parameters guaranteed to be non-null.\n@@ -31,7 +31,7 @@\n          *                           strings otherwise.\n          * @param sources For each tile, the {@code NTPTileSource} that generated the tile.\n          */\n-        @CalledByNative(\""MostVisitedURLsObserver\"")\n+        @CalledByNative(\""Observer\"")\n         void onMostVisitedURLsAvailable(\n                 String[] titles, String[] urls, String[] whitelistIconPaths, int[] sources);\n \n@@ -41,7 +41,7 @@ void onMostVisitedURLsAvailable(\n          *\n          * @param siteUrl URL of site with newly-cached icon.\n          */\n-        @CalledByNative(\""MostVisitedURLsObserver\"")\n+        @CalledByNative(\""Observer\"")\n         void onIconMadeAvailable(String siteUrl);\n     }\n \n@@ -64,16 +64,13 @@ public void destroy() {\n     }\n \n     /**\n-     * Sets the MostVisitedURLsObserver to receive the list of most visited sites now or soon, and\n-     * after any changes to the list. Note: the observer may be notified synchronously or\n-     * asynchronously.\n-     * @param observer The MostVisitedURLsObserver to be called once when the most visited sites\n-     *                 are initially available and again whenever the list of most visited sites\n-     *                 changes.\n-     * @param numSites The maximum number of most visited sites to return.\n+     * Sets the recipient for events from {@link MostVisitedSites}. The observer may be notified\n+     * synchronously or asynchronously.\n+     * @param observer The observer to be notified.\n+     * @param numSites The maximum number of sites to return.\n      */\n-    public void setMostVisitedURLsObserver(final MostVisitedURLsObserver observer, int numSites) {\n-        MostVisitedURLsObserver wrappedObserver = new MostVisitedURLsObserver() {\n+    public void setObserver(final Observer observer, int numSites) {\n+        Observer wrappedObserver = new Observer() {\n             @Override\n             public void onMostVisitedURLsAvailable(\n                     String[] titles, String[] urls, String[] whitelistIconPaths, int[] sources) {\n@@ -90,7 +87,7 @@ public void onIconMadeAvailable(String siteUrl) {\n                 }\n             }\n         };\n-        nativeSetMostVisitedURLsObserver(mNativeMostVisitedSitesBridge, wrappedObserver, numSites);\n+        nativeSetObserver(mNativeMostVisitedSitesBridge, wrappedObserver, numSites);\n     }\n \n     /**\n@@ -133,8 +130,8 @@ public void recordOpenedMostVisitedItem(\n \n     private native long nativeInit(Profile profile);\n     private native void nativeDestroy(long nativeMostVisitedSitesBridge);\n-    private native void nativeSetMostVisitedURLsObserver(\n-            long nativeMostVisitedSitesBridge, MostVisitedURLsObserver observer, int numSites);\n+    private native void nativeSetObserver(\n+            long nativeMostVisitedSitesBridge, Observer observer, int numSites);\n     private native void nativeAddOrRemoveBlacklistedUrl(\n             long nativeMostVisitedSitesBridge, String url, boolean addUrl);\n     private native void nativeRecordPageImpression(""}<_**next**_>{""sha"": ""52af27f0da072e4559e6e4a1de86c9bf752ff507"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroup.java"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroup.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroup.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroup.java?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -31,7 +31,6 @@\n import org.chromium.chrome.browser.ntp.ContextMenuManager;\n import org.chromium.chrome.browser.ntp.ContextMenuManager.ContextMenuItemId;\n import org.chromium.chrome.browser.ntp.MostVisitedTileType;\n-import org.chromium.chrome.browser.suggestions.MostVisitedSites.MostVisitedURLsObserver;\n import org.chromium.chrome.browser.widget.RoundedIconGenerator;\n import org.chromium.ui.mojom.WindowOpenDisposition;\n \n@@ -44,7 +43,7 @@\n /**\n  * The model and controller for a group of site suggestion tiles.\n  */\n-public class TileGroup implements MostVisitedURLsObserver {\n+public class TileGroup implements MostVisitedSites.Observer {\n     /**\n      * Performs work in other parts of the system that the {@link TileGroup} should not know about.\n      */\n@@ -58,7 +57,7 @@\n          * @param observer The observer to be notified with the list of sites.\n          * @param maxResults The maximum number of sites to retrieve.\n          */\n-        void setMostVisitedURLsObserver(MostVisitedURLsObserver observer, int maxResults);\n+        void setMostVisitedSitesObserver(MostVisitedSites.Observer observer, int maxResults);\n \n         /**\n          * Called when the NTP has completely finished loading (all views will be inflated\n@@ -190,7 +189,7 @@ public void onIconMadeAvailable(String siteUrl) {\n      * @param maxResults The maximum number of sites to retrieve.\n      */\n     public void startObserving(int maxResults) {\n-        mTileGroupDelegate.setMostVisitedURLsObserver(this, maxResults);\n+        mTileGroupDelegate.setMostVisitedSitesObserver(this, maxResults);\n     }\n \n     /**""}<_**next**_>{""sha"": ""3a3d8bd7d065aba3392d9dd2d18b93fccd93dbd0"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroupDelegateImpl.java"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroupDelegateImpl.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroupDelegateImpl.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroupDelegateImpl.java?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -19,7 +19,6 @@\n import org.chromium.chrome.browser.snackbar.Snackbar;\n import org.chromium.chrome.browser.snackbar.SnackbarManager;\n import org.chromium.chrome.browser.snackbar.SnackbarManager.SnackbarController;\n-import org.chromium.chrome.browser.suggestions.MostVisitedSites.MostVisitedURLsObserver;\n import org.chromium.chrome.browser.tabmodel.TabModel;\n import org.chromium.chrome.browser.tabmodel.TabModelSelector;\n import org.chromium.chrome.browser.tabmodel.TabModelUtils;\n@@ -81,10 +80,10 @@ public void openMostVisitedItem(int windowDisposition, Tile item) {\n     }\n \n     @Override\n-    public void setMostVisitedURLsObserver(MostVisitedURLsObserver observer, int maxResults) {\n+    public void setMostVisitedSitesObserver(MostVisitedSites.Observer observer, int maxResults) {\n         assert !mIsDestroyed;\n \n-        mMostVisitedSites.setMostVisitedURLsObserver(observer, maxResults);\n+        mMostVisitedSites.setObserver(observer, maxResults);\n     }\n \n     @Override""}<_**next**_>{""sha"": ""b411748dd34ebb35da14a73170f8ab20dc456f1d"", ""filename"": ""chrome/android/javatests/src/org/chromium/chrome/browser/suggestions/FakeMostVisitedSites.java"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/javatests/src/org/chromium/chrome/browser/suggestions/FakeMostVisitedSites.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/javatests/src/org/chromium/chrome/browser/suggestions/FakeMostVisitedSites.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/javatests/src/org/chromium/chrome/browser/suggestions/FakeMostVisitedSites.java?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -20,7 +20,7 @@\n     private String[] mUrls = new String[] {};\n     private String[] mWhitelistIconPaths = new String[] {};\n     private int[] mSources = new int[] {};\n-    private MostVisitedURLsObserver mObserver;\n+    private Observer mObserver;\n \n     /**\n      * @param profile The profile for which to fetch site suggestions.\n@@ -31,7 +31,7 @@ public FakeMostVisitedSites(Profile profile) {\n     }\n \n     @Override\n-    public void setMostVisitedURLsObserver(MostVisitedURLsObserver observer, int numResults) {\n+    public void setObserver(Observer observer, int numResults) {\n         mObserver = observer;\n         notifyTileSuggestionsAvailable();\n     }""}<_**next**_>{""sha"": ""7ebe858a24e24cdeee80cdc8f7a05f1ce52235f5"", ""filename"": ""chrome/browser/android/ntp/most_visited_sites_bridge.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/browser/android/ntp/most_visited_sites_bridge.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/browser/android/ntp/most_visited_sites_bridge.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/ntp/most_visited_sites_bridge.cc?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -72,7 +72,7 @@ void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(\n     whitelist_icon_paths.emplace_back(tile.whitelist_icon_path.value());\n     sources.emplace_back(static_cast<int>(tile.source));\n   }\n-  Java_MostVisitedURLsObserver_onMostVisitedURLsAvailable(\n+  Java_Observer_onMostVisitedURLsAvailable(\n       env, observer_, ToJavaArrayOfStrings(env, titles),\n       ToJavaArrayOfStrings(env, urls),\n       ToJavaArrayOfStrings(env, whitelist_icon_paths),\n@@ -82,7 +82,7 @@ void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(\n void MostVisitedSitesBridge::JavaObserver::OnIconMadeAvailable(\n     const GURL& site_url) {\n   JNIEnv* env = AttachCurrentThread();\n-  Java_MostVisitedURLsObserver_onIconMadeAvailable(\n+  Java_Observer_onIconMadeAvailable(\n       env, observer_, ConvertUTF8ToJavaString(env, site_url.spec()));\n }\n \n@@ -101,7 +101,7 @@ void MostVisitedSitesBridge::Destroy(\n   delete this;\n }\n \n-void MostVisitedSitesBridge::SetMostVisitedURLsObserver(\n+void MostVisitedSitesBridge::SetObserver(\n     JNIEnv* env,\n     const JavaParamRef<jobject>& obj,\n     const JavaParamRef<jobject>& j_observer,""}<_**next**_>{""sha"": ""730ef0cf9629271129fa5111ada49409907c74ca"", ""filename"": ""chrome/browser/android/ntp/most_visited_sites_bridge.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/browser/android/ntp/most_visited_sites_bridge.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/browser/android/ntp/most_visited_sites_bridge.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/ntp/most_visited_sites_bridge.h?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -25,11 +25,10 @@ class MostVisitedSitesBridge {\n \n   void Destroy(JNIEnv* env, const base::android::JavaParamRef<jobject>& obj);\n \n-  void SetMostVisitedURLsObserver(\n-      JNIEnv* env,\n-      const base::android::JavaParamRef<jobject>& obj,\n-      const base::android::JavaParamRef<jobject>& j_observer,\n-      jint num_sites);\n+  void SetObserver(JNIEnv* env,\n+                   const base::android::JavaParamRef<jobject>& obj,\n+                   const base::android::JavaParamRef<jobject>& j_observer,\n+                   jint num_sites);\n \n   void AddOrRemoveBlacklistedUrl(\n       JNIEnv* env,""}","void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(
    const NTPTilesVector& tiles) {
  JNIEnv* env = AttachCurrentThread();
  std::vector<base::string16> titles;
  std::vector<std::string> urls;
  std::vector<std::string> whitelist_icon_paths;
  std::vector<int> sources;

  titles.reserve(tiles.size());
  urls.reserve(tiles.size());
  whitelist_icon_paths.reserve(tiles.size());
  sources.reserve(tiles.size());
  for (const auto& tile : tiles) {
    titles.emplace_back(tile.title);
    urls.emplace_back(tile.url.spec());
     whitelist_icon_paths.emplace_back(tile.whitelist_icon_path.value());
     sources.emplace_back(static_cast<int>(tile.source));
   }
  Java_Observer_onMostVisitedURLsAvailable(
       env, observer_, ToJavaArrayOfStrings(env, titles),
       ToJavaArrayOfStrings(env, urls),
       ToJavaArrayOfStrings(env, whitelist_icon_paths),
      ToJavaIntArray(env, sources));
}
","void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(
    const NTPTilesVector& tiles) {
  JNIEnv* env = AttachCurrentThread();
  std::vector<base::string16> titles;
  std::vector<std::string> urls;
  std::vector<std::string> whitelist_icon_paths;
  std::vector<int> sources;

  titles.reserve(tiles.size());
  urls.reserve(tiles.size());
  whitelist_icon_paths.reserve(tiles.size());
  sources.reserve(tiles.size());
  for (const auto& tile : tiles) {
    titles.emplace_back(tile.title);
    urls.emplace_back(tile.url.spec());
     whitelist_icon_paths.emplace_back(tile.whitelist_icon_path.value());
     sources.emplace_back(static_cast<int>(tile.source));
   }
  Java_MostVisitedURLsObserver_onMostVisitedURLsAvailable(
       env, observer_, ToJavaArrayOfStrings(env, titles),
       ToJavaArrayOfStrings(env, urls),
       ToJavaArrayOfStrings(env, whitelist_icon_paths),
      ToJavaIntArray(env, sources));
}
",C,"  Java_Observer_onMostVisitedURLsAvailable(
","  Java_MostVisitedURLsObserver_onMostVisitedURLsAvailable(
",,"@@ -72,7 +72,7 @@ void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(
     whitelist_icon_paths.emplace_back(tile.whitelist_icon_path.value());
     sources.emplace_back(static_cast<int>(tile.source));
   }
-  Java_MostVisitedURLsObserver_onMostVisitedURLsAvailable(
+  Java_Observer_onMostVisitedURLsAvailable(
       env, observer_, ToJavaArrayOfStrings(env, titles),
       ToJavaArrayOfStrings(env, urls),
       ToJavaArrayOfStrings(env, whitelist_icon_paths),
@@ -82,7 +82,7 @@ void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(
 void MostVisitedSitesBridge::JavaObserver::OnIconMadeAvailable(
     const GURL& site_url) {
   JNIEnv* env = AttachCurrentThread();
-  Java_MostVisitedURLsObserver_onIconMadeAvailable(
+  Java_Observer_onIconMadeAvailable(
       env, observer_, ConvertUTF8ToJavaString(env, site_url.spec()));
 }
 
@@ -101,7 +101,7 @@ void MostVisitedSitesBridge::Destroy(
   delete this;
 }
 
-void MostVisitedSitesBridge::SetMostVisitedURLsObserver(
+void MostVisitedSitesBridge::SetObserver(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj,
     const JavaParamRef<jobject>& j_observer,",Chrome,5c6e9372daae557d6857f02888e84363eeff9be9,3a41077cf9560947e1d84ea72ba324921e4b40af,1,"void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(
    const NTPTilesVector& tiles) {
  JNIEnv* env = AttachCurrentThread();
  std::vector<base::string16> titles;
  std::vector<std::string> urls;
  std::vector<std::string> whitelist_icon_paths;
  std::vector<int> sources;

  titles.reserve(tiles.size());
  urls.reserve(tiles.size());
  whitelist_icon_paths.reserve(tiles.size());
  sources.reserve(tiles.size());
  for (const auto& tile : tiles) {
    titles.emplace_back(tile.title);
    urls.emplace_back(tile.url.spec());
     whitelist_icon_paths.emplace_back(tile.whitelist_icon_path.value());
     sources.emplace_back(static_cast<int>(tile.source));
   }
//flaw_line_below:
  Java_MostVisitedURLsObserver_onMostVisitedURLsAvailable(
//fix_flaw_line_below:
//  Java_Observer_onMostVisitedURLsAvailable(
       env, observer_, ToJavaArrayOfStrings(env, titles),
       ToJavaArrayOfStrings(env, urls),
       ToJavaArrayOfStrings(env, whitelist_icon_paths),
      ToJavaIntArray(env, sources));
}
"
8209,185945,,Remote,Not required,Partial,CVE-2015-1224,https://www.cvedetails.com/cve/CVE-2015-1224/,CWE-17,Low,,,,2015-03-08,5.0,"The VpxVideoDecoder::VpxDecode function in media/filters/vpx_video_decoder.cc in the vpxdecoder implementation in Google Chrome before 41.0.2272.76 does not ensure that alpha-plane dimensions are identical to image dimensions, which allows remote attackers to cause a denial of service (out-of-bounds read) via crafted VPx video data.",2016-12-21,DoS ,1,https://github.com/chromium/chromium/commit/5c6e9372daae557d6857f02888e84363eeff9be9,5c6e9372daae557d6857f02888e84363eeff9be9,"Rename MostVisitedSites.MostVisitedURLsObserver to Observer.

BUG=677672

Review-Url: https://codereview.chromium.org/2697543002
Cr-Commit-Position: refs/heads/master@{#449958}",0,chrome/browser/android/ntp/most_visited_sites_bridge.cc,"{""sha"": ""53362f0082ae47e69ef165910af02383ad21831a"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/suggestions/MostVisitedSites.java"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/MostVisitedSites.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/MostVisitedSites.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/suggestions/MostVisitedSites.java?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -16,9 +16,9 @@\n     private long mNativeMostVisitedSitesBridge;\n \n     /**\n-     * Interface for receiving the list of most visited urls.\n+     * An interface for handling events in {@link MostVisitedSites}.\n      */\n-    public interface MostVisitedURLsObserver {\n+    public interface Observer {\n         /**\n          * This is called when the list of most visited URLs is initially available or updated.\n          * Parameters guaranteed to be non-null.\n@@ -31,7 +31,7 @@\n          *                           strings otherwise.\n          * @param sources For each tile, the {@code NTPTileSource} that generated the tile.\n          */\n-        @CalledByNative(\""MostVisitedURLsObserver\"")\n+        @CalledByNative(\""Observer\"")\n         void onMostVisitedURLsAvailable(\n                 String[] titles, String[] urls, String[] whitelistIconPaths, int[] sources);\n \n@@ -41,7 +41,7 @@ void onMostVisitedURLsAvailable(\n          *\n          * @param siteUrl URL of site with newly-cached icon.\n          */\n-        @CalledByNative(\""MostVisitedURLsObserver\"")\n+        @CalledByNative(\""Observer\"")\n         void onIconMadeAvailable(String siteUrl);\n     }\n \n@@ -64,16 +64,13 @@ public void destroy() {\n     }\n \n     /**\n-     * Sets the MostVisitedURLsObserver to receive the list of most visited sites now or soon, and\n-     * after any changes to the list. Note: the observer may be notified synchronously or\n-     * asynchronously.\n-     * @param observer The MostVisitedURLsObserver to be called once when the most visited sites\n-     *                 are initially available and again whenever the list of most visited sites\n-     *                 changes.\n-     * @param numSites The maximum number of most visited sites to return.\n+     * Sets the recipient for events from {@link MostVisitedSites}. The observer may be notified\n+     * synchronously or asynchronously.\n+     * @param observer The observer to be notified.\n+     * @param numSites The maximum number of sites to return.\n      */\n-    public void setMostVisitedURLsObserver(final MostVisitedURLsObserver observer, int numSites) {\n-        MostVisitedURLsObserver wrappedObserver = new MostVisitedURLsObserver() {\n+    public void setObserver(final Observer observer, int numSites) {\n+        Observer wrappedObserver = new Observer() {\n             @Override\n             public void onMostVisitedURLsAvailable(\n                     String[] titles, String[] urls, String[] whitelistIconPaths, int[] sources) {\n@@ -90,7 +87,7 @@ public void onIconMadeAvailable(String siteUrl) {\n                 }\n             }\n         };\n-        nativeSetMostVisitedURLsObserver(mNativeMostVisitedSitesBridge, wrappedObserver, numSites);\n+        nativeSetObserver(mNativeMostVisitedSitesBridge, wrappedObserver, numSites);\n     }\n \n     /**\n@@ -133,8 +130,8 @@ public void recordOpenedMostVisitedItem(\n \n     private native long nativeInit(Profile profile);\n     private native void nativeDestroy(long nativeMostVisitedSitesBridge);\n-    private native void nativeSetMostVisitedURLsObserver(\n-            long nativeMostVisitedSitesBridge, MostVisitedURLsObserver observer, int numSites);\n+    private native void nativeSetObserver(\n+            long nativeMostVisitedSitesBridge, Observer observer, int numSites);\n     private native void nativeAddOrRemoveBlacklistedUrl(\n             long nativeMostVisitedSitesBridge, String url, boolean addUrl);\n     private native void nativeRecordPageImpression(""}<_**next**_>{""sha"": ""52af27f0da072e4559e6e4a1de86c9bf752ff507"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroup.java"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroup.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroup.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroup.java?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -31,7 +31,6 @@\n import org.chromium.chrome.browser.ntp.ContextMenuManager;\n import org.chromium.chrome.browser.ntp.ContextMenuManager.ContextMenuItemId;\n import org.chromium.chrome.browser.ntp.MostVisitedTileType;\n-import org.chromium.chrome.browser.suggestions.MostVisitedSites.MostVisitedURLsObserver;\n import org.chromium.chrome.browser.widget.RoundedIconGenerator;\n import org.chromium.ui.mojom.WindowOpenDisposition;\n \n@@ -44,7 +43,7 @@\n /**\n  * The model and controller for a group of site suggestion tiles.\n  */\n-public class TileGroup implements MostVisitedURLsObserver {\n+public class TileGroup implements MostVisitedSites.Observer {\n     /**\n      * Performs work in other parts of the system that the {@link TileGroup} should not know about.\n      */\n@@ -58,7 +57,7 @@\n          * @param observer The observer to be notified with the list of sites.\n          * @param maxResults The maximum number of sites to retrieve.\n          */\n-        void setMostVisitedURLsObserver(MostVisitedURLsObserver observer, int maxResults);\n+        void setMostVisitedSitesObserver(MostVisitedSites.Observer observer, int maxResults);\n \n         /**\n          * Called when the NTP has completely finished loading (all views will be inflated\n@@ -190,7 +189,7 @@ public void onIconMadeAvailable(String siteUrl) {\n      * @param maxResults The maximum number of sites to retrieve.\n      */\n     public void startObserving(int maxResults) {\n-        mTileGroupDelegate.setMostVisitedURLsObserver(this, maxResults);\n+        mTileGroupDelegate.setMostVisitedSitesObserver(this, maxResults);\n     }\n \n     /**""}<_**next**_>{""sha"": ""3a3d8bd7d065aba3392d9dd2d18b93fccd93dbd0"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroupDelegateImpl.java"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroupDelegateImpl.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroupDelegateImpl.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/suggestions/TileGroupDelegateImpl.java?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -19,7 +19,6 @@\n import org.chromium.chrome.browser.snackbar.Snackbar;\n import org.chromium.chrome.browser.snackbar.SnackbarManager;\n import org.chromium.chrome.browser.snackbar.SnackbarManager.SnackbarController;\n-import org.chromium.chrome.browser.suggestions.MostVisitedSites.MostVisitedURLsObserver;\n import org.chromium.chrome.browser.tabmodel.TabModel;\n import org.chromium.chrome.browser.tabmodel.TabModelSelector;\n import org.chromium.chrome.browser.tabmodel.TabModelUtils;\n@@ -81,10 +80,10 @@ public void openMostVisitedItem(int windowDisposition, Tile item) {\n     }\n \n     @Override\n-    public void setMostVisitedURLsObserver(MostVisitedURLsObserver observer, int maxResults) {\n+    public void setMostVisitedSitesObserver(MostVisitedSites.Observer observer, int maxResults) {\n         assert !mIsDestroyed;\n \n-        mMostVisitedSites.setMostVisitedURLsObserver(observer, maxResults);\n+        mMostVisitedSites.setObserver(observer, maxResults);\n     }\n \n     @Override""}<_**next**_>{""sha"": ""b411748dd34ebb35da14a73170f8ab20dc456f1d"", ""filename"": ""chrome/android/javatests/src/org/chromium/chrome/browser/suggestions/FakeMostVisitedSites.java"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/javatests/src/org/chromium/chrome/browser/suggestions/FakeMostVisitedSites.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/android/javatests/src/org/chromium/chrome/browser/suggestions/FakeMostVisitedSites.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/javatests/src/org/chromium/chrome/browser/suggestions/FakeMostVisitedSites.java?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -20,7 +20,7 @@\n     private String[] mUrls = new String[] {};\n     private String[] mWhitelistIconPaths = new String[] {};\n     private int[] mSources = new int[] {};\n-    private MostVisitedURLsObserver mObserver;\n+    private Observer mObserver;\n \n     /**\n      * @param profile The profile for which to fetch site suggestions.\n@@ -31,7 +31,7 @@ public FakeMostVisitedSites(Profile profile) {\n     }\n \n     @Override\n-    public void setMostVisitedURLsObserver(MostVisitedURLsObserver observer, int numResults) {\n+    public void setObserver(Observer observer, int numResults) {\n         mObserver = observer;\n         notifyTileSuggestionsAvailable();\n     }""}<_**next**_>{""sha"": ""7ebe858a24e24cdeee80cdc8f7a05f1ce52235f5"", ""filename"": ""chrome/browser/android/ntp/most_visited_sites_bridge.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/browser/android/ntp/most_visited_sites_bridge.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/browser/android/ntp/most_visited_sites_bridge.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/ntp/most_visited_sites_bridge.cc?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -72,7 +72,7 @@ void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(\n     whitelist_icon_paths.emplace_back(tile.whitelist_icon_path.value());\n     sources.emplace_back(static_cast<int>(tile.source));\n   }\n-  Java_MostVisitedURLsObserver_onMostVisitedURLsAvailable(\n+  Java_Observer_onMostVisitedURLsAvailable(\n       env, observer_, ToJavaArrayOfStrings(env, titles),\n       ToJavaArrayOfStrings(env, urls),\n       ToJavaArrayOfStrings(env, whitelist_icon_paths),\n@@ -82,7 +82,7 @@ void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(\n void MostVisitedSitesBridge::JavaObserver::OnIconMadeAvailable(\n     const GURL& site_url) {\n   JNIEnv* env = AttachCurrentThread();\n-  Java_MostVisitedURLsObserver_onIconMadeAvailable(\n+  Java_Observer_onIconMadeAvailable(\n       env, observer_, ConvertUTF8ToJavaString(env, site_url.spec()));\n }\n \n@@ -101,7 +101,7 @@ void MostVisitedSitesBridge::Destroy(\n   delete this;\n }\n \n-void MostVisitedSitesBridge::SetMostVisitedURLsObserver(\n+void MostVisitedSitesBridge::SetObserver(\n     JNIEnv* env,\n     const JavaParamRef<jobject>& obj,\n     const JavaParamRef<jobject>& j_observer,""}<_**next**_>{""sha"": ""730ef0cf9629271129fa5111ada49409907c74ca"", ""filename"": ""chrome/browser/android/ntp/most_visited_sites_bridge.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/browser/android/ntp/most_visited_sites_bridge.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5c6e9372daae557d6857f02888e84363eeff9be9/chrome/browser/android/ntp/most_visited_sites_bridge.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/ntp/most_visited_sites_bridge.h?ref=5c6e9372daae557d6857f02888e84363eeff9be9"", ""patch"": ""@@ -25,11 +25,10 @@ class MostVisitedSitesBridge {\n \n   void Destroy(JNIEnv* env, const base::android::JavaParamRef<jobject>& obj);\n \n-  void SetMostVisitedURLsObserver(\n-      JNIEnv* env,\n-      const base::android::JavaParamRef<jobject>& obj,\n-      const base::android::JavaParamRef<jobject>& j_observer,\n-      jint num_sites);\n+  void SetObserver(JNIEnv* env,\n+                   const base::android::JavaParamRef<jobject>& obj,\n+                   const base::android::JavaParamRef<jobject>& j_observer,\n+                   jint num_sites);\n \n   void AddOrRemoveBlacklistedUrl(\n       JNIEnv* env,""}","void MostVisitedSitesBridge::SetMostVisitedURLsObserver(
void MostVisitedSitesBridge::SetObserver(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj,
     const JavaParamRef<jobject>& j_observer,
    jint num_sites) {
  java_observer_.reset(new JavaObserver(env, j_observer));
  most_visited_->SetMostVisitedURLsObserver(java_observer_.get(), num_sites);
}
","void MostVisitedSitesBridge::SetMostVisitedURLsObserver(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj,
     const JavaParamRef<jobject>& j_observer,
    jint num_sites) {
  java_observer_.reset(new JavaObserver(env, j_observer));
  most_visited_->SetMostVisitedURLsObserver(java_observer_.get(), num_sites);
}
",C,"void MostVisitedSitesBridge::SetObserver(
",,,"@@ -72,7 +72,7 @@ void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(
     whitelist_icon_paths.emplace_back(tile.whitelist_icon_path.value());
     sources.emplace_back(static_cast<int>(tile.source));
   }
-  Java_MostVisitedURLsObserver_onMostVisitedURLsAvailable(
+  Java_Observer_onMostVisitedURLsAvailable(
       env, observer_, ToJavaArrayOfStrings(env, titles),
       ToJavaArrayOfStrings(env, urls),
       ToJavaArrayOfStrings(env, whitelist_icon_paths),
@@ -82,7 +82,7 @@ void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(
 void MostVisitedSitesBridge::JavaObserver::OnIconMadeAvailable(
     const GURL& site_url) {
   JNIEnv* env = AttachCurrentThread();
-  Java_MostVisitedURLsObserver_onIconMadeAvailable(
+  Java_Observer_onIconMadeAvailable(
       env, observer_, ConvertUTF8ToJavaString(env, site_url.spec()));
 }
 
@@ -101,7 +101,7 @@ void MostVisitedSitesBridge::Destroy(
   delete this;
 }
 
-void MostVisitedSitesBridge::SetMostVisitedURLsObserver(
+void MostVisitedSitesBridge::SetObserver(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj,
     const JavaParamRef<jobject>& j_observer,",Chrome,5c6e9372daae557d6857f02888e84363eeff9be9,3a41077cf9560947e1d84ea72ba324921e4b40af,1,"void MostVisitedSitesBridge::SetMostVisitedURLsObserver(
//fix_flaw_line_below:
//void MostVisitedSitesBridge::SetObserver(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj,
     const JavaParamRef<jobject>& j_observer,
    jint num_sites) {
  java_observer_.reset(new JavaObserver(env, j_observer));
  most_visited_->SetMostVisitedURLsObserver(java_observer_.get(), num_sites);
}
"
8216,185952,,Remote,Not required,Partial,CVE-2015-1233,https://www.cvedetails.com/cve/CVE-2015-1233/,CWE-17,Low,Partial,Partial,,2015-04-01,7.5,"Google Chrome before 41.0.2272.118 does not properly handle the interaction of IPC, the Gamepad API, and Google V8, which allows remote attackers to execute arbitrary code via unspecified vectors.",2016-12-21,Exec Code ,6,https://github.com/chromium/chromium/commit/31b81d4cf8b6a063391839816c82fc61c8272e53,31b81d4cf8b6a063391839816c82fc61c8272e53,"Avoid Showing rotation change notification when source is accelerometer

BUG=717252
TEST=Manually rotate device with accelerometer and observe there's no notification

Review-Url: https://codereview.chromium.org/2853113005
Cr-Commit-Position: refs/heads/master@{#469058}",2,ash/system/screen_layout_observer.cc,"{""sha"": ""0056693d5a9f7f7988d3c985e5e548ea39ae2c03"", ""filename"": ""ash/system/screen_layout_observer.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 2, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/31b81d4cf8b6a063391839816c82fc61c8272e53/ash/system/screen_layout_observer.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/31b81d4cf8b6a063391839816c82fc61c8272e53/ash/system/screen_layout_observer.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/system/screen_layout_observer.cc?ref=31b81d4cf8b6a063391839816c82fc61c8272e53"", ""patch"": ""@@ -271,8 +271,12 @@ bool ScreenLayoutObserver::GetDisplayMessageForNotification(\n           GetDisplayName(iter.first), GetDisplaySize(iter.first));\n       return true;\n     }\n-    if (iter.second.GetActiveRotation() !=\n-        old_iter->second.GetActiveRotation()) {\n+    // We don't show rotation change notification when the rotation source is\n+    // the accelerometer.\n+    if (iter.second.active_rotation_source() !=\n+            display::Display::ROTATION_SOURCE_ACCELEROMETER &&\n+        iter.second.GetActiveRotation() !=\n+            old_iter->second.GetActiveRotation()) {\n       int rotation_text_id = 0;\n       switch (iter.second.GetActiveRotation()) {\n         case display::Display::ROTATE_0:""}<_**next**_>{""sha"": ""07ffba774b58dedeeeca0369962d165b5858fdc3"", ""filename"": ""ash/system/screen_layout_observer_unittest.cc"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 0, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/31b81d4cf8b6a063391839816c82fc61c8272e53/ash/system/screen_layout_observer_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/31b81d4cf8b6a063391839816c82fc61c8272e53/ash/system/screen_layout_observer_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/system/screen_layout_observer_unittest.cc?ref=31b81d4cf8b6a063391839816c82fc61c8272e53"", ""patch"": ""@@ -430,4 +430,32 @@ TEST_F(ScreenLayoutObserverTest, DockedModeWithExternalPrimaryDisplayMessage) {\n   EXPECT_TRUE(GetDisplayNotificationAdditionalText().empty());\n }\n \n+// Tests that rotation notifications are only shown when the rotation source is\n+// a user action. The accelerometer source nevber produces any notifications.\n+TEST_F(ScreenLayoutObserverTest, RotationNotification) {\n+  Shell::Get()->screen_layout_observer()->set_show_notifications_for_testing(\n+      true);\n+  UpdateDisplay(\""400x400\"");\n+  const int64_t primary_id =\n+      display_manager()->GetPrimaryDisplayCandidate().id();\n+\n+  // The accelerometer source.\n+  display_manager()->SetDisplayRotation(\n+      primary_id, display::Display::ROTATE_90,\n+      display::Display::ROTATION_SOURCE_ACCELEROMETER);\n+  EXPECT_TRUE(GetDisplayNotificationText().empty());\n+  EXPECT_TRUE(GetDisplayNotificationAdditionalText().empty());\n+\n+  // The user source.\n+  display_manager()->SetDisplayRotation(primary_id,\n+                                        display::Display::ROTATE_180,\n+                                        display::Display::ROTATION_SOURCE_USER);\n+  EXPECT_EQ(l10n_util::GetStringFUTF16(\n+                IDS_ASH_STATUS_TRAY_DISPLAY_ROTATED, GetFirstDisplayName(),\n+                l10n_util::GetStringUTF16(\n+                    IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_180)),\n+            GetDisplayNotificationAdditionalText());\n+  EXPECT_TRUE(GetDisplayNotificationText().empty());\n+}\n+\n }  // namespace ash""}<_**next**_>{""sha"": ""5dc857c7785da2bb4a28e44822f01d8a70d545a3"", ""filename"": ""testing/buildbot/filters/ash_mus_unittests.filter"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/31b81d4cf8b6a063391839816c82fc61c8272e53/testing/buildbot/filters/ash_mus_unittests.filter"", ""raw_url"": ""https://github.com/chromium/chromium/raw/31b81d4cf8b6a063391839816c82fc61c8272e53/testing/buildbot/filters/ash_mus_unittests.filter"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/testing/buildbot/filters/ash_mus_unittests.filter?ref=31b81d4cf8b6a063391839816c82fc61c8272e53"", ""patch"": ""@@ -257,6 +257,7 @@\n -ScreenLayoutObserverTest.ExitMirrorModeBecauseOfThirdDisplayMessage\n -ScreenLayoutObserverTest.ExitMirrorModeNoInternalDisplayBecauseOfDisplayRemovedMessage\n -ScreenLayoutObserverTest.OverscanDisplay\n+-ScreenLayoutObserverTest.RotationNotification\n -ScreenLayoutObserverTest.UpdateAfterSuppressDisplayNotification\n -ScreenPositionControllerTest.ConvertHostPointToScreen\n -ScreenPositionControllerTest.ConvertHostPointToScreenHiDPI""}","bool ScreenLayoutObserver::GetDisplayMessageForNotification(
    const ScreenLayoutObserver::DisplayInfoMap& old_info,
    base::string16* out_message,
    base::string16* out_additional_message) {
  if (old_display_mode_ != current_display_mode_) {
    if (current_display_mode_ == DisplayMode::MIRRORING) {
      *out_message = GetEnterMirrorModeMessage();
      return true;
    }
    if (old_display_mode_ == DisplayMode::MIRRORING &&
        GetExitMirrorModeMessage(out_message, out_additional_message)) {
      return true;
    }

    if (current_display_mode_ == DisplayMode::UNIFIED) {
      *out_message = GetEnterUnifiedModeMessage();
      return true;
    }
    if (old_display_mode_ == DisplayMode::UNIFIED) {
      *out_message = GetExitUnifiedModeMessage();
      return true;
    }

    if (current_display_mode_ == DisplayMode::DOCKED ||
        old_display_mode_ == DisplayMode::DOCKED) {
      return false;
    }
  }

  if (display_info_.size() < old_info.size()) {
    for (const auto& iter : old_info) {
      if (display_info_.count(iter.first))
        continue;

      *out_message =
          GetDisplayRemovedMessage(iter.second, out_additional_message);
      return true;
    }
  } else if (display_info_.size() > old_info.size()) {
    for (const auto& iter : display_info_) {
      if (old_info.count(iter.first))
        continue;

      *out_message = GetDisplayAddedMessage(iter.first, out_additional_message);
      return true;
    }
  }

  for (const auto& iter : display_info_) {
    DisplayInfoMap::const_iterator old_iter = old_info.find(iter.first);
    if (old_iter == old_info.end()) {
      NOTREACHED() << ""A display mode transition that should have been handled""
                      ""earlier."";
      return false;
    }

    if (iter.second.configured_ui_scale() !=
        old_iter->second.configured_ui_scale()) {
      *out_additional_message = l10n_util::GetStringFUTF16(
          IDS_ASH_STATUS_TRAY_DISPLAY_RESOLUTION_CHANGED,
           GetDisplayName(iter.first), GetDisplaySize(iter.first));
       return true;
     }
    // We don't show rotation change notification when the rotation source is
    // the accelerometer.
    if (iter.second.active_rotation_source() !=
            display::Display::ROTATION_SOURCE_ACCELEROMETER &&
        iter.second.GetActiveRotation() !=
            old_iter->second.GetActiveRotation()) {
       int rotation_text_id = 0;
       switch (iter.second.GetActiveRotation()) {
         case display::Display::ROTATE_0:
          rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_STANDARD_ORIENTATION;
          break;
        case display::Display::ROTATE_90:
          rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_90;
          break;
        case display::Display::ROTATE_180:
          rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_180;
          break;
        case display::Display::ROTATE_270:
          rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_270;
          break;
      }
      *out_additional_message = l10n_util::GetStringFUTF16(
          IDS_ASH_STATUS_TRAY_DISPLAY_ROTATED, GetDisplayName(iter.first),
          l10n_util::GetStringUTF16(rotation_text_id));
      return true;
    }
  }

  return false;
}
","bool ScreenLayoutObserver::GetDisplayMessageForNotification(
    const ScreenLayoutObserver::DisplayInfoMap& old_info,
    base::string16* out_message,
    base::string16* out_additional_message) {
  if (old_display_mode_ != current_display_mode_) {
    if (current_display_mode_ == DisplayMode::MIRRORING) {
      *out_message = GetEnterMirrorModeMessage();
      return true;
    }
    if (old_display_mode_ == DisplayMode::MIRRORING &&
        GetExitMirrorModeMessage(out_message, out_additional_message)) {
      return true;
    }

    if (current_display_mode_ == DisplayMode::UNIFIED) {
      *out_message = GetEnterUnifiedModeMessage();
      return true;
    }
    if (old_display_mode_ == DisplayMode::UNIFIED) {
      *out_message = GetExitUnifiedModeMessage();
      return true;
    }

    if (current_display_mode_ == DisplayMode::DOCKED ||
        old_display_mode_ == DisplayMode::DOCKED) {
      return false;
    }
  }

  if (display_info_.size() < old_info.size()) {
    for (const auto& iter : old_info) {
      if (display_info_.count(iter.first))
        continue;

      *out_message =
          GetDisplayRemovedMessage(iter.second, out_additional_message);
      return true;
    }
  } else if (display_info_.size() > old_info.size()) {
    for (const auto& iter : display_info_) {
      if (old_info.count(iter.first))
        continue;

      *out_message = GetDisplayAddedMessage(iter.first, out_additional_message);
      return true;
    }
  }

  for (const auto& iter : display_info_) {
    DisplayInfoMap::const_iterator old_iter = old_info.find(iter.first);
    if (old_iter == old_info.end()) {
      NOTREACHED() << ""A display mode transition that should have been handled""
                      ""earlier."";
      return false;
    }

    if (iter.second.configured_ui_scale() !=
        old_iter->second.configured_ui_scale()) {
      *out_additional_message = l10n_util::GetStringFUTF16(
          IDS_ASH_STATUS_TRAY_DISPLAY_RESOLUTION_CHANGED,
           GetDisplayName(iter.first), GetDisplaySize(iter.first));
       return true;
     }
    if (iter.second.GetActiveRotation() !=
        old_iter->second.GetActiveRotation()) {
       int rotation_text_id = 0;
       switch (iter.second.GetActiveRotation()) {
         case display::Display::ROTATE_0:
          rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_STANDARD_ORIENTATION;
          break;
        case display::Display::ROTATE_90:
          rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_90;
          break;
        case display::Display::ROTATE_180:
          rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_180;
          break;
        case display::Display::ROTATE_270:
          rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_270;
          break;
      }
      *out_additional_message = l10n_util::GetStringFUTF16(
          IDS_ASH_STATUS_TRAY_DISPLAY_ROTATED, GetDisplayName(iter.first),
          l10n_util::GetStringUTF16(rotation_text_id));
      return true;
    }
  }

  return false;
}
",C,"    // We don't show rotation change notification when the rotation source is
    // the accelerometer.
    if (iter.second.active_rotation_source() !=
            display::Display::ROTATION_SOURCE_ACCELEROMETER &&
        iter.second.GetActiveRotation() !=
            old_iter->second.GetActiveRotation()) {
","    if (iter.second.GetActiveRotation() !=
        old_iter->second.GetActiveRotation()) {
",,"@@ -271,8 +271,12 @@ bool ScreenLayoutObserver::GetDisplayMessageForNotification(
           GetDisplayName(iter.first), GetDisplaySize(iter.first));
       return true;
     }
-    if (iter.second.GetActiveRotation() !=
-        old_iter->second.GetActiveRotation()) {
+    // We don't show rotation change notification when the rotation source is
+    // the accelerometer.
+    if (iter.second.active_rotation_source() !=
+            display::Display::ROTATION_SOURCE_ACCELEROMETER &&
+        iter.second.GetActiveRotation() !=
+            old_iter->second.GetActiveRotation()) {
       int rotation_text_id = 0;
       switch (iter.second.GetActiveRotation()) {
         case display::Display::ROTATE_0:",Chrome,31b81d4cf8b6a063391839816c82fc61c8272e53,ddffea091f64d790fa6b2f40a82e19b39b1768c9,1,"bool ScreenLayoutObserver::GetDisplayMessageForNotification(
    const ScreenLayoutObserver::DisplayInfoMap& old_info,
    base::string16* out_message,
    base::string16* out_additional_message) {
  if (old_display_mode_ != current_display_mode_) {
    // Detect changes in the mirror mode status.
    if (current_display_mode_ == DisplayMode::MIRRORING) {
      *out_message = GetEnterMirrorModeMessage();
      return true;
    }
    if (old_display_mode_ == DisplayMode::MIRRORING &&
        GetExitMirrorModeMessage(out_message, out_additional_message)) {
      return true;
    }

    // Detect changes in the unified mode status.
    if (current_display_mode_ == DisplayMode::UNIFIED) {
      *out_message = GetEnterUnifiedModeMessage();
      return true;
    }
    if (old_display_mode_ == DisplayMode::UNIFIED) {
      *out_message = GetExitUnifiedModeMessage();
      return true;
    }

    if (current_display_mode_ == DisplayMode::DOCKED ||
        old_display_mode_ == DisplayMode::DOCKED) {
      // We no longer show any notification for docked mode events.
      // crbug.com/674719.
      return false;
    }
  }

  // Displays are added or removed.
  if (display_info_.size() < old_info.size()) {
    // A display has been removed.
    for (const auto& iter : old_info) {
      if (display_info_.count(iter.first))
        continue;

      *out_message =
          GetDisplayRemovedMessage(iter.second, out_additional_message);
      return true;
    }
  } else if (display_info_.size() > old_info.size()) {
    // A display has been added.
    for (const auto& iter : display_info_) {
      if (old_info.count(iter.first))
        continue;

      *out_message = GetDisplayAddedMessage(iter.first, out_additional_message);
      return true;
    }
  }

  for (const auto& iter : display_info_) {
    DisplayInfoMap::const_iterator old_iter = old_info.find(iter.first);
    if (old_iter == old_info.end()) {
      // The display's number is same but different displays. This happens
      // for the transition between docked mode and mirrored display.
      // This condition can never be reached here, since it is handled above.
      NOTREACHED() << ""A display mode transition that should have been handled""
                      ""earlier."";
      return false;
    }

    if (iter.second.configured_ui_scale() !=
        old_iter->second.configured_ui_scale()) {
      *out_additional_message = l10n_util::GetStringFUTF16(
          IDS_ASH_STATUS_TRAY_DISPLAY_RESOLUTION_CHANGED,
           GetDisplayName(iter.first), GetDisplaySize(iter.first));
       return true;
     }
//flaw_line_below:
    if (iter.second.GetActiveRotation() !=
//flaw_line_below:
        old_iter->second.GetActiveRotation()) {
//fix_flaw_line_below:
//    // We don't show rotation change notification when the rotation source is
//fix_flaw_line_below:
//    // the accelerometer.
//fix_flaw_line_below:
//    if (iter.second.active_rotation_source() !=
//fix_flaw_line_below:
//            display::Display::ROTATION_SOURCE_ACCELEROMETER &&
//fix_flaw_line_below:
//        iter.second.GetActiveRotation() !=
//fix_flaw_line_below:
//            old_iter->second.GetActiveRotation()) {
       int rotation_text_id = 0;
       switch (iter.second.GetActiveRotation()) {
         case display::Display::ROTATE_0:
          rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_STANDARD_ORIENTATION;
          break;
        case display::Display::ROTATE_90:
          rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_90;
          break;
        case display::Display::ROTATE_180:
          rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_180;
          break;
        case display::Display::ROTATE_270:
          rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_270;
          break;
      }
      *out_additional_message = l10n_util::GetStringFUTF16(
          IDS_ASH_STATUS_TRAY_DISPLAY_ROTATED, GetDisplayName(iter.first),
          l10n_util::GetStringUTF16(rotation_text_id));
      return true;
    }
  }

  // Found nothing special
  return false;
}
"
8438,186174,,Remote,Not required,,CVE-2016-1640,https://www.cvedetails.com/cve/CVE-2016-1640/,CWE-17,Medium,,Partial,,2016-03-05,4.3,"The Web Store inline-installer implementation in the Extensions UI in Google Chrome before 49.0.2623.75 does not block installations upon deletion of an installation frame, which makes it easier for remote attackers to trick a user into believing that an installation request originated from the user's next navigation target via a crafted web site.",2016-12-02,,2,https://github.com/chromium/chromium/commit/0a1c15fecb1240ab909e1431b6127410c3b380e0,0a1c15fecb1240ab909e1431b6127410c3b380e0,"Make the webstore inline install dialog be tab-modal

Also clean up a few minor lint errors while I'm in here.

BUG=550047

Review URL: https://codereview.chromium.org/1496033003

Cr-Commit-Position: refs/heads/master@{#363925}",1,chrome/browser/ui/views/extensions/extension_install_dialog_view.cc,"{""sha"": ""619f600f3e515b2cb79365aeb9547659b70caa8c"", ""filename"": ""chrome/browser/extensions/extension_install_prompt.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/extensions/extension_install_prompt.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/extensions/extension_install_prompt.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_install_prompt.cc?ref=0a1c15fecb1240ab909e1431b6127410c3b380e0"", ""patch"": ""@@ -408,6 +408,13 @@ bool ExtensionInstallPrompt::Prompt::ShouldShowPermissions() const {\n          type_ == POST_INSTALL_PERMISSIONS_PROMPT;\n }\n \n+bool ExtensionInstallPrompt::Prompt::ShouldUseTabModalDialog() const {\n+  // For inline install, we want the install prompt to be tab modal so that the\n+  // dialog is always clearly associated with the page that made the inline\n+  // install request.\n+  return type_ == INLINE_INSTALL_PROMPT;\n+}\n+\n void ExtensionInstallPrompt::Prompt::AppendRatingStars(\n     StarAppender appender, void* data) const {\n   CHECK(appender);""}<_**next**_>{""sha"": ""6cf7320267c89f43a35a47e5337e99263a3ba800"", ""filename"": ""chrome/browser/extensions/extension_install_prompt.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/extensions/extension_install_prompt.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/extensions/extension_install_prompt.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_install_prompt.h?ref=0a1c15fecb1240ab909e1431b6127410c3b380e0"", ""patch"": ""@@ -128,6 +128,8 @@ class ExtensionInstallPrompt\n \n     bool ShouldShowPermissions() const;\n \n+    bool ShouldUseTabModalDialog() const;\n+\n     // Getters for webstore metadata. Only populated when the type is\n     // INLINE_INSTALL_PROMPT, EXTERNAL_INSTALL_PROMPT, or REPAIR_PROMPT.\n ""}<_**next**_>{""sha"": ""ff1ac90f583c27c2c9a888504cb702c9e3ccee14"", ""filename"": ""chrome/browser/ui/views/extensions/extension_install_dialog_view.cc"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 4, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/ui/views/extensions/extension_install_dialog_view.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/ui/views/extensions/extension_install_dialog_view.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/extension_install_dialog_view.cc?ref=0a1c15fecb1240ab909e1431b6127410c3b380e0"", ""patch"": ""@@ -4,6 +4,8 @@\n \n #include \""chrome/browser/ui/views/extensions/extension_install_dialog_view.h\""\n \n+#include <algorithm>\n+#include <string>\n #include <vector>\n \n #include \""base/basictypes.h\""\n@@ -107,8 +109,16 @@ void ShowExtensionInstallDialogImpl(\n                                      show_params->GetParentWebContents(),\n                                      delegate,\n                                      prompt);\n-  constrained_window::CreateBrowserModalDialogViews(\n-      dialog, show_params->GetParentWindow())->Show();\n+  if (prompt->ShouldUseTabModalDialog()) {\n+    content::WebContents* parent_web_contents =\n+        show_params->GetParentWebContents();\n+    if (parent_web_contents)\n+      constrained_window::ShowWebModalDialogViews(dialog, parent_web_contents);\n+  } else {\n+    constrained_window::CreateBrowserModalDialogViews(\n+        dialog, show_params->GetParentWindow())\n+        ->Show();\n+  }\n }\n \n // A custom scrollable view implementation for the dialog.\n@@ -412,7 +422,7 @@ void ExtensionInstallDialogView::InitView() {\n     scroll_layout->AddView(issue_advice_view);\n   }\n \n-  DCHECK(prompt_->type() >= 0);\n+  DCHECK_GE(prompt_->type(), 0);\n   UMA_HISTOGRAM_ENUMERATION(\""Extensions.InstallPrompt.Type\"",\n                             prompt_->type(),\n                             ExtensionInstallPrompt::NUM_PROMPT_TYPES);\n@@ -598,7 +608,8 @@ bool ExtensionInstallDialogView::Accept() {\n }\n \n ui::ModalType ExtensionInstallDialogView::GetModalType() const {\n-  return ui::MODAL_TYPE_WINDOW;\n+  return prompt_->ShouldUseTabModalDialog() ? ui::MODAL_TYPE_CHILD\n+                                            : ui::MODAL_TYPE_WINDOW;\n }\n \n void ExtensionInstallDialogView::LinkClicked(views::Link* source,""}"," ui::ModalType ExtensionInstallDialogView::GetModalType() const {
  return prompt_->ShouldUseTabModalDialog() ? ui::MODAL_TYPE_CHILD
                                            : ui::MODAL_TYPE_WINDOW;
 }
"," ui::ModalType ExtensionInstallDialogView::GetModalType() const {
  return ui::MODAL_TYPE_WINDOW;
 }
",C,"  return prompt_->ShouldUseTabModalDialog() ? ui::MODAL_TYPE_CHILD
                                            : ui::MODAL_TYPE_WINDOW;
","  return ui::MODAL_TYPE_WINDOW;
",,"@@ -4,6 +4,8 @@
 
 #include ""chrome/browser/ui/views/extensions/extension_install_dialog_view.h""
 
+#include <algorithm>
+#include <string>
 #include <vector>
 
 #include ""base/basictypes.h""
@@ -107,8 +109,16 @@ void ShowExtensionInstallDialogImpl(
                                      show_params->GetParentWebContents(),
                                      delegate,
                                      prompt);
-  constrained_window::CreateBrowserModalDialogViews(
-      dialog, show_params->GetParentWindow())->Show();
+  if (prompt->ShouldUseTabModalDialog()) {
+    content::WebContents* parent_web_contents =
+        show_params->GetParentWebContents();
+    if (parent_web_contents)
+      constrained_window::ShowWebModalDialogViews(dialog, parent_web_contents);
+  } else {
+    constrained_window::CreateBrowserModalDialogViews(
+        dialog, show_params->GetParentWindow())
+        ->Show();
+  }
 }
 
 // A custom scrollable view implementation for the dialog.
@@ -412,7 +422,7 @@ void ExtensionInstallDialogView::InitView() {
     scroll_layout->AddView(issue_advice_view);
   }
 
-  DCHECK(prompt_->type() >= 0);
+  DCHECK_GE(prompt_->type(), 0);
   UMA_HISTOGRAM_ENUMERATION(""Extensions.InstallPrompt.Type"",
                             prompt_->type(),
                             ExtensionInstallPrompt::NUM_PROMPT_TYPES);
@@ -598,7 +608,8 @@ bool ExtensionInstallDialogView::Accept() {
 }
 
 ui::ModalType ExtensionInstallDialogView::GetModalType() const {
-  return ui::MODAL_TYPE_WINDOW;
+  return prompt_->ShouldUseTabModalDialog() ? ui::MODAL_TYPE_CHILD
+                                            : ui::MODAL_TYPE_WINDOW;
 }
 
 void ExtensionInstallDialogView::LinkClicked(views::Link* source,",Chrome,0a1c15fecb1240ab909e1431b6127410c3b380e0,5d23f8c18f1d9fbf1655ece40b31d59dea443c60,1," ui::ModalType ExtensionInstallDialogView::GetModalType() const {
//flaw_line_below:
  return ui::MODAL_TYPE_WINDOW;
//fix_flaw_line_below:
//  return prompt_->ShouldUseTabModalDialog() ? ui::MODAL_TYPE_CHILD
//fix_flaw_line_below:
//                                            : ui::MODAL_TYPE_WINDOW;
 }
"
8439,186175,,Remote,Not required,,CVE-2016-1640,https://www.cvedetails.com/cve/CVE-2016-1640/,CWE-17,Medium,,Partial,,2016-03-05,4.3,"The Web Store inline-installer implementation in the Extensions UI in Google Chrome before 49.0.2623.75 does not block installations upon deletion of an installation frame, which makes it easier for remote attackers to trick a user into believing that an installation request originated from the user's next navigation target via a crafted web site.",2016-12-02,,1,https://github.com/chromium/chromium/commit/0a1c15fecb1240ab909e1431b6127410c3b380e0,0a1c15fecb1240ab909e1431b6127410c3b380e0,"Make the webstore inline install dialog be tab-modal

Also clean up a few minor lint errors while I'm in here.

BUG=550047

Review URL: https://codereview.chromium.org/1496033003

Cr-Commit-Position: refs/heads/master@{#363925}",1,chrome/browser/ui/views/extensions/extension_install_dialog_view.cc,"{""sha"": ""619f600f3e515b2cb79365aeb9547659b70caa8c"", ""filename"": ""chrome/browser/extensions/extension_install_prompt.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/extensions/extension_install_prompt.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/extensions/extension_install_prompt.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_install_prompt.cc?ref=0a1c15fecb1240ab909e1431b6127410c3b380e0"", ""patch"": ""@@ -408,6 +408,13 @@ bool ExtensionInstallPrompt::Prompt::ShouldShowPermissions() const {\n          type_ == POST_INSTALL_PERMISSIONS_PROMPT;\n }\n \n+bool ExtensionInstallPrompt::Prompt::ShouldUseTabModalDialog() const {\n+  // For inline install, we want the install prompt to be tab modal so that the\n+  // dialog is always clearly associated with the page that made the inline\n+  // install request.\n+  return type_ == INLINE_INSTALL_PROMPT;\n+}\n+\n void ExtensionInstallPrompt::Prompt::AppendRatingStars(\n     StarAppender appender, void* data) const {\n   CHECK(appender);""}<_**next**_>{""sha"": ""6cf7320267c89f43a35a47e5337e99263a3ba800"", ""filename"": ""chrome/browser/extensions/extension_install_prompt.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/extensions/extension_install_prompt.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/extensions/extension_install_prompt.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_install_prompt.h?ref=0a1c15fecb1240ab909e1431b6127410c3b380e0"", ""patch"": ""@@ -128,6 +128,8 @@ class ExtensionInstallPrompt\n \n     bool ShouldShowPermissions() const;\n \n+    bool ShouldUseTabModalDialog() const;\n+\n     // Getters for webstore metadata. Only populated when the type is\n     // INLINE_INSTALL_PROMPT, EXTERNAL_INSTALL_PROMPT, or REPAIR_PROMPT.\n ""}<_**next**_>{""sha"": ""ff1ac90f583c27c2c9a888504cb702c9e3ccee14"", ""filename"": ""chrome/browser/ui/views/extensions/extension_install_dialog_view.cc"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 4, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/ui/views/extensions/extension_install_dialog_view.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/ui/views/extensions/extension_install_dialog_view.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/extension_install_dialog_view.cc?ref=0a1c15fecb1240ab909e1431b6127410c3b380e0"", ""patch"": ""@@ -4,6 +4,8 @@\n \n #include \""chrome/browser/ui/views/extensions/extension_install_dialog_view.h\""\n \n+#include <algorithm>\n+#include <string>\n #include <vector>\n \n #include \""base/basictypes.h\""\n@@ -107,8 +109,16 @@ void ShowExtensionInstallDialogImpl(\n                                      show_params->GetParentWebContents(),\n                                      delegate,\n                                      prompt);\n-  constrained_window::CreateBrowserModalDialogViews(\n-      dialog, show_params->GetParentWindow())->Show();\n+  if (prompt->ShouldUseTabModalDialog()) {\n+    content::WebContents* parent_web_contents =\n+        show_params->GetParentWebContents();\n+    if (parent_web_contents)\n+      constrained_window::ShowWebModalDialogViews(dialog, parent_web_contents);\n+  } else {\n+    constrained_window::CreateBrowserModalDialogViews(\n+        dialog, show_params->GetParentWindow())\n+        ->Show();\n+  }\n }\n \n // A custom scrollable view implementation for the dialog.\n@@ -412,7 +422,7 @@ void ExtensionInstallDialogView::InitView() {\n     scroll_layout->AddView(issue_advice_view);\n   }\n \n-  DCHECK(prompt_->type() >= 0);\n+  DCHECK_GE(prompt_->type(), 0);\n   UMA_HISTOGRAM_ENUMERATION(\""Extensions.InstallPrompt.Type\"",\n                             prompt_->type(),\n                             ExtensionInstallPrompt::NUM_PROMPT_TYPES);\n@@ -598,7 +608,8 @@ bool ExtensionInstallDialogView::Accept() {\n }\n \n ui::ModalType ExtensionInstallDialogView::GetModalType() const {\n-  return ui::MODAL_TYPE_WINDOW;\n+  return prompt_->ShouldUseTabModalDialog() ? ui::MODAL_TYPE_CHILD\n+                                            : ui::MODAL_TYPE_WINDOW;\n }\n \n void ExtensionInstallDialogView::LinkClicked(views::Link* source,""}","void ExtensionInstallDialogView::InitView() {
  int left_column_width =
      (prompt_->ShouldShowPermissions() || prompt_->GetRetainedFileCount() > 0)
          ? kPermissionsLeftColumnWidth
          : kNoPermissionsLeftColumnWidth;
  if (is_external_install())
    left_column_width = kExternalInstallLeftColumnWidth;

  int column_set_id = 0;
  views::GridLayout* layout = CreateLayout(left_column_width, column_set_id);

  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();

  if (prompt_->has_webstore_data()) {
    layout->StartRow(0, column_set_id);
    views::View* rating = new views::View();
    rating->SetLayoutManager(new views::BoxLayout(
        views::BoxLayout::kHorizontal, 0, 0, 0));
    layout->AddView(rating);
    prompt_->AppendRatingStars(AddResourceIcon, rating);

    const gfx::FontList& small_font_list =
        rb.GetFontList(ui::ResourceBundle::SmallFont);
    views::Label* rating_count =
        new views::Label(prompt_->GetRatingCount(), small_font_list);
    rating_count->SetBorder(views::Border::CreateEmptyBorder(0, 2, 0, 0));
    rating->AddChildView(rating_count);

    layout->StartRow(0, column_set_id);
    views::Label* user_count =
        new views::Label(prompt_->GetUserCount(), small_font_list);
    user_count->SetAutoColorReadabilityEnabled(false);
    user_count->SetEnabledColor(SK_ColorGRAY);
    layout->AddView(user_count);

    layout->StartRow(0, column_set_id);
    views::Link* store_link = new views::Link(
        l10n_util::GetStringUTF16(IDS_EXTENSION_PROMPT_STORE_LINK));
    store_link->SetFontList(small_font_list);
    store_link->set_listener(this);
    layout->AddView(store_link);

    if (prompt_->ShouldShowPermissions()) {
      layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);
      layout->StartRow(0, column_set_id);
      layout->AddView(new views::Separator(views::Separator::HORIZONTAL),
                      3,
                      1,
                      views::GridLayout::FILL,
                      views::GridLayout::FILL);
    }
  }

  int content_width = left_column_width + views::kPanelHorizMargin + kIconSize;

  CustomScrollableView* scrollable = new CustomScrollableView();
  views::GridLayout* scroll_layout = new views::GridLayout(scrollable);
  scrollable->SetLayoutManager(scroll_layout);

  views::ColumnSet* scrollable_column_set =
      scroll_layout->AddColumnSet(column_set_id);
  int scrollable_width = prompt_->has_webstore_data() ? content_width
                                                      : left_column_width;
  scrollable_column_set->AddColumn(views::GridLayout::LEADING,
                                   views::GridLayout::LEADING,
                                   0,  // no resizing
                                   views::GridLayout::USE_PREF,
                                   scrollable_width,
                                   scrollable_width);
  int padding_width =
      content_width + views::kButtonHEdgeMarginNew - scrollable_width;
  scrollable_column_set->AddPaddingColumn(0, padding_width);

  layout->StartRow(0, column_set_id);
  scroll_view_ = new views::ScrollView();
  scroll_view_->set_hide_horizontal_scrollbar(true);
  scroll_view_->SetContents(scrollable);
  layout->AddView(scroll_view_, 4, 1);

  if (is_bundle_install()) {
    BundleInstaller::ItemList items = prompt_->bundle()->GetItemsWithState(
        BundleInstaller::Item::STATE_PENDING);
    scroll_layout->AddPaddingRow(0, views::kRelatedControlSmallVerticalSpacing);
    for (const BundleInstaller::Item& item : items) {
      scroll_layout->StartRow(0, column_set_id);
      views::Label* extension_label =
          new views::Label(item.GetNameForDisplay());
      extension_label->SetMultiLine(true);
      extension_label->SetHorizontalAlignment(gfx::ALIGN_LEFT);
      extension_label->SizeToFit(
          scrollable_width - kSmallIconSize - kSmallIconPadding);
      gfx::ImageSkia image = gfx::ImageSkia::CreateFrom1xBitmap(item.icon);
      scroll_layout->AddView(new IconedView(extension_label, image));
    }
    scroll_layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);
  }

  if (prompt_->ShouldShowPermissions()) {
    bool has_permissions =
        prompt_->GetPermissionCount(
            ExtensionInstallPrompt::PermissionsType::ALL_PERMISSIONS) > 0;
    if (has_permissions) {
      AddPermissions(
          scroll_layout,
          rb,
          column_set_id,
          scrollable_width,
          ExtensionInstallPrompt::PermissionsType::REGULAR_PERMISSIONS);
      AddPermissions(
          scroll_layout,
          rb,
          column_set_id,
          scrollable_width,
          ExtensionInstallPrompt::PermissionsType::WITHHELD_PERMISSIONS);
    } else {
      scroll_layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);
      scroll_layout->StartRow(0, column_set_id);
      views::Label* permission_label = new views::Label(
          l10n_util::GetStringUTF16(IDS_EXTENSION_NO_SPECIAL_PERMISSIONS));
      permission_label->SetMultiLine(true);
      permission_label->SetHorizontalAlignment(gfx::ALIGN_LEFT);
      permission_label->SizeToFit(scrollable_width);
      scroll_layout->AddView(permission_label);
    }
  }

  if (prompt_->GetRetainedFileCount()) {
    scroll_layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);

    scroll_layout->StartRow(0, column_set_id);
    views::Label* retained_files_header =
        new views::Label(prompt_->GetRetainedFilesHeading());
    retained_files_header->SetMultiLine(true);
    retained_files_header->SetHorizontalAlignment(gfx::ALIGN_LEFT);
    retained_files_header->SizeToFit(scrollable_width);
    scroll_layout->AddView(retained_files_header);

    scroll_layout->StartRow(0, column_set_id);
    PermissionDetails details;
    for (size_t i = 0; i < prompt_->GetRetainedFileCount(); ++i) {
      details.push_back(prompt_->GetRetainedFile(i));
    }
    ExpandableContainerView* issue_advice_view =
        new ExpandableContainerView(this,
                                    base::string16(),
                                    details,
                                    scrollable_width,
                                    false);
    scroll_layout->AddView(issue_advice_view);
  }

  if (prompt_->GetRetainedDeviceCount()) {
    scroll_layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);

    scroll_layout->StartRow(0, column_set_id);
    views::Label* retained_devices_header =
        new views::Label(prompt_->GetRetainedDevicesHeading());
    retained_devices_header->SetMultiLine(true);
    retained_devices_header->SetHorizontalAlignment(gfx::ALIGN_LEFT);
    retained_devices_header->SizeToFit(scrollable_width);
    scroll_layout->AddView(retained_devices_header);

    scroll_layout->StartRow(0, column_set_id);
    PermissionDetails details;
    for (size_t i = 0; i < prompt_->GetRetainedDeviceCount(); ++i) {
      details.push_back(prompt_->GetRetainedDeviceMessageString(i));
    }
    ExpandableContainerView* issue_advice_view =
        new ExpandableContainerView(this,
                                    base::string16(),
                                    details,
                                    scrollable_width,
                                    false);
     scroll_layout->AddView(issue_advice_view);
   }
 
  DCHECK_GE(prompt_->type(), 0);
   UMA_HISTOGRAM_ENUMERATION(""Extensions.InstallPrompt.Type"",
                             prompt_->type(),
                             ExtensionInstallPrompt::NUM_PROMPT_TYPES);

  scroll_view_->ClipHeightTo(
      0,
      std::min(kScrollViewMaxHeight, scrollable->GetPreferredSize().height()));

  dialog_size_ = gfx::Size(
      content_width + 2 * views::kButtonHEdgeMarginNew,
      container_->GetPreferredSize().height());

  std::string event_name = ExperienceSamplingEvent::kExtensionInstallDialog;
  event_name.append(
      ExtensionInstallPrompt::PromptTypeToString(prompt_->type()));
  sampling_event_ = ExperienceSamplingEvent::Create(event_name);
}
","void ExtensionInstallDialogView::InitView() {
  int left_column_width =
      (prompt_->ShouldShowPermissions() || prompt_->GetRetainedFileCount() > 0)
          ? kPermissionsLeftColumnWidth
          : kNoPermissionsLeftColumnWidth;
  if (is_external_install())
    left_column_width = kExternalInstallLeftColumnWidth;

  int column_set_id = 0;
  views::GridLayout* layout = CreateLayout(left_column_width, column_set_id);

  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();

  if (prompt_->has_webstore_data()) {
    layout->StartRow(0, column_set_id);
    views::View* rating = new views::View();
    rating->SetLayoutManager(new views::BoxLayout(
        views::BoxLayout::kHorizontal, 0, 0, 0));
    layout->AddView(rating);
    prompt_->AppendRatingStars(AddResourceIcon, rating);

    const gfx::FontList& small_font_list =
        rb.GetFontList(ui::ResourceBundle::SmallFont);
    views::Label* rating_count =
        new views::Label(prompt_->GetRatingCount(), small_font_list);
    rating_count->SetBorder(views::Border::CreateEmptyBorder(0, 2, 0, 0));
    rating->AddChildView(rating_count);

    layout->StartRow(0, column_set_id);
    views::Label* user_count =
        new views::Label(prompt_->GetUserCount(), small_font_list);
    user_count->SetAutoColorReadabilityEnabled(false);
    user_count->SetEnabledColor(SK_ColorGRAY);
    layout->AddView(user_count);

    layout->StartRow(0, column_set_id);
    views::Link* store_link = new views::Link(
        l10n_util::GetStringUTF16(IDS_EXTENSION_PROMPT_STORE_LINK));
    store_link->SetFontList(small_font_list);
    store_link->set_listener(this);
    layout->AddView(store_link);

    if (prompt_->ShouldShowPermissions()) {
      layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);
      layout->StartRow(0, column_set_id);
      layout->AddView(new views::Separator(views::Separator::HORIZONTAL),
                      3,
                      1,
                      views::GridLayout::FILL,
                      views::GridLayout::FILL);
    }
  }

  int content_width = left_column_width + views::kPanelHorizMargin + kIconSize;

  CustomScrollableView* scrollable = new CustomScrollableView();
  views::GridLayout* scroll_layout = new views::GridLayout(scrollable);
  scrollable->SetLayoutManager(scroll_layout);

  views::ColumnSet* scrollable_column_set =
      scroll_layout->AddColumnSet(column_set_id);
  int scrollable_width = prompt_->has_webstore_data() ? content_width
                                                      : left_column_width;
  scrollable_column_set->AddColumn(views::GridLayout::LEADING,
                                   views::GridLayout::LEADING,
                                   0,  // no resizing
                                   views::GridLayout::USE_PREF,
                                   scrollable_width,
                                   scrollable_width);
  int padding_width =
      content_width + views::kButtonHEdgeMarginNew - scrollable_width;
  scrollable_column_set->AddPaddingColumn(0, padding_width);

  layout->StartRow(0, column_set_id);
  scroll_view_ = new views::ScrollView();
  scroll_view_->set_hide_horizontal_scrollbar(true);
  scroll_view_->SetContents(scrollable);
  layout->AddView(scroll_view_, 4, 1);

  if (is_bundle_install()) {
    BundleInstaller::ItemList items = prompt_->bundle()->GetItemsWithState(
        BundleInstaller::Item::STATE_PENDING);
    scroll_layout->AddPaddingRow(0, views::kRelatedControlSmallVerticalSpacing);
    for (const BundleInstaller::Item& item : items) {
      scroll_layout->StartRow(0, column_set_id);
      views::Label* extension_label =
          new views::Label(item.GetNameForDisplay());
      extension_label->SetMultiLine(true);
      extension_label->SetHorizontalAlignment(gfx::ALIGN_LEFT);
      extension_label->SizeToFit(
          scrollable_width - kSmallIconSize - kSmallIconPadding);
      gfx::ImageSkia image = gfx::ImageSkia::CreateFrom1xBitmap(item.icon);
      scroll_layout->AddView(new IconedView(extension_label, image));
    }
    scroll_layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);
  }

  if (prompt_->ShouldShowPermissions()) {
    bool has_permissions =
        prompt_->GetPermissionCount(
            ExtensionInstallPrompt::PermissionsType::ALL_PERMISSIONS) > 0;
    if (has_permissions) {
      AddPermissions(
          scroll_layout,
          rb,
          column_set_id,
          scrollable_width,
          ExtensionInstallPrompt::PermissionsType::REGULAR_PERMISSIONS);
      AddPermissions(
          scroll_layout,
          rb,
          column_set_id,
          scrollable_width,
          ExtensionInstallPrompt::PermissionsType::WITHHELD_PERMISSIONS);
    } else {
      scroll_layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);
      scroll_layout->StartRow(0, column_set_id);
      views::Label* permission_label = new views::Label(
          l10n_util::GetStringUTF16(IDS_EXTENSION_NO_SPECIAL_PERMISSIONS));
      permission_label->SetMultiLine(true);
      permission_label->SetHorizontalAlignment(gfx::ALIGN_LEFT);
      permission_label->SizeToFit(scrollable_width);
      scroll_layout->AddView(permission_label);
    }
  }

  if (prompt_->GetRetainedFileCount()) {
    scroll_layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);

    scroll_layout->StartRow(0, column_set_id);
    views::Label* retained_files_header =
        new views::Label(prompt_->GetRetainedFilesHeading());
    retained_files_header->SetMultiLine(true);
    retained_files_header->SetHorizontalAlignment(gfx::ALIGN_LEFT);
    retained_files_header->SizeToFit(scrollable_width);
    scroll_layout->AddView(retained_files_header);

    scroll_layout->StartRow(0, column_set_id);
    PermissionDetails details;
    for (size_t i = 0; i < prompt_->GetRetainedFileCount(); ++i) {
      details.push_back(prompt_->GetRetainedFile(i));
    }
    ExpandableContainerView* issue_advice_view =
        new ExpandableContainerView(this,
                                    base::string16(),
                                    details,
                                    scrollable_width,
                                    false);
    scroll_layout->AddView(issue_advice_view);
  }

  if (prompt_->GetRetainedDeviceCount()) {
    scroll_layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);

    scroll_layout->StartRow(0, column_set_id);
    views::Label* retained_devices_header =
        new views::Label(prompt_->GetRetainedDevicesHeading());
    retained_devices_header->SetMultiLine(true);
    retained_devices_header->SetHorizontalAlignment(gfx::ALIGN_LEFT);
    retained_devices_header->SizeToFit(scrollable_width);
    scroll_layout->AddView(retained_devices_header);

    scroll_layout->StartRow(0, column_set_id);
    PermissionDetails details;
    for (size_t i = 0; i < prompt_->GetRetainedDeviceCount(); ++i) {
      details.push_back(prompt_->GetRetainedDeviceMessageString(i));
    }
    ExpandableContainerView* issue_advice_view =
        new ExpandableContainerView(this,
                                    base::string16(),
                                    details,
                                    scrollable_width,
                                    false);
     scroll_layout->AddView(issue_advice_view);
   }
 
  DCHECK(prompt_->type() >= 0);
   UMA_HISTOGRAM_ENUMERATION(""Extensions.InstallPrompt.Type"",
                             prompt_->type(),
                             ExtensionInstallPrompt::NUM_PROMPT_TYPES);

  scroll_view_->ClipHeightTo(
      0,
      std::min(kScrollViewMaxHeight, scrollable->GetPreferredSize().height()));

  dialog_size_ = gfx::Size(
      content_width + 2 * views::kButtonHEdgeMarginNew,
      container_->GetPreferredSize().height());

  std::string event_name = ExperienceSamplingEvent::kExtensionInstallDialog;
  event_name.append(
      ExtensionInstallPrompt::PromptTypeToString(prompt_->type()));
  sampling_event_ = ExperienceSamplingEvent::Create(event_name);
}
",C,"  DCHECK_GE(prompt_->type(), 0);
","  DCHECK(prompt_->type() >= 0);
",,"@@ -4,6 +4,8 @@
 
 #include ""chrome/browser/ui/views/extensions/extension_install_dialog_view.h""
 
+#include <algorithm>
+#include <string>
 #include <vector>
 
 #include ""base/basictypes.h""
@@ -107,8 +109,16 @@ void ShowExtensionInstallDialogImpl(
                                      show_params->GetParentWebContents(),
                                      delegate,
                                      prompt);
-  constrained_window::CreateBrowserModalDialogViews(
-      dialog, show_params->GetParentWindow())->Show();
+  if (prompt->ShouldUseTabModalDialog()) {
+    content::WebContents* parent_web_contents =
+        show_params->GetParentWebContents();
+    if (parent_web_contents)
+      constrained_window::ShowWebModalDialogViews(dialog, parent_web_contents);
+  } else {
+    constrained_window::CreateBrowserModalDialogViews(
+        dialog, show_params->GetParentWindow())
+        ->Show();
+  }
 }
 
 // A custom scrollable view implementation for the dialog.
@@ -412,7 +422,7 @@ void ExtensionInstallDialogView::InitView() {
     scroll_layout->AddView(issue_advice_view);
   }
 
-  DCHECK(prompt_->type() >= 0);
+  DCHECK_GE(prompt_->type(), 0);
   UMA_HISTOGRAM_ENUMERATION(""Extensions.InstallPrompt.Type"",
                             prompt_->type(),
                             ExtensionInstallPrompt::NUM_PROMPT_TYPES);
@@ -598,7 +608,8 @@ bool ExtensionInstallDialogView::Accept() {
 }
 
 ui::ModalType ExtensionInstallDialogView::GetModalType() const {
-  return ui::MODAL_TYPE_WINDOW;
+  return prompt_->ShouldUseTabModalDialog() ? ui::MODAL_TYPE_CHILD
+                                            : ui::MODAL_TYPE_WINDOW;
 }
 
 void ExtensionInstallDialogView::LinkClicked(views::Link* source,",Chrome,0a1c15fecb1240ab909e1431b6127410c3b380e0,5d23f8c18f1d9fbf1655ece40b31d59dea443c60,1,"void ExtensionInstallDialogView::InitView() {
  // Possible grid layouts:
  // With webstore data (inline install, external install, repair)
  //      w/ permissions           no permissions
  // +--------------+------+  +--------------+------+
  // | title        | icon |  | title        | icon |
  // +--------------|      |  +--------------|      |
  // | rating       |      |  | rating       |      |
  // +--------------|      |  +--------------|      |
  // | user_count   |      |  | user_count   |      |
  // +--------------|      |  +--------------|      |
  // | store_link   |      |  | store_link   |      |
  // +--------------+------+  +--------------+------+
  // |      separator      |  | scroll_view (empty) |
  // +---------------------+  +---------------------+
  // | scroll_view         |
  // +---------------------+
  //
  // No webstore data (all other types)
  // +--------------+------+
  // | title        | icon |
  // +--------------|      |
  // | scroll_view  |      |
  // +--------------+------+
  // The scroll_view contains permissions (if there are any) and retained
  // files/devices (if there are any; post-install-permissions prompt only).
  int left_column_width =
      (prompt_->ShouldShowPermissions() || prompt_->GetRetainedFileCount() > 0)
          ? kPermissionsLeftColumnWidth
          : kNoPermissionsLeftColumnWidth;
  if (is_external_install())
    left_column_width = kExternalInstallLeftColumnWidth;

  int column_set_id = 0;
  views::GridLayout* layout = CreateLayout(left_column_width, column_set_id);

  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();

  if (prompt_->has_webstore_data()) {
    layout->StartRow(0, column_set_id);
    views::View* rating = new views::View();
    rating->SetLayoutManager(new views::BoxLayout(
        views::BoxLayout::kHorizontal, 0, 0, 0));
    layout->AddView(rating);
    prompt_->AppendRatingStars(AddResourceIcon, rating);

    const gfx::FontList& small_font_list =
        rb.GetFontList(ui::ResourceBundle::SmallFont);
    views::Label* rating_count =
        new views::Label(prompt_->GetRatingCount(), small_font_list);
    // Add some space between the stars and the rating count.
    rating_count->SetBorder(views::Border::CreateEmptyBorder(0, 2, 0, 0));
    rating->AddChildView(rating_count);

    layout->StartRow(0, column_set_id);
    views::Label* user_count =
        new views::Label(prompt_->GetUserCount(), small_font_list);
    user_count->SetAutoColorReadabilityEnabled(false);
    user_count->SetEnabledColor(SK_ColorGRAY);
    layout->AddView(user_count);

    layout->StartRow(0, column_set_id);
    views::Link* store_link = new views::Link(
        l10n_util::GetStringUTF16(IDS_EXTENSION_PROMPT_STORE_LINK));
    store_link->SetFontList(small_font_list);
    store_link->set_listener(this);
    layout->AddView(store_link);

    if (prompt_->ShouldShowPermissions()) {
      layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);
      layout->StartRow(0, column_set_id);
      layout->AddView(new views::Separator(views::Separator::HORIZONTAL),
                      3,
                      1,
                      views::GridLayout::FILL,
                      views::GridLayout::FILL);
    }
  }

  int content_width = left_column_width + views::kPanelHorizMargin + kIconSize;

  // Create the scrollable view which will contain the permissions and retained
  // files/devices.
  CustomScrollableView* scrollable = new CustomScrollableView();
  views::GridLayout* scroll_layout = new views::GridLayout(scrollable);
  scrollable->SetLayoutManager(scroll_layout);

  views::ColumnSet* scrollable_column_set =
      scroll_layout->AddColumnSet(column_set_id);
  // If we have webstore data, there's a separator below it, so we can span the
  // whole content width. Otherwise just use the width of the left column so
  // that we don't overlap the icon.
  int scrollable_width = prompt_->has_webstore_data() ? content_width
                                                      : left_column_width;
  scrollable_column_set->AddColumn(views::GridLayout::LEADING,
                                   views::GridLayout::LEADING,
                                   0,  // no resizing
                                   views::GridLayout::USE_PREF,
                                   scrollable_width,
                                   scrollable_width);
  // Pad to the very right of the dialog, so the scrollbar will be on the edge.
  int padding_width =
      content_width + views::kButtonHEdgeMarginNew - scrollable_width;
  scrollable_column_set->AddPaddingColumn(0, padding_width);

  layout->StartRow(0, column_set_id);
  scroll_view_ = new views::ScrollView();
  scroll_view_->set_hide_horizontal_scrollbar(true);
  scroll_view_->SetContents(scrollable);
  layout->AddView(scroll_view_, 4, 1);

  if (is_bundle_install()) {
    BundleInstaller::ItemList items = prompt_->bundle()->GetItemsWithState(
        BundleInstaller::Item::STATE_PENDING);
    scroll_layout->AddPaddingRow(0, views::kRelatedControlSmallVerticalSpacing);
    for (const BundleInstaller::Item& item : items) {
      scroll_layout->StartRow(0, column_set_id);
      views::Label* extension_label =
          new views::Label(item.GetNameForDisplay());
      extension_label->SetMultiLine(true);
      extension_label->SetHorizontalAlignment(gfx::ALIGN_LEFT);
      extension_label->SizeToFit(
          scrollable_width - kSmallIconSize - kSmallIconPadding);
      gfx::ImageSkia image = gfx::ImageSkia::CreateFrom1xBitmap(item.icon);
      scroll_layout->AddView(new IconedView(extension_label, image));
    }
    scroll_layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);
  }

  if (prompt_->ShouldShowPermissions()) {
    bool has_permissions =
        prompt_->GetPermissionCount(
            ExtensionInstallPrompt::PermissionsType::ALL_PERMISSIONS) > 0;
    if (has_permissions) {
      AddPermissions(
          scroll_layout,
          rb,
          column_set_id,
          scrollable_width,
          ExtensionInstallPrompt::PermissionsType::REGULAR_PERMISSIONS);
      AddPermissions(
          scroll_layout,
          rb,
          column_set_id,
          scrollable_width,
          ExtensionInstallPrompt::PermissionsType::WITHHELD_PERMISSIONS);
    } else {
      scroll_layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);
      scroll_layout->StartRow(0, column_set_id);
      views::Label* permission_label = new views::Label(
          l10n_util::GetStringUTF16(IDS_EXTENSION_NO_SPECIAL_PERMISSIONS));
      permission_label->SetMultiLine(true);
      permission_label->SetHorizontalAlignment(gfx::ALIGN_LEFT);
      permission_label->SizeToFit(scrollable_width);
      scroll_layout->AddView(permission_label);
    }
  }

  if (prompt_->GetRetainedFileCount()) {
    scroll_layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);

    scroll_layout->StartRow(0, column_set_id);
    views::Label* retained_files_header =
        new views::Label(prompt_->GetRetainedFilesHeading());
    retained_files_header->SetMultiLine(true);
    retained_files_header->SetHorizontalAlignment(gfx::ALIGN_LEFT);
    retained_files_header->SizeToFit(scrollable_width);
    scroll_layout->AddView(retained_files_header);

    scroll_layout->StartRow(0, column_set_id);
    PermissionDetails details;
    for (size_t i = 0; i < prompt_->GetRetainedFileCount(); ++i) {
      details.push_back(prompt_->GetRetainedFile(i));
    }
    ExpandableContainerView* issue_advice_view =
        new ExpandableContainerView(this,
                                    base::string16(),
                                    details,
                                    scrollable_width,
                                    false);
    scroll_layout->AddView(issue_advice_view);
  }

  if (prompt_->GetRetainedDeviceCount()) {
    scroll_layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);

    scroll_layout->StartRow(0, column_set_id);
    views::Label* retained_devices_header =
        new views::Label(prompt_->GetRetainedDevicesHeading());
    retained_devices_header->SetMultiLine(true);
    retained_devices_header->SetHorizontalAlignment(gfx::ALIGN_LEFT);
    retained_devices_header->SizeToFit(scrollable_width);
    scroll_layout->AddView(retained_devices_header);

    scroll_layout->StartRow(0, column_set_id);
    PermissionDetails details;
    for (size_t i = 0; i < prompt_->GetRetainedDeviceCount(); ++i) {
      details.push_back(prompt_->GetRetainedDeviceMessageString(i));
    }
    ExpandableContainerView* issue_advice_view =
        new ExpandableContainerView(this,
                                    base::string16(),
                                    details,
                                    scrollable_width,
                                    false);
     scroll_layout->AddView(issue_advice_view);
   }
 
//flaw_line_below:
  DCHECK(prompt_->type() >= 0);
//fix_flaw_line_below:
//  DCHECK_GE(prompt_->type(), 0);
   UMA_HISTOGRAM_ENUMERATION(""Extensions.InstallPrompt.Type"",
                             prompt_->type(),
                             ExtensionInstallPrompt::NUM_PROMPT_TYPES);

  scroll_view_->ClipHeightTo(
      0,
      std::min(kScrollViewMaxHeight, scrollable->GetPreferredSize().height()));

  dialog_size_ = gfx::Size(
      content_width + 2 * views::kButtonHEdgeMarginNew,
      container_->GetPreferredSize().height());

  std::string event_name = ExperienceSamplingEvent::kExtensionInstallDialog;
  event_name.append(
      ExtensionInstallPrompt::PromptTypeToString(prompt_->type()));
  sampling_event_ = ExperienceSamplingEvent::Create(event_name);
}
"
8440,186176,,Remote,Not required,,CVE-2016-1640,https://www.cvedetails.com/cve/CVE-2016-1640/,CWE-17,Medium,,Partial,,2016-03-05,4.3,"The Web Store inline-installer implementation in the Extensions UI in Google Chrome before 49.0.2623.75 does not block installations upon deletion of an installation frame, which makes it easier for remote attackers to trick a user into believing that an installation request originated from the user's next navigation target via a crafted web site.",2016-12-02,,10,https://github.com/chromium/chromium/commit/0a1c15fecb1240ab909e1431b6127410c3b380e0,0a1c15fecb1240ab909e1431b6127410c3b380e0,"Make the webstore inline install dialog be tab-modal

Also clean up a few minor lint errors while I'm in here.

BUG=550047

Review URL: https://codereview.chromium.org/1496033003

Cr-Commit-Position: refs/heads/master@{#363925}",2,chrome/browser/ui/views/extensions/extension_install_dialog_view.cc,"{""sha"": ""619f600f3e515b2cb79365aeb9547659b70caa8c"", ""filename"": ""chrome/browser/extensions/extension_install_prompt.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/extensions/extension_install_prompt.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/extensions/extension_install_prompt.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_install_prompt.cc?ref=0a1c15fecb1240ab909e1431b6127410c3b380e0"", ""patch"": ""@@ -408,6 +408,13 @@ bool ExtensionInstallPrompt::Prompt::ShouldShowPermissions() const {\n          type_ == POST_INSTALL_PERMISSIONS_PROMPT;\n }\n \n+bool ExtensionInstallPrompt::Prompt::ShouldUseTabModalDialog() const {\n+  // For inline install, we want the install prompt to be tab modal so that the\n+  // dialog is always clearly associated with the page that made the inline\n+  // install request.\n+  return type_ == INLINE_INSTALL_PROMPT;\n+}\n+\n void ExtensionInstallPrompt::Prompt::AppendRatingStars(\n     StarAppender appender, void* data) const {\n   CHECK(appender);""}<_**next**_>{""sha"": ""6cf7320267c89f43a35a47e5337e99263a3ba800"", ""filename"": ""chrome/browser/extensions/extension_install_prompt.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/extensions/extension_install_prompt.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/extensions/extension_install_prompt.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_install_prompt.h?ref=0a1c15fecb1240ab909e1431b6127410c3b380e0"", ""patch"": ""@@ -128,6 +128,8 @@ class ExtensionInstallPrompt\n \n     bool ShouldShowPermissions() const;\n \n+    bool ShouldUseTabModalDialog() const;\n+\n     // Getters for webstore metadata. Only populated when the type is\n     // INLINE_INSTALL_PROMPT, EXTERNAL_INSTALL_PROMPT, or REPAIR_PROMPT.\n ""}<_**next**_>{""sha"": ""ff1ac90f583c27c2c9a888504cb702c9e3ccee14"", ""filename"": ""chrome/browser/ui/views/extensions/extension_install_dialog_view.cc"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 4, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/ui/views/extensions/extension_install_dialog_view.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a1c15fecb1240ab909e1431b6127410c3b380e0/chrome/browser/ui/views/extensions/extension_install_dialog_view.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/extension_install_dialog_view.cc?ref=0a1c15fecb1240ab909e1431b6127410c3b380e0"", ""patch"": ""@@ -4,6 +4,8 @@\n \n #include \""chrome/browser/ui/views/extensions/extension_install_dialog_view.h\""\n \n+#include <algorithm>\n+#include <string>\n #include <vector>\n \n #include \""base/basictypes.h\""\n@@ -107,8 +109,16 @@ void ShowExtensionInstallDialogImpl(\n                                      show_params->GetParentWebContents(),\n                                      delegate,\n                                      prompt);\n-  constrained_window::CreateBrowserModalDialogViews(\n-      dialog, show_params->GetParentWindow())->Show();\n+  if (prompt->ShouldUseTabModalDialog()) {\n+    content::WebContents* parent_web_contents =\n+        show_params->GetParentWebContents();\n+    if (parent_web_contents)\n+      constrained_window::ShowWebModalDialogViews(dialog, parent_web_contents);\n+  } else {\n+    constrained_window::CreateBrowserModalDialogViews(\n+        dialog, show_params->GetParentWindow())\n+        ->Show();\n+  }\n }\n \n // A custom scrollable view implementation for the dialog.\n@@ -412,7 +422,7 @@ void ExtensionInstallDialogView::InitView() {\n     scroll_layout->AddView(issue_advice_view);\n   }\n \n-  DCHECK(prompt_->type() >= 0);\n+  DCHECK_GE(prompt_->type(), 0);\n   UMA_HISTOGRAM_ENUMERATION(\""Extensions.InstallPrompt.Type\"",\n                             prompt_->type(),\n                             ExtensionInstallPrompt::NUM_PROMPT_TYPES);\n@@ -598,7 +608,8 @@ bool ExtensionInstallDialogView::Accept() {\n }\n \n ui::ModalType ExtensionInstallDialogView::GetModalType() const {\n-  return ui::MODAL_TYPE_WINDOW;\n+  return prompt_->ShouldUseTabModalDialog() ? ui::MODAL_TYPE_CHILD\n+                                            : ui::MODAL_TYPE_WINDOW;\n }\n \n void ExtensionInstallDialogView::LinkClicked(views::Link* source,""}","void ShowExtensionInstallDialogImpl(
    ExtensionInstallPromptShowParams* show_params,
    ExtensionInstallPrompt::Delegate* delegate,
    scoped_refptr<ExtensionInstallPrompt::Prompt> prompt) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  ExtensionInstallDialogView* dialog =
      new ExtensionInstallDialogView(show_params->profile(),
                                      show_params->GetParentWebContents(),
                                      delegate,
                                      prompt);
  if (prompt->ShouldUseTabModalDialog()) {
    content::WebContents* parent_web_contents =
        show_params->GetParentWebContents();
    if (parent_web_contents)
      constrained_window::ShowWebModalDialogViews(dialog, parent_web_contents);
  } else {
    constrained_window::CreateBrowserModalDialogViews(
        dialog, show_params->GetParentWindow())
        ->Show();
  }
 }
","void ShowExtensionInstallDialogImpl(
    ExtensionInstallPromptShowParams* show_params,
    ExtensionInstallPrompt::Delegate* delegate,
    scoped_refptr<ExtensionInstallPrompt::Prompt> prompt) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  ExtensionInstallDialogView* dialog =
      new ExtensionInstallDialogView(show_params->profile(),
                                      show_params->GetParentWebContents(),
                                      delegate,
                                      prompt);
  constrained_window::CreateBrowserModalDialogViews(
      dialog, show_params->GetParentWindow())->Show();
 }
",C,"  if (prompt->ShouldUseTabModalDialog()) {
    content::WebContents* parent_web_contents =
        show_params->GetParentWebContents();
    if (parent_web_contents)
      constrained_window::ShowWebModalDialogViews(dialog, parent_web_contents);
  } else {
    constrained_window::CreateBrowserModalDialogViews(
        dialog, show_params->GetParentWindow())
        ->Show();
  }
","  constrained_window::CreateBrowserModalDialogViews(
      dialog, show_params->GetParentWindow())->Show();
",,"@@ -4,6 +4,8 @@
 
 #include ""chrome/browser/ui/views/extensions/extension_install_dialog_view.h""
 
+#include <algorithm>
+#include <string>
 #include <vector>
 
 #include ""base/basictypes.h""
@@ -107,8 +109,16 @@ void ShowExtensionInstallDialogImpl(
                                      show_params->GetParentWebContents(),
                                      delegate,
                                      prompt);
-  constrained_window::CreateBrowserModalDialogViews(
-      dialog, show_params->GetParentWindow())->Show();
+  if (prompt->ShouldUseTabModalDialog()) {
+    content::WebContents* parent_web_contents =
+        show_params->GetParentWebContents();
+    if (parent_web_contents)
+      constrained_window::ShowWebModalDialogViews(dialog, parent_web_contents);
+  } else {
+    constrained_window::CreateBrowserModalDialogViews(
+        dialog, show_params->GetParentWindow())
+        ->Show();
+  }
 }
 
 // A custom scrollable view implementation for the dialog.
@@ -412,7 +422,7 @@ void ExtensionInstallDialogView::InitView() {
     scroll_layout->AddView(issue_advice_view);
   }
 
-  DCHECK(prompt_->type() >= 0);
+  DCHECK_GE(prompt_->type(), 0);
   UMA_HISTOGRAM_ENUMERATION(""Extensions.InstallPrompt.Type"",
                             prompt_->type(),
                             ExtensionInstallPrompt::NUM_PROMPT_TYPES);
@@ -598,7 +608,8 @@ bool ExtensionInstallDialogView::Accept() {
 }
 
 ui::ModalType ExtensionInstallDialogView::GetModalType() const {
-  return ui::MODAL_TYPE_WINDOW;
+  return prompt_->ShouldUseTabModalDialog() ? ui::MODAL_TYPE_CHILD
+                                            : ui::MODAL_TYPE_WINDOW;
 }
 
 void ExtensionInstallDialogView::LinkClicked(views::Link* source,",Chrome,0a1c15fecb1240ab909e1431b6127410c3b380e0,5d23f8c18f1d9fbf1655ece40b31d59dea443c60,1,"void ShowExtensionInstallDialogImpl(
    ExtensionInstallPromptShowParams* show_params,
    ExtensionInstallPrompt::Delegate* delegate,
    scoped_refptr<ExtensionInstallPrompt::Prompt> prompt) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  ExtensionInstallDialogView* dialog =
      new ExtensionInstallDialogView(show_params->profile(),
                                      show_params->GetParentWebContents(),
                                      delegate,
                                      prompt);
//flaw_line_below:
  constrained_window::CreateBrowserModalDialogViews(
//flaw_line_below:
      dialog, show_params->GetParentWindow())->Show();
//fix_flaw_line_below:
//  if (prompt->ShouldUseTabModalDialog()) {
//fix_flaw_line_below:
//    content::WebContents* parent_web_contents =
//fix_flaw_line_below:
//        show_params->GetParentWebContents();
//fix_flaw_line_below:
//    if (parent_web_contents)
//fix_flaw_line_below:
//      constrained_window::ShowWebModalDialogViews(dialog, parent_web_contents);
//fix_flaw_line_below:
//  } else {
//fix_flaw_line_below:
//    constrained_window::CreateBrowserModalDialogViews(
//fix_flaw_line_below:
//        dialog, show_params->GetParentWindow())
//fix_flaw_line_below:
//        ->Show();
//fix_flaw_line_below:
//  }
 }
"
