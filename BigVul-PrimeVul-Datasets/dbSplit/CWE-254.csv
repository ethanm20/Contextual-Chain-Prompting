,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
203,177939,,Remote,Not required,,CVE-2015-1793,https://www.cvedetails.com/cve/CVE-2015-1793/,CWE-254,Low,Partial,Partial,,2015-07-09,6.4,"The X509_verify_cert function in crypto/x509/x509_vfy.c in OpenSSL 1.0.1n, 1.0.1o, 1.0.2b, and 1.0.2c does not properly process X.509 Basic Constraints cA values during identification of alternative certificate chains, which allows remote attackers to spoof a Certification Authority role and trigger unintended certificate verifications via a valid leaf certificate.",2018-11-30,,1,https://git.openssl.org/?p=openssl.git;a=commit;h=9a0db453ba017ebcaccbee933ee6511a9ae4d1c8,9a0db453ba017ebcaccbee933ee6511a9ae4d1c8,,1,,,"int X509_verify_cert(X509_STORE_CTX *ctx)
{
    X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;
    int bad_chain = 0;
    X509_VERIFY_PARAM *param = ctx->param;
    int depth, i, ok = 0;
    int num, j, retry;
    int (*cb) (int xok, X509_STORE_CTX *xctx);
    STACK_OF(X509) *sktmp = NULL;
    if (ctx->cert == NULL) {
        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);
        return -1;
    }

    cb = ctx->verify_cb;

    /*
     * first we make sure the chain we are going to build is present and that
     * the first entry is in place
     */
    if (ctx->chain == NULL) {
        if (((ctx->chain = sk_X509_new_null()) == NULL) ||
            (!sk_X509_push(ctx->chain, ctx->cert))) {
            X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
            goto end;
        }
        CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);
        ctx->last_untrusted = 1;
    }

    /* We use a temporary STACK so we can chop and hack at it */
    if (ctx->untrusted != NULL
        && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {
        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
        goto end;
    }

    num = sk_X509_num(ctx->chain);
    x = sk_X509_value(ctx->chain, num - 1);
    depth = param->depth;

    for (;;) {
        /* If we have enough, we break */
        if (depth < num)
            break;              /* FIXME: If this happens, we should take
                                 * note of it and, if appropriate, use the
                                 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code
                                 * later. */

        /* If we are self signed, we break */
        if (ctx->check_issued(ctx, x, x))
            break;

        /* If we were passed a cert chain, use it first */
        if (ctx->untrusted != NULL) {
            xtmp = find_issuer(ctx, sktmp, x);
            if (xtmp != NULL) {
                if (!sk_X509_push(ctx->chain, xtmp)) {
                    X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
                    goto end;
                }
                CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);
                (void)sk_X509_delete_ptr(sktmp, xtmp);
                ctx->last_untrusted++;
                x = xtmp;
                num++;
                /*
                 * reparse the full chain for the next one
                 */
                continue;
            }
        }
        break;
    }

    /* Remember how many untrusted certs we have */
    j = num;
    /*
     * at this point, chain should contain a list of untrusted certificates.
     * We now need to add at least one trusted one, if possible, otherwise we
     * complain.
     */

    do {
        /*
         * Examine last certificate in chain and see if it is self signed.
         */
        i = sk_X509_num(ctx->chain);
        x = sk_X509_value(ctx->chain, i - 1);
        if (ctx->check_issued(ctx, x, x)) {
            /* we have a self signed certificate */
            if (sk_X509_num(ctx->chain) == 1) {
                /*
                 * We have a single self signed certificate: see if we can
                 * find it in the store. We must have an exact match to avoid
                 * possible impersonation.
                 */
                ok = ctx->get_issuer(&xtmp, ctx, x);
                if ((ok <= 0) || X509_cmp(x, xtmp)) {
                    ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
                    ctx->current_cert = x;
                    ctx->error_depth = i - 1;
                    if (ok == 1)
                        X509_free(xtmp);
                    bad_chain = 1;
                    ok = cb(0, ctx);
                    if (!ok)
                        goto end;
                } else {
                    /*
                     * We have a match: replace certificate with store
                     * version so we get any trust settings.
                     */
                    X509_free(x);
                    x = xtmp;
                    (void)sk_X509_set(ctx->chain, i - 1, x);
                    ctx->last_untrusted = 0;
                }
            } else {
                /*
                 * extract and save self signed certificate for later use
                 */
                chain_ss = sk_X509_pop(ctx->chain);
                ctx->last_untrusted--;
                num--;
                j--;
                x = sk_X509_value(ctx->chain, num - 1);
            }
        }
        /* We now lookup certs from the certificate store */
        for (;;) {
            /* If we have enough, we break */
            if (depth < num)
                break;
            /* If we are self signed, we break */
            if (ctx->check_issued(ctx, x, x))
                break;
            ok = ctx->get_issuer(&xtmp, ctx, x);
            if (ok < 0)
                return ok;
            if (ok == 0)
                break;
            x = xtmp;
            if (!sk_X509_push(ctx->chain, x)) {
                X509_free(xtmp);
                X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
                return 0;
            }
            num++;
        }

        /*
         * If we haven't got a least one certificate from our store then check
         * if there is an alternative chain that could be used.  We only do this
         * if the user hasn't switched off alternate chain checking
         */
        retry = 0;
        if (j == ctx->last_untrusted &&
            !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {
            while (j-- > 1) {
                xtmp2 = sk_X509_value(ctx->chain, j - 1);
                ok = ctx->get_issuer(&xtmp, ctx, xtmp2);
                if (ok < 0)
                    goto end;
                /* Check if we found an alternate chain */
                if (ok > 0) {
                    /*
                     * Free up the found cert we'll add it again later
                     */
                    X509_free(xtmp);

                    /*
                     * Dump all the certs above this point - we've found an
                     * alternate chain
                     */
                    while (num > j) {
                         xtmp = sk_X509_pop(ctx->chain);
                         X509_free(xtmp);
                         num--;
                     }
                    ctx->last_untrusted = sk_X509_num(ctx->chain);
                     retry = 1;
                     break;
                 }
            }
        }
    } while (retry);

    /* Is last certificate looked up self signed? */
    if (!ctx->check_issued(ctx, x, x)) {
        if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {
            if (ctx->last_untrusted >= num)
                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
            else
                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;
            ctx->current_cert = x;
        } else {

            sk_X509_push(ctx->chain, chain_ss);
            num++;
            ctx->last_untrusted = num;
            ctx->current_cert = chain_ss;
            ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;
            chain_ss = NULL;
        }

        ctx->error_depth = num - 1;
        bad_chain = 1;
        ok = cb(0, ctx);
        if (!ok)
            goto end;
    }

    /* We have the chain complete: now we need to check its purpose */
    ok = check_chain_extensions(ctx);

    if (!ok)
        goto end;

    /* Check name constraints */

    ok = check_name_constraints(ctx);

    if (!ok)
        goto end;

    /* The chain extensions are OK: check trust */

    if (param->trust > 0)
        ok = check_trust(ctx);

    if (!ok)
        goto end;

    /* We may as well copy down any DSA parameters that are required */
    X509_get_pubkey_parameters(NULL, ctx->chain);

    /*
     * Check revocation status: we do this after copying parameters because
     * they may be needed for CRL signature verification.
     */

    ok = ctx->check_revocation(ctx);
    if (!ok)
        goto end;

    /* At this point, we have a chain and need to verify it */
    if (ctx->verify != NULL)
        ok = ctx->verify(ctx);
    else
        ok = internal_verify(ctx);
    if (!ok)
        goto end;

#ifndef OPENSSL_NO_RFC3779
    /* RFC 3779 path validation, now that CRL check has been done */
    ok = v3_asid_validate_path(ctx);
    if (!ok)
        goto end;
    ok = v3_addr_validate_path(ctx);
    if (!ok)
        goto end;
#endif

    /* If we get this far evaluate policies */
    if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))
        ok = ctx->check_policy(ctx);
    if (!ok)
        goto end;
    if (0) {
 end:
        X509_get_pubkey_parameters(NULL, ctx->chain);
    }
    if (sktmp != NULL)
        sk_X509_free(sktmp);
    if (chain_ss != NULL)
        X509_free(chain_ss);
    return ok;
}
","int X509_verify_cert(X509_STORE_CTX *ctx)
{
    X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;
    int bad_chain = 0;
    X509_VERIFY_PARAM *param = ctx->param;
    int depth, i, ok = 0;
    int num, j, retry;
    int (*cb) (int xok, X509_STORE_CTX *xctx);
    STACK_OF(X509) *sktmp = NULL;
    if (ctx->cert == NULL) {
        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);
        return -1;
    }

    cb = ctx->verify_cb;

    /*
     * first we make sure the chain we are going to build is present and that
     * the first entry is in place
     */
    if (ctx->chain == NULL) {
        if (((ctx->chain = sk_X509_new_null()) == NULL) ||
            (!sk_X509_push(ctx->chain, ctx->cert))) {
            X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
            goto end;
        }
        CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);
        ctx->last_untrusted = 1;
    }

    /* We use a temporary STACK so we can chop and hack at it */
    if (ctx->untrusted != NULL
        && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {
        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
        goto end;
    }

    num = sk_X509_num(ctx->chain);
    x = sk_X509_value(ctx->chain, num - 1);
    depth = param->depth;

    for (;;) {
        /* If we have enough, we break */
        if (depth < num)
            break;              /* FIXME: If this happens, we should take
                                 * note of it and, if appropriate, use the
                                 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code
                                 * later. */

        /* If we are self signed, we break */
        if (ctx->check_issued(ctx, x, x))
            break;

        /* If we were passed a cert chain, use it first */
        if (ctx->untrusted != NULL) {
            xtmp = find_issuer(ctx, sktmp, x);
            if (xtmp != NULL) {
                if (!sk_X509_push(ctx->chain, xtmp)) {
                    X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
                    goto end;
                }
                CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);
                (void)sk_X509_delete_ptr(sktmp, xtmp);
                ctx->last_untrusted++;
                x = xtmp;
                num++;
                /*
                 * reparse the full chain for the next one
                 */
                continue;
            }
        }
        break;
    }

    /* Remember how many untrusted certs we have */
    j = num;
    /*
     * at this point, chain should contain a list of untrusted certificates.
     * We now need to add at least one trusted one, if possible, otherwise we
     * complain.
     */

    do {
        /*
         * Examine last certificate in chain and see if it is self signed.
         */
        i = sk_X509_num(ctx->chain);
        x = sk_X509_value(ctx->chain, i - 1);
        if (ctx->check_issued(ctx, x, x)) {
            /* we have a self signed certificate */
            if (sk_X509_num(ctx->chain) == 1) {
                /*
                 * We have a single self signed certificate: see if we can
                 * find it in the store. We must have an exact match to avoid
                 * possible impersonation.
                 */
                ok = ctx->get_issuer(&xtmp, ctx, x);
                if ((ok <= 0) || X509_cmp(x, xtmp)) {
                    ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
                    ctx->current_cert = x;
                    ctx->error_depth = i - 1;
                    if (ok == 1)
                        X509_free(xtmp);
                    bad_chain = 1;
                    ok = cb(0, ctx);
                    if (!ok)
                        goto end;
                } else {
                    /*
                     * We have a match: replace certificate with store
                     * version so we get any trust settings.
                     */
                    X509_free(x);
                    x = xtmp;
                    (void)sk_X509_set(ctx->chain, i - 1, x);
                    ctx->last_untrusted = 0;
                }
            } else {
                /*
                 * extract and save self signed certificate for later use
                 */
                chain_ss = sk_X509_pop(ctx->chain);
                ctx->last_untrusted--;
                num--;
                j--;
                x = sk_X509_value(ctx->chain, num - 1);
            }
        }
        /* We now lookup certs from the certificate store */
        for (;;) {
            /* If we have enough, we break */
            if (depth < num)
                break;
            /* If we are self signed, we break */
            if (ctx->check_issued(ctx, x, x))
                break;
            ok = ctx->get_issuer(&xtmp, ctx, x);
            if (ok < 0)
                return ok;
            if (ok == 0)
                break;
            x = xtmp;
            if (!sk_X509_push(ctx->chain, x)) {
                X509_free(xtmp);
                X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
                return 0;
            }
            num++;
        }

        /*
         * If we haven't got a least one certificate from our store then check
         * if there is an alternative chain that could be used.  We only do this
         * if the user hasn't switched off alternate chain checking
         */
        retry = 0;
        if (j == ctx->last_untrusted &&
            !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {
            while (j-- > 1) {
                xtmp2 = sk_X509_value(ctx->chain, j - 1);
                ok = ctx->get_issuer(&xtmp, ctx, xtmp2);
                if (ok < 0)
                    goto end;
                /* Check if we found an alternate chain */
                if (ok > 0) {
                    /*
                     * Free up the found cert we'll add it again later
                     */
                    X509_free(xtmp);

                    /*
                     * Dump all the certs above this point - we've found an
                     * alternate chain
                     */
                    while (num > j) {
                         xtmp = sk_X509_pop(ctx->chain);
                         X509_free(xtmp);
                         num--;
                        ctx->last_untrusted--;
                     }
                     retry = 1;
                     break;
                 }
            }
        }
    } while (retry);

    /* Is last certificate looked up self signed? */
    if (!ctx->check_issued(ctx, x, x)) {
        if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {
            if (ctx->last_untrusted >= num)
                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
            else
                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;
            ctx->current_cert = x;
        } else {

            sk_X509_push(ctx->chain, chain_ss);
            num++;
            ctx->last_untrusted = num;
            ctx->current_cert = chain_ss;
            ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;
            chain_ss = NULL;
        }

        ctx->error_depth = num - 1;
        bad_chain = 1;
        ok = cb(0, ctx);
        if (!ok)
            goto end;
    }

    /* We have the chain complete: now we need to check its purpose */
    ok = check_chain_extensions(ctx);

    if (!ok)
        goto end;

    /* Check name constraints */

    ok = check_name_constraints(ctx);

    if (!ok)
        goto end;

    /* The chain extensions are OK: check trust */

    if (param->trust > 0)
        ok = check_trust(ctx);

    if (!ok)
        goto end;

    /* We may as well copy down any DSA parameters that are required */
    X509_get_pubkey_parameters(NULL, ctx->chain);

    /*
     * Check revocation status: we do this after copying parameters because
     * they may be needed for CRL signature verification.
     */

    ok = ctx->check_revocation(ctx);
    if (!ok)
        goto end;

    /* At this point, we have a chain and need to verify it */
    if (ctx->verify != NULL)
        ok = ctx->verify(ctx);
    else
        ok = internal_verify(ctx);
    if (!ok)
        goto end;

#ifndef OPENSSL_NO_RFC3779
    /* RFC 3779 path validation, now that CRL check has been done */
    ok = v3_asid_validate_path(ctx);
    if (!ok)
        goto end;
    ok = v3_addr_validate_path(ctx);
    if (!ok)
        goto end;
#endif

    /* If we get this far evaluate policies */
    if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))
        ok = ctx->check_policy(ctx);
    if (!ok)
        goto end;
    if (0) {
 end:
        X509_get_pubkey_parameters(NULL, ctx->chain);
    }
    if (sktmp != NULL)
        sk_X509_free(sktmp);
    if (chain_ss != NULL)
        X509_free(chain_ss);
    return ok;
}
",C,"                    ctx->last_untrusted = sk_X509_num(ctx->chain);
","                        ctx->last_untrusted--;
",cb6e0ed17a61ae3711d385f517d61be2b4c33a55,"@@ -328,8 +328,8 @@ int X509_verify_cert(X509_STORE_CTX *ctx)
                         xtmp = sk_X509_pop(ctx->chain);
                         X509_free(xtmp);
                         num--;
-                        ctx->last_untrusted--;
                     }
+                    ctx->last_untrusted = sk_X509_num(ctx->chain);
                     retry = 1;
                     break;
                 }",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/x509/x509_vfy.c;h=a0083b552d3a53402ab6c751b95f8d45eeb0183e;hb=a0083b552d3a53402ab6c751b95f8d45eeb0183e,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/x509/x509_vfy.c;h=16db4c025a14539427f02eede2018bd7264660e3;hb=16db4c025a14539427f02eede2018bd7264660e3,1,"int X509_verify_cert(X509_STORE_CTX *ctx)
{
    X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;
    int bad_chain = 0;
    X509_VERIFY_PARAM *param = ctx->param;
    int depth, i, ok = 0;
    int num, j, retry;
    int (*cb) (int xok, X509_STORE_CTX *xctx);
    STACK_OF(X509) *sktmp = NULL;
    if (ctx->cert == NULL) {
        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);
        return -1;
    }

    cb = ctx->verify_cb;

    /*
     * first we make sure the chain we are going to build is present and that
     * the first entry is in place
     */
    if (ctx->chain == NULL) {
        if (((ctx->chain = sk_X509_new_null()) == NULL) ||
            (!sk_X509_push(ctx->chain, ctx->cert))) {
            X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
            goto end;
        }
        CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);
        ctx->last_untrusted = 1;
    }

    /* We use a temporary STACK so we can chop and hack at it */
    if (ctx->untrusted != NULL
        && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {
        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
        goto end;
    }

    num = sk_X509_num(ctx->chain);
    x = sk_X509_value(ctx->chain, num - 1);
    depth = param->depth;

    for (;;) {
        /* If we have enough, we break */
        if (depth < num)
            break;              /* FIXME: If this happens, we should take
                                 * note of it and, if appropriate, use the
                                 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code
                                 * later. */

        /* If we are self signed, we break */
        if (ctx->check_issued(ctx, x, x))
            break;

        /* If we were passed a cert chain, use it first */
        if (ctx->untrusted != NULL) {
            xtmp = find_issuer(ctx, sktmp, x);
            if (xtmp != NULL) {
                if (!sk_X509_push(ctx->chain, xtmp)) {
                    X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
                    goto end;
                }
                CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);
                (void)sk_X509_delete_ptr(sktmp, xtmp);
                ctx->last_untrusted++;
                x = xtmp;
                num++;
                /*
                 * reparse the full chain for the next one
                 */
                continue;
            }
        }
        break;
    }

    /* Remember how many untrusted certs we have */
    j = num;
    /*
     * at this point, chain should contain a list of untrusted certificates.
     * We now need to add at least one trusted one, if possible, otherwise we
     * complain.
     */

    do {
        /*
         * Examine last certificate in chain and see if it is self signed.
         */
        i = sk_X509_num(ctx->chain);
        x = sk_X509_value(ctx->chain, i - 1);
        if (ctx->check_issued(ctx, x, x)) {
            /* we have a self signed certificate */
            if (sk_X509_num(ctx->chain) == 1) {
                /*
                 * We have a single self signed certificate: see if we can
                 * find it in the store. We must have an exact match to avoid
                 * possible impersonation.
                 */
                ok = ctx->get_issuer(&xtmp, ctx, x);
                if ((ok <= 0) || X509_cmp(x, xtmp)) {
                    ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
                    ctx->current_cert = x;
                    ctx->error_depth = i - 1;
                    if (ok == 1)
                        X509_free(xtmp);
                    bad_chain = 1;
                    ok = cb(0, ctx);
                    if (!ok)
                        goto end;
                } else {
                    /*
                     * We have a match: replace certificate with store
                     * version so we get any trust settings.
                     */
                    X509_free(x);
                    x = xtmp;
                    (void)sk_X509_set(ctx->chain, i - 1, x);
                    ctx->last_untrusted = 0;
                }
            } else {
                /*
                 * extract and save self signed certificate for later use
                 */
                chain_ss = sk_X509_pop(ctx->chain);
                ctx->last_untrusted--;
                num--;
                j--;
                x = sk_X509_value(ctx->chain, num - 1);
            }
        }
        /* We now lookup certs from the certificate store */
        for (;;) {
            /* If we have enough, we break */
            if (depth < num)
                break;
            /* If we are self signed, we break */
            if (ctx->check_issued(ctx, x, x))
                break;
            ok = ctx->get_issuer(&xtmp, ctx, x);
            if (ok < 0)
                return ok;
            if (ok == 0)
                break;
            x = xtmp;
            if (!sk_X509_push(ctx->chain, x)) {
                X509_free(xtmp);
                X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
                return 0;
            }
            num++;
        }

        /*
         * If we haven't got a least one certificate from our store then check
         * if there is an alternative chain that could be used.  We only do this
         * if the user hasn't switched off alternate chain checking
         */
        retry = 0;
        if (j == ctx->last_untrusted &&
            !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {
            while (j-- > 1) {
                xtmp2 = sk_X509_value(ctx->chain, j - 1);
                ok = ctx->get_issuer(&xtmp, ctx, xtmp2);
                if (ok < 0)
                    goto end;
                /* Check if we found an alternate chain */
                if (ok > 0) {
                    /*
                     * Free up the found cert we'll add it again later
                     */
                    X509_free(xtmp);

                    /*
                     * Dump all the certs above this point - we've found an
                     * alternate chain
                     */
                    while (num > j) {
                         xtmp = sk_X509_pop(ctx->chain);
                         X509_free(xtmp);
                         num--;
//flaw_line_below:
                        ctx->last_untrusted--;
                     }
//fix_flaw_line_below:
//                    ctx->last_untrusted = sk_X509_num(ctx->chain);
                     retry = 1;
                     break;
                 }
            }
        }
    } while (retry);

    /* Is last certificate looked up self signed? */
    if (!ctx->check_issued(ctx, x, x)) {
        if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {
            if (ctx->last_untrusted >= num)
                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
            else
                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;
            ctx->current_cert = x;
        } else {

            sk_X509_push(ctx->chain, chain_ss);
            num++;
            ctx->last_untrusted = num;
            ctx->current_cert = chain_ss;
            ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;
            chain_ss = NULL;
        }

        ctx->error_depth = num - 1;
        bad_chain = 1;
        ok = cb(0, ctx);
        if (!ok)
            goto end;
    }

    /* We have the chain complete: now we need to check its purpose */
    ok = check_chain_extensions(ctx);

    if (!ok)
        goto end;

    /* Check name constraints */

    ok = check_name_constraints(ctx);

    if (!ok)
        goto end;

    /* The chain extensions are OK: check trust */

    if (param->trust > 0)
        ok = check_trust(ctx);

    if (!ok)
        goto end;

    /* We may as well copy down any DSA parameters that are required */
    X509_get_pubkey_parameters(NULL, ctx->chain);

    /*
     * Check revocation status: we do this after copying parameters because
     * they may be needed for CRL signature verification.
     */

    ok = ctx->check_revocation(ctx);
    if (!ok)
        goto end;

    /* At this point, we have a chain and need to verify it */
    if (ctx->verify != NULL)
        ok = ctx->verify(ctx);
    else
        ok = internal_verify(ctx);
    if (!ok)
        goto end;

#ifndef OPENSSL_NO_RFC3779
    /* RFC 3779 path validation, now that CRL check has been done */
    ok = v3_asid_validate_path(ctx);
    if (!ok)
        goto end;
    ok = v3_addr_validate_path(ctx);
    if (!ok)
        goto end;
#endif

    /* If we get this far evaluate policies */
    if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))
        ok = ctx->check_policy(ctx);
    if (!ok)
        goto end;
    if (0) {
 end:
        X509_get_pubkey_parameters(NULL, ctx->chain);
    }
    if (sktmp != NULL)
        sk_X509_free(sktmp);
    if (chain_ss != NULL)
        X509_free(chain_ss);
    return ok;
}
"
451,178187,,Remote,Not required,,CVE-2016-4971,https://www.cvedetails.com/cve/CVE-2016-4971/,CWE-254,Medium,,Partial,,2016-06-30,4.3,GNU wget before 1.18 allows remote servers to write to arbitrary files by redirecting a request from HTTP to a crafted FTP resource.,2018-01-04,,8,https://git.savannah.gnu.org/cgit/wget.git/commit/?id=e996e322ffd42aaa051602da182d03178d0f13e1,e996e322ffd42aaa051602da182d03178d0f13e1,,6,,,"ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con, char **local_file,
ftp_loop_internal (struct url *u, struct url *original_url, struct fileinfo *f,
                   ccon *con, char **local_file, bool force_full_retrieve)
 {
   int count, orig_lp;
   wgint restval, len = 0, qtyread = 0;
  const char *tmrate = NULL;
  uerr_t err;
  struct_stat st;

  /* Declare WARC variables. */
  bool warc_enabled = (opt.warc_filename != NULL);
  FILE *warc_tmp = NULL;
  ip_address *warc_ip = NULL;
  wgint last_expected_bytes = 0;

  /* Get the target, and set the name for the message accordingly. */
  if ((f == NULL) && (con->target))
    {
      /* Explicit file (like "".listing""). */
      locf = con->target;
    }
  else
    {
     {
       /* URL-derived file.  Consider ""-O file"" name. */
       xfree (con->target);
      con->target = url_file_name (opt.trustservernames || !original_url ? u : original_url, NULL);
       if (!opt.output_document)
         locf = con->target;
       else
    }

  /* If the output_document was given, then this check was already done and
     the file didn't exist. Hence the !opt.output_document */

  /* If we receive .listing file it is necessary to determine system type of the ftp
     server even if opn.noclobber is given. Thus we must ignore opt.noclobber in
     order to establish connection with the server and get system type. */
  if (opt.noclobber && !opt.output_document && file_exists_p (con->target)
      && !((con->cmd & DO_LIST) && !(con->cmd & DO_RETR)))
    {
      logprintf (LOG_VERBOSE,
                 _(""File %s already there; not retrieving.\n""), quote (con->target));
      /* If the file is there, we suppose it's retrieved OK.  */
      return RETROK;
    }

  /* Remove it if it's a link.  */
  remove_link (con->target);

  count = 0;

  if (con->st & ON_YOUR_OWN)
    con->st = ON_YOUR_OWN;

  orig_lp = con->cmd & LEAVE_PENDING ? 1 : 0;

  /* THE loop.  */
  do
    {
      /* Increment the pass counter.  */
      ++count;
      sleep_between_retrievals (count);
      if (con->st & ON_YOUR_OWN)
        {
          con->cmd = 0;
          con->cmd |= (DO_RETR | LEAVE_PENDING);
          if (con->csock != -1)
            con->cmd &= ~ (DO_LOGIN | DO_CWD);
          else
            con->cmd |= (DO_LOGIN | DO_CWD);
        }
      else /* not on your own */
        {
          if (con->csock != -1)
            con->cmd &= ~DO_LOGIN;
          else
            con->cmd |= DO_LOGIN;
          if (con->st & DONE_CWD)
            con->cmd &= ~DO_CWD;
          else
            con->cmd |= DO_CWD;
        }

      /* For file RETR requests, we can write a WARC record.
         We record the file contents to a temporary file. */
      if (warc_enabled && (con->cmd & DO_RETR) && warc_tmp == NULL)
        {
          warc_tmp = warc_tempfile ();
          if (warc_tmp == NULL)
            return WARC_TMP_FOPENERR;

          if (!con->proxy && con->csock != -1)
            {
              warc_ip = (ip_address *) alloca (sizeof (ip_address));
              socket_ip_address (con->csock, warc_ip, ENDPOINT_PEER);
            }
        }

      /* Decide whether or not to restart.  */
      if (con->cmd & DO_LIST)
        restval = 0;
      else if (force_full_retrieve)
        restval = 0;
      else if (opt.start_pos >= 0)
        restval = opt.start_pos;
      else if (opt.always_rest
          && stat (locf, &st) == 0
          && S_ISREG (st.st_mode))
        /* When -c is used, continue from on-disk size.  (Can't use
           hstat.len even if count>1 because we don't want a failed
           first attempt to clobber existing data.)  */
        restval = st.st_size;
      else if (count > 1)
        restval = qtyread;          /* start where the previous run left off */
      else
        restval = 0;

      /* Get the current time string.  */
      tms = datetime_str (time (NULL));
      /* Print fetch message, if opt.verbose.  */
      if (opt.verbose)
        {
          char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD);
          char tmp[256];
          strcpy (tmp, ""        "");
          if (count > 1)
            sprintf (tmp, _(""(try:%2d)""), count);
          logprintf (LOG_VERBOSE, ""--%s--  %s\n  %s => %s\n"",
                     tms, hurl, tmp, quote (locf));
#ifdef WINDOWS
          ws_changetitle (hurl);
#endif
          xfree (hurl);
        }
      /* Send getftp the proper length, if fileinfo was provided.  */
      if (f && f->type != FT_SYMLINK)
        len = f->size;
      else
        len = 0;

 
       /* If we are working on a WARC record, getftp should also write
          to the warc_tmp file. */
      err = getftp (u, original_url, len, &qtyread, restval, con, count,
                    &last_expected_bytes, warc_tmp);
 
       if (con->csock == -1)
         con->st &= ~DONE_CWD;
        con->st |= DONE_CWD;

      switch (err)
        {
        case HOSTERR: case CONIMPOSSIBLE: case FWRITEERR: case FOPENERR:
        case FTPNSFOD: case FTPLOGINC: case FTPNOPASV: case FTPNOAUTH: case FTPNOPBSZ: case FTPNOPROT:
        case UNLINKERR: case WARC_TMP_FWRITEERR: case CONSSLERR: case CONTNOTSUPPORTED:
#ifdef HAVE_SSL
          if (err == FTPNOAUTH)
            logputs (LOG_NOTQUIET, ""Server does not support AUTH TLS.\n"");
          if (opt.ftps_implicit)
            logputs (LOG_NOTQUIET, ""Server does not like implicit FTPS connections.\n"");
#endif
          /* Fatal errors, give up.  */
          if (warc_tmp != NULL)
              fclose (warc_tmp);
          return err;
        case CONSOCKERR: case CONERROR: case FTPSRVERR: case FTPRERR:
        case WRITEFAILED: case FTPUNKNOWNTYPE: case FTPSYSERR:
        case FTPPORTERR: case FTPLOGREFUSED: case FTPINVPASV:
        case FOPEN_EXCL_ERR:
          printwhat (count, opt.ntry);
          /* non-fatal errors */
          if (err == FOPEN_EXCL_ERR)
            {
              /* Re-determine the file name. */
              xfree (con->target);
              con->target = url_file_name (u, NULL);
              locf = con->target;
            }
          continue;
        case FTPRETRINT:
          /* If the control connection was closed, the retrieval
             will be considered OK if f->size == len.  */
          if (!f || qtyread != f->size)
            {
              printwhat (count, opt.ntry);
              continue;
            }
          break;
        case RETRFINISHED:
          /* Great!  */
          break;
        default:
          /* Not as great.  */
          abort ();
        }
      tms = datetime_str (time (NULL));
      if (!opt.spider)
        tmrate = retr_rate (qtyread - restval, con->dltime);

      /* If we get out of the switch above without continue'ing, we've
         successfully downloaded a file.  Remember this fact. */
      downloaded_file (FILE_DOWNLOADED_NORMALLY, locf);

      if (con->st & ON_YOUR_OWN)
        {
          fd_close (con->csock);
          con->csock = -1;
        }
      if (!opt.spider)
        {
          bool write_to_stdout = (opt.output_document && HYPHENP (opt.output_document));

          logprintf (LOG_VERBOSE,
                     write_to_stdout
                     ? _(""%s (%s) - written to stdout %s[%s]\n\n"")
                     : _(""%s (%s) - %s saved [%s]\n\n""),
                     tms, tmrate,
                     write_to_stdout ? """" : quote (locf),
                     number_to_static_string (qtyread));
        }
      if (!opt.verbose && !opt.quiet)
        {
          /* Need to hide the password from the URL.  The `if' is here
             so that we don't do the needless allocation every
             time. */
          char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD);
          logprintf (LOG_NONVERBOSE, ""%s URL: %s [%s] -> \""%s\"" [%d]\n"",
                     tms, hurl, number_to_static_string (qtyread), locf, count);
          xfree (hurl);
        }

      if (warc_enabled && (con->cmd & DO_RETR))
        {
          /* Create and store a WARC resource record for the retrieved file. */
          bool warc_res;

          warc_res = warc_write_resource_record (NULL, u->url, NULL, NULL,
                                                  warc_ip, NULL, warc_tmp, -1);

          if (! warc_res)
            return WARC_ERR;

          /* warc_write_resource_record has also closed warc_tmp. */
          warc_tmp = NULL;
        }

      if (con->cmd & DO_LIST)
        /* This is a directory listing file. */
        {
          if (!opt.remove_listing)
            /* --dont-remove-listing was specified, so do count this towards the
               number of bytes and files downloaded. */
            {
              total_downloaded_bytes += qtyread;
              numurls++;
            }

          /* Deletion of listing files is not controlled by --delete-after, but
             by the more specific option --dont-remove-listing, and the code
             to do this deletion is in another function. */
        }
      else if (!opt.spider)
        /* This is not a directory listing file. */
        {
          /* Unlike directory listing files, don't pretend normal files weren't
             downloaded if they're going to be deleted.  People seeding proxies,
             for instance, may want to know how many bytes and files they've
             downloaded through it. */
          total_downloaded_bytes += qtyread;
          numurls++;

          if (opt.delete_after && !input_file_url (opt.input_filename))
            {
              DEBUGP ((""\
Removing file due to --delete-after in ftp_loop_internal():\n""));
              logprintf (LOG_VERBOSE, _(""Removing %s.\n""), locf);
              if (unlink (locf))
                logprintf (LOG_NOTQUIET, ""unlink: %s\n"", strerror (errno));
            }
        }

      /* Restore the original leave-pendingness.  */
      if (orig_lp)
        con->cmd |= LEAVE_PENDING;
      else
        con->cmd &= ~LEAVE_PENDING;

      if (local_file)
        *local_file = xstrdup (locf);

      if (warc_tmp != NULL)
        fclose (warc_tmp);

      return RETROK;
    } while (!opt.ntry || (count < opt.ntry));

  if (con->csock != -1 && (con->st & ON_YOUR_OWN))
    {
      fd_close (con->csock);
      con->csock = -1;
    }

  if (warc_tmp != NULL)
    fclose (warc_tmp);

  return TRYLIMEXC;
}

/* Return the directory listing in a reusable format.  The directory
 /* Return the directory listing in a reusable format.  The directory
    is specifed in u->dir.  */
 static uerr_t
ftp_get_listing (struct url *u, struct url *original_url, ccon *con,
                 struct fileinfo **f)
 {
   uerr_t err;
   char *uf;                     /* url file name */

  con->st &= ~ON_YOUR_OWN;
  con->cmd |= (DO_LIST | LEAVE_PENDING);
  con->cmd &= ~DO_RETR;

  /* Find the listing file name.  We do it by taking the file name of
     the URL and replacing the last component with the listing file
     name.  */
  uf = url_file_name (u, NULL);
  lf = file_merge (uf, LIST_FILENAME);
  xfree (uf);
  DEBUGP ((_(""Using %s as listing tmp file.\n""), quote (lf)));

  con->target = xstrdup (lf);
 
   con->target = xstrdup (lf);
   xfree (lf);
  err = ftp_loop_internal (u, original_url, NULL, con, NULL, false);
   lf = xstrdup (con->target);
   xfree (con->target);
   con->target = old_target;
    {
      *f = ftp_parse_ls (lf, con->rs);
      if (opt.remove_listing)
        {
          if (unlink (lf))
            logprintf (LOG_NOTQUIET, ""unlink: %s\n"", strerror (errno));
          else
            logprintf (LOG_VERBOSE, _(""Removed %s.\n""), quote (lf));
        }
    }
  else
    *f = NULL;
  xfree (lf);
  con->cmd &= ~DO_LIST;
  return err;
}
   return err;
 }
","ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con, char **local_file,
                   bool force_full_retrieve)
 {
   int count, orig_lp;
   wgint restval, len = 0, qtyread = 0;
  const char *tmrate = NULL;
  uerr_t err;
  struct_stat st;

  /* Declare WARC variables. */
  bool warc_enabled = (opt.warc_filename != NULL);
  FILE *warc_tmp = NULL;
  ip_address *warc_ip = NULL;
  wgint last_expected_bytes = 0;

  /* Get the target, and set the name for the message accordingly. */
  if ((f == NULL) && (con->target))
    {
      /* Explicit file (like "".listing""). */
      locf = con->target;
    }
  else
    {
     {
       /* URL-derived file.  Consider ""-O file"" name. */
       xfree (con->target);
      con->target = url_file_name (u, NULL);
       if (!opt.output_document)
         locf = con->target;
       else
    }

  /* If the output_document was given, then this check was already done and
     the file didn't exist. Hence the !opt.output_document */

  /* If we receive .listing file it is necessary to determine system type of the ftp
     server even if opn.noclobber is given. Thus we must ignore opt.noclobber in
     order to establish connection with the server and get system type. */
  if (opt.noclobber && !opt.output_document && file_exists_p (con->target)
      && !((con->cmd & DO_LIST) && !(con->cmd & DO_RETR)))
    {
      logprintf (LOG_VERBOSE,
                 _(""File %s already there; not retrieving.\n""), quote (con->target));
      /* If the file is there, we suppose it's retrieved OK.  */
      return RETROK;
    }

  /* Remove it if it's a link.  */
  remove_link (con->target);

  count = 0;

  if (con->st & ON_YOUR_OWN)
    con->st = ON_YOUR_OWN;

  orig_lp = con->cmd & LEAVE_PENDING ? 1 : 0;

  /* THE loop.  */
  do
    {
      /* Increment the pass counter.  */
      ++count;
      sleep_between_retrievals (count);
      if (con->st & ON_YOUR_OWN)
        {
          con->cmd = 0;
          con->cmd |= (DO_RETR | LEAVE_PENDING);
          if (con->csock != -1)
            con->cmd &= ~ (DO_LOGIN | DO_CWD);
          else
            con->cmd |= (DO_LOGIN | DO_CWD);
        }
      else /* not on your own */
        {
          if (con->csock != -1)
            con->cmd &= ~DO_LOGIN;
          else
            con->cmd |= DO_LOGIN;
          if (con->st & DONE_CWD)
            con->cmd &= ~DO_CWD;
          else
            con->cmd |= DO_CWD;
        }

      /* For file RETR requests, we can write a WARC record.
         We record the file contents to a temporary file. */
      if (warc_enabled && (con->cmd & DO_RETR) && warc_tmp == NULL)
        {
          warc_tmp = warc_tempfile ();
          if (warc_tmp == NULL)
            return WARC_TMP_FOPENERR;

          if (!con->proxy && con->csock != -1)
            {
              warc_ip = (ip_address *) alloca (sizeof (ip_address));
              socket_ip_address (con->csock, warc_ip, ENDPOINT_PEER);
            }
        }

      /* Decide whether or not to restart.  */
      if (con->cmd & DO_LIST)
        restval = 0;
      else if (force_full_retrieve)
        restval = 0;
      else if (opt.start_pos >= 0)
        restval = opt.start_pos;
      else if (opt.always_rest
          && stat (locf, &st) == 0
          && S_ISREG (st.st_mode))
        /* When -c is used, continue from on-disk size.  (Can't use
           hstat.len even if count>1 because we don't want a failed
           first attempt to clobber existing data.)  */
        restval = st.st_size;
      else if (count > 1)
        restval = qtyread;          /* start where the previous run left off */
      else
        restval = 0;

      /* Get the current time string.  */
      tms = datetime_str (time (NULL));
      /* Print fetch message, if opt.verbose.  */
      if (opt.verbose)
        {
          char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD);
          char tmp[256];
          strcpy (tmp, ""        "");
          if (count > 1)
            sprintf (tmp, _(""(try:%2d)""), count);
          logprintf (LOG_VERBOSE, ""--%s--  %s\n  %s => %s\n"",
                     tms, hurl, tmp, quote (locf));
#ifdef WINDOWS
          ws_changetitle (hurl);
#endif
          xfree (hurl);
        }
      /* Send getftp the proper length, if fileinfo was provided.  */
      if (f && f->type != FT_SYMLINK)
        len = f->size;
      else
        len = 0;

 
       /* If we are working on a WARC record, getftp should also write
          to the warc_tmp file. */
      err = getftp (u, len, &qtyread, restval, con, count, &last_expected_bytes,
                    warc_tmp);
 
       if (con->csock == -1)
         con->st &= ~DONE_CWD;
        con->st |= DONE_CWD;

      switch (err)
        {
        case HOSTERR: case CONIMPOSSIBLE: case FWRITEERR: case FOPENERR:
        case FTPNSFOD: case FTPLOGINC: case FTPNOPASV: case FTPNOAUTH: case FTPNOPBSZ: case FTPNOPROT:
        case UNLINKERR: case WARC_TMP_FWRITEERR: case CONSSLERR: case CONTNOTSUPPORTED:
#ifdef HAVE_SSL
          if (err == FTPNOAUTH)
            logputs (LOG_NOTQUIET, ""Server does not support AUTH TLS.\n"");
          if (opt.ftps_implicit)
            logputs (LOG_NOTQUIET, ""Server does not like implicit FTPS connections.\n"");
#endif
          /* Fatal errors, give up.  */
          if (warc_tmp != NULL)
              fclose (warc_tmp);
          return err;
        case CONSOCKERR: case CONERROR: case FTPSRVERR: case FTPRERR:
        case WRITEFAILED: case FTPUNKNOWNTYPE: case FTPSYSERR:
        case FTPPORTERR: case FTPLOGREFUSED: case FTPINVPASV:
        case FOPEN_EXCL_ERR:
          printwhat (count, opt.ntry);
          /* non-fatal errors */
          if (err == FOPEN_EXCL_ERR)
            {
              /* Re-determine the file name. */
              xfree (con->target);
              con->target = url_file_name (u, NULL);
              locf = con->target;
            }
          continue;
        case FTPRETRINT:
          /* If the control connection was closed, the retrieval
             will be considered OK if f->size == len.  */
          if (!f || qtyread != f->size)
            {
              printwhat (count, opt.ntry);
              continue;
            }
          break;
        case RETRFINISHED:
          /* Great!  */
          break;
        default:
          /* Not as great.  */
          abort ();
        }
      tms = datetime_str (time (NULL));
      if (!opt.spider)
        tmrate = retr_rate (qtyread - restval, con->dltime);

      /* If we get out of the switch above without continue'ing, we've
         successfully downloaded a file.  Remember this fact. */
      downloaded_file (FILE_DOWNLOADED_NORMALLY, locf);

      if (con->st & ON_YOUR_OWN)
        {
          fd_close (con->csock);
          con->csock = -1;
        }
      if (!opt.spider)
        {
          bool write_to_stdout = (opt.output_document && HYPHENP (opt.output_document));

          logprintf (LOG_VERBOSE,
                     write_to_stdout
                     ? _(""%s (%s) - written to stdout %s[%s]\n\n"")
                     : _(""%s (%s) - %s saved [%s]\n\n""),
                     tms, tmrate,
                     write_to_stdout ? """" : quote (locf),
                     number_to_static_string (qtyread));
        }
      if (!opt.verbose && !opt.quiet)
        {
          /* Need to hide the password from the URL.  The `if' is here
             so that we don't do the needless allocation every
             time. */
          char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD);
          logprintf (LOG_NONVERBOSE, ""%s URL: %s [%s] -> \""%s\"" [%d]\n"",
                     tms, hurl, number_to_static_string (qtyread), locf, count);
          xfree (hurl);
        }

      if (warc_enabled && (con->cmd & DO_RETR))
        {
          /* Create and store a WARC resource record for the retrieved file. */
          bool warc_res;

          warc_res = warc_write_resource_record (NULL, u->url, NULL, NULL,
                                                  warc_ip, NULL, warc_tmp, -1);

          if (! warc_res)
            return WARC_ERR;

          /* warc_write_resource_record has also closed warc_tmp. */
          warc_tmp = NULL;
        }

      if (con->cmd & DO_LIST)
        /* This is a directory listing file. */
        {
          if (!opt.remove_listing)
            /* --dont-remove-listing was specified, so do count this towards the
               number of bytes and files downloaded. */
            {
              total_downloaded_bytes += qtyread;
              numurls++;
            }

          /* Deletion of listing files is not controlled by --delete-after, but
             by the more specific option --dont-remove-listing, and the code
             to do this deletion is in another function. */
        }
      else if (!opt.spider)
        /* This is not a directory listing file. */
        {
          /* Unlike directory listing files, don't pretend normal files weren't
             downloaded if they're going to be deleted.  People seeding proxies,
             for instance, may want to know how many bytes and files they've
             downloaded through it. */
          total_downloaded_bytes += qtyread;
          numurls++;

          if (opt.delete_after && !input_file_url (opt.input_filename))
            {
              DEBUGP ((""\
Removing file due to --delete-after in ftp_loop_internal():\n""));
              logprintf (LOG_VERBOSE, _(""Removing %s.\n""), locf);
              if (unlink (locf))
                logprintf (LOG_NOTQUIET, ""unlink: %s\n"", strerror (errno));
            }
        }

      /* Restore the original leave-pendingness.  */
      if (orig_lp)
        con->cmd |= LEAVE_PENDING;
      else
        con->cmd &= ~LEAVE_PENDING;

      if (local_file)
        *local_file = xstrdup (locf);

      if (warc_tmp != NULL)
        fclose (warc_tmp);

      return RETROK;
    } while (!opt.ntry || (count < opt.ntry));

  if (con->csock != -1 && (con->st & ON_YOUR_OWN))
    {
      fd_close (con->csock);
      con->csock = -1;
    }

  if (warc_tmp != NULL)
    fclose (warc_tmp);

  return TRYLIMEXC;
}

/* Return the directory listing in a reusable format.  The directory
 /* Return the directory listing in a reusable format.  The directory
    is specifed in u->dir.  */
 static uerr_t
ftp_get_listing (struct url *u, ccon *con, struct fileinfo **f)
 {
   uerr_t err;
   char *uf;                     /* url file name */

  con->st &= ~ON_YOUR_OWN;
  con->cmd |= (DO_LIST | LEAVE_PENDING);
  con->cmd &= ~DO_RETR;

  /* Find the listing file name.  We do it by taking the file name of
     the URL and replacing the last component with the listing file
     name.  */
  uf = url_file_name (u, NULL);
  lf = file_merge (uf, LIST_FILENAME);
  xfree (uf);
  DEBUGP ((_(""Using %s as listing tmp file.\n""), quote (lf)));

  con->target = xstrdup (lf);
 
   con->target = xstrdup (lf);
   xfree (lf);
  err = ftp_loop_internal (u, NULL, con, NULL, false);
   lf = xstrdup (con->target);
   xfree (con->target);
   con->target = old_target;
    {
      *f = ftp_parse_ls (lf, con->rs);
      if (opt.remove_listing)
        {
          if (unlink (lf))
            logprintf (LOG_NOTQUIET, ""unlink: %s\n"", strerror (errno));
          else
            logprintf (LOG_VERBOSE, _(""Removed %s.\n""), quote (lf));
        }
    }
  else
    *f = NULL;
  xfree (lf);
  con->cmd &= ~DO_LIST;
  return err;
}
   return err;
 }
",C,"ftp_loop_internal (struct url *u, struct url *original_url, struct fileinfo *f,
                   ccon *con, char **local_file, bool force_full_retrieve)
      con->target = url_file_name (opt.trustservernames || !original_url ? u : original_url, NULL);
      err = getftp (u, original_url, len, &qtyread, restval, con, count,
                    &last_expected_bytes, warc_tmp);
ftp_get_listing (struct url *u, struct url *original_url, ccon *con,
                 struct fileinfo **f)
  err = ftp_loop_internal (u, original_url, NULL, con, NULL, false);
","                   bool force_full_retrieve)
      con->target = url_file_name (u, NULL);
      err = getftp (u, len, &qtyread, restval, con, count, &last_expected_bytes,
                    warc_tmp);
ftp_get_listing (struct url *u, ccon *con, struct fileinfo **f)
  err = ftp_loop_internal (u, NULL, con, NULL, false);
",2bdfc4f521047514a74c18ecd271679ca61b0a26,"@@ -236,7 +236,7 @@ print_length (wgint size, wgint start, bool authoritative)
   logputs (LOG_VERBOSE, !authoritative ? _("" (unauthoritative)\n"") : ""\n"");
 }
 
-static uerr_t ftp_get_listing (struct url *, ccon *, struct fileinfo **);
+static uerr_t ftp_get_listing (struct url *, struct url *, ccon *, struct fileinfo **);
 
 static uerr_t
 get_ftp_greeting(int csock, ccon *con)
@@ -315,7 +315,8 @@ init_control_ssl_connection (int csock, struct url *u, bool *using_control_secur
    and closes the control connection in case of error.  If warc_tmp
    is non-NULL, the downloaded data will be written there as well.  */
 static uerr_t
-getftp (struct url *u, wgint passed_expected_bytes, wgint *qtyread,
+getftp (struct url *u, struct url *original_url,
+        wgint passed_expected_bytes, wgint *qtyread,
         wgint restval, ccon *con, int count, wgint *last_expected_bytes,
         FILE *warc_tmp)
 {
@@ -1188,7 +1189,7 @@ Error in server response, closing control connection.\n""));
         {
           bool exists = false;
           struct fileinfo *f;
-          uerr_t _res = ftp_get_listing (u, con, &f);
+          uerr_t _res = ftp_get_listing (u, original_url, con, &f);
           /* Set the DO_RETR command flag again, because it gets unset when
              calling ftp_get_listing() and would otherwise cause an assertion
              failure earlier on when this function gets repeatedly called
@@ -1779,8 +1780,8 @@ exit_error:
    This loop either gets commands from con, or (if ON_YOUR_OWN is
    set), makes them up to retrieve the file given by the URL.  */
 static uerr_t
-ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con, char **local_file,
-                   bool force_full_retrieve)
+ftp_loop_internal (struct url *u, struct url *original_url, struct fileinfo *f,
+                   ccon *con, char **local_file, bool force_full_retrieve)
 {
   int count, orig_lp;
   wgint restval, len = 0, qtyread = 0;
@@ -1805,7 +1806,7 @@ ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con, char **local_fi
     {
       /* URL-derived file.  Consider ""-O file"" name. */
       xfree (con->target);
-      con->target = url_file_name (u, NULL);
+      con->target = url_file_name (opt.trustservernames || !original_url ? u : original_url, NULL);
       if (!opt.output_document)
         locf = con->target;
       else
@@ -1923,8 +1924,8 @@ ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con, char **local_fi
 
       /* If we are working on a WARC record, getftp should also write
          to the warc_tmp file. */
-      err = getftp (u, len, &qtyread, restval, con, count, &last_expected_bytes,
-                    warc_tmp);
+      err = getftp (u, original_url, len, &qtyread, restval, con, count,
+                    &last_expected_bytes, warc_tmp);
 
       if (con->csock == -1)
         con->st &= ~DONE_CWD;
@@ -2092,7 +2093,8 @@ Removing file due to --delete-after in ftp_loop_internal():\n""));
 /* Return the directory listing in a reusable format.  The directory
    is specifed in u->dir.  */
 static uerr_t
-ftp_get_listing (struct url *u, ccon *con, struct fileinfo **f)
+ftp_get_listing (struct url *u, struct url *original_url, ccon *con,
+                 struct fileinfo **f)
 {
   uerr_t err;
   char *uf;                     /* url file name */
@@ -2113,7 +2115,7 @@ ftp_get_listing (struct url *u, ccon *con, struct fileinfo **f)
 
   con->target = xstrdup (lf);
   xfree (lf);
-  err = ftp_loop_internal (u, NULL, con, NULL, false);
+  err = ftp_loop_internal (u, original_url, NULL, con, NULL, false);
   lf = xstrdup (con->target);
   xfree (con->target);
   con->target = old_target;
@@ -2136,8 +2138,9 @@ ftp_get_listing (struct url *u, ccon *con, struct fileinfo **f)
   return err;
 }
 
-static uerr_t ftp_retrieve_dirs (struct url *, struct fileinfo *, ccon *);
-static uerr_t ftp_retrieve_glob (struct url *, ccon *, int);
+static uerr_t ftp_retrieve_dirs (struct url *, struct url *,
+                                 struct fileinfo *, ccon *);
+static uerr_t ftp_retrieve_glob (struct url *, struct url *, ccon *, int);
 static struct fileinfo *delelement (struct fileinfo *, struct fileinfo **);
 static void freefileinfo (struct fileinfo *f);
 
@@ -2149,7 +2152,8 @@ static void freefileinfo (struct fileinfo *f);
    If opt.recursive is set, after all files have been retrieved,
    ftp_retrieve_dirs will be called to retrieve the directories.  */
 static uerr_t
-ftp_retrieve_list (struct url *u, struct fileinfo *f, ccon *con)
+ftp_retrieve_list (struct url *u, struct url *original_url,
+                   struct fileinfo *f, ccon *con)
 {
   static int depth = 0;
   uerr_t err;
@@ -2310,7 +2314,10 @@ Already have correct symlink %s -> %s\n\n""),
           else                /* opt.retr_symlinks */
             {
               if (dlthis)
-                err = ftp_loop_internal (u, f, con, NULL, force_full_retrieve);
+                {
+                  err = ftp_loop_internal (u, original_url, f, con, NULL,
+                                           force_full_retrieve);
+                }
             } /* opt.retr_symlinks */
           break;
         case FT_DIRECTORY:
@@ -2321,7 +2328,10 @@ Already have correct symlink %s -> %s\n\n""),
         case FT_PLAINFILE:
           /* Call the retrieve loop.  */
           if (dlthis)
-            err = ftp_loop_internal (u, f, con, NULL, force_full_retrieve);
+            {
+              err = ftp_loop_internal (u, original_url, f, con, NULL,
+                                       force_full_retrieve);
+            }
           break;
         case FT_UNKNOWN:
           logprintf (LOG_NOTQUIET, _(""%s: unknown/unsupported file type.\n""),
@@ -2386,7 +2396,7 @@ Already have correct symlink %s -> %s\n\n""),
   /* We do not want to call ftp_retrieve_dirs here */
   if (opt.recursive &&
       !(opt.reclevel != INFINITE_RECURSION && depth >= opt.reclevel))
-    err = ftp_retrieve_dirs (u, orig, con);
+    err = ftp_retrieve_dirs (u, original_url, orig, con);
   else if (opt.recursive)
     DEBUGP ((_(""Will not retrieve dirs since depth is %d (max %d).\n""),
              depth, opt.reclevel));
@@ -2399,7 +2409,8 @@ Already have correct symlink %s -> %s\n\n""),
    ftp_retrieve_glob on each directory entry.  The function knows
    about excluded directories.  */
 static uerr_t
-ftp_retrieve_dirs (struct url *u, struct fileinfo *f, ccon *con)
+ftp_retrieve_dirs (struct url *u, struct url *original_url,
+                   struct fileinfo *f, ccon *con)
 {
   char *container = NULL;
   int container_size = 0;
@@ -2449,7 +2460,7 @@ Not descending to %s as it is excluded/not-included.\n""),
       odir = xstrdup (u->dir);  /* because url_set_dir will free
                                    u->dir. */
       url_set_dir (u, newdir);
-      ftp_retrieve_glob (u, con, GLOB_GETALL);
+      ftp_retrieve_glob (u, original_url, con, GLOB_GETALL);
       url_set_dir (u, odir);
       xfree (odir);
 
@@ -2508,14 +2519,15 @@ is_invalid_entry (struct fileinfo *f)
    GLOB_GLOBALL, use globbing; if it's GLOB_GETALL, download the whole
    directory.  */
 static uerr_t
-ftp_retrieve_glob (struct url *u, ccon *con, int action)
+ftp_retrieve_glob (struct url *u, struct url *original_url,
+                   ccon *con, int action)
 {
   struct fileinfo *f, *start;
   uerr_t res;
 
   con->cmd |= LEAVE_PENDING;
 
-  res = ftp_get_listing (u, con, &start);
+  res = ftp_get_listing (u, original_url, con, &start);
   if (res != RETROK)
     return res;
   /* First: weed out that do not conform the global rules given in
@@ -2611,7 +2623,7 @@ ftp_retrieve_glob (struct url *u, ccon *con, int action)
   if (start)
     {
       /* Just get everything.  */
-      res = ftp_retrieve_list (u, start, con);
+      res = ftp_retrieve_list (u, original_url, start, con);
     }
   else
     {
@@ -2627,7 +2639,7 @@ ftp_retrieve_glob (struct url *u, ccon *con, int action)
         {
           /* Let's try retrieving it anyway.  */
           con->st |= ON_YOUR_OWN;
-          res = ftp_loop_internal (u, NULL, con, NULL, false);
+          res = ftp_loop_internal (u, original_url, NULL, con, NULL, false);
           return res;
         }
 
@@ -2647,8 +2659,8 @@ ftp_retrieve_glob (struct url *u, ccon *con, int action)
    of URL.  Inherently, its capabilities are limited on what can be
    encoded into a URL.  */
 uerr_t
-ftp_loop (struct url *u, char **local_file, int *dt, struct url *proxy,
-          bool recursive, bool glob)
+ftp_loop (struct url *u, struct url *original_url, char **local_file, int *dt,
+          struct url *proxy, bool recursive, bool glob)
 {
   ccon con;                     /* FTP connection */
   uerr_t res;
@@ -2669,16 +2681,17 @@ ftp_loop (struct url *u, char **local_file, int *dt, struct url *proxy,
   if (!*u->file && !recursive)
     {
       struct fileinfo *f;
-      res = ftp_get_listing (u, &con, &f);
+      res = ftp_get_listing (u, original_url, &con, &f);
 
       if (res == RETROK)
         {
           if (opt.htmlify && !opt.spider)
             {
+              struct url *url_file = opt.trustservernames ? u : original_url;
               char *filename = (opt.output_document
                                 ? xstrdup (opt.output_document)
                                 : (con.target ? xstrdup (con.target)
-                                   : url_file_name (u, NULL)));
+                                   : url_file_name (url_file, NULL)));
               res = ftp_index (filename, u, f);
               if (res == FTPOK && opt.verbose)
                 {
@@ -2723,11 +2736,13 @@ ftp_loop (struct url *u, char **local_file, int *dt, struct url *proxy,
           /* ftp_retrieve_glob is a catch-all function that gets called
              if we need globbing, time-stamping, recursion or preserve
              permissions.  Its third argument is just what we really need.  */
-          res = ftp_retrieve_glob (u, &con,
+          res = ftp_retrieve_glob (u, original_url, &con,
                                    ispattern ? GLOB_GLOBALL : GLOB_GETONE);
         }
       else
-        res = ftp_loop_internal (u, NULL, &con, local_file, false);
+        {
+          res = ftp_loop_internal (u, original_url, NULL, &con, local_file, false);
+        }
     }
   if (res == FTPOK)
     res = RETROK;",savannah,https://git.savannah.gnu.org/cgit/wget.git/tree/src/ftp.c?id=e996e322ffd42aaa051602da182d03178d0f13e1,https://git.savannah.gnu.org/cgit/wget.git/tree/src/ftp.c?id=2bdfc4f521047514a74c18ecd271679ca61b0a26,1,"ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con, char **local_file,
//flaw_line_below:
                   bool force_full_retrieve)
//fix_flaw_line_below:
//ftp_loop_internal (struct url *u, struct url *original_url, struct fileinfo *f,
//fix_flaw_line_below:
//                   ccon *con, char **local_file, bool force_full_retrieve)
 {
   int count, orig_lp;
   wgint restval, len = 0, qtyread = 0;
  const char *tmrate = NULL;
  uerr_t err;
  struct_stat st;

  /* Declare WARC variables. */
  bool warc_enabled = (opt.warc_filename != NULL);
  FILE *warc_tmp = NULL;
  ip_address *warc_ip = NULL;
  wgint last_expected_bytes = 0;

  /* Get the target, and set the name for the message accordingly. */
  if ((f == NULL) && (con->target))
    {
      /* Explicit file (like "".listing""). */
      locf = con->target;
    }
  else
    {
     {
       /* URL-derived file.  Consider ""-O file"" name. */
       xfree (con->target);
//flaw_line_below:
      con->target = url_file_name (u, NULL);
//fix_flaw_line_below:
//      con->target = url_file_name (opt.trustservernames || !original_url ? u : original_url, NULL);
       if (!opt.output_document)
         locf = con->target;
       else
    }

  /* If the output_document was given, then this check was already done and
     the file didn't exist. Hence the !opt.output_document */

  /* If we receive .listing file it is necessary to determine system type of the ftp
     server even if opn.noclobber is given. Thus we must ignore opt.noclobber in
     order to establish connection with the server and get system type. */
  if (opt.noclobber && !opt.output_document && file_exists_p (con->target)
      && !((con->cmd & DO_LIST) && !(con->cmd & DO_RETR)))
    {
      logprintf (LOG_VERBOSE,
                 _(""File %s already there; not retrieving.\n""), quote (con->target));
      /* If the file is there, we suppose it's retrieved OK.  */
      return RETROK;
    }

  /* Remove it if it's a link.  */
  remove_link (con->target);

  count = 0;

  if (con->st & ON_YOUR_OWN)
    con->st = ON_YOUR_OWN;

  orig_lp = con->cmd & LEAVE_PENDING ? 1 : 0;

  /* THE loop.  */
  do
    {
      /* Increment the pass counter.  */
      ++count;
      sleep_between_retrievals (count);
      if (con->st & ON_YOUR_OWN)
        {
          con->cmd = 0;
          con->cmd |= (DO_RETR | LEAVE_PENDING);
          if (con->csock != -1)
            con->cmd &= ~ (DO_LOGIN | DO_CWD);
          else
            con->cmd |= (DO_LOGIN | DO_CWD);
        }
      else /* not on your own */
        {
          if (con->csock != -1)
            con->cmd &= ~DO_LOGIN;
          else
            con->cmd |= DO_LOGIN;
          if (con->st & DONE_CWD)
            con->cmd &= ~DO_CWD;
          else
            con->cmd |= DO_CWD;
        }

      /* For file RETR requests, we can write a WARC record.
         We record the file contents to a temporary file. */
      if (warc_enabled && (con->cmd & DO_RETR) && warc_tmp == NULL)
        {
          warc_tmp = warc_tempfile ();
          if (warc_tmp == NULL)
            return WARC_TMP_FOPENERR;

          if (!con->proxy && con->csock != -1)
            {
              warc_ip = (ip_address *) alloca (sizeof (ip_address));
              socket_ip_address (con->csock, warc_ip, ENDPOINT_PEER);
            }
        }

      /* Decide whether or not to restart.  */
      if (con->cmd & DO_LIST)
        restval = 0;
      else if (force_full_retrieve)
        restval = 0;
      else if (opt.start_pos >= 0)
        restval = opt.start_pos;
      else if (opt.always_rest
          && stat (locf, &st) == 0
          && S_ISREG (st.st_mode))
        /* When -c is used, continue from on-disk size.  (Can't use
           hstat.len even if count>1 because we don't want a failed
           first attempt to clobber existing data.)  */
        restval = st.st_size;
      else if (count > 1)
        restval = qtyread;          /* start where the previous run left off */
      else
        restval = 0;

      /* Get the current time string.  */
      tms = datetime_str (time (NULL));
      /* Print fetch message, if opt.verbose.  */
      if (opt.verbose)
        {
          char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD);
          char tmp[256];
          strcpy (tmp, ""        "");
          if (count > 1)
            sprintf (tmp, _(""(try:%2d)""), count);
          logprintf (LOG_VERBOSE, ""--%s--  %s\n  %s => %s\n"",
                     tms, hurl, tmp, quote (locf));
#ifdef WINDOWS
          ws_changetitle (hurl);
#endif
          xfree (hurl);
        }
      /* Send getftp the proper length, if fileinfo was provided.  */
      if (f && f->type != FT_SYMLINK)
        len = f->size;
      else
        len = 0;

 
       /* If we are working on a WARC record, getftp should also write
          to the warc_tmp file. */
//flaw_line_below:
      err = getftp (u, len, &qtyread, restval, con, count, &last_expected_bytes,
//flaw_line_below:
                    warc_tmp);
//fix_flaw_line_below:
//      err = getftp (u, original_url, len, &qtyread, restval, con, count,
//fix_flaw_line_below:
//                    &last_expected_bytes, warc_tmp);
 
       if (con->csock == -1)
         con->st &= ~DONE_CWD;
        con->st |= DONE_CWD;

      switch (err)
        {
        case HOSTERR: case CONIMPOSSIBLE: case FWRITEERR: case FOPENERR:
        case FTPNSFOD: case FTPLOGINC: case FTPNOPASV: case FTPNOAUTH: case FTPNOPBSZ: case FTPNOPROT:
        case UNLINKERR: case WARC_TMP_FWRITEERR: case CONSSLERR: case CONTNOTSUPPORTED:
#ifdef HAVE_SSL
          if (err == FTPNOAUTH)
            logputs (LOG_NOTQUIET, ""Server does not support AUTH TLS.\n"");
          if (opt.ftps_implicit)
            logputs (LOG_NOTQUIET, ""Server does not like implicit FTPS connections.\n"");
#endif
          /* Fatal errors, give up.  */
          if (warc_tmp != NULL)
              fclose (warc_tmp);
          return err;
        case CONSOCKERR: case CONERROR: case FTPSRVERR: case FTPRERR:
        case WRITEFAILED: case FTPUNKNOWNTYPE: case FTPSYSERR:
        case FTPPORTERR: case FTPLOGREFUSED: case FTPINVPASV:
        case FOPEN_EXCL_ERR:
          printwhat (count, opt.ntry);
          /* non-fatal errors */
          if (err == FOPEN_EXCL_ERR)
            {
              /* Re-determine the file name. */
              xfree (con->target);
              con->target = url_file_name (u, NULL);
              locf = con->target;
            }
          continue;
        case FTPRETRINT:
          /* If the control connection was closed, the retrieval
             will be considered OK if f->size == len.  */
          if (!f || qtyread != f->size)
            {
              printwhat (count, opt.ntry);
              continue;
            }
          break;
        case RETRFINISHED:
          /* Great!  */
          break;
        default:
          /* Not as great.  */
          abort ();
        }
      tms = datetime_str (time (NULL));
      if (!opt.spider)
        tmrate = retr_rate (qtyread - restval, con->dltime);

      /* If we get out of the switch above without continue'ing, we've
         successfully downloaded a file.  Remember this fact. */
      downloaded_file (FILE_DOWNLOADED_NORMALLY, locf);

      if (con->st & ON_YOUR_OWN)
        {
          fd_close (con->csock);
          con->csock = -1;
        }
      if (!opt.spider)
        {
          bool write_to_stdout = (opt.output_document && HYPHENP (opt.output_document));

          logprintf (LOG_VERBOSE,
                     write_to_stdout
                     ? _(""%s (%s) - written to stdout %s[%s]\n\n"")
                     : _(""%s (%s) - %s saved [%s]\n\n""),
                     tms, tmrate,
                     write_to_stdout ? """" : quote (locf),
                     number_to_static_string (qtyread));
        }
      if (!opt.verbose && !opt.quiet)
        {
          /* Need to hide the password from the URL.  The `if' is here
             so that we don't do the needless allocation every
             time. */
          char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD);
          logprintf (LOG_NONVERBOSE, ""%s URL: %s [%s] -> \""%s\"" [%d]\n"",
                     tms, hurl, number_to_static_string (qtyread), locf, count);
          xfree (hurl);
        }

      if (warc_enabled && (con->cmd & DO_RETR))
        {
          /* Create and store a WARC resource record for the retrieved file. */
          bool warc_res;

          warc_res = warc_write_resource_record (NULL, u->url, NULL, NULL,
                                                  warc_ip, NULL, warc_tmp, -1);

          if (! warc_res)
            return WARC_ERR;

          /* warc_write_resource_record has also closed warc_tmp. */
          warc_tmp = NULL;
        }

      if (con->cmd & DO_LIST)
        /* This is a directory listing file. */
        {
          if (!opt.remove_listing)
            /* --dont-remove-listing was specified, so do count this towards the
               number of bytes and files downloaded. */
            {
              total_downloaded_bytes += qtyread;
              numurls++;
            }

          /* Deletion of listing files is not controlled by --delete-after, but
             by the more specific option --dont-remove-listing, and the code
             to do this deletion is in another function. */
        }
      else if (!opt.spider)
        /* This is not a directory listing file. */
        {
          /* Unlike directory listing files, don't pretend normal files weren't
             downloaded if they're going to be deleted.  People seeding proxies,
             for instance, may want to know how many bytes and files they've
             downloaded through it. */
          total_downloaded_bytes += qtyread;
          numurls++;

          if (opt.delete_after && !input_file_url (opt.input_filename))
            {
              DEBUGP ((""\
Removing file due to --delete-after in ftp_loop_internal():\n""));
              logprintf (LOG_VERBOSE, _(""Removing %s.\n""), locf);
              if (unlink (locf))
                logprintf (LOG_NOTQUIET, ""unlink: %s\n"", strerror (errno));
            }
        }

      /* Restore the original leave-pendingness.  */
      if (orig_lp)
        con->cmd |= LEAVE_PENDING;
      else
        con->cmd &= ~LEAVE_PENDING;

      if (local_file)
        *local_file = xstrdup (locf);

      if (warc_tmp != NULL)
        fclose (warc_tmp);

      return RETROK;
    } while (!opt.ntry || (count < opt.ntry));

  if (con->csock != -1 && (con->st & ON_YOUR_OWN))
    {
      fd_close (con->csock);
      con->csock = -1;
    }

  if (warc_tmp != NULL)
    fclose (warc_tmp);

  return TRYLIMEXC;
}

/* Return the directory listing in a reusable format.  The directory
 /* Return the directory listing in a reusable format.  The directory
    is specifed in u->dir.  */
 static uerr_t
//flaw_line_below:
ftp_get_listing (struct url *u, ccon *con, struct fileinfo **f)
//fix_flaw_line_below:
//ftp_get_listing (struct url *u, struct url *original_url, ccon *con,
//fix_flaw_line_below:
//                 struct fileinfo **f)
 {
   uerr_t err;
   char *uf;                     /* url file name */

  con->st &= ~ON_YOUR_OWN;
  con->cmd |= (DO_LIST | LEAVE_PENDING);
  con->cmd &= ~DO_RETR;

  /* Find the listing file name.  We do it by taking the file name of
     the URL and replacing the last component with the listing file
     name.  */
  uf = url_file_name (u, NULL);
  lf = file_merge (uf, LIST_FILENAME);
  xfree (uf);
  DEBUGP ((_(""Using %s as listing tmp file.\n""), quote (lf)));

  con->target = xstrdup (lf);
 
   con->target = xstrdup (lf);
   xfree (lf);
//flaw_line_below:
  err = ftp_loop_internal (u, NULL, con, NULL, false);
//fix_flaw_line_below:
//  err = ftp_loop_internal (u, original_url, NULL, con, NULL, false);
   lf = xstrdup (con->target);
   xfree (con->target);
   con->target = old_target;
    {
      *f = ftp_parse_ls (lf, con->rs);
      if (opt.remove_listing)
        {
          if (unlink (lf))
            logprintf (LOG_NOTQUIET, ""unlink: %s\n"", strerror (errno));
          else
            logprintf (LOG_VERBOSE, _(""Removed %s.\n""), quote (lf));
        }
    }
  else
    *f = NULL;
  xfree (lf);
  con->cmd &= ~DO_LIST;
  return err;
}
   return err;
 }
"
452,178188,,Remote,Not required,,CVE-2016-4971,https://www.cvedetails.com/cve/CVE-2016-4971/,CWE-254,Medium,,Partial,,2016-06-30,4.3,GNU wget before 1.18 allows remote servers to write to arbitrary files by redirecting a request from HTTP to a crafted FTP resource.,2018-01-04,,2,https://git.savannah.gnu.org/cgit/wget.git/commit/?id=e996e322ffd42aaa051602da182d03178d0f13e1,e996e322ffd42aaa051602da182d03178d0f13e1,,1,,,"retrieve_url (struct url * orig_parsed, const char *origurl, char **file,
              char **newloc, const char *refurl, int *dt, bool recursive,
              struct iri *iri, bool register_status)
{
  uerr_t result;
  char *url;
  bool location_changed;
  bool iri_fallbacked = 0;
  int dummy;
  char *mynewloc, *proxy;
  struct url *u = orig_parsed, *proxy_url;
  int up_error_code;            /* url parse error code */
  char *local_file = NULL;
  int redirection_count = 0;

  bool method_suspended = false;
  char *saved_body_data = NULL;
  char *saved_method = NULL;
  char *saved_body_file_name = NULL;

  /* If dt is NULL, use local storage.  */
  if (!dt)
    {
      dt = &dummy;
      dummy = 0;
    }
  url = xstrdup (origurl);
  if (newloc)
    *newloc = NULL;
  if (file)
    *file = NULL;

  if (!refurl)
    refurl = opt.referer;

 redirected:
  /* (also for IRI fallbacking) */

  result = NOCONERROR;
  mynewloc = NULL;
  xfree(local_file);
  proxy_url = NULL;

  proxy = getproxy (u);
  if (proxy)
    {
      struct iri *pi = iri_new ();
      set_uri_encoding (pi, opt.locale, true);
      pi->utf8_encode = false;

      /* Parse the proxy URL.  */
      proxy_url = url_parse (proxy, &up_error_code, pi, true);
      if (!proxy_url)
        {
          char *error = url_error (proxy, up_error_code);
          logprintf (LOG_NOTQUIET, _(""Error parsing proxy URL %s: %s.\n""),
                     proxy, error);
          xfree (url);
          xfree (error);
          xfree (proxy);
          iri_free (pi);
          RESTORE_METHOD;
          result = PROXERR;
          goto bail;
        }
      if (proxy_url->scheme != SCHEME_HTTP && proxy_url->scheme != u->scheme)
        {
          logprintf (LOG_NOTQUIET, _(""Error in proxy URL %s: Must be HTTP.\n""), proxy);
          url_free (proxy_url);
          xfree (url);
          xfree (proxy);
          iri_free (pi);
          RESTORE_METHOD;
          result = PROXERR;
          goto bail;
        }
      iri_free(pi);
      xfree (proxy);
    }

  if (u->scheme == SCHEME_HTTP
#ifdef HAVE_SSL
      || u->scheme == SCHEME_HTTPS
#endif
      || (proxy_url && proxy_url->scheme == SCHEME_HTTP))
    {
#ifdef HAVE_HSTS
#ifdef TESTING
      /* we don't link against main.o when we're testing */
      hsts_store_t hsts_store = NULL;
#else
      extern hsts_store_t hsts_store;
#endif

      if (opt.hsts && hsts_store)
	{
	  if (hsts_match (hsts_store, u))
	    logprintf (LOG_VERBOSE, ""URL transformed to HTTPS due to an HSTS policy\n"");
	}
#endif
      result = http_loop (u, orig_parsed, &mynewloc, &local_file, refurl, dt,
                          proxy_url, iri);
    }
  else if (u->scheme == SCHEME_FTP
#ifdef HAVE_SSL
      || u->scheme == SCHEME_FTPS
#endif
      )
    {
      /* If this is a redirection, temporarily turn off opt.ftp_glob
         and opt.recursive, both being undesirable when following
         redirects.  */
      bool oldrec = recursive, glob = opt.ftp_glob;
       if (redirection_count)
         oldrec = glob = false;
 
      result = ftp_loop (u, orig_parsed, &local_file, dt, proxy_url,
                         recursive, glob);
       recursive = oldrec;
 
       /* There is a possibility of having HTTP being redirected to
         according to the suffix.  The HTML suffixes are `.html',
         `.htm' and a few others, case-insensitive.  */
      if (redirection_count && local_file && (u->scheme == SCHEME_FTP
#ifdef HAVE_SSL
          || u->scheme == SCHEME_FTPS
#endif
          ))
        {
          if (has_html_suffix_p (local_file))
            *dt |= TEXTHTML;
        }
    }

  if (proxy_url)
    {
      url_free (proxy_url);
      proxy_url = NULL;
    }

  location_changed = (result == NEWLOCATION || result == NEWLOCATION_KEEP_POST);
  if (location_changed)
    {
      char *construced_newloc;
      struct url *newloc_parsed;

      assert (mynewloc != NULL);

      xfree (local_file);

      /* The HTTP specs only allow absolute URLs to appear in
         redirects, but a ton of boneheaded webservers and CGIs out
         there break the rules and use relative URLs, and popular
         browsers are lenient about this, so wget should be too. */
      construced_newloc = uri_merge (url, mynewloc);
      xfree (mynewloc);
      mynewloc = construced_newloc;

#ifdef ENABLE_IRI
      /* Reset UTF-8 encoding state, set the URI encoding and reset
         the content encoding. */
      iri->utf8_encode = opt.enable_iri;
      if (opt.encoding_remote)
       set_uri_encoding (iri, opt.encoding_remote, true);
      set_content_encoding (iri, NULL);
      xfree (iri->orig_url);
#endif

      /* Now, see if this new location makes sense. */
      newloc_parsed = url_parse (mynewloc, &up_error_code, iri, true);
      if (!newloc_parsed)
        {
          char *error = url_error (mynewloc, up_error_code);
          logprintf (LOG_NOTQUIET, ""%s: %s.\n"", escnonprint_uri (mynewloc),
                     error);
          if (orig_parsed != u)
            {
              url_free (u);
            }
          xfree (url);
          xfree (mynewloc);
          xfree (error);
          RESTORE_METHOD;
          goto bail;
        }

      /* Now mynewloc will become newloc_parsed->url, because if the
         Location contained relative paths like .././something, we
         don't want that propagating as url.  */
      xfree (mynewloc);
      mynewloc = xstrdup (newloc_parsed->url);

      /* Check for max. number of redirections.  */
      if (++redirection_count > opt.max_redirect)
        {
          logprintf (LOG_NOTQUIET, _(""%d redirections exceeded.\n""),
                     opt.max_redirect);
          url_free (newloc_parsed);
          if (orig_parsed != u)
            {
              url_free (u);
            }
          xfree (url);
          xfree (mynewloc);
          RESTORE_METHOD;
          result = WRONGCODE;
          goto bail;
        }

      xfree (url);
      url = mynewloc;
      if (orig_parsed != u)
        {
          url_free (u);
        }
      u = newloc_parsed;

      /* If we're being redirected from POST, and we received a
         redirect code different than 307, we don't want to POST
         again.  Many requests answer POST with a redirection to an
         index page; that redirection is clearly a GET.  We ""suspend""
         POST data for the duration of the redirections, and restore
         it when we're done.

         RFC2616 HTTP/1.1 introduces code 307 Temporary Redirect
         specifically to preserve the method of the request.
     */
      if (result != NEWLOCATION_KEEP_POST && !method_suspended)
        SUSPEND_METHOD;

      goto redirected;
    }
  else
    {
      xfree(mynewloc);
    }

  /* Try to not encode in UTF-8 if fetching failed */
  if (!(*dt & RETROKF) && iri->utf8_encode)
    {
      iri->utf8_encode = false;
      if (orig_parsed != u)
        {
          url_free (u);
        }
      u = url_parse (origurl, NULL, iri, true);
      if (u)
        {
          DEBUGP ((""[IRI fallbacking to non-utf8 for %s\n"", quote (url)));
          xfree (url);
          url = xstrdup (u->url);
          iri_fallbacked = 1;
          goto redirected;
        }
      else
          DEBUGP ((""[Couldn't fallback to non-utf8 for %s\n"", quote (url)));
    }

  if (local_file && u && (*dt & RETROKF || opt.content_on_error))
    {
      register_download (u->url, local_file);

      if (!opt.spider && redirection_count && 0 != strcmp (origurl, u->url))
        register_redirection (origurl, u->url);

      if (*dt & TEXTHTML)
        register_html (local_file);

      if (*dt & TEXTCSS)
        register_css (local_file);
    }

  if (file)
    *file = local_file ? local_file : NULL;
  else
    xfree (local_file);

  if (orig_parsed != u)
    {
      url_free (u);
    }

  if (redirection_count || iri_fallbacked)
    {
      if (newloc)
        *newloc = url;
      else
        xfree (url);
    }
  else
    {
      if (newloc)
        *newloc = NULL;
      xfree (url);
    }

  RESTORE_METHOD;

bail:
  if (register_status)
    inform_exit_status (result);

  return result;
}
","retrieve_url (struct url * orig_parsed, const char *origurl, char **file,
              char **newloc, const char *refurl, int *dt, bool recursive,
              struct iri *iri, bool register_status)
{
  uerr_t result;
  char *url;
  bool location_changed;
  bool iri_fallbacked = 0;
  int dummy;
  char *mynewloc, *proxy;
  struct url *u = orig_parsed, *proxy_url;
  int up_error_code;            /* url parse error code */
  char *local_file = NULL;
  int redirection_count = 0;

  bool method_suspended = false;
  char *saved_body_data = NULL;
  char *saved_method = NULL;
  char *saved_body_file_name = NULL;

  /* If dt is NULL, use local storage.  */
  if (!dt)
    {
      dt = &dummy;
      dummy = 0;
    }
  url = xstrdup (origurl);
  if (newloc)
    *newloc = NULL;
  if (file)
    *file = NULL;

  if (!refurl)
    refurl = opt.referer;

 redirected:
  /* (also for IRI fallbacking) */

  result = NOCONERROR;
  mynewloc = NULL;
  xfree(local_file);
  proxy_url = NULL;

  proxy = getproxy (u);
  if (proxy)
    {
      struct iri *pi = iri_new ();
      set_uri_encoding (pi, opt.locale, true);
      pi->utf8_encode = false;

      /* Parse the proxy URL.  */
      proxy_url = url_parse (proxy, &up_error_code, pi, true);
      if (!proxy_url)
        {
          char *error = url_error (proxy, up_error_code);
          logprintf (LOG_NOTQUIET, _(""Error parsing proxy URL %s: %s.\n""),
                     proxy, error);
          xfree (url);
          xfree (error);
          xfree (proxy);
          iri_free (pi);
          RESTORE_METHOD;
          result = PROXERR;
          goto bail;
        }
      if (proxy_url->scheme != SCHEME_HTTP && proxy_url->scheme != u->scheme)
        {
          logprintf (LOG_NOTQUIET, _(""Error in proxy URL %s: Must be HTTP.\n""), proxy);
          url_free (proxy_url);
          xfree (url);
          xfree (proxy);
          iri_free (pi);
          RESTORE_METHOD;
          result = PROXERR;
          goto bail;
        }
      iri_free(pi);
      xfree (proxy);
    }

  if (u->scheme == SCHEME_HTTP
#ifdef HAVE_SSL
      || u->scheme == SCHEME_HTTPS
#endif
      || (proxy_url && proxy_url->scheme == SCHEME_HTTP))
    {
#ifdef HAVE_HSTS
#ifdef TESTING
      /* we don't link against main.o when we're testing */
      hsts_store_t hsts_store = NULL;
#else
      extern hsts_store_t hsts_store;
#endif

      if (opt.hsts && hsts_store)
	{
	  if (hsts_match (hsts_store, u))
	    logprintf (LOG_VERBOSE, ""URL transformed to HTTPS due to an HSTS policy\n"");
	}
#endif
      result = http_loop (u, orig_parsed, &mynewloc, &local_file, refurl, dt,
                          proxy_url, iri);
    }
  else if (u->scheme == SCHEME_FTP
#ifdef HAVE_SSL
      || u->scheme == SCHEME_FTPS
#endif
      )
    {
      /* If this is a redirection, temporarily turn off opt.ftp_glob
         and opt.recursive, both being undesirable when following
         redirects.  */
      bool oldrec = recursive, glob = opt.ftp_glob;
       if (redirection_count)
         oldrec = glob = false;
 
      result = ftp_loop (u, &local_file, dt, proxy_url, recursive, glob);
       recursive = oldrec;
 
       /* There is a possibility of having HTTP being redirected to
         according to the suffix.  The HTML suffixes are `.html',
         `.htm' and a few others, case-insensitive.  */
      if (redirection_count && local_file && (u->scheme == SCHEME_FTP
#ifdef HAVE_SSL
          || u->scheme == SCHEME_FTPS
#endif
          ))
        {
          if (has_html_suffix_p (local_file))
            *dt |= TEXTHTML;
        }
    }

  if (proxy_url)
    {
      url_free (proxy_url);
      proxy_url = NULL;
    }

  location_changed = (result == NEWLOCATION || result == NEWLOCATION_KEEP_POST);
  if (location_changed)
    {
      char *construced_newloc;
      struct url *newloc_parsed;

      assert (mynewloc != NULL);

      xfree (local_file);

      /* The HTTP specs only allow absolute URLs to appear in
         redirects, but a ton of boneheaded webservers and CGIs out
         there break the rules and use relative URLs, and popular
         browsers are lenient about this, so wget should be too. */
      construced_newloc = uri_merge (url, mynewloc);
      xfree (mynewloc);
      mynewloc = construced_newloc;

#ifdef ENABLE_IRI
      /* Reset UTF-8 encoding state, set the URI encoding and reset
         the content encoding. */
      iri->utf8_encode = opt.enable_iri;
      if (opt.encoding_remote)
       set_uri_encoding (iri, opt.encoding_remote, true);
      set_content_encoding (iri, NULL);
      xfree (iri->orig_url);
#endif

      /* Now, see if this new location makes sense. */
      newloc_parsed = url_parse (mynewloc, &up_error_code, iri, true);
      if (!newloc_parsed)
        {
          char *error = url_error (mynewloc, up_error_code);
          logprintf (LOG_NOTQUIET, ""%s: %s.\n"", escnonprint_uri (mynewloc),
                     error);
          if (orig_parsed != u)
            {
              url_free (u);
            }
          xfree (url);
          xfree (mynewloc);
          xfree (error);
          RESTORE_METHOD;
          goto bail;
        }

      /* Now mynewloc will become newloc_parsed->url, because if the
         Location contained relative paths like .././something, we
         don't want that propagating as url.  */
      xfree (mynewloc);
      mynewloc = xstrdup (newloc_parsed->url);

      /* Check for max. number of redirections.  */
      if (++redirection_count > opt.max_redirect)
        {
          logprintf (LOG_NOTQUIET, _(""%d redirections exceeded.\n""),
                     opt.max_redirect);
          url_free (newloc_parsed);
          if (orig_parsed != u)
            {
              url_free (u);
            }
          xfree (url);
          xfree (mynewloc);
          RESTORE_METHOD;
          result = WRONGCODE;
          goto bail;
        }

      xfree (url);
      url = mynewloc;
      if (orig_parsed != u)
        {
          url_free (u);
        }
      u = newloc_parsed;

      /* If we're being redirected from POST, and we received a
         redirect code different than 307, we don't want to POST
         again.  Many requests answer POST with a redirection to an
         index page; that redirection is clearly a GET.  We ""suspend""
         POST data for the duration of the redirections, and restore
         it when we're done.

         RFC2616 HTTP/1.1 introduces code 307 Temporary Redirect
         specifically to preserve the method of the request.
     */
      if (result != NEWLOCATION_KEEP_POST && !method_suspended)
        SUSPEND_METHOD;

      goto redirected;
    }
  else
    {
      xfree(mynewloc);
    }

  /* Try to not encode in UTF-8 if fetching failed */
  if (!(*dt & RETROKF) && iri->utf8_encode)
    {
      iri->utf8_encode = false;
      if (orig_parsed != u)
        {
          url_free (u);
        }
      u = url_parse (origurl, NULL, iri, true);
      if (u)
        {
          DEBUGP ((""[IRI fallbacking to non-utf8 for %s\n"", quote (url)));
          xfree (url);
          url = xstrdup (u->url);
          iri_fallbacked = 1;
          goto redirected;
        }
      else
          DEBUGP ((""[Couldn't fallback to non-utf8 for %s\n"", quote (url)));
    }

  if (local_file && u && (*dt & RETROKF || opt.content_on_error))
    {
      register_download (u->url, local_file);

      if (!opt.spider && redirection_count && 0 != strcmp (origurl, u->url))
        register_redirection (origurl, u->url);

      if (*dt & TEXTHTML)
        register_html (local_file);

      if (*dt & TEXTCSS)
        register_css (local_file);
    }

  if (file)
    *file = local_file ? local_file : NULL;
  else
    xfree (local_file);

  if (orig_parsed != u)
    {
      url_free (u);
    }

  if (redirection_count || iri_fallbacked)
    {
      if (newloc)
        *newloc = url;
      else
        xfree (url);
    }
  else
    {
      if (newloc)
        *newloc = NULL;
      xfree (url);
    }

  RESTORE_METHOD;

bail:
  if (register_status)
    inform_exit_status (result);

  return result;
}
",C,"      result = ftp_loop (u, orig_parsed, &local_file, dt, proxy_url,
                         recursive, glob);
","      result = ftp_loop (u, &local_file, dt, proxy_url, recursive, glob);
",2bdfc4f521047514a74c18ecd271679ca61b0a26,"@@ -830,7 +830,8 @@ retrieve_url (struct url * orig_parsed, const char *origurl, char **file,
       if (redirection_count)
         oldrec = glob = false;
 
-      result = ftp_loop (u, &local_file, dt, proxy_url, recursive, glob);
+      result = ftp_loop (u, orig_parsed, &local_file, dt, proxy_url,
+                         recursive, glob);
       recursive = oldrec;
 
       /* There is a possibility of having HTTP being redirected to",savannah,https://git.savannah.gnu.org/cgit/wget.git/tree/src/retr.c?id=e996e322ffd42aaa051602da182d03178d0f13e1,https://git.savannah.gnu.org/cgit/wget.git/tree/src/retr.c?id=2bdfc4f521047514a74c18ecd271679ca61b0a26,1,"retrieve_url (struct url * orig_parsed, const char *origurl, char **file,
              char **newloc, const char *refurl, int *dt, bool recursive,
              struct iri *iri, bool register_status)
{
  uerr_t result;
  char *url;
  bool location_changed;
  bool iri_fallbacked = 0;
  int dummy;
  char *mynewloc, *proxy;
  struct url *u = orig_parsed, *proxy_url;
  int up_error_code;            /* url parse error code */
  char *local_file = NULL;
  int redirection_count = 0;

  bool method_suspended = false;
  char *saved_body_data = NULL;
  char *saved_method = NULL;
  char *saved_body_file_name = NULL;

  /* If dt is NULL, use local storage.  */
  if (!dt)
    {
      dt = &dummy;
      dummy = 0;
    }
  url = xstrdup (origurl);
  if (newloc)
    *newloc = NULL;
  if (file)
    *file = NULL;

  if (!refurl)
    refurl = opt.referer;

 redirected:
  /* (also for IRI fallbacking) */

  result = NOCONERROR;
  mynewloc = NULL;
  xfree(local_file);
  proxy_url = NULL;

  proxy = getproxy (u);
  if (proxy)
    {
      struct iri *pi = iri_new ();
      set_uri_encoding (pi, opt.locale, true);
      pi->utf8_encode = false;

      /* Parse the proxy URL.  */
      proxy_url = url_parse (proxy, &up_error_code, pi, true);
      if (!proxy_url)
        {
          char *error = url_error (proxy, up_error_code);
          logprintf (LOG_NOTQUIET, _(""Error parsing proxy URL %s: %s.\n""),
                     proxy, error);
          xfree (url);
          xfree (error);
          xfree (proxy);
          iri_free (pi);
          RESTORE_METHOD;
          result = PROXERR;
          goto bail;
        }
      if (proxy_url->scheme != SCHEME_HTTP && proxy_url->scheme != u->scheme)
        {
          logprintf (LOG_NOTQUIET, _(""Error in proxy URL %s: Must be HTTP.\n""), proxy);
          url_free (proxy_url);
          xfree (url);
          xfree (proxy);
          iri_free (pi);
          RESTORE_METHOD;
          result = PROXERR;
          goto bail;
        }
      iri_free(pi);
      xfree (proxy);
    }

  if (u->scheme == SCHEME_HTTP
#ifdef HAVE_SSL
      || u->scheme == SCHEME_HTTPS
#endif
      || (proxy_url && proxy_url->scheme == SCHEME_HTTP))
    {
#ifdef HAVE_HSTS
#ifdef TESTING
      /* we don't link against main.o when we're testing */
      hsts_store_t hsts_store = NULL;
#else
      extern hsts_store_t hsts_store;
#endif

      if (opt.hsts && hsts_store)
	{
	  if (hsts_match (hsts_store, u))
	    logprintf (LOG_VERBOSE, ""URL transformed to HTTPS due to an HSTS policy\n"");
	}
#endif
      result = http_loop (u, orig_parsed, &mynewloc, &local_file, refurl, dt,
                          proxy_url, iri);
    }
  else if (u->scheme == SCHEME_FTP
#ifdef HAVE_SSL
      || u->scheme == SCHEME_FTPS
#endif
      )
    {
      /* If this is a redirection, temporarily turn off opt.ftp_glob
         and opt.recursive, both being undesirable when following
         redirects.  */
      bool oldrec = recursive, glob = opt.ftp_glob;
       if (redirection_count)
         oldrec = glob = false;
 
//flaw_line_below:
      result = ftp_loop (u, &local_file, dt, proxy_url, recursive, glob);
//fix_flaw_line_below:
//      result = ftp_loop (u, orig_parsed, &local_file, dt, proxy_url,
//fix_flaw_line_below:
//                         recursive, glob);
       recursive = oldrec;
 
       /* There is a possibility of having HTTP being redirected to
         according to the suffix.  The HTML suffixes are `.html',
         `.htm' and a few others, case-insensitive.  */
      if (redirection_count && local_file && (u->scheme == SCHEME_FTP
#ifdef HAVE_SSL
          || u->scheme == SCHEME_FTPS
#endif
          ))
        {
          if (has_html_suffix_p (local_file))
            *dt |= TEXTHTML;
        }
    }

  if (proxy_url)
    {
      url_free (proxy_url);
      proxy_url = NULL;
    }

  location_changed = (result == NEWLOCATION || result == NEWLOCATION_KEEP_POST);
  if (location_changed)
    {
      char *construced_newloc;
      struct url *newloc_parsed;

      assert (mynewloc != NULL);

      xfree (local_file);

      /* The HTTP specs only allow absolute URLs to appear in
         redirects, but a ton of boneheaded webservers and CGIs out
         there break the rules and use relative URLs, and popular
         browsers are lenient about this, so wget should be too. */
      construced_newloc = uri_merge (url, mynewloc);
      xfree (mynewloc);
      mynewloc = construced_newloc;

#ifdef ENABLE_IRI
      /* Reset UTF-8 encoding state, set the URI encoding and reset
         the content encoding. */
      iri->utf8_encode = opt.enable_iri;
      if (opt.encoding_remote)
       set_uri_encoding (iri, opt.encoding_remote, true);
      set_content_encoding (iri, NULL);
      xfree (iri->orig_url);
#endif

      /* Now, see if this new location makes sense. */
      newloc_parsed = url_parse (mynewloc, &up_error_code, iri, true);
      if (!newloc_parsed)
        {
          char *error = url_error (mynewloc, up_error_code);
          logprintf (LOG_NOTQUIET, ""%s: %s.\n"", escnonprint_uri (mynewloc),
                     error);
          if (orig_parsed != u)
            {
              url_free (u);
            }
          xfree (url);
          xfree (mynewloc);
          xfree (error);
          RESTORE_METHOD;
          goto bail;
        }

      /* Now mynewloc will become newloc_parsed->url, because if the
         Location contained relative paths like .././something, we
         don't want that propagating as url.  */
      xfree (mynewloc);
      mynewloc = xstrdup (newloc_parsed->url);

      /* Check for max. number of redirections.  */
      if (++redirection_count > opt.max_redirect)
        {
          logprintf (LOG_NOTQUIET, _(""%d redirections exceeded.\n""),
                     opt.max_redirect);
          url_free (newloc_parsed);
          if (orig_parsed != u)
            {
              url_free (u);
            }
          xfree (url);
          xfree (mynewloc);
          RESTORE_METHOD;
          result = WRONGCODE;
          goto bail;
        }

      xfree (url);
      url = mynewloc;
      if (orig_parsed != u)
        {
          url_free (u);
        }
      u = newloc_parsed;

      /* If we're being redirected from POST, and we received a
         redirect code different than 307, we don't want to POST
         again.  Many requests answer POST with a redirection to an
         index page; that redirection is clearly a GET.  We ""suspend""
         POST data for the duration of the redirections, and restore
         it when we're done.

         RFC2616 HTTP/1.1 introduces code 307 Temporary Redirect
         specifically to preserve the method of the request.
     */
      if (result != NEWLOCATION_KEEP_POST && !method_suspended)
        SUSPEND_METHOD;

      goto redirected;
    }
  else
    {
      xfree(mynewloc);
    }

  /* Try to not encode in UTF-8 if fetching failed */
  if (!(*dt & RETROKF) && iri->utf8_encode)
    {
      iri->utf8_encode = false;
      if (orig_parsed != u)
        {
          url_free (u);
        }
      u = url_parse (origurl, NULL, iri, true);
      if (u)
        {
          DEBUGP ((""[IRI fallbacking to non-utf8 for %s\n"", quote (url)));
          xfree (url);
          url = xstrdup (u->url);
          iri_fallbacked = 1;
          goto redirected;
        }
      else
          DEBUGP ((""[Couldn't fallback to non-utf8 for %s\n"", quote (url)));
    }

  if (local_file && u && (*dt & RETROKF || opt.content_on_error))
    {
      register_download (u->url, local_file);

      if (!opt.spider && redirection_count && 0 != strcmp (origurl, u->url))
        register_redirection (origurl, u->url);

      if (*dt & TEXTHTML)
        register_html (local_file);

      if (*dt & TEXTCSS)
        register_css (local_file);
    }

  if (file)
    *file = local_file ? local_file : NULL;
  else
    xfree (local_file);

  if (orig_parsed != u)
    {
      url_free (u);
    }

  if (redirection_count || iri_fallbacked)
    {
      if (newloc)
        *newloc = url;
      else
        xfree (url);
    }
  else
    {
      if (newloc)
        *newloc = NULL;
      xfree (url);
    }

  RESTORE_METHOD;

bail:
  if (register_status)
    inform_exit_status (result);

  return result;
}
"
745,178481,,Remote,Not required,,CVE-2015-3412,https://www.cvedetails.com/cve/CVE-2015-3412/,CWE-254,Low,Partial,,,2016-05-16,5.0,"PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read arbitrary files via crafted input to an application that calls the stream_resolve_include_path function in ext/standard/streamsfuncs.c, as demonstrated by a filename\0.extension attack that bypasses an intended configuration in which client users may read files with only one specific extension.",2019-04-22,Bypass,4,https://git.php.net/?p=php-src.git;a=commit;h=4435b9142ff9813845d5c97ab29a5d637bedb257,4435b9142ff9813845d5c97ab29a5d637bedb257,,1,,,"static xmlDocPtr dom_document_parser(zval *id, int mode, char *source, int source_len, int options TSRMLS_DC) /* {{{ */
{
    xmlDocPtr ret;
    xmlParserCtxtPtr ctxt = NULL;
	dom_doc_propsptr doc_props;
	dom_object *intern;
	php_libxml_ref_obj *document = NULL;
	int validate, recover, resolve_externals, keep_blanks, substitute_ent;
	int resolved_path_len;
	int old_error_reporting = 0;
	char *directory=NULL, resolved_path[MAXPATHLEN];

	if (id != NULL) {
		intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);
		document = intern->document;
	}

	doc_props = dom_get_doc_props(document);
	validate = doc_props->validateonparse;
	resolve_externals = doc_props->resolveexternals;
	keep_blanks = doc_props->preservewhitespace;
	substitute_ent = doc_props->substituteentities;
	recover = doc_props->recover;

	if (document == NULL) {
		efree(doc_props);
	}

        xmlInitParser();
 
        if (mode == DOM_LOAD_FILE) {
               if (CHECK_NULL_PATH(source, source_len)) {
                       return NULL;
               }
                char *file_dest = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);
                if (file_dest) {
                        ctxt = xmlCreateFileParserCtxt(file_dest);
		ctxt = xmlCreateMemoryParserCtxt(source, source_len);
	}

	if (ctxt == NULL) {
		return(NULL);
	}

	/* If loading from memory, we need to set the base directory for the document */
	if (mode != DOM_LOAD_FILE) {
#if HAVE_GETCWD
		directory = VCWD_GETCWD(resolved_path, MAXPATHLEN);
#elif HAVE_GETWD
		directory = VCWD_GETWD(resolved_path);
#endif
		if (directory) {
			if(ctxt->directory != NULL) {
				xmlFree((char *) ctxt->directory);
			}
			resolved_path_len = strlen(resolved_path);
			if (resolved_path[resolved_path_len - 1] != DEFAULT_SLASH) {
				resolved_path[resolved_path_len] = DEFAULT_SLASH;
				resolved_path[++resolved_path_len] = '\0';
			}
			ctxt->directory = (char *) xmlCanonicPath((const xmlChar *) resolved_path);
		}
	}

	ctxt->vctxt.error = php_libxml_ctx_error;
	ctxt->vctxt.warning = php_libxml_ctx_warning;

	if (ctxt->sax != NULL) {
		ctxt->sax->error = php_libxml_ctx_error;
		ctxt->sax->warning = php_libxml_ctx_warning;
	}

	if (validate && ! (options & XML_PARSE_DTDVALID)) {
		options |= XML_PARSE_DTDVALID;
	}
	if (resolve_externals && ! (options & XML_PARSE_DTDATTR)) {
		options |= XML_PARSE_DTDATTR;
	}
	if (substitute_ent && ! (options & XML_PARSE_NOENT)) {
		options |= XML_PARSE_NOENT;
	}
	if (keep_blanks == 0 && ! (options & XML_PARSE_NOBLANKS)) {
		options |= XML_PARSE_NOBLANKS;
	}

	xmlCtxtUseOptions(ctxt, options);

	ctxt->recovery = recover;
	if (recover) {
		old_error_reporting = EG(error_reporting);
		EG(error_reporting) = old_error_reporting | E_WARNING;
	}

	xmlParseDocument(ctxt);

	if (ctxt->wellFormed || recover) {
		ret = ctxt->myDoc;
		if (ctxt->recovery) {
			EG(error_reporting) = old_error_reporting;
		}
		/* If loading from memory, set the base reference uri for the document */
		if (ret && ret->URL == NULL && ctxt->directory != NULL) {
			ret->URL = xmlStrdup(ctxt->directory);
		}
	} else {
		ret = NULL;
		xmlFreeDoc(ctxt->myDoc);
		ctxt->myDoc = NULL;
	}

	xmlFreeParserCtxt(ctxt);

	return(ret);
}
/* }}} */

/* {{{ static void dom_parse_document(INTERNAL_FUNCTION_PARAMETERS, int mode) */
static void dom_parse_document(INTERNAL_FUNCTION_PARAMETERS, int mode) {
	zval *id;
	xmlDoc *docp = NULL, *newdoc;
	dom_doc_propsptr doc_prop;
	dom_object *intern;
	char *source;
	int source_len, refcount, ret;
	long options = 0;

	id = getThis();
	if (id != NULL && ! instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) {
		id = NULL;
	}

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|l"", &source, &source_len, &options) == FAILURE) {
		return;
	}

	if (!source_len) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty string supplied as input"");
		RETURN_FALSE;
	}

	newdoc = dom_document_parser(id, mode, source, source_len, options TSRMLS_CC);

	if (!newdoc)
		RETURN_FALSE;

	if (id != NULL) {
		intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);
		if (intern != NULL) {
			docp = (xmlDocPtr) dom_object_get_node(intern);
			doc_prop = NULL;
			if (docp != NULL) {
				php_libxml_decrement_node_ptr((php_libxml_node_object *) intern TSRMLS_CC);
				doc_prop = intern->document->doc_props;
				intern->document->doc_props = NULL;
				refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern TSRMLS_CC);
				if (refcount != 0) {
					docp->_private = NULL;
				}
			}
			intern->document = NULL;
			if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, newdoc TSRMLS_CC) == -1) {
				RETURN_FALSE;
			}
			intern->document->doc_props = doc_prop;
		}

		php_libxml_increment_node_ptr((php_libxml_node_object *)intern, (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC);

		RETURN_TRUE;
	} else {
		DOM_RET_OBJ((xmlNodePtr) newdoc, &ret, NULL);
	}
}
/* }}} end dom_parser_document */

/* {{{ proto DOMNode dom_document_load(string source [, int options]);
URL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-load
Since: DOM Level 3
*/
PHP_METHOD(domdocument, load)
{
	dom_parse_document(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_FILE);
}
/* }}} end dom_document_load */

/* {{{ proto DOMNode dom_document_loadxml(string source [, int options]);
URL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-loadXML
Since: DOM Level 3
*/
PHP_METHOD(domdocument, loadXML)
{
	dom_parse_document(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_STRING);
}
/* }}} end dom_document_loadxml */

/* {{{ proto int dom_document_save(string file);
Convenience method to save to file
*/
PHP_FUNCTION(dom_document_save)
{
	zval *id;
	xmlDoc *docp;
	int file_len = 0, bytes, format, saveempty = 0;
	dom_object *intern;
	dom_doc_propsptr doc_props;
	char *file;
	long options = 0;

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""Os|l"", &id, dom_document_class_entry, &file, &file_len, &options) == FAILURE) {
		return;
	}

	if (file_len == 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid Filename"");
		RETURN_FALSE;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	/* encoding handled by property on doc */

	doc_props = dom_get_doc_props(intern->document);
	format = doc_props->formatoutput;
	if (options & LIBXML_SAVE_NOEMPTYTAG) {
		saveempty = xmlSaveNoEmptyTags;
		xmlSaveNoEmptyTags = 1;
	}
	bytes = xmlSaveFormatFileEnc(file, docp, NULL, format);
	if (options & LIBXML_SAVE_NOEMPTYTAG) {
		xmlSaveNoEmptyTags = saveempty;
	}
	if (bytes == -1) {
		RETURN_FALSE;
	}
	RETURN_LONG(bytes);
}
/* }}} end dom_document_save */

/* {{{ proto string dom_document_savexml([node n]);
URL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-saveXML
Since: DOM Level 3
*/
PHP_FUNCTION(dom_document_savexml)
{
	zval *id, *nodep = NULL;
	xmlDoc *docp;
	xmlNode *node;
	xmlBufferPtr buf;
	xmlChar *mem;
	dom_object *intern, *nodeobj;
	dom_doc_propsptr doc_props;
	int size, format, saveempty = 0;
	long options = 0;

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""O|O!l"", &id, dom_document_class_entry, &nodep, dom_node_class_entry, &options) == FAILURE) {
		return;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	doc_props = dom_get_doc_props(intern->document);
	format = doc_props->formatoutput;

	if (nodep != NULL) {
		/* Dump contents of Node */
		DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
		if (node->doc != docp) {
			php_dom_throw_error(WRONG_DOCUMENT_ERR, dom_get_strict_error(intern->document) TSRMLS_CC);
			RETURN_FALSE;
		}
		buf = xmlBufferCreate();
		if (!buf) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Could not fetch buffer"");
			RETURN_FALSE;
		}
		if (options & LIBXML_SAVE_NOEMPTYTAG) {
			saveempty = xmlSaveNoEmptyTags;
			xmlSaveNoEmptyTags = 1;
		}
		xmlNodeDump(buf, docp, node, 0, format);
		if (options & LIBXML_SAVE_NOEMPTYTAG) {
			xmlSaveNoEmptyTags = saveempty;
		}
		mem = (xmlChar*) xmlBufferContent(buf);
		if (!mem) {
			xmlBufferFree(buf);
			RETURN_FALSE;
		}
		RETVAL_STRING(mem, 1);
		xmlBufferFree(buf);
	} else {
		if (options & LIBXML_SAVE_NOEMPTYTAG) {
			saveempty = xmlSaveNoEmptyTags;
			xmlSaveNoEmptyTags = 1;
		}
		/* Encoding is handled from the encoding property set on the document */
		xmlDocDumpFormatMemory(docp, &mem, &size, format);
		if (options & LIBXML_SAVE_NOEMPTYTAG) {
			xmlSaveNoEmptyTags = saveempty;
		}
		if (!size) {
			RETURN_FALSE;
		}
		RETVAL_STRINGL(mem, size, 1);
		xmlFree(mem);
	}
}
/* }}} end dom_document_savexml */

static xmlNodePtr php_dom_free_xinclude_node(xmlNodePtr cur TSRMLS_DC) /* {{{ */
{
	xmlNodePtr xincnode;

	xincnode = cur;
	cur = cur->next;
	xmlUnlinkNode(xincnode);
	php_libxml_node_free_resource(xincnode TSRMLS_CC);

	return cur;
}
/* }}} */

static void php_dom_remove_xinclude_nodes(xmlNodePtr cur TSRMLS_DC) /* {{{ */
{
	while(cur) {
		if (cur->type == XML_XINCLUDE_START) {
			cur = php_dom_free_xinclude_node(cur TSRMLS_CC);

			/* XML_XINCLUDE_END node will be a sibling of XML_XINCLUDE_START */
			while(cur && cur->type != XML_XINCLUDE_END) {
				/* remove xinclude processing nodes from recursive xincludes */
				if (cur->type == XML_ELEMENT_NODE) {
					   php_dom_remove_xinclude_nodes(cur->children TSRMLS_CC);
				}
				cur = cur->next;
			}

			if (cur && cur->type == XML_XINCLUDE_END) {
				cur = php_dom_free_xinclude_node(cur TSRMLS_CC);
			}
		} else {
			if (cur->type == XML_ELEMENT_NODE) {
				php_dom_remove_xinclude_nodes(cur->children TSRMLS_CC);
			}
			cur = cur->next;
		}
	}
}
/* }}} */

/* {{{ proto int dom_document_xinclude([int options])
   Substitutues xincludes in a DomDocument */
PHP_FUNCTION(dom_document_xinclude)
{
	zval *id;
	xmlDoc *docp;
	xmlNodePtr root;
	long flags = 0; 
	int err;
	dom_object *intern;

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""O|l"", &id, dom_document_class_entry, &flags) == FAILURE) {
		return;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	err = xmlXIncludeProcessFlags(docp, flags);

	/* XML_XINCLUDE_START and XML_XINCLUDE_END nodes need to be removed as these
	are added via xmlXIncludeProcess to mark beginning and ending of xincluded document 
	but are not wanted in resulting document - must be done even if err as it could fail after
	having processed some xincludes */
	root = (xmlNodePtr) docp->children;
	while(root && root->type != XML_ELEMENT_NODE && root->type != XML_XINCLUDE_START) {
		root = root->next;
	}
	if (root) {
		php_dom_remove_xinclude_nodes(root TSRMLS_CC);
	}

	if (err) {
		RETVAL_LONG(err);
	} else {
		RETVAL_FALSE;
	}
    
}
/* }}} */

/* {{{ proto boolean dom_document_validate();
Since: DOM extended
*/
PHP_FUNCTION(dom_document_validate)
{
	zval *id;
	xmlDoc *docp;
	dom_object *intern;
	xmlValidCtxt *cvp;

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""O"", &id, dom_document_class_entry) == FAILURE) {
		return;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	cvp = xmlNewValidCtxt();
	
	cvp->userData = NULL;
	cvp->error    = (xmlValidityErrorFunc) php_libxml_error_handler;
	cvp->warning  = (xmlValidityErrorFunc) php_libxml_error_handler;
	
	if (xmlValidateDocument(cvp, docp)) {
		RETVAL_TRUE;
	} else {
		RETVAL_FALSE;
	}
	
	xmlFreeValidCtxt(cvp);
	
}
/* }}} */

#if defined(LIBXML_SCHEMAS_ENABLED)
static void _dom_document_schema_validate(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */
{
	zval *id;
	xmlDoc *docp;
	dom_object *intern;
	char *source = NULL, *valid_file = NULL;
	int source_len = 0;
	xmlSchemaParserCtxtPtr  parser;
	xmlSchemaPtr            sptr;
	xmlSchemaValidCtxtPtr   vptr;
	int                     is_valid;
	char resolved_path[MAXPATHLEN + 1];

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""Op"", &id, dom_document_class_entry, &source, &source_len) == FAILURE) {
		return;
	}

	if (source_len == 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid Schema source"");
		RETURN_FALSE;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	switch (type) {
	case DOM_LOAD_FILE:
		valid_file = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);
		if (!valid_file) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid Schema file source"");
			RETURN_FALSE;
		}
		parser = xmlSchemaNewParserCtxt(valid_file);
		break;
	case DOM_LOAD_STRING:
		parser = xmlSchemaNewMemParserCtxt(source, source_len);
		/* If loading from memory, we need to set the base directory for the document 
		   but it is not apparent how to do that for schema's */
		break;
	default:
		return;
	}

	xmlSchemaSetParserErrors(parser,
		(xmlSchemaValidityErrorFunc) php_libxml_error_handler,
		(xmlSchemaValidityWarningFunc) php_libxml_error_handler,
		parser);
	sptr = xmlSchemaParse(parser);
	xmlSchemaFreeParserCtxt(parser);
	if (!sptr) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid Schema"");
		RETURN_FALSE;
	}

	docp = (xmlDocPtr) dom_object_get_node(intern);

	vptr = xmlSchemaNewValidCtxt(sptr);
	if (!vptr) {
		xmlSchemaFree(sptr);
		php_error(E_ERROR, ""Invalid Schema Validation Context"");
		RETURN_FALSE;
	}

	xmlSchemaSetValidErrors(vptr, php_libxml_error_handler, php_libxml_error_handler, vptr);
	is_valid = xmlSchemaValidateDoc(vptr, docp);
	xmlSchemaFree(sptr);
	xmlSchemaFreeValidCtxt(vptr);

	if (is_valid == 0) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}
}
/* }}} */

/* {{{ proto boolean dom_document_schema_validate_file(string filename); */
PHP_FUNCTION(dom_document_schema_validate_file)
{
	_dom_document_schema_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_FILE);
}
/* }}} end dom_document_schema_validate_file */

/* {{{ proto boolean dom_document_schema_validate(string source); */
PHP_FUNCTION(dom_document_schema_validate_xml)
{
	_dom_document_schema_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_STRING);
}
/* }}} end dom_document_schema_validate */

static void _dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */
{
	zval *id;
	xmlDoc *docp;
	dom_object *intern;
	char *source = NULL, *valid_file = NULL;
	int source_len = 0;
	xmlRelaxNGParserCtxtPtr parser;
	xmlRelaxNGPtr           sptr;
	xmlRelaxNGValidCtxtPtr  vptr;
	int                     is_valid;
	char resolved_path[MAXPATHLEN + 1];

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""Op"", &id, dom_document_class_entry, &source, &source_len) == FAILURE) {
		return;
	}

	if (source_len == 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid Schema source"");
		RETURN_FALSE;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	switch (type) {
	case DOM_LOAD_FILE:
		valid_file = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);
		if (!valid_file) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid RelaxNG file source"");
			RETURN_FALSE;
		}
		parser = xmlRelaxNGNewParserCtxt(valid_file);
		break;
	case DOM_LOAD_STRING:
		parser = xmlRelaxNGNewMemParserCtxt(source, source_len);
		/* If loading from memory, we need to set the base directory for the document 
		   but it is not apparent how to do that for schema's */
		break;
	default:
		return;
	}

	xmlRelaxNGSetParserErrors(parser,
		(xmlRelaxNGValidityErrorFunc) php_libxml_error_handler,
		(xmlRelaxNGValidityWarningFunc) php_libxml_error_handler,
		parser);
	sptr = xmlRelaxNGParse(parser);
	xmlRelaxNGFreeParserCtxt(parser);
	if (!sptr) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid RelaxNG"");
		RETURN_FALSE;
	}

	docp = (xmlDocPtr) dom_object_get_node(intern);

	vptr = xmlRelaxNGNewValidCtxt(sptr);
	if (!vptr) {
		xmlRelaxNGFree(sptr);
		php_error(E_ERROR, ""Invalid RelaxNG Validation Context"");
		RETURN_FALSE;
	}

	xmlRelaxNGSetValidErrors(vptr, php_libxml_error_handler, php_libxml_error_handler, vptr);
	is_valid = xmlRelaxNGValidateDoc(vptr, docp);
	xmlRelaxNGFree(sptr);
	xmlRelaxNGFreeValidCtxt(vptr);

	if (is_valid == 0) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}
}
/* }}} */

/* {{{ proto boolean dom_document_relaxNG_validate_file(string filename); */
PHP_FUNCTION(dom_document_relaxNG_validate_file)
{
	_dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_FILE);
}
/* }}} end dom_document_relaxNG_validate_file */

/* {{{ proto boolean dom_document_relaxNG_validate_xml(string source); */
PHP_FUNCTION(dom_document_relaxNG_validate_xml)
{
	_dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_STRING);
}
/* }}} end dom_document_relaxNG_validate_xml */

#endif

#if defined(LIBXML_HTML_ENABLED)

static void dom_load_html(INTERNAL_FUNCTION_PARAMETERS, int mode) /* {{{ */
{
	zval *id;
	xmlDoc *docp = NULL, *newdoc;
	dom_object *intern;
	dom_doc_propsptr doc_prop;
	char *source;
	int source_len, refcount, ret;
	long options = 0;
	htmlParserCtxtPtr ctxt;
	
	id = getThis();

        
        id = getThis();
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|l"", &source, &source_len, &options) == FAILURE) {
                return;
        }
	}

	if (mode == DOM_LOAD_FILE) {
		ctxt = htmlCreateFileParserCtxt(source, NULL);
	} else {
		source_len = xmlStrlen(source);
		ctxt = htmlCreateMemoryParserCtxt(source, source_len);
	}

	if (!ctxt) {
		RETURN_FALSE;
	}

	if (options) {
		htmlCtxtUseOptions(ctxt, options);
	}

	ctxt->vctxt.error = php_libxml_ctx_error;
	ctxt->vctxt.warning = php_libxml_ctx_warning;
	if (ctxt->sax != NULL) {
		ctxt->sax->error = php_libxml_ctx_error;
		ctxt->sax->warning = php_libxml_ctx_warning;
	}
	htmlParseDocument(ctxt);
	newdoc = ctxt->myDoc;
	htmlFreeParserCtxt(ctxt);
	
	if (!newdoc)
		RETURN_FALSE;

	if (id != NULL && instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) {
		intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);
		if (intern != NULL) {
			docp = (xmlDocPtr) dom_object_get_node(intern);
			doc_prop = NULL;
			if (docp != NULL) {
				php_libxml_decrement_node_ptr((php_libxml_node_object *) intern TSRMLS_CC);
				doc_prop = intern->document->doc_props;
				intern->document->doc_props = NULL;
				refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern TSRMLS_CC);
				if (refcount != 0) {
					docp->_private = NULL;
				}
			}
			intern->document = NULL;
			if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, newdoc TSRMLS_CC) == -1) {
				RETURN_FALSE;
			}
			intern->document->doc_props = doc_prop;
		}

		php_libxml_increment_node_ptr((php_libxml_node_object *)intern, (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC);

		RETURN_TRUE;
	} else {
		DOM_RET_OBJ((xmlNodePtr) newdoc, &ret, NULL);
	}
}
/* }}} */
","static xmlDocPtr dom_document_parser(zval *id, int mode, char *source, int source_len, int options TSRMLS_DC) /* {{{ */
{
    xmlDocPtr ret;
    xmlParserCtxtPtr ctxt = NULL;
	dom_doc_propsptr doc_props;
	dom_object *intern;
	php_libxml_ref_obj *document = NULL;
	int validate, recover, resolve_externals, keep_blanks, substitute_ent;
	int resolved_path_len;
	int old_error_reporting = 0;
	char *directory=NULL, resolved_path[MAXPATHLEN];

	if (id != NULL) {
		intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);
		document = intern->document;
	}

	doc_props = dom_get_doc_props(document);
	validate = doc_props->validateonparse;
	resolve_externals = doc_props->resolveexternals;
	keep_blanks = doc_props->preservewhitespace;
	substitute_ent = doc_props->substituteentities;
	recover = doc_props->recover;

	if (document == NULL) {
		efree(doc_props);
	}

        xmlInitParser();
 
        if (mode == DOM_LOAD_FILE) {
                char *file_dest = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);
                if (file_dest) {
                        ctxt = xmlCreateFileParserCtxt(file_dest);
		ctxt = xmlCreateMemoryParserCtxt(source, source_len);
	}

	if (ctxt == NULL) {
		return(NULL);
	}

	/* If loading from memory, we need to set the base directory for the document */
	if (mode != DOM_LOAD_FILE) {
#if HAVE_GETCWD
		directory = VCWD_GETCWD(resolved_path, MAXPATHLEN);
#elif HAVE_GETWD
		directory = VCWD_GETWD(resolved_path);
#endif
		if (directory) {
			if(ctxt->directory != NULL) {
				xmlFree((char *) ctxt->directory);
			}
			resolved_path_len = strlen(resolved_path);
			if (resolved_path[resolved_path_len - 1] != DEFAULT_SLASH) {
				resolved_path[resolved_path_len] = DEFAULT_SLASH;
				resolved_path[++resolved_path_len] = '\0';
			}
			ctxt->directory = (char *) xmlCanonicPath((const xmlChar *) resolved_path);
		}
	}

	ctxt->vctxt.error = php_libxml_ctx_error;
	ctxt->vctxt.warning = php_libxml_ctx_warning;

	if (ctxt->sax != NULL) {
		ctxt->sax->error = php_libxml_ctx_error;
		ctxt->sax->warning = php_libxml_ctx_warning;
	}

	if (validate && ! (options & XML_PARSE_DTDVALID)) {
		options |= XML_PARSE_DTDVALID;
	}
	if (resolve_externals && ! (options & XML_PARSE_DTDATTR)) {
		options |= XML_PARSE_DTDATTR;
	}
	if (substitute_ent && ! (options & XML_PARSE_NOENT)) {
		options |= XML_PARSE_NOENT;
	}
	if (keep_blanks == 0 && ! (options & XML_PARSE_NOBLANKS)) {
		options |= XML_PARSE_NOBLANKS;
	}

	xmlCtxtUseOptions(ctxt, options);

	ctxt->recovery = recover;
	if (recover) {
		old_error_reporting = EG(error_reporting);
		EG(error_reporting) = old_error_reporting | E_WARNING;
	}

	xmlParseDocument(ctxt);

	if (ctxt->wellFormed || recover) {
		ret = ctxt->myDoc;
		if (ctxt->recovery) {
			EG(error_reporting) = old_error_reporting;
		}
		/* If loading from memory, set the base reference uri for the document */
		if (ret && ret->URL == NULL && ctxt->directory != NULL) {
			ret->URL = xmlStrdup(ctxt->directory);
		}
	} else {
		ret = NULL;
		xmlFreeDoc(ctxt->myDoc);
		ctxt->myDoc = NULL;
	}

	xmlFreeParserCtxt(ctxt);

	return(ret);
}
/* }}} */

/* {{{ static void dom_parse_document(INTERNAL_FUNCTION_PARAMETERS, int mode) */
static void dom_parse_document(INTERNAL_FUNCTION_PARAMETERS, int mode) {
	zval *id;
	xmlDoc *docp = NULL, *newdoc;
	dom_doc_propsptr doc_prop;
	dom_object *intern;
	char *source;
	int source_len, refcount, ret;
	long options = 0;

	id = getThis();
	if (id != NULL && ! instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) {
		id = NULL;
	}

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|l"", &source, &source_len, &options) == FAILURE) {
		return;
	}

	if (!source_len) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty string supplied as input"");
		RETURN_FALSE;
	}

	newdoc = dom_document_parser(id, mode, source, source_len, options TSRMLS_CC);

	if (!newdoc)
		RETURN_FALSE;

	if (id != NULL) {
		intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);
		if (intern != NULL) {
			docp = (xmlDocPtr) dom_object_get_node(intern);
			doc_prop = NULL;
			if (docp != NULL) {
				php_libxml_decrement_node_ptr((php_libxml_node_object *) intern TSRMLS_CC);
				doc_prop = intern->document->doc_props;
				intern->document->doc_props = NULL;
				refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern TSRMLS_CC);
				if (refcount != 0) {
					docp->_private = NULL;
				}
			}
			intern->document = NULL;
			if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, newdoc TSRMLS_CC) == -1) {
				RETURN_FALSE;
			}
			intern->document->doc_props = doc_prop;
		}

		php_libxml_increment_node_ptr((php_libxml_node_object *)intern, (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC);

		RETURN_TRUE;
	} else {
		DOM_RET_OBJ((xmlNodePtr) newdoc, &ret, NULL);
	}
}
/* }}} end dom_parser_document */

/* {{{ proto DOMNode dom_document_load(string source [, int options]);
URL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-load
Since: DOM Level 3
*/
PHP_METHOD(domdocument, load)
{
	dom_parse_document(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_FILE);
}
/* }}} end dom_document_load */

/* {{{ proto DOMNode dom_document_loadxml(string source [, int options]);
URL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-loadXML
Since: DOM Level 3
*/
PHP_METHOD(domdocument, loadXML)
{
	dom_parse_document(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_STRING);
}
/* }}} end dom_document_loadxml */

/* {{{ proto int dom_document_save(string file);
Convenience method to save to file
*/
PHP_FUNCTION(dom_document_save)
{
	zval *id;
	xmlDoc *docp;
	int file_len = 0, bytes, format, saveempty = 0;
	dom_object *intern;
	dom_doc_propsptr doc_props;
	char *file;
	long options = 0;

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""Os|l"", &id, dom_document_class_entry, &file, &file_len, &options) == FAILURE) {
		return;
	}

	if (file_len == 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid Filename"");
		RETURN_FALSE;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	/* encoding handled by property on doc */

	doc_props = dom_get_doc_props(intern->document);
	format = doc_props->formatoutput;
	if (options & LIBXML_SAVE_NOEMPTYTAG) {
		saveempty = xmlSaveNoEmptyTags;
		xmlSaveNoEmptyTags = 1;
	}
	bytes = xmlSaveFormatFileEnc(file, docp, NULL, format);
	if (options & LIBXML_SAVE_NOEMPTYTAG) {
		xmlSaveNoEmptyTags = saveempty;
	}
	if (bytes == -1) {
		RETURN_FALSE;
	}
	RETURN_LONG(bytes);
}
/* }}} end dom_document_save */

/* {{{ proto string dom_document_savexml([node n]);
URL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-saveXML
Since: DOM Level 3
*/
PHP_FUNCTION(dom_document_savexml)
{
	zval *id, *nodep = NULL;
	xmlDoc *docp;
	xmlNode *node;
	xmlBufferPtr buf;
	xmlChar *mem;
	dom_object *intern, *nodeobj;
	dom_doc_propsptr doc_props;
	int size, format, saveempty = 0;
	long options = 0;

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""O|O!l"", &id, dom_document_class_entry, &nodep, dom_node_class_entry, &options) == FAILURE) {
		return;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	doc_props = dom_get_doc_props(intern->document);
	format = doc_props->formatoutput;

	if (nodep != NULL) {
		/* Dump contents of Node */
		DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
		if (node->doc != docp) {
			php_dom_throw_error(WRONG_DOCUMENT_ERR, dom_get_strict_error(intern->document) TSRMLS_CC);
			RETURN_FALSE;
		}
		buf = xmlBufferCreate();
		if (!buf) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Could not fetch buffer"");
			RETURN_FALSE;
		}
		if (options & LIBXML_SAVE_NOEMPTYTAG) {
			saveempty = xmlSaveNoEmptyTags;
			xmlSaveNoEmptyTags = 1;
		}
		xmlNodeDump(buf, docp, node, 0, format);
		if (options & LIBXML_SAVE_NOEMPTYTAG) {
			xmlSaveNoEmptyTags = saveempty;
		}
		mem = (xmlChar*) xmlBufferContent(buf);
		if (!mem) {
			xmlBufferFree(buf);
			RETURN_FALSE;
		}
		RETVAL_STRING(mem, 1);
		xmlBufferFree(buf);
	} else {
		if (options & LIBXML_SAVE_NOEMPTYTAG) {
			saveempty = xmlSaveNoEmptyTags;
			xmlSaveNoEmptyTags = 1;
		}
		/* Encoding is handled from the encoding property set on the document */
		xmlDocDumpFormatMemory(docp, &mem, &size, format);
		if (options & LIBXML_SAVE_NOEMPTYTAG) {
			xmlSaveNoEmptyTags = saveempty;
		}
		if (!size) {
			RETURN_FALSE;
		}
		RETVAL_STRINGL(mem, size, 1);
		xmlFree(mem);
	}
}
/* }}} end dom_document_savexml */

static xmlNodePtr php_dom_free_xinclude_node(xmlNodePtr cur TSRMLS_DC) /* {{{ */
{
	xmlNodePtr xincnode;

	xincnode = cur;
	cur = cur->next;
	xmlUnlinkNode(xincnode);
	php_libxml_node_free_resource(xincnode TSRMLS_CC);

	return cur;
}
/* }}} */

static void php_dom_remove_xinclude_nodes(xmlNodePtr cur TSRMLS_DC) /* {{{ */
{
	while(cur) {
		if (cur->type == XML_XINCLUDE_START) {
			cur = php_dom_free_xinclude_node(cur TSRMLS_CC);

			/* XML_XINCLUDE_END node will be a sibling of XML_XINCLUDE_START */
			while(cur && cur->type != XML_XINCLUDE_END) {
				/* remove xinclude processing nodes from recursive xincludes */
				if (cur->type == XML_ELEMENT_NODE) {
					   php_dom_remove_xinclude_nodes(cur->children TSRMLS_CC);
				}
				cur = cur->next;
			}

			if (cur && cur->type == XML_XINCLUDE_END) {
				cur = php_dom_free_xinclude_node(cur TSRMLS_CC);
			}
		} else {
			if (cur->type == XML_ELEMENT_NODE) {
				php_dom_remove_xinclude_nodes(cur->children TSRMLS_CC);
			}
			cur = cur->next;
		}
	}
}
/* }}} */

/* {{{ proto int dom_document_xinclude([int options])
   Substitutues xincludes in a DomDocument */
PHP_FUNCTION(dom_document_xinclude)
{
	zval *id;
	xmlDoc *docp;
	xmlNodePtr root;
	long flags = 0; 
	int err;
	dom_object *intern;

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""O|l"", &id, dom_document_class_entry, &flags) == FAILURE) {
		return;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	err = xmlXIncludeProcessFlags(docp, flags);

	/* XML_XINCLUDE_START and XML_XINCLUDE_END nodes need to be removed as these
	are added via xmlXIncludeProcess to mark beginning and ending of xincluded document 
	but are not wanted in resulting document - must be done even if err as it could fail after
	having processed some xincludes */
	root = (xmlNodePtr) docp->children;
	while(root && root->type != XML_ELEMENT_NODE && root->type != XML_XINCLUDE_START) {
		root = root->next;
	}
	if (root) {
		php_dom_remove_xinclude_nodes(root TSRMLS_CC);
	}

	if (err) {
		RETVAL_LONG(err);
	} else {
		RETVAL_FALSE;
	}
    
}
/* }}} */

/* {{{ proto boolean dom_document_validate();
Since: DOM extended
*/
PHP_FUNCTION(dom_document_validate)
{
	zval *id;
	xmlDoc *docp;
	dom_object *intern;
	xmlValidCtxt *cvp;

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""O"", &id, dom_document_class_entry) == FAILURE) {
		return;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	cvp = xmlNewValidCtxt();
	
	cvp->userData = NULL;
	cvp->error    = (xmlValidityErrorFunc) php_libxml_error_handler;
	cvp->warning  = (xmlValidityErrorFunc) php_libxml_error_handler;
	
	if (xmlValidateDocument(cvp, docp)) {
		RETVAL_TRUE;
	} else {
		RETVAL_FALSE;
	}
	
	xmlFreeValidCtxt(cvp);
	
}
/* }}} */

#if defined(LIBXML_SCHEMAS_ENABLED)
static void _dom_document_schema_validate(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */
{
	zval *id;
	xmlDoc *docp;
	dom_object *intern;
	char *source = NULL, *valid_file = NULL;
	int source_len = 0;
	xmlSchemaParserCtxtPtr  parser;
	xmlSchemaPtr            sptr;
	xmlSchemaValidCtxtPtr   vptr;
	int                     is_valid;
	char resolved_path[MAXPATHLEN + 1];

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""Op"", &id, dom_document_class_entry, &source, &source_len) == FAILURE) {
		return;
	}

	if (source_len == 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid Schema source"");
		RETURN_FALSE;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	switch (type) {
	case DOM_LOAD_FILE:
		valid_file = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);
		if (!valid_file) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid Schema file source"");
			RETURN_FALSE;
		}
		parser = xmlSchemaNewParserCtxt(valid_file);
		break;
	case DOM_LOAD_STRING:
		parser = xmlSchemaNewMemParserCtxt(source, source_len);
		/* If loading from memory, we need to set the base directory for the document 
		   but it is not apparent how to do that for schema's */
		break;
	default:
		return;
	}

	xmlSchemaSetParserErrors(parser,
		(xmlSchemaValidityErrorFunc) php_libxml_error_handler,
		(xmlSchemaValidityWarningFunc) php_libxml_error_handler,
		parser);
	sptr = xmlSchemaParse(parser);
	xmlSchemaFreeParserCtxt(parser);
	if (!sptr) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid Schema"");
		RETURN_FALSE;
	}

	docp = (xmlDocPtr) dom_object_get_node(intern);

	vptr = xmlSchemaNewValidCtxt(sptr);
	if (!vptr) {
		xmlSchemaFree(sptr);
		php_error(E_ERROR, ""Invalid Schema Validation Context"");
		RETURN_FALSE;
	}

	xmlSchemaSetValidErrors(vptr, php_libxml_error_handler, php_libxml_error_handler, vptr);
	is_valid = xmlSchemaValidateDoc(vptr, docp);
	xmlSchemaFree(sptr);
	xmlSchemaFreeValidCtxt(vptr);

	if (is_valid == 0) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}
}
/* }}} */

/* {{{ proto boolean dom_document_schema_validate_file(string filename); */
PHP_FUNCTION(dom_document_schema_validate_file)
{
	_dom_document_schema_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_FILE);
}
/* }}} end dom_document_schema_validate_file */

/* {{{ proto boolean dom_document_schema_validate(string source); */
PHP_FUNCTION(dom_document_schema_validate_xml)
{
	_dom_document_schema_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_STRING);
}
/* }}} end dom_document_schema_validate */

static void _dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */
{
	zval *id;
	xmlDoc *docp;
	dom_object *intern;
	char *source = NULL, *valid_file = NULL;
	int source_len = 0;
	xmlRelaxNGParserCtxtPtr parser;
	xmlRelaxNGPtr           sptr;
	xmlRelaxNGValidCtxtPtr  vptr;
	int                     is_valid;
	char resolved_path[MAXPATHLEN + 1];

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""Op"", &id, dom_document_class_entry, &source, &source_len) == FAILURE) {
		return;
	}

	if (source_len == 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid Schema source"");
		RETURN_FALSE;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	switch (type) {
	case DOM_LOAD_FILE:
		valid_file = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);
		if (!valid_file) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid RelaxNG file source"");
			RETURN_FALSE;
		}
		parser = xmlRelaxNGNewParserCtxt(valid_file);
		break;
	case DOM_LOAD_STRING:
		parser = xmlRelaxNGNewMemParserCtxt(source, source_len);
		/* If loading from memory, we need to set the base directory for the document 
		   but it is not apparent how to do that for schema's */
		break;
	default:
		return;
	}

	xmlRelaxNGSetParserErrors(parser,
		(xmlRelaxNGValidityErrorFunc) php_libxml_error_handler,
		(xmlRelaxNGValidityWarningFunc) php_libxml_error_handler,
		parser);
	sptr = xmlRelaxNGParse(parser);
	xmlRelaxNGFreeParserCtxt(parser);
	if (!sptr) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid RelaxNG"");
		RETURN_FALSE;
	}

	docp = (xmlDocPtr) dom_object_get_node(intern);

	vptr = xmlRelaxNGNewValidCtxt(sptr);
	if (!vptr) {
		xmlRelaxNGFree(sptr);
		php_error(E_ERROR, ""Invalid RelaxNG Validation Context"");
		RETURN_FALSE;
	}

	xmlRelaxNGSetValidErrors(vptr, php_libxml_error_handler, php_libxml_error_handler, vptr);
	is_valid = xmlRelaxNGValidateDoc(vptr, docp);
	xmlRelaxNGFree(sptr);
	xmlRelaxNGFreeValidCtxt(vptr);

	if (is_valid == 0) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}
}
/* }}} */

/* {{{ proto boolean dom_document_relaxNG_validate_file(string filename); */
PHP_FUNCTION(dom_document_relaxNG_validate_file)
{
	_dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_FILE);
}
/* }}} end dom_document_relaxNG_validate_file */

/* {{{ proto boolean dom_document_relaxNG_validate_xml(string source); */
PHP_FUNCTION(dom_document_relaxNG_validate_xml)
{
	_dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_STRING);
}
/* }}} end dom_document_relaxNG_validate_xml */

#endif

#if defined(LIBXML_HTML_ENABLED)

static void dom_load_html(INTERNAL_FUNCTION_PARAMETERS, int mode) /* {{{ */
{
	zval *id;
	xmlDoc *docp = NULL, *newdoc;
	dom_object *intern;
	dom_doc_propsptr doc_prop;
	char *source;
	int source_len, refcount, ret;
	long options = 0;
	htmlParserCtxtPtr ctxt;
	
	id = getThis();

        
        id = getThis();
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|l"", &source, &source_len, &options) == FAILURE) {
                return;
        }
	}

	if (mode == DOM_LOAD_FILE) {
		ctxt = htmlCreateFileParserCtxt(source, NULL);
	} else {
		source_len = xmlStrlen(source);
		ctxt = htmlCreateMemoryParserCtxt(source, source_len);
	}

	if (!ctxt) {
		RETURN_FALSE;
	}

	if (options) {
		htmlCtxtUseOptions(ctxt, options);
	}

	ctxt->vctxt.error = php_libxml_ctx_error;
	ctxt->vctxt.warning = php_libxml_ctx_warning;
	if (ctxt->sax != NULL) {
		ctxt->sax->error = php_libxml_ctx_error;
		ctxt->sax->warning = php_libxml_ctx_warning;
	}
	htmlParseDocument(ctxt);
	newdoc = ctxt->myDoc;
	htmlFreeParserCtxt(ctxt);
	
	if (!newdoc)
		RETURN_FALSE;

	if (id != NULL && instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) {
		intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);
		if (intern != NULL) {
			docp = (xmlDocPtr) dom_object_get_node(intern);
			doc_prop = NULL;
			if (docp != NULL) {
				php_libxml_decrement_node_ptr((php_libxml_node_object *) intern TSRMLS_CC);
				doc_prop = intern->document->doc_props;
				intern->document->doc_props = NULL;
				refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern TSRMLS_CC);
				if (refcount != 0) {
					docp->_private = NULL;
				}
			}
			intern->document = NULL;
			if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, newdoc TSRMLS_CC) == -1) {
				RETURN_FALSE;
			}
			intern->document->doc_props = doc_prop;
		}

		php_libxml_increment_node_ptr((php_libxml_node_object *)intern, (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC);

		RETURN_TRUE;
	} else {
		DOM_RET_OBJ((xmlNodePtr) newdoc, &ret, NULL);
	}
}
/* }}} */
",C,"               if (CHECK_NULL_PATH(source, source_len)) {
                       return NULL;
               }
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|l"", &source, &source_len, &options) == FAILURE) {
","       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|l"", &source, &source_len, &options) == FAILURE) {
",9faaee66fa493372c7340b1ab05f8fd115131a42,"@@ -1580,6 +1580,9 @@ static xmlDocPtr dom_document_parser(zval *id, int mode, char *source, int sourc
        xmlInitParser();
 
        if (mode == DOM_LOAD_FILE) {
+               if (CHECK_NULL_PATH(source, source_len)) {
+                       return NULL;
+               }
                char *file_dest = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);
                if (file_dest) {
                        ctxt = xmlCreateFileParserCtxt(file_dest);
@@ -2168,7 +2171,7 @@ static void dom_load_html(INTERNAL_FUNCTION_PARAMETERS, int mode) /* {{{ */
        
        id = getThis();
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|l"", &source, &source_len, &options) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|l"", &source, &source_len, &options) == FAILURE) {
                return;
        }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/dom/document.c;h=4666746ad2baec453b05ce67f56166aa2bfd4162;hb=4435b9142ff9813845d5c97ab29a5d637bedb257,https://git.php.net/?p=php-src.git;a=blob;f=ext/dom/document.c;h=f105f6d7fe83ced36799094e48907bfe440a0afe,1,"static xmlDocPtr dom_document_parser(zval *id, int mode, char *source, int source_len, int options TSRMLS_DC) /* {{{ */
{
    xmlDocPtr ret;
    xmlParserCtxtPtr ctxt = NULL;
	dom_doc_propsptr doc_props;
	dom_object *intern;
	php_libxml_ref_obj *document = NULL;
	int validate, recover, resolve_externals, keep_blanks, substitute_ent;
	int resolved_path_len;
	int old_error_reporting = 0;
	char *directory=NULL, resolved_path[MAXPATHLEN];

	if (id != NULL) {
		intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);
		document = intern->document;
	}

	doc_props = dom_get_doc_props(document);
	validate = doc_props->validateonparse;
	resolve_externals = doc_props->resolveexternals;
	keep_blanks = doc_props->preservewhitespace;
	substitute_ent = doc_props->substituteentities;
	recover = doc_props->recover;

	if (document == NULL) {
		efree(doc_props);
	}

        xmlInitParser();
 
        if (mode == DOM_LOAD_FILE) {
//fix_flaw_line_below:
//               if (CHECK_NULL_PATH(source, source_len)) {
//fix_flaw_line_below:
//                       return NULL;
//fix_flaw_line_below:
//               }
                char *file_dest = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);
                if (file_dest) {
                        ctxt = xmlCreateFileParserCtxt(file_dest);
		ctxt = xmlCreateMemoryParserCtxt(source, source_len);
	}

	if (ctxt == NULL) {
		return(NULL);
	}

	/* If loading from memory, we need to set the base directory for the document */
	if (mode != DOM_LOAD_FILE) {
#if HAVE_GETCWD
		directory = VCWD_GETCWD(resolved_path, MAXPATHLEN);
#elif HAVE_GETWD
		directory = VCWD_GETWD(resolved_path);
#endif
		if (directory) {
			if(ctxt->directory != NULL) {
				xmlFree((char *) ctxt->directory);
			}
			resolved_path_len = strlen(resolved_path);
			if (resolved_path[resolved_path_len - 1] != DEFAULT_SLASH) {
				resolved_path[resolved_path_len] = DEFAULT_SLASH;
				resolved_path[++resolved_path_len] = '\0';
			}
			ctxt->directory = (char *) xmlCanonicPath((const xmlChar *) resolved_path);
		}
	}

	ctxt->vctxt.error = php_libxml_ctx_error;
	ctxt->vctxt.warning = php_libxml_ctx_warning;

	if (ctxt->sax != NULL) {
		ctxt->sax->error = php_libxml_ctx_error;
		ctxt->sax->warning = php_libxml_ctx_warning;
	}

	if (validate && ! (options & XML_PARSE_DTDVALID)) {
		options |= XML_PARSE_DTDVALID;
	}
	if (resolve_externals && ! (options & XML_PARSE_DTDATTR)) {
		options |= XML_PARSE_DTDATTR;
	}
	if (substitute_ent && ! (options & XML_PARSE_NOENT)) {
		options |= XML_PARSE_NOENT;
	}
	if (keep_blanks == 0 && ! (options & XML_PARSE_NOBLANKS)) {
		options |= XML_PARSE_NOBLANKS;
	}

	xmlCtxtUseOptions(ctxt, options);

	ctxt->recovery = recover;
	if (recover) {
		old_error_reporting = EG(error_reporting);
		EG(error_reporting) = old_error_reporting | E_WARNING;
	}

	xmlParseDocument(ctxt);

	if (ctxt->wellFormed || recover) {
		ret = ctxt->myDoc;
		if (ctxt->recovery) {
			EG(error_reporting) = old_error_reporting;
		}
		/* If loading from memory, set the base reference uri for the document */
		if (ret && ret->URL == NULL && ctxt->directory != NULL) {
			ret->URL = xmlStrdup(ctxt->directory);
		}
	} else {
		ret = NULL;
		xmlFreeDoc(ctxt->myDoc);
		ctxt->myDoc = NULL;
	}

	xmlFreeParserCtxt(ctxt);

	return(ret);
}
/* }}} */

/* {{{ static void dom_parse_document(INTERNAL_FUNCTION_PARAMETERS, int mode) */
static void dom_parse_document(INTERNAL_FUNCTION_PARAMETERS, int mode) {
	zval *id;
	xmlDoc *docp = NULL, *newdoc;
	dom_doc_propsptr doc_prop;
	dom_object *intern;
	char *source;
	int source_len, refcount, ret;
	long options = 0;

	id = getThis();
	if (id != NULL && ! instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) {
		id = NULL;
	}

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|l"", &source, &source_len, &options) == FAILURE) {
		return;
	}

	if (!source_len) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty string supplied as input"");
		RETURN_FALSE;
	}

	newdoc = dom_document_parser(id, mode, source, source_len, options TSRMLS_CC);

	if (!newdoc)
		RETURN_FALSE;

	if (id != NULL) {
		intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);
		if (intern != NULL) {
			docp = (xmlDocPtr) dom_object_get_node(intern);
			doc_prop = NULL;
			if (docp != NULL) {
				php_libxml_decrement_node_ptr((php_libxml_node_object *) intern TSRMLS_CC);
				doc_prop = intern->document->doc_props;
				intern->document->doc_props = NULL;
				refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern TSRMLS_CC);
				if (refcount != 0) {
					docp->_private = NULL;
				}
			}
			intern->document = NULL;
			if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, newdoc TSRMLS_CC) == -1) {
				RETURN_FALSE;
			}
			intern->document->doc_props = doc_prop;
		}

		php_libxml_increment_node_ptr((php_libxml_node_object *)intern, (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC);

		RETURN_TRUE;
	} else {
		DOM_RET_OBJ((xmlNodePtr) newdoc, &ret, NULL);
	}
}
/* }}} end dom_parser_document */

/* {{{ proto DOMNode dom_document_load(string source [, int options]);
URL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-load
Since: DOM Level 3
*/
PHP_METHOD(domdocument, load)
{
	dom_parse_document(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_FILE);
}
/* }}} end dom_document_load */

/* {{{ proto DOMNode dom_document_loadxml(string source [, int options]);
URL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-loadXML
Since: DOM Level 3
*/
PHP_METHOD(domdocument, loadXML)
{
	dom_parse_document(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_STRING);
}
/* }}} end dom_document_loadxml */

/* {{{ proto int dom_document_save(string file);
Convenience method to save to file
*/
PHP_FUNCTION(dom_document_save)
{
	zval *id;
	xmlDoc *docp;
	int file_len = 0, bytes, format, saveempty = 0;
	dom_object *intern;
	dom_doc_propsptr doc_props;
	char *file;
	long options = 0;

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""Os|l"", &id, dom_document_class_entry, &file, &file_len, &options) == FAILURE) {
		return;
	}

	if (file_len == 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid Filename"");
		RETURN_FALSE;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	/* encoding handled by property on doc */

	doc_props = dom_get_doc_props(intern->document);
	format = doc_props->formatoutput;
	if (options & LIBXML_SAVE_NOEMPTYTAG) {
		saveempty = xmlSaveNoEmptyTags;
		xmlSaveNoEmptyTags = 1;
	}
	bytes = xmlSaveFormatFileEnc(file, docp, NULL, format);
	if (options & LIBXML_SAVE_NOEMPTYTAG) {
		xmlSaveNoEmptyTags = saveempty;
	}
	if (bytes == -1) {
		RETURN_FALSE;
	}
	RETURN_LONG(bytes);
}
/* }}} end dom_document_save */

/* {{{ proto string dom_document_savexml([node n]);
URL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-saveXML
Since: DOM Level 3
*/
PHP_FUNCTION(dom_document_savexml)
{
	zval *id, *nodep = NULL;
	xmlDoc *docp;
	xmlNode *node;
	xmlBufferPtr buf;
	xmlChar *mem;
	dom_object *intern, *nodeobj;
	dom_doc_propsptr doc_props;
	int size, format, saveempty = 0;
	long options = 0;

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""O|O!l"", &id, dom_document_class_entry, &nodep, dom_node_class_entry, &options) == FAILURE) {
		return;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	doc_props = dom_get_doc_props(intern->document);
	format = doc_props->formatoutput;

	if (nodep != NULL) {
		/* Dump contents of Node */
		DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);
		if (node->doc != docp) {
			php_dom_throw_error(WRONG_DOCUMENT_ERR, dom_get_strict_error(intern->document) TSRMLS_CC);
			RETURN_FALSE;
		}
		buf = xmlBufferCreate();
		if (!buf) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Could not fetch buffer"");
			RETURN_FALSE;
		}
		if (options & LIBXML_SAVE_NOEMPTYTAG) {
			saveempty = xmlSaveNoEmptyTags;
			xmlSaveNoEmptyTags = 1;
		}
		xmlNodeDump(buf, docp, node, 0, format);
		if (options & LIBXML_SAVE_NOEMPTYTAG) {
			xmlSaveNoEmptyTags = saveempty;
		}
		mem = (xmlChar*) xmlBufferContent(buf);
		if (!mem) {
			xmlBufferFree(buf);
			RETURN_FALSE;
		}
		RETVAL_STRING(mem, 1);
		xmlBufferFree(buf);
	} else {
		if (options & LIBXML_SAVE_NOEMPTYTAG) {
			saveempty = xmlSaveNoEmptyTags;
			xmlSaveNoEmptyTags = 1;
		}
		/* Encoding is handled from the encoding property set on the document */
		xmlDocDumpFormatMemory(docp, &mem, &size, format);
		if (options & LIBXML_SAVE_NOEMPTYTAG) {
			xmlSaveNoEmptyTags = saveempty;
		}
		if (!size) {
			RETURN_FALSE;
		}
		RETVAL_STRINGL(mem, size, 1);
		xmlFree(mem);
	}
}
/* }}} end dom_document_savexml */

static xmlNodePtr php_dom_free_xinclude_node(xmlNodePtr cur TSRMLS_DC) /* {{{ */
{
	xmlNodePtr xincnode;

	xincnode = cur;
	cur = cur->next;
	xmlUnlinkNode(xincnode);
	php_libxml_node_free_resource(xincnode TSRMLS_CC);

	return cur;
}
/* }}} */

static void php_dom_remove_xinclude_nodes(xmlNodePtr cur TSRMLS_DC) /* {{{ */
{
	while(cur) {
		if (cur->type == XML_XINCLUDE_START) {
			cur = php_dom_free_xinclude_node(cur TSRMLS_CC);

			/* XML_XINCLUDE_END node will be a sibling of XML_XINCLUDE_START */
			while(cur && cur->type != XML_XINCLUDE_END) {
				/* remove xinclude processing nodes from recursive xincludes */
				if (cur->type == XML_ELEMENT_NODE) {
					   php_dom_remove_xinclude_nodes(cur->children TSRMLS_CC);
				}
				cur = cur->next;
			}

			if (cur && cur->type == XML_XINCLUDE_END) {
				cur = php_dom_free_xinclude_node(cur TSRMLS_CC);
			}
		} else {
			if (cur->type == XML_ELEMENT_NODE) {
				php_dom_remove_xinclude_nodes(cur->children TSRMLS_CC);
			}
			cur = cur->next;
		}
	}
}
/* }}} */

/* {{{ proto int dom_document_xinclude([int options])
   Substitutues xincludes in a DomDocument */
PHP_FUNCTION(dom_document_xinclude)
{
	zval *id;
	xmlDoc *docp;
	xmlNodePtr root;
	long flags = 0; 
	int err;
	dom_object *intern;

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""O|l"", &id, dom_document_class_entry, &flags) == FAILURE) {
		return;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	err = xmlXIncludeProcessFlags(docp, flags);

	/* XML_XINCLUDE_START and XML_XINCLUDE_END nodes need to be removed as these
	are added via xmlXIncludeProcess to mark beginning and ending of xincluded document 
	but are not wanted in resulting document - must be done even if err as it could fail after
	having processed some xincludes */
	root = (xmlNodePtr) docp->children;
	while(root && root->type != XML_ELEMENT_NODE && root->type != XML_XINCLUDE_START) {
		root = root->next;
	}
	if (root) {
		php_dom_remove_xinclude_nodes(root TSRMLS_CC);
	}

	if (err) {
		RETVAL_LONG(err);
	} else {
		RETVAL_FALSE;
	}
    
}
/* }}} */

/* {{{ proto boolean dom_document_validate();
Since: DOM extended
*/
PHP_FUNCTION(dom_document_validate)
{
	zval *id;
	xmlDoc *docp;
	dom_object *intern;
	xmlValidCtxt *cvp;

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""O"", &id, dom_document_class_entry) == FAILURE) {
		return;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	cvp = xmlNewValidCtxt();
	
	cvp->userData = NULL;
	cvp->error    = (xmlValidityErrorFunc) php_libxml_error_handler;
	cvp->warning  = (xmlValidityErrorFunc) php_libxml_error_handler;
	
	if (xmlValidateDocument(cvp, docp)) {
		RETVAL_TRUE;
	} else {
		RETVAL_FALSE;
	}
	
	xmlFreeValidCtxt(cvp);
	
}
/* }}} */

#if defined(LIBXML_SCHEMAS_ENABLED)
static void _dom_document_schema_validate(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */
{
	zval *id;
	xmlDoc *docp;
	dom_object *intern;
	char *source = NULL, *valid_file = NULL;
	int source_len = 0;
	xmlSchemaParserCtxtPtr  parser;
	xmlSchemaPtr            sptr;
	xmlSchemaValidCtxtPtr   vptr;
	int                     is_valid;
	char resolved_path[MAXPATHLEN + 1];

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""Op"", &id, dom_document_class_entry, &source, &source_len) == FAILURE) {
		return;
	}

	if (source_len == 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid Schema source"");
		RETURN_FALSE;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	switch (type) {
	case DOM_LOAD_FILE:
		valid_file = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);
		if (!valid_file) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid Schema file source"");
			RETURN_FALSE;
		}
		parser = xmlSchemaNewParserCtxt(valid_file);
		break;
	case DOM_LOAD_STRING:
		parser = xmlSchemaNewMemParserCtxt(source, source_len);
		/* If loading from memory, we need to set the base directory for the document 
		   but it is not apparent how to do that for schema's */
		break;
	default:
		return;
	}

	xmlSchemaSetParserErrors(parser,
		(xmlSchemaValidityErrorFunc) php_libxml_error_handler,
		(xmlSchemaValidityWarningFunc) php_libxml_error_handler,
		parser);
	sptr = xmlSchemaParse(parser);
	xmlSchemaFreeParserCtxt(parser);
	if (!sptr) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid Schema"");
		RETURN_FALSE;
	}

	docp = (xmlDocPtr) dom_object_get_node(intern);

	vptr = xmlSchemaNewValidCtxt(sptr);
	if (!vptr) {
		xmlSchemaFree(sptr);
		php_error(E_ERROR, ""Invalid Schema Validation Context"");
		RETURN_FALSE;
	}

	xmlSchemaSetValidErrors(vptr, php_libxml_error_handler, php_libxml_error_handler, vptr);
	is_valid = xmlSchemaValidateDoc(vptr, docp);
	xmlSchemaFree(sptr);
	xmlSchemaFreeValidCtxt(vptr);

	if (is_valid == 0) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}
}
/* }}} */

/* {{{ proto boolean dom_document_schema_validate_file(string filename); */
PHP_FUNCTION(dom_document_schema_validate_file)
{
	_dom_document_schema_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_FILE);
}
/* }}} end dom_document_schema_validate_file */

/* {{{ proto boolean dom_document_schema_validate(string source); */
PHP_FUNCTION(dom_document_schema_validate_xml)
{
	_dom_document_schema_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_STRING);
}
/* }}} end dom_document_schema_validate */

static void _dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */
{
	zval *id;
	xmlDoc *docp;
	dom_object *intern;
	char *source = NULL, *valid_file = NULL;
	int source_len = 0;
	xmlRelaxNGParserCtxtPtr parser;
	xmlRelaxNGPtr           sptr;
	xmlRelaxNGValidCtxtPtr  vptr;
	int                     is_valid;
	char resolved_path[MAXPATHLEN + 1];

	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), ""Op"", &id, dom_document_class_entry, &source, &source_len) == FAILURE) {
		return;
	}

	if (source_len == 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid Schema source"");
		RETURN_FALSE;
	}

	DOM_GET_OBJ(docp, id, xmlDocPtr, intern);

	switch (type) {
	case DOM_LOAD_FILE:
		valid_file = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);
		if (!valid_file) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid RelaxNG file source"");
			RETURN_FALSE;
		}
		parser = xmlRelaxNGNewParserCtxt(valid_file);
		break;
	case DOM_LOAD_STRING:
		parser = xmlRelaxNGNewMemParserCtxt(source, source_len);
		/* If loading from memory, we need to set the base directory for the document 
		   but it is not apparent how to do that for schema's */
		break;
	default:
		return;
	}

	xmlRelaxNGSetParserErrors(parser,
		(xmlRelaxNGValidityErrorFunc) php_libxml_error_handler,
		(xmlRelaxNGValidityWarningFunc) php_libxml_error_handler,
		parser);
	sptr = xmlRelaxNGParse(parser);
	xmlRelaxNGFreeParserCtxt(parser);
	if (!sptr) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid RelaxNG"");
		RETURN_FALSE;
	}

	docp = (xmlDocPtr) dom_object_get_node(intern);

	vptr = xmlRelaxNGNewValidCtxt(sptr);
	if (!vptr) {
		xmlRelaxNGFree(sptr);
		php_error(E_ERROR, ""Invalid RelaxNG Validation Context"");
		RETURN_FALSE;
	}

	xmlRelaxNGSetValidErrors(vptr, php_libxml_error_handler, php_libxml_error_handler, vptr);
	is_valid = xmlRelaxNGValidateDoc(vptr, docp);
	xmlRelaxNGFree(sptr);
	xmlRelaxNGFreeValidCtxt(vptr);

	if (is_valid == 0) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}
}
/* }}} */

/* {{{ proto boolean dom_document_relaxNG_validate_file(string filename); */
PHP_FUNCTION(dom_document_relaxNG_validate_file)
{
	_dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_FILE);
}
/* }}} end dom_document_relaxNG_validate_file */

/* {{{ proto boolean dom_document_relaxNG_validate_xml(string source); */
PHP_FUNCTION(dom_document_relaxNG_validate_xml)
{
	_dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_STRING);
}
/* }}} end dom_document_relaxNG_validate_xml */

#endif

#if defined(LIBXML_HTML_ENABLED)

static void dom_load_html(INTERNAL_FUNCTION_PARAMETERS, int mode) /* {{{ */
{
	zval *id;
	xmlDoc *docp = NULL, *newdoc;
	dom_object *intern;
	dom_doc_propsptr doc_prop;
	char *source;
	int source_len, refcount, ret;
	long options = 0;
	htmlParserCtxtPtr ctxt;
	
	id = getThis();

        
        id = getThis();
 
//flaw_line_below:
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|l"", &source, &source_len, &options) == FAILURE) {
//fix_flaw_line_below:
//       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|l"", &source, &source_len, &options) == FAILURE) {
                return;
        }
	}

	if (mode == DOM_LOAD_FILE) {
		ctxt = htmlCreateFileParserCtxt(source, NULL);
	} else {
		source_len = xmlStrlen(source);
		ctxt = htmlCreateMemoryParserCtxt(source, source_len);
	}

	if (!ctxt) {
		RETURN_FALSE;
	}

	if (options) {
		htmlCtxtUseOptions(ctxt, options);
	}

	ctxt->vctxt.error = php_libxml_ctx_error;
	ctxt->vctxt.warning = php_libxml_ctx_warning;
	if (ctxt->sax != NULL) {
		ctxt->sax->error = php_libxml_ctx_error;
		ctxt->sax->warning = php_libxml_ctx_warning;
	}
	htmlParseDocument(ctxt);
	newdoc = ctxt->myDoc;
	htmlFreeParserCtxt(ctxt);
	
	if (!newdoc)
		RETURN_FALSE;

	if (id != NULL && instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) {
		intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);
		if (intern != NULL) {
			docp = (xmlDocPtr) dom_object_get_node(intern);
			doc_prop = NULL;
			if (docp != NULL) {
				php_libxml_decrement_node_ptr((php_libxml_node_object *) intern TSRMLS_CC);
				doc_prop = intern->document->doc_props;
				intern->document->doc_props = NULL;
				refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern TSRMLS_CC);
				if (refcount != 0) {
					docp->_private = NULL;
				}
			}
			intern->document = NULL;
			if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, newdoc TSRMLS_CC) == -1) {
				RETURN_FALSE;
			}
			intern->document->doc_props = doc_prop;
		}

		php_libxml_increment_node_ptr((php_libxml_node_object *)intern, (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC);

		RETURN_TRUE;
	} else {
		DOM_RET_OBJ((xmlNodePtr) newdoc, &ret, NULL);
	}
}
/* }}} */
"
746,178482,,Remote,Not required,,CVE-2015-3412,https://www.cvedetails.com/cve/CVE-2015-3412/,CWE-254,Low,Partial,,,2016-05-16,5.0,"PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read arbitrary files via crafted input to an application that calls the stream_resolve_include_path function in ext/standard/streamsfuncs.c, as demonstrated by a filename\0.extension attack that bypasses an intended configuration in which client users may read files with only one specific extension.",2019-04-22,Bypass,5,https://git.php.net/?p=php-src.git;a=commit;h=4435b9142ff9813845d5c97ab29a5d637bedb257,4435b9142ff9813845d5c97ab29a5d637bedb257,,0,,,"PHP_FUNCTION(finfo_open)
{
	long options = MAGIC_NONE;
	char *file = NULL;
	int file_len = 0;
	struct php_fileinfo *finfo;
	FILEINFO_DECLARE_INIT_OBJECT(object)
	char resolved_path[MAXPATHLEN];

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|lp"", &options, &file, &file_len) == FAILURE) {
		FILEINFO_DESTROY_OBJECT(object);
		RETURN_FALSE;
	}

	if (object) {
		struct finfo_object *finfo_obj = (struct finfo_object*)zend_object_store_get_object(object TSRMLS_CC);

		if (finfo_obj->ptr) {
			magic_close(finfo_obj->ptr->magic);
			efree(finfo_obj->ptr);
			finfo_obj->ptr = NULL;
		}
	}

	if (file_len == 0) {
		file = NULL;
	} else if (file && *file) { /* user specified file, perform open_basedir checks */

#if PHP_API_VERSION < 20100412
		if ((PG(safe_mode) && (!php_checkuid(file, NULL, CHECKUID_CHECK_FILE_AND_DIR))) || php_check_open_basedir(file TSRMLS_CC)) {
#else
		if (php_check_open_basedir(file TSRMLS_CC)) {
#endif
			FILEINFO_DESTROY_OBJECT(object);
			RETURN_FALSE;
		}
		if (!expand_filepath_with_mode(file, resolved_path, NULL, 0, CWD_EXPAND TSRMLS_CC)) {
			FILEINFO_DESTROY_OBJECT(object);
			RETURN_FALSE;
		}
		file = resolved_path;
	}

	finfo = emalloc(sizeof(struct php_fileinfo));

	finfo->options = options;
	finfo->magic = magic_open(options);

	if (finfo->magic == NULL) {
		efree(finfo);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid mode '%ld'."", options);
		FILEINFO_DESTROY_OBJECT(object);
		RETURN_FALSE;
	}

	if (magic_load(finfo->magic, file) == -1) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to load magic database at '%s'."", file);
		magic_close(finfo->magic);
		efree(finfo);
		FILEINFO_DESTROY_OBJECT(object);
		RETURN_FALSE;
	}

	if (object) {
		FILEINFO_REGISTER_OBJECT(object, finfo);
	} else {
		ZEND_REGISTER_RESOURCE(return_value, finfo, le_fileinfo);
	}
}
/* }}} */

/* {{{ proto resource finfo_close(resource finfo)
   Close fileinfo resource. */
PHP_FUNCTION(finfo_close)
{
	struct php_fileinfo *finfo;
	zval *zfinfo;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &zfinfo) == FAILURE) {
		RETURN_FALSE;
	}
	ZEND_FETCH_RESOURCE(finfo, struct php_fileinfo *, &zfinfo, -1, ""file_info"", le_fileinfo);

	zend_list_delete(Z_RESVAL_P(zfinfo));

	RETURN_TRUE;
}
/* }}} */

/* {{{ proto bool finfo_set_flags(resource finfo, int options)
   Set libmagic configuration options. */
PHP_FUNCTION(finfo_set_flags)
{
	long options;
	struct php_fileinfo *finfo;
	zval *zfinfo;
	FILEINFO_DECLARE_INIT_OBJECT(object)

	if (object) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &options) == FAILURE) {
			RETURN_FALSE;
		}
		FILEINFO_FROM_OBJECT(finfo, object);
	} else {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl"", &zfinfo, &options) == FAILURE) {
			RETURN_FALSE;
		}
		ZEND_FETCH_RESOURCE(finfo, struct php_fileinfo *, &zfinfo, -1, ""file_info"", le_fileinfo);
	}

	FINFO_SET_OPTION(finfo->magic, options)
	finfo->options = options;

	RETURN_TRUE;
}
/* }}} */

#define FILEINFO_MODE_BUFFER 0
#define FILEINFO_MODE_STREAM 1
#define FILEINFO_MODE_FILE 2

static void _php_finfo_get_type(INTERNAL_FUNCTION_PARAMETERS, int mode, int mimetype_emu) /* {{{ */
{
	long options = 0;
	char *ret_val = NULL, *buffer = NULL;
	int buffer_len;
	struct php_fileinfo *finfo = NULL;
	zval *zfinfo, *zcontext = NULL;
	zval *what;
	char mime_directory[] = ""directory"";

	struct magic_set *magic = NULL;
	FILEINFO_DECLARE_INIT_OBJECT(object)

	if (mimetype_emu) {

		/* mime_content_type(..) emulation */
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""z"", &what) == FAILURE) {
			return;
		}

		switch (Z_TYPE_P(what)) {
			case IS_STRING:
				buffer = Z_STRVAL_P(what);
				buffer_len = Z_STRLEN_P(what);
				mode = FILEINFO_MODE_FILE;
				break;

			case IS_RESOURCE:
				mode = FILEINFO_MODE_STREAM;
				break;

			default:
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Can only process string or stream arguments"");
				RETURN_FALSE;
		}

		magic = magic_open(MAGIC_MIME_TYPE);
		if (magic_load(magic, NULL) == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to load magic database."");
			goto common;
		}
	} else if (object) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|lr"", &buffer, &buffer_len, &options, &zcontext) == FAILURE) {
			RETURN_FALSE;
		}
		FILEINFO_FROM_OBJECT(finfo, object);
		magic = finfo->magic;
	} else {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs|lr"", &zfinfo, &buffer, &buffer_len, &options, &zcontext) == FAILURE) {
			RETURN_FALSE;
		}
		ZEND_FETCH_RESOURCE(finfo, struct php_fileinfo *, &zfinfo, -1, ""file_info"", le_fileinfo);
		magic = finfo->magic;
	}	

	/* Set options for the current file/buffer. */
	if (options) {
		FINFO_SET_OPTION(magic, options)
	}

	switch (mode) {
		case FILEINFO_MODE_BUFFER:
		{
			ret_val = (char *) magic_buffer(magic, buffer, buffer_len);
			break;
		}

		case FILEINFO_MODE_STREAM:
		{
				php_stream *stream;
				off_t streampos;

				php_stream_from_zval_no_verify(stream, &what);
				if (!stream) {
					goto common;
				}

				streampos = php_stream_tell(stream); /* remember stream position for restoration */
				php_stream_seek(stream, 0, SEEK_SET);

				ret_val = (char *) magic_stream(magic, stream);

				php_stream_seek(stream, streampos, SEEK_SET);
				break;
		}

		case FILEINFO_MODE_FILE:
		{
			/* determine if the file is a local file or remote URL */
			char *tmp2;
			php_stream_wrapper *wrap;
			php_stream_statbuf ssb;

			if (buffer == NULL || !*buffer) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty filename or path"");
                                RETVAL_FALSE;
                                goto clean;
                        }
                       if (CHECK_NULL_PATH(buffer, buffer_len)) {
                               php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid path"");
                               RETVAL_FALSE;
                               goto clean;
                       }
 
                        wrap = php_stream_locate_url_wrapper(buffer, &tmp2, 0 TSRMLS_CC);
				if (php_stream_stat_path_ex(buffer, 0, &ssb, context) == SUCCESS) {
					if (ssb.sb.st_mode & S_IFDIR) {
						ret_val = mime_directory;
						goto common;
					}
				}
#endif

#if PHP_API_VERSION < 20100412
				stream = php_stream_open_wrapper_ex(buffer, ""rb"", ENFORCE_SAFE_MODE | REPORT_ERRORS, NULL, context);
#else
				stream = php_stream_open_wrapper_ex(buffer, ""rb"", REPORT_ERRORS, NULL, context);
#endif

				if (!stream) {
					RETVAL_FALSE;
					goto clean;
				}

				if (php_stream_stat(stream, &ssb) == SUCCESS) {
					if (ssb.sb.st_mode & S_IFDIR) {
						ret_val = mime_directory;
					} else {
						ret_val = (char *)magic_stream(magic, stream);
					}
				}

				php_stream_close(stream);
			}
			break;
		}

		default:
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Can only process string or stream arguments"");
	}

common:
	if (ret_val) {
		RETVAL_STRING(ret_val, 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed identify data %d:%s"", magic_errno(magic), magic_error(magic));
		RETVAL_FALSE;
	}

clean:
	if (mimetype_emu) {
		magic_close(magic);
	}

	/* Restore options */
	if (options) {
		FINFO_SET_OPTION(magic, finfo->options)
	}
	return;
}
","PHP_FUNCTION(finfo_open)
{
	long options = MAGIC_NONE;
	char *file = NULL;
	int file_len = 0;
	struct php_fileinfo *finfo;
	FILEINFO_DECLARE_INIT_OBJECT(object)
	char resolved_path[MAXPATHLEN];

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|lp"", &options, &file, &file_len) == FAILURE) {
		FILEINFO_DESTROY_OBJECT(object);
		RETURN_FALSE;
	}

	if (object) {
		struct finfo_object *finfo_obj = (struct finfo_object*)zend_object_store_get_object(object TSRMLS_CC);

		if (finfo_obj->ptr) {
			magic_close(finfo_obj->ptr->magic);
			efree(finfo_obj->ptr);
			finfo_obj->ptr = NULL;
		}
	}

	if (file_len == 0) {
		file = NULL;
	} else if (file && *file) { /* user specified file, perform open_basedir checks */

#if PHP_API_VERSION < 20100412
		if ((PG(safe_mode) && (!php_checkuid(file, NULL, CHECKUID_CHECK_FILE_AND_DIR))) || php_check_open_basedir(file TSRMLS_CC)) {
#else
		if (php_check_open_basedir(file TSRMLS_CC)) {
#endif
			FILEINFO_DESTROY_OBJECT(object);
			RETURN_FALSE;
		}
		if (!expand_filepath_with_mode(file, resolved_path, NULL, 0, CWD_EXPAND TSRMLS_CC)) {
			FILEINFO_DESTROY_OBJECT(object);
			RETURN_FALSE;
		}
		file = resolved_path;
	}

	finfo = emalloc(sizeof(struct php_fileinfo));

	finfo->options = options;
	finfo->magic = magic_open(options);

	if (finfo->magic == NULL) {
		efree(finfo);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid mode '%ld'."", options);
		FILEINFO_DESTROY_OBJECT(object);
		RETURN_FALSE;
	}

	if (magic_load(finfo->magic, file) == -1) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to load magic database at '%s'."", file);
		magic_close(finfo->magic);
		efree(finfo);
		FILEINFO_DESTROY_OBJECT(object);
		RETURN_FALSE;
	}

	if (object) {
		FILEINFO_REGISTER_OBJECT(object, finfo);
	} else {
		ZEND_REGISTER_RESOURCE(return_value, finfo, le_fileinfo);
	}
}
/* }}} */

/* {{{ proto resource finfo_close(resource finfo)
   Close fileinfo resource. */
PHP_FUNCTION(finfo_close)
{
	struct php_fileinfo *finfo;
	zval *zfinfo;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &zfinfo) == FAILURE) {
		RETURN_FALSE;
	}
	ZEND_FETCH_RESOURCE(finfo, struct php_fileinfo *, &zfinfo, -1, ""file_info"", le_fileinfo);

	zend_list_delete(Z_RESVAL_P(zfinfo));

	RETURN_TRUE;
}
/* }}} */

/* {{{ proto bool finfo_set_flags(resource finfo, int options)
   Set libmagic configuration options. */
PHP_FUNCTION(finfo_set_flags)
{
	long options;
	struct php_fileinfo *finfo;
	zval *zfinfo;
	FILEINFO_DECLARE_INIT_OBJECT(object)

	if (object) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &options) == FAILURE) {
			RETURN_FALSE;
		}
		FILEINFO_FROM_OBJECT(finfo, object);
	} else {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl"", &zfinfo, &options) == FAILURE) {
			RETURN_FALSE;
		}
		ZEND_FETCH_RESOURCE(finfo, struct php_fileinfo *, &zfinfo, -1, ""file_info"", le_fileinfo);
	}

	FINFO_SET_OPTION(finfo->magic, options)
	finfo->options = options;

	RETURN_TRUE;
}
/* }}} */

#define FILEINFO_MODE_BUFFER 0
#define FILEINFO_MODE_STREAM 1
#define FILEINFO_MODE_FILE 2

static void _php_finfo_get_type(INTERNAL_FUNCTION_PARAMETERS, int mode, int mimetype_emu) /* {{{ */
{
	long options = 0;
	char *ret_val = NULL, *buffer = NULL;
	int buffer_len;
	struct php_fileinfo *finfo = NULL;
	zval *zfinfo, *zcontext = NULL;
	zval *what;
	char mime_directory[] = ""directory"";

	struct magic_set *magic = NULL;
	FILEINFO_DECLARE_INIT_OBJECT(object)

	if (mimetype_emu) {

		/* mime_content_type(..) emulation */
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""z"", &what) == FAILURE) {
			return;
		}

		switch (Z_TYPE_P(what)) {
			case IS_STRING:
				buffer = Z_STRVAL_P(what);
				buffer_len = Z_STRLEN_P(what);
				mode = FILEINFO_MODE_FILE;
				break;

			case IS_RESOURCE:
				mode = FILEINFO_MODE_STREAM;
				break;

			default:
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Can only process string or stream arguments"");
				RETURN_FALSE;
		}

		magic = magic_open(MAGIC_MIME_TYPE);
		if (magic_load(magic, NULL) == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to load magic database."");
			goto common;
		}
	} else if (object) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|lr"", &buffer, &buffer_len, &options, &zcontext) == FAILURE) {
			RETURN_FALSE;
		}
		FILEINFO_FROM_OBJECT(finfo, object);
		magic = finfo->magic;
	} else {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs|lr"", &zfinfo, &buffer, &buffer_len, &options, &zcontext) == FAILURE) {
			RETURN_FALSE;
		}
		ZEND_FETCH_RESOURCE(finfo, struct php_fileinfo *, &zfinfo, -1, ""file_info"", le_fileinfo);
		magic = finfo->magic;
	}	

	/* Set options for the current file/buffer. */
	if (options) {
		FINFO_SET_OPTION(magic, options)
	}

	switch (mode) {
		case FILEINFO_MODE_BUFFER:
		{
			ret_val = (char *) magic_buffer(magic, buffer, buffer_len);
			break;
		}

		case FILEINFO_MODE_STREAM:
		{
				php_stream *stream;
				off_t streampos;

				php_stream_from_zval_no_verify(stream, &what);
				if (!stream) {
					goto common;
				}

				streampos = php_stream_tell(stream); /* remember stream position for restoration */
				php_stream_seek(stream, 0, SEEK_SET);

				ret_val = (char *) magic_stream(magic, stream);

				php_stream_seek(stream, streampos, SEEK_SET);
				break;
		}

		case FILEINFO_MODE_FILE:
		{
			/* determine if the file is a local file or remote URL */
			char *tmp2;
			php_stream_wrapper *wrap;
			php_stream_statbuf ssb;

			if (buffer == NULL || !*buffer) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty filename or path"");
                                RETVAL_FALSE;
                                goto clean;
                        }
 
                        wrap = php_stream_locate_url_wrapper(buffer, &tmp2, 0 TSRMLS_CC);
				if (php_stream_stat_path_ex(buffer, 0, &ssb, context) == SUCCESS) {
					if (ssb.sb.st_mode & S_IFDIR) {
						ret_val = mime_directory;
						goto common;
					}
				}
#endif

#if PHP_API_VERSION < 20100412
				stream = php_stream_open_wrapper_ex(buffer, ""rb"", ENFORCE_SAFE_MODE | REPORT_ERRORS, NULL, context);
#else
				stream = php_stream_open_wrapper_ex(buffer, ""rb"", REPORT_ERRORS, NULL, context);
#endif

				if (!stream) {
					RETVAL_FALSE;
					goto clean;
				}

				if (php_stream_stat(stream, &ssb) == SUCCESS) {
					if (ssb.sb.st_mode & S_IFDIR) {
						ret_val = mime_directory;
					} else {
						ret_val = (char *)magic_stream(magic, stream);
					}
				}

				php_stream_close(stream);
			}
			break;
		}

		default:
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Can only process string or stream arguments"");
	}

common:
	if (ret_val) {
		RETVAL_STRING(ret_val, 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed identify data %d:%s"", magic_errno(magic), magic_error(magic));
		RETVAL_FALSE;
	}

clean:
	if (mimetype_emu) {
		magic_close(magic);
	}

	/* Restore options */
	if (options) {
		FINFO_SET_OPTION(magic, finfo->options)
	}
	return;
}
",C,"                       if (CHECK_NULL_PATH(buffer, buffer_len)) {
                               php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid path"");
                               RETVAL_FALSE;
                               goto clean;
                       }
",,9faaee66fa493372c7340b1ab05f8fd115131a42,"@@ -506,6 +506,11 @@ static void _php_finfo_get_type(INTERNAL_FUNCTION_PARAMETERS, int mode, int mime
                                RETVAL_FALSE;
                                goto clean;
                        }
+                       if (CHECK_NULL_PATH(buffer, buffer_len)) {
+                               php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid path"");
+                               RETVAL_FALSE;
+                               goto clean;
+                       }
 
                        wrap = php_stream_locate_url_wrapper(buffer, &tmp2, 0 TSRMLS_CC);",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/fileinfo/fileinfo.c;h=5fd951174520a0e1161d45d41e18182a07d507c0;hb=4435b9142ff9813845d5c97ab29a5d637bedb257,https://git.php.net/?p=php-src.git;a=blob;f=ext/fileinfo/fileinfo.c;h=2d523ab49812dd43df92d26aadfc0f24e3363ac3,1,"PHP_FUNCTION(finfo_open)
{
	long options = MAGIC_NONE;
	char *file = NULL;
	int file_len = 0;
	struct php_fileinfo *finfo;
	FILEINFO_DECLARE_INIT_OBJECT(object)
	char resolved_path[MAXPATHLEN];

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|lp"", &options, &file, &file_len) == FAILURE) {
		FILEINFO_DESTROY_OBJECT(object);
		RETURN_FALSE;
	}

	if (object) {
		struct finfo_object *finfo_obj = (struct finfo_object*)zend_object_store_get_object(object TSRMLS_CC);

		if (finfo_obj->ptr) {
			magic_close(finfo_obj->ptr->magic);
			efree(finfo_obj->ptr);
			finfo_obj->ptr = NULL;
		}
	}

	if (file_len == 0) {
		file = NULL;
	} else if (file && *file) { /* user specified file, perform open_basedir checks */

#if PHP_API_VERSION < 20100412
		if ((PG(safe_mode) && (!php_checkuid(file, NULL, CHECKUID_CHECK_FILE_AND_DIR))) || php_check_open_basedir(file TSRMLS_CC)) {
#else
		if (php_check_open_basedir(file TSRMLS_CC)) {
#endif
			FILEINFO_DESTROY_OBJECT(object);
			RETURN_FALSE;
		}
		if (!expand_filepath_with_mode(file, resolved_path, NULL, 0, CWD_EXPAND TSRMLS_CC)) {
			FILEINFO_DESTROY_OBJECT(object);
			RETURN_FALSE;
		}
		file = resolved_path;
	}

	finfo = emalloc(sizeof(struct php_fileinfo));

	finfo->options = options;
	finfo->magic = magic_open(options);

	if (finfo->magic == NULL) {
		efree(finfo);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid mode '%ld'."", options);
		FILEINFO_DESTROY_OBJECT(object);
		RETURN_FALSE;
	}

	if (magic_load(finfo->magic, file) == -1) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to load magic database at '%s'."", file);
		magic_close(finfo->magic);
		efree(finfo);
		FILEINFO_DESTROY_OBJECT(object);
		RETURN_FALSE;
	}

	if (object) {
		FILEINFO_REGISTER_OBJECT(object, finfo);
	} else {
		ZEND_REGISTER_RESOURCE(return_value, finfo, le_fileinfo);
	}
}
/* }}} */

/* {{{ proto resource finfo_close(resource finfo)
   Close fileinfo resource. */
PHP_FUNCTION(finfo_close)
{
	struct php_fileinfo *finfo;
	zval *zfinfo;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &zfinfo) == FAILURE) {
		RETURN_FALSE;
	}
	ZEND_FETCH_RESOURCE(finfo, struct php_fileinfo *, &zfinfo, -1, ""file_info"", le_fileinfo);

	zend_list_delete(Z_RESVAL_P(zfinfo));

	RETURN_TRUE;
}
/* }}} */

/* {{{ proto bool finfo_set_flags(resource finfo, int options)
   Set libmagic configuration options. */
PHP_FUNCTION(finfo_set_flags)
{
	long options;
	struct php_fileinfo *finfo;
	zval *zfinfo;
	FILEINFO_DECLARE_INIT_OBJECT(object)

	if (object) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &options) == FAILURE) {
			RETURN_FALSE;
		}
		FILEINFO_FROM_OBJECT(finfo, object);
	} else {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl"", &zfinfo, &options) == FAILURE) {
			RETURN_FALSE;
		}
		ZEND_FETCH_RESOURCE(finfo, struct php_fileinfo *, &zfinfo, -1, ""file_info"", le_fileinfo);
	}

	FINFO_SET_OPTION(finfo->magic, options)
	finfo->options = options;

	RETURN_TRUE;
}
/* }}} */

#define FILEINFO_MODE_BUFFER 0
#define FILEINFO_MODE_STREAM 1
#define FILEINFO_MODE_FILE 2

static void _php_finfo_get_type(INTERNAL_FUNCTION_PARAMETERS, int mode, int mimetype_emu) /* {{{ */
{
	long options = 0;
	char *ret_val = NULL, *buffer = NULL;
	int buffer_len;
	struct php_fileinfo *finfo = NULL;
	zval *zfinfo, *zcontext = NULL;
	zval *what;
	char mime_directory[] = ""directory"";

	struct magic_set *magic = NULL;
	FILEINFO_DECLARE_INIT_OBJECT(object)

	if (mimetype_emu) {

		/* mime_content_type(..) emulation */
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""z"", &what) == FAILURE) {
			return;
		}

		switch (Z_TYPE_P(what)) {
			case IS_STRING:
				buffer = Z_STRVAL_P(what);
				buffer_len = Z_STRLEN_P(what);
				mode = FILEINFO_MODE_FILE;
				break;

			case IS_RESOURCE:
				mode = FILEINFO_MODE_STREAM;
				break;

			default:
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Can only process string or stream arguments"");
				RETURN_FALSE;
		}

		magic = magic_open(MAGIC_MIME_TYPE);
		if (magic_load(magic, NULL) == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to load magic database."");
			goto common;
		}
	} else if (object) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|lr"", &buffer, &buffer_len, &options, &zcontext) == FAILURE) {
			RETURN_FALSE;
		}
		FILEINFO_FROM_OBJECT(finfo, object);
		magic = finfo->magic;
	} else {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs|lr"", &zfinfo, &buffer, &buffer_len, &options, &zcontext) == FAILURE) {
			RETURN_FALSE;
		}
		ZEND_FETCH_RESOURCE(finfo, struct php_fileinfo *, &zfinfo, -1, ""file_info"", le_fileinfo);
		magic = finfo->magic;
	}	

	/* Set options for the current file/buffer. */
	if (options) {
		FINFO_SET_OPTION(magic, options)
	}

	switch (mode) {
		case FILEINFO_MODE_BUFFER:
		{
			ret_val = (char *) magic_buffer(magic, buffer, buffer_len);
			break;
		}

		case FILEINFO_MODE_STREAM:
		{
				php_stream *stream;
				off_t streampos;

				php_stream_from_zval_no_verify(stream, &what);
				if (!stream) {
					goto common;
				}

				streampos = php_stream_tell(stream); /* remember stream position for restoration */
				php_stream_seek(stream, 0, SEEK_SET);

				ret_val = (char *) magic_stream(magic, stream);

				php_stream_seek(stream, streampos, SEEK_SET);
				break;
		}

		case FILEINFO_MODE_FILE:
		{
			/* determine if the file is a local file or remote URL */
			char *tmp2;
			php_stream_wrapper *wrap;
			php_stream_statbuf ssb;

			if (buffer == NULL || !*buffer) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty filename or path"");
                                RETVAL_FALSE;
                                goto clean;
                        }
//fix_flaw_line_below:
//                       if (CHECK_NULL_PATH(buffer, buffer_len)) {
//fix_flaw_line_below:
//                               php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid path"");
//fix_flaw_line_below:
//                               RETVAL_FALSE;
//fix_flaw_line_below:
//                               goto clean;
//fix_flaw_line_below:
//                       }
 
                        wrap = php_stream_locate_url_wrapper(buffer, &tmp2, 0 TSRMLS_CC);
				if (php_stream_stat_path_ex(buffer, 0, &ssb, context) == SUCCESS) {
					if (ssb.sb.st_mode & S_IFDIR) {
						ret_val = mime_directory;
						goto common;
					}
				}
#endif

#if PHP_API_VERSION < 20100412
				stream = php_stream_open_wrapper_ex(buffer, ""rb"", ENFORCE_SAFE_MODE | REPORT_ERRORS, NULL, context);
#else
				stream = php_stream_open_wrapper_ex(buffer, ""rb"", REPORT_ERRORS, NULL, context);
#endif

				if (!stream) {
					RETVAL_FALSE;
					goto clean;
				}

				if (php_stream_stat(stream, &ssb) == SUCCESS) {
					if (ssb.sb.st_mode & S_IFDIR) {
						ret_val = mime_directory;
					} else {
						ret_val = (char *)magic_stream(magic, stream);
					}
				}

				php_stream_close(stream);
			}
			break;
		}

		default:
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Can only process string or stream arguments"");
	}

common:
	if (ret_val) {
		RETVAL_STRING(ret_val, 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed identify data %d:%s"", magic_errno(magic), magic_error(magic));
		RETVAL_FALSE;
	}

clean:
	if (mimetype_emu) {
		magic_close(magic);
	}

	/* Restore options */
	if (options) {
		FINFO_SET_OPTION(magic, finfo->options)
	}
	return;
}
"
747,178483,,Remote,Not required,,CVE-2015-3412,https://www.cvedetails.com/cve/CVE-2015-3412/,CWE-254,Low,Partial,,,2016-05-16,5.0,"PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read arbitrary files via crafted input to an application that calls the stream_resolve_include_path function in ext/standard/streamsfuncs.c, as demonstrated by a filename\0.extension attack that bypasses an intended configuration in which client users may read files with only one specific extension.",2019-04-22,Bypass,1,https://git.php.net/?p=php-src.git;a=commit;h=4435b9142ff9813845d5c97ab29a5d637bedb257,4435b9142ff9813845d5c97ab29a5d637bedb257,,1,,,"PHP_FUNCTION(imageloadfont)
{
	char *file;
	int file_name, hdr_size = sizeof(gdFont) - sizeof(char *);
	int ind, body_size, n = 0, b, i, body_size_check;
        gdFontPtr font;
        php_stream *stream;
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &file, &file_name) == FAILURE) {
                return;
        }
 
	stream = php_stream_open_wrapper(file, ""rb"", IGNORE_PATH | IGNORE_URL_WIN | REPORT_ERRORS, NULL);
	if (stream == NULL) {
		RETURN_FALSE;
	}

	/* Only supports a architecture-dependent binary dump format
	 * at the moment.
	 * The file format is like this on machines with 32-byte integers:
	 *
	 * byte 0-3:   (int) number of characters in the font
	 * byte 4-7:   (int) value of first character in the font (often 32, space)
	 * byte 8-11:  (int) pixel width of each character
	 * byte 12-15: (int) pixel height of each character
	 * bytes 16-:  (char) array with character data, one byte per pixel
	 *                    in each character, for a total of
	 *                    (nchars*width*height) bytes.
	 */
	font = (gdFontPtr) emalloc(sizeof(gdFont));
	b = 0;
	while (b < hdr_size && (n = php_stream_read(stream, (char*)&font[b], hdr_size - b))) {
		b += n;
	}

	if (!n) {
		efree(font);
		if (php_stream_eof(stream)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""End of file while reading header"");
		} else {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error while reading header"");
		}
		php_stream_close(stream);
		RETURN_FALSE;
	}
	i = php_stream_tell(stream);
	php_stream_seek(stream, 0, SEEK_END);
	body_size_check = php_stream_tell(stream) - hdr_size;
	php_stream_seek(stream, i, SEEK_SET);

	body_size = font->w * font->h * font->nchars;
	if (body_size != body_size_check) {
		font->w = FLIPWORD(font->w);
		font->h = FLIPWORD(font->h);
		font->nchars = FLIPWORD(font->nchars);
		body_size = font->w * font->h * font->nchars;
	}

	if (overflow2(font->nchars, font->h)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error reading font, invalid font header"");
		efree(font);
		php_stream_close(stream);
		RETURN_FALSE;
	}
	if (overflow2(font->nchars * font->h, font->w )) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error reading font, invalid font header"");
		efree(font);
		php_stream_close(stream);
		RETURN_FALSE;
	}

	if (body_size != body_size_check) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error reading font"");
		efree(font);
		php_stream_close(stream);
		RETURN_FALSE;
	}

	font->data = emalloc(body_size);
	b = 0;
	while (b < body_size && (n = php_stream_read(stream, &font->data[b], body_size - b))) {
		b += n;
	}

	if (!n) {
		efree(font->data);
		efree(font);
		if (php_stream_eof(stream)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""End of file while reading body"");
		} else {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error while reading body"");
		}
		php_stream_close(stream);
		RETURN_FALSE;
	}
	php_stream_close(stream);

	/* Adding 5 to the font index so we will never have font indices
	 * that overlap with the old fonts (with indices 1-5).  The first
	 * list index given out is always 1.
	 */
	ind = 5 + zend_list_insert(font, le_gd_font TSRMLS_CC);

	RETURN_LONG(ind);
}
","PHP_FUNCTION(imageloadfont)
{
	char *file;
	int file_name, hdr_size = sizeof(gdFont) - sizeof(char *);
	int ind, body_size, n = 0, b, i, body_size_check;
        gdFontPtr font;
        php_stream *stream;
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &file, &file_name) == FAILURE) {
                return;
        }
 
	stream = php_stream_open_wrapper(file, ""rb"", IGNORE_PATH | IGNORE_URL_WIN | REPORT_ERRORS, NULL);
	if (stream == NULL) {
		RETURN_FALSE;
	}

	/* Only supports a architecture-dependent binary dump format
	 * at the moment.
	 * The file format is like this on machines with 32-byte integers:
	 *
	 * byte 0-3:   (int) number of characters in the font
	 * byte 4-7:   (int) value of first character in the font (often 32, space)
	 * byte 8-11:  (int) pixel width of each character
	 * byte 12-15: (int) pixel height of each character
	 * bytes 16-:  (char) array with character data, one byte per pixel
	 *                    in each character, for a total of
	 *                    (nchars*width*height) bytes.
	 */
	font = (gdFontPtr) emalloc(sizeof(gdFont));
	b = 0;
	while (b < hdr_size && (n = php_stream_read(stream, (char*)&font[b], hdr_size - b))) {
		b += n;
	}

	if (!n) {
		efree(font);
		if (php_stream_eof(stream)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""End of file while reading header"");
		} else {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error while reading header"");
		}
		php_stream_close(stream);
		RETURN_FALSE;
	}
	i = php_stream_tell(stream);
	php_stream_seek(stream, 0, SEEK_END);
	body_size_check = php_stream_tell(stream) - hdr_size;
	php_stream_seek(stream, i, SEEK_SET);

	body_size = font->w * font->h * font->nchars;
	if (body_size != body_size_check) {
		font->w = FLIPWORD(font->w);
		font->h = FLIPWORD(font->h);
		font->nchars = FLIPWORD(font->nchars);
		body_size = font->w * font->h * font->nchars;
	}

	if (overflow2(font->nchars, font->h)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error reading font, invalid font header"");
		efree(font);
		php_stream_close(stream);
		RETURN_FALSE;
	}
	if (overflow2(font->nchars * font->h, font->w )) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error reading font, invalid font header"");
		efree(font);
		php_stream_close(stream);
		RETURN_FALSE;
	}

	if (body_size != body_size_check) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error reading font"");
		efree(font);
		php_stream_close(stream);
		RETURN_FALSE;
	}

	font->data = emalloc(body_size);
	b = 0;
	while (b < body_size && (n = php_stream_read(stream, &font->data[b], body_size - b))) {
		b += n;
	}

	if (!n) {
		efree(font->data);
		efree(font);
		if (php_stream_eof(stream)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""End of file while reading body"");
		} else {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error while reading body"");
		}
		php_stream_close(stream);
		RETURN_FALSE;
	}
	php_stream_close(stream);

	/* Adding 5 to the font index so we will never have font indices
	 * that overlap with the old fonts (with indices 1-5).  The first
	 * list index given out is always 1.
	 */
	ind = 5 + zend_list_insert(font, le_gd_font TSRMLS_CC);

	RETURN_LONG(ind);
}
",C,"       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &file, &file_name) == FAILURE) {
","       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &file, &file_name) == FAILURE) {
",9faaee66fa493372c7340b1ab05f8fd115131a42,"@@ -1495,7 +1495,7 @@ PHP_FUNCTION(imageloadfont)
        gdFontPtr font;
        php_stream *stream;
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &file, &file_name) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &file, &file_name) == FAILURE) {
                return;
        }
 
@@ -2438,7 +2438,7 @@ static void _php_image_create_from(INTERNAL_FUNCTION_PARAMETERS, int image_type,
        long ignore_warning;
 #endif
        if (image_type == PHP_GDIMG_TYPE_GD2PART) {
-               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sllll"", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {
+               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""pllll"", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {
                        return;
                }
                if (width < 1 || height < 1) {
@@ -2446,7 +2446,7 @@ static void _php_image_create_from(INTERNAL_FUNCTION_PARAMETERS, int image_type,
                        RETURN_FALSE;
                }
        } else {
-               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &file, &file_len) == FAILURE) {
+               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &file, &file_len) == FAILURE) {
                        return;
                }
        }
@@ -4178,7 +4178,7 @@ PHP_FUNCTION(imagepsencodefont)
        char *enc, **enc_vector;
        int enc_len, *f_ind;
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &fnt, &enc, &enc_len) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rp"", &fnt, &enc, &enc_len) == FAILURE) {
                return;
        }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/gd/gd.c;h=d258c3dbc7862534762d3640688f1b980c031459;hb=4435b9142ff9813845d5c97ab29a5d637bedb257,https://git.php.net/?p=php-src.git;a=blob;f=ext/gd/gd.c;h=e5657f7424ab30c8f3ca7ec73e9201375d1fab39,1,"PHP_FUNCTION(imageloadfont)
{
	char *file;
	int file_name, hdr_size = sizeof(gdFont) - sizeof(char *);
	int ind, body_size, n = 0, b, i, body_size_check;
        gdFontPtr font;
        php_stream *stream;
 
//flaw_line_below:
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &file, &file_name) == FAILURE) {
//fix_flaw_line_below:
//       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &file, &file_name) == FAILURE) {
                return;
        }
 
	stream = php_stream_open_wrapper(file, ""rb"", IGNORE_PATH | IGNORE_URL_WIN | REPORT_ERRORS, NULL);
	if (stream == NULL) {
		RETURN_FALSE;
	}

	/* Only supports a architecture-dependent binary dump format
	 * at the moment.
	 * The file format is like this on machines with 32-byte integers:
	 *
	 * byte 0-3:   (int) number of characters in the font
	 * byte 4-7:   (int) value of first character in the font (often 32, space)
	 * byte 8-11:  (int) pixel width of each character
	 * byte 12-15: (int) pixel height of each character
	 * bytes 16-:  (char) array with character data, one byte per pixel
	 *                    in each character, for a total of
	 *                    (nchars*width*height) bytes.
	 */
	font = (gdFontPtr) emalloc(sizeof(gdFont));
	b = 0;
	while (b < hdr_size && (n = php_stream_read(stream, (char*)&font[b], hdr_size - b))) {
		b += n;
	}

	if (!n) {
		efree(font);
		if (php_stream_eof(stream)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""End of file while reading header"");
		} else {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error while reading header"");
		}
		php_stream_close(stream);
		RETURN_FALSE;
	}
	i = php_stream_tell(stream);
	php_stream_seek(stream, 0, SEEK_END);
	body_size_check = php_stream_tell(stream) - hdr_size;
	php_stream_seek(stream, i, SEEK_SET);

	body_size = font->w * font->h * font->nchars;
	if (body_size != body_size_check) {
		font->w = FLIPWORD(font->w);
		font->h = FLIPWORD(font->h);
		font->nchars = FLIPWORD(font->nchars);
		body_size = font->w * font->h * font->nchars;
	}

	if (overflow2(font->nchars, font->h)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error reading font, invalid font header"");
		efree(font);
		php_stream_close(stream);
		RETURN_FALSE;
	}
	if (overflow2(font->nchars * font->h, font->w )) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error reading font, invalid font header"");
		efree(font);
		php_stream_close(stream);
		RETURN_FALSE;
	}

	if (body_size != body_size_check) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error reading font"");
		efree(font);
		php_stream_close(stream);
		RETURN_FALSE;
	}

	font->data = emalloc(body_size);
	b = 0;
	while (b < body_size && (n = php_stream_read(stream, &font->data[b], body_size - b))) {
		b += n;
	}

	if (!n) {
		efree(font->data);
		efree(font);
		if (php_stream_eof(stream)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""End of file while reading body"");
		} else {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error while reading body"");
		}
		php_stream_close(stream);
		RETURN_FALSE;
	}
	php_stream_close(stream);

	/* Adding 5 to the font index so we will never have font indices
	 * that overlap with the old fonts (with indices 1-5).  The first
	 * list index given out is always 1.
	 */
	ind = 5 + zend_list_insert(font, le_gd_font TSRMLS_CC);

	RETURN_LONG(ind);
}
"
748,178484,,Remote,Not required,,CVE-2015-3412,https://www.cvedetails.com/cve/CVE-2015-3412/,CWE-254,Low,Partial,,,2016-05-16,5.0,"PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read arbitrary files via crafted input to an application that calls the stream_resolve_include_path function in ext/standard/streamsfuncs.c, as demonstrated by a filename\0.extension attack that bypasses an intended configuration in which client users may read files with only one specific extension.",2019-04-22,Bypass,1,https://git.php.net/?p=php-src.git;a=commit;h=4435b9142ff9813845d5c97ab29a5d637bedb257,4435b9142ff9813845d5c97ab29a5d637bedb257,,1,,,"PHP_FUNCTION(imagepsencodefont)
{
	zval *fnt;
        char *enc, **enc_vector;
        int enc_len, *f_ind;
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rp"", &fnt, &enc, &enc_len) == FAILURE) {
                return;
        }
	ZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, ""Type 1 font"", le_ps_font);

	if ((enc_vector = T1_LoadEncoding(enc)) == NULL) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Couldn't load encoding vector from %s"", enc);
		RETURN_FALSE;
	}

	T1_DeleteAllSizes(*f_ind);
	if (T1_ReencodeFont(*f_ind, enc_vector)) {
		T1_DeleteEncoding(enc_vector);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Couldn't re-encode font"");
		RETURN_FALSE;
	}

	zend_list_insert(enc_vector, le_ps_enc TSRMLS_CC);

	RETURN_TRUE;
}
","PHP_FUNCTION(imagepsencodefont)
{
	zval *fnt;
        char *enc, **enc_vector;
        int enc_len, *f_ind;
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &fnt, &enc, &enc_len) == FAILURE) {
                return;
        }
	ZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, ""Type 1 font"", le_ps_font);

	if ((enc_vector = T1_LoadEncoding(enc)) == NULL) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Couldn't load encoding vector from %s"", enc);
		RETURN_FALSE;
	}

	T1_DeleteAllSizes(*f_ind);
	if (T1_ReencodeFont(*f_ind, enc_vector)) {
		T1_DeleteEncoding(enc_vector);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Couldn't re-encode font"");
		RETURN_FALSE;
	}

	zend_list_insert(enc_vector, le_ps_enc TSRMLS_CC);

	RETURN_TRUE;
}
",C,"       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rp"", &fnt, &enc, &enc_len) == FAILURE) {
","       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &fnt, &enc, &enc_len) == FAILURE) {
",9faaee66fa493372c7340b1ab05f8fd115131a42,"@@ -1495,7 +1495,7 @@ PHP_FUNCTION(imageloadfont)
        gdFontPtr font;
        php_stream *stream;
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &file, &file_name) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &file, &file_name) == FAILURE) {
                return;
        }
 
@@ -2438,7 +2438,7 @@ static void _php_image_create_from(INTERNAL_FUNCTION_PARAMETERS, int image_type,
        long ignore_warning;
 #endif
        if (image_type == PHP_GDIMG_TYPE_GD2PART) {
-               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sllll"", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {
+               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""pllll"", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {
                        return;
                }
                if (width < 1 || height < 1) {
@@ -2446,7 +2446,7 @@ static void _php_image_create_from(INTERNAL_FUNCTION_PARAMETERS, int image_type,
                        RETURN_FALSE;
                }
        } else {
-               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &file, &file_len) == FAILURE) {
+               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &file, &file_len) == FAILURE) {
                        return;
                }
        }
@@ -4178,7 +4178,7 @@ PHP_FUNCTION(imagepsencodefont)
        char *enc, **enc_vector;
        int enc_len, *f_ind;
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &fnt, &enc, &enc_len) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rp"", &fnt, &enc, &enc_len) == FAILURE) {
                return;
        }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/gd/gd.c;h=d258c3dbc7862534762d3640688f1b980c031459;hb=4435b9142ff9813845d5c97ab29a5d637bedb257,https://git.php.net/?p=php-src.git;a=blob;f=ext/gd/gd.c;h=e5657f7424ab30c8f3ca7ec73e9201375d1fab39,1,"PHP_FUNCTION(imagepsencodefont)
{
	zval *fnt;
        char *enc, **enc_vector;
        int enc_len, *f_ind;
 
//flaw_line_below:
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &fnt, &enc, &enc_len) == FAILURE) {
//fix_flaw_line_below:
//       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rp"", &fnt, &enc, &enc_len) == FAILURE) {
                return;
        }
	ZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, ""Type 1 font"", le_ps_font);

	if ((enc_vector = T1_LoadEncoding(enc)) == NULL) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Couldn't load encoding vector from %s"", enc);
		RETURN_FALSE;
	}

	T1_DeleteAllSizes(*f_ind);
	if (T1_ReencodeFont(*f_ind, enc_vector)) {
		T1_DeleteEncoding(enc_vector);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Couldn't re-encode font"");
		RETURN_FALSE;
	}

	zend_list_insert(enc_vector, le_ps_enc TSRMLS_CC);

	RETURN_TRUE;
}
"
749,178485,,Remote,Not required,,CVE-2015-3412,https://www.cvedetails.com/cve/CVE-2015-3412/,CWE-254,Low,Partial,,,2016-05-16,5.0,"PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read arbitrary files via crafted input to an application that calls the stream_resolve_include_path function in ext/standard/streamsfuncs.c, as demonstrated by a filename\0.extension attack that bypasses an intended configuration in which client users may read files with only one specific extension.",2019-04-22,Bypass,2,https://git.php.net/?p=php-src.git;a=commit;h=4435b9142ff9813845d5c97ab29a5d637bedb257,4435b9142ff9813845d5c97ab29a5d637bedb257,,2,,,"static void _php_image_create_from(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, gdImagePtr (*func_p)(), gdImagePtr (*ioctx_func_p)())
{
	char *file;
	int file_len;
	long srcx, srcy, width, height;
	gdImagePtr im = NULL;
	php_stream *stream;
	FILE * fp = NULL;
#ifdef HAVE_GD_JPG
        long ignore_warning;
 #endif
        if (image_type == PHP_GDIMG_TYPE_GD2PART) {
               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""pllll"", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {
                        return;
                }
                if (width < 1 || height < 1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Zero width or height not allowed"");
                        RETURN_FALSE;
                }
        } else {
               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &file, &file_len) == FAILURE) {
                        return;
                }
        }

	stream = php_stream_open_wrapper(file, ""rb"", REPORT_ERRORS|IGNORE_PATH|IGNORE_URL_WIN, NULL);
	if (stream == NULL)	{
		RETURN_FALSE;
	}

#ifndef USE_GD_IOCTX
	ioctx_func_p = NULL; /* don't allow sockets without IOCtx */
#endif

	if (image_type == PHP_GDIMG_TYPE_WEBP) {
		size_t buff_size;
		char *buff;

		/* needs to be malloc (persistent) - GD will free() it later */
		buff_size = php_stream_copy_to_mem(stream, &buff, PHP_STREAM_COPY_ALL, 1);
		if (!buff_size) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING,""Cannot read image data"");
			goto out_err;
		}
		im = (*ioctx_func_p)(buff_size, buff);
		if (!im) {
			goto out_err;
		}
		goto register_im;
	}

	/* try and avoid allocating a FILE* if the stream is not naturally a FILE* */
	if (php_stream_is(stream, PHP_STREAM_IS_STDIO))	{
		if (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&fp, REPORT_ERRORS)) {
			goto out_err;
		}
	} else if (ioctx_func_p) {
#ifdef USE_GD_IOCTX
		/* we can create an io context */
		gdIOCtx* io_ctx;
		size_t buff_size;
		char *buff;

		/* needs to be malloc (persistent) - GD will free() it later */
		buff_size = php_stream_copy_to_mem(stream, &buff, PHP_STREAM_COPY_ALL, 1);

		if (!buff_size) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING,""Cannot read image data"");
			goto out_err;
		}

		io_ctx = gdNewDynamicCtxEx(buff_size, buff, 0);
		if (!io_ctx) {
			pefree(buff, 1);
			php_error_docref(NULL TSRMLS_CC, E_WARNING,""Cannot allocate GD IO context"");
			goto out_err;
		}

		if (image_type == PHP_GDIMG_TYPE_GD2PART) {
			im = (*ioctx_func_p)(io_ctx, srcx, srcy, width, height);
		} else {
			im = (*ioctx_func_p)(io_ctx);
		}
#if HAVE_LIBGD204
		io_ctx->gd_free(io_ctx);
#else
		io_ctx->free(io_ctx);
#endif
		pefree(buff, 1);
#endif
	}
	else {
		/* try and force the stream to be FILE* */
		if (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO | PHP_STREAM_CAST_TRY_HARD, (void **) &fp, REPORT_ERRORS)) {
			goto out_err;
		}
	}

	if (!im && fp) {
		switch (image_type) {
			case PHP_GDIMG_TYPE_GD2PART:
				im = (*func_p)(fp, srcx, srcy, width, height);
				break;
#if defined(HAVE_GD_XPM) && defined(HAVE_GD_BUNDLED)
			case PHP_GDIMG_TYPE_XPM:
				im = gdImageCreateFromXpm(file);
				break;
#endif

#ifdef HAVE_GD_JPG
			case PHP_GDIMG_TYPE_JPG:
				ignore_warning = INI_INT(""gd.jpeg_ignore_warning"");
#ifdef HAVE_GD_BUNDLED
				im = gdImageCreateFromJpeg(fp, ignore_warning);
#else
				im = gdImageCreateFromJpeg(fp);
#endif
			break;
#endif

			default:
				im = (*func_p)(fp);
				break;
		}

		fflush(fp);
	}

register_im:
	if (im) {
		ZEND_REGISTER_RESOURCE(return_value, im, le_gd);
		php_stream_close(stream);
		return;
	}

	php_error_docref(NULL TSRMLS_CC, E_WARNING, ""'%s' is not a valid %s file"", file, tn);
out_err:
	php_stream_close(stream);
	RETURN_FALSE;

}
","static void _php_image_create_from(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, gdImagePtr (*func_p)(), gdImagePtr (*ioctx_func_p)())
{
	char *file;
	int file_len;
	long srcx, srcy, width, height;
	gdImagePtr im = NULL;
	php_stream *stream;
	FILE * fp = NULL;
#ifdef HAVE_GD_JPG
        long ignore_warning;
 #endif
        if (image_type == PHP_GDIMG_TYPE_GD2PART) {
               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sllll"", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {
                        return;
                }
                if (width < 1 || height < 1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Zero width or height not allowed"");
                        RETURN_FALSE;
                }
        } else {
               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &file, &file_len) == FAILURE) {
                        return;
                }
        }

	stream = php_stream_open_wrapper(file, ""rb"", REPORT_ERRORS|IGNORE_PATH|IGNORE_URL_WIN, NULL);
	if (stream == NULL)	{
		RETURN_FALSE;
	}

#ifndef USE_GD_IOCTX
	ioctx_func_p = NULL; /* don't allow sockets without IOCtx */
#endif

	if (image_type == PHP_GDIMG_TYPE_WEBP) {
		size_t buff_size;
		char *buff;

		/* needs to be malloc (persistent) - GD will free() it later */
		buff_size = php_stream_copy_to_mem(stream, &buff, PHP_STREAM_COPY_ALL, 1);
		if (!buff_size) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING,""Cannot read image data"");
			goto out_err;
		}
		im = (*ioctx_func_p)(buff_size, buff);
		if (!im) {
			goto out_err;
		}
		goto register_im;
	}

	/* try and avoid allocating a FILE* if the stream is not naturally a FILE* */
	if (php_stream_is(stream, PHP_STREAM_IS_STDIO))	{
		if (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&fp, REPORT_ERRORS)) {
			goto out_err;
		}
	} else if (ioctx_func_p) {
#ifdef USE_GD_IOCTX
		/* we can create an io context */
		gdIOCtx* io_ctx;
		size_t buff_size;
		char *buff;

		/* needs to be malloc (persistent) - GD will free() it later */
		buff_size = php_stream_copy_to_mem(stream, &buff, PHP_STREAM_COPY_ALL, 1);

		if (!buff_size) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING,""Cannot read image data"");
			goto out_err;
		}

		io_ctx = gdNewDynamicCtxEx(buff_size, buff, 0);
		if (!io_ctx) {
			pefree(buff, 1);
			php_error_docref(NULL TSRMLS_CC, E_WARNING,""Cannot allocate GD IO context"");
			goto out_err;
		}

		if (image_type == PHP_GDIMG_TYPE_GD2PART) {
			im = (*ioctx_func_p)(io_ctx, srcx, srcy, width, height);
		} else {
			im = (*ioctx_func_p)(io_ctx);
		}
#if HAVE_LIBGD204
		io_ctx->gd_free(io_ctx);
#else
		io_ctx->free(io_ctx);
#endif
		pefree(buff, 1);
#endif
	}
	else {
		/* try and force the stream to be FILE* */
		if (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO | PHP_STREAM_CAST_TRY_HARD, (void **) &fp, REPORT_ERRORS)) {
			goto out_err;
		}
	}

	if (!im && fp) {
		switch (image_type) {
			case PHP_GDIMG_TYPE_GD2PART:
				im = (*func_p)(fp, srcx, srcy, width, height);
				break;
#if defined(HAVE_GD_XPM) && defined(HAVE_GD_BUNDLED)
			case PHP_GDIMG_TYPE_XPM:
				im = gdImageCreateFromXpm(file);
				break;
#endif

#ifdef HAVE_GD_JPG
			case PHP_GDIMG_TYPE_JPG:
				ignore_warning = INI_INT(""gd.jpeg_ignore_warning"");
#ifdef HAVE_GD_BUNDLED
				im = gdImageCreateFromJpeg(fp, ignore_warning);
#else
				im = gdImageCreateFromJpeg(fp);
#endif
			break;
#endif

			default:
				im = (*func_p)(fp);
				break;
		}

		fflush(fp);
	}

register_im:
	if (im) {
		ZEND_REGISTER_RESOURCE(return_value, im, le_gd);
		php_stream_close(stream);
		return;
	}

	php_error_docref(NULL TSRMLS_CC, E_WARNING, ""'%s' is not a valid %s file"", file, tn);
out_err:
	php_stream_close(stream);
	RETURN_FALSE;

}
",C,"               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""pllll"", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {
               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &file, &file_len) == FAILURE) {
","               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sllll"", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {
               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &file, &file_len) == FAILURE) {
",9faaee66fa493372c7340b1ab05f8fd115131a42,"@@ -1495,7 +1495,7 @@ PHP_FUNCTION(imageloadfont)
        gdFontPtr font;
        php_stream *stream;
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &file, &file_name) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &file, &file_name) == FAILURE) {
                return;
        }
 
@@ -2438,7 +2438,7 @@ static void _php_image_create_from(INTERNAL_FUNCTION_PARAMETERS, int image_type,
        long ignore_warning;
 #endif
        if (image_type == PHP_GDIMG_TYPE_GD2PART) {
-               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sllll"", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {
+               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""pllll"", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {
                        return;
                }
                if (width < 1 || height < 1) {
@@ -2446,7 +2446,7 @@ static void _php_image_create_from(INTERNAL_FUNCTION_PARAMETERS, int image_type,
                        RETURN_FALSE;
                }
        } else {
-               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &file, &file_len) == FAILURE) {
+               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &file, &file_len) == FAILURE) {
                        return;
                }
        }
@@ -4178,7 +4178,7 @@ PHP_FUNCTION(imagepsencodefont)
        char *enc, **enc_vector;
        int enc_len, *f_ind;
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &fnt, &enc, &enc_len) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rp"", &fnt, &enc, &enc_len) == FAILURE) {
                return;
        }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/gd/gd.c;h=d258c3dbc7862534762d3640688f1b980c031459;hb=4435b9142ff9813845d5c97ab29a5d637bedb257,https://git.php.net/?p=php-src.git;a=blob;f=ext/gd/gd.c;h=e5657f7424ab30c8f3ca7ec73e9201375d1fab39,1,"static void _php_image_create_from(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, gdImagePtr (*func_p)(), gdImagePtr (*ioctx_func_p)())
{
	char *file;
	int file_len;
	long srcx, srcy, width, height;
	gdImagePtr im = NULL;
	php_stream *stream;
	FILE * fp = NULL;
#ifdef HAVE_GD_JPG
        long ignore_warning;
 #endif
        if (image_type == PHP_GDIMG_TYPE_GD2PART) {
//flaw_line_below:
               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sllll"", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {
//fix_flaw_line_below:
//               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""pllll"", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {
                        return;
                }
                if (width < 1 || height < 1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Zero width or height not allowed"");
                        RETURN_FALSE;
                }
        } else {
//flaw_line_below:
               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &file, &file_len) == FAILURE) {
//fix_flaw_line_below:
//               if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &file, &file_len) == FAILURE) {
                        return;
                }
        }

	stream = php_stream_open_wrapper(file, ""rb"", REPORT_ERRORS|IGNORE_PATH|IGNORE_URL_WIN, NULL);
	if (stream == NULL)	{
		RETURN_FALSE;
	}

#ifndef USE_GD_IOCTX
	ioctx_func_p = NULL; /* don't allow sockets without IOCtx */
#endif

	if (image_type == PHP_GDIMG_TYPE_WEBP) {
		size_t buff_size;
		char *buff;

		/* needs to be malloc (persistent) - GD will free() it later */
		buff_size = php_stream_copy_to_mem(stream, &buff, PHP_STREAM_COPY_ALL, 1);
		if (!buff_size) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING,""Cannot read image data"");
			goto out_err;
		}
		im = (*ioctx_func_p)(buff_size, buff);
		if (!im) {
			goto out_err;
		}
		goto register_im;
	}

	/* try and avoid allocating a FILE* if the stream is not naturally a FILE* */
	if (php_stream_is(stream, PHP_STREAM_IS_STDIO))	{
		if (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&fp, REPORT_ERRORS)) {
			goto out_err;
		}
	} else if (ioctx_func_p) {
#ifdef USE_GD_IOCTX
		/* we can create an io context */
		gdIOCtx* io_ctx;
		size_t buff_size;
		char *buff;

		/* needs to be malloc (persistent) - GD will free() it later */
		buff_size = php_stream_copy_to_mem(stream, &buff, PHP_STREAM_COPY_ALL, 1);

		if (!buff_size) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING,""Cannot read image data"");
			goto out_err;
		}

		io_ctx = gdNewDynamicCtxEx(buff_size, buff, 0);
		if (!io_ctx) {
			pefree(buff, 1);
			php_error_docref(NULL TSRMLS_CC, E_WARNING,""Cannot allocate GD IO context"");
			goto out_err;
		}

		if (image_type == PHP_GDIMG_TYPE_GD2PART) {
			im = (*ioctx_func_p)(io_ctx, srcx, srcy, width, height);
		} else {
			im = (*ioctx_func_p)(io_ctx);
		}
#if HAVE_LIBGD204
		io_ctx->gd_free(io_ctx);
#else
		io_ctx->free(io_ctx);
#endif
		pefree(buff, 1);
#endif
	}
	else {
		/* try and force the stream to be FILE* */
		if (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO | PHP_STREAM_CAST_TRY_HARD, (void **) &fp, REPORT_ERRORS)) {
			goto out_err;
		}
	}

	if (!im && fp) {
		switch (image_type) {
			case PHP_GDIMG_TYPE_GD2PART:
				im = (*func_p)(fp, srcx, srcy, width, height);
				break;
#if defined(HAVE_GD_XPM) && defined(HAVE_GD_BUNDLED)
			case PHP_GDIMG_TYPE_XPM:
				im = gdImageCreateFromXpm(file);
				break;
#endif

#ifdef HAVE_GD_JPG
			case PHP_GDIMG_TYPE_JPG:
				ignore_warning = INI_INT(""gd.jpeg_ignore_warning"");
#ifdef HAVE_GD_BUNDLED
				im = gdImageCreateFromJpeg(fp, ignore_warning);
#else
				im = gdImageCreateFromJpeg(fp);
#endif
			break;
#endif

			default:
				im = (*func_p)(fp);
				break;
		}

		fflush(fp);
	}

register_im:
	if (im) {
		ZEND_REGISTER_RESOURCE(return_value, im, le_gd);
		php_stream_close(stream);
		return;
	}

	php_error_docref(NULL TSRMLS_CC, E_WARNING, ""'%s' is not a valid %s file"", file, tn);
out_err:
	php_stream_close(stream);
	RETURN_FALSE;

}
"
750,178486,,Remote,Not required,,CVE-2015-3412,https://www.cvedetails.com/cve/CVE-2015-3412/,CWE-254,Low,Partial,,,2016-05-16,5.0,"PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read arbitrary files via crafted input to an application that calls the stream_resolve_include_path function in ext/standard/streamsfuncs.c, as demonstrated by a filename\0.extension attack that bypasses an intended configuration in which client users may read files with only one specific extension.",2019-04-22,Bypass,1,https://git.php.net/?p=php-src.git;a=commit;h=4435b9142ff9813845d5c97ab29a5d637bedb257,4435b9142ff9813845d5c97ab29a5d637bedb257,,1,,,"PHP_FUNCTION(pg_trace)
{
	char *z_filename, *mode = ""w"";
	int z_filename_len, mode_len;
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	FILE *fp = NULL;
        php_stream *stream;
        id = PGG(default_link);
 
       if (zend_parse_parameters(argc TSRMLS_CC, ""p|sr"", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {
                return;
        }
	if (argc < 3) {
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	stream = php_stream_open_wrapper(z_filename, mode, REPORT_ERRORS, NULL);

	if (!stream) {
		RETURN_FALSE;
	}

	if (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&fp, REPORT_ERRORS))	{
		php_stream_close(stream);
		RETURN_FALSE;
	}
	php_stream_auto_cleanup(stream);
	PQtrace(pgsql, fp);
	RETURN_TRUE;
}
","PHP_FUNCTION(pg_trace)
{
	char *z_filename, *mode = ""w"";
	int z_filename_len, mode_len;
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	FILE *fp = NULL;
        php_stream *stream;
        id = PGG(default_link);
 
       if (zend_parse_parameters(argc TSRMLS_CC, ""s|sr"", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {
                return;
        }
	if (argc < 3) {
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	stream = php_stream_open_wrapper(z_filename, mode, REPORT_ERRORS, NULL);

	if (!stream) {
		RETURN_FALSE;
	}

	if (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&fp, REPORT_ERRORS))	{
		php_stream_close(stream);
		RETURN_FALSE;
	}
	php_stream_auto_cleanup(stream);
	PQtrace(pgsql, fp);
	RETURN_TRUE;
}
",C,"       if (zend_parse_parameters(argc TSRMLS_CC, ""p|sr"", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {
","       if (zend_parse_parameters(argc TSRMLS_CC, ""s|sr"", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {
",9faaee66fa493372c7340b1ab05f8fd115131a42,"@@ -3014,7 +3014,7 @@ PHP_FUNCTION(pg_trace)
        php_stream *stream;
        id = PGG(default_link);
 
-       if (zend_parse_parameters(argc TSRMLS_CC, ""s|sr"", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {
+       if (zend_parse_parameters(argc TSRMLS_CC, ""p|sr"", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {
                return;
        }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/pgsql/pgsql.c;h=cd51143c903be8f8cb5552a77a2845a31c49d927;hb=4435b9142ff9813845d5c97ab29a5d637bedb257,https://git.php.net/?p=php-src.git;a=blob;f=ext/pgsql/pgsql.c;h=eb557777583f15e591c45ae9f43578ee6be85db4,1,"PHP_FUNCTION(pg_trace)
{
	char *z_filename, *mode = ""w"";
	int z_filename_len, mode_len;
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	FILE *fp = NULL;
        php_stream *stream;
        id = PGG(default_link);
 
//flaw_line_below:
       if (zend_parse_parameters(argc TSRMLS_CC, ""s|sr"", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {
//fix_flaw_line_below:
//       if (zend_parse_parameters(argc TSRMLS_CC, ""p|sr"", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {
                return;
        }
	if (argc < 3) {
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	stream = php_stream_open_wrapper(z_filename, mode, REPORT_ERRORS, NULL);

	if (!stream) {
		RETURN_FALSE;
	}

	if (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&fp, REPORT_ERRORS))	{
		php_stream_close(stream);
		RETURN_FALSE;
	}
	php_stream_auto_cleanup(stream);
	PQtrace(pgsql, fp);
	RETURN_TRUE;
}
"
751,178487,,Remote,Not required,,CVE-2015-3412,https://www.cvedetails.com/cve/CVE-2015-3412/,CWE-254,Low,Partial,,,2016-05-16,5.0,"PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read arbitrary files via crafted input to an application that calls the stream_resolve_include_path function in ext/standard/streamsfuncs.c, as demonstrated by a filename\0.extension attack that bypasses an intended configuration in which client users may read files with only one specific extension.",2019-04-22,Bypass,1,https://git.php.net/?p=php-src.git;a=commit;h=4435b9142ff9813845d5c97ab29a5d637bedb257,4435b9142ff9813845d5c97ab29a5d637bedb257,,1,,,"static void php_pgsql_do_connect(INTERNAL_FUNCTION_PARAMETERS, int persistent)
{
	char *host=NULL,*port=NULL,*options=NULL,*tty=NULL,*dbname=NULL,*connstring=NULL;
	PGconn *pgsql;
	smart_str str = {0};
	zval **args[5];
	int i, connect_type = 0;
	PGresult *pg_result;

	if (ZEND_NUM_ARGS() < 1 || ZEND_NUM_ARGS() > 5
			|| zend_get_parameters_array_ex(ZEND_NUM_ARGS(), args) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	smart_str_appends(&str, ""pgsql"");
	
	for (i = 0; i < ZEND_NUM_ARGS(); i++) {
		/* make sure that the PGSQL_CONNECT_FORCE_NEW bit is not part of the hash so that subsequent connections
		 * can re-use this connection. Bug #39979
		 */ 
		if (i == 1 && ZEND_NUM_ARGS() == 2 && Z_TYPE_PP(args[i]) == IS_LONG) {
			if (Z_LVAL_PP(args[1]) == PGSQL_CONNECT_FORCE_NEW) {
				continue;
			} else if (Z_LVAL_PP(args[1]) & PGSQL_CONNECT_FORCE_NEW) {
				smart_str_append_long(&str, Z_LVAL_PP(args[1]) ^ PGSQL_CONNECT_FORCE_NEW);
			}
		}
		convert_to_string_ex(args[i]);
		smart_str_appendc(&str, '_');
		smart_str_appendl(&str, Z_STRVAL_PP(args[i]), Z_STRLEN_PP(args[i]));
	}

	smart_str_0(&str);

	if (ZEND_NUM_ARGS() == 1) { /* new style, using connection string */
		connstring = Z_STRVAL_PP(args[0]);
	} else if (ZEND_NUM_ARGS() == 2 ) { /* Safe to add conntype_option, since 2 args was illegal */
		connstring = Z_STRVAL_PP(args[0]);
		convert_to_long_ex(args[1]);
		connect_type = Z_LVAL_PP(args[1]);
	} else {
		host = Z_STRVAL_PP(args[0]);
		port = Z_STRVAL_PP(args[1]);
		dbname = Z_STRVAL_PP(args[ZEND_NUM_ARGS()-1]);

		switch (ZEND_NUM_ARGS()) {
		case 5:
			tty = Z_STRVAL_PP(args[3]);
			/* fall through */
		case 4:
			options = Z_STRVAL_PP(args[2]);
			break;
		}
	}

	if (persistent && PGG(allow_persistent)) {
		zend_rsrc_list_entry *le;
		
		/* try to find if we already have this link in our persistent list */
		if (zend_hash_find(&EG(persistent_list), str.c, str.len+1, (void **) &le)==FAILURE) {  /* we don't */
			zend_rsrc_list_entry new_le;
			
			if (PGG(max_links)!=-1 && PGG(num_links)>=PGG(max_links)) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,
								 ""Cannot create new link. Too many open links (%ld)"", PGG(num_links));
				goto err;
			}
			if (PGG(max_persistent)!=-1 && PGG(num_persistent)>=PGG(max_persistent)) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,
								 ""Cannot create new link. Too many open persistent links (%ld)"", PGG(num_persistent));
				goto err;
			}

			/* create the link */
			if (connstring) {
				pgsql=PQconnectdb(connstring);
			} else {
				pgsql=PQsetdb(host,port,options,tty,dbname);
			}
			if (pgsql==NULL || PQstatus(pgsql)==CONNECTION_BAD) {
				PHP_PQ_ERROR(""Unable to connect to PostgreSQL server: %s"", pgsql)
				if (pgsql) {
					PQfinish(pgsql);
				}
				goto err;
			}

			/* hash it up */
			Z_TYPE(new_le) = le_plink;
			new_le.ptr = pgsql;
			if (zend_hash_update(&EG(persistent_list), str.c, str.len+1, (void *) &new_le, sizeof(zend_rsrc_list_entry), NULL)==FAILURE) {
				goto err;
			}
			PGG(num_links)++;
			PGG(num_persistent)++;
		} else {  /* we do */
			if (Z_TYPE_P(le) != le_plink) {
				RETURN_FALSE;
			}
			/* ensure that the link did not die */
			if (PGG(auto_reset_persistent) & 1) {
				/* need to send & get something from backend to
				   make sure we catch CONNECTION_BAD everytime */
				PGresult *pg_result;
				pg_result = PQexec(le->ptr, ""select 1"");
				PQclear(pg_result);
			}
			if (PQstatus(le->ptr)==CONNECTION_BAD) { /* the link died */
				if (le->ptr == NULL) {
					if (connstring) {
						le->ptr=PQconnectdb(connstring);
					} else {
						le->ptr=PQsetdb(host,port,options,tty,dbname);
					}
				}
				else {
					PQreset(le->ptr);
				}
				if (le->ptr==NULL || PQstatus(le->ptr)==CONNECTION_BAD) {
					php_error_docref(NULL TSRMLS_CC, E_WARNING,""PostgreSQL link lost, unable to reconnect"");
					zend_hash_del(&EG(persistent_list),str.c,str.len+1);
					goto err;
				}
			}
			pgsql = (PGconn *) le->ptr;
#if HAVE_PQPROTOCOLVERSION && HAVE_PQPARAMETERSTATUS
			if (PQprotocolVersion(pgsql) >= 3 && atof(PQparameterStatus(pgsql, ""server_version"")) >= 7.2) {
#else
			if (atof(PG_VERSION) >= 7.2) {
#endif
				pg_result = PQexec(pgsql, ""RESET ALL;"");
				PQclear(pg_result);
			}
		}
		ZEND_REGISTER_RESOURCE(return_value, pgsql, le_plink);
	} else { /* Non persistent connection */
		zend_rsrc_list_entry *index_ptr,new_index_ptr;

		/* first we check the hash for the hashed_details key.  if it exists,
		 * it should point us to the right offset where the actual pgsql link sits.
		 * if it doesn't, open a new pgsql link, add it to the resource list,
		 * and add a pointer to it with hashed_details as the key.
		 */
		if (!(connect_type & PGSQL_CONNECT_FORCE_NEW)
			&& zend_hash_find(&EG(regular_list),str.c,str.len+1,(void **) &index_ptr)==SUCCESS) {
			int type;
			ulong link;
			void *ptr;

			if (Z_TYPE_P(index_ptr) != le_index_ptr) {
				RETURN_FALSE;
			}
			link = (ulong) index_ptr->ptr;
			ptr = zend_list_find(link,&type);   /* check if the link is still there */
			if (ptr && (type==le_link || type==le_plink)) {
				Z_LVAL_P(return_value) = link;
				zend_list_addref(link);
				php_pgsql_set_default_link(link TSRMLS_CC);
				Z_TYPE_P(return_value) = IS_RESOURCE;
				goto cleanup;
			} else {
				zend_hash_del(&EG(regular_list),str.c,str.len+1);
			}
		}
		if (PGG(max_links)!=-1 && PGG(num_links)>=PGG(max_links)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Cannot create new link. Too many open links (%ld)"", PGG(num_links));
			goto err;
		}
		if (connstring) {
			pgsql = PQconnectdb(connstring);
		} else {
			pgsql = PQsetdb(host,port,options,tty,dbname);
		}
		if (pgsql==NULL || PQstatus(pgsql)==CONNECTION_BAD) {
			PHP_PQ_ERROR(""Unable to connect to PostgreSQL server: %s"", pgsql);
			if (pgsql) {
				PQfinish(pgsql);
			}
			goto err;
		}

		/* add it to the list */
		ZEND_REGISTER_RESOURCE(return_value, pgsql, le_link);

		/* add it to the hash */
		new_index_ptr.ptr = (void *) Z_LVAL_P(return_value);
		Z_TYPE(new_index_ptr) = le_index_ptr;
		if (zend_hash_update(&EG(regular_list),str.c,str.len+1,(void *) &new_index_ptr, sizeof(zend_rsrc_list_entry), NULL)==FAILURE) {
			goto err;
		}
		PGG(num_links)++;
	}
	/* set notice processer */
	if (! PGG(ignore_notices) && Z_TYPE_P(return_value) == IS_RESOURCE) {
		PQsetNoticeProcessor(pgsql, _php_pgsql_notice_handler, (void*)Z_RESVAL_P(return_value));
	}
	php_pgsql_set_default_link(Z_LVAL_P(return_value) TSRMLS_CC);
	
cleanup:
	smart_str_free(&str);
	return;

err:
	smart_str_free(&str);
	RETURN_FALSE;
}
/* }}} */

#if 0
/* {{{ php_pgsql_get_default_link
 */
static int php_pgsql_get_default_link(INTERNAL_FUNCTION_PARAMETERS)
{
	if (PGG(default_link)==-1) { /* no link opened yet, implicitly open one */
		ht = 0;
		php_pgsql_do_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU,0);
	}
	return PGG(default_link);
}
/* }}} */
#endif

/* {{{ proto resource pg_connect(string connection_string[, int connect_type] | [string host, string port [, string options [, string tty,]]] string database)
   Open a PostgreSQL connection */
PHP_FUNCTION(pg_connect)
{
	php_pgsql_do_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU,0);
}
/* }}} */

/* {{{ proto resource pg_pconnect(string connection_string | [string host, string port [, string options [, string tty,]]] string database)
   Open a persistent PostgreSQL connection */
PHP_FUNCTION(pg_pconnect)
{
	php_pgsql_do_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU,1);
}
/* }}} */

/* {{{ proto bool pg_close([resource connection])
   Close a PostgreSQL connection */ 
PHP_FUNCTION(pg_close)
{
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;

	if (zend_parse_parameters(argc TSRMLS_CC, ""|r"", &pgsql_link) == FAILURE) {
		return;
	}

	if (argc == 0) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (id==-1) { /* explicit resource number */
		zend_list_delete(Z_RESVAL_P(pgsql_link));
	}

	if (id!=-1
		|| (pgsql_link && Z_RESVAL_P(pgsql_link)==PGG(default_link))) {
		zend_list_delete(PGG(default_link));
		PGG(default_link) = -1;
	}

	RETURN_TRUE;
}
/* }}} */


#define PHP_PG_DBNAME 1
#define PHP_PG_ERROR_MESSAGE 2
#define PHP_PG_OPTIONS 3
#define PHP_PG_PORT 4
#define PHP_PG_TTY 5
#define PHP_PG_HOST 6
#define PHP_PG_VERSION 7


/* {{{ php_pgsql_get_link_info
 */
static void php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAMETERS, int entry_type)
{
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	char *msgbuf;

	if (zend_parse_parameters(argc TSRMLS_CC, ""|r"", &pgsql_link) == FAILURE) {
		return;
	}
	
	if (argc == 0) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	
	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	switch(entry_type) {
		case PHP_PG_DBNAME:
			Z_STRVAL_P(return_value) = PQdb(pgsql);
			break;
		case PHP_PG_ERROR_MESSAGE:
			RETURN_STRING(PQErrorMessageTrim(pgsql, &msgbuf), 0);
			return;
		case PHP_PG_OPTIONS:
			Z_STRVAL_P(return_value) = PQoptions(pgsql);
			break;
		case PHP_PG_PORT:
			Z_STRVAL_P(return_value) = PQport(pgsql);
			break;
		case PHP_PG_TTY:
			Z_STRVAL_P(return_value) = PQtty(pgsql);
			break;
		case PHP_PG_HOST:
			Z_STRVAL_P(return_value) = PQhost(pgsql);
			break;
		case PHP_PG_VERSION:
			array_init(return_value);
			add_assoc_string(return_value, ""client"", PG_VERSION, 1);
#if HAVE_PQPROTOCOLVERSION
			add_assoc_long(return_value, ""protocol"", PQprotocolVersion(pgsql));
#if HAVE_PQPARAMETERSTATUS
			if (PQprotocolVersion(pgsql) >= 3) {
				add_assoc_string(return_value, ""server"", (char*)PQparameterStatus(pgsql, ""server_version""), 1);
			}
#endif
#endif
			return;
		default:
			RETURN_FALSE;
	}
	if (Z_STRVAL_P(return_value)) {
		Z_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));
		Z_STRVAL_P(return_value) = (char *) estrdup(Z_STRVAL_P(return_value));
	} else {
		Z_STRLEN_P(return_value) = 0;
		Z_STRVAL_P(return_value) = (char *) estrdup("""");
	}
	Z_TYPE_P(return_value) = IS_STRING;
}
/* }}} */

/* {{{ proto string pg_dbname([resource connection])
   Get the database name */ 
PHP_FUNCTION(pg_dbname)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_DBNAME);
}
/* }}} */

/* {{{ proto string pg_last_error([resource connection])
   Get the error message string */
PHP_FUNCTION(pg_last_error)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_ERROR_MESSAGE);
}
/* }}} */

/* {{{ proto string pg_options([resource connection])
   Get the options associated with the connection */
PHP_FUNCTION(pg_options)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_OPTIONS);
}
/* }}} */

/* {{{ proto int pg_port([resource connection])
   Return the port number associated with the connection */
PHP_FUNCTION(pg_port)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_PORT);
}
/* }}} */

/* {{{ proto string pg_tty([resource connection])
   Return the tty name associated with the connection */
PHP_FUNCTION(pg_tty)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_TTY);
}
/* }}} */

/* {{{ proto string pg_host([resource connection])
   Returns the host name associated with the connection */
PHP_FUNCTION(pg_host)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_HOST);
}
/* }}} */

/* {{{ proto array pg_version([resource connection])
   Returns an array with client, protocol and server version (when available) */
PHP_FUNCTION(pg_version)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_VERSION);
}
/* }}} */

#if HAVE_PQPARAMETERSTATUS
/* {{{ proto string|false pg_parameter_status([resource connection,] string param_name)
   Returns the value of a server parameter */
PHP_FUNCTION(pg_parameter_status)
{
	zval *pgsql_link;
	int id;
	PGconn *pgsql;
	char *param;
	int len;

	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &pgsql_link, &param, &len) == SUCCESS) {
		id = -1;
	} else if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &param, &len) == SUCCESS) {
		pgsql_link = NULL;
		id = PGG(default_link);
	} else {
		RETURN_FALSE;
	}
	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	param = (char*)PQparameterStatus(pgsql, param);
	if (param) {
		RETURN_STRING(param, 1);
	} else {
		RETURN_FALSE;
	}
}
/* }}} */
#endif

/* {{{ proto bool pg_ping([resource connection])
   Ping database. If connection is bad, try to reconnect. */
PHP_FUNCTION(pg_ping)
{
	zval *pgsql_link;
	int id;
	PGconn *pgsql;
	PGresult *res;

	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &pgsql_link) == SUCCESS) {
		id = -1;
	} else {
		pgsql_link = NULL;
		id = PGG(default_link);
	}
	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	/* ping connection */
	res = PQexec(pgsql, ""SELECT 1;"");
	PQclear(res);

	/* check status. */
	if (PQstatus(pgsql) == CONNECTION_OK)
		RETURN_TRUE;

	/* reset connection if it's broken */
	PQreset(pgsql);
	if (PQstatus(pgsql) == CONNECTION_OK) {
		RETURN_TRUE;
	}
	RETURN_FALSE;
}
/* }}} */

/* {{{ proto resource pg_query([resource connection,] string query)
   Execute a query */
PHP_FUNCTION(pg_query)
{
	zval *pgsql_link = NULL;
	char *query;
	int id = -1, query_len, argc = ZEND_NUM_ARGS();
	int leftover = 0;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	pgsql_result_handle *pg_result;

	if (argc == 1) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &query, &query_len) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &pgsql_link, &query, &query_len) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (PQ_SETNONBLOCKING(pgsql, 0)) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE,""Cannot set connection to blocking mode"");
		RETURN_FALSE;
	}
	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
		leftover = 1;
	}
	if (leftover) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found results on this connection. Use pg_get_result() to get these results first"");
	}
	pgsql_result = PQexec(pgsql, query);
	if ((PGG(auto_reset_persistent) & 2) && PQstatus(pgsql) != CONNECTION_OK) {
		PQclear(pgsql_result);
		PQreset(pgsql);
		pgsql_result = PQexec(pgsql, query);
	}

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}

	switch (status) {
		case PGRES_EMPTY_QUERY:
		case PGRES_BAD_RESPONSE:
		case PGRES_NONFATAL_ERROR:
		case PGRES_FATAL_ERROR:
			PHP_PQ_ERROR(""Query failed: %s"", pgsql);
			PQclear(pgsql_result);
			RETURN_FALSE;
			break;
		case PGRES_COMMAND_OK: /* successful command that did not return rows */
		default:
			if (pgsql_result) {
				pg_result = (pgsql_result_handle *) emalloc(sizeof(pgsql_result_handle));
				pg_result->conn = pgsql;
				pg_result->result = pgsql_result;
				pg_result->row = 0;
				ZEND_REGISTER_RESOURCE(return_value, pg_result, le_result);
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			break;
	}
}
/* }}} */

#if HAVE_PQEXECPARAMS || HAVE_PQEXECPREPARED || HAVE_PQSENDQUERYPARAMS || HAVE_PQSENDQUERYPREPARED
/* {{{ _php_pgsql_free_params */
static void _php_pgsql_free_params(char **params, int num_params)
{
	if (num_params > 0) {
		int i;
		for (i = 0; i < num_params; i++) {
			if (params[i]) {
				efree(params[i]);
			}
		}
		efree(params);
	}
}
/* }}} */
#endif

#if HAVE_PQEXECPARAMS
/* {{{ proto resource pg_query_params([resource connection,] string query, array params)
   Execute a query */
PHP_FUNCTION(pg_query_params)
{
	zval *pgsql_link = NULL;
	zval *pv_param_arr, **tmp;
	char *query;
	int query_len, id = -1, argc = ZEND_NUM_ARGS();
	int leftover = 0;
	int num_params = 0;
	char **params = NULL;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	pgsql_result_handle *pg_result;
	
	if (argc == 2) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""sa"", &query, &query_len, &pv_param_arr) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rsa"", &pgsql_link, &query, &query_len, &pv_param_arr) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (PQ_SETNONBLOCKING(pgsql, 0)) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE,""Cannot set connection to blocking mode"");
		RETURN_FALSE;
	}
	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
		leftover = 1;
	}
	if (leftover) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found results on this connection. Use pg_get_result() to get these results first"");
	}

	zend_hash_internal_pointer_reset(Z_ARRVAL_P(pv_param_arr));
	num_params = zend_hash_num_elements(Z_ARRVAL_P(pv_param_arr));
	if (num_params > 0) {
		int i = 0;
		params = (char **)safe_emalloc(sizeof(char *), num_params, 0);

		for(i = 0; i < num_params; i++) {
			if (zend_hash_get_current_data(Z_ARRVAL_P(pv_param_arr), (void **) &tmp) == FAILURE) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,""Error getting parameter"");
				_php_pgsql_free_params(params, num_params);
				RETURN_FALSE;
			}

			if (Z_TYPE_PP(tmp) == IS_NULL) {
				params[i] = NULL;
			} else {
				zval tmp_val = **tmp;
				zval_copy_ctor(&tmp_val);
				convert_to_string(&tmp_val);
				if (Z_TYPE(tmp_val) != IS_STRING) {
					php_error_docref(NULL TSRMLS_CC, E_WARNING,""Error converting parameter"");
					zval_dtor(&tmp_val);
					_php_pgsql_free_params(params, num_params);
					RETURN_FALSE;
				}
				params[i] = estrndup(Z_STRVAL(tmp_val), Z_STRLEN(tmp_val));
				zval_dtor(&tmp_val);
			}

			zend_hash_move_forward(Z_ARRVAL_P(pv_param_arr));
		}
	}

	pgsql_result = PQexecParams(pgsql, query, num_params, 
					NULL, (const char * const *)params, NULL, NULL, 0);
	if ((PGG(auto_reset_persistent) & 2) && PQstatus(pgsql) != CONNECTION_OK) {
		PQclear(pgsql_result);
		PQreset(pgsql);
		pgsql_result = PQexecParams(pgsql, query, num_params, 
						NULL, (const char * const *)params, NULL, NULL, 0);
	}

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}
	
	_php_pgsql_free_params(params, num_params);

	switch (status) {
		case PGRES_EMPTY_QUERY:
		case PGRES_BAD_RESPONSE:
		case PGRES_NONFATAL_ERROR:
		case PGRES_FATAL_ERROR:
			PHP_PQ_ERROR(""Query failed: %s"", pgsql);
			PQclear(pgsql_result);
			RETURN_FALSE;
			break;
		case PGRES_COMMAND_OK: /* successful command that did not return rows */
		default:
			if (pgsql_result) {
				pg_result = (pgsql_result_handle *) emalloc(sizeof(pgsql_result_handle));
				pg_result->conn = pgsql;
				pg_result->result = pgsql_result;
				pg_result->row = 0;
				ZEND_REGISTER_RESOURCE(return_value, pg_result, le_result);
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			break;
	}
}
/* }}} */
#endif

#if HAVE_PQPREPARE
/* {{{ proto resource pg_prepare([resource connection,] string stmtname, string query)
   Prepare a query for future execution */
PHP_FUNCTION(pg_prepare)
{
	zval *pgsql_link = NULL;
	char *query, *stmtname;
	int query_len, stmtname_len, id = -1, argc = ZEND_NUM_ARGS();
	int leftover = 0;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	pgsql_result_handle *pg_result;

	if (argc == 2) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""ss"", &stmtname, &stmtname_len, &query, &query_len) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rss"", &pgsql_link, &stmtname, &stmtname_len, &query, &query_len) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (PQ_SETNONBLOCKING(pgsql, 0)) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE,""Cannot set connection to blocking mode"");
		RETURN_FALSE;
	}
	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
		leftover = 1;
	}
	if (leftover) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found results on this connection. Use pg_get_result() to get these results first"");
	}
	pgsql_result = PQprepare(pgsql, stmtname, query, 0, NULL);
	if ((PGG(auto_reset_persistent) & 2) && PQstatus(pgsql) != CONNECTION_OK) {
		PQclear(pgsql_result);
		PQreset(pgsql);
		pgsql_result = PQprepare(pgsql, stmtname, query, 0, NULL);
	}

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}

	switch (status) {
		case PGRES_EMPTY_QUERY:
		case PGRES_BAD_RESPONSE:
		case PGRES_NONFATAL_ERROR:
		case PGRES_FATAL_ERROR:
			PHP_PQ_ERROR(""Query failed: %s"", pgsql);
			PQclear(pgsql_result);
			RETURN_FALSE;
			break;
		case PGRES_COMMAND_OK: /* successful command that did not return rows */
		default:
			if (pgsql_result) {
				pg_result = (pgsql_result_handle *) emalloc(sizeof(pgsql_result_handle));
				pg_result->conn = pgsql;
				pg_result->result = pgsql_result;
				pg_result->row = 0;
				ZEND_REGISTER_RESOURCE(return_value, pg_result, le_result);
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			break;
	}
}
/* }}} */
#endif

#if HAVE_PQEXECPREPARED
/* {{{ proto resource pg_execute([resource connection,] string stmtname, array params)
   Execute a prepared query  */
PHP_FUNCTION(pg_execute)
{
	zval *pgsql_link = NULL;
	zval *pv_param_arr, **tmp;
	char *stmtname;
	int stmtname_len, id = -1, argc = ZEND_NUM_ARGS();
	int leftover = 0;
	int num_params = 0;
	char **params = NULL;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	pgsql_result_handle *pg_result;

	if (argc == 2) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""sa/"", &stmtname, &stmtname_len, &pv_param_arr)==FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rsa/"", &pgsql_link, &stmtname, &stmtname_len, &pv_param_arr) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (PQ_SETNONBLOCKING(pgsql, 0)) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE,""Cannot set connection to blocking mode"");
		RETURN_FALSE;
	}
	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
		leftover = 1;
	}
	if (leftover) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found results on this connection. Use pg_get_result() to get these results first"");
	}

	zend_hash_internal_pointer_reset(Z_ARRVAL_P(pv_param_arr));
	num_params = zend_hash_num_elements(Z_ARRVAL_P(pv_param_arr));
	if (num_params > 0) {
		int i = 0;
		params = (char **)safe_emalloc(sizeof(char *), num_params, 0);

		for(i = 0; i < num_params; i++) {
			if (zend_hash_get_current_data(Z_ARRVAL_P(pv_param_arr), (void **) &tmp) == FAILURE) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,""Error getting parameter"");
				_php_pgsql_free_params(params, num_params);
				RETURN_FALSE;
			}

			if (Z_TYPE_PP(tmp) == IS_NULL) {
				params[i] = NULL;
			} else {
				zval tmp_val = **tmp;
				zval_copy_ctor(&tmp_val);
				convert_to_string(&tmp_val);
				if (Z_TYPE(tmp_val) != IS_STRING) {
					php_error_docref(NULL TSRMLS_CC, E_WARNING,""Error converting parameter"");
					zval_dtor(&tmp_val);
					_php_pgsql_free_params(params, num_params);
					RETURN_FALSE;
				}
				params[i] = estrndup(Z_STRVAL(tmp_val), Z_STRLEN(tmp_val));
				zval_dtor(&tmp_val);
			}

			zend_hash_move_forward(Z_ARRVAL_P(pv_param_arr));
		}
	}

	pgsql_result = PQexecPrepared(pgsql, stmtname, num_params, 
					(const char * const *)params, NULL, NULL, 0);
	if ((PGG(auto_reset_persistent) & 2) && PQstatus(pgsql) != CONNECTION_OK) {
		PQclear(pgsql_result);
		PQreset(pgsql);
		pgsql_result = PQexecPrepared(pgsql, stmtname, num_params, 
						(const char * const *)params, NULL, NULL, 0);
	}

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}

	_php_pgsql_free_params(params, num_params);

	switch (status) {
		case PGRES_EMPTY_QUERY:
		case PGRES_BAD_RESPONSE:
		case PGRES_NONFATAL_ERROR:
		case PGRES_FATAL_ERROR:
			PHP_PQ_ERROR(""Query failed: %s"", pgsql);
			PQclear(pgsql_result);
			RETURN_FALSE;
			break;
		case PGRES_COMMAND_OK: /* successful command that did not return rows */
		default:
			if (pgsql_result) {
				pg_result = (pgsql_result_handle *) emalloc(sizeof(pgsql_result_handle));
				pg_result->conn = pgsql;
				pg_result->result = pgsql_result;
				pg_result->row = 0;
				ZEND_REGISTER_RESOURCE(return_value, pg_result, le_result);
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			break;
	}
}
/* }}} */
#endif

#define PHP_PG_NUM_ROWS 1
#define PHP_PG_NUM_FIELDS 2
#define PHP_PG_CMD_TUPLES 3

/* {{{ php_pgsql_get_result_info
 */
static void php_pgsql_get_result_info(INTERNAL_FUNCTION_PARAMETERS, int entry_type)
{
	zval *result;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &result) == FAILURE) {
		return;
	}
	
	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;

	switch (entry_type) {
		case PHP_PG_NUM_ROWS:
			Z_LVAL_P(return_value) = PQntuples(pgsql_result);
			break;
		case PHP_PG_NUM_FIELDS:
			Z_LVAL_P(return_value) = PQnfields(pgsql_result);
			break;
		case PHP_PG_CMD_TUPLES:
#if HAVE_PQCMDTUPLES
			Z_LVAL_P(return_value) = atoi(PQcmdTuples(pgsql_result));
#else
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Not supported under this build"");
			Z_LVAL_P(return_value) = 0;
#endif
			break;
		default:
			RETURN_FALSE;
	}
	Z_TYPE_P(return_value) = IS_LONG;
}
/* }}} */

/* {{{ proto int pg_num_rows(resource result)
   Return the number of rows in the result */
PHP_FUNCTION(pg_num_rows)
{
	php_pgsql_get_result_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_NUM_ROWS);
}
/* }}} */

/* {{{ proto int pg_num_fields(resource result)
   Return the number of fields in the result */
PHP_FUNCTION(pg_num_fields)
{
	php_pgsql_get_result_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_NUM_FIELDS);
}
/* }}} */

#if HAVE_PQCMDTUPLES
/* {{{ proto int pg_affected_rows(resource result)
   Returns the number of affected tuples */
PHP_FUNCTION(pg_affected_rows)
{
	php_pgsql_get_result_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_CMD_TUPLES);
}
/* }}} */
#endif

/* {{{ proto string pg_last_notice(resource connection)
   Returns the last notice set by the backend */
PHP_FUNCTION(pg_last_notice) 
{
	zval *pgsql_link;
	PGconn *pg_link;
	int id = -1;
	php_pgsql_notice **notice;
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &pgsql_link) == FAILURE) {
		return;
	}
	/* Just to check if user passed valid resoruce */
	ZEND_FETCH_RESOURCE2(pg_link, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (zend_hash_index_find(&PGG(notices), Z_RESVAL_P(pgsql_link), (void **)&notice) == FAILURE) {
		RETURN_FALSE;
	}
	RETURN_STRINGL((*notice)->message, (*notice)->len, 1);
}
/* }}} */

/* {{{ get_field_name
 */
static char *get_field_name(PGconn *pgsql, Oid oid, HashTable *list TSRMLS_DC)
{
	PGresult *result;
	smart_str str = {0};
	zend_rsrc_list_entry *field_type;
	char *ret=NULL;

	/* try to lookup the type in the resource list */
	smart_str_appends(&str, ""pgsql_oid_"");
	smart_str_append_unsigned(&str, oid);
	smart_str_0(&str);

	if (zend_hash_find(list,str.c,str.len+1,(void **) &field_type)==SUCCESS) {
		ret = estrdup((char *)field_type->ptr);
	} else { /* hash all oid's */
		int i,num_rows;
		int oid_offset,name_offset;
		char *tmp_oid, *end_ptr, *tmp_name;
		zend_rsrc_list_entry new_oid_entry;

		if ((result = PQexec(pgsql,""select oid,typname from pg_type"")) == NULL || PQresultStatus(result) != PGRES_TUPLES_OK) {
			if (result) {
				PQclear(result);
			}
			smart_str_free(&str);
			return STR_EMPTY_ALLOC();
		}
		num_rows = PQntuples(result);
		oid_offset = PQfnumber(result,""oid"");
		name_offset = PQfnumber(result,""typname"");

		for (i=0; i<num_rows; i++) {
			if ((tmp_oid = PQgetvalue(result,i,oid_offset))==NULL) {
				continue;
			}
			
			str.len = 0;
			smart_str_appends(&str, ""pgsql_oid_"");
			smart_str_appends(&str, tmp_oid);
			smart_str_0(&str);

			if ((tmp_name = PQgetvalue(result,i,name_offset))==NULL) {
				continue;
			}
			Z_TYPE(new_oid_entry) = le_string;
			new_oid_entry.ptr = estrdup(tmp_name);
			zend_hash_update(list,str.c,str.len+1,(void *) &new_oid_entry, sizeof(zend_rsrc_list_entry), NULL);
			if (!ret && strtoul(tmp_oid, &end_ptr, 10)==oid) {
				ret = estrdup(tmp_name);
			}
		}
		PQclear(result);
	}

	smart_str_free(&str);
	return ret;
}
/* }}} */

#ifdef HAVE_PQFTABLE
/* {{{ proto mixed pg_field_table(resource result, int field_number[, bool oid_only])
   Returns the name of the table field belongs to, or table's oid if oid_only is true */
PHP_FUNCTION(pg_field_table)
{
	zval *result;
	pgsql_result_handle *pg_result;
	long fnum = -1;
	zend_bool return_oid = 0;
	Oid oid;
	smart_str hash_key = {0};
	char *table_name;
	zend_rsrc_list_entry *field_table;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl|b"", &result, &fnum, &return_oid) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	if (fnum < 0 || fnum >= PQnfields(pg_result->result)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Bad field offset specified"");
		RETURN_FALSE;
	}

	oid = PQftable(pg_result->result, fnum);

	if (InvalidOid == oid) {
		RETURN_FALSE;
	}

	if (return_oid) {
#if UINT_MAX > LONG_MAX /* Oid is unsigned int, we don't need this code, where LONG is wider */
		if (oid > LONG_MAX) {
			smart_str oidstr = {0};
			smart_str_append_unsigned(&oidstr, oid);
			smart_str_0(&oidstr);
			RETURN_STRINGL(oidstr.c, oidstr.len, 0);
		} else
#endif
			RETURN_LONG((long)oid);
	}

	/* try to lookup the table name in the resource list */
	smart_str_appends(&hash_key, ""pgsql_table_oid_"");
	smart_str_append_unsigned(&hash_key, oid);
	smart_str_0(&hash_key);

	if (zend_hash_find(&EG(regular_list), hash_key.c, hash_key.len+1, (void **) &field_table) == SUCCESS) {
		smart_str_free(&hash_key);
		RETURN_STRING((char *)field_table->ptr, 1);
	} else { /* Not found, lookup by querying PostgreSQL system tables */
		PGresult *tmp_res;
		smart_str querystr = {0};
		zend_rsrc_list_entry new_field_table;

		smart_str_appends(&querystr, ""select relname from pg_class where oid="");
		smart_str_append_unsigned(&querystr, oid);
		smart_str_0(&querystr);

		if ((tmp_res = PQexec(pg_result->conn, querystr.c)) == NULL || PQresultStatus(tmp_res) != PGRES_TUPLES_OK) {
			if (tmp_res) {
				PQclear(tmp_res);
			}
			smart_str_free(&querystr);
			smart_str_free(&hash_key);
			RETURN_FALSE;
		}

		smart_str_free(&querystr);

		if ((table_name = PQgetvalue(tmp_res, 0, 0)) == NULL) {
			PQclear(tmp_res);
			smart_str_free(&hash_key);
			RETURN_FALSE;
		}

		Z_TYPE(new_field_table) = le_string;
		new_field_table.ptr = estrdup(table_name);
		zend_hash_update(&EG(regular_list), hash_key.c, hash_key.len+1, (void *) &new_field_table, sizeof(zend_rsrc_list_entry), NULL);

		smart_str_free(&hash_key);
		PQclear(tmp_res);
		RETURN_STRING(table_name, 1);
	}

}
/* }}} */
#endif

#define PHP_PG_FIELD_NAME 1
#define PHP_PG_FIELD_SIZE 2
#define PHP_PG_FIELD_TYPE 3
#define PHP_PG_FIELD_TYPE_OID 4

/* {{{ php_pgsql_get_field_info
 */
static void php_pgsql_get_field_info(INTERNAL_FUNCTION_PARAMETERS, int entry_type)
{
	zval *result;
	long field;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;
	Oid oid;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl"", &result, &field) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;
	
	if (field < 0 || field >= PQnfields(pgsql_result)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Bad field offset specified"");
		RETURN_FALSE;
	}

	switch (entry_type) {
		case PHP_PG_FIELD_NAME:
			Z_STRVAL_P(return_value) = PQfname(pgsql_result, field);
			Z_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));
			Z_STRVAL_P(return_value) = estrndup(Z_STRVAL_P(return_value),Z_STRLEN_P(return_value));
			Z_TYPE_P(return_value) = IS_STRING;
			break;
		case PHP_PG_FIELD_SIZE:
			Z_LVAL_P(return_value) = PQfsize(pgsql_result, field);
			Z_TYPE_P(return_value) = IS_LONG;
			break;
		case PHP_PG_FIELD_TYPE:
			Z_STRVAL_P(return_value) = get_field_name(pg_result->conn, PQftype(pgsql_result, field), &EG(regular_list) TSRMLS_CC);
			Z_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));
			Z_TYPE_P(return_value) = IS_STRING;
			break;
		case PHP_PG_FIELD_TYPE_OID:
			
			oid = PQftype(pgsql_result, field);
#if UINT_MAX > LONG_MAX
			if (oid > LONG_MAX) {
				smart_str s = {0};
				smart_str_append_unsigned(&s, oid);
				smart_str_0(&s);
				Z_STRVAL_P(return_value) = s.c;
				Z_STRLEN_P(return_value) = s.len;
				Z_TYPE_P(return_value) = IS_STRING;
			} else
#endif
			{
				Z_LVAL_P(return_value) = (long)oid;
				Z_TYPE_P(return_value) = IS_LONG;
			}
			break;
		default:
			RETURN_FALSE;
	}
}
/* }}} */

/* {{{ proto string pg_field_name(resource result, int field_number)
   Returns the name of the field */
PHP_FUNCTION(pg_field_name)
{
	php_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_NAME);
}
/* }}} */

/* {{{ proto int pg_field_size(resource result, int field_number)
   Returns the internal size of the field */ 
PHP_FUNCTION(pg_field_size)
{
	php_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_SIZE);
}
/* }}} */

/* {{{ proto string pg_field_type(resource result, int field_number)
   Returns the type name for the given field */
PHP_FUNCTION(pg_field_type)
{
	php_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_TYPE);
}
/* }}} */


/* {{{ proto string pg_field_type_oid(resource result, int field_number)
   Returns the type oid for the given field */
PHP_FUNCTION(pg_field_type_oid)
{
	php_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_TYPE_OID);
}
/* }}} */

/* {{{ proto int pg_field_num(resource result, string field_name)
   Returns the field number of the named field */
PHP_FUNCTION(pg_field_num)
{
	zval *result;
	char *field;
	int field_len;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &result, &field, &field_len) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;

	Z_LVAL_P(return_value) = PQfnumber(pgsql_result, field);
	Z_TYPE_P(return_value) = IS_LONG;
}
/* }}} */

/* {{{ proto mixed pg_fetch_result(resource result, [int row_number,] mixed field_name)
   Returns values from a result identifier */
PHP_FUNCTION(pg_fetch_result)
{
	zval *result, **field=NULL;
	long row;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;
	int field_offset, pgsql_row, argc = ZEND_NUM_ARGS();

	if (argc == 2) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rZ"", &result, &field) == FAILURE) {
			return;
		}
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rlZ"", &result, &row, &field) == FAILURE) {
			return;
		}
	}
	
	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;
	if (argc == 2) {
		if (pg_result->row < 0) {
			pg_result->row = 0;
		}
		pgsql_row = pg_result->row;
		if (pgsql_row >= PQntuples(pgsql_result)) {
			RETURN_FALSE;
		}
	} else {
		pgsql_row = row;
		if (pgsql_row < 0 || pgsql_row >= PQntuples(pgsql_result)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to jump to row %ld on PostgreSQL result index %ld"",
							row, Z_LVAL_P(result));
			RETURN_FALSE;
		}
	}
	switch(Z_TYPE_PP(field)) {
		case IS_STRING:
			field_offset = PQfnumber(pgsql_result, Z_STRVAL_PP(field));
			break;
		default:
			convert_to_long_ex(field);
			field_offset = Z_LVAL_PP(field);
			break;
	}
	if (field_offset<0 || field_offset>=PQnfields(pgsql_result)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Bad column offset specified"");
		RETURN_FALSE;
	}

	if (PQgetisnull(pgsql_result, pgsql_row, field_offset)) {
		Z_TYPE_P(return_value) = IS_NULL;
	} else {
		char *value = PQgetvalue(pgsql_result, pgsql_row, field_offset);
		int value_len = PQgetlength(pgsql_result, pgsql_row, field_offset);
		ZVAL_STRINGL(return_value, value, value_len, 1);
	}
}
/* }}} */

/* {{{ void php_pgsql_fetch_hash */
static void php_pgsql_fetch_hash(INTERNAL_FUNCTION_PARAMETERS, long result_type, int into_object)
{
	zval                *result, *zrow = NULL;
	PGresult            *pgsql_result;
	pgsql_result_handle *pg_result;
	int             i, num_fields, pgsql_row, use_row;
	long            row = -1;
	char            *field_name;
	zval            *ctor_params = NULL;
	zend_class_entry *ce = NULL;

	if (into_object) {
		char *class_name = NULL;
		int class_name_len;

		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r|z!sz"", &result, &zrow, &class_name, &class_name_len, &ctor_params) == FAILURE) {
			return;
		}
		if (!class_name) {
			ce = zend_standard_class_def;
		} else {
			ce = zend_fetch_class(class_name, class_name_len, ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
		}
		if (!ce) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Could not find class '%s'"", class_name);
			return;
		}
		result_type = PGSQL_ASSOC;
	} else {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r|z!l"", &result, &zrow, &result_type) == FAILURE) {
			return;
		}
	}
	if (zrow == NULL) {
		row = -1;
	} else {
		convert_to_long(zrow);
		row = Z_LVAL_P(zrow);
		if (row < 0) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The row parameter must be greater or equal to zero"");
			RETURN_FALSE;
		}
	}
	use_row = ZEND_NUM_ARGS() > 1 && row != -1;

	if (!(result_type & PGSQL_BOTH)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid result type"");
		RETURN_FALSE;
	}
	
	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;

	if (use_row) { 
		pgsql_row = row;
		pg_result->row = pgsql_row;
		if (pgsql_row < 0 || pgsql_row >= PQntuples(pgsql_result)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to jump to row %ld on PostgreSQL result index %ld"",
							row, Z_LVAL_P(result));
			RETURN_FALSE;
		}
	} else {
		/* If 2nd param is NULL, use internal row counter to access next row */
		pgsql_row = pg_result->row;
		if (pgsql_row < 0 || pgsql_row >= PQntuples(pgsql_result)) {
			RETURN_FALSE;
		}
		pg_result->row++;
	}

	array_init(return_value);
	for (i = 0, num_fields = PQnfields(pgsql_result); i < num_fields; i++) {
		if (PQgetisnull(pgsql_result, pgsql_row, i)) {
			if (result_type & PGSQL_NUM) {
				add_index_null(return_value, i);
			}
			if (result_type & PGSQL_ASSOC) {
				field_name = PQfname(pgsql_result, i);
				add_assoc_null(return_value, field_name);
			}
		} else {
			char *element = PQgetvalue(pgsql_result, pgsql_row, i);
			if (element) {
				char *data;
				int data_len;
				int should_copy=0;
				const uint element_len = strlen(element);

				data = safe_estrndup(element, element_len);
				data_len = element_len;

				if (result_type & PGSQL_NUM) {
					add_index_stringl(return_value, i, data, data_len, should_copy);
					should_copy=1;
				}

				if (result_type & PGSQL_ASSOC) {
					field_name = PQfname(pgsql_result, i);
					add_assoc_stringl(return_value, field_name, data, data_len, should_copy);
				}
			}
		}
	}

	if (into_object) {
		zval dataset = *return_value;
		zend_fcall_info fci;
		zend_fcall_info_cache fcc;
		zval *retval_ptr;

		object_and_properties_init(return_value, ce, NULL);
		zend_merge_properties(return_value, Z_ARRVAL(dataset), 1 TSRMLS_CC);

		if (ce->constructor) {
			fci.size = sizeof(fci);
			fci.function_table = &ce->function_table;
			fci.function_name = NULL;
			fci.symbol_table = NULL;
			fci.object_ptr = return_value;
			fci.retval_ptr_ptr = &retval_ptr;
			if (ctor_params && Z_TYPE_P(ctor_params) != IS_NULL) {
				if (Z_TYPE_P(ctor_params) == IS_ARRAY) {
					HashTable *ht = Z_ARRVAL_P(ctor_params);
					Bucket *p;

					fci.param_count = 0;
					fci.params = safe_emalloc(sizeof(zval***), ht->nNumOfElements, 0);
					p = ht->pListHead;
					while (p != NULL) {
						fci.params[fci.param_count++] = (zval**)p->pData;
						p = p->pListNext;
					}
				} else {
					/* Two problems why we throw exceptions here: PHP is typeless
					 * and hence passing one argument that's not an array could be
					 * by mistake and the other way round is possible, too. The 
					 * single value is an array. Also we'd have to make that one
					 * argument passed by reference.
					 */
					zend_throw_exception(zend_exception_get_default(TSRMLS_C), ""Parameter ctor_params must be an array"", 0 TSRMLS_CC);
					return;
				}
			} else {
				fci.param_count = 0;
				fci.params = NULL;
			}
			fci.no_separation = 1;

			fcc.initialized = 1;
			fcc.function_handler = ce->constructor;
			fcc.calling_scope = EG(scope);
			fcc.called_scope = Z_OBJCE_P(return_value);
			fcc.object_ptr = return_value;

			if (zend_call_function(&fci, &fcc TSRMLS_CC) == FAILURE) {
				zend_throw_exception_ex(zend_exception_get_default(TSRMLS_C), 0 TSRMLS_CC, ""Could not execute %s::%s()"", ce->name, ce->constructor->common.function_name);
			} else {
				if (retval_ptr) {
					zval_ptr_dtor(&retval_ptr);
				}
			}
			if (fci.params) {
				efree(fci.params);
			}
		} else if (ctor_params) {
			zend_throw_exception_ex(zend_exception_get_default(TSRMLS_C), 0 TSRMLS_CC, ""Class %s does not have a constructor hence you cannot use ctor_params"", ce->name);
		}
	}
}
/* }}} */

/* {{{ proto array pg_fetch_row(resource result [, int row [, int result_type]])
   Get a row as an enumerated array */ 
PHP_FUNCTION(pg_fetch_row)
{
	php_pgsql_fetch_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, PGSQL_NUM, 0);
}
/* }}} */

/* {{{ proto array pg_fetch_assoc(resource result [, int row])
   Fetch a row as an assoc array */
PHP_FUNCTION(pg_fetch_assoc)
{
	/* pg_fetch_assoc() is added from PHP 4.3.0. It should raise error, when
	   there is 3rd parameter */
	if (ZEND_NUM_ARGS() > 2)
		WRONG_PARAM_COUNT;
	php_pgsql_fetch_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, PGSQL_ASSOC, 0);
}
/* }}} */

/* {{{ proto array pg_fetch_array(resource result [, int row [, int result_type]])
   Fetch a row as an array */
PHP_FUNCTION(pg_fetch_array)
{
	php_pgsql_fetch_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, PGSQL_BOTH, 0);
}
/* }}} */

/* {{{ proto object pg_fetch_object(resource result [, int row [, string class_name [, NULL|array ctor_params]]])
   Fetch a row as an object */
PHP_FUNCTION(pg_fetch_object)
{
	/* pg_fetch_object() allowed result_type used to be. 3rd parameter
	   must be allowed for compatibility */
	php_pgsql_fetch_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, PGSQL_ASSOC, 1);
}
/* }}} */

/* {{{ proto array pg_fetch_all(resource result)
   Fetch all rows into array */
PHP_FUNCTION(pg_fetch_all)
{
	zval *result;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &result) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;
	array_init(return_value);
	if (php_pgsql_result2array(pgsql_result, return_value TSRMLS_CC) == FAILURE) {
		zval_dtor(return_value);
		RETURN_FALSE;
	}
}
/* }}} */

/* {{{ proto array pg_fetch_all_columns(resource result [, int column_number])
   Fetch all rows into array */
PHP_FUNCTION(pg_fetch_all_columns)
{
	zval *result;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;
	unsigned long colno=0;
	int pg_numrows, pg_row;
	size_t num_fields;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r|l"", &result, &colno) == FAILURE) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;

	num_fields = PQnfields(pgsql_result);
	if (colno >= num_fields || colno < 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid column number '%ld'"", colno);
		RETURN_FALSE;
	}

	array_init(return_value);

	if ((pg_numrows = PQntuples(pgsql_result)) <= 0) {
		return;
	}

	for (pg_row = 0; pg_row < pg_numrows; pg_row++) {
		if (PQgetisnull(pgsql_result, pg_row, colno)) {
			add_next_index_null(return_value);
		} else {
			add_next_index_string(return_value, PQgetvalue(pgsql_result, pg_row, colno), 1); 
		}
	}
}
/* }}} */

/* {{{ proto bool pg_result_seek(resource result, int offset)
   Set internal row offset */
PHP_FUNCTION(pg_result_seek)
{
	zval *result;
	long row;
	pgsql_result_handle *pg_result;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl"", &result, &row) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	if (row < 0 || row >= PQntuples(pg_result->result)) {
		RETURN_FALSE;
	}

	/* seek to offset */
	pg_result->row = row;
	RETURN_TRUE;
}
/* }}} */


#define PHP_PG_DATA_LENGTH 1
#define PHP_PG_DATA_ISNULL 2

/* {{{ php_pgsql_data_info
 */
static void php_pgsql_data_info(INTERNAL_FUNCTION_PARAMETERS, int entry_type)
{
	zval *result, **field;
	long row;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;
	int field_offset, pgsql_row, argc = ZEND_NUM_ARGS();

	if (argc == 2) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rZ"", &result, &field) == FAILURE) {
			return;
		}
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rlZ"", &result, &row, &field) == FAILURE) {
			return;
		}
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;
	if (argc == 2) {
		if (pg_result->row < 0) {
			pg_result->row = 0;
		}
		pgsql_row = pg_result->row;
		if (pgsql_row < 0 || pgsql_row >= PQntuples(pgsql_result)) {
			RETURN_FALSE;
		}
	} else {
		pgsql_row = row;
		if (pgsql_row < 0 || pgsql_row >= PQntuples(pgsql_result)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to jump to row %ld on PostgreSQL result index %ld"",
							row, Z_LVAL_P(result));
			RETURN_FALSE;
		}
	}

	switch(Z_TYPE_PP(field)) {
		case IS_STRING:
			convert_to_string_ex(field);
			field_offset = PQfnumber(pgsql_result, Z_STRVAL_PP(field));
			break;
		default:
			convert_to_long_ex(field);
			field_offset = Z_LVAL_PP(field);
			break;
	}
	if (field_offset < 0 || field_offset >= PQnfields(pgsql_result)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Bad column offset specified"");
		RETURN_FALSE;
	}

	switch (entry_type) {
		case PHP_PG_DATA_LENGTH:
			Z_LVAL_P(return_value) = PQgetlength(pgsql_result, pgsql_row, field_offset);
			break;
		case PHP_PG_DATA_ISNULL:
			Z_LVAL_P(return_value) = PQgetisnull(pgsql_result, pgsql_row, field_offset);
			break;
	}
	Z_TYPE_P(return_value) = IS_LONG;
}
/* }}} */

/* {{{ proto int pg_field_prtlen(resource result, [int row,] mixed field_name_or_number)
   Returns the printed length */
PHP_FUNCTION(pg_field_prtlen)
{
	php_pgsql_data_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_PG_DATA_LENGTH);
}
/* }}} */

/* {{{ proto int pg_field_is_null(resource result, [int row,] mixed field_name_or_number)
   Test if a field is NULL */
PHP_FUNCTION(pg_field_is_null)
{
	php_pgsql_data_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_PG_DATA_ISNULL);
}
/* }}} */

/* {{{ proto bool pg_free_result(resource result)
   Free result memory */
PHP_FUNCTION(pg_free_result)
{
	zval *result;
	pgsql_result_handle *pg_result;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &result) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);
	if (Z_LVAL_P(result) == 0) {
		RETURN_FALSE;
	}
	zend_list_delete(Z_RESVAL_P(result));
	RETURN_TRUE;
}
/* }}} */

/* {{{ proto string pg_last_oid(resource result)
   Returns the last object identifier */
PHP_FUNCTION(pg_last_oid)
{
	zval *result;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;
#ifdef HAVE_PQOIDVALUE
	Oid oid;
#endif

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &result) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);
	pgsql_result = pg_result->result;
#ifdef HAVE_PQOIDVALUE
	oid = PQoidValue(pgsql_result);
	if (oid == InvalidOid) {
		RETURN_FALSE;
	}
	PGSQL_RETURN_OID(oid);
#else
	Z_STRVAL_P(return_value) = (char *) PQoidStatus(pgsql_result);
	if (Z_STRVAL_P(return_value)) {
		RETURN_STRING(Z_STRVAL_P(return_value), 1);
	}
	RETURN_STRING("""", 1);
#endif
}
/* }}} */

/* {{{ proto bool pg_trace(string filename [, string mode [, resource connection]])
   Enable tracing a PostgreSQL connection */
PHP_FUNCTION(pg_trace)
{
	char *z_filename, *mode = ""w"";
	int z_filename_len, mode_len;
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	FILE *fp = NULL;
        php_stream *stream;
        id = PGG(default_link);
 
       if (zend_parse_parameters(argc TSRMLS_CC, ""p|sr"", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {
                return;
        }
	if (argc < 3) {
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	stream = php_stream_open_wrapper(z_filename, mode, REPORT_ERRORS, NULL);

	if (!stream) {
		RETURN_FALSE;
	}

	if (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&fp, REPORT_ERRORS))	{
		php_stream_close(stream);
		RETURN_FALSE;
	}
	php_stream_auto_cleanup(stream);
	PQtrace(pgsql, fp);
	RETURN_TRUE;
}
/* }}} */

/* {{{ proto bool pg_untrace([resource connection])
   Disable tracing of a PostgreSQL connection */
PHP_FUNCTION(pg_untrace)
{
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	
	if (zend_parse_parameters(argc TSRMLS_CC, ""|r"", &pgsql_link) == FAILURE) {
		return;
	}

	if (argc == 0) { 
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);
	PQuntrace(pgsql);
	RETURN_TRUE;
}
/* }}} */

/* {{{ proto mixed pg_lo_create([resource connection],[mixed large_object_oid])
   Create a large object */
PHP_FUNCTION(pg_lo_create)
{
	zval *pgsql_link = NULL, *oid = NULL;
	PGconn *pgsql;
	Oid pgsql_oid, wanted_oid = InvalidOid;
	int id = -1, argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""|zz"", &pgsql_link, &oid) == FAILURE) {
		return;
	}

	if ((argc == 1) && (Z_TYPE_P(pgsql_link) != IS_RESOURCE)) {
		oid = pgsql_link;
		pgsql_link = NULL;
	}
	
	if (pgsql_link == NULL) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
		if (id == -1) {
			RETURN_FALSE;
		}
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);
	
	if (oid) {
#ifndef HAVE_PG_LO_CREATE
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Passing OID value is not supported. Upgrade your PostgreSQL"");
#else
		switch (Z_TYPE_P(oid)) {
		case IS_STRING:
			{
				char *end_ptr;
				wanted_oid = (Oid)strtoul(Z_STRVAL_P(oid), &end_ptr, 10);
				if ((Z_STRVAL_P(oid)+Z_STRLEN_P(oid)) != end_ptr) {
				/* wrong integer format */
				php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
				RETURN_FALSE;
				}
			}
			break;
		case IS_LONG:
			if (Z_LVAL_P(oid) < (long)InvalidOid) {
				php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
				RETURN_FALSE;
			}
			wanted_oid = (Oid)Z_LVAL_P(oid);
			break;
		default:
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
			RETURN_FALSE;
        }
		if ((pgsql_oid = lo_create(pgsql, wanted_oid)) == InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to create PostgreSQL large object"");
			RETURN_FALSE;
		}

		PGSQL_RETURN_OID(pgsql_oid);
#endif
	}

	if ((pgsql_oid = lo_creat(pgsql, INV_READ|INV_WRITE)) == InvalidOid) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to create PostgreSQL large object"");
		RETURN_FALSE;
	}

	PGSQL_RETURN_OID(pgsql_oid);
}
/* }}} */

/* {{{ proto bool pg_lo_unlink([resource connection,] string large_object_oid)
   Delete a large object */
PHP_FUNCTION(pg_lo_unlink)
{
	zval *pgsql_link = NULL;
	long oid_long;
	char *oid_string, *end_ptr;
	int oid_strlen;
	PGconn *pgsql;
	Oid oid;
	int id = -1;
	int argc = ZEND_NUM_ARGS();

	/* accept string type since Oid type is unsigned int */
	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rs"", &pgsql_link, &oid_string, &oid_strlen) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rl"", &pgsql_link, &oid_long) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""s"", &oid_string, &oid_strlen) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""l"", &oid_long) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID is specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Requires 1 or 2 arguments"");
		RETURN_FALSE;
	}
	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (lo_unlink(pgsql, oid) == -1) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to delete PostgreSQL large object %u"", oid);
		RETURN_FALSE;
	}
	RETURN_TRUE;
}
/* }}} */

/* {{{ proto resource pg_lo_open([resource connection,] int large_object_oid, string mode)
   Open a large object and return fd */
PHP_FUNCTION(pg_lo_open)
{
	zval *pgsql_link = NULL;
	long oid_long;
	char *oid_string, *end_ptr, *mode_string;
	int oid_strlen, mode_strlen;
	PGconn *pgsql;
	Oid oid;
	int id = -1, pgsql_mode=0, pgsql_lofd;
	int create=0;
	pgLofp *pgsql_lofp;
	int argc = ZEND_NUM_ARGS();

	/* accept string type since Oid is unsigned int */
	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rss"", &pgsql_link, &oid_string, &oid_strlen, &mode_string, &mode_strlen) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rls"", &pgsql_link, &oid_long, &mode_string, &mode_strlen) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""ss"", &oid_string, &oid_strlen, &mode_string, &mode_strlen) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""ls"", &oid_long, &mode_string, &mode_strlen) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Requires 1 or 2 arguments"");
		RETURN_FALSE;
	}
	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);
	
	/* r/w/+ is little bit more PHP-like than INV_READ/INV_WRITE and a lot of
	   faster to type. Unfortunately, doesn't behave the same way as fopen()...
	   (Jouni)
	*/

	if (strchr(mode_string, 'r') == mode_string) {
		pgsql_mode |= INV_READ;
		if (strchr(mode_string, '+') == mode_string+1) {
			pgsql_mode |= INV_WRITE;
		}
	}
	if (strchr(mode_string, 'w') == mode_string) {
		pgsql_mode |= INV_WRITE;
		create = 1;
		if (strchr(mode_string, '+') == mode_string+1) {
			pgsql_mode |= INV_READ;
		}
	}

	pgsql_lofp = (pgLofp *) emalloc(sizeof(pgLofp));

	if ((pgsql_lofd = lo_open(pgsql, oid, pgsql_mode)) == -1) {
		if (create) {
			if ((oid = lo_creat(pgsql, INV_READ|INV_WRITE)) == 0) {
				efree(pgsql_lofp);
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to create PostgreSQL large object"");
				RETURN_FALSE;
			} else {
				if ((pgsql_lofd = lo_open(pgsql, oid, pgsql_mode)) == -1) {
					if (lo_unlink(pgsql, oid) == -1) {
						efree(pgsql_lofp);
						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Something is really messed up! Your database is badly corrupted in a way NOT related to PHP"");
						RETURN_FALSE;
					}
					efree(pgsql_lofp);
					php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to open PostgreSQL large object"");
					RETURN_FALSE;
				} else {
					pgsql_lofp->conn = pgsql;
					pgsql_lofp->lofd = pgsql_lofd;
					Z_LVAL_P(return_value) = zend_list_insert(pgsql_lofp, le_lofp TSRMLS_CC);
					Z_TYPE_P(return_value) = IS_LONG;
				}
			}
		} else {
			efree(pgsql_lofp);
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to open PostgreSQL large object"");
			RETURN_FALSE;
		}
	} else {
		pgsql_lofp->conn = pgsql;
		pgsql_lofp->lofd = pgsql_lofd;
		ZEND_REGISTER_RESOURCE(return_value, pgsql_lofp, le_lofp);
	}
}
/* }}} */

/* {{{ proto bool pg_lo_close(resource large_object)
   Close a large object */
PHP_FUNCTION(pg_lo_close)
{
	zval *pgsql_lofp;
	pgLofp *pgsql;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &pgsql_lofp) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_lofp, -1, ""PostgreSQL large object"", le_lofp);
	
	if (lo_close((PGconn *)pgsql->conn, pgsql->lofd) < 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to close PostgreSQL large object descriptor %d"", pgsql->lofd);
		RETVAL_FALSE;
	} else {
		RETVAL_TRUE;
	}

	zend_list_delete(Z_RESVAL_P(pgsql_lofp));
	return;
}
/* }}} */

#define PGSQL_LO_READ_BUF_SIZE  8192

/* {{{ proto string pg_lo_read(resource large_object [, int len])
   Read a large object */
PHP_FUNCTION(pg_lo_read)
{
	zval *pgsql_id;
	long len;
	int buf_len = PGSQL_LO_READ_BUF_SIZE, nbytes, argc = ZEND_NUM_ARGS();
	char *buf;
	pgLofp *pgsql;

	if (zend_parse_parameters(argc TSRMLS_CC, ""r|l"", &pgsql_id, &len) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	if (argc > 1) {
		buf_len = len;
	}
	
	buf = (char *) safe_emalloc(sizeof(char), (buf_len+1), 0);
	if ((nbytes = lo_read((PGconn *)pgsql->conn, pgsql->lofd, buf, buf_len))<0) {
		efree(buf);
		RETURN_FALSE;
	}

	buf[nbytes] = '\0';
	RETURN_STRINGL(buf, nbytes, 0);
}
/* }}} */

/* {{{ proto int pg_lo_write(resource large_object, string buf [, int len])
   Write a large object */
PHP_FUNCTION(pg_lo_write)
{
  	zval *pgsql_id;
  	char *str;
  	long z_len;
	int str_len, nbytes;
	int len;
	pgLofp *pgsql;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""rs|l"", &pgsql_id, &str, &str_len, &z_len) == FAILURE) {
		return;
	}

	if (argc > 2) {
		if (z_len > str_len) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Cannot write more than buffer size %d. Tried to write %ld"", str_len, z_len);
			RETURN_FALSE;
		}
		if (z_len < 0) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Buffer size must be larger than 0, but %ld was specified"", z_len);
			RETURN_FALSE;
		}
		len = z_len;
	}
	else {
		len = str_len;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	if ((nbytes = lo_write((PGconn *)pgsql->conn, pgsql->lofd, str, len)) == -1) {
		RETURN_FALSE;
	}

	RETURN_LONG(nbytes);
}
/* }}} */

/* {{{ proto int pg_lo_read_all(resource large_object)
   Read a large object and send straight to browser */
PHP_FUNCTION(pg_lo_read_all)
{
  	zval *pgsql_id;
	int tbytes;
	volatile int nbytes;
	char buf[PGSQL_LO_READ_BUF_SIZE];
	pgLofp *pgsql;
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &pgsql_id) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	tbytes = 0;
	while ((nbytes = lo_read((PGconn *)pgsql->conn, pgsql->lofd, buf, PGSQL_LO_READ_BUF_SIZE))>0) {
		PHPWRITE(buf, nbytes);
		tbytes += nbytes;
	}
	RETURN_LONG(tbytes);
}
/* }}} */

/* {{{ proto int pg_lo_import([resource connection, ] string filename [, mixed oid])
   Import large object direct from filesystem */
PHP_FUNCTION(pg_lo_import)
{
	zval *pgsql_link = NULL, *oid = NULL;
	char *file_in;
	int id = -1, name_len;
	int argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	Oid returned_oid;

	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rp|z"", &pgsql_link, &file_in, &name_len, &oid) == SUCCESS) {
		;
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
									  ""p|z"", &file_in, &name_len, &oid) == SUCCESS) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	/* old calling convention, deprecated since PHP 4.2 */
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
									  ""pr"", &file_in, &name_len, &pgsql_link ) == SUCCESS) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Old API is used"");
	}
	else {
		WRONG_PARAM_COUNT;
	}
	
	if (php_check_open_basedir(file_in TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (oid) {
#ifndef HAVE_PG_LO_IMPORT_WITH_OID
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""OID value passing not supported"");
#else
		Oid wanted_oid;
		switch (Z_TYPE_P(oid)) {
		case IS_STRING:
			{
				char *end_ptr;
				wanted_oid = (Oid)strtoul(Z_STRVAL_P(oid), &end_ptr, 10);
				if ((Z_STRVAL_P(oid)+Z_STRLEN_P(oid)) != end_ptr) {
				/* wrong integer format */
				php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
				RETURN_FALSE;
				}
			}
			break;
		case IS_LONG:
			if (Z_LVAL_P(oid) < (long)InvalidOid) {
				php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
				RETURN_FALSE;
			}
			wanted_oid = (Oid)Z_LVAL_P(oid);
			break;
		default:
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
			RETURN_FALSE;
        }

       returned_oid = lo_import_with_oid(pgsql, file_in, wanted_oid);

	   if (returned_oid == InvalidOid) {
		   RETURN_FALSE;
	   }

	   PGSQL_RETURN_OID(returned_oid);
#endif
	}

	returned_oid = lo_import(pgsql, file_in);

	if (returned_oid == InvalidOid) {
		RETURN_FALSE;
	}
	PGSQL_RETURN_OID(returned_oid);
}
/* }}} */

/* {{{ proto bool pg_lo_export([resource connection, ] int objoid, string filename)
   Export large object direct to filesystem */
PHP_FUNCTION(pg_lo_export)
{
	zval *pgsql_link = NULL;
	char *file_out, *oid_string, *end_ptr;
	int oid_strlen;
	int id = -1, name_len;
	long oid_long;
	Oid oid;
	PGconn *pgsql;
	int argc = ZEND_NUM_ARGS();

	/* allow string to handle large OID value correctly */
	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rlp"", &pgsql_link, &oid_long, &file_out, &name_len) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rss"", &pgsql_link, &oid_string, &oid_strlen, &file_out, &name_len) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
									  ""lp"",  &oid_long, &file_out, &name_len) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""sp"", &oid_string, &oid_strlen, &file_out, &name_len) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""spr"", &oid_string, &oid_strlen, &file_out, &name_len, &pgsql_link) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
									  ""lpr"", &oid_long, &file_out, &name_len, &pgsql_link) == SUCCESS) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Old API is used"");
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
	}
	else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Requires 2 or 3 arguments"");
		RETURN_FALSE;
	}
	
	if (php_check_open_basedir(file_out TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (lo_export(pgsql, oid, file_out)) {
		RETURN_TRUE;
	}
	RETURN_FALSE;
}
/* }}} */

/* {{{ proto bool pg_lo_seek(resource large_object, int offset [, int whence])
   Seeks position of large object */
PHP_FUNCTION(pg_lo_seek)
{
	zval *pgsql_id = NULL;
	long offset = 0, whence = SEEK_CUR;
	pgLofp *pgsql;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""rl|l"", &pgsql_id, &offset, &whence) == FAILURE) {
		return;
	}
	if (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid whence parameter"");
		return;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	if (lo_lseek((PGconn *)pgsql->conn, pgsql->lofd, offset, whence) > -1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}
}
/* }}} */

/* {{{ proto int pg_lo_tell(resource large_object)
   Returns current position of large object */
PHP_FUNCTION(pg_lo_tell)
{
	zval *pgsql_id = NULL;
	int offset = 0;
	pgLofp *pgsql;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""r"", &pgsql_id) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	offset = lo_tell((PGconn *)pgsql->conn, pgsql->lofd);
	RETURN_LONG(offset);
}
/* }}} */

#if HAVE_PQSETERRORVERBOSITY
/* {{{ proto int pg_set_error_verbosity([resource connection,] int verbosity)
   Set error verbosity */
PHP_FUNCTION(pg_set_error_verbosity)
{
	zval *pgsql_link = NULL;
	long verbosity;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;

	if (argc == 1) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""l"", &verbosity) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rl"", &pgsql_link, &verbosity) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}	

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (verbosity & (PQERRORS_TERSE|PQERRORS_DEFAULT|PQERRORS_VERBOSE)) {
		Z_LVAL_P(return_value) = PQsetErrorVerbosity(pgsql, verbosity);
		Z_TYPE_P(return_value) = IS_LONG;
	} else {
		RETURN_FALSE;
	}
}
/* }}} */
#endif

#ifdef HAVE_PQCLIENTENCODING
/* {{{ proto int pg_set_client_encoding([resource connection,] string encoding)
   Set client encoding */
PHP_FUNCTION(pg_set_client_encoding)
{
	char *encoding;
	int encoding_len;
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;

	if (argc == 1) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""s"", &encoding, &encoding_len) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rs"", &pgsql_link, &encoding, &encoding_len) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	Z_LVAL_P(return_value) = PQsetClientEncoding(pgsql, encoding);
	Z_TYPE_P(return_value) = IS_LONG;
}
/* }}} */

/* {{{ proto string pg_client_encoding([resource connection])
   Get the current client encoding */
PHP_FUNCTION(pg_client_encoding)
{
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;

	if (zend_parse_parameters(argc TSRMLS_CC, ""|r"", &pgsql_link) == FAILURE) {
		return;
	}
	
	if (argc == 0) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}	

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	/* Just do the same as found in PostgreSQL sources... */

	Z_STRVAL_P(return_value) = (char *) pg_encoding_to_char(PQclientEncoding(pgsql));
	Z_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));
	Z_STRVAL_P(return_value) = (char *) estrdup(Z_STRVAL_P(return_value));
	Z_TYPE_P(return_value) = IS_STRING;
}
/* }}} */
#endif

#if !HAVE_PQGETCOPYDATA
#define	COPYBUFSIZ	8192
#endif

/* {{{ proto bool pg_end_copy([resource connection])
   Sync with backend. Completes the Copy command */
PHP_FUNCTION(pg_end_copy)
{
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	int result = 0;

	if (zend_parse_parameters(argc TSRMLS_CC, ""|r"", &pgsql_link) == FAILURE) {
		return;
	}
	
	if (argc == 0) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	result = PQendcopy(pgsql);

	if (result!=0) {
		PHP_PQ_ERROR(""Query failed: %s"", pgsql);
		RETURN_FALSE;
	}
	RETURN_TRUE;
}
/* }}} */


/* {{{ proto bool pg_put_line([resource connection,] string query)
   Send null-terminated string to backend server*/
PHP_FUNCTION(pg_put_line)
{
	char *query;
	zval *pgsql_link = NULL;
	int query_len, id = -1;
	PGconn *pgsql;
	int result = 0, argc = ZEND_NUM_ARGS();

	if (argc == 1) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""s"", &query, &query_len) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rs"", &pgsql_link, &query, &query_len) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}	

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	result = PQputline(pgsql, query);
	if (result==EOF) {
		PHP_PQ_ERROR(""Query failed: %s"", pgsql);
		RETURN_FALSE;
	}
	RETURN_TRUE;
}
/* }}} */

/* {{{ proto array pg_copy_to(resource connection, string table_name [, string delimiter [, string null_as]])
   Copy table to array */
PHP_FUNCTION(pg_copy_to)
{
	zval *pgsql_link;
	char *table_name, *pg_delim = NULL, *pg_null_as = NULL;
	int table_name_len, pg_delim_len, pg_null_as_len, free_pg_null = 0;
	char *query;
	int id = -1;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	int copydone = 0;
#if !HAVE_PQGETCOPYDATA
	char copybuf[COPYBUFSIZ];
#endif
	char *csv = (char *)NULL;
	int ret;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""rs|ss"",
							  &pgsql_link, &table_name, &table_name_len,
							  &pg_delim, &pg_delim_len, &pg_null_as, &pg_null_as_len) == FAILURE) {
		return;
	}
	if (!pg_delim) {
		pg_delim = ""\t"";
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (!pg_null_as) {
		pg_null_as = safe_estrdup(""\\\\N"");
		free_pg_null = 1;
	}

	spprintf(&query, 0, ""COPY %s TO STDOUT DELIMITERS E'%c' WITH NULL AS E'%s'"", table_name, *pg_delim, pg_null_as);

	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
	}
	pgsql_result = PQexec(pgsql, query);
	if (free_pg_null) {
		efree(pg_null_as);
	}
	efree(query);

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}

	switch (status) {
		case PGRES_COPY_OUT:
			if (pgsql_result) {
				PQclear(pgsql_result);
				array_init(return_value);
#if HAVE_PQGETCOPYDATA
				while (!copydone)
				{
					ret = PQgetCopyData(pgsql, &csv, 0);
					switch (ret) {
						case -1:
							copydone = 1;
							break;
						case 0:
						case -2:
							PHP_PQ_ERROR(""getline failed: %s"", pgsql);
							RETURN_FALSE;
							break;
						default:
							add_next_index_string(return_value, csv, 1);
							PQfreemem(csv);
							break;
					}
				}
#else
				while (!copydone)
				{
					if ((ret = PQgetline(pgsql, copybuf, COPYBUFSIZ))) {
						PHP_PQ_ERROR(""getline failed: %s"", pgsql);
						RETURN_FALSE;
					}

					if (copybuf[0] == '\\' &&
						copybuf[1] == '.' &&
						copybuf[2] == '\0')
					{
						copydone = 1;
					}
					else
					{
						if (csv == (char *)NULL) {
							csv = estrdup(copybuf);
						} else {
							csv = (char *)erealloc(csv, strlen(csv) + sizeof(char)*(COPYBUFSIZ+1));
							strcat(csv, copybuf);
						}
							
						switch (ret)
						{
							case EOF:
								copydone = 1;
							case 0:
								add_next_index_string(return_value, csv, 1);
								efree(csv);
								csv = (char *)NULL;
								break;
							case 1:
								break;
						}
					}
				}
				if (PQendcopy(pgsql)) {
					PHP_PQ_ERROR(""endcopy failed: %s"", pgsql);
					RETURN_FALSE;
				}
#endif
				while ((pgsql_result = PQgetResult(pgsql))) {
					PQclear(pgsql_result);
				}
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			break;
		default:
			PQclear(pgsql_result);
			PHP_PQ_ERROR(""Copy command failed: %s"", pgsql);
			RETURN_FALSE;
			break;
	}
}
/* }}} */

/* {{{ proto bool pg_copy_from(resource connection, string table_name , array rows [, string delimiter [, string null_as]])
   Copy table from array */
PHP_FUNCTION(pg_copy_from)
{
	zval *pgsql_link = NULL, *pg_rows;
	zval **tmp;
	char *table_name, *pg_delim = NULL, *pg_null_as = NULL;
	int  table_name_len, pg_delim_len, pg_null_as_len;
	int  pg_null_as_free = 0;
	char *query;
	HashPosition pos;
	int id = -1;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""rsa|ss"",
							  &pgsql_link, &table_name, &table_name_len, &pg_rows,
							  &pg_delim, &pg_delim_len, &pg_null_as, &pg_null_as_len) == FAILURE) {
		return;
	}
	if (!pg_delim) {
		pg_delim = ""\t"";
	}
	if (!pg_null_as) {
		pg_null_as = safe_estrdup(""\\\\N"");
		pg_null_as_free = 1;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	spprintf(&query, 0, ""COPY %s FROM STDIN DELIMITERS E'%c' WITH NULL AS E'%s'"", table_name, *pg_delim, pg_null_as);
	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
	}
	pgsql_result = PQexec(pgsql, query);

	if (pg_null_as_free) {
		efree(pg_null_as);
	}
	efree(query);

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}

	switch (status) {
		case PGRES_COPY_IN:
			if (pgsql_result) {
				int command_failed = 0;
				PQclear(pgsql_result);
				zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(pg_rows), &pos);
#if HAVE_PQPUTCOPYDATA
				while (zend_hash_get_current_data_ex(Z_ARRVAL_P(pg_rows), (void **) &tmp, &pos) == SUCCESS) {
					convert_to_string_ex(tmp);
					query = (char *)emalloc(Z_STRLEN_PP(tmp) + 2);
					strlcpy(query, Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp) + 2);
					if(Z_STRLEN_PP(tmp) > 0 && *(query + Z_STRLEN_PP(tmp) - 1) != '\n') {
						strlcat(query, ""\n"", Z_STRLEN_PP(tmp) + 2);
					}
					if (PQputCopyData(pgsql, query, strlen(query)) != 1) {
						efree(query);
						PHP_PQ_ERROR(""copy failed: %s"", pgsql);
						RETURN_FALSE;
					}
					efree(query);
					zend_hash_move_forward_ex(Z_ARRVAL_P(pg_rows), &pos);
				}
				if (PQputCopyEnd(pgsql, NULL) != 1) {
					PHP_PQ_ERROR(""putcopyend failed: %s"", pgsql);
					RETURN_FALSE;
				}
#else
				while (zend_hash_get_current_data_ex(Z_ARRVAL_P(pg_rows), (void **) &tmp, &pos) == SUCCESS) {
					convert_to_string_ex(tmp);
					query = (char *)emalloc(Z_STRLEN_PP(tmp) + 2);
					strlcpy(query, Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp) + 2);
					if(Z_STRLEN_PP(tmp) > 0 && *(query + Z_STRLEN_PP(tmp) - 1) != '\n') {
						strlcat(query, ""\n"", Z_STRLEN_PP(tmp) + 2);
					}
					if (PQputline(pgsql, query)==EOF) {
						efree(query);
						PHP_PQ_ERROR(""copy failed: %s"", pgsql);
						RETURN_FALSE;
					}
					efree(query);
					zend_hash_move_forward_ex(Z_ARRVAL_P(pg_rows), &pos);
				}
				if (PQputline(pgsql, ""\\.\n"") == EOF) {
					PHP_PQ_ERROR(""putline failed: %s"", pgsql);
					RETURN_FALSE;
				}
				if (PQendcopy(pgsql)) {
					PHP_PQ_ERROR(""endcopy failed: %s"", pgsql);
					RETURN_FALSE;
				}
#endif
				while ((pgsql_result = PQgetResult(pgsql))) {
					if (PGRES_COMMAND_OK != PQresultStatus(pgsql_result)) {
						PHP_PQ_ERROR(""Copy command failed: %s"", pgsql);
						command_failed = 1;
					}
					PQclear(pgsql_result);
				}
				if (command_failed) {
					RETURN_FALSE;
				}
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			RETURN_TRUE;
			break;
		default:
			PQclear(pgsql_result);
			PHP_PQ_ERROR(""Copy command failed: %s"", pgsql);
			RETURN_FALSE;
			break;
	}
}
/* }}} */

#ifdef HAVE_PQESCAPE
/* {{{ proto string pg_escape_string([resource connection,] string data)
   Escape string for text/char type */
PHP_FUNCTION(pg_escape_string)
{
	char *from = NULL, *to = NULL;
	zval *pgsql_link;
#ifdef HAVE_PQESCAPE_CONN
	PGconn *pgsql;
#endif
	int to_len;
	int from_len;
	int id = -1;

	switch (ZEND_NUM_ARGS()) {
		case 1:
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &from, &from_len) == FAILURE) {
				return;
			}
			pgsql_link = NULL;
			id = PGG(default_link);
			break;

		default:
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &pgsql_link, &from, &from_len) == FAILURE) {
				return;
			}
			break;
	}

	to = (char *) safe_emalloc(from_len, 2, 1);
#ifdef HAVE_PQESCAPE_CONN
	if (pgsql_link != NULL || id != -1) {
		ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);
		to_len = (int) PQescapeStringConn(pgsql, to, from, (size_t)from_len, NULL);
	} else
#endif
		to_len = (int) PQescapeString(to, from, (size_t)from_len);

	RETURN_STRINGL(to, to_len, 0);
}
/* }}} */

/* {{{ proto string pg_escape_bytea([resource connection,] string data)
   Escape binary for bytea type  */
PHP_FUNCTION(pg_escape_bytea)
{
	char *from = NULL, *to = NULL;
	size_t to_len;
	int from_len, id = -1;
#ifdef HAVE_PQESCAPE_BYTEA_CONN
	PGconn *pgsql;
#endif
	zval *pgsql_link;

	switch (ZEND_NUM_ARGS()) {
		case 1:
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &from, &from_len) == FAILURE) {
				return;
			}
			pgsql_link = NULL;
			id = PGG(default_link);
			break;

		default:
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &pgsql_link, &from, &from_len) == FAILURE) {
				return;
			}
			break;
	}

#ifdef HAVE_PQESCAPE_BYTEA_CONN
	if (pgsql_link != NULL || id != -1) {
		ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);
		to = (char *)PQescapeByteaConn(pgsql, (unsigned char *)from, (size_t)from_len, &to_len);
	} else
#endif
		to = (char *)PQescapeBytea((unsigned char*)from, from_len, &to_len);

	RETVAL_STRINGL(to, to_len-1, 1); /* to_len includes addtional '\0' */
	PQfreemem(to);
}
/* }}} */

#if !HAVE_PQUNESCAPEBYTEA
/* PQunescapeBytea() from PostgreSQL 7.3 to provide bytea unescape feature to 7.2 users.
   Renamed to php_pgsql_unescape_bytea() */
/*
 *		PQunescapeBytea - converts the null terminated string representation
 *		of a bytea, strtext, into binary, filling a buffer. It returns a
 *		pointer to the buffer which is NULL on error, and the size of the
 *		buffer in retbuflen. The pointer may subsequently be used as an
 *		argument to the function free(3). It is the reverse of PQescapeBytea.
 *
 *		The following transformations are reversed:
 *		'\0' == ASCII  0 == \000
 *		'\'' == ASCII 39 == \'
 *		'\\' == ASCII 92 == \\
 *
 *		States:
 *		0	normal		0->1->2->3->4
 *		1	\			   1->5
 *		2	\0			   1->6
 *		3	\00
 *		4	\000
 *		5	\'
 *		6	\\
 */
static unsigned char * php_pgsql_unescape_bytea(unsigned char *strtext, size_t *retbuflen)
{
	size_t     buflen;
	unsigned char *buffer,
			   *sp,
			   *bp;
	unsigned int state = 0;

	if (strtext == NULL)
		return NULL;
	buflen = strlen(strtext);	/* will shrink, also we discover if
								 * strtext */
	buffer = (unsigned char *) emalloc(buflen);	/* isn't NULL terminated */
	for (bp = buffer, sp = strtext; *sp != '\0'; bp++, sp++)
	{
","static void php_pgsql_do_connect(INTERNAL_FUNCTION_PARAMETERS, int persistent)
{
	char *host=NULL,*port=NULL,*options=NULL,*tty=NULL,*dbname=NULL,*connstring=NULL;
	PGconn *pgsql;
	smart_str str = {0};
	zval **args[5];
	int i, connect_type = 0;
	PGresult *pg_result;

	if (ZEND_NUM_ARGS() < 1 || ZEND_NUM_ARGS() > 5
			|| zend_get_parameters_array_ex(ZEND_NUM_ARGS(), args) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	smart_str_appends(&str, ""pgsql"");
	
	for (i = 0; i < ZEND_NUM_ARGS(); i++) {
		/* make sure that the PGSQL_CONNECT_FORCE_NEW bit is not part of the hash so that subsequent connections
		 * can re-use this connection. Bug #39979
		 */ 
		if (i == 1 && ZEND_NUM_ARGS() == 2 && Z_TYPE_PP(args[i]) == IS_LONG) {
			if (Z_LVAL_PP(args[1]) == PGSQL_CONNECT_FORCE_NEW) {
				continue;
			} else if (Z_LVAL_PP(args[1]) & PGSQL_CONNECT_FORCE_NEW) {
				smart_str_append_long(&str, Z_LVAL_PP(args[1]) ^ PGSQL_CONNECT_FORCE_NEW);
			}
		}
		convert_to_string_ex(args[i]);
		smart_str_appendc(&str, '_');
		smart_str_appendl(&str, Z_STRVAL_PP(args[i]), Z_STRLEN_PP(args[i]));
	}

	smart_str_0(&str);

	if (ZEND_NUM_ARGS() == 1) { /* new style, using connection string */
		connstring = Z_STRVAL_PP(args[0]);
	} else if (ZEND_NUM_ARGS() == 2 ) { /* Safe to add conntype_option, since 2 args was illegal */
		connstring = Z_STRVAL_PP(args[0]);
		convert_to_long_ex(args[1]);
		connect_type = Z_LVAL_PP(args[1]);
	} else {
		host = Z_STRVAL_PP(args[0]);
		port = Z_STRVAL_PP(args[1]);
		dbname = Z_STRVAL_PP(args[ZEND_NUM_ARGS()-1]);

		switch (ZEND_NUM_ARGS()) {
		case 5:
			tty = Z_STRVAL_PP(args[3]);
			/* fall through */
		case 4:
			options = Z_STRVAL_PP(args[2]);
			break;
		}
	}

	if (persistent && PGG(allow_persistent)) {
		zend_rsrc_list_entry *le;
		
		/* try to find if we already have this link in our persistent list */
		if (zend_hash_find(&EG(persistent_list), str.c, str.len+1, (void **) &le)==FAILURE) {  /* we don't */
			zend_rsrc_list_entry new_le;
			
			if (PGG(max_links)!=-1 && PGG(num_links)>=PGG(max_links)) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,
								 ""Cannot create new link. Too many open links (%ld)"", PGG(num_links));
				goto err;
			}
			if (PGG(max_persistent)!=-1 && PGG(num_persistent)>=PGG(max_persistent)) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,
								 ""Cannot create new link. Too many open persistent links (%ld)"", PGG(num_persistent));
				goto err;
			}

			/* create the link */
			if (connstring) {
				pgsql=PQconnectdb(connstring);
			} else {
				pgsql=PQsetdb(host,port,options,tty,dbname);
			}
			if (pgsql==NULL || PQstatus(pgsql)==CONNECTION_BAD) {
				PHP_PQ_ERROR(""Unable to connect to PostgreSQL server: %s"", pgsql)
				if (pgsql) {
					PQfinish(pgsql);
				}
				goto err;
			}

			/* hash it up */
			Z_TYPE(new_le) = le_plink;
			new_le.ptr = pgsql;
			if (zend_hash_update(&EG(persistent_list), str.c, str.len+1, (void *) &new_le, sizeof(zend_rsrc_list_entry), NULL)==FAILURE) {
				goto err;
			}
			PGG(num_links)++;
			PGG(num_persistent)++;
		} else {  /* we do */
			if (Z_TYPE_P(le) != le_plink) {
				RETURN_FALSE;
			}
			/* ensure that the link did not die */
			if (PGG(auto_reset_persistent) & 1) {
				/* need to send & get something from backend to
				   make sure we catch CONNECTION_BAD everytime */
				PGresult *pg_result;
				pg_result = PQexec(le->ptr, ""select 1"");
				PQclear(pg_result);
			}
			if (PQstatus(le->ptr)==CONNECTION_BAD) { /* the link died */
				if (le->ptr == NULL) {
					if (connstring) {
						le->ptr=PQconnectdb(connstring);
					} else {
						le->ptr=PQsetdb(host,port,options,tty,dbname);
					}
				}
				else {
					PQreset(le->ptr);
				}
				if (le->ptr==NULL || PQstatus(le->ptr)==CONNECTION_BAD) {
					php_error_docref(NULL TSRMLS_CC, E_WARNING,""PostgreSQL link lost, unable to reconnect"");
					zend_hash_del(&EG(persistent_list),str.c,str.len+1);
					goto err;
				}
			}
			pgsql = (PGconn *) le->ptr;
#if HAVE_PQPROTOCOLVERSION && HAVE_PQPARAMETERSTATUS
			if (PQprotocolVersion(pgsql) >= 3 && atof(PQparameterStatus(pgsql, ""server_version"")) >= 7.2) {
#else
			if (atof(PG_VERSION) >= 7.2) {
#endif
				pg_result = PQexec(pgsql, ""RESET ALL;"");
				PQclear(pg_result);
			}
		}
		ZEND_REGISTER_RESOURCE(return_value, pgsql, le_plink);
	} else { /* Non persistent connection */
		zend_rsrc_list_entry *index_ptr,new_index_ptr;

		/* first we check the hash for the hashed_details key.  if it exists,
		 * it should point us to the right offset where the actual pgsql link sits.
		 * if it doesn't, open a new pgsql link, add it to the resource list,
		 * and add a pointer to it with hashed_details as the key.
		 */
		if (!(connect_type & PGSQL_CONNECT_FORCE_NEW)
			&& zend_hash_find(&EG(regular_list),str.c,str.len+1,(void **) &index_ptr)==SUCCESS) {
			int type;
			ulong link;
			void *ptr;

			if (Z_TYPE_P(index_ptr) != le_index_ptr) {
				RETURN_FALSE;
			}
			link = (ulong) index_ptr->ptr;
			ptr = zend_list_find(link,&type);   /* check if the link is still there */
			if (ptr && (type==le_link || type==le_plink)) {
				Z_LVAL_P(return_value) = link;
				zend_list_addref(link);
				php_pgsql_set_default_link(link TSRMLS_CC);
				Z_TYPE_P(return_value) = IS_RESOURCE;
				goto cleanup;
			} else {
				zend_hash_del(&EG(regular_list),str.c,str.len+1);
			}
		}
		if (PGG(max_links)!=-1 && PGG(num_links)>=PGG(max_links)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Cannot create new link. Too many open links (%ld)"", PGG(num_links));
			goto err;
		}
		if (connstring) {
			pgsql = PQconnectdb(connstring);
		} else {
			pgsql = PQsetdb(host,port,options,tty,dbname);
		}
		if (pgsql==NULL || PQstatus(pgsql)==CONNECTION_BAD) {
			PHP_PQ_ERROR(""Unable to connect to PostgreSQL server: %s"", pgsql);
			if (pgsql) {
				PQfinish(pgsql);
			}
			goto err;
		}

		/* add it to the list */
		ZEND_REGISTER_RESOURCE(return_value, pgsql, le_link);

		/* add it to the hash */
		new_index_ptr.ptr = (void *) Z_LVAL_P(return_value);
		Z_TYPE(new_index_ptr) = le_index_ptr;
		if (zend_hash_update(&EG(regular_list),str.c,str.len+1,(void *) &new_index_ptr, sizeof(zend_rsrc_list_entry), NULL)==FAILURE) {
			goto err;
		}
		PGG(num_links)++;
	}
	/* set notice processer */
	if (! PGG(ignore_notices) && Z_TYPE_P(return_value) == IS_RESOURCE) {
		PQsetNoticeProcessor(pgsql, _php_pgsql_notice_handler, (void*)Z_RESVAL_P(return_value));
	}
	php_pgsql_set_default_link(Z_LVAL_P(return_value) TSRMLS_CC);
	
cleanup:
	smart_str_free(&str);
	return;

err:
	smart_str_free(&str);
	RETURN_FALSE;
}
/* }}} */

#if 0
/* {{{ php_pgsql_get_default_link
 */
static int php_pgsql_get_default_link(INTERNAL_FUNCTION_PARAMETERS)
{
	if (PGG(default_link)==-1) { /* no link opened yet, implicitly open one */
		ht = 0;
		php_pgsql_do_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU,0);
	}
	return PGG(default_link);
}
/* }}} */
#endif

/* {{{ proto resource pg_connect(string connection_string[, int connect_type] | [string host, string port [, string options [, string tty,]]] string database)
   Open a PostgreSQL connection */
PHP_FUNCTION(pg_connect)
{
	php_pgsql_do_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU,0);
}
/* }}} */

/* {{{ proto resource pg_pconnect(string connection_string | [string host, string port [, string options [, string tty,]]] string database)
   Open a persistent PostgreSQL connection */
PHP_FUNCTION(pg_pconnect)
{
	php_pgsql_do_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU,1);
}
/* }}} */

/* {{{ proto bool pg_close([resource connection])
   Close a PostgreSQL connection */ 
PHP_FUNCTION(pg_close)
{
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;

	if (zend_parse_parameters(argc TSRMLS_CC, ""|r"", &pgsql_link) == FAILURE) {
		return;
	}

	if (argc == 0) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (id==-1) { /* explicit resource number */
		zend_list_delete(Z_RESVAL_P(pgsql_link));
	}

	if (id!=-1
		|| (pgsql_link && Z_RESVAL_P(pgsql_link)==PGG(default_link))) {
		zend_list_delete(PGG(default_link));
		PGG(default_link) = -1;
	}

	RETURN_TRUE;
}
/* }}} */


#define PHP_PG_DBNAME 1
#define PHP_PG_ERROR_MESSAGE 2
#define PHP_PG_OPTIONS 3
#define PHP_PG_PORT 4
#define PHP_PG_TTY 5
#define PHP_PG_HOST 6
#define PHP_PG_VERSION 7


/* {{{ php_pgsql_get_link_info
 */
static void php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAMETERS, int entry_type)
{
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	char *msgbuf;

	if (zend_parse_parameters(argc TSRMLS_CC, ""|r"", &pgsql_link) == FAILURE) {
		return;
	}
	
	if (argc == 0) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	
	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	switch(entry_type) {
		case PHP_PG_DBNAME:
			Z_STRVAL_P(return_value) = PQdb(pgsql);
			break;
		case PHP_PG_ERROR_MESSAGE:
			RETURN_STRING(PQErrorMessageTrim(pgsql, &msgbuf), 0);
			return;
		case PHP_PG_OPTIONS:
			Z_STRVAL_P(return_value) = PQoptions(pgsql);
			break;
		case PHP_PG_PORT:
			Z_STRVAL_P(return_value) = PQport(pgsql);
			break;
		case PHP_PG_TTY:
			Z_STRVAL_P(return_value) = PQtty(pgsql);
			break;
		case PHP_PG_HOST:
			Z_STRVAL_P(return_value) = PQhost(pgsql);
			break;
		case PHP_PG_VERSION:
			array_init(return_value);
			add_assoc_string(return_value, ""client"", PG_VERSION, 1);
#if HAVE_PQPROTOCOLVERSION
			add_assoc_long(return_value, ""protocol"", PQprotocolVersion(pgsql));
#if HAVE_PQPARAMETERSTATUS
			if (PQprotocolVersion(pgsql) >= 3) {
				add_assoc_string(return_value, ""server"", (char*)PQparameterStatus(pgsql, ""server_version""), 1);
			}
#endif
#endif
			return;
		default:
			RETURN_FALSE;
	}
	if (Z_STRVAL_P(return_value)) {
		Z_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));
		Z_STRVAL_P(return_value) = (char *) estrdup(Z_STRVAL_P(return_value));
	} else {
		Z_STRLEN_P(return_value) = 0;
		Z_STRVAL_P(return_value) = (char *) estrdup("""");
	}
	Z_TYPE_P(return_value) = IS_STRING;
}
/* }}} */

/* {{{ proto string pg_dbname([resource connection])
   Get the database name */ 
PHP_FUNCTION(pg_dbname)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_DBNAME);
}
/* }}} */

/* {{{ proto string pg_last_error([resource connection])
   Get the error message string */
PHP_FUNCTION(pg_last_error)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_ERROR_MESSAGE);
}
/* }}} */

/* {{{ proto string pg_options([resource connection])
   Get the options associated with the connection */
PHP_FUNCTION(pg_options)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_OPTIONS);
}
/* }}} */

/* {{{ proto int pg_port([resource connection])
   Return the port number associated with the connection */
PHP_FUNCTION(pg_port)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_PORT);
}
/* }}} */

/* {{{ proto string pg_tty([resource connection])
   Return the tty name associated with the connection */
PHP_FUNCTION(pg_tty)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_TTY);
}
/* }}} */

/* {{{ proto string pg_host([resource connection])
   Returns the host name associated with the connection */
PHP_FUNCTION(pg_host)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_HOST);
}
/* }}} */

/* {{{ proto array pg_version([resource connection])
   Returns an array with client, protocol and server version (when available) */
PHP_FUNCTION(pg_version)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_VERSION);
}
/* }}} */

#if HAVE_PQPARAMETERSTATUS
/* {{{ proto string|false pg_parameter_status([resource connection,] string param_name)
   Returns the value of a server parameter */
PHP_FUNCTION(pg_parameter_status)
{
	zval *pgsql_link;
	int id;
	PGconn *pgsql;
	char *param;
	int len;

	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &pgsql_link, &param, &len) == SUCCESS) {
		id = -1;
	} else if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &param, &len) == SUCCESS) {
		pgsql_link = NULL;
		id = PGG(default_link);
	} else {
		RETURN_FALSE;
	}
	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	param = (char*)PQparameterStatus(pgsql, param);
	if (param) {
		RETURN_STRING(param, 1);
	} else {
		RETURN_FALSE;
	}
}
/* }}} */
#endif

/* {{{ proto bool pg_ping([resource connection])
   Ping database. If connection is bad, try to reconnect. */
PHP_FUNCTION(pg_ping)
{
	zval *pgsql_link;
	int id;
	PGconn *pgsql;
	PGresult *res;

	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &pgsql_link) == SUCCESS) {
		id = -1;
	} else {
		pgsql_link = NULL;
		id = PGG(default_link);
	}
	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	/* ping connection */
	res = PQexec(pgsql, ""SELECT 1;"");
	PQclear(res);

	/* check status. */
	if (PQstatus(pgsql) == CONNECTION_OK)
		RETURN_TRUE;

	/* reset connection if it's broken */
	PQreset(pgsql);
	if (PQstatus(pgsql) == CONNECTION_OK) {
		RETURN_TRUE;
	}
	RETURN_FALSE;
}
/* }}} */

/* {{{ proto resource pg_query([resource connection,] string query)
   Execute a query */
PHP_FUNCTION(pg_query)
{
	zval *pgsql_link = NULL;
	char *query;
	int id = -1, query_len, argc = ZEND_NUM_ARGS();
	int leftover = 0;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	pgsql_result_handle *pg_result;

	if (argc == 1) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &query, &query_len) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &pgsql_link, &query, &query_len) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (PQ_SETNONBLOCKING(pgsql, 0)) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE,""Cannot set connection to blocking mode"");
		RETURN_FALSE;
	}
	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
		leftover = 1;
	}
	if (leftover) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found results on this connection. Use pg_get_result() to get these results first"");
	}
	pgsql_result = PQexec(pgsql, query);
	if ((PGG(auto_reset_persistent) & 2) && PQstatus(pgsql) != CONNECTION_OK) {
		PQclear(pgsql_result);
		PQreset(pgsql);
		pgsql_result = PQexec(pgsql, query);
	}

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}

	switch (status) {
		case PGRES_EMPTY_QUERY:
		case PGRES_BAD_RESPONSE:
		case PGRES_NONFATAL_ERROR:
		case PGRES_FATAL_ERROR:
			PHP_PQ_ERROR(""Query failed: %s"", pgsql);
			PQclear(pgsql_result);
			RETURN_FALSE;
			break;
		case PGRES_COMMAND_OK: /* successful command that did not return rows */
		default:
			if (pgsql_result) {
				pg_result = (pgsql_result_handle *) emalloc(sizeof(pgsql_result_handle));
				pg_result->conn = pgsql;
				pg_result->result = pgsql_result;
				pg_result->row = 0;
				ZEND_REGISTER_RESOURCE(return_value, pg_result, le_result);
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			break;
	}
}
/* }}} */

#if HAVE_PQEXECPARAMS || HAVE_PQEXECPREPARED || HAVE_PQSENDQUERYPARAMS || HAVE_PQSENDQUERYPREPARED
/* {{{ _php_pgsql_free_params */
static void _php_pgsql_free_params(char **params, int num_params)
{
	if (num_params > 0) {
		int i;
		for (i = 0; i < num_params; i++) {
			if (params[i]) {
				efree(params[i]);
			}
		}
		efree(params);
	}
}
/* }}} */
#endif

#if HAVE_PQEXECPARAMS
/* {{{ proto resource pg_query_params([resource connection,] string query, array params)
   Execute a query */
PHP_FUNCTION(pg_query_params)
{
	zval *pgsql_link = NULL;
	zval *pv_param_arr, **tmp;
	char *query;
	int query_len, id = -1, argc = ZEND_NUM_ARGS();
	int leftover = 0;
	int num_params = 0;
	char **params = NULL;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	pgsql_result_handle *pg_result;
	
	if (argc == 2) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""sa"", &query, &query_len, &pv_param_arr) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rsa"", &pgsql_link, &query, &query_len, &pv_param_arr) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (PQ_SETNONBLOCKING(pgsql, 0)) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE,""Cannot set connection to blocking mode"");
		RETURN_FALSE;
	}
	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
		leftover = 1;
	}
	if (leftover) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found results on this connection. Use pg_get_result() to get these results first"");
	}

	zend_hash_internal_pointer_reset(Z_ARRVAL_P(pv_param_arr));
	num_params = zend_hash_num_elements(Z_ARRVAL_P(pv_param_arr));
	if (num_params > 0) {
		int i = 0;
		params = (char **)safe_emalloc(sizeof(char *), num_params, 0);

		for(i = 0; i < num_params; i++) {
			if (zend_hash_get_current_data(Z_ARRVAL_P(pv_param_arr), (void **) &tmp) == FAILURE) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,""Error getting parameter"");
				_php_pgsql_free_params(params, num_params);
				RETURN_FALSE;
			}

			if (Z_TYPE_PP(tmp) == IS_NULL) {
				params[i] = NULL;
			} else {
				zval tmp_val = **tmp;
				zval_copy_ctor(&tmp_val);
				convert_to_string(&tmp_val);
				if (Z_TYPE(tmp_val) != IS_STRING) {
					php_error_docref(NULL TSRMLS_CC, E_WARNING,""Error converting parameter"");
					zval_dtor(&tmp_val);
					_php_pgsql_free_params(params, num_params);
					RETURN_FALSE;
				}
				params[i] = estrndup(Z_STRVAL(tmp_val), Z_STRLEN(tmp_val));
				zval_dtor(&tmp_val);
			}

			zend_hash_move_forward(Z_ARRVAL_P(pv_param_arr));
		}
	}

	pgsql_result = PQexecParams(pgsql, query, num_params, 
					NULL, (const char * const *)params, NULL, NULL, 0);
	if ((PGG(auto_reset_persistent) & 2) && PQstatus(pgsql) != CONNECTION_OK) {
		PQclear(pgsql_result);
		PQreset(pgsql);
		pgsql_result = PQexecParams(pgsql, query, num_params, 
						NULL, (const char * const *)params, NULL, NULL, 0);
	}

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}
	
	_php_pgsql_free_params(params, num_params);

	switch (status) {
		case PGRES_EMPTY_QUERY:
		case PGRES_BAD_RESPONSE:
		case PGRES_NONFATAL_ERROR:
		case PGRES_FATAL_ERROR:
			PHP_PQ_ERROR(""Query failed: %s"", pgsql);
			PQclear(pgsql_result);
			RETURN_FALSE;
			break;
		case PGRES_COMMAND_OK: /* successful command that did not return rows */
		default:
			if (pgsql_result) {
				pg_result = (pgsql_result_handle *) emalloc(sizeof(pgsql_result_handle));
				pg_result->conn = pgsql;
				pg_result->result = pgsql_result;
				pg_result->row = 0;
				ZEND_REGISTER_RESOURCE(return_value, pg_result, le_result);
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			break;
	}
}
/* }}} */
#endif

#if HAVE_PQPREPARE
/* {{{ proto resource pg_prepare([resource connection,] string stmtname, string query)
   Prepare a query for future execution */
PHP_FUNCTION(pg_prepare)
{
	zval *pgsql_link = NULL;
	char *query, *stmtname;
	int query_len, stmtname_len, id = -1, argc = ZEND_NUM_ARGS();
	int leftover = 0;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	pgsql_result_handle *pg_result;

	if (argc == 2) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""ss"", &stmtname, &stmtname_len, &query, &query_len) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rss"", &pgsql_link, &stmtname, &stmtname_len, &query, &query_len) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (PQ_SETNONBLOCKING(pgsql, 0)) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE,""Cannot set connection to blocking mode"");
		RETURN_FALSE;
	}
	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
		leftover = 1;
	}
	if (leftover) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found results on this connection. Use pg_get_result() to get these results first"");
	}
	pgsql_result = PQprepare(pgsql, stmtname, query, 0, NULL);
	if ((PGG(auto_reset_persistent) & 2) && PQstatus(pgsql) != CONNECTION_OK) {
		PQclear(pgsql_result);
		PQreset(pgsql);
		pgsql_result = PQprepare(pgsql, stmtname, query, 0, NULL);
	}

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}

	switch (status) {
		case PGRES_EMPTY_QUERY:
		case PGRES_BAD_RESPONSE:
		case PGRES_NONFATAL_ERROR:
		case PGRES_FATAL_ERROR:
			PHP_PQ_ERROR(""Query failed: %s"", pgsql);
			PQclear(pgsql_result);
			RETURN_FALSE;
			break;
		case PGRES_COMMAND_OK: /* successful command that did not return rows */
		default:
			if (pgsql_result) {
				pg_result = (pgsql_result_handle *) emalloc(sizeof(pgsql_result_handle));
				pg_result->conn = pgsql;
				pg_result->result = pgsql_result;
				pg_result->row = 0;
				ZEND_REGISTER_RESOURCE(return_value, pg_result, le_result);
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			break;
	}
}
/* }}} */
#endif

#if HAVE_PQEXECPREPARED
/* {{{ proto resource pg_execute([resource connection,] string stmtname, array params)
   Execute a prepared query  */
PHP_FUNCTION(pg_execute)
{
	zval *pgsql_link = NULL;
	zval *pv_param_arr, **tmp;
	char *stmtname;
	int stmtname_len, id = -1, argc = ZEND_NUM_ARGS();
	int leftover = 0;
	int num_params = 0;
	char **params = NULL;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	pgsql_result_handle *pg_result;

	if (argc == 2) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""sa/"", &stmtname, &stmtname_len, &pv_param_arr)==FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rsa/"", &pgsql_link, &stmtname, &stmtname_len, &pv_param_arr) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (PQ_SETNONBLOCKING(pgsql, 0)) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE,""Cannot set connection to blocking mode"");
		RETURN_FALSE;
	}
	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
		leftover = 1;
	}
	if (leftover) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found results on this connection. Use pg_get_result() to get these results first"");
	}

	zend_hash_internal_pointer_reset(Z_ARRVAL_P(pv_param_arr));
	num_params = zend_hash_num_elements(Z_ARRVAL_P(pv_param_arr));
	if (num_params > 0) {
		int i = 0;
		params = (char **)safe_emalloc(sizeof(char *), num_params, 0);

		for(i = 0; i < num_params; i++) {
			if (zend_hash_get_current_data(Z_ARRVAL_P(pv_param_arr), (void **) &tmp) == FAILURE) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,""Error getting parameter"");
				_php_pgsql_free_params(params, num_params);
				RETURN_FALSE;
			}

			if (Z_TYPE_PP(tmp) == IS_NULL) {
				params[i] = NULL;
			} else {
				zval tmp_val = **tmp;
				zval_copy_ctor(&tmp_val);
				convert_to_string(&tmp_val);
				if (Z_TYPE(tmp_val) != IS_STRING) {
					php_error_docref(NULL TSRMLS_CC, E_WARNING,""Error converting parameter"");
					zval_dtor(&tmp_val);
					_php_pgsql_free_params(params, num_params);
					RETURN_FALSE;
				}
				params[i] = estrndup(Z_STRVAL(tmp_val), Z_STRLEN(tmp_val));
				zval_dtor(&tmp_val);
			}

			zend_hash_move_forward(Z_ARRVAL_P(pv_param_arr));
		}
	}

	pgsql_result = PQexecPrepared(pgsql, stmtname, num_params, 
					(const char * const *)params, NULL, NULL, 0);
	if ((PGG(auto_reset_persistent) & 2) && PQstatus(pgsql) != CONNECTION_OK) {
		PQclear(pgsql_result);
		PQreset(pgsql);
		pgsql_result = PQexecPrepared(pgsql, stmtname, num_params, 
						(const char * const *)params, NULL, NULL, 0);
	}

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}

	_php_pgsql_free_params(params, num_params);

	switch (status) {
		case PGRES_EMPTY_QUERY:
		case PGRES_BAD_RESPONSE:
		case PGRES_NONFATAL_ERROR:
		case PGRES_FATAL_ERROR:
			PHP_PQ_ERROR(""Query failed: %s"", pgsql);
			PQclear(pgsql_result);
			RETURN_FALSE;
			break;
		case PGRES_COMMAND_OK: /* successful command that did not return rows */
		default:
			if (pgsql_result) {
				pg_result = (pgsql_result_handle *) emalloc(sizeof(pgsql_result_handle));
				pg_result->conn = pgsql;
				pg_result->result = pgsql_result;
				pg_result->row = 0;
				ZEND_REGISTER_RESOURCE(return_value, pg_result, le_result);
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			break;
	}
}
/* }}} */
#endif

#define PHP_PG_NUM_ROWS 1
#define PHP_PG_NUM_FIELDS 2
#define PHP_PG_CMD_TUPLES 3

/* {{{ php_pgsql_get_result_info
 */
static void php_pgsql_get_result_info(INTERNAL_FUNCTION_PARAMETERS, int entry_type)
{
	zval *result;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &result) == FAILURE) {
		return;
	}
	
	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;

	switch (entry_type) {
		case PHP_PG_NUM_ROWS:
			Z_LVAL_P(return_value) = PQntuples(pgsql_result);
			break;
		case PHP_PG_NUM_FIELDS:
			Z_LVAL_P(return_value) = PQnfields(pgsql_result);
			break;
		case PHP_PG_CMD_TUPLES:
#if HAVE_PQCMDTUPLES
			Z_LVAL_P(return_value) = atoi(PQcmdTuples(pgsql_result));
#else
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Not supported under this build"");
			Z_LVAL_P(return_value) = 0;
#endif
			break;
		default:
			RETURN_FALSE;
	}
	Z_TYPE_P(return_value) = IS_LONG;
}
/* }}} */

/* {{{ proto int pg_num_rows(resource result)
   Return the number of rows in the result */
PHP_FUNCTION(pg_num_rows)
{
	php_pgsql_get_result_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_NUM_ROWS);
}
/* }}} */

/* {{{ proto int pg_num_fields(resource result)
   Return the number of fields in the result */
PHP_FUNCTION(pg_num_fields)
{
	php_pgsql_get_result_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_NUM_FIELDS);
}
/* }}} */

#if HAVE_PQCMDTUPLES
/* {{{ proto int pg_affected_rows(resource result)
   Returns the number of affected tuples */
PHP_FUNCTION(pg_affected_rows)
{
	php_pgsql_get_result_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_CMD_TUPLES);
}
/* }}} */
#endif

/* {{{ proto string pg_last_notice(resource connection)
   Returns the last notice set by the backend */
PHP_FUNCTION(pg_last_notice) 
{
	zval *pgsql_link;
	PGconn *pg_link;
	int id = -1;
	php_pgsql_notice **notice;
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &pgsql_link) == FAILURE) {
		return;
	}
	/* Just to check if user passed valid resoruce */
	ZEND_FETCH_RESOURCE2(pg_link, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (zend_hash_index_find(&PGG(notices), Z_RESVAL_P(pgsql_link), (void **)&notice) == FAILURE) {
		RETURN_FALSE;
	}
	RETURN_STRINGL((*notice)->message, (*notice)->len, 1);
}
/* }}} */

/* {{{ get_field_name
 */
static char *get_field_name(PGconn *pgsql, Oid oid, HashTable *list TSRMLS_DC)
{
	PGresult *result;
	smart_str str = {0};
	zend_rsrc_list_entry *field_type;
	char *ret=NULL;

	/* try to lookup the type in the resource list */
	smart_str_appends(&str, ""pgsql_oid_"");
	smart_str_append_unsigned(&str, oid);
	smart_str_0(&str);

	if (zend_hash_find(list,str.c,str.len+1,(void **) &field_type)==SUCCESS) {
		ret = estrdup((char *)field_type->ptr);
	} else { /* hash all oid's */
		int i,num_rows;
		int oid_offset,name_offset;
		char *tmp_oid, *end_ptr, *tmp_name;
		zend_rsrc_list_entry new_oid_entry;

		if ((result = PQexec(pgsql,""select oid,typname from pg_type"")) == NULL || PQresultStatus(result) != PGRES_TUPLES_OK) {
			if (result) {
				PQclear(result);
			}
			smart_str_free(&str);
			return STR_EMPTY_ALLOC();
		}
		num_rows = PQntuples(result);
		oid_offset = PQfnumber(result,""oid"");
		name_offset = PQfnumber(result,""typname"");

		for (i=0; i<num_rows; i++) {
			if ((tmp_oid = PQgetvalue(result,i,oid_offset))==NULL) {
				continue;
			}
			
			str.len = 0;
			smart_str_appends(&str, ""pgsql_oid_"");
			smart_str_appends(&str, tmp_oid);
			smart_str_0(&str);

			if ((tmp_name = PQgetvalue(result,i,name_offset))==NULL) {
				continue;
			}
			Z_TYPE(new_oid_entry) = le_string;
			new_oid_entry.ptr = estrdup(tmp_name);
			zend_hash_update(list,str.c,str.len+1,(void *) &new_oid_entry, sizeof(zend_rsrc_list_entry), NULL);
			if (!ret && strtoul(tmp_oid, &end_ptr, 10)==oid) {
				ret = estrdup(tmp_name);
			}
		}
		PQclear(result);
	}

	smart_str_free(&str);
	return ret;
}
/* }}} */

#ifdef HAVE_PQFTABLE
/* {{{ proto mixed pg_field_table(resource result, int field_number[, bool oid_only])
   Returns the name of the table field belongs to, or table's oid if oid_only is true */
PHP_FUNCTION(pg_field_table)
{
	zval *result;
	pgsql_result_handle *pg_result;
	long fnum = -1;
	zend_bool return_oid = 0;
	Oid oid;
	smart_str hash_key = {0};
	char *table_name;
	zend_rsrc_list_entry *field_table;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl|b"", &result, &fnum, &return_oid) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	if (fnum < 0 || fnum >= PQnfields(pg_result->result)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Bad field offset specified"");
		RETURN_FALSE;
	}

	oid = PQftable(pg_result->result, fnum);

	if (InvalidOid == oid) {
		RETURN_FALSE;
	}

	if (return_oid) {
#if UINT_MAX > LONG_MAX /* Oid is unsigned int, we don't need this code, where LONG is wider */
		if (oid > LONG_MAX) {
			smart_str oidstr = {0};
			smart_str_append_unsigned(&oidstr, oid);
			smart_str_0(&oidstr);
			RETURN_STRINGL(oidstr.c, oidstr.len, 0);
		} else
#endif
			RETURN_LONG((long)oid);
	}

	/* try to lookup the table name in the resource list */
	smart_str_appends(&hash_key, ""pgsql_table_oid_"");
	smart_str_append_unsigned(&hash_key, oid);
	smart_str_0(&hash_key);

	if (zend_hash_find(&EG(regular_list), hash_key.c, hash_key.len+1, (void **) &field_table) == SUCCESS) {
		smart_str_free(&hash_key);
		RETURN_STRING((char *)field_table->ptr, 1);
	} else { /* Not found, lookup by querying PostgreSQL system tables */
		PGresult *tmp_res;
		smart_str querystr = {0};
		zend_rsrc_list_entry new_field_table;

		smart_str_appends(&querystr, ""select relname from pg_class where oid="");
		smart_str_append_unsigned(&querystr, oid);
		smart_str_0(&querystr);

		if ((tmp_res = PQexec(pg_result->conn, querystr.c)) == NULL || PQresultStatus(tmp_res) != PGRES_TUPLES_OK) {
			if (tmp_res) {
				PQclear(tmp_res);
			}
			smart_str_free(&querystr);
			smart_str_free(&hash_key);
			RETURN_FALSE;
		}

		smart_str_free(&querystr);

		if ((table_name = PQgetvalue(tmp_res, 0, 0)) == NULL) {
			PQclear(tmp_res);
			smart_str_free(&hash_key);
			RETURN_FALSE;
		}

		Z_TYPE(new_field_table) = le_string;
		new_field_table.ptr = estrdup(table_name);
		zend_hash_update(&EG(regular_list), hash_key.c, hash_key.len+1, (void *) &new_field_table, sizeof(zend_rsrc_list_entry), NULL);

		smart_str_free(&hash_key);
		PQclear(tmp_res);
		RETURN_STRING(table_name, 1);
	}

}
/* }}} */
#endif

#define PHP_PG_FIELD_NAME 1
#define PHP_PG_FIELD_SIZE 2
#define PHP_PG_FIELD_TYPE 3
#define PHP_PG_FIELD_TYPE_OID 4

/* {{{ php_pgsql_get_field_info
 */
static void php_pgsql_get_field_info(INTERNAL_FUNCTION_PARAMETERS, int entry_type)
{
	zval *result;
	long field;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;
	Oid oid;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl"", &result, &field) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;
	
	if (field < 0 || field >= PQnfields(pgsql_result)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Bad field offset specified"");
		RETURN_FALSE;
	}

	switch (entry_type) {
		case PHP_PG_FIELD_NAME:
			Z_STRVAL_P(return_value) = PQfname(pgsql_result, field);
			Z_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));
			Z_STRVAL_P(return_value) = estrndup(Z_STRVAL_P(return_value),Z_STRLEN_P(return_value));
			Z_TYPE_P(return_value) = IS_STRING;
			break;
		case PHP_PG_FIELD_SIZE:
			Z_LVAL_P(return_value) = PQfsize(pgsql_result, field);
			Z_TYPE_P(return_value) = IS_LONG;
			break;
		case PHP_PG_FIELD_TYPE:
			Z_STRVAL_P(return_value) = get_field_name(pg_result->conn, PQftype(pgsql_result, field), &EG(regular_list) TSRMLS_CC);
			Z_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));
			Z_TYPE_P(return_value) = IS_STRING;
			break;
		case PHP_PG_FIELD_TYPE_OID:
			
			oid = PQftype(pgsql_result, field);
#if UINT_MAX > LONG_MAX
			if (oid > LONG_MAX) {
				smart_str s = {0};
				smart_str_append_unsigned(&s, oid);
				smart_str_0(&s);
				Z_STRVAL_P(return_value) = s.c;
				Z_STRLEN_P(return_value) = s.len;
				Z_TYPE_P(return_value) = IS_STRING;
			} else
#endif
			{
				Z_LVAL_P(return_value) = (long)oid;
				Z_TYPE_P(return_value) = IS_LONG;
			}
			break;
		default:
			RETURN_FALSE;
	}
}
/* }}} */

/* {{{ proto string pg_field_name(resource result, int field_number)
   Returns the name of the field */
PHP_FUNCTION(pg_field_name)
{
	php_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_NAME);
}
/* }}} */

/* {{{ proto int pg_field_size(resource result, int field_number)
   Returns the internal size of the field */ 
PHP_FUNCTION(pg_field_size)
{
	php_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_SIZE);
}
/* }}} */

/* {{{ proto string pg_field_type(resource result, int field_number)
   Returns the type name for the given field */
PHP_FUNCTION(pg_field_type)
{
	php_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_TYPE);
}
/* }}} */


/* {{{ proto string pg_field_type_oid(resource result, int field_number)
   Returns the type oid for the given field */
PHP_FUNCTION(pg_field_type_oid)
{
	php_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_TYPE_OID);
}
/* }}} */

/* {{{ proto int pg_field_num(resource result, string field_name)
   Returns the field number of the named field */
PHP_FUNCTION(pg_field_num)
{
	zval *result;
	char *field;
	int field_len;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &result, &field, &field_len) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;

	Z_LVAL_P(return_value) = PQfnumber(pgsql_result, field);
	Z_TYPE_P(return_value) = IS_LONG;
}
/* }}} */

/* {{{ proto mixed pg_fetch_result(resource result, [int row_number,] mixed field_name)
   Returns values from a result identifier */
PHP_FUNCTION(pg_fetch_result)
{
	zval *result, **field=NULL;
	long row;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;
	int field_offset, pgsql_row, argc = ZEND_NUM_ARGS();

	if (argc == 2) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rZ"", &result, &field) == FAILURE) {
			return;
		}
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rlZ"", &result, &row, &field) == FAILURE) {
			return;
		}
	}
	
	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;
	if (argc == 2) {
		if (pg_result->row < 0) {
			pg_result->row = 0;
		}
		pgsql_row = pg_result->row;
		if (pgsql_row >= PQntuples(pgsql_result)) {
			RETURN_FALSE;
		}
	} else {
		pgsql_row = row;
		if (pgsql_row < 0 || pgsql_row >= PQntuples(pgsql_result)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to jump to row %ld on PostgreSQL result index %ld"",
							row, Z_LVAL_P(result));
			RETURN_FALSE;
		}
	}
	switch(Z_TYPE_PP(field)) {
		case IS_STRING:
			field_offset = PQfnumber(pgsql_result, Z_STRVAL_PP(field));
			break;
		default:
			convert_to_long_ex(field);
			field_offset = Z_LVAL_PP(field);
			break;
	}
	if (field_offset<0 || field_offset>=PQnfields(pgsql_result)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Bad column offset specified"");
		RETURN_FALSE;
	}

	if (PQgetisnull(pgsql_result, pgsql_row, field_offset)) {
		Z_TYPE_P(return_value) = IS_NULL;
	} else {
		char *value = PQgetvalue(pgsql_result, pgsql_row, field_offset);
		int value_len = PQgetlength(pgsql_result, pgsql_row, field_offset);
		ZVAL_STRINGL(return_value, value, value_len, 1);
	}
}
/* }}} */

/* {{{ void php_pgsql_fetch_hash */
static void php_pgsql_fetch_hash(INTERNAL_FUNCTION_PARAMETERS, long result_type, int into_object)
{
	zval                *result, *zrow = NULL;
	PGresult            *pgsql_result;
	pgsql_result_handle *pg_result;
	int             i, num_fields, pgsql_row, use_row;
	long            row = -1;
	char            *field_name;
	zval            *ctor_params = NULL;
	zend_class_entry *ce = NULL;

	if (into_object) {
		char *class_name = NULL;
		int class_name_len;

		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r|z!sz"", &result, &zrow, &class_name, &class_name_len, &ctor_params) == FAILURE) {
			return;
		}
		if (!class_name) {
			ce = zend_standard_class_def;
		} else {
			ce = zend_fetch_class(class_name, class_name_len, ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
		}
		if (!ce) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Could not find class '%s'"", class_name);
			return;
		}
		result_type = PGSQL_ASSOC;
	} else {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r|z!l"", &result, &zrow, &result_type) == FAILURE) {
			return;
		}
	}
	if (zrow == NULL) {
		row = -1;
	} else {
		convert_to_long(zrow);
		row = Z_LVAL_P(zrow);
		if (row < 0) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The row parameter must be greater or equal to zero"");
			RETURN_FALSE;
		}
	}
	use_row = ZEND_NUM_ARGS() > 1 && row != -1;

	if (!(result_type & PGSQL_BOTH)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid result type"");
		RETURN_FALSE;
	}
	
	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;

	if (use_row) { 
		pgsql_row = row;
		pg_result->row = pgsql_row;
		if (pgsql_row < 0 || pgsql_row >= PQntuples(pgsql_result)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to jump to row %ld on PostgreSQL result index %ld"",
							row, Z_LVAL_P(result));
			RETURN_FALSE;
		}
	} else {
		/* If 2nd param is NULL, use internal row counter to access next row */
		pgsql_row = pg_result->row;
		if (pgsql_row < 0 || pgsql_row >= PQntuples(pgsql_result)) {
			RETURN_FALSE;
		}
		pg_result->row++;
	}

	array_init(return_value);
	for (i = 0, num_fields = PQnfields(pgsql_result); i < num_fields; i++) {
		if (PQgetisnull(pgsql_result, pgsql_row, i)) {
			if (result_type & PGSQL_NUM) {
				add_index_null(return_value, i);
			}
			if (result_type & PGSQL_ASSOC) {
				field_name = PQfname(pgsql_result, i);
				add_assoc_null(return_value, field_name);
			}
		} else {
			char *element = PQgetvalue(pgsql_result, pgsql_row, i);
			if (element) {
				char *data;
				int data_len;
				int should_copy=0;
				const uint element_len = strlen(element);

				data = safe_estrndup(element, element_len);
				data_len = element_len;

				if (result_type & PGSQL_NUM) {
					add_index_stringl(return_value, i, data, data_len, should_copy);
					should_copy=1;
				}

				if (result_type & PGSQL_ASSOC) {
					field_name = PQfname(pgsql_result, i);
					add_assoc_stringl(return_value, field_name, data, data_len, should_copy);
				}
			}
		}
	}

	if (into_object) {
		zval dataset = *return_value;
		zend_fcall_info fci;
		zend_fcall_info_cache fcc;
		zval *retval_ptr;

		object_and_properties_init(return_value, ce, NULL);
		zend_merge_properties(return_value, Z_ARRVAL(dataset), 1 TSRMLS_CC);

		if (ce->constructor) {
			fci.size = sizeof(fci);
			fci.function_table = &ce->function_table;
			fci.function_name = NULL;
			fci.symbol_table = NULL;
			fci.object_ptr = return_value;
			fci.retval_ptr_ptr = &retval_ptr;
			if (ctor_params && Z_TYPE_P(ctor_params) != IS_NULL) {
				if (Z_TYPE_P(ctor_params) == IS_ARRAY) {
					HashTable *ht = Z_ARRVAL_P(ctor_params);
					Bucket *p;

					fci.param_count = 0;
					fci.params = safe_emalloc(sizeof(zval***), ht->nNumOfElements, 0);
					p = ht->pListHead;
					while (p != NULL) {
						fci.params[fci.param_count++] = (zval**)p->pData;
						p = p->pListNext;
					}
				} else {
					/* Two problems why we throw exceptions here: PHP is typeless
					 * and hence passing one argument that's not an array could be
					 * by mistake and the other way round is possible, too. The 
					 * single value is an array. Also we'd have to make that one
					 * argument passed by reference.
					 */
					zend_throw_exception(zend_exception_get_default(TSRMLS_C), ""Parameter ctor_params must be an array"", 0 TSRMLS_CC);
					return;
				}
			} else {
				fci.param_count = 0;
				fci.params = NULL;
			}
			fci.no_separation = 1;

			fcc.initialized = 1;
			fcc.function_handler = ce->constructor;
			fcc.calling_scope = EG(scope);
			fcc.called_scope = Z_OBJCE_P(return_value);
			fcc.object_ptr = return_value;

			if (zend_call_function(&fci, &fcc TSRMLS_CC) == FAILURE) {
				zend_throw_exception_ex(zend_exception_get_default(TSRMLS_C), 0 TSRMLS_CC, ""Could not execute %s::%s()"", ce->name, ce->constructor->common.function_name);
			} else {
				if (retval_ptr) {
					zval_ptr_dtor(&retval_ptr);
				}
			}
			if (fci.params) {
				efree(fci.params);
			}
		} else if (ctor_params) {
			zend_throw_exception_ex(zend_exception_get_default(TSRMLS_C), 0 TSRMLS_CC, ""Class %s does not have a constructor hence you cannot use ctor_params"", ce->name);
		}
	}
}
/* }}} */

/* {{{ proto array pg_fetch_row(resource result [, int row [, int result_type]])
   Get a row as an enumerated array */ 
PHP_FUNCTION(pg_fetch_row)
{
	php_pgsql_fetch_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, PGSQL_NUM, 0);
}
/* }}} */

/* {{{ proto array pg_fetch_assoc(resource result [, int row])
   Fetch a row as an assoc array */
PHP_FUNCTION(pg_fetch_assoc)
{
	/* pg_fetch_assoc() is added from PHP 4.3.0. It should raise error, when
	   there is 3rd parameter */
	if (ZEND_NUM_ARGS() > 2)
		WRONG_PARAM_COUNT;
	php_pgsql_fetch_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, PGSQL_ASSOC, 0);
}
/* }}} */

/* {{{ proto array pg_fetch_array(resource result [, int row [, int result_type]])
   Fetch a row as an array */
PHP_FUNCTION(pg_fetch_array)
{
	php_pgsql_fetch_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, PGSQL_BOTH, 0);
}
/* }}} */

/* {{{ proto object pg_fetch_object(resource result [, int row [, string class_name [, NULL|array ctor_params]]])
   Fetch a row as an object */
PHP_FUNCTION(pg_fetch_object)
{
	/* pg_fetch_object() allowed result_type used to be. 3rd parameter
	   must be allowed for compatibility */
	php_pgsql_fetch_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, PGSQL_ASSOC, 1);
}
/* }}} */

/* {{{ proto array pg_fetch_all(resource result)
   Fetch all rows into array */
PHP_FUNCTION(pg_fetch_all)
{
	zval *result;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &result) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;
	array_init(return_value);
	if (php_pgsql_result2array(pgsql_result, return_value TSRMLS_CC) == FAILURE) {
		zval_dtor(return_value);
		RETURN_FALSE;
	}
}
/* }}} */

/* {{{ proto array pg_fetch_all_columns(resource result [, int column_number])
   Fetch all rows into array */
PHP_FUNCTION(pg_fetch_all_columns)
{
	zval *result;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;
	unsigned long colno=0;
	int pg_numrows, pg_row;
	size_t num_fields;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r|l"", &result, &colno) == FAILURE) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;

	num_fields = PQnfields(pgsql_result);
	if (colno >= num_fields || colno < 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid column number '%ld'"", colno);
		RETURN_FALSE;
	}

	array_init(return_value);

	if ((pg_numrows = PQntuples(pgsql_result)) <= 0) {
		return;
	}

	for (pg_row = 0; pg_row < pg_numrows; pg_row++) {
		if (PQgetisnull(pgsql_result, pg_row, colno)) {
			add_next_index_null(return_value);
		} else {
			add_next_index_string(return_value, PQgetvalue(pgsql_result, pg_row, colno), 1); 
		}
	}
}
/* }}} */

/* {{{ proto bool pg_result_seek(resource result, int offset)
   Set internal row offset */
PHP_FUNCTION(pg_result_seek)
{
	zval *result;
	long row;
	pgsql_result_handle *pg_result;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl"", &result, &row) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	if (row < 0 || row >= PQntuples(pg_result->result)) {
		RETURN_FALSE;
	}

	/* seek to offset */
	pg_result->row = row;
	RETURN_TRUE;
}
/* }}} */


#define PHP_PG_DATA_LENGTH 1
#define PHP_PG_DATA_ISNULL 2

/* {{{ php_pgsql_data_info
 */
static void php_pgsql_data_info(INTERNAL_FUNCTION_PARAMETERS, int entry_type)
{
	zval *result, **field;
	long row;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;
	int field_offset, pgsql_row, argc = ZEND_NUM_ARGS();

	if (argc == 2) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rZ"", &result, &field) == FAILURE) {
			return;
		}
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rlZ"", &result, &row, &field) == FAILURE) {
			return;
		}
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;
	if (argc == 2) {
		if (pg_result->row < 0) {
			pg_result->row = 0;
		}
		pgsql_row = pg_result->row;
		if (pgsql_row < 0 || pgsql_row >= PQntuples(pgsql_result)) {
			RETURN_FALSE;
		}
	} else {
		pgsql_row = row;
		if (pgsql_row < 0 || pgsql_row >= PQntuples(pgsql_result)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to jump to row %ld on PostgreSQL result index %ld"",
							row, Z_LVAL_P(result));
			RETURN_FALSE;
		}
	}

	switch(Z_TYPE_PP(field)) {
		case IS_STRING:
			convert_to_string_ex(field);
			field_offset = PQfnumber(pgsql_result, Z_STRVAL_PP(field));
			break;
		default:
			convert_to_long_ex(field);
			field_offset = Z_LVAL_PP(field);
			break;
	}
	if (field_offset < 0 || field_offset >= PQnfields(pgsql_result)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Bad column offset specified"");
		RETURN_FALSE;
	}

	switch (entry_type) {
		case PHP_PG_DATA_LENGTH:
			Z_LVAL_P(return_value) = PQgetlength(pgsql_result, pgsql_row, field_offset);
			break;
		case PHP_PG_DATA_ISNULL:
			Z_LVAL_P(return_value) = PQgetisnull(pgsql_result, pgsql_row, field_offset);
			break;
	}
	Z_TYPE_P(return_value) = IS_LONG;
}
/* }}} */

/* {{{ proto int pg_field_prtlen(resource result, [int row,] mixed field_name_or_number)
   Returns the printed length */
PHP_FUNCTION(pg_field_prtlen)
{
	php_pgsql_data_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_PG_DATA_LENGTH);
}
/* }}} */

/* {{{ proto int pg_field_is_null(resource result, [int row,] mixed field_name_or_number)
   Test if a field is NULL */
PHP_FUNCTION(pg_field_is_null)
{
	php_pgsql_data_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_PG_DATA_ISNULL);
}
/* }}} */

/* {{{ proto bool pg_free_result(resource result)
   Free result memory */
PHP_FUNCTION(pg_free_result)
{
	zval *result;
	pgsql_result_handle *pg_result;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &result) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);
	if (Z_LVAL_P(result) == 0) {
		RETURN_FALSE;
	}
	zend_list_delete(Z_RESVAL_P(result));
	RETURN_TRUE;
}
/* }}} */

/* {{{ proto string pg_last_oid(resource result)
   Returns the last object identifier */
PHP_FUNCTION(pg_last_oid)
{
	zval *result;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;
#ifdef HAVE_PQOIDVALUE
	Oid oid;
#endif

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &result) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);
	pgsql_result = pg_result->result;
#ifdef HAVE_PQOIDVALUE
	oid = PQoidValue(pgsql_result);
	if (oid == InvalidOid) {
		RETURN_FALSE;
	}
	PGSQL_RETURN_OID(oid);
#else
	Z_STRVAL_P(return_value) = (char *) PQoidStatus(pgsql_result);
	if (Z_STRVAL_P(return_value)) {
		RETURN_STRING(Z_STRVAL_P(return_value), 1);
	}
	RETURN_STRING("""", 1);
#endif
}
/* }}} */

/* {{{ proto bool pg_trace(string filename [, string mode [, resource connection]])
   Enable tracing a PostgreSQL connection */
PHP_FUNCTION(pg_trace)
{
	char *z_filename, *mode = ""w"";
	int z_filename_len, mode_len;
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	FILE *fp = NULL;
        php_stream *stream;
        id = PGG(default_link);
 
       if (zend_parse_parameters(argc TSRMLS_CC, ""s|sr"", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {
                return;
        }
	if (argc < 3) {
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	stream = php_stream_open_wrapper(z_filename, mode, REPORT_ERRORS, NULL);

	if (!stream) {
		RETURN_FALSE;
	}

	if (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&fp, REPORT_ERRORS))	{
		php_stream_close(stream);
		RETURN_FALSE;
	}
	php_stream_auto_cleanup(stream);
	PQtrace(pgsql, fp);
	RETURN_TRUE;
}
/* }}} */

/* {{{ proto bool pg_untrace([resource connection])
   Disable tracing of a PostgreSQL connection */
PHP_FUNCTION(pg_untrace)
{
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	
	if (zend_parse_parameters(argc TSRMLS_CC, ""|r"", &pgsql_link) == FAILURE) {
		return;
	}

	if (argc == 0) { 
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);
	PQuntrace(pgsql);
	RETURN_TRUE;
}
/* }}} */

/* {{{ proto mixed pg_lo_create([resource connection],[mixed large_object_oid])
   Create a large object */
PHP_FUNCTION(pg_lo_create)
{
	zval *pgsql_link = NULL, *oid = NULL;
	PGconn *pgsql;
	Oid pgsql_oid, wanted_oid = InvalidOid;
	int id = -1, argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""|zz"", &pgsql_link, &oid) == FAILURE) {
		return;
	}

	if ((argc == 1) && (Z_TYPE_P(pgsql_link) != IS_RESOURCE)) {
		oid = pgsql_link;
		pgsql_link = NULL;
	}
	
	if (pgsql_link == NULL) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
		if (id == -1) {
			RETURN_FALSE;
		}
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);
	
	if (oid) {
#ifndef HAVE_PG_LO_CREATE
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Passing OID value is not supported. Upgrade your PostgreSQL"");
#else
		switch (Z_TYPE_P(oid)) {
		case IS_STRING:
			{
				char *end_ptr;
				wanted_oid = (Oid)strtoul(Z_STRVAL_P(oid), &end_ptr, 10);
				if ((Z_STRVAL_P(oid)+Z_STRLEN_P(oid)) != end_ptr) {
				/* wrong integer format */
				php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
				RETURN_FALSE;
				}
			}
			break;
		case IS_LONG:
			if (Z_LVAL_P(oid) < (long)InvalidOid) {
				php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
				RETURN_FALSE;
			}
			wanted_oid = (Oid)Z_LVAL_P(oid);
			break;
		default:
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
			RETURN_FALSE;
        }
		if ((pgsql_oid = lo_create(pgsql, wanted_oid)) == InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to create PostgreSQL large object"");
			RETURN_FALSE;
		}

		PGSQL_RETURN_OID(pgsql_oid);
#endif
	}

	if ((pgsql_oid = lo_creat(pgsql, INV_READ|INV_WRITE)) == InvalidOid) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to create PostgreSQL large object"");
		RETURN_FALSE;
	}

	PGSQL_RETURN_OID(pgsql_oid);
}
/* }}} */

/* {{{ proto bool pg_lo_unlink([resource connection,] string large_object_oid)
   Delete a large object */
PHP_FUNCTION(pg_lo_unlink)
{
	zval *pgsql_link = NULL;
	long oid_long;
	char *oid_string, *end_ptr;
	int oid_strlen;
	PGconn *pgsql;
	Oid oid;
	int id = -1;
	int argc = ZEND_NUM_ARGS();

	/* accept string type since Oid type is unsigned int */
	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rs"", &pgsql_link, &oid_string, &oid_strlen) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rl"", &pgsql_link, &oid_long) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""s"", &oid_string, &oid_strlen) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""l"", &oid_long) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID is specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Requires 1 or 2 arguments"");
		RETURN_FALSE;
	}
	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (lo_unlink(pgsql, oid) == -1) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to delete PostgreSQL large object %u"", oid);
		RETURN_FALSE;
	}
	RETURN_TRUE;
}
/* }}} */

/* {{{ proto resource pg_lo_open([resource connection,] int large_object_oid, string mode)
   Open a large object and return fd */
PHP_FUNCTION(pg_lo_open)
{
	zval *pgsql_link = NULL;
	long oid_long;
	char *oid_string, *end_ptr, *mode_string;
	int oid_strlen, mode_strlen;
	PGconn *pgsql;
	Oid oid;
	int id = -1, pgsql_mode=0, pgsql_lofd;
	int create=0;
	pgLofp *pgsql_lofp;
	int argc = ZEND_NUM_ARGS();

	/* accept string type since Oid is unsigned int */
	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rss"", &pgsql_link, &oid_string, &oid_strlen, &mode_string, &mode_strlen) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rls"", &pgsql_link, &oid_long, &mode_string, &mode_strlen) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""ss"", &oid_string, &oid_strlen, &mode_string, &mode_strlen) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""ls"", &oid_long, &mode_string, &mode_strlen) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Requires 1 or 2 arguments"");
		RETURN_FALSE;
	}
	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);
	
	/* r/w/+ is little bit more PHP-like than INV_READ/INV_WRITE and a lot of
	   faster to type. Unfortunately, doesn't behave the same way as fopen()...
	   (Jouni)
	*/

	if (strchr(mode_string, 'r') == mode_string) {
		pgsql_mode |= INV_READ;
		if (strchr(mode_string, '+') == mode_string+1) {
			pgsql_mode |= INV_WRITE;
		}
	}
	if (strchr(mode_string, 'w') == mode_string) {
		pgsql_mode |= INV_WRITE;
		create = 1;
		if (strchr(mode_string, '+') == mode_string+1) {
			pgsql_mode |= INV_READ;
		}
	}

	pgsql_lofp = (pgLofp *) emalloc(sizeof(pgLofp));

	if ((pgsql_lofd = lo_open(pgsql, oid, pgsql_mode)) == -1) {
		if (create) {
			if ((oid = lo_creat(pgsql, INV_READ|INV_WRITE)) == 0) {
				efree(pgsql_lofp);
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to create PostgreSQL large object"");
				RETURN_FALSE;
			} else {
				if ((pgsql_lofd = lo_open(pgsql, oid, pgsql_mode)) == -1) {
					if (lo_unlink(pgsql, oid) == -1) {
						efree(pgsql_lofp);
						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Something is really messed up! Your database is badly corrupted in a way NOT related to PHP"");
						RETURN_FALSE;
					}
					efree(pgsql_lofp);
					php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to open PostgreSQL large object"");
					RETURN_FALSE;
				} else {
					pgsql_lofp->conn = pgsql;
					pgsql_lofp->lofd = pgsql_lofd;
					Z_LVAL_P(return_value) = zend_list_insert(pgsql_lofp, le_lofp TSRMLS_CC);
					Z_TYPE_P(return_value) = IS_LONG;
				}
			}
		} else {
			efree(pgsql_lofp);
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to open PostgreSQL large object"");
			RETURN_FALSE;
		}
	} else {
		pgsql_lofp->conn = pgsql;
		pgsql_lofp->lofd = pgsql_lofd;
		ZEND_REGISTER_RESOURCE(return_value, pgsql_lofp, le_lofp);
	}
}
/* }}} */

/* {{{ proto bool pg_lo_close(resource large_object)
   Close a large object */
PHP_FUNCTION(pg_lo_close)
{
	zval *pgsql_lofp;
	pgLofp *pgsql;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &pgsql_lofp) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_lofp, -1, ""PostgreSQL large object"", le_lofp);
	
	if (lo_close((PGconn *)pgsql->conn, pgsql->lofd) < 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to close PostgreSQL large object descriptor %d"", pgsql->lofd);
		RETVAL_FALSE;
	} else {
		RETVAL_TRUE;
	}

	zend_list_delete(Z_RESVAL_P(pgsql_lofp));
	return;
}
/* }}} */

#define PGSQL_LO_READ_BUF_SIZE  8192

/* {{{ proto string pg_lo_read(resource large_object [, int len])
   Read a large object */
PHP_FUNCTION(pg_lo_read)
{
	zval *pgsql_id;
	long len;
	int buf_len = PGSQL_LO_READ_BUF_SIZE, nbytes, argc = ZEND_NUM_ARGS();
	char *buf;
	pgLofp *pgsql;

	if (zend_parse_parameters(argc TSRMLS_CC, ""r|l"", &pgsql_id, &len) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	if (argc > 1) {
		buf_len = len;
	}
	
	buf = (char *) safe_emalloc(sizeof(char), (buf_len+1), 0);
	if ((nbytes = lo_read((PGconn *)pgsql->conn, pgsql->lofd, buf, buf_len))<0) {
		efree(buf);
		RETURN_FALSE;
	}

	buf[nbytes] = '\0';
	RETURN_STRINGL(buf, nbytes, 0);
}
/* }}} */

/* {{{ proto int pg_lo_write(resource large_object, string buf [, int len])
   Write a large object */
PHP_FUNCTION(pg_lo_write)
{
  	zval *pgsql_id;
  	char *str;
  	long z_len;
	int str_len, nbytes;
	int len;
	pgLofp *pgsql;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""rs|l"", &pgsql_id, &str, &str_len, &z_len) == FAILURE) {
		return;
	}

	if (argc > 2) {
		if (z_len > str_len) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Cannot write more than buffer size %d. Tried to write %ld"", str_len, z_len);
			RETURN_FALSE;
		}
		if (z_len < 0) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Buffer size must be larger than 0, but %ld was specified"", z_len);
			RETURN_FALSE;
		}
		len = z_len;
	}
	else {
		len = str_len;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	if ((nbytes = lo_write((PGconn *)pgsql->conn, pgsql->lofd, str, len)) == -1) {
		RETURN_FALSE;
	}

	RETURN_LONG(nbytes);
}
/* }}} */

/* {{{ proto int pg_lo_read_all(resource large_object)
   Read a large object and send straight to browser */
PHP_FUNCTION(pg_lo_read_all)
{
  	zval *pgsql_id;
	int tbytes;
	volatile int nbytes;
	char buf[PGSQL_LO_READ_BUF_SIZE];
	pgLofp *pgsql;
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &pgsql_id) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	tbytes = 0;
	while ((nbytes = lo_read((PGconn *)pgsql->conn, pgsql->lofd, buf, PGSQL_LO_READ_BUF_SIZE))>0) {
		PHPWRITE(buf, nbytes);
		tbytes += nbytes;
	}
	RETURN_LONG(tbytes);
}
/* }}} */

/* {{{ proto int pg_lo_import([resource connection, ] string filename [, mixed oid])
   Import large object direct from filesystem */
PHP_FUNCTION(pg_lo_import)
{
	zval *pgsql_link = NULL, *oid = NULL;
	char *file_in;
	int id = -1, name_len;
	int argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	Oid returned_oid;

	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rp|z"", &pgsql_link, &file_in, &name_len, &oid) == SUCCESS) {
		;
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
									  ""p|z"", &file_in, &name_len, &oid) == SUCCESS) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	/* old calling convention, deprecated since PHP 4.2 */
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
									  ""pr"", &file_in, &name_len, &pgsql_link ) == SUCCESS) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Old API is used"");
	}
	else {
		WRONG_PARAM_COUNT;
	}
	
	if (php_check_open_basedir(file_in TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (oid) {
#ifndef HAVE_PG_LO_IMPORT_WITH_OID
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""OID value passing not supported"");
#else
		Oid wanted_oid;
		switch (Z_TYPE_P(oid)) {
		case IS_STRING:
			{
				char *end_ptr;
				wanted_oid = (Oid)strtoul(Z_STRVAL_P(oid), &end_ptr, 10);
				if ((Z_STRVAL_P(oid)+Z_STRLEN_P(oid)) != end_ptr) {
				/* wrong integer format */
				php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
				RETURN_FALSE;
				}
			}
			break;
		case IS_LONG:
			if (Z_LVAL_P(oid) < (long)InvalidOid) {
				php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
				RETURN_FALSE;
			}
			wanted_oid = (Oid)Z_LVAL_P(oid);
			break;
		default:
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
			RETURN_FALSE;
        }

       returned_oid = lo_import_with_oid(pgsql, file_in, wanted_oid);

	   if (returned_oid == InvalidOid) {
		   RETURN_FALSE;
	   }

	   PGSQL_RETURN_OID(returned_oid);
#endif
	}

	returned_oid = lo_import(pgsql, file_in);

	if (returned_oid == InvalidOid) {
		RETURN_FALSE;
	}
	PGSQL_RETURN_OID(returned_oid);
}
/* }}} */

/* {{{ proto bool pg_lo_export([resource connection, ] int objoid, string filename)
   Export large object direct to filesystem */
PHP_FUNCTION(pg_lo_export)
{
	zval *pgsql_link = NULL;
	char *file_out, *oid_string, *end_ptr;
	int oid_strlen;
	int id = -1, name_len;
	long oid_long;
	Oid oid;
	PGconn *pgsql;
	int argc = ZEND_NUM_ARGS();

	/* allow string to handle large OID value correctly */
	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rlp"", &pgsql_link, &oid_long, &file_out, &name_len) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rss"", &pgsql_link, &oid_string, &oid_strlen, &file_out, &name_len) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
									  ""lp"",  &oid_long, &file_out, &name_len) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""sp"", &oid_string, &oid_strlen, &file_out, &name_len) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""spr"", &oid_string, &oid_strlen, &file_out, &name_len, &pgsql_link) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
									  ""lpr"", &oid_long, &file_out, &name_len, &pgsql_link) == SUCCESS) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Old API is used"");
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
	}
	else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Requires 2 or 3 arguments"");
		RETURN_FALSE;
	}
	
	if (php_check_open_basedir(file_out TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (lo_export(pgsql, oid, file_out)) {
		RETURN_TRUE;
	}
	RETURN_FALSE;
}
/* }}} */

/* {{{ proto bool pg_lo_seek(resource large_object, int offset [, int whence])
   Seeks position of large object */
PHP_FUNCTION(pg_lo_seek)
{
	zval *pgsql_id = NULL;
	long offset = 0, whence = SEEK_CUR;
	pgLofp *pgsql;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""rl|l"", &pgsql_id, &offset, &whence) == FAILURE) {
		return;
	}
	if (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid whence parameter"");
		return;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	if (lo_lseek((PGconn *)pgsql->conn, pgsql->lofd, offset, whence) > -1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}
}
/* }}} */

/* {{{ proto int pg_lo_tell(resource large_object)
   Returns current position of large object */
PHP_FUNCTION(pg_lo_tell)
{
	zval *pgsql_id = NULL;
	int offset = 0;
	pgLofp *pgsql;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""r"", &pgsql_id) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	offset = lo_tell((PGconn *)pgsql->conn, pgsql->lofd);
	RETURN_LONG(offset);
}
/* }}} */

#if HAVE_PQSETERRORVERBOSITY
/* {{{ proto int pg_set_error_verbosity([resource connection,] int verbosity)
   Set error verbosity */
PHP_FUNCTION(pg_set_error_verbosity)
{
	zval *pgsql_link = NULL;
	long verbosity;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;

	if (argc == 1) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""l"", &verbosity) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rl"", &pgsql_link, &verbosity) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}	

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (verbosity & (PQERRORS_TERSE|PQERRORS_DEFAULT|PQERRORS_VERBOSE)) {
		Z_LVAL_P(return_value) = PQsetErrorVerbosity(pgsql, verbosity);
		Z_TYPE_P(return_value) = IS_LONG;
	} else {
		RETURN_FALSE;
	}
}
/* }}} */
#endif

#ifdef HAVE_PQCLIENTENCODING
/* {{{ proto int pg_set_client_encoding([resource connection,] string encoding)
   Set client encoding */
PHP_FUNCTION(pg_set_client_encoding)
{
	char *encoding;
	int encoding_len;
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;

	if (argc == 1) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""s"", &encoding, &encoding_len) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rs"", &pgsql_link, &encoding, &encoding_len) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	Z_LVAL_P(return_value) = PQsetClientEncoding(pgsql, encoding);
	Z_TYPE_P(return_value) = IS_LONG;
}
/* }}} */

/* {{{ proto string pg_client_encoding([resource connection])
   Get the current client encoding */
PHP_FUNCTION(pg_client_encoding)
{
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;

	if (zend_parse_parameters(argc TSRMLS_CC, ""|r"", &pgsql_link) == FAILURE) {
		return;
	}
	
	if (argc == 0) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}	

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	/* Just do the same as found in PostgreSQL sources... */

	Z_STRVAL_P(return_value) = (char *) pg_encoding_to_char(PQclientEncoding(pgsql));
	Z_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));
	Z_STRVAL_P(return_value) = (char *) estrdup(Z_STRVAL_P(return_value));
	Z_TYPE_P(return_value) = IS_STRING;
}
/* }}} */
#endif

#if !HAVE_PQGETCOPYDATA
#define	COPYBUFSIZ	8192
#endif

/* {{{ proto bool pg_end_copy([resource connection])
   Sync with backend. Completes the Copy command */
PHP_FUNCTION(pg_end_copy)
{
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	int result = 0;

	if (zend_parse_parameters(argc TSRMLS_CC, ""|r"", &pgsql_link) == FAILURE) {
		return;
	}
	
	if (argc == 0) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	result = PQendcopy(pgsql);

	if (result!=0) {
		PHP_PQ_ERROR(""Query failed: %s"", pgsql);
		RETURN_FALSE;
	}
	RETURN_TRUE;
}
/* }}} */


/* {{{ proto bool pg_put_line([resource connection,] string query)
   Send null-terminated string to backend server*/
PHP_FUNCTION(pg_put_line)
{
	char *query;
	zval *pgsql_link = NULL;
	int query_len, id = -1;
	PGconn *pgsql;
	int result = 0, argc = ZEND_NUM_ARGS();

	if (argc == 1) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""s"", &query, &query_len) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rs"", &pgsql_link, &query, &query_len) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}	

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	result = PQputline(pgsql, query);
	if (result==EOF) {
		PHP_PQ_ERROR(""Query failed: %s"", pgsql);
		RETURN_FALSE;
	}
	RETURN_TRUE;
}
/* }}} */

/* {{{ proto array pg_copy_to(resource connection, string table_name [, string delimiter [, string null_as]])
   Copy table to array */
PHP_FUNCTION(pg_copy_to)
{
	zval *pgsql_link;
	char *table_name, *pg_delim = NULL, *pg_null_as = NULL;
	int table_name_len, pg_delim_len, pg_null_as_len, free_pg_null = 0;
	char *query;
	int id = -1;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	int copydone = 0;
#if !HAVE_PQGETCOPYDATA
	char copybuf[COPYBUFSIZ];
#endif
	char *csv = (char *)NULL;
	int ret;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""rs|ss"",
							  &pgsql_link, &table_name, &table_name_len,
							  &pg_delim, &pg_delim_len, &pg_null_as, &pg_null_as_len) == FAILURE) {
		return;
	}
	if (!pg_delim) {
		pg_delim = ""\t"";
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (!pg_null_as) {
		pg_null_as = safe_estrdup(""\\\\N"");
		free_pg_null = 1;
	}

	spprintf(&query, 0, ""COPY %s TO STDOUT DELIMITERS E'%c' WITH NULL AS E'%s'"", table_name, *pg_delim, pg_null_as);

	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
	}
	pgsql_result = PQexec(pgsql, query);
	if (free_pg_null) {
		efree(pg_null_as);
	}
	efree(query);

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}

	switch (status) {
		case PGRES_COPY_OUT:
			if (pgsql_result) {
				PQclear(pgsql_result);
				array_init(return_value);
#if HAVE_PQGETCOPYDATA
				while (!copydone)
				{
					ret = PQgetCopyData(pgsql, &csv, 0);
					switch (ret) {
						case -1:
							copydone = 1;
							break;
						case 0:
						case -2:
							PHP_PQ_ERROR(""getline failed: %s"", pgsql);
							RETURN_FALSE;
							break;
						default:
							add_next_index_string(return_value, csv, 1);
							PQfreemem(csv);
							break;
					}
				}
#else
				while (!copydone)
				{
					if ((ret = PQgetline(pgsql, copybuf, COPYBUFSIZ))) {
						PHP_PQ_ERROR(""getline failed: %s"", pgsql);
						RETURN_FALSE;
					}

					if (copybuf[0] == '\\' &&
						copybuf[1] == '.' &&
						copybuf[2] == '\0')
					{
						copydone = 1;
					}
					else
					{
						if (csv == (char *)NULL) {
							csv = estrdup(copybuf);
						} else {
							csv = (char *)erealloc(csv, strlen(csv) + sizeof(char)*(COPYBUFSIZ+1));
							strcat(csv, copybuf);
						}
							
						switch (ret)
						{
							case EOF:
								copydone = 1;
							case 0:
								add_next_index_string(return_value, csv, 1);
								efree(csv);
								csv = (char *)NULL;
								break;
							case 1:
								break;
						}
					}
				}
				if (PQendcopy(pgsql)) {
					PHP_PQ_ERROR(""endcopy failed: %s"", pgsql);
					RETURN_FALSE;
				}
#endif
				while ((pgsql_result = PQgetResult(pgsql))) {
					PQclear(pgsql_result);
				}
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			break;
		default:
			PQclear(pgsql_result);
			PHP_PQ_ERROR(""Copy command failed: %s"", pgsql);
			RETURN_FALSE;
			break;
	}
}
/* }}} */

/* {{{ proto bool pg_copy_from(resource connection, string table_name , array rows [, string delimiter [, string null_as]])
   Copy table from array */
PHP_FUNCTION(pg_copy_from)
{
	zval *pgsql_link = NULL, *pg_rows;
	zval **tmp;
	char *table_name, *pg_delim = NULL, *pg_null_as = NULL;
	int  table_name_len, pg_delim_len, pg_null_as_len;
	int  pg_null_as_free = 0;
	char *query;
	HashPosition pos;
	int id = -1;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""rsa|ss"",
							  &pgsql_link, &table_name, &table_name_len, &pg_rows,
							  &pg_delim, &pg_delim_len, &pg_null_as, &pg_null_as_len) == FAILURE) {
		return;
	}
	if (!pg_delim) {
		pg_delim = ""\t"";
	}
	if (!pg_null_as) {
		pg_null_as = safe_estrdup(""\\\\N"");
		pg_null_as_free = 1;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	spprintf(&query, 0, ""COPY %s FROM STDIN DELIMITERS E'%c' WITH NULL AS E'%s'"", table_name, *pg_delim, pg_null_as);
	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
	}
	pgsql_result = PQexec(pgsql, query);

	if (pg_null_as_free) {
		efree(pg_null_as);
	}
	efree(query);

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}

	switch (status) {
		case PGRES_COPY_IN:
			if (pgsql_result) {
				int command_failed = 0;
				PQclear(pgsql_result);
				zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(pg_rows), &pos);
#if HAVE_PQPUTCOPYDATA
				while (zend_hash_get_current_data_ex(Z_ARRVAL_P(pg_rows), (void **) &tmp, &pos) == SUCCESS) {
					convert_to_string_ex(tmp);
					query = (char *)emalloc(Z_STRLEN_PP(tmp) + 2);
					strlcpy(query, Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp) + 2);
					if(Z_STRLEN_PP(tmp) > 0 && *(query + Z_STRLEN_PP(tmp) - 1) != '\n') {
						strlcat(query, ""\n"", Z_STRLEN_PP(tmp) + 2);
					}
					if (PQputCopyData(pgsql, query, strlen(query)) != 1) {
						efree(query);
						PHP_PQ_ERROR(""copy failed: %s"", pgsql);
						RETURN_FALSE;
					}
					efree(query);
					zend_hash_move_forward_ex(Z_ARRVAL_P(pg_rows), &pos);
				}
				if (PQputCopyEnd(pgsql, NULL) != 1) {
					PHP_PQ_ERROR(""putcopyend failed: %s"", pgsql);
					RETURN_FALSE;
				}
#else
				while (zend_hash_get_current_data_ex(Z_ARRVAL_P(pg_rows), (void **) &tmp, &pos) == SUCCESS) {
					convert_to_string_ex(tmp);
					query = (char *)emalloc(Z_STRLEN_PP(tmp) + 2);
					strlcpy(query, Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp) + 2);
					if(Z_STRLEN_PP(tmp) > 0 && *(query + Z_STRLEN_PP(tmp) - 1) != '\n') {
						strlcat(query, ""\n"", Z_STRLEN_PP(tmp) + 2);
					}
					if (PQputline(pgsql, query)==EOF) {
						efree(query);
						PHP_PQ_ERROR(""copy failed: %s"", pgsql);
						RETURN_FALSE;
					}
					efree(query);
					zend_hash_move_forward_ex(Z_ARRVAL_P(pg_rows), &pos);
				}
				if (PQputline(pgsql, ""\\.\n"") == EOF) {
					PHP_PQ_ERROR(""putline failed: %s"", pgsql);
					RETURN_FALSE;
				}
				if (PQendcopy(pgsql)) {
					PHP_PQ_ERROR(""endcopy failed: %s"", pgsql);
					RETURN_FALSE;
				}
#endif
				while ((pgsql_result = PQgetResult(pgsql))) {
					if (PGRES_COMMAND_OK != PQresultStatus(pgsql_result)) {
						PHP_PQ_ERROR(""Copy command failed: %s"", pgsql);
						command_failed = 1;
					}
					PQclear(pgsql_result);
				}
				if (command_failed) {
					RETURN_FALSE;
				}
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			RETURN_TRUE;
			break;
		default:
			PQclear(pgsql_result);
			PHP_PQ_ERROR(""Copy command failed: %s"", pgsql);
			RETURN_FALSE;
			break;
	}
}
/* }}} */

#ifdef HAVE_PQESCAPE
/* {{{ proto string pg_escape_string([resource connection,] string data)
   Escape string for text/char type */
PHP_FUNCTION(pg_escape_string)
{
	char *from = NULL, *to = NULL;
	zval *pgsql_link;
#ifdef HAVE_PQESCAPE_CONN
	PGconn *pgsql;
#endif
	int to_len;
	int from_len;
	int id = -1;

	switch (ZEND_NUM_ARGS()) {
		case 1:
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &from, &from_len) == FAILURE) {
				return;
			}
			pgsql_link = NULL;
			id = PGG(default_link);
			break;

		default:
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &pgsql_link, &from, &from_len) == FAILURE) {
				return;
			}
			break;
	}

	to = (char *) safe_emalloc(from_len, 2, 1);
#ifdef HAVE_PQESCAPE_CONN
	if (pgsql_link != NULL || id != -1) {
		ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);
		to_len = (int) PQescapeStringConn(pgsql, to, from, (size_t)from_len, NULL);
	} else
#endif
		to_len = (int) PQescapeString(to, from, (size_t)from_len);

	RETURN_STRINGL(to, to_len, 0);
}
/* }}} */

/* {{{ proto string pg_escape_bytea([resource connection,] string data)
   Escape binary for bytea type  */
PHP_FUNCTION(pg_escape_bytea)
{
	char *from = NULL, *to = NULL;
	size_t to_len;
	int from_len, id = -1;
#ifdef HAVE_PQESCAPE_BYTEA_CONN
	PGconn *pgsql;
#endif
	zval *pgsql_link;

	switch (ZEND_NUM_ARGS()) {
		case 1:
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &from, &from_len) == FAILURE) {
				return;
			}
			pgsql_link = NULL;
			id = PGG(default_link);
			break;

		default:
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &pgsql_link, &from, &from_len) == FAILURE) {
				return;
			}
			break;
	}

#ifdef HAVE_PQESCAPE_BYTEA_CONN
	if (pgsql_link != NULL || id != -1) {
		ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);
		to = (char *)PQescapeByteaConn(pgsql, (unsigned char *)from, (size_t)from_len, &to_len);
	} else
#endif
		to = (char *)PQescapeBytea((unsigned char*)from, from_len, &to_len);

	RETVAL_STRINGL(to, to_len-1, 1); /* to_len includes addtional '\0' */
	PQfreemem(to);
}
/* }}} */

#if !HAVE_PQUNESCAPEBYTEA
/* PQunescapeBytea() from PostgreSQL 7.3 to provide bytea unescape feature to 7.2 users.
   Renamed to php_pgsql_unescape_bytea() */
/*
 *		PQunescapeBytea - converts the null terminated string representation
 *		of a bytea, strtext, into binary, filling a buffer. It returns a
 *		pointer to the buffer which is NULL on error, and the size of the
 *		buffer in retbuflen. The pointer may subsequently be used as an
 *		argument to the function free(3). It is the reverse of PQescapeBytea.
 *
 *		The following transformations are reversed:
 *		'\0' == ASCII  0 == \000
 *		'\'' == ASCII 39 == \'
 *		'\\' == ASCII 92 == \\
 *
 *		States:
 *		0	normal		0->1->2->3->4
 *		1	\			   1->5
 *		2	\0			   1->6
 *		3	\00
 *		4	\000
 *		5	\'
 *		6	\\
 */
static unsigned char * php_pgsql_unescape_bytea(unsigned char *strtext, size_t *retbuflen)
{
	size_t     buflen;
	unsigned char *buffer,
			   *sp,
			   *bp;
	unsigned int state = 0;

	if (strtext == NULL)
		return NULL;
	buflen = strlen(strtext);	/* will shrink, also we discover if
								 * strtext */
	buffer = (unsigned char *) emalloc(buflen);	/* isn't NULL terminated */
	for (bp = buffer, sp = strtext; *sp != '\0'; bp++, sp++)
	{
",C,"       if (zend_parse_parameters(argc TSRMLS_CC, ""p|sr"", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {
","       if (zend_parse_parameters(argc TSRMLS_CC, ""s|sr"", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {
",9faaee66fa493372c7340b1ab05f8fd115131a42,"@@ -3014,7 +3014,7 @@ PHP_FUNCTION(pg_trace)
        php_stream *stream;
        id = PGG(default_link);
 
-       if (zend_parse_parameters(argc TSRMLS_CC, ""s|sr"", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {
+       if (zend_parse_parameters(argc TSRMLS_CC, ""p|sr"", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {
                return;
        }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/pgsql/pgsql.c;h=cd51143c903be8f8cb5552a77a2845a31c49d927;hb=4435b9142ff9813845d5c97ab29a5d637bedb257,https://git.php.net/?p=php-src.git;a=blob;f=ext/pgsql/pgsql.c;h=eb557777583f15e591c45ae9f43578ee6be85db4,1,"static void php_pgsql_do_connect(INTERNAL_FUNCTION_PARAMETERS, int persistent)
{
	char *host=NULL,*port=NULL,*options=NULL,*tty=NULL,*dbname=NULL,*connstring=NULL;
	PGconn *pgsql;
	smart_str str = {0};
	zval **args[5];
	int i, connect_type = 0;
	PGresult *pg_result;

	if (ZEND_NUM_ARGS() < 1 || ZEND_NUM_ARGS() > 5
			|| zend_get_parameters_array_ex(ZEND_NUM_ARGS(), args) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	smart_str_appends(&str, ""pgsql"");
	
	for (i = 0; i < ZEND_NUM_ARGS(); i++) {
		/* make sure that the PGSQL_CONNECT_FORCE_NEW bit is not part of the hash so that subsequent connections
		 * can re-use this connection. Bug #39979
		 */ 
		if (i == 1 && ZEND_NUM_ARGS() == 2 && Z_TYPE_PP(args[i]) == IS_LONG) {
			if (Z_LVAL_PP(args[1]) == PGSQL_CONNECT_FORCE_NEW) {
				continue;
			} else if (Z_LVAL_PP(args[1]) & PGSQL_CONNECT_FORCE_NEW) {
				smart_str_append_long(&str, Z_LVAL_PP(args[1]) ^ PGSQL_CONNECT_FORCE_NEW);
			}
		}
		convert_to_string_ex(args[i]);
		smart_str_appendc(&str, '_');
		smart_str_appendl(&str, Z_STRVAL_PP(args[i]), Z_STRLEN_PP(args[i]));
	}

	smart_str_0(&str);

	if (ZEND_NUM_ARGS() == 1) { /* new style, using connection string */
		connstring = Z_STRVAL_PP(args[0]);
	} else if (ZEND_NUM_ARGS() == 2 ) { /* Safe to add conntype_option, since 2 args was illegal */
		connstring = Z_STRVAL_PP(args[0]);
		convert_to_long_ex(args[1]);
		connect_type = Z_LVAL_PP(args[1]);
	} else {
		host = Z_STRVAL_PP(args[0]);
		port = Z_STRVAL_PP(args[1]);
		dbname = Z_STRVAL_PP(args[ZEND_NUM_ARGS()-1]);

		switch (ZEND_NUM_ARGS()) {
		case 5:
			tty = Z_STRVAL_PP(args[3]);
			/* fall through */
		case 4:
			options = Z_STRVAL_PP(args[2]);
			break;
		}
	}

	if (persistent && PGG(allow_persistent)) {
		zend_rsrc_list_entry *le;
		
		/* try to find if we already have this link in our persistent list */
		if (zend_hash_find(&EG(persistent_list), str.c, str.len+1, (void **) &le)==FAILURE) {  /* we don't */
			zend_rsrc_list_entry new_le;
			
			if (PGG(max_links)!=-1 && PGG(num_links)>=PGG(max_links)) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,
								 ""Cannot create new link. Too many open links (%ld)"", PGG(num_links));
				goto err;
			}
			if (PGG(max_persistent)!=-1 && PGG(num_persistent)>=PGG(max_persistent)) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,
								 ""Cannot create new link. Too many open persistent links (%ld)"", PGG(num_persistent));
				goto err;
			}

			/* create the link */
			if (connstring) {
				pgsql=PQconnectdb(connstring);
			} else {
				pgsql=PQsetdb(host,port,options,tty,dbname);
			}
			if (pgsql==NULL || PQstatus(pgsql)==CONNECTION_BAD) {
				PHP_PQ_ERROR(""Unable to connect to PostgreSQL server: %s"", pgsql)
				if (pgsql) {
					PQfinish(pgsql);
				}
				goto err;
			}

			/* hash it up */
			Z_TYPE(new_le) = le_plink;
			new_le.ptr = pgsql;
			if (zend_hash_update(&EG(persistent_list), str.c, str.len+1, (void *) &new_le, sizeof(zend_rsrc_list_entry), NULL)==FAILURE) {
				goto err;
			}
			PGG(num_links)++;
			PGG(num_persistent)++;
		} else {  /* we do */
			if (Z_TYPE_P(le) != le_plink) {
				RETURN_FALSE;
			}
			/* ensure that the link did not die */
			if (PGG(auto_reset_persistent) & 1) {
				/* need to send & get something from backend to
				   make sure we catch CONNECTION_BAD everytime */
				PGresult *pg_result;
				pg_result = PQexec(le->ptr, ""select 1"");
				PQclear(pg_result);
			}
			if (PQstatus(le->ptr)==CONNECTION_BAD) { /* the link died */
				if (le->ptr == NULL) {
					if (connstring) {
						le->ptr=PQconnectdb(connstring);
					} else {
						le->ptr=PQsetdb(host,port,options,tty,dbname);
					}
				}
				else {
					PQreset(le->ptr);
				}
				if (le->ptr==NULL || PQstatus(le->ptr)==CONNECTION_BAD) {
					php_error_docref(NULL TSRMLS_CC, E_WARNING,""PostgreSQL link lost, unable to reconnect"");
					zend_hash_del(&EG(persistent_list),str.c,str.len+1);
					goto err;
				}
			}
			pgsql = (PGconn *) le->ptr;
#if HAVE_PQPROTOCOLVERSION && HAVE_PQPARAMETERSTATUS
			if (PQprotocolVersion(pgsql) >= 3 && atof(PQparameterStatus(pgsql, ""server_version"")) >= 7.2) {
#else
			if (atof(PG_VERSION) >= 7.2) {
#endif
				pg_result = PQexec(pgsql, ""RESET ALL;"");
				PQclear(pg_result);
			}
		}
		ZEND_REGISTER_RESOURCE(return_value, pgsql, le_plink);
	} else { /* Non persistent connection */
		zend_rsrc_list_entry *index_ptr,new_index_ptr;

		/* first we check the hash for the hashed_details key.  if it exists,
		 * it should point us to the right offset where the actual pgsql link sits.
		 * if it doesn't, open a new pgsql link, add it to the resource list,
		 * and add a pointer to it with hashed_details as the key.
		 */
		if (!(connect_type & PGSQL_CONNECT_FORCE_NEW)
			&& zend_hash_find(&EG(regular_list),str.c,str.len+1,(void **) &index_ptr)==SUCCESS) {
			int type;
			ulong link;
			void *ptr;

			if (Z_TYPE_P(index_ptr) != le_index_ptr) {
				RETURN_FALSE;
			}
			link = (ulong) index_ptr->ptr;
			ptr = zend_list_find(link,&type);   /* check if the link is still there */
			if (ptr && (type==le_link || type==le_plink)) {
				Z_LVAL_P(return_value) = link;
				zend_list_addref(link);
				php_pgsql_set_default_link(link TSRMLS_CC);
				Z_TYPE_P(return_value) = IS_RESOURCE;
				goto cleanup;
			} else {
				zend_hash_del(&EG(regular_list),str.c,str.len+1);
			}
		}
		if (PGG(max_links)!=-1 && PGG(num_links)>=PGG(max_links)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Cannot create new link. Too many open links (%ld)"", PGG(num_links));
			goto err;
		}
		if (connstring) {
			pgsql = PQconnectdb(connstring);
		} else {
			pgsql = PQsetdb(host,port,options,tty,dbname);
		}
		if (pgsql==NULL || PQstatus(pgsql)==CONNECTION_BAD) {
			PHP_PQ_ERROR(""Unable to connect to PostgreSQL server: %s"", pgsql);
			if (pgsql) {
				PQfinish(pgsql);
			}
			goto err;
		}

		/* add it to the list */
		ZEND_REGISTER_RESOURCE(return_value, pgsql, le_link);

		/* add it to the hash */
		new_index_ptr.ptr = (void *) Z_LVAL_P(return_value);
		Z_TYPE(new_index_ptr) = le_index_ptr;
		if (zend_hash_update(&EG(regular_list),str.c,str.len+1,(void *) &new_index_ptr, sizeof(zend_rsrc_list_entry), NULL)==FAILURE) {
			goto err;
		}
		PGG(num_links)++;
	}
	/* set notice processer */
	if (! PGG(ignore_notices) && Z_TYPE_P(return_value) == IS_RESOURCE) {
		PQsetNoticeProcessor(pgsql, _php_pgsql_notice_handler, (void*)Z_RESVAL_P(return_value));
	}
	php_pgsql_set_default_link(Z_LVAL_P(return_value) TSRMLS_CC);
	
cleanup:
	smart_str_free(&str);
	return;

err:
	smart_str_free(&str);
	RETURN_FALSE;
}
/* }}} */

#if 0
/* {{{ php_pgsql_get_default_link
 */
static int php_pgsql_get_default_link(INTERNAL_FUNCTION_PARAMETERS)
{
	if (PGG(default_link)==-1) { /* no link opened yet, implicitly open one */
		ht = 0;
		php_pgsql_do_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU,0);
	}
	return PGG(default_link);
}
/* }}} */
#endif

/* {{{ proto resource pg_connect(string connection_string[, int connect_type] | [string host, string port [, string options [, string tty,]]] string database)
   Open a PostgreSQL connection */
PHP_FUNCTION(pg_connect)
{
	php_pgsql_do_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU,0);
}
/* }}} */

/* {{{ proto resource pg_pconnect(string connection_string | [string host, string port [, string options [, string tty,]]] string database)
   Open a persistent PostgreSQL connection */
PHP_FUNCTION(pg_pconnect)
{
	php_pgsql_do_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU,1);
}
/* }}} */

/* {{{ proto bool pg_close([resource connection])
   Close a PostgreSQL connection */ 
PHP_FUNCTION(pg_close)
{
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;

	if (zend_parse_parameters(argc TSRMLS_CC, ""|r"", &pgsql_link) == FAILURE) {
		return;
	}

	if (argc == 0) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (id==-1) { /* explicit resource number */
		zend_list_delete(Z_RESVAL_P(pgsql_link));
	}

	if (id!=-1
		|| (pgsql_link && Z_RESVAL_P(pgsql_link)==PGG(default_link))) {
		zend_list_delete(PGG(default_link));
		PGG(default_link) = -1;
	}

	RETURN_TRUE;
}
/* }}} */


#define PHP_PG_DBNAME 1
#define PHP_PG_ERROR_MESSAGE 2
#define PHP_PG_OPTIONS 3
#define PHP_PG_PORT 4
#define PHP_PG_TTY 5
#define PHP_PG_HOST 6
#define PHP_PG_VERSION 7


/* {{{ php_pgsql_get_link_info
 */
static void php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAMETERS, int entry_type)
{
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	char *msgbuf;

	if (zend_parse_parameters(argc TSRMLS_CC, ""|r"", &pgsql_link) == FAILURE) {
		return;
	}
	
	if (argc == 0) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	
	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	switch(entry_type) {
		case PHP_PG_DBNAME:
			Z_STRVAL_P(return_value) = PQdb(pgsql);
			break;
		case PHP_PG_ERROR_MESSAGE:
			RETURN_STRING(PQErrorMessageTrim(pgsql, &msgbuf), 0);
			return;
		case PHP_PG_OPTIONS:
			Z_STRVAL_P(return_value) = PQoptions(pgsql);
			break;
		case PHP_PG_PORT:
			Z_STRVAL_P(return_value) = PQport(pgsql);
			break;
		case PHP_PG_TTY:
			Z_STRVAL_P(return_value) = PQtty(pgsql);
			break;
		case PHP_PG_HOST:
			Z_STRVAL_P(return_value) = PQhost(pgsql);
			break;
		case PHP_PG_VERSION:
			array_init(return_value);
			add_assoc_string(return_value, ""client"", PG_VERSION, 1);
#if HAVE_PQPROTOCOLVERSION
			add_assoc_long(return_value, ""protocol"", PQprotocolVersion(pgsql));
#if HAVE_PQPARAMETERSTATUS
			if (PQprotocolVersion(pgsql) >= 3) {
				add_assoc_string(return_value, ""server"", (char*)PQparameterStatus(pgsql, ""server_version""), 1);
			}
#endif
#endif
			return;
		default:
			RETURN_FALSE;
	}
	if (Z_STRVAL_P(return_value)) {
		Z_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));
		Z_STRVAL_P(return_value) = (char *) estrdup(Z_STRVAL_P(return_value));
	} else {
		Z_STRLEN_P(return_value) = 0;
		Z_STRVAL_P(return_value) = (char *) estrdup("""");
	}
	Z_TYPE_P(return_value) = IS_STRING;
}
/* }}} */

/* {{{ proto string pg_dbname([resource connection])
   Get the database name */ 
PHP_FUNCTION(pg_dbname)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_DBNAME);
}
/* }}} */

/* {{{ proto string pg_last_error([resource connection])
   Get the error message string */
PHP_FUNCTION(pg_last_error)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_ERROR_MESSAGE);
}
/* }}} */

/* {{{ proto string pg_options([resource connection])
   Get the options associated with the connection */
PHP_FUNCTION(pg_options)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_OPTIONS);
}
/* }}} */

/* {{{ proto int pg_port([resource connection])
   Return the port number associated with the connection */
PHP_FUNCTION(pg_port)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_PORT);
}
/* }}} */

/* {{{ proto string pg_tty([resource connection])
   Return the tty name associated with the connection */
PHP_FUNCTION(pg_tty)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_TTY);
}
/* }}} */

/* {{{ proto string pg_host([resource connection])
   Returns the host name associated with the connection */
PHP_FUNCTION(pg_host)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_HOST);
}
/* }}} */

/* {{{ proto array pg_version([resource connection])
   Returns an array with client, protocol and server version (when available) */
PHP_FUNCTION(pg_version)
{
	php_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_VERSION);
}
/* }}} */

#if HAVE_PQPARAMETERSTATUS
/* {{{ proto string|false pg_parameter_status([resource connection,] string param_name)
   Returns the value of a server parameter */
PHP_FUNCTION(pg_parameter_status)
{
	zval *pgsql_link;
	int id;
	PGconn *pgsql;
	char *param;
	int len;

	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &pgsql_link, &param, &len) == SUCCESS) {
		id = -1;
	} else if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &param, &len) == SUCCESS) {
		pgsql_link = NULL;
		id = PGG(default_link);
	} else {
		RETURN_FALSE;
	}
	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	param = (char*)PQparameterStatus(pgsql, param);
	if (param) {
		RETURN_STRING(param, 1);
	} else {
		RETURN_FALSE;
	}
}
/* }}} */
#endif

/* {{{ proto bool pg_ping([resource connection])
   Ping database. If connection is bad, try to reconnect. */
PHP_FUNCTION(pg_ping)
{
	zval *pgsql_link;
	int id;
	PGconn *pgsql;
	PGresult *res;

	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &pgsql_link) == SUCCESS) {
		id = -1;
	} else {
		pgsql_link = NULL;
		id = PGG(default_link);
	}
	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	/* ping connection */
	res = PQexec(pgsql, ""SELECT 1;"");
	PQclear(res);

	/* check status. */
	if (PQstatus(pgsql) == CONNECTION_OK)
		RETURN_TRUE;

	/* reset connection if it's broken */
	PQreset(pgsql);
	if (PQstatus(pgsql) == CONNECTION_OK) {
		RETURN_TRUE;
	}
	RETURN_FALSE;
}
/* }}} */

/* {{{ proto resource pg_query([resource connection,] string query)
   Execute a query */
PHP_FUNCTION(pg_query)
{
	zval *pgsql_link = NULL;
	char *query;
	int id = -1, query_len, argc = ZEND_NUM_ARGS();
	int leftover = 0;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	pgsql_result_handle *pg_result;

	if (argc == 1) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &query, &query_len) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &pgsql_link, &query, &query_len) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (PQ_SETNONBLOCKING(pgsql, 0)) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE,""Cannot set connection to blocking mode"");
		RETURN_FALSE;
	}
	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
		leftover = 1;
	}
	if (leftover) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found results on this connection. Use pg_get_result() to get these results first"");
	}
	pgsql_result = PQexec(pgsql, query);
	if ((PGG(auto_reset_persistent) & 2) && PQstatus(pgsql) != CONNECTION_OK) {
		PQclear(pgsql_result);
		PQreset(pgsql);
		pgsql_result = PQexec(pgsql, query);
	}

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}

	switch (status) {
		case PGRES_EMPTY_QUERY:
		case PGRES_BAD_RESPONSE:
		case PGRES_NONFATAL_ERROR:
		case PGRES_FATAL_ERROR:
			PHP_PQ_ERROR(""Query failed: %s"", pgsql);
			PQclear(pgsql_result);
			RETURN_FALSE;
			break;
		case PGRES_COMMAND_OK: /* successful command that did not return rows */
		default:
			if (pgsql_result) {
				pg_result = (pgsql_result_handle *) emalloc(sizeof(pgsql_result_handle));
				pg_result->conn = pgsql;
				pg_result->result = pgsql_result;
				pg_result->row = 0;
				ZEND_REGISTER_RESOURCE(return_value, pg_result, le_result);
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			break;
	}
}
/* }}} */

#if HAVE_PQEXECPARAMS || HAVE_PQEXECPREPARED || HAVE_PQSENDQUERYPARAMS || HAVE_PQSENDQUERYPREPARED
/* {{{ _php_pgsql_free_params */
static void _php_pgsql_free_params(char **params, int num_params)
{
	if (num_params > 0) {
		int i;
		for (i = 0; i < num_params; i++) {
			if (params[i]) {
				efree(params[i]);
			}
		}
		efree(params);
	}
}
/* }}} */
#endif

#if HAVE_PQEXECPARAMS
/* {{{ proto resource pg_query_params([resource connection,] string query, array params)
   Execute a query */
PHP_FUNCTION(pg_query_params)
{
	zval *pgsql_link = NULL;
	zval *pv_param_arr, **tmp;
	char *query;
	int query_len, id = -1, argc = ZEND_NUM_ARGS();
	int leftover = 0;
	int num_params = 0;
	char **params = NULL;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	pgsql_result_handle *pg_result;
	
	if (argc == 2) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""sa"", &query, &query_len, &pv_param_arr) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rsa"", &pgsql_link, &query, &query_len, &pv_param_arr) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (PQ_SETNONBLOCKING(pgsql, 0)) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE,""Cannot set connection to blocking mode"");
		RETURN_FALSE;
	}
	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
		leftover = 1;
	}
	if (leftover) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found results on this connection. Use pg_get_result() to get these results first"");
	}

	zend_hash_internal_pointer_reset(Z_ARRVAL_P(pv_param_arr));
	num_params = zend_hash_num_elements(Z_ARRVAL_P(pv_param_arr));
	if (num_params > 0) {
		int i = 0;
		params = (char **)safe_emalloc(sizeof(char *), num_params, 0);

		for(i = 0; i < num_params; i++) {
			if (zend_hash_get_current_data(Z_ARRVAL_P(pv_param_arr), (void **) &tmp) == FAILURE) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,""Error getting parameter"");
				_php_pgsql_free_params(params, num_params);
				RETURN_FALSE;
			}

			if (Z_TYPE_PP(tmp) == IS_NULL) {
				params[i] = NULL;
			} else {
				zval tmp_val = **tmp;
				zval_copy_ctor(&tmp_val);
				convert_to_string(&tmp_val);
				if (Z_TYPE(tmp_val) != IS_STRING) {
					php_error_docref(NULL TSRMLS_CC, E_WARNING,""Error converting parameter"");
					zval_dtor(&tmp_val);
					_php_pgsql_free_params(params, num_params);
					RETURN_FALSE;
				}
				params[i] = estrndup(Z_STRVAL(tmp_val), Z_STRLEN(tmp_val));
				zval_dtor(&tmp_val);
			}

			zend_hash_move_forward(Z_ARRVAL_P(pv_param_arr));
		}
	}

	pgsql_result = PQexecParams(pgsql, query, num_params, 
					NULL, (const char * const *)params, NULL, NULL, 0);
	if ((PGG(auto_reset_persistent) & 2) && PQstatus(pgsql) != CONNECTION_OK) {
		PQclear(pgsql_result);
		PQreset(pgsql);
		pgsql_result = PQexecParams(pgsql, query, num_params, 
						NULL, (const char * const *)params, NULL, NULL, 0);
	}

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}
	
	_php_pgsql_free_params(params, num_params);

	switch (status) {
		case PGRES_EMPTY_QUERY:
		case PGRES_BAD_RESPONSE:
		case PGRES_NONFATAL_ERROR:
		case PGRES_FATAL_ERROR:
			PHP_PQ_ERROR(""Query failed: %s"", pgsql);
			PQclear(pgsql_result);
			RETURN_FALSE;
			break;
		case PGRES_COMMAND_OK: /* successful command that did not return rows */
		default:
			if (pgsql_result) {
				pg_result = (pgsql_result_handle *) emalloc(sizeof(pgsql_result_handle));
				pg_result->conn = pgsql;
				pg_result->result = pgsql_result;
				pg_result->row = 0;
				ZEND_REGISTER_RESOURCE(return_value, pg_result, le_result);
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			break;
	}
}
/* }}} */
#endif

#if HAVE_PQPREPARE
/* {{{ proto resource pg_prepare([resource connection,] string stmtname, string query)
   Prepare a query for future execution */
PHP_FUNCTION(pg_prepare)
{
	zval *pgsql_link = NULL;
	char *query, *stmtname;
	int query_len, stmtname_len, id = -1, argc = ZEND_NUM_ARGS();
	int leftover = 0;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	pgsql_result_handle *pg_result;

	if (argc == 2) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""ss"", &stmtname, &stmtname_len, &query, &query_len) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rss"", &pgsql_link, &stmtname, &stmtname_len, &query, &query_len) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (PQ_SETNONBLOCKING(pgsql, 0)) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE,""Cannot set connection to blocking mode"");
		RETURN_FALSE;
	}
	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
		leftover = 1;
	}
	if (leftover) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found results on this connection. Use pg_get_result() to get these results first"");
	}
	pgsql_result = PQprepare(pgsql, stmtname, query, 0, NULL);
	if ((PGG(auto_reset_persistent) & 2) && PQstatus(pgsql) != CONNECTION_OK) {
		PQclear(pgsql_result);
		PQreset(pgsql);
		pgsql_result = PQprepare(pgsql, stmtname, query, 0, NULL);
	}

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}

	switch (status) {
		case PGRES_EMPTY_QUERY:
		case PGRES_BAD_RESPONSE:
		case PGRES_NONFATAL_ERROR:
		case PGRES_FATAL_ERROR:
			PHP_PQ_ERROR(""Query failed: %s"", pgsql);
			PQclear(pgsql_result);
			RETURN_FALSE;
			break;
		case PGRES_COMMAND_OK: /* successful command that did not return rows */
		default:
			if (pgsql_result) {
				pg_result = (pgsql_result_handle *) emalloc(sizeof(pgsql_result_handle));
				pg_result->conn = pgsql;
				pg_result->result = pgsql_result;
				pg_result->row = 0;
				ZEND_REGISTER_RESOURCE(return_value, pg_result, le_result);
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			break;
	}
}
/* }}} */
#endif

#if HAVE_PQEXECPREPARED
/* {{{ proto resource pg_execute([resource connection,] string stmtname, array params)
   Execute a prepared query  */
PHP_FUNCTION(pg_execute)
{
	zval *pgsql_link = NULL;
	zval *pv_param_arr, **tmp;
	char *stmtname;
	int stmtname_len, id = -1, argc = ZEND_NUM_ARGS();
	int leftover = 0;
	int num_params = 0;
	char **params = NULL;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	pgsql_result_handle *pg_result;

	if (argc == 2) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""sa/"", &stmtname, &stmtname_len, &pv_param_arr)==FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rsa/"", &pgsql_link, &stmtname, &stmtname_len, &pv_param_arr) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (PQ_SETNONBLOCKING(pgsql, 0)) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE,""Cannot set connection to blocking mode"");
		RETURN_FALSE;
	}
	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
		leftover = 1;
	}
	if (leftover) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found results on this connection. Use pg_get_result() to get these results first"");
	}

	zend_hash_internal_pointer_reset(Z_ARRVAL_P(pv_param_arr));
	num_params = zend_hash_num_elements(Z_ARRVAL_P(pv_param_arr));
	if (num_params > 0) {
		int i = 0;
		params = (char **)safe_emalloc(sizeof(char *), num_params, 0);

		for(i = 0; i < num_params; i++) {
			if (zend_hash_get_current_data(Z_ARRVAL_P(pv_param_arr), (void **) &tmp) == FAILURE) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,""Error getting parameter"");
				_php_pgsql_free_params(params, num_params);
				RETURN_FALSE;
			}

			if (Z_TYPE_PP(tmp) == IS_NULL) {
				params[i] = NULL;
			} else {
				zval tmp_val = **tmp;
				zval_copy_ctor(&tmp_val);
				convert_to_string(&tmp_val);
				if (Z_TYPE(tmp_val) != IS_STRING) {
					php_error_docref(NULL TSRMLS_CC, E_WARNING,""Error converting parameter"");
					zval_dtor(&tmp_val);
					_php_pgsql_free_params(params, num_params);
					RETURN_FALSE;
				}
				params[i] = estrndup(Z_STRVAL(tmp_val), Z_STRLEN(tmp_val));
				zval_dtor(&tmp_val);
			}

			zend_hash_move_forward(Z_ARRVAL_P(pv_param_arr));
		}
	}

	pgsql_result = PQexecPrepared(pgsql, stmtname, num_params, 
					(const char * const *)params, NULL, NULL, 0);
	if ((PGG(auto_reset_persistent) & 2) && PQstatus(pgsql) != CONNECTION_OK) {
		PQclear(pgsql_result);
		PQreset(pgsql);
		pgsql_result = PQexecPrepared(pgsql, stmtname, num_params, 
						(const char * const *)params, NULL, NULL, 0);
	}

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}

	_php_pgsql_free_params(params, num_params);

	switch (status) {
		case PGRES_EMPTY_QUERY:
		case PGRES_BAD_RESPONSE:
		case PGRES_NONFATAL_ERROR:
		case PGRES_FATAL_ERROR:
			PHP_PQ_ERROR(""Query failed: %s"", pgsql);
			PQclear(pgsql_result);
			RETURN_FALSE;
			break;
		case PGRES_COMMAND_OK: /* successful command that did not return rows */
		default:
			if (pgsql_result) {
				pg_result = (pgsql_result_handle *) emalloc(sizeof(pgsql_result_handle));
				pg_result->conn = pgsql;
				pg_result->result = pgsql_result;
				pg_result->row = 0;
				ZEND_REGISTER_RESOURCE(return_value, pg_result, le_result);
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			break;
	}
}
/* }}} */
#endif

#define PHP_PG_NUM_ROWS 1
#define PHP_PG_NUM_FIELDS 2
#define PHP_PG_CMD_TUPLES 3

/* {{{ php_pgsql_get_result_info
 */
static void php_pgsql_get_result_info(INTERNAL_FUNCTION_PARAMETERS, int entry_type)
{
	zval *result;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &result) == FAILURE) {
		return;
	}
	
	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;

	switch (entry_type) {
		case PHP_PG_NUM_ROWS:
			Z_LVAL_P(return_value) = PQntuples(pgsql_result);
			break;
		case PHP_PG_NUM_FIELDS:
			Z_LVAL_P(return_value) = PQnfields(pgsql_result);
			break;
		case PHP_PG_CMD_TUPLES:
#if HAVE_PQCMDTUPLES
			Z_LVAL_P(return_value) = atoi(PQcmdTuples(pgsql_result));
#else
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Not supported under this build"");
			Z_LVAL_P(return_value) = 0;
#endif
			break;
		default:
			RETURN_FALSE;
	}
	Z_TYPE_P(return_value) = IS_LONG;
}
/* }}} */

/* {{{ proto int pg_num_rows(resource result)
   Return the number of rows in the result */
PHP_FUNCTION(pg_num_rows)
{
	php_pgsql_get_result_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_NUM_ROWS);
}
/* }}} */

/* {{{ proto int pg_num_fields(resource result)
   Return the number of fields in the result */
PHP_FUNCTION(pg_num_fields)
{
	php_pgsql_get_result_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_NUM_FIELDS);
}
/* }}} */

#if HAVE_PQCMDTUPLES
/* {{{ proto int pg_affected_rows(resource result)
   Returns the number of affected tuples */
PHP_FUNCTION(pg_affected_rows)
{
	php_pgsql_get_result_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_CMD_TUPLES);
}
/* }}} */
#endif

/* {{{ proto string pg_last_notice(resource connection)
   Returns the last notice set by the backend */
PHP_FUNCTION(pg_last_notice) 
{
	zval *pgsql_link;
	PGconn *pg_link;
	int id = -1;
	php_pgsql_notice **notice;
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &pgsql_link) == FAILURE) {
		return;
	}
	/* Just to check if user passed valid resoruce */
	ZEND_FETCH_RESOURCE2(pg_link, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (zend_hash_index_find(&PGG(notices), Z_RESVAL_P(pgsql_link), (void **)&notice) == FAILURE) {
		RETURN_FALSE;
	}
	RETURN_STRINGL((*notice)->message, (*notice)->len, 1);
}
/* }}} */

/* {{{ get_field_name
 */
static char *get_field_name(PGconn *pgsql, Oid oid, HashTable *list TSRMLS_DC)
{
	PGresult *result;
	smart_str str = {0};
	zend_rsrc_list_entry *field_type;
	char *ret=NULL;

	/* try to lookup the type in the resource list */
	smart_str_appends(&str, ""pgsql_oid_"");
	smart_str_append_unsigned(&str, oid);
	smart_str_0(&str);

	if (zend_hash_find(list,str.c,str.len+1,(void **) &field_type)==SUCCESS) {
		ret = estrdup((char *)field_type->ptr);
	} else { /* hash all oid's */
		int i,num_rows;
		int oid_offset,name_offset;
		char *tmp_oid, *end_ptr, *tmp_name;
		zend_rsrc_list_entry new_oid_entry;

		if ((result = PQexec(pgsql,""select oid,typname from pg_type"")) == NULL || PQresultStatus(result) != PGRES_TUPLES_OK) {
			if (result) {
				PQclear(result);
			}
			smart_str_free(&str);
			return STR_EMPTY_ALLOC();
		}
		num_rows = PQntuples(result);
		oid_offset = PQfnumber(result,""oid"");
		name_offset = PQfnumber(result,""typname"");

		for (i=0; i<num_rows; i++) {
			if ((tmp_oid = PQgetvalue(result,i,oid_offset))==NULL) {
				continue;
			}
			
			str.len = 0;
			smart_str_appends(&str, ""pgsql_oid_"");
			smart_str_appends(&str, tmp_oid);
			smart_str_0(&str);

			if ((tmp_name = PQgetvalue(result,i,name_offset))==NULL) {
				continue;
			}
			Z_TYPE(new_oid_entry) = le_string;
			new_oid_entry.ptr = estrdup(tmp_name);
			zend_hash_update(list,str.c,str.len+1,(void *) &new_oid_entry, sizeof(zend_rsrc_list_entry), NULL);
			if (!ret && strtoul(tmp_oid, &end_ptr, 10)==oid) {
				ret = estrdup(tmp_name);
			}
		}
		PQclear(result);
	}

	smart_str_free(&str);
	return ret;
}
/* }}} */

#ifdef HAVE_PQFTABLE
/* {{{ proto mixed pg_field_table(resource result, int field_number[, bool oid_only])
   Returns the name of the table field belongs to, or table's oid if oid_only is true */
PHP_FUNCTION(pg_field_table)
{
	zval *result;
	pgsql_result_handle *pg_result;
	long fnum = -1;
	zend_bool return_oid = 0;
	Oid oid;
	smart_str hash_key = {0};
	char *table_name;
	zend_rsrc_list_entry *field_table;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl|b"", &result, &fnum, &return_oid) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	if (fnum < 0 || fnum >= PQnfields(pg_result->result)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Bad field offset specified"");
		RETURN_FALSE;
	}

	oid = PQftable(pg_result->result, fnum);

	if (InvalidOid == oid) {
		RETURN_FALSE;
	}

	if (return_oid) {
#if UINT_MAX > LONG_MAX /* Oid is unsigned int, we don't need this code, where LONG is wider */
		if (oid > LONG_MAX) {
			smart_str oidstr = {0};
			smart_str_append_unsigned(&oidstr, oid);
			smart_str_0(&oidstr);
			RETURN_STRINGL(oidstr.c, oidstr.len, 0);
		} else
#endif
			RETURN_LONG((long)oid);
	}

	/* try to lookup the table name in the resource list */
	smart_str_appends(&hash_key, ""pgsql_table_oid_"");
	smart_str_append_unsigned(&hash_key, oid);
	smart_str_0(&hash_key);

	if (zend_hash_find(&EG(regular_list), hash_key.c, hash_key.len+1, (void **) &field_table) == SUCCESS) {
		smart_str_free(&hash_key);
		RETURN_STRING((char *)field_table->ptr, 1);
	} else { /* Not found, lookup by querying PostgreSQL system tables */
		PGresult *tmp_res;
		smart_str querystr = {0};
		zend_rsrc_list_entry new_field_table;

		smart_str_appends(&querystr, ""select relname from pg_class where oid="");
		smart_str_append_unsigned(&querystr, oid);
		smart_str_0(&querystr);

		if ((tmp_res = PQexec(pg_result->conn, querystr.c)) == NULL || PQresultStatus(tmp_res) != PGRES_TUPLES_OK) {
			if (tmp_res) {
				PQclear(tmp_res);
			}
			smart_str_free(&querystr);
			smart_str_free(&hash_key);
			RETURN_FALSE;
		}

		smart_str_free(&querystr);

		if ((table_name = PQgetvalue(tmp_res, 0, 0)) == NULL) {
			PQclear(tmp_res);
			smart_str_free(&hash_key);
			RETURN_FALSE;
		}

		Z_TYPE(new_field_table) = le_string;
		new_field_table.ptr = estrdup(table_name);
		zend_hash_update(&EG(regular_list), hash_key.c, hash_key.len+1, (void *) &new_field_table, sizeof(zend_rsrc_list_entry), NULL);

		smart_str_free(&hash_key);
		PQclear(tmp_res);
		RETURN_STRING(table_name, 1);
	}

}
/* }}} */
#endif

#define PHP_PG_FIELD_NAME 1
#define PHP_PG_FIELD_SIZE 2
#define PHP_PG_FIELD_TYPE 3
#define PHP_PG_FIELD_TYPE_OID 4

/* {{{ php_pgsql_get_field_info
 */
static void php_pgsql_get_field_info(INTERNAL_FUNCTION_PARAMETERS, int entry_type)
{
	zval *result;
	long field;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;
	Oid oid;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl"", &result, &field) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;
	
	if (field < 0 || field >= PQnfields(pgsql_result)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Bad field offset specified"");
		RETURN_FALSE;
	}

	switch (entry_type) {
		case PHP_PG_FIELD_NAME:
			Z_STRVAL_P(return_value) = PQfname(pgsql_result, field);
			Z_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));
			Z_STRVAL_P(return_value) = estrndup(Z_STRVAL_P(return_value),Z_STRLEN_P(return_value));
			Z_TYPE_P(return_value) = IS_STRING;
			break;
		case PHP_PG_FIELD_SIZE:
			Z_LVAL_P(return_value) = PQfsize(pgsql_result, field);
			Z_TYPE_P(return_value) = IS_LONG;
			break;
		case PHP_PG_FIELD_TYPE:
			Z_STRVAL_P(return_value) = get_field_name(pg_result->conn, PQftype(pgsql_result, field), &EG(regular_list) TSRMLS_CC);
			Z_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));
			Z_TYPE_P(return_value) = IS_STRING;
			break;
		case PHP_PG_FIELD_TYPE_OID:
			
			oid = PQftype(pgsql_result, field);
#if UINT_MAX > LONG_MAX
			if (oid > LONG_MAX) {
				smart_str s = {0};
				smart_str_append_unsigned(&s, oid);
				smart_str_0(&s);
				Z_STRVAL_P(return_value) = s.c;
				Z_STRLEN_P(return_value) = s.len;
				Z_TYPE_P(return_value) = IS_STRING;
			} else
#endif
			{
				Z_LVAL_P(return_value) = (long)oid;
				Z_TYPE_P(return_value) = IS_LONG;
			}
			break;
		default:
			RETURN_FALSE;
	}
}
/* }}} */

/* {{{ proto string pg_field_name(resource result, int field_number)
   Returns the name of the field */
PHP_FUNCTION(pg_field_name)
{
	php_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_NAME);
}
/* }}} */

/* {{{ proto int pg_field_size(resource result, int field_number)
   Returns the internal size of the field */ 
PHP_FUNCTION(pg_field_size)
{
	php_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_SIZE);
}
/* }}} */

/* {{{ proto string pg_field_type(resource result, int field_number)
   Returns the type name for the given field */
PHP_FUNCTION(pg_field_type)
{
	php_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_TYPE);
}
/* }}} */


/* {{{ proto string pg_field_type_oid(resource result, int field_number)
   Returns the type oid for the given field */
PHP_FUNCTION(pg_field_type_oid)
{
	php_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_TYPE_OID);
}
/* }}} */

/* {{{ proto int pg_field_num(resource result, string field_name)
   Returns the field number of the named field */
PHP_FUNCTION(pg_field_num)
{
	zval *result;
	char *field;
	int field_len;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &result, &field, &field_len) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;

	Z_LVAL_P(return_value) = PQfnumber(pgsql_result, field);
	Z_TYPE_P(return_value) = IS_LONG;
}
/* }}} */

/* {{{ proto mixed pg_fetch_result(resource result, [int row_number,] mixed field_name)
   Returns values from a result identifier */
PHP_FUNCTION(pg_fetch_result)
{
	zval *result, **field=NULL;
	long row;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;
	int field_offset, pgsql_row, argc = ZEND_NUM_ARGS();

	if (argc == 2) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rZ"", &result, &field) == FAILURE) {
			return;
		}
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rlZ"", &result, &row, &field) == FAILURE) {
			return;
		}
	}
	
	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;
	if (argc == 2) {
		if (pg_result->row < 0) {
			pg_result->row = 0;
		}
		pgsql_row = pg_result->row;
		if (pgsql_row >= PQntuples(pgsql_result)) {
			RETURN_FALSE;
		}
	} else {
		pgsql_row = row;
		if (pgsql_row < 0 || pgsql_row >= PQntuples(pgsql_result)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to jump to row %ld on PostgreSQL result index %ld"",
							row, Z_LVAL_P(result));
			RETURN_FALSE;
		}
	}
	switch(Z_TYPE_PP(field)) {
		case IS_STRING:
			field_offset = PQfnumber(pgsql_result, Z_STRVAL_PP(field));
			break;
		default:
			convert_to_long_ex(field);
			field_offset = Z_LVAL_PP(field);
			break;
	}
	if (field_offset<0 || field_offset>=PQnfields(pgsql_result)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Bad column offset specified"");
		RETURN_FALSE;
	}

	if (PQgetisnull(pgsql_result, pgsql_row, field_offset)) {
		Z_TYPE_P(return_value) = IS_NULL;
	} else {
		char *value = PQgetvalue(pgsql_result, pgsql_row, field_offset);
		int value_len = PQgetlength(pgsql_result, pgsql_row, field_offset);
		ZVAL_STRINGL(return_value, value, value_len, 1);
	}
}
/* }}} */

/* {{{ void php_pgsql_fetch_hash */
static void php_pgsql_fetch_hash(INTERNAL_FUNCTION_PARAMETERS, long result_type, int into_object)
{
	zval                *result, *zrow = NULL;
	PGresult            *pgsql_result;
	pgsql_result_handle *pg_result;
	int             i, num_fields, pgsql_row, use_row;
	long            row = -1;
	char            *field_name;
	zval            *ctor_params = NULL;
	zend_class_entry *ce = NULL;

	if (into_object) {
		char *class_name = NULL;
		int class_name_len;

		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r|z!sz"", &result, &zrow, &class_name, &class_name_len, &ctor_params) == FAILURE) {
			return;
		}
		if (!class_name) {
			ce = zend_standard_class_def;
		} else {
			ce = zend_fetch_class(class_name, class_name_len, ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
		}
		if (!ce) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Could not find class '%s'"", class_name);
			return;
		}
		result_type = PGSQL_ASSOC;
	} else {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r|z!l"", &result, &zrow, &result_type) == FAILURE) {
			return;
		}
	}
	if (zrow == NULL) {
		row = -1;
	} else {
		convert_to_long(zrow);
		row = Z_LVAL_P(zrow);
		if (row < 0) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The row parameter must be greater or equal to zero"");
			RETURN_FALSE;
		}
	}
	use_row = ZEND_NUM_ARGS() > 1 && row != -1;

	if (!(result_type & PGSQL_BOTH)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid result type"");
		RETURN_FALSE;
	}
	
	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;

	if (use_row) { 
		pgsql_row = row;
		pg_result->row = pgsql_row;
		if (pgsql_row < 0 || pgsql_row >= PQntuples(pgsql_result)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to jump to row %ld on PostgreSQL result index %ld"",
							row, Z_LVAL_P(result));
			RETURN_FALSE;
		}
	} else {
		/* If 2nd param is NULL, use internal row counter to access next row */
		pgsql_row = pg_result->row;
		if (pgsql_row < 0 || pgsql_row >= PQntuples(pgsql_result)) {
			RETURN_FALSE;
		}
		pg_result->row++;
	}

	array_init(return_value);
	for (i = 0, num_fields = PQnfields(pgsql_result); i < num_fields; i++) {
		if (PQgetisnull(pgsql_result, pgsql_row, i)) {
			if (result_type & PGSQL_NUM) {
				add_index_null(return_value, i);
			}
			if (result_type & PGSQL_ASSOC) {
				field_name = PQfname(pgsql_result, i);
				add_assoc_null(return_value, field_name);
			}
		} else {
			char *element = PQgetvalue(pgsql_result, pgsql_row, i);
			if (element) {
				char *data;
				int data_len;
				int should_copy=0;
				const uint element_len = strlen(element);

				data = safe_estrndup(element, element_len);
				data_len = element_len;

				if (result_type & PGSQL_NUM) {
					add_index_stringl(return_value, i, data, data_len, should_copy);
					should_copy=1;
				}

				if (result_type & PGSQL_ASSOC) {
					field_name = PQfname(pgsql_result, i);
					add_assoc_stringl(return_value, field_name, data, data_len, should_copy);
				}
			}
		}
	}

	if (into_object) {
		zval dataset = *return_value;
		zend_fcall_info fci;
		zend_fcall_info_cache fcc;
		zval *retval_ptr;

		object_and_properties_init(return_value, ce, NULL);
		zend_merge_properties(return_value, Z_ARRVAL(dataset), 1 TSRMLS_CC);

		if (ce->constructor) {
			fci.size = sizeof(fci);
			fci.function_table = &ce->function_table;
			fci.function_name = NULL;
			fci.symbol_table = NULL;
			fci.object_ptr = return_value;
			fci.retval_ptr_ptr = &retval_ptr;
			if (ctor_params && Z_TYPE_P(ctor_params) != IS_NULL) {
				if (Z_TYPE_P(ctor_params) == IS_ARRAY) {
					HashTable *ht = Z_ARRVAL_P(ctor_params);
					Bucket *p;

					fci.param_count = 0;
					fci.params = safe_emalloc(sizeof(zval***), ht->nNumOfElements, 0);
					p = ht->pListHead;
					while (p != NULL) {
						fci.params[fci.param_count++] = (zval**)p->pData;
						p = p->pListNext;
					}
				} else {
					/* Two problems why we throw exceptions here: PHP is typeless
					 * and hence passing one argument that's not an array could be
					 * by mistake and the other way round is possible, too. The 
					 * single value is an array. Also we'd have to make that one
					 * argument passed by reference.
					 */
					zend_throw_exception(zend_exception_get_default(TSRMLS_C), ""Parameter ctor_params must be an array"", 0 TSRMLS_CC);
					return;
				}
			} else {
				fci.param_count = 0;
				fci.params = NULL;
			}
			fci.no_separation = 1;

			fcc.initialized = 1;
			fcc.function_handler = ce->constructor;
			fcc.calling_scope = EG(scope);
			fcc.called_scope = Z_OBJCE_P(return_value);
			fcc.object_ptr = return_value;

			if (zend_call_function(&fci, &fcc TSRMLS_CC) == FAILURE) {
				zend_throw_exception_ex(zend_exception_get_default(TSRMLS_C), 0 TSRMLS_CC, ""Could not execute %s::%s()"", ce->name, ce->constructor->common.function_name);
			} else {
				if (retval_ptr) {
					zval_ptr_dtor(&retval_ptr);
				}
			}
			if (fci.params) {
				efree(fci.params);
			}
		} else if (ctor_params) {
			zend_throw_exception_ex(zend_exception_get_default(TSRMLS_C), 0 TSRMLS_CC, ""Class %s does not have a constructor hence you cannot use ctor_params"", ce->name);
		}
	}
}
/* }}} */

/* {{{ proto array pg_fetch_row(resource result [, int row [, int result_type]])
   Get a row as an enumerated array */ 
PHP_FUNCTION(pg_fetch_row)
{
	php_pgsql_fetch_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, PGSQL_NUM, 0);
}
/* }}} */

/* {{{ proto array pg_fetch_assoc(resource result [, int row])
   Fetch a row as an assoc array */
PHP_FUNCTION(pg_fetch_assoc)
{
	/* pg_fetch_assoc() is added from PHP 4.3.0. It should raise error, when
	   there is 3rd parameter */
	if (ZEND_NUM_ARGS() > 2)
		WRONG_PARAM_COUNT;
	php_pgsql_fetch_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, PGSQL_ASSOC, 0);
}
/* }}} */

/* {{{ proto array pg_fetch_array(resource result [, int row [, int result_type]])
   Fetch a row as an array */
PHP_FUNCTION(pg_fetch_array)
{
	php_pgsql_fetch_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, PGSQL_BOTH, 0);
}
/* }}} */

/* {{{ proto object pg_fetch_object(resource result [, int row [, string class_name [, NULL|array ctor_params]]])
   Fetch a row as an object */
PHP_FUNCTION(pg_fetch_object)
{
	/* pg_fetch_object() allowed result_type used to be. 3rd parameter
	   must be allowed for compatibility */
	php_pgsql_fetch_hash(INTERNAL_FUNCTION_PARAM_PASSTHRU, PGSQL_ASSOC, 1);
}
/* }}} */

/* {{{ proto array pg_fetch_all(resource result)
   Fetch all rows into array */
PHP_FUNCTION(pg_fetch_all)
{
	zval *result;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &result) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;
	array_init(return_value);
	if (php_pgsql_result2array(pgsql_result, return_value TSRMLS_CC) == FAILURE) {
		zval_dtor(return_value);
		RETURN_FALSE;
	}
}
/* }}} */

/* {{{ proto array pg_fetch_all_columns(resource result [, int column_number])
   Fetch all rows into array */
PHP_FUNCTION(pg_fetch_all_columns)
{
	zval *result;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;
	unsigned long colno=0;
	int pg_numrows, pg_row;
	size_t num_fields;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r|l"", &result, &colno) == FAILURE) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;

	num_fields = PQnfields(pgsql_result);
	if (colno >= num_fields || colno < 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid column number '%ld'"", colno);
		RETURN_FALSE;
	}

	array_init(return_value);

	if ((pg_numrows = PQntuples(pgsql_result)) <= 0) {
		return;
	}

	for (pg_row = 0; pg_row < pg_numrows; pg_row++) {
		if (PQgetisnull(pgsql_result, pg_row, colno)) {
			add_next_index_null(return_value);
		} else {
			add_next_index_string(return_value, PQgetvalue(pgsql_result, pg_row, colno), 1); 
		}
	}
}
/* }}} */

/* {{{ proto bool pg_result_seek(resource result, int offset)
   Set internal row offset */
PHP_FUNCTION(pg_result_seek)
{
	zval *result;
	long row;
	pgsql_result_handle *pg_result;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl"", &result, &row) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	if (row < 0 || row >= PQntuples(pg_result->result)) {
		RETURN_FALSE;
	}

	/* seek to offset */
	pg_result->row = row;
	RETURN_TRUE;
}
/* }}} */


#define PHP_PG_DATA_LENGTH 1
#define PHP_PG_DATA_ISNULL 2

/* {{{ php_pgsql_data_info
 */
static void php_pgsql_data_info(INTERNAL_FUNCTION_PARAMETERS, int entry_type)
{
	zval *result, **field;
	long row;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;
	int field_offset, pgsql_row, argc = ZEND_NUM_ARGS();

	if (argc == 2) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rZ"", &result, &field) == FAILURE) {
			return;
		}
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rlZ"", &result, &row, &field) == FAILURE) {
			return;
		}
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);

	pgsql_result = pg_result->result;
	if (argc == 2) {
		if (pg_result->row < 0) {
			pg_result->row = 0;
		}
		pgsql_row = pg_result->row;
		if (pgsql_row < 0 || pgsql_row >= PQntuples(pgsql_result)) {
			RETURN_FALSE;
		}
	} else {
		pgsql_row = row;
		if (pgsql_row < 0 || pgsql_row >= PQntuples(pgsql_result)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to jump to row %ld on PostgreSQL result index %ld"",
							row, Z_LVAL_P(result));
			RETURN_FALSE;
		}
	}

	switch(Z_TYPE_PP(field)) {
		case IS_STRING:
			convert_to_string_ex(field);
			field_offset = PQfnumber(pgsql_result, Z_STRVAL_PP(field));
			break;
		default:
			convert_to_long_ex(field);
			field_offset = Z_LVAL_PP(field);
			break;
	}
	if (field_offset < 0 || field_offset >= PQnfields(pgsql_result)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Bad column offset specified"");
		RETURN_FALSE;
	}

	switch (entry_type) {
		case PHP_PG_DATA_LENGTH:
			Z_LVAL_P(return_value) = PQgetlength(pgsql_result, pgsql_row, field_offset);
			break;
		case PHP_PG_DATA_ISNULL:
			Z_LVAL_P(return_value) = PQgetisnull(pgsql_result, pgsql_row, field_offset);
			break;
	}
	Z_TYPE_P(return_value) = IS_LONG;
}
/* }}} */

/* {{{ proto int pg_field_prtlen(resource result, [int row,] mixed field_name_or_number)
   Returns the printed length */
PHP_FUNCTION(pg_field_prtlen)
{
	php_pgsql_data_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_PG_DATA_LENGTH);
}
/* }}} */

/* {{{ proto int pg_field_is_null(resource result, [int row,] mixed field_name_or_number)
   Test if a field is NULL */
PHP_FUNCTION(pg_field_is_null)
{
	php_pgsql_data_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_PG_DATA_ISNULL);
}
/* }}} */

/* {{{ proto bool pg_free_result(resource result)
   Free result memory */
PHP_FUNCTION(pg_free_result)
{
	zval *result;
	pgsql_result_handle *pg_result;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &result) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);
	if (Z_LVAL_P(result) == 0) {
		RETURN_FALSE;
	}
	zend_list_delete(Z_RESVAL_P(result));
	RETURN_TRUE;
}
/* }}} */

/* {{{ proto string pg_last_oid(resource result)
   Returns the last object identifier */
PHP_FUNCTION(pg_last_oid)
{
	zval *result;
	PGresult *pgsql_result;
	pgsql_result_handle *pg_result;
#ifdef HAVE_PQOIDVALUE
	Oid oid;
#endif

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &result) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, ""PostgreSQL result"", le_result);
	pgsql_result = pg_result->result;
#ifdef HAVE_PQOIDVALUE
	oid = PQoidValue(pgsql_result);
	if (oid == InvalidOid) {
		RETURN_FALSE;
	}
	PGSQL_RETURN_OID(oid);
#else
	Z_STRVAL_P(return_value) = (char *) PQoidStatus(pgsql_result);
	if (Z_STRVAL_P(return_value)) {
		RETURN_STRING(Z_STRVAL_P(return_value), 1);
	}
	RETURN_STRING("""", 1);
#endif
}
/* }}} */

/* {{{ proto bool pg_trace(string filename [, string mode [, resource connection]])
   Enable tracing a PostgreSQL connection */
PHP_FUNCTION(pg_trace)
{
	char *z_filename, *mode = ""w"";
	int z_filename_len, mode_len;
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	FILE *fp = NULL;
        php_stream *stream;
        id = PGG(default_link);
 
//flaw_line_below:
       if (zend_parse_parameters(argc TSRMLS_CC, ""s|sr"", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {
//fix_flaw_line_below:
//       if (zend_parse_parameters(argc TSRMLS_CC, ""p|sr"", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {
                return;
        }
	if (argc < 3) {
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	stream = php_stream_open_wrapper(z_filename, mode, REPORT_ERRORS, NULL);

	if (!stream) {
		RETURN_FALSE;
	}

	if (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&fp, REPORT_ERRORS))	{
		php_stream_close(stream);
		RETURN_FALSE;
	}
	php_stream_auto_cleanup(stream);
	PQtrace(pgsql, fp);
	RETURN_TRUE;
}
/* }}} */

/* {{{ proto bool pg_untrace([resource connection])
   Disable tracing of a PostgreSQL connection */
PHP_FUNCTION(pg_untrace)
{
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	
	if (zend_parse_parameters(argc TSRMLS_CC, ""|r"", &pgsql_link) == FAILURE) {
		return;
	}

	if (argc == 0) { 
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);
	PQuntrace(pgsql);
	RETURN_TRUE;
}
/* }}} */

/* {{{ proto mixed pg_lo_create([resource connection],[mixed large_object_oid])
   Create a large object */
PHP_FUNCTION(pg_lo_create)
{
	zval *pgsql_link = NULL, *oid = NULL;
	PGconn *pgsql;
	Oid pgsql_oid, wanted_oid = InvalidOid;
	int id = -1, argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""|zz"", &pgsql_link, &oid) == FAILURE) {
		return;
	}

	if ((argc == 1) && (Z_TYPE_P(pgsql_link) != IS_RESOURCE)) {
		oid = pgsql_link;
		pgsql_link = NULL;
	}
	
	if (pgsql_link == NULL) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
		if (id == -1) {
			RETURN_FALSE;
		}
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);
	
	if (oid) {
#ifndef HAVE_PG_LO_CREATE
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Passing OID value is not supported. Upgrade your PostgreSQL"");
#else
		switch (Z_TYPE_P(oid)) {
		case IS_STRING:
			{
				char *end_ptr;
				wanted_oid = (Oid)strtoul(Z_STRVAL_P(oid), &end_ptr, 10);
				if ((Z_STRVAL_P(oid)+Z_STRLEN_P(oid)) != end_ptr) {
				/* wrong integer format */
				php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
				RETURN_FALSE;
				}
			}
			break;
		case IS_LONG:
			if (Z_LVAL_P(oid) < (long)InvalidOid) {
				php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
				RETURN_FALSE;
			}
			wanted_oid = (Oid)Z_LVAL_P(oid);
			break;
		default:
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
			RETURN_FALSE;
        }
		if ((pgsql_oid = lo_create(pgsql, wanted_oid)) == InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to create PostgreSQL large object"");
			RETURN_FALSE;
		}

		PGSQL_RETURN_OID(pgsql_oid);
#endif
	}

	if ((pgsql_oid = lo_creat(pgsql, INV_READ|INV_WRITE)) == InvalidOid) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to create PostgreSQL large object"");
		RETURN_FALSE;
	}

	PGSQL_RETURN_OID(pgsql_oid);
}
/* }}} */

/* {{{ proto bool pg_lo_unlink([resource connection,] string large_object_oid)
   Delete a large object */
PHP_FUNCTION(pg_lo_unlink)
{
	zval *pgsql_link = NULL;
	long oid_long;
	char *oid_string, *end_ptr;
	int oid_strlen;
	PGconn *pgsql;
	Oid oid;
	int id = -1;
	int argc = ZEND_NUM_ARGS();

	/* accept string type since Oid type is unsigned int */
	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rs"", &pgsql_link, &oid_string, &oid_strlen) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rl"", &pgsql_link, &oid_long) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""s"", &oid_string, &oid_strlen) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""l"", &oid_long) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID is specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Requires 1 or 2 arguments"");
		RETURN_FALSE;
	}
	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (lo_unlink(pgsql, oid) == -1) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to delete PostgreSQL large object %u"", oid);
		RETURN_FALSE;
	}
	RETURN_TRUE;
}
/* }}} */

/* {{{ proto resource pg_lo_open([resource connection,] int large_object_oid, string mode)
   Open a large object and return fd */
PHP_FUNCTION(pg_lo_open)
{
	zval *pgsql_link = NULL;
	long oid_long;
	char *oid_string, *end_ptr, *mode_string;
	int oid_strlen, mode_strlen;
	PGconn *pgsql;
	Oid oid;
	int id = -1, pgsql_mode=0, pgsql_lofd;
	int create=0;
	pgLofp *pgsql_lofp;
	int argc = ZEND_NUM_ARGS();

	/* accept string type since Oid is unsigned int */
	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rss"", &pgsql_link, &oid_string, &oid_strlen, &mode_string, &mode_strlen) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rls"", &pgsql_link, &oid_long, &mode_string, &mode_strlen) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""ss"", &oid_string, &oid_strlen, &mode_string, &mode_strlen) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""ls"", &oid_long, &mode_string, &mode_strlen) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Requires 1 or 2 arguments"");
		RETURN_FALSE;
	}
	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);
	
	/* r/w/+ is little bit more PHP-like than INV_READ/INV_WRITE and a lot of
	   faster to type. Unfortunately, doesn't behave the same way as fopen()...
	   (Jouni)
	*/

	if (strchr(mode_string, 'r') == mode_string) {
		pgsql_mode |= INV_READ;
		if (strchr(mode_string, '+') == mode_string+1) {
			pgsql_mode |= INV_WRITE;
		}
	}
	if (strchr(mode_string, 'w') == mode_string) {
		pgsql_mode |= INV_WRITE;
		create = 1;
		if (strchr(mode_string, '+') == mode_string+1) {
			pgsql_mode |= INV_READ;
		}
	}

	pgsql_lofp = (pgLofp *) emalloc(sizeof(pgLofp));

	if ((pgsql_lofd = lo_open(pgsql, oid, pgsql_mode)) == -1) {
		if (create) {
			if ((oid = lo_creat(pgsql, INV_READ|INV_WRITE)) == 0) {
				efree(pgsql_lofp);
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to create PostgreSQL large object"");
				RETURN_FALSE;
			} else {
				if ((pgsql_lofd = lo_open(pgsql, oid, pgsql_mode)) == -1) {
					if (lo_unlink(pgsql, oid) == -1) {
						efree(pgsql_lofp);
						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Something is really messed up! Your database is badly corrupted in a way NOT related to PHP"");
						RETURN_FALSE;
					}
					efree(pgsql_lofp);
					php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to open PostgreSQL large object"");
					RETURN_FALSE;
				} else {
					pgsql_lofp->conn = pgsql;
					pgsql_lofp->lofd = pgsql_lofd;
					Z_LVAL_P(return_value) = zend_list_insert(pgsql_lofp, le_lofp TSRMLS_CC);
					Z_TYPE_P(return_value) = IS_LONG;
				}
			}
		} else {
			efree(pgsql_lofp);
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to open PostgreSQL large object"");
			RETURN_FALSE;
		}
	} else {
		pgsql_lofp->conn = pgsql;
		pgsql_lofp->lofd = pgsql_lofd;
		ZEND_REGISTER_RESOURCE(return_value, pgsql_lofp, le_lofp);
	}
}
/* }}} */

/* {{{ proto bool pg_lo_close(resource large_object)
   Close a large object */
PHP_FUNCTION(pg_lo_close)
{
	zval *pgsql_lofp;
	pgLofp *pgsql;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &pgsql_lofp) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_lofp, -1, ""PostgreSQL large object"", le_lofp);
	
	if (lo_close((PGconn *)pgsql->conn, pgsql->lofd) < 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to close PostgreSQL large object descriptor %d"", pgsql->lofd);
		RETVAL_FALSE;
	} else {
		RETVAL_TRUE;
	}

	zend_list_delete(Z_RESVAL_P(pgsql_lofp));
	return;
}
/* }}} */

#define PGSQL_LO_READ_BUF_SIZE  8192

/* {{{ proto string pg_lo_read(resource large_object [, int len])
   Read a large object */
PHP_FUNCTION(pg_lo_read)
{
	zval *pgsql_id;
	long len;
	int buf_len = PGSQL_LO_READ_BUF_SIZE, nbytes, argc = ZEND_NUM_ARGS();
	char *buf;
	pgLofp *pgsql;

	if (zend_parse_parameters(argc TSRMLS_CC, ""r|l"", &pgsql_id, &len) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	if (argc > 1) {
		buf_len = len;
	}
	
	buf = (char *) safe_emalloc(sizeof(char), (buf_len+1), 0);
	if ((nbytes = lo_read((PGconn *)pgsql->conn, pgsql->lofd, buf, buf_len))<0) {
		efree(buf);
		RETURN_FALSE;
	}

	buf[nbytes] = '\0';
	RETURN_STRINGL(buf, nbytes, 0);
}
/* }}} */

/* {{{ proto int pg_lo_write(resource large_object, string buf [, int len])
   Write a large object */
PHP_FUNCTION(pg_lo_write)
{
  	zval *pgsql_id;
  	char *str;
  	long z_len;
	int str_len, nbytes;
	int len;
	pgLofp *pgsql;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""rs|l"", &pgsql_id, &str, &str_len, &z_len) == FAILURE) {
		return;
	}

	if (argc > 2) {
		if (z_len > str_len) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Cannot write more than buffer size %d. Tried to write %ld"", str_len, z_len);
			RETURN_FALSE;
		}
		if (z_len < 0) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Buffer size must be larger than 0, but %ld was specified"", z_len);
			RETURN_FALSE;
		}
		len = z_len;
	}
	else {
		len = str_len;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	if ((nbytes = lo_write((PGconn *)pgsql->conn, pgsql->lofd, str, len)) == -1) {
		RETURN_FALSE;
	}

	RETURN_LONG(nbytes);
}
/* }}} */

/* {{{ proto int pg_lo_read_all(resource large_object)
   Read a large object and send straight to browser */
PHP_FUNCTION(pg_lo_read_all)
{
  	zval *pgsql_id;
	int tbytes;
	volatile int nbytes;
	char buf[PGSQL_LO_READ_BUF_SIZE];
	pgLofp *pgsql;
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &pgsql_id) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	tbytes = 0;
	while ((nbytes = lo_read((PGconn *)pgsql->conn, pgsql->lofd, buf, PGSQL_LO_READ_BUF_SIZE))>0) {
		PHPWRITE(buf, nbytes);
		tbytes += nbytes;
	}
	RETURN_LONG(tbytes);
}
/* }}} */

/* {{{ proto int pg_lo_import([resource connection, ] string filename [, mixed oid])
   Import large object direct from filesystem */
PHP_FUNCTION(pg_lo_import)
{
	zval *pgsql_link = NULL, *oid = NULL;
	char *file_in;
	int id = -1, name_len;
	int argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	Oid returned_oid;

	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rp|z"", &pgsql_link, &file_in, &name_len, &oid) == SUCCESS) {
		;
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
									  ""p|z"", &file_in, &name_len, &oid) == SUCCESS) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	/* old calling convention, deprecated since PHP 4.2 */
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
									  ""pr"", &file_in, &name_len, &pgsql_link ) == SUCCESS) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Old API is used"");
	}
	else {
		WRONG_PARAM_COUNT;
	}
	
	if (php_check_open_basedir(file_in TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (oid) {
#ifndef HAVE_PG_LO_IMPORT_WITH_OID
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""OID value passing not supported"");
#else
		Oid wanted_oid;
		switch (Z_TYPE_P(oid)) {
		case IS_STRING:
			{
				char *end_ptr;
				wanted_oid = (Oid)strtoul(Z_STRVAL_P(oid), &end_ptr, 10);
				if ((Z_STRVAL_P(oid)+Z_STRLEN_P(oid)) != end_ptr) {
				/* wrong integer format */
				php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
				RETURN_FALSE;
				}
			}
			break;
		case IS_LONG:
			if (Z_LVAL_P(oid) < (long)InvalidOid) {
				php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
				RETURN_FALSE;
			}
			wanted_oid = (Oid)Z_LVAL_P(oid);
			break;
		default:
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""invalid OID value passed"");
			RETURN_FALSE;
        }

       returned_oid = lo_import_with_oid(pgsql, file_in, wanted_oid);

	   if (returned_oid == InvalidOid) {
		   RETURN_FALSE;
	   }

	   PGSQL_RETURN_OID(returned_oid);
#endif
	}

	returned_oid = lo_import(pgsql, file_in);

	if (returned_oid == InvalidOid) {
		RETURN_FALSE;
	}
	PGSQL_RETURN_OID(returned_oid);
}
/* }}} */

/* {{{ proto bool pg_lo_export([resource connection, ] int objoid, string filename)
   Export large object direct to filesystem */
PHP_FUNCTION(pg_lo_export)
{
	zval *pgsql_link = NULL;
	char *file_out, *oid_string, *end_ptr;
	int oid_strlen;
	int id = -1, name_len;
	long oid_long;
	Oid oid;
	PGconn *pgsql;
	int argc = ZEND_NUM_ARGS();

	/* allow string to handle large OID value correctly */
	if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rlp"", &pgsql_link, &oid_long, &file_out, &name_len) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""rss"", &pgsql_link, &oid_string, &oid_strlen, &file_out, &name_len) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
									  ""lp"",  &oid_long, &file_out, &name_len) == SUCCESS) {
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""sp"", &oid_string, &oid_strlen, &file_out, &name_len) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
								 ""spr"", &oid_string, &oid_strlen, &file_out, &name_len, &pgsql_link) == SUCCESS) {
		oid = (Oid)strtoul(oid_string, &end_ptr, 10);
		if ((oid_string+oid_strlen) != end_ptr) {
			/* wrong integer format */
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Wrong OID value passed"");
			RETURN_FALSE;
		}
	}
	else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
									  ""lpr"", &oid_long, &file_out, &name_len, &pgsql_link) == SUCCESS) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Old API is used"");
		if (oid_long <= InvalidOid) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Invalid OID specified"");
			RETURN_FALSE;
		}
		oid = (Oid)oid_long;
	}
	else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Requires 2 or 3 arguments"");
		RETURN_FALSE;
	}
	
	if (php_check_open_basedir(file_out TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (lo_export(pgsql, oid, file_out)) {
		RETURN_TRUE;
	}
	RETURN_FALSE;
}
/* }}} */

/* {{{ proto bool pg_lo_seek(resource large_object, int offset [, int whence])
   Seeks position of large object */
PHP_FUNCTION(pg_lo_seek)
{
	zval *pgsql_id = NULL;
	long offset = 0, whence = SEEK_CUR;
	pgLofp *pgsql;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""rl|l"", &pgsql_id, &offset, &whence) == FAILURE) {
		return;
	}
	if (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid whence parameter"");
		return;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	if (lo_lseek((PGconn *)pgsql->conn, pgsql->lofd, offset, whence) > -1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}
}
/* }}} */

/* {{{ proto int pg_lo_tell(resource large_object)
   Returns current position of large object */
PHP_FUNCTION(pg_lo_tell)
{
	zval *pgsql_id = NULL;
	int offset = 0;
	pgLofp *pgsql;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""r"", &pgsql_id) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	offset = lo_tell((PGconn *)pgsql->conn, pgsql->lofd);
	RETURN_LONG(offset);
}
/* }}} */

#if HAVE_PQSETERRORVERBOSITY
/* {{{ proto int pg_set_error_verbosity([resource connection,] int verbosity)
   Set error verbosity */
PHP_FUNCTION(pg_set_error_verbosity)
{
	zval *pgsql_link = NULL;
	long verbosity;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;

	if (argc == 1) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""l"", &verbosity) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rl"", &pgsql_link, &verbosity) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}	

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (verbosity & (PQERRORS_TERSE|PQERRORS_DEFAULT|PQERRORS_VERBOSE)) {
		Z_LVAL_P(return_value) = PQsetErrorVerbosity(pgsql, verbosity);
		Z_TYPE_P(return_value) = IS_LONG;
	} else {
		RETURN_FALSE;
	}
}
/* }}} */
#endif

#ifdef HAVE_PQCLIENTENCODING
/* {{{ proto int pg_set_client_encoding([resource connection,] string encoding)
   Set client encoding */
PHP_FUNCTION(pg_set_client_encoding)
{
	char *encoding;
	int encoding_len;
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;

	if (argc == 1) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""s"", &encoding, &encoding_len) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rs"", &pgsql_link, &encoding, &encoding_len) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	Z_LVAL_P(return_value) = PQsetClientEncoding(pgsql, encoding);
	Z_TYPE_P(return_value) = IS_LONG;
}
/* }}} */

/* {{{ proto string pg_client_encoding([resource connection])
   Get the current client encoding */
PHP_FUNCTION(pg_client_encoding)
{
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;

	if (zend_parse_parameters(argc TSRMLS_CC, ""|r"", &pgsql_link) == FAILURE) {
		return;
	}
	
	if (argc == 0) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}	

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	/* Just do the same as found in PostgreSQL sources... */

	Z_STRVAL_P(return_value) = (char *) pg_encoding_to_char(PQclientEncoding(pgsql));
	Z_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));
	Z_STRVAL_P(return_value) = (char *) estrdup(Z_STRVAL_P(return_value));
	Z_TYPE_P(return_value) = IS_STRING;
}
/* }}} */
#endif

#if !HAVE_PQGETCOPYDATA
#define	COPYBUFSIZ	8192
#endif

/* {{{ proto bool pg_end_copy([resource connection])
   Sync with backend. Completes the Copy command */
PHP_FUNCTION(pg_end_copy)
{
	zval *pgsql_link = NULL;
	int id = -1, argc = ZEND_NUM_ARGS();
	PGconn *pgsql;
	int result = 0;

	if (zend_parse_parameters(argc TSRMLS_CC, ""|r"", &pgsql_link) == FAILURE) {
		return;
	}
	
	if (argc == 0) {
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	result = PQendcopy(pgsql);

	if (result!=0) {
		PHP_PQ_ERROR(""Query failed: %s"", pgsql);
		RETURN_FALSE;
	}
	RETURN_TRUE;
}
/* }}} */


/* {{{ proto bool pg_put_line([resource connection,] string query)
   Send null-terminated string to backend server*/
PHP_FUNCTION(pg_put_line)
{
	char *query;
	zval *pgsql_link = NULL;
	int query_len, id = -1;
	PGconn *pgsql;
	int result = 0, argc = ZEND_NUM_ARGS();

	if (argc == 1) {
		if (zend_parse_parameters(argc TSRMLS_CC, ""s"", &query, &query_len) == FAILURE) {
			return;
		}
		id = PGG(default_link);
		CHECK_DEFAULT_LINK(id);
	} else {
		if (zend_parse_parameters(argc TSRMLS_CC, ""rs"", &pgsql_link, &query, &query_len) == FAILURE) {
			return;
		}
	}

	if (pgsql_link == NULL && id == -1) {
		RETURN_FALSE;
	}	

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	result = PQputline(pgsql, query);
	if (result==EOF) {
		PHP_PQ_ERROR(""Query failed: %s"", pgsql);
		RETURN_FALSE;
	}
	RETURN_TRUE;
}
/* }}} */

/* {{{ proto array pg_copy_to(resource connection, string table_name [, string delimiter [, string null_as]])
   Copy table to array */
PHP_FUNCTION(pg_copy_to)
{
	zval *pgsql_link;
	char *table_name, *pg_delim = NULL, *pg_null_as = NULL;
	int table_name_len, pg_delim_len, pg_null_as_len, free_pg_null = 0;
	char *query;
	int id = -1;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	int copydone = 0;
#if !HAVE_PQGETCOPYDATA
	char copybuf[COPYBUFSIZ];
#endif
	char *csv = (char *)NULL;
	int ret;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""rs|ss"",
							  &pgsql_link, &table_name, &table_name_len,
							  &pg_delim, &pg_delim_len, &pg_null_as, &pg_null_as_len) == FAILURE) {
		return;
	}
	if (!pg_delim) {
		pg_delim = ""\t"";
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	if (!pg_null_as) {
		pg_null_as = safe_estrdup(""\\\\N"");
		free_pg_null = 1;
	}

	spprintf(&query, 0, ""COPY %s TO STDOUT DELIMITERS E'%c' WITH NULL AS E'%s'"", table_name, *pg_delim, pg_null_as);

	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
	}
	pgsql_result = PQexec(pgsql, query);
	if (free_pg_null) {
		efree(pg_null_as);
	}
	efree(query);

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}

	switch (status) {
		case PGRES_COPY_OUT:
			if (pgsql_result) {
				PQclear(pgsql_result);
				array_init(return_value);
#if HAVE_PQGETCOPYDATA
				while (!copydone)
				{
					ret = PQgetCopyData(pgsql, &csv, 0);
					switch (ret) {
						case -1:
							copydone = 1;
							break;
						case 0:
						case -2:
							PHP_PQ_ERROR(""getline failed: %s"", pgsql);
							RETURN_FALSE;
							break;
						default:
							add_next_index_string(return_value, csv, 1);
							PQfreemem(csv);
							break;
					}
				}
#else
				while (!copydone)
				{
					if ((ret = PQgetline(pgsql, copybuf, COPYBUFSIZ))) {
						PHP_PQ_ERROR(""getline failed: %s"", pgsql);
						RETURN_FALSE;
					}

					if (copybuf[0] == '\\' &&
						copybuf[1] == '.' &&
						copybuf[2] == '\0')
					{
						copydone = 1;
					}
					else
					{
						if (csv == (char *)NULL) {
							csv = estrdup(copybuf);
						} else {
							csv = (char *)erealloc(csv, strlen(csv) + sizeof(char)*(COPYBUFSIZ+1));
							strcat(csv, copybuf);
						}
							
						switch (ret)
						{
							case EOF:
								copydone = 1;
							case 0:
								add_next_index_string(return_value, csv, 1);
								efree(csv);
								csv = (char *)NULL;
								break;
							case 1:
								break;
						}
					}
				}
				if (PQendcopy(pgsql)) {
					PHP_PQ_ERROR(""endcopy failed: %s"", pgsql);
					RETURN_FALSE;
				}
#endif
				while ((pgsql_result = PQgetResult(pgsql))) {
					PQclear(pgsql_result);
				}
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			break;
		default:
			PQclear(pgsql_result);
			PHP_PQ_ERROR(""Copy command failed: %s"", pgsql);
			RETURN_FALSE;
			break;
	}
}
/* }}} */

/* {{{ proto bool pg_copy_from(resource connection, string table_name , array rows [, string delimiter [, string null_as]])
   Copy table from array */
PHP_FUNCTION(pg_copy_from)
{
	zval *pgsql_link = NULL, *pg_rows;
	zval **tmp;
	char *table_name, *pg_delim = NULL, *pg_null_as = NULL;
	int  table_name_len, pg_delim_len, pg_null_as_len;
	int  pg_null_as_free = 0;
	char *query;
	HashPosition pos;
	int id = -1;
	PGconn *pgsql;
	PGresult *pgsql_result;
	ExecStatusType status;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""rsa|ss"",
							  &pgsql_link, &table_name, &table_name_len, &pg_rows,
							  &pg_delim, &pg_delim_len, &pg_null_as, &pg_null_as_len) == FAILURE) {
		return;
	}
	if (!pg_delim) {
		pg_delim = ""\t"";
	}
	if (!pg_null_as) {
		pg_null_as = safe_estrdup(""\\\\N"");
		pg_null_as_free = 1;
	}

	ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);

	spprintf(&query, 0, ""COPY %s FROM STDIN DELIMITERS E'%c' WITH NULL AS E'%s'"", table_name, *pg_delim, pg_null_as);
	while ((pgsql_result = PQgetResult(pgsql))) {
		PQclear(pgsql_result);
	}
	pgsql_result = PQexec(pgsql, query);

	if (pg_null_as_free) {
		efree(pg_null_as);
	}
	efree(query);

	if (pgsql_result) {
		status = PQresultStatus(pgsql_result);
	} else {
		status = (ExecStatusType) PQstatus(pgsql);
	}

	switch (status) {
		case PGRES_COPY_IN:
			if (pgsql_result) {
				int command_failed = 0;
				PQclear(pgsql_result);
				zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(pg_rows), &pos);
#if HAVE_PQPUTCOPYDATA
				while (zend_hash_get_current_data_ex(Z_ARRVAL_P(pg_rows), (void **) &tmp, &pos) == SUCCESS) {
					convert_to_string_ex(tmp);
					query = (char *)emalloc(Z_STRLEN_PP(tmp) + 2);
					strlcpy(query, Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp) + 2);
					if(Z_STRLEN_PP(tmp) > 0 && *(query + Z_STRLEN_PP(tmp) - 1) != '\n') {
						strlcat(query, ""\n"", Z_STRLEN_PP(tmp) + 2);
					}
					if (PQputCopyData(pgsql, query, strlen(query)) != 1) {
						efree(query);
						PHP_PQ_ERROR(""copy failed: %s"", pgsql);
						RETURN_FALSE;
					}
					efree(query);
					zend_hash_move_forward_ex(Z_ARRVAL_P(pg_rows), &pos);
				}
				if (PQputCopyEnd(pgsql, NULL) != 1) {
					PHP_PQ_ERROR(""putcopyend failed: %s"", pgsql);
					RETURN_FALSE;
				}
#else
				while (zend_hash_get_current_data_ex(Z_ARRVAL_P(pg_rows), (void **) &tmp, &pos) == SUCCESS) {
					convert_to_string_ex(tmp);
					query = (char *)emalloc(Z_STRLEN_PP(tmp) + 2);
					strlcpy(query, Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp) + 2);
					if(Z_STRLEN_PP(tmp) > 0 && *(query + Z_STRLEN_PP(tmp) - 1) != '\n') {
						strlcat(query, ""\n"", Z_STRLEN_PP(tmp) + 2);
					}
					if (PQputline(pgsql, query)==EOF) {
						efree(query);
						PHP_PQ_ERROR(""copy failed: %s"", pgsql);
						RETURN_FALSE;
					}
					efree(query);
					zend_hash_move_forward_ex(Z_ARRVAL_P(pg_rows), &pos);
				}
				if (PQputline(pgsql, ""\\.\n"") == EOF) {
					PHP_PQ_ERROR(""putline failed: %s"", pgsql);
					RETURN_FALSE;
				}
				if (PQendcopy(pgsql)) {
					PHP_PQ_ERROR(""endcopy failed: %s"", pgsql);
					RETURN_FALSE;
				}
#endif
				while ((pgsql_result = PQgetResult(pgsql))) {
					if (PGRES_COMMAND_OK != PQresultStatus(pgsql_result)) {
						PHP_PQ_ERROR(""Copy command failed: %s"", pgsql);
						command_failed = 1;
					}
					PQclear(pgsql_result);
				}
				if (command_failed) {
					RETURN_FALSE;
				}
			} else {
				PQclear(pgsql_result);
				RETURN_FALSE;
			}
			RETURN_TRUE;
			break;
		default:
			PQclear(pgsql_result);
			PHP_PQ_ERROR(""Copy command failed: %s"", pgsql);
			RETURN_FALSE;
			break;
	}
}
/* }}} */

#ifdef HAVE_PQESCAPE
/* {{{ proto string pg_escape_string([resource connection,] string data)
   Escape string for text/char type */
PHP_FUNCTION(pg_escape_string)
{
	char *from = NULL, *to = NULL;
	zval *pgsql_link;
#ifdef HAVE_PQESCAPE_CONN
	PGconn *pgsql;
#endif
	int to_len;
	int from_len;
	int id = -1;

	switch (ZEND_NUM_ARGS()) {
		case 1:
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &from, &from_len) == FAILURE) {
				return;
			}
			pgsql_link = NULL;
			id = PGG(default_link);
			break;

		default:
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &pgsql_link, &from, &from_len) == FAILURE) {
				return;
			}
			break;
	}

	to = (char *) safe_emalloc(from_len, 2, 1);
#ifdef HAVE_PQESCAPE_CONN
	if (pgsql_link != NULL || id != -1) {
		ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);
		to_len = (int) PQescapeStringConn(pgsql, to, from, (size_t)from_len, NULL);
	} else
#endif
		to_len = (int) PQescapeString(to, from, (size_t)from_len);

	RETURN_STRINGL(to, to_len, 0);
}
/* }}} */

/* {{{ proto string pg_escape_bytea([resource connection,] string data)
   Escape binary for bytea type  */
PHP_FUNCTION(pg_escape_bytea)
{
	char *from = NULL, *to = NULL;
	size_t to_len;
	int from_len, id = -1;
#ifdef HAVE_PQESCAPE_BYTEA_CONN
	PGconn *pgsql;
#endif
	zval *pgsql_link;

	switch (ZEND_NUM_ARGS()) {
		case 1:
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &from, &from_len) == FAILURE) {
				return;
			}
			pgsql_link = NULL;
			id = PGG(default_link);
			break;

		default:
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &pgsql_link, &from, &from_len) == FAILURE) {
				return;
			}
			break;
	}

#ifdef HAVE_PQESCAPE_BYTEA_CONN
	if (pgsql_link != NULL || id != -1) {
		ZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, ""PostgreSQL link"", le_link, le_plink);
		to = (char *)PQescapeByteaConn(pgsql, (unsigned char *)from, (size_t)from_len, &to_len);
	} else
#endif
		to = (char *)PQescapeBytea((unsigned char*)from, from_len, &to_len);

	RETVAL_STRINGL(to, to_len-1, 1); /* to_len includes addtional '\0' */
	PQfreemem(to);
}
/* }}} */

#if !HAVE_PQUNESCAPEBYTEA
/* PQunescapeBytea() from PostgreSQL 7.3 to provide bytea unescape feature to 7.2 users.
   Renamed to php_pgsql_unescape_bytea() */
/*
 *		PQunescapeBytea - converts the null terminated string representation
 *		of a bytea, strtext, into binary, filling a buffer. It returns a
 *		pointer to the buffer which is NULL on error, and the size of the
 *		buffer in retbuflen. The pointer may subsequently be used as an
 *		argument to the function free(3). It is the reverse of PQescapeBytea.
 *
 *		The following transformations are reversed:
 *		'\0' == ASCII  0 == \000
 *		'\'' == ASCII 39 == \'
 *		'\\' == ASCII 92 == \\
 *
 *		States:
 *		0	normal		0->1->2->3->4
 *		1	\			   1->5
 *		2	\0			   1->6
 *		3	\00
 *		4	\000
 *		5	\'
 *		6	\\
 */
static unsigned char * php_pgsql_unescape_bytea(unsigned char *strtext, size_t *retbuflen)
{
	size_t     buflen;
	unsigned char *buffer,
			   *sp,
			   *bp;
	unsigned int state = 0;

	if (strtext == NULL)
		return NULL;
	buflen = strlen(strtext);	/* will shrink, also we discover if
								 * strtext */
	buffer = (unsigned char *) emalloc(buflen);	/* isn't NULL terminated */
	for (bp = buffer, sp = strtext; *sp != '\0'; bp++, sp++)
	{
"
752,178488,,Remote,Not required,,CVE-2015-3412,https://www.cvedetails.com/cve/CVE-2015-3412/,CWE-254,Low,Partial,,,2016-05-16,5.0,"PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read arbitrary files via crafted input to an application that calls the stream_resolve_include_path function in ext/standard/streamsfuncs.c, as demonstrated by a filename\0.extension attack that bypasses an intended configuration in which client users may read files with only one specific extension.",2019-04-22,Bypass,1,https://git.php.net/?p=php-src.git;a=commit;h=4435b9142ff9813845d5c97ab29a5d637bedb257,4435b9142ff9813845d5c97ab29a5d637bedb257,,1,,,"PHP_FUNCTION(readlink)
{
	char *link;
	int link_len;
        char buff[MAXPATHLEN];
        int ret;
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &link, &link_len) == FAILURE) {
                return;
        }
	if (php_check_open_basedir(link TSRMLS_CC)) {
		RETURN_FALSE;
	}

	ret = php_sys_readlink(link, buff, MAXPATHLEN-1);

	if (ret == -1) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		RETURN_FALSE;
	}
	/* Append NULL to the end of the string */
	buff[ret] = '\0';

	RETURN_STRING(buff, 1);
}
","PHP_FUNCTION(readlink)
{
	char *link;
	int link_len;
        char buff[MAXPATHLEN];
        int ret;
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &link, &link_len) == FAILURE) {
                return;
        }
	if (php_check_open_basedir(link TSRMLS_CC)) {
		RETURN_FALSE;
	}

	ret = php_sys_readlink(link, buff, MAXPATHLEN-1);

	if (ret == -1) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		RETURN_FALSE;
	}
	/* Append NULL to the end of the string */
	buff[ret] = '\0';

	RETURN_STRING(buff, 1);
}
",C,"       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &link, &link_len) == FAILURE) {
","       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &link, &link_len) == FAILURE) {
",9faaee66fa493372c7340b1ab05f8fd115131a42,"@@ -59,7 +59,7 @@ PHP_FUNCTION(readlink)
        char buff[MAXPATHLEN];
        int ret;
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &link, &link_len) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &link, &link_len) == FAILURE) {
                return;
        }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/standard/link.c;h=686dd3e306b796af1c1894ef446e8cabfb4a2a10;hb=4435b9142ff9813845d5c97ab29a5d637bedb257,https://git.php.net/?p=php-src.git;a=blob;f=ext/standard/link.c;h=c57484e766f3c2825ef2ab8999d077b5bfee2fab,1,"PHP_FUNCTION(readlink)
{
	char *link;
	int link_len;
        char buff[MAXPATHLEN];
        int ret;
 
//flaw_line_below:
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &link, &link_len) == FAILURE) {
//fix_flaw_line_below:
//       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &link, &link_len) == FAILURE) {
                return;
        }
	if (php_check_open_basedir(link TSRMLS_CC)) {
		RETURN_FALSE;
	}

	ret = php_sys_readlink(link, buff, MAXPATHLEN-1);

	if (ret == -1) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		RETURN_FALSE;
	}
	/* Append NULL to the end of the string */
	buff[ret] = '\0';

	RETURN_STRING(buff, 1);
}
"
753,178489,,Remote,Not required,,CVE-2015-3412,https://www.cvedetails.com/cve/CVE-2015-3412/,CWE-254,Low,Partial,,,2016-05-16,5.0,"PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read arbitrary files via crafted input to an application that calls the stream_resolve_include_path function in ext/standard/streamsfuncs.c, as demonstrated by a filename\0.extension attack that bypasses an intended configuration in which client users may read files with only one specific extension.",2019-04-22,Bypass,1,https://git.php.net/?p=php-src.git;a=commit;h=4435b9142ff9813845d5c97ab29a5d637bedb257,4435b9142ff9813845d5c97ab29a5d637bedb257,,1,,,"PHP_FUNCTION(stream_resolve_include_path)
{
        char *filename, *resolved_path;
        int filename_len;
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &filename, &filename_len) == FAILURE) {
                return;
        }
	resolved_path = zend_resolve_path(filename, filename_len TSRMLS_CC);

	if (resolved_path) {
		RETURN_STRING(resolved_path, 0);
	}
	RETURN_FALSE;
}
","PHP_FUNCTION(stream_resolve_include_path)
{
        char *filename, *resolved_path;
        int filename_len;
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &filename, &filename_len) == FAILURE) {
                return;
        }
	resolved_path = zend_resolve_path(filename, filename_len TSRMLS_CC);

	if (resolved_path) {
		RETURN_STRING(resolved_path, 0);
	}
	RETURN_FALSE;
}
",C,"       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &filename, &filename_len) == FAILURE) {
","       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &filename, &filename_len) == FAILURE) {
",9faaee66fa493372c7340b1ab05f8fd115131a42,"@@ -1549,7 +1549,7 @@ PHP_FUNCTION(stream_resolve_include_path)
        char *filename, *resolved_path;
        int filename_len;
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &filename, &filename_len) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &filename, &filename_len) == FAILURE) {
                return;
        }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/standard/streamsfuncs.c;h=b8f15e32c2f56275d5c23f1cf8864c2d4dcc2b13;hb=4435b9142ff9813845d5c97ab29a5d637bedb257,https://git.php.net/?p=php-src.git;a=blob;f=ext/standard/streamsfuncs.c;h=b1b318044ea5f0b16a2d36346c6225ae188ed65c,1,"PHP_FUNCTION(stream_resolve_include_path)
{
        char *filename, *resolved_path;
        int filename_len;
 
//flaw_line_below:
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &filename, &filename_len) == FAILURE) {
//fix_flaw_line_below:
//       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &filename, &filename_len) == FAILURE) {
                return;
        }
	resolved_path = zend_resolve_path(filename, filename_len TSRMLS_CC);

	if (resolved_path) {
		RETURN_STRING(resolved_path, 0);
	}
	RETURN_FALSE;
}
"
754,178490,,Remote,Not required,,CVE-2015-3412,https://www.cvedetails.com/cve/CVE-2015-3412/,CWE-254,Low,Partial,,,2016-05-16,5.0,"PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read arbitrary files via crafted input to an application that calls the stream_resolve_include_path function in ext/standard/streamsfuncs.c, as demonstrated by a filename\0.extension attack that bypasses an intended configuration in which client users may read files with only one specific extension.",2019-04-22,Bypass,1,https://git.php.net/?p=php-src.git;a=commit;h=4435b9142ff9813845d5c97ab29a5d637bedb257,4435b9142ff9813845d5c97ab29a5d637bedb257,,1,,," static PHP_FUNCTION(xmlwriter_open_uri)
 {
	char *valid_file = NULL;
	xmlwriter_object *intern;
	xmlTextWriterPtr ptr;
	char *source;
	char resolved_path[MAXPATHLEN + 1];
	int source_len;

#ifdef ZEND_ENGINE_2
	zval *this = getThis();
	ze_xmlwriter_object *ze_obj = NULL;
#endif

#ifndef ZEND_ENGINE_2
	xmlOutputBufferPtr out_buffer;
        void *ioctx;
 #endif
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &source, &source_len) == FAILURE) {
                return;
        }
#ifdef ZEND_ENGINE_2
	if (this) {
		/* We do not use XMLWRITER_FROM_OBJECT, xmlwriter init function here */
		ze_obj = (ze_xmlwriter_object*) zend_object_store_get_object(this TSRMLS_CC); 
	}
#endif

	if (source_len == 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty string as source"");
		RETURN_FALSE;
	}

	valid_file = _xmlwriter_get_valid_file_path(source, resolved_path, MAXPATHLEN TSRMLS_CC);
	if (!valid_file) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to resolve file path"");
		RETURN_FALSE;
	}

	/* TODO: Fix either the PHP stream or libxml APIs: it can then detect when a given 
		 path is valid and not report out of memory error. Once it is done, remove the
		 directory check in _xmlwriter_get_valid_file_path */
#ifndef ZEND_ENGINE_2
	ioctx = php_xmlwriter_streams_IO_open_write_wrapper(valid_file TSRMLS_CC);
	if (ioctx == NULL) {
		RETURN_FALSE;
	}

	out_buffer = xmlOutputBufferCreateIO(php_xmlwriter_streams_IO_write, 
		php_xmlwriter_streams_IO_close, ioctx, NULL);

	if (out_buffer == NULL) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to create output buffer"");
		RETURN_FALSE;
	}
	ptr = xmlNewTextWriter(out_buffer);
#else
	ptr = xmlNewTextWriterFilename(valid_file, 0);
#endif

	if (!ptr) {
		RETURN_FALSE;
	}

	intern = emalloc(sizeof(xmlwriter_object));
	intern->ptr = ptr;
	intern->output = NULL;
#ifndef ZEND_ENGINE_2
	intern->uri_output = out_buffer;
#else
	if (this) {
		if (ze_obj->xmlwriter_ptr) {
			xmlwriter_free_resource_ptr(ze_obj->xmlwriter_ptr TSRMLS_CC);
		}
		ze_obj->xmlwriter_ptr = intern;
		RETURN_TRUE;
	} else
#endif
	{
		ZEND_REGISTER_RESOURCE(return_value,intern,le_xmlwriter);
	}
}
"," static PHP_FUNCTION(xmlwriter_open_uri)
 {
	char *valid_file = NULL;
	xmlwriter_object *intern;
	xmlTextWriterPtr ptr;
	char *source;
	char resolved_path[MAXPATHLEN + 1];
	int source_len;

#ifdef ZEND_ENGINE_2
	zval *this = getThis();
	ze_xmlwriter_object *ze_obj = NULL;
#endif

#ifndef ZEND_ENGINE_2
	xmlOutputBufferPtr out_buffer;
        void *ioctx;
 #endif
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &source, &source_len) == FAILURE) {
                return;
        }
#ifdef ZEND_ENGINE_2
	if (this) {
		/* We do not use XMLWRITER_FROM_OBJECT, xmlwriter init function here */
		ze_obj = (ze_xmlwriter_object*) zend_object_store_get_object(this TSRMLS_CC); 
	}
#endif

	if (source_len == 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty string as source"");
		RETURN_FALSE;
	}

	valid_file = _xmlwriter_get_valid_file_path(source, resolved_path, MAXPATHLEN TSRMLS_CC);
	if (!valid_file) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to resolve file path"");
		RETURN_FALSE;
	}

	/* TODO: Fix either the PHP stream or libxml APIs: it can then detect when a given 
		 path is valid and not report out of memory error. Once it is done, remove the
		 directory check in _xmlwriter_get_valid_file_path */
#ifndef ZEND_ENGINE_2
	ioctx = php_xmlwriter_streams_IO_open_write_wrapper(valid_file TSRMLS_CC);
	if (ioctx == NULL) {
		RETURN_FALSE;
	}

	out_buffer = xmlOutputBufferCreateIO(php_xmlwriter_streams_IO_write, 
		php_xmlwriter_streams_IO_close, ioctx, NULL);

	if (out_buffer == NULL) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to create output buffer"");
		RETURN_FALSE;
	}
	ptr = xmlNewTextWriter(out_buffer);
#else
	ptr = xmlNewTextWriterFilename(valid_file, 0);
#endif

	if (!ptr) {
		RETURN_FALSE;
	}

	intern = emalloc(sizeof(xmlwriter_object));
	intern->ptr = ptr;
	intern->output = NULL;
#ifndef ZEND_ENGINE_2
	intern->uri_output = out_buffer;
#else
	if (this) {
		if (ze_obj->xmlwriter_ptr) {
			xmlwriter_free_resource_ptr(ze_obj->xmlwriter_ptr TSRMLS_CC);
		}
		ze_obj->xmlwriter_ptr = intern;
		RETURN_TRUE;
	} else
#endif
	{
		ZEND_REGISTER_RESOURCE(return_value,intern,le_xmlwriter);
	}
}
",C,"       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &source, &source_len) == FAILURE) {
","       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &source, &source_len) == FAILURE) {
",9faaee66fa493372c7340b1ab05f8fd115131a42,"@@ -1738,7 +1738,7 @@ static PHP_FUNCTION(xmlwriter_write_dtd_entity)
 /* }}} */
 #endif
 
-/* {{{ proto resource xmlwriter_open_uri(resource xmlwriter, string source)
+/* {{{ proto resource xmlwriter_open_uri(string source)
 Create new xmlwriter using source uri for output */
 static PHP_FUNCTION(xmlwriter_open_uri)
 {
@@ -1759,7 +1759,7 @@ static PHP_FUNCTION(xmlwriter_open_uri)
        void *ioctx;
 #endif
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &source, &source_len) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &source, &source_len) == FAILURE) {
                return;
        }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/xmlwriter/php_xmlwriter.c;h=acb87541d825add8288b761ce9ecebbe532ffed6;hb=4435b9142ff9813845d5c97ab29a5d637bedb257,https://git.php.net/?p=php-src.git;a=blob;f=ext/xmlwriter/php_xmlwriter.c;h=7bc35dabc41a9671ab5e132890f6b3cbd8fcb29a,1," static PHP_FUNCTION(xmlwriter_open_uri)
 {
	char *valid_file = NULL;
	xmlwriter_object *intern;
	xmlTextWriterPtr ptr;
	char *source;
	char resolved_path[MAXPATHLEN + 1];
	int source_len;

#ifdef ZEND_ENGINE_2
	zval *this = getThis();
	ze_xmlwriter_object *ze_obj = NULL;
#endif

#ifndef ZEND_ENGINE_2
	xmlOutputBufferPtr out_buffer;
        void *ioctx;
 #endif
 
//flaw_line_below:
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &source, &source_len) == FAILURE) {
//fix_flaw_line_below:
//       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &source, &source_len) == FAILURE) {
                return;
        }
#ifdef ZEND_ENGINE_2
	if (this) {
		/* We do not use XMLWRITER_FROM_OBJECT, xmlwriter init function here */
		ze_obj = (ze_xmlwriter_object*) zend_object_store_get_object(this TSRMLS_CC); 
	}
#endif

	if (source_len == 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty string as source"");
		RETURN_FALSE;
	}

	valid_file = _xmlwriter_get_valid_file_path(source, resolved_path, MAXPATHLEN TSRMLS_CC);
	if (!valid_file) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to resolve file path"");
		RETURN_FALSE;
	}

	/* TODO: Fix either the PHP stream or libxml APIs: it can then detect when a given 
		 path is valid and not report out of memory error. Once it is done, remove the
		 directory check in _xmlwriter_get_valid_file_path */
#ifndef ZEND_ENGINE_2
	ioctx = php_xmlwriter_streams_IO_open_write_wrapper(valid_file TSRMLS_CC);
	if (ioctx == NULL) {
		RETURN_FALSE;
	}

	out_buffer = xmlOutputBufferCreateIO(php_xmlwriter_streams_IO_write, 
		php_xmlwriter_streams_IO_close, ioctx, NULL);

	if (out_buffer == NULL) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to create output buffer"");
		RETURN_FALSE;
	}
	ptr = xmlNewTextWriter(out_buffer);
#else
	ptr = xmlNewTextWriterFilename(valid_file, 0);
#endif

	if (!ptr) {
		RETURN_FALSE;
	}

	intern = emalloc(sizeof(xmlwriter_object));
	intern->ptr = ptr;
	intern->output = NULL;
#ifndef ZEND_ENGINE_2
	intern->uri_output = out_buffer;
#else
	if (this) {
		if (ze_obj->xmlwriter_ptr) {
			xmlwriter_free_resource_ptr(ze_obj->xmlwriter_ptr TSRMLS_CC);
		}
		ze_obj->xmlwriter_ptr = intern;
		RETURN_TRUE;
	} else
#endif
	{
		ZEND_REGISTER_RESOURCE(return_value,intern,le_xmlwriter);
	}
}
"
755,178491,,Remote,Not required,,CVE-2015-3412,https://www.cvedetails.com/cve/CVE-2015-3412/,CWE-254,Low,Partial,,,2016-05-16,5.0,"PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read arbitrary files via crafted input to an application that calls the stream_resolve_include_path function in ext/standard/streamsfuncs.c, as demonstrated by a filename\0.extension attack that bypasses an intended configuration in which client users may read files with only one specific extension.",2019-04-22,Bypass,1,https://git.php.net/?p=php-src.git;a=commit;h=4435b9142ff9813845d5c97ab29a5d637bedb257,4435b9142ff9813845d5c97ab29a5d637bedb257,,1,,,"static PHP_FUNCTION(gzopen)
{
	char *filename;
	char *mode;
	int filename_len, mode_len;
	int flags = REPORT_ERRORS;
        php_stream *stream;
        long use_include_path = 0;
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ps|l"", &filename, &filename_len, &mode, &mode_len, &use_include_path) == FAILURE) {
                return;
        }
 
	if (use_include_path) {
		flags |= USE_PATH;
	}

	stream = php_stream_gzopen(NULL, filename, mode, flags, NULL, NULL STREAMS_CC TSRMLS_CC);

	if (!stream) {
		RETURN_FALSE;
	}
	php_stream_to_zval(stream, return_value);
}
","static PHP_FUNCTION(gzopen)
{
	char *filename;
	char *mode;
	int filename_len, mode_len;
	int flags = REPORT_ERRORS;
        php_stream *stream;
        long use_include_path = 0;
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &filename, &filename_len, &mode, &mode_len, &use_include_path) == FAILURE) {
                return;
        }
 
	if (use_include_path) {
		flags |= USE_PATH;
	}

	stream = php_stream_gzopen(NULL, filename, mode, flags, NULL, NULL STREAMS_CC TSRMLS_CC);

	if (!stream) {
		RETURN_FALSE;
	}
	php_stream_to_zval(stream, return_value);
}
",C,"       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ps|l"", &filename, &filename_len, &mode, &mode_len, &use_include_path) == FAILURE) {
","       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &filename, &filename_len, &mode, &mode_len, &use_include_path) == FAILURE) {
",9faaee66fa493372c7340b1ab05f8fd115131a42,"@@ -581,7 +581,7 @@ static PHP_FUNCTION(gzopen)
        php_stream *stream;
        long use_include_path = 0;
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &filename, &filename_len, &mode, &mode_len, &use_include_path) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ps|l"", &filename, &filename_len, &mode, &mode_len, &use_include_path) == FAILURE) {
                return;
        }
 
@@ -609,7 +609,7 @@ static PHP_FUNCTION(readgzfile)
        int size;
        long use_include_path = 0;
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|l"", &filename, &filename_len, &use_include_path) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|l"", &filename, &filename_len, &use_include_path) == FAILURE) {
                return;
        }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/zlib/zlib.c;h=431dfde54723e86aae5df325b8922862313ad245;hb=4435b9142ff9813845d5c97ab29a5d637bedb257,https://git.php.net/?p=php-src.git;a=blob;f=ext/zlib/zlib.c;h=705fb5dd5f6d95b9ced2619417cc10603672fed1,1,"static PHP_FUNCTION(gzopen)
{
	char *filename;
	char *mode;
	int filename_len, mode_len;
	int flags = REPORT_ERRORS;
        php_stream *stream;
        long use_include_path = 0;
 
//flaw_line_below:
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &filename, &filename_len, &mode, &mode_len, &use_include_path) == FAILURE) {
//fix_flaw_line_below:
//       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ps|l"", &filename, &filename_len, &mode, &mode_len, &use_include_path) == FAILURE) {
                return;
        }
 
	if (use_include_path) {
		flags |= USE_PATH;
	}

	stream = php_stream_gzopen(NULL, filename, mode, flags, NULL, NULL STREAMS_CC TSRMLS_CC);

	if (!stream) {
		RETURN_FALSE;
	}
	php_stream_to_zval(stream, return_value);
}
"
756,178492,,Remote,Not required,,CVE-2015-3412,https://www.cvedetails.com/cve/CVE-2015-3412/,CWE-254,Low,Partial,,,2016-05-16,5.0,"PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read arbitrary files via crafted input to an application that calls the stream_resolve_include_path function in ext/standard/streamsfuncs.c, as demonstrated by a filename\0.extension attack that bypasses an intended configuration in which client users may read files with only one specific extension.",2019-04-22,Bypass,1,https://git.php.net/?p=php-src.git;a=commit;h=4435b9142ff9813845d5c97ab29a5d637bedb257,4435b9142ff9813845d5c97ab29a5d637bedb257,,1,,,"static PHP_FUNCTION(readgzfile)
{
	char *filename;
	int filename_len;
	int flags = REPORT_ERRORS;
	php_stream *stream;
        int size;
        long use_include_path = 0;
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|l"", &filename, &filename_len, &use_include_path) == FAILURE) {
                return;
        }
	if (use_include_path) {
		flags |= USE_PATH;
	}

	stream = php_stream_gzopen(NULL, filename, ""rb"", flags, NULL, NULL STREAMS_CC TSRMLS_CC);

	if (!stream) {
		RETURN_FALSE;
	}
	size = php_stream_passthru(stream);
	php_stream_close(stream);
	RETURN_LONG(size);
}
","static PHP_FUNCTION(readgzfile)
{
	char *filename;
	int filename_len;
	int flags = REPORT_ERRORS;
	php_stream *stream;
        int size;
        long use_include_path = 0;
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|l"", &filename, &filename_len, &use_include_path) == FAILURE) {
                return;
        }
	if (use_include_path) {
		flags |= USE_PATH;
	}

	stream = php_stream_gzopen(NULL, filename, ""rb"", flags, NULL, NULL STREAMS_CC TSRMLS_CC);

	if (!stream) {
		RETURN_FALSE;
	}
	size = php_stream_passthru(stream);
	php_stream_close(stream);
	RETURN_LONG(size);
}
",C,"       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|l"", &filename, &filename_len, &use_include_path) == FAILURE) {
","       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|l"", &filename, &filename_len, &use_include_path) == FAILURE) {
",9faaee66fa493372c7340b1ab05f8fd115131a42,"@@ -581,7 +581,7 @@ static PHP_FUNCTION(gzopen)
        php_stream *stream;
        long use_include_path = 0;
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &filename, &filename_len, &mode, &mode_len, &use_include_path) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ps|l"", &filename, &filename_len, &mode, &mode_len, &use_include_path) == FAILURE) {
                return;
        }
 
@@ -609,7 +609,7 @@ static PHP_FUNCTION(readgzfile)
        int size;
        long use_include_path = 0;
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|l"", &filename, &filename_len, &use_include_path) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|l"", &filename, &filename_len, &use_include_path) == FAILURE) {
                return;
        }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/zlib/zlib.c;h=431dfde54723e86aae5df325b8922862313ad245;hb=4435b9142ff9813845d5c97ab29a5d637bedb257,https://git.php.net/?p=php-src.git;a=blob;f=ext/zlib/zlib.c;h=705fb5dd5f6d95b9ced2619417cc10603672fed1,1,"static PHP_FUNCTION(readgzfile)
{
	char *filename;
	int filename_len;
	int flags = REPORT_ERRORS;
	php_stream *stream;
        int size;
        long use_include_path = 0;
 
//flaw_line_below:
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|l"", &filename, &filename_len, &use_include_path) == FAILURE) {
//fix_flaw_line_below:
//       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|l"", &filename, &filename_len, &use_include_path) == FAILURE) {
                return;
        }
	if (use_include_path) {
		flags |= USE_PATH;
	}

	stream = php_stream_gzopen(NULL, filename, ""rb"", flags, NULL, NULL STREAMS_CC TSRMLS_CC);

	if (!stream) {
		RETURN_FALSE;
	}
	size = php_stream_passthru(stream);
	php_stream_close(stream);
	RETURN_LONG(size);
}
"
787,178523,,Remote,Not required,Partial,CVE-2016-1908,https://www.cvedetails.com/cve/CVE-2016-1908/,CWE-254,Low,Partial,Partial,,2017-04-11,7.5,"The client in OpenSSH before 7.2 mishandles failed cookie generation for untrusted X11 forwarding and relies on the local X11 server for access-control decisions, which allows remote X11 clients to trigger a fallback and obtain trusted X11 forwarding privileges by leveraging configuration issues on this X11 server, as demonstrated by lack of the SECURITY extension on this X11 server.",2018-09-11,,3,https://anongit.mindrot.org/openssh.git/commit/?id=ed4ce82dbfa8a3a3c8ea6fa0db113c71e234416c,ed4ce82dbfa8a3a3c8ea6fa0db113c71e234416c,,0,,,"client_x11_display_valid(const char *display)
 {
 	size_t i, dlen;
 
	if (display == NULL)
		return 0;

 	dlen = strlen(display);
 	for (i = 0; i < dlen; i++) {
 		if (!isalnum((u_char)display[i]) &&
		}
	}
","client_x11_display_valid(const char *display)
 {
 	size_t i, dlen;
 
 	dlen = strlen(display);
 	for (i = 0; i < dlen; i++) {
 		if (!isalnum((u_char)display[i]) &&
		}
	}
",C,"	if (display == NULL)
		return 0;

",,9a728cc918fad67c8a9a71201088b1e150340ba4,"@@ -1,4 +1,4 @@
-/* $OpenBSD: clientloop.c,v 1.278 2015/12/26 07:46:03 semarie Exp $ */
+/* $OpenBSD: clientloop.c,v 1.279 2016/01/13 23:04:47 djm Exp $ */
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
@@ -288,6 +288,9 @@ client_x11_display_valid(const char *display)
 {
 	size_t i, dlen;
 
+	if (display == NULL)
+		return 0;
+
 	dlen = strlen(display);
 	for (i = 0; i < dlen; i++) {
 		if (!isalnum((u_char)display[i]) &&
@@ -301,34 +304,33 @@ client_x11_display_valid(const char *display)
 
 #define SSH_X11_PROTO		""MIT-MAGIC-COOKIE-1""
 #define X11_TIMEOUT_SLACK	60
-void
+int
 client_x11_get_proto(const char *display, const char *xauth_path,
     u_int trusted, u_int timeout, char **_proto, char **_data)
 {
-	char cmd[1024];
-	char line[512];
-	char xdisplay[512];
+	char cmd[1024], line[512], xdisplay[512];
+	char xauthfile[PATH_MAX], xauthdir[PATH_MAX];
 	static char proto[512], data[512];
 	FILE *f;
-	int got_data = 0, generated = 0, do_unlink = 0, i;
-	char xauthdir[PATH_MAX] = """", xauthfile[PATH_MAX] = """";
+	int got_data = 0, generated = 0, do_unlink = 0, i, r;
 	struct stat st;
 	u_int now, x11_timeout_real;
 
 	*_proto = proto;
 	*_data = data;
-	proto[0] = data[0] = '\0';
+	proto[0] = data[0] = xauthfile[0] = xauthdir[0] = '\0';
 
-	if (xauth_path == NULL ||(stat(xauth_path, &st) == -1)) {
-		debug(""No xauth program."");
-	} else if (!client_x11_display_valid(display)) {
-		logit(""DISPLAY '%s' invalid, falling back to fake xauth data"",
+	if (!client_x11_display_valid(display)) {
+		logit(""DISPLAY \""%s\"" invalid; disabling X11 forwarding"",
 		    display);
-	} else {
-		if (display == NULL) {
-			debug(""x11_get_proto: DISPLAY not set"");
-			return;
-		}
+		return -1;
+	}
+	if (xauth_path != NULL && stat(xauth_path, &st) == -1) {
+		debug(""No xauth program."");
+		xauth_path = NULL;
+	}
+
+	if (xauth_path != NULL) {
 		/*
 		 * Handle FamilyLocal case where $DISPLAY does
 		 * not match an authorization entry.  For this we
@@ -337,43 +339,60 @@ client_x11_get_proto(const char *display, const char *xauth_path,
 		 *      is not perfect.
 		 */
 		if (strncmp(display, ""localhost:"", 10) == 0) {
-			snprintf(xdisplay, sizeof(xdisplay), ""unix:%s"",
-			    display + 10);
+			if ((r = snprintf(xdisplay, sizeof(xdisplay), ""unix:%s"",
+			    display + 10)) < 0 ||
+			    (size_t)r >= sizeof(xdisplay)) {
+				error(""%s: display name too long"", __func__);
+				return -1;
+			}
 			display = xdisplay;
 		}
 		if (trusted == 0) {
-			mktemp_proto(xauthdir, PATH_MAX);
 			/*
+			 * Generate an untrusted X11 auth cookie.
+			 *
 			 * The authentication cookie should briefly outlive
 			 * ssh's willingness to forward X11 connections to
 			 * avoid nasty fail-open behaviour in the X server.
 			 */
+			mktemp_proto(xauthdir, sizeof(xauthdir));
+			if (mkdtemp(xauthdir) == NULL) {
+				error(""%s: mkdtemp: %s"",
+				    __func__, strerror(errno));
+				return -1;
+			}
+			do_unlink = 1;
+			if ((r = snprintf(xauthfile, sizeof(xauthfile),
+			    ""%s/xauthfile"", xauthdir)) < 0 ||
+			    (size_t)r >= sizeof(xauthfile)) {
+				error(""%s: xauthfile path too long"", __func__);
+				unlink(xauthfile);
+				rmdir(xauthdir);
+				return -1;
+			}
+
 			if (timeout >= UINT_MAX - X11_TIMEOUT_SLACK)
 				x11_timeout_real = UINT_MAX;
 			else
 				x11_timeout_real = timeout + X11_TIMEOUT_SLACK;
-			if (mkdtemp(xauthdir) != NULL) {
-				do_unlink = 1;
-				snprintf(xauthfile, PATH_MAX, ""%s/xauthfile"",
-				    xauthdir);
-				snprintf(cmd, sizeof(cmd),
-				    ""%s -f %s generate %s "" SSH_X11_PROTO
-				    "" untrusted timeout %u 2>"" _PATH_DEVNULL,
-				    xauth_path, xauthfile, display,
-				    x11_timeout_real);
-				debug2(""x11_get_proto: %s"", cmd);
-				if (x11_refuse_time == 0) {
-					now = monotime() + 1;
-					if (UINT_MAX - timeout < now)
-						x11_refuse_time = UINT_MAX;
-					else
-						x11_refuse_time = now + timeout;
-					channel_set_x11_refuse_time(
-					    x11_refuse_time);
-				}
-				if (system(cmd) == 0)
-					generated = 1;
+			if ((r = snprintf(cmd, sizeof(cmd),
+			    ""%s -f %s generate %s "" SSH_X11_PROTO
+			    "" untrusted timeout %u 2>"" _PATH_DEVNULL,
+			    xauth_path, xauthfile, display,
+			    x11_timeout_real)) < 0 ||
+			    (size_t)r >= sizeof(cmd))
+				fatal(""%s: cmd too long"", __func__);
+			debug2(""%s: %s"", __func__, cmd);
+			if (x11_refuse_time == 0) {
+				now = monotime() + 1;
+				if (UINT_MAX - timeout < now)
+					x11_refuse_time = UINT_MAX;
+				else
+					x11_refuse_time = now + timeout;
+				channel_set_x11_refuse_time(x11_refuse_time);
 			}
+			if (system(cmd) == 0)
+				generated = 1;
 		}
 
 		/*
@@ -395,9 +414,7 @@ client_x11_get_proto(const char *display, const char *xauth_path,
 				got_data = 1;
 			if (f)
 				pclose(f);
-		} else
-			error(""Warning: untrusted X11 forwarding setup failed: ""
-			    ""xauth key data not generated"");
+		}
 	}
 
 	if (do_unlink) {
@@ -405,6 +422,13 @@ client_x11_get_proto(const char *display, const char *xauth_path,
 		rmdir(xauthdir);
 	}
 
+	/* Don't fall back to fake X11 data for untrusted forwarding */
+	if (!trusted && !got_data) {
+		error(""Warning: untrusted X11 forwarding setup failed: ""
+		    ""xauth key data not generated"");
+		return -1;
+	}
+
 	/*
 	 * If we didn't get authentication data, just make up some
 	 * data.  The forwarding code will check the validity of the
@@ -427,6 +451,8 @@ client_x11_get_proto(const char *display, const char *xauth_path,
 			rnd >>= 8;
 		}
 	}
+
+	return 0;
 }
 
 /*",mindrot,https://anongit.mindrot.org/openssh.git/tree/clientloop.c?id=ed4ce82dbfa8a3a3c8ea6fa0db113c71e234416c,https://anongit.mindrot.org/openssh.git/tree/clientloop.c?id=9a728cc918fad67c8a9a71201088b1e150340ba4,1,"client_x11_display_valid(const char *display)
 {
 	size_t i, dlen;
 
//fix_flaw_line_below:
//	if (display == NULL)
//fix_flaw_line_below:
//		return 0;
//fix_flaw_line_below:
//
 	dlen = strlen(display);
 	for (i = 0; i < dlen; i++) {
 		if (!isalnum((u_char)display[i]) &&
		}
	}
"
788,178524,,Remote,Not required,Partial,CVE-2016-1908,https://www.cvedetails.com/cve/CVE-2016-1908/,CWE-254,Low,Partial,Partial,,2017-04-11,7.5,"The client in OpenSSH before 7.2 mishandles failed cookie generation for untrusted X11 forwarding and relies on the local X11 server for access-control decisions, which allows remote X11 clients to trigger a fallback and obtain trusted X11 forwarding privileges by leveraging configuration issues on this X11 server, as demonstrated by lack of the SECURITY extension on this X11 server.",2018-09-11,,11,https://anongit.mindrot.org/openssh.git/commit/?id=ed4ce82dbfa8a3a3c8ea6fa0db113c71e234416c,ed4ce82dbfa8a3a3c8ea6fa0db113c71e234416c,,9,,,"mux_session_confirm(int id, int success, void *arg)
{
	struct mux_session_confirm_ctx *cctx = arg;
	const char *display;
	Channel *c, *cc;
	int i;
	Buffer reply;

	if (cctx == NULL)
		fatal(""%s: cctx == NULL"", __func__);
	if ((c = channel_by_id(id)) == NULL)
		fatal(""%s: no channel for id %d"", __func__, id);
	if ((cc = channel_by_id(c->ctl_chan)) == NULL)
		fatal(""%s: channel %d lacks control channel %d"", __func__,
		    id, c->ctl_chan);

	if (!success) {
		debug3(""%s: sending failure reply"", __func__);
		/* prepare reply */
		buffer_init(&reply);
		buffer_put_int(&reply, MUX_S_FAILURE);
		buffer_put_int(&reply, cctx->rid);
		buffer_put_cstring(&reply, ""Session open refused by peer"");
		goto done;
	}

	display = getenv(""DISPLAY"");
	if (cctx->want_x_fwd && options.forward_x11 && display != NULL) {
 		char *proto, *data;
 
 		/* Get reasonable local authentication information. */
		if (client_x11_get_proto(display, options.xauth_location,
 		    options.forward_x11_trusted, options.forward_x11_timeout,
		    &proto, &data) == 0) {
			/* Request forwarding with authentication spoofing. */
			debug(""Requesting X11 forwarding with authentication ""
			    ""spoofing."");
			x11_request_forwarding_with_spoofing(id, display, proto,
			    data, 1);
			/* XXX exit_on_forward_failure */
			client_expect_confirm(id, ""X11 forwarding"",
			    CONFIRM_WARN);
		}
 	}
 
 	if (cctx->want_agent_fwd && options.forward_agent) {
		packet_send();
	}

	client_session2_setup(id, cctx->want_tty, cctx->want_subsys,
	    cctx->term, &cctx->tio, c->rfd, &cctx->cmd, cctx->env);

	debug3(""%s: sending success reply"", __func__);
	/* prepare reply */
	buffer_init(&reply);
	buffer_put_int(&reply, MUX_S_SESSION_OPENED);
	buffer_put_int(&reply, cctx->rid);
	buffer_put_int(&reply, c->self);

 done:
	/* Send reply */
	buffer_put_string(&cc->output, buffer_ptr(&reply), buffer_len(&reply));
	buffer_free(&reply);

	if (cc->mux_pause <= 0)
		fatal(""%s: mux_pause %d"", __func__, cc->mux_pause);
	cc->mux_pause = 0; /* start processing messages again */
	c->open_confirm_ctx = NULL;
	buffer_free(&cctx->cmd);
	free(cctx->term);
	if (cctx->env != NULL) {
		for (i = 0; cctx->env[i] != NULL; i++)
			free(cctx->env[i]);
		free(cctx->env);
	}
	free(cctx);
}
","mux_session_confirm(int id, int success, void *arg)
{
	struct mux_session_confirm_ctx *cctx = arg;
	const char *display;
	Channel *c, *cc;
	int i;
	Buffer reply;

	if (cctx == NULL)
		fatal(""%s: cctx == NULL"", __func__);
	if ((c = channel_by_id(id)) == NULL)
		fatal(""%s: no channel for id %d"", __func__, id);
	if ((cc = channel_by_id(c->ctl_chan)) == NULL)
		fatal(""%s: channel %d lacks control channel %d"", __func__,
		    id, c->ctl_chan);

	if (!success) {
		debug3(""%s: sending failure reply"", __func__);
		/* prepare reply */
		buffer_init(&reply);
		buffer_put_int(&reply, MUX_S_FAILURE);
		buffer_put_int(&reply, cctx->rid);
		buffer_put_cstring(&reply, ""Session open refused by peer"");
		goto done;
	}

	display = getenv(""DISPLAY"");
	if (cctx->want_x_fwd && options.forward_x11 && display != NULL) {
 		char *proto, *data;
 
 		/* Get reasonable local authentication information. */
		client_x11_get_proto(display, options.xauth_location,
 		    options.forward_x11_trusted, options.forward_x11_timeout,
		    &proto, &data);
		/* Request forwarding with authentication spoofing. */
		debug(""Requesting X11 forwarding with authentication ""
		    ""spoofing."");
		x11_request_forwarding_with_spoofing(id, display, proto,
		    data, 1);
		client_expect_confirm(id, ""X11 forwarding"", CONFIRM_WARN);
		/* XXX exit_on_forward_failure */
 	}
 
 	if (cctx->want_agent_fwd && options.forward_agent) {
		packet_send();
	}

	client_session2_setup(id, cctx->want_tty, cctx->want_subsys,
	    cctx->term, &cctx->tio, c->rfd, &cctx->cmd, cctx->env);

	debug3(""%s: sending success reply"", __func__);
	/* prepare reply */
	buffer_init(&reply);
	buffer_put_int(&reply, MUX_S_SESSION_OPENED);
	buffer_put_int(&reply, cctx->rid);
	buffer_put_int(&reply, c->self);

 done:
	/* Send reply */
	buffer_put_string(&cc->output, buffer_ptr(&reply), buffer_len(&reply));
	buffer_free(&reply);

	if (cc->mux_pause <= 0)
		fatal(""%s: mux_pause %d"", __func__, cc->mux_pause);
	cc->mux_pause = 0; /* start processing messages again */
	c->open_confirm_ctx = NULL;
	buffer_free(&cctx->cmd);
	free(cctx->term);
	if (cctx->env != NULL) {
		for (i = 0; cctx->env[i] != NULL; i++)
			free(cctx->env[i]);
		free(cctx->env);
	}
	free(cctx);
}
",C,"		if (client_x11_get_proto(display, options.xauth_location,
		    &proto, &data) == 0) {
			/* Request forwarding with authentication spoofing. */
			debug(""Requesting X11 forwarding with authentication ""
			    ""spoofing."");
			x11_request_forwarding_with_spoofing(id, display, proto,
			    data, 1);
			/* XXX exit_on_forward_failure */
			client_expect_confirm(id, ""X11 forwarding"",
			    CONFIRM_WARN);
		}
","		client_x11_get_proto(display, options.xauth_location,
		    &proto, &data);
		/* Request forwarding with authentication spoofing. */
		debug(""Requesting X11 forwarding with authentication ""
		    ""spoofing."");
		x11_request_forwarding_with_spoofing(id, display, proto,
		    data, 1);
		client_expect_confirm(id, ""X11 forwarding"", CONFIRM_WARN);
		/* XXX exit_on_forward_failure */
",9a728cc918fad67c8a9a71201088b1e150340ba4,"@@ -1,4 +1,4 @@
-/* $OpenBSD: mux.c,v 1.57 2015/12/26 07:46:03 semarie Exp $ */
+/* $OpenBSD: mux.c,v 1.58 2016/01/13 23:04:47 djm Exp $ */
 /*
  * Copyright (c) 2002-2008 Damien Miller <djm@openbsd.org>
  *
@@ -1354,16 +1354,18 @@ mux_session_confirm(int id, int success, void *arg)
 		char *proto, *data;
 
 		/* Get reasonable local authentication information. */
-		client_x11_get_proto(display, options.xauth_location,
+		if (client_x11_get_proto(display, options.xauth_location,
 		    options.forward_x11_trusted, options.forward_x11_timeout,
-		    &proto, &data);
-		/* Request forwarding with authentication spoofing. */
-		debug(""Requesting X11 forwarding with authentication ""
-		    ""spoofing."");
-		x11_request_forwarding_with_spoofing(id, display, proto,
-		    data, 1);
-		client_expect_confirm(id, ""X11 forwarding"", CONFIRM_WARN);
-		/* XXX exit_on_forward_failure */
+		    &proto, &data) == 0) {
+			/* Request forwarding with authentication spoofing. */
+			debug(""Requesting X11 forwarding with authentication ""
+			    ""spoofing."");
+			x11_request_forwarding_with_spoofing(id, display, proto,
+			    data, 1);
+			/* XXX exit_on_forward_failure */
+			client_expect_confirm(id, ""X11 forwarding"",
+			    CONFIRM_WARN);
+		}
 	}
 
 	if (cctx->want_agent_fwd && options.forward_agent) {",mindrot,https://anongit.mindrot.org/openssh.git/tree/mux.c?id=ed4ce82dbfa8a3a3c8ea6fa0db113c71e234416c,https://anongit.mindrot.org/openssh.git/tree/mux.c?id=9a728cc918fad67c8a9a71201088b1e150340ba4,1,"mux_session_confirm(int id, int success, void *arg)
{
	struct mux_session_confirm_ctx *cctx = arg;
	const char *display;
	Channel *c, *cc;
	int i;
	Buffer reply;

	if (cctx == NULL)
		fatal(""%s: cctx == NULL"", __func__);
	if ((c = channel_by_id(id)) == NULL)
		fatal(""%s: no channel for id %d"", __func__, id);
	if ((cc = channel_by_id(c->ctl_chan)) == NULL)
		fatal(""%s: channel %d lacks control channel %d"", __func__,
		    id, c->ctl_chan);

	if (!success) {
		debug3(""%s: sending failure reply"", __func__);
		/* prepare reply */
		buffer_init(&reply);
		buffer_put_int(&reply, MUX_S_FAILURE);
		buffer_put_int(&reply, cctx->rid);
		buffer_put_cstring(&reply, ""Session open refused by peer"");
		goto done;
	}

	display = getenv(""DISPLAY"");
	if (cctx->want_x_fwd && options.forward_x11 && display != NULL) {
 		char *proto, *data;
 
 		/* Get reasonable local authentication information. */
//flaw_line_below:
		client_x11_get_proto(display, options.xauth_location,
//fix_flaw_line_below:
//		if (client_x11_get_proto(display, options.xauth_location,
 		    options.forward_x11_trusted, options.forward_x11_timeout,
//flaw_line_below:
		    &proto, &data);
//flaw_line_below:
		/* Request forwarding with authentication spoofing. */
//flaw_line_below:
		debug(""Requesting X11 forwarding with authentication ""
//flaw_line_below:
		    ""spoofing."");
//flaw_line_below:
		x11_request_forwarding_with_spoofing(id, display, proto,
//flaw_line_below:
		    data, 1);
//flaw_line_below:
		client_expect_confirm(id, ""X11 forwarding"", CONFIRM_WARN);
//flaw_line_below:
		/* XXX exit_on_forward_failure */
//fix_flaw_line_below:
//		    &proto, &data) == 0) {
//fix_flaw_line_below:
//			/* Request forwarding with authentication spoofing. */
//fix_flaw_line_below:
//			debug(""Requesting X11 forwarding with authentication ""
//fix_flaw_line_below:
//			    ""spoofing."");
//fix_flaw_line_below:
//			x11_request_forwarding_with_spoofing(id, display, proto,
//fix_flaw_line_below:
//			    data, 1);
//fix_flaw_line_below:
//			/* XXX exit_on_forward_failure */
//fix_flaw_line_below:
//			client_expect_confirm(id, ""X11 forwarding"",
//fix_flaw_line_below:
//			    CONFIRM_WARN);
//fix_flaw_line_below:
//		}
 	}
 
 	if (cctx->want_agent_fwd && options.forward_agent) {
		packet_send();
	}

	client_session2_setup(id, cctx->want_tty, cctx->want_subsys,
	    cctx->term, &cctx->tio, c->rfd, &cctx->cmd, cctx->env);

	debug3(""%s: sending success reply"", __func__);
	/* prepare reply */
	buffer_init(&reply);
	buffer_put_int(&reply, MUX_S_SESSION_OPENED);
	buffer_put_int(&reply, cctx->rid);
	buffer_put_int(&reply, c->self);

 done:
	/* Send reply */
	buffer_put_string(&cc->output, buffer_ptr(&reply), buffer_len(&reply));
	buffer_free(&reply);

	if (cc->mux_pause <= 0)
		fatal(""%s: mux_pause %d"", __func__, cc->mux_pause);
	cc->mux_pause = 0; /* start processing messages again */
	c->open_confirm_ctx = NULL;
	buffer_free(&cctx->cmd);
	free(cctx->term);
	if (cctx->env != NULL) {
		for (i = 0; cctx->env[i] != NULL; i++)
			free(cctx->env[i]);
		free(cctx->env);
	}
	free(cctx);
}
"
789,178525,,Remote,Not required,Partial,CVE-2016-1908,https://www.cvedetails.com/cve/CVE-2016-1908/,CWE-254,Low,Partial,Partial,,2017-04-11,7.5,"The client in OpenSSH before 7.2 mishandles failed cookie generation for untrusted X11 forwarding and relies on the local X11 server for access-control decisions, which allows remote X11 clients to trigger a fallback and obtain trusted X11 forwarding privileges by leveraging configuration issues on this X11 server, as demonstrated by lack of the SECURITY extension on this X11 server.",2018-09-11,,4,https://anongit.mindrot.org/openssh.git/commit/?id=ed4ce82dbfa8a3a3c8ea6fa0db113c71e234416c,ed4ce82dbfa8a3a3c8ea6fa0db113c71e234416c,,7,,,"ssh_session(void)
{
	int type;
	int interactive = 0;
	int have_tty = 0;
 	struct winsize ws;
 	char *cp;
 	const char *display;
	char *proto = NULL, *data = NULL;
 
 	/* Enable compression if requested. */
 	if (options.compression) {
		    options.compression_level);

		if (options.compression_level < 1 ||
		    options.compression_level > 9)
			fatal(""Compression level must be from 1 (fast) to ""
			    ""9 (slow, best)."");

		/* Send the request. */
		packet_start(SSH_CMSG_REQUEST_COMPRESSION);
		packet_put_int(options.compression_level);
		packet_send();
		packet_write_wait();
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS)
			packet_start_compression(options.compression_level);
		else if (type == SSH_SMSG_FAILURE)
			logit(""Warning: Remote host refused compression."");
		else
			packet_disconnect(""Protocol error waiting for ""
			    ""compression response."");
	}
	/* Allocate a pseudo tty if appropriate. */
	if (tty_flag) {
		debug(""Requesting pty."");

		/* Start the packet. */
		packet_start(SSH_CMSG_REQUEST_PTY);

		/* Store TERM in the packet.  There is no limit on the
		   length of the string. */
		cp = getenv(""TERM"");
		if (!cp)
			cp = """";
		packet_put_cstring(cp);

		/* Store window size in the packet. */
		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)
			memset(&ws, 0, sizeof(ws));
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);

		/* Store tty modes in the packet. */
		tty_make_modes(fileno(stdin), NULL);

		/* Send the packet, and wait for it to leave. */
		packet_send();
		packet_write_wait();

		/* Read response from the server. */
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS) {
			interactive = 1;
			have_tty = 1;
		} else if (type == SSH_SMSG_FAILURE)
			logit(""Warning: Remote host failed or refused to ""
			    ""allocate a pseudo tty."");
		else
			packet_disconnect(""Protocol error waiting for pty ""
			    ""request response."");
	}
	/* Request X11 forwarding if enabled and DISPLAY is set. */
	display = getenv(""DISPLAY"");
 	display = getenv(""DISPLAY"");
 	if (display == NULL && options.forward_x11)
 		debug(""X11 forwarding requested but DISPLAY not set"");
	if (options.forward_x11 && client_x11_get_proto(display,
	    options.xauth_location, options.forward_x11_trusted,
	    options.forward_x11_timeout, &proto, &data) == 0) {
 		/* Request forwarding with authentication spoofing. */
 		debug(""Requesting X11 forwarding with authentication ""
 		    ""spoofing."");
		/* Request forwarding with authentication spoofing. */
		debug(""Requesting X11 forwarding with authentication ""
		    ""spoofing."");
		x11_request_forwarding_with_spoofing(0, display, proto,
		    data, 0);
		/* Read response from the server. */
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS) {
			interactive = 1;
		} else if (type == SSH_SMSG_FAILURE) {
			logit(""Warning: Remote host denied X11 forwarding."");
		} else {
			packet_disconnect(""Protocol error waiting for X11 ""
			    ""forwarding"");
		}
	}
	/* Tell the packet module whether this is an interactive session. */
	packet_set_interactive(interactive,
	    options.ip_qos_interactive, options.ip_qos_bulk);

	/* Request authentication agent forwarding if appropriate. */
	check_agent_present();

	if (options.forward_agent) {
		debug(""Requesting authentication agent forwarding."");
		auth_request_forwarding();

		/* Read response from the server. */
		type = packet_read();
		packet_check_eom();
		if (type != SSH_SMSG_SUCCESS)
			logit(""Warning: Remote host denied authentication agent forwarding."");
	}

	/* Initiate port forwardings. */
	ssh_init_stdio_forwarding();
	ssh_init_forwarding();

	/* Execute a local command */
	if (options.local_command != NULL &&
	    options.permit_local_command)
		ssh_local_cmd(options.local_command);

	/*
	 * If requested and we are not interested in replies to remote
	 * forwarding requests, then let ssh continue in the background.
	 */
	if (fork_after_authentication_flag) {
		if (options.exit_on_forward_failure &&
		    options.num_remote_forwards > 0) {
			debug(""deferring postauth fork until remote forward ""
			    ""confirmation received"");
		} else
			fork_postauth();
	}

	/*
	 * If a command was specified on the command line, execute the
	 * command now. Otherwise request the server to start a shell.
	 */
	if (buffer_len(&command) > 0) {
		int len = buffer_len(&command);
		if (len > 900)
			len = 900;
		debug(""Sending command: %.*s"", len,
		    (u_char *)buffer_ptr(&command));
		packet_start(SSH_CMSG_EXEC_CMD);
		packet_put_string(buffer_ptr(&command), buffer_len(&command));
		packet_send();
		packet_write_wait();
	} else {
		debug(""Requesting shell."");
		packet_start(SSH_CMSG_EXEC_SHELL);
		packet_send();
		packet_write_wait();
	}

	/* Enter the interactive session. */
	return client_loop(have_tty, tty_flag ?
	    options.escape_char : SSH_ESCAPECHAR_NONE, 0);
}
","ssh_session(void)
{
	int type;
	int interactive = 0;
	int have_tty = 0;
 	struct winsize ws;
 	char *cp;
 	const char *display;
 
 	/* Enable compression if requested. */
 	if (options.compression) {
		    options.compression_level);

		if (options.compression_level < 1 ||
		    options.compression_level > 9)
			fatal(""Compression level must be from 1 (fast) to ""
			    ""9 (slow, best)."");

		/* Send the request. */
		packet_start(SSH_CMSG_REQUEST_COMPRESSION);
		packet_put_int(options.compression_level);
		packet_send();
		packet_write_wait();
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS)
			packet_start_compression(options.compression_level);
		else if (type == SSH_SMSG_FAILURE)
			logit(""Warning: Remote host refused compression."");
		else
			packet_disconnect(""Protocol error waiting for ""
			    ""compression response."");
	}
	/* Allocate a pseudo tty if appropriate. */
	if (tty_flag) {
		debug(""Requesting pty."");

		/* Start the packet. */
		packet_start(SSH_CMSG_REQUEST_PTY);

		/* Store TERM in the packet.  There is no limit on the
		   length of the string. */
		cp = getenv(""TERM"");
		if (!cp)
			cp = """";
		packet_put_cstring(cp);

		/* Store window size in the packet. */
		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)
			memset(&ws, 0, sizeof(ws));
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);

		/* Store tty modes in the packet. */
		tty_make_modes(fileno(stdin), NULL);

		/* Send the packet, and wait for it to leave. */
		packet_send();
		packet_write_wait();

		/* Read response from the server. */
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS) {
			interactive = 1;
			have_tty = 1;
		} else if (type == SSH_SMSG_FAILURE)
			logit(""Warning: Remote host failed or refused to ""
			    ""allocate a pseudo tty."");
		else
			packet_disconnect(""Protocol error waiting for pty ""
			    ""request response."");
	}
	/* Request X11 forwarding if enabled and DISPLAY is set. */
	display = getenv(""DISPLAY"");
 	display = getenv(""DISPLAY"");
 	if (display == NULL && options.forward_x11)
 		debug(""X11 forwarding requested but DISPLAY not set"");
	if (options.forward_x11 && display != NULL) {
		char *proto, *data;
		/* Get reasonable local authentication information. */
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted,
		    options.forward_x11_timeout,
		    &proto, &data);
 		/* Request forwarding with authentication spoofing. */
 		debug(""Requesting X11 forwarding with authentication ""
 		    ""spoofing."");
		/* Request forwarding with authentication spoofing. */
		debug(""Requesting X11 forwarding with authentication ""
		    ""spoofing."");
		x11_request_forwarding_with_spoofing(0, display, proto,
		    data, 0);
		/* Read response from the server. */
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS) {
			interactive = 1;
		} else if (type == SSH_SMSG_FAILURE) {
			logit(""Warning: Remote host denied X11 forwarding."");
		} else {
			packet_disconnect(""Protocol error waiting for X11 ""
			    ""forwarding"");
		}
	}
	/* Tell the packet module whether this is an interactive session. */
	packet_set_interactive(interactive,
	    options.ip_qos_interactive, options.ip_qos_bulk);

	/* Request authentication agent forwarding if appropriate. */
	check_agent_present();

	if (options.forward_agent) {
		debug(""Requesting authentication agent forwarding."");
		auth_request_forwarding();

		/* Read response from the server. */
		type = packet_read();
		packet_check_eom();
		if (type != SSH_SMSG_SUCCESS)
			logit(""Warning: Remote host denied authentication agent forwarding."");
	}

	/* Initiate port forwardings. */
	ssh_init_stdio_forwarding();
	ssh_init_forwarding();

	/* Execute a local command */
	if (options.local_command != NULL &&
	    options.permit_local_command)
		ssh_local_cmd(options.local_command);

	/*
	 * If requested and we are not interested in replies to remote
	 * forwarding requests, then let ssh continue in the background.
	 */
	if (fork_after_authentication_flag) {
		if (options.exit_on_forward_failure &&
		    options.num_remote_forwards > 0) {
			debug(""deferring postauth fork until remote forward ""
			    ""confirmation received"");
		} else
			fork_postauth();
	}

	/*
	 * If a command was specified on the command line, execute the
	 * command now. Otherwise request the server to start a shell.
	 */
	if (buffer_len(&command) > 0) {
		int len = buffer_len(&command);
		if (len > 900)
			len = 900;
		debug(""Sending command: %.*s"", len,
		    (u_char *)buffer_ptr(&command));
		packet_start(SSH_CMSG_EXEC_CMD);
		packet_put_string(buffer_ptr(&command), buffer_len(&command));
		packet_send();
		packet_write_wait();
	} else {
		debug(""Requesting shell."");
		packet_start(SSH_CMSG_EXEC_SHELL);
		packet_send();
		packet_write_wait();
	}

	/* Enter the interactive session. */
	return client_loop(have_tty, tty_flag ?
	    options.escape_char : SSH_ESCAPECHAR_NONE, 0);
}
",C,"	char *proto = NULL, *data = NULL;
	if (options.forward_x11 && client_x11_get_proto(display,
	    options.xauth_location, options.forward_x11_trusted,
	    options.forward_x11_timeout, &proto, &data) == 0) {
","	if (options.forward_x11 && display != NULL) {
		char *proto, *data;
		/* Get reasonable local authentication information. */
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted,
		    options.forward_x11_timeout,
		    &proto, &data);
",9a728cc918fad67c8a9a71201088b1e150340ba4,"@@ -1,4 +1,4 @@
-/* $OpenBSD: ssh.c,v 1.432 2015/12/11 03:20:09 djm Exp $ */
+/* $OpenBSD: ssh.c,v 1.433 2016/01/13 23:04:47 djm Exp $ */
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
@@ -1626,6 +1626,7 @@ ssh_session(void)
 	struct winsize ws;
 	char *cp;
 	const char *display;
+	char *proto = NULL, *data = NULL;
 
 	/* Enable compression if requested. */
 	if (options.compression) {
@@ -1696,13 +1697,9 @@ ssh_session(void)
 	display = getenv(""DISPLAY"");
 	if (display == NULL && options.forward_x11)
 		debug(""X11 forwarding requested but DISPLAY not set"");
-	if (options.forward_x11 && display != NULL) {
-		char *proto, *data;
-		/* Get reasonable local authentication information. */
-		client_x11_get_proto(display, options.xauth_location,
-		    options.forward_x11_trusted,
-		    options.forward_x11_timeout,
-		    &proto, &data);
+	if (options.forward_x11 && client_x11_get_proto(display,
+	    options.xauth_location, options.forward_x11_trusted,
+	    options.forward_x11_timeout, &proto, &data) == 0) {
 		/* Request forwarding with authentication spoofing. */
 		debug(""Requesting X11 forwarding with authentication ""
 		    ""spoofing."");
@@ -1792,6 +1789,7 @@ ssh_session2_setup(int id, int success, void *arg)
 	extern char **environ;
 	const char *display;
 	int interactive = tty_flag;
+	char *proto = NULL, *data = NULL;
 
 	if (!success)
 		return; /* No need for error message, channels code sens one */
@@ -1799,12 +1797,9 @@ ssh_session2_setup(int id, int success, void *arg)
 	display = getenv(""DISPLAY"");
 	if (display == NULL && options.forward_x11)
 		debug(""X11 forwarding requested but DISPLAY not set"");
-	if (options.forward_x11 && display != NULL) {
-		char *proto, *data;
-		/* Get reasonable local authentication information. */
-		client_x11_get_proto(display, options.xauth_location,
-		    options.forward_x11_trusted,
-		    options.forward_x11_timeout, &proto, &data);
+	if (options.forward_x11 && client_x11_get_proto(display,
+	    options.xauth_location, options.forward_x11_trusted,
+	    options.forward_x11_timeout, &proto, &data) == 0) {
 		/* Request forwarding with authentication spoofing. */
 		debug(""Requesting X11 forwarding with authentication ""
 		    ""spoofing."");",mindrot,https://anongit.mindrot.org/openssh.git/tree/ssh.c?id=ed4ce82dbfa8a3a3c8ea6fa0db113c71e234416c,https://anongit.mindrot.org/openssh.git/tree/ssh.c?id=9a728cc918fad67c8a9a71201088b1e150340ba4,1,"ssh_session(void)
{
	int type;
	int interactive = 0;
	int have_tty = 0;
 	struct winsize ws;
 	char *cp;
 	const char *display;
//fix_flaw_line_below:
//	char *proto = NULL, *data = NULL;
 
 	/* Enable compression if requested. */
 	if (options.compression) {
		    options.compression_level);

		if (options.compression_level < 1 ||
		    options.compression_level > 9)
			fatal(""Compression level must be from 1 (fast) to ""
			    ""9 (slow, best)."");

		/* Send the request. */
		packet_start(SSH_CMSG_REQUEST_COMPRESSION);
		packet_put_int(options.compression_level);
		packet_send();
		packet_write_wait();
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS)
			packet_start_compression(options.compression_level);
		else if (type == SSH_SMSG_FAILURE)
			logit(""Warning: Remote host refused compression."");
		else
			packet_disconnect(""Protocol error waiting for ""
			    ""compression response."");
	}
	/* Allocate a pseudo tty if appropriate. */
	if (tty_flag) {
		debug(""Requesting pty."");

		/* Start the packet. */
		packet_start(SSH_CMSG_REQUEST_PTY);

		/* Store TERM in the packet.  There is no limit on the
		   length of the string. */
		cp = getenv(""TERM"");
		if (!cp)
			cp = """";
		packet_put_cstring(cp);

		/* Store window size in the packet. */
		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)
			memset(&ws, 0, sizeof(ws));
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);

		/* Store tty modes in the packet. */
		tty_make_modes(fileno(stdin), NULL);

		/* Send the packet, and wait for it to leave. */
		packet_send();
		packet_write_wait();

		/* Read response from the server. */
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS) {
			interactive = 1;
			have_tty = 1;
		} else if (type == SSH_SMSG_FAILURE)
			logit(""Warning: Remote host failed or refused to ""
			    ""allocate a pseudo tty."");
		else
			packet_disconnect(""Protocol error waiting for pty ""
			    ""request response."");
	}
	/* Request X11 forwarding if enabled and DISPLAY is set. */
	display = getenv(""DISPLAY"");
 	display = getenv(""DISPLAY"");
 	if (display == NULL && options.forward_x11)
 		debug(""X11 forwarding requested but DISPLAY not set"");
//flaw_line_below:
	if (options.forward_x11 && display != NULL) {
//flaw_line_below:
		char *proto, *data;
//flaw_line_below:
		/* Get reasonable local authentication information. */
//flaw_line_below:
		client_x11_get_proto(display, options.xauth_location,
//flaw_line_below:
		    options.forward_x11_trusted,
//flaw_line_below:
		    options.forward_x11_timeout,
//flaw_line_below:
		    &proto, &data);
//fix_flaw_line_below:
//	if (options.forward_x11 && client_x11_get_proto(display,
//fix_flaw_line_below:
//	    options.xauth_location, options.forward_x11_trusted,
//fix_flaw_line_below:
//	    options.forward_x11_timeout, &proto, &data) == 0) {
 		/* Request forwarding with authentication spoofing. */
 		debug(""Requesting X11 forwarding with authentication ""
 		    ""spoofing."");
		/* Request forwarding with authentication spoofing. */
		debug(""Requesting X11 forwarding with authentication ""
		    ""spoofing."");
		x11_request_forwarding_with_spoofing(0, display, proto,
		    data, 0);
		/* Read response from the server. */
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS) {
			interactive = 1;
		} else if (type == SSH_SMSG_FAILURE) {
			logit(""Warning: Remote host denied X11 forwarding."");
		} else {
			packet_disconnect(""Protocol error waiting for X11 ""
			    ""forwarding"");
		}
	}
	/* Tell the packet module whether this is an interactive session. */
	packet_set_interactive(interactive,
	    options.ip_qos_interactive, options.ip_qos_bulk);

	/* Request authentication agent forwarding if appropriate. */
	check_agent_present();

	if (options.forward_agent) {
		debug(""Requesting authentication agent forwarding."");
		auth_request_forwarding();

		/* Read response from the server. */
		type = packet_read();
		packet_check_eom();
		if (type != SSH_SMSG_SUCCESS)
			logit(""Warning: Remote host denied authentication agent forwarding."");
	}

	/* Initiate port forwardings. */
	ssh_init_stdio_forwarding();
	ssh_init_forwarding();

	/* Execute a local command */
	if (options.local_command != NULL &&
	    options.permit_local_command)
		ssh_local_cmd(options.local_command);

	/*
	 * If requested and we are not interested in replies to remote
	 * forwarding requests, then let ssh continue in the background.
	 */
	if (fork_after_authentication_flag) {
		if (options.exit_on_forward_failure &&
		    options.num_remote_forwards > 0) {
			debug(""deferring postauth fork until remote forward ""
			    ""confirmation received"");
		} else
			fork_postauth();
	}

	/*
	 * If a command was specified on the command line, execute the
	 * command now. Otherwise request the server to start a shell.
	 */
	if (buffer_len(&command) > 0) {
		int len = buffer_len(&command);
		if (len > 900)
			len = 900;
		debug(""Sending command: %.*s"", len,
		    (u_char *)buffer_ptr(&command));
		packet_start(SSH_CMSG_EXEC_CMD);
		packet_put_string(buffer_ptr(&command), buffer_len(&command));
		packet_send();
		packet_write_wait();
	} else {
		debug(""Requesting shell."");
		packet_start(SSH_CMSG_EXEC_SHELL);
		packet_send();
		packet_write_wait();
	}

	/* Enter the interactive session. */
	return client_loop(have_tty, tty_flag ?
	    options.escape_char : SSH_ESCAPECHAR_NONE, 0);
}
"
2071,179807,,Local,Not required,Complete,CVE-2015-2925,https://www.cvedetails.com/cve/CVE-2015-2925/,CWE-254,Medium,Complete,Complete,,2015-11-16,6.9,"The prepend_path function in fs/dcache.c in the Linux kernel before 4.2.4 does not properly handle rename actions inside a bind mount, which allows local users to bypass an intended container protection mechanism by renaming a directory, related to a *double-chroot attack.*",2018-01-04,Bypass ,4,https://github.com/torvalds/linux/commit/397d425dc26da728396e66d392d5dcb8dac30c37,397d425dc26da728396e66d392d5dcb8dac30c37,"vfs: Test for and handle paths that are unreachable from their mnt_root

In rare cases a directory can be renamed out from under a bind mount.
In those cases without special handling it becomes possible to walk up
the directory tree to the root dentry of the filesystem and down
from the root dentry to every other file or directory on the filesystem.

Like division by zero .. from an unconnected path can not be given
a useful semantic as there is no predicting at which path component
the code will realize it is unconnected.  We certainly can not match
the current behavior as the current behavior is a security hole.

Therefore when encounting .. when following an unconnected path
return -ENOENT.

- Add a function path_connected to verify path->dentry is reachable
  from path->mnt.mnt_root.  AKA to validate that rename did not do
  something nasty to the bind mount.

  To avoid races path_connected must be called after following a path
  component to it's next path component.

Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",0,fs/namei.c,"{""sha"": ""29b927938b8ce9c78af99d0f9c8f5af5a294cefd"", ""filename"": ""fs/namei.c"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 2, ""changes"": 27, ""blob_url"": ""https://github.com/torvalds/linux/blob/397d425dc26da728396e66d392d5dcb8dac30c37/fs/namei.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/397d425dc26da728396e66d392d5dcb8dac30c37/fs/namei.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namei.c?ref=397d425dc26da728396e66d392d5dcb8dac30c37"", ""patch"": ""@@ -560,6 +560,24 @@ static int __nd_alloc_stack(struct nameidata *nd)\n \treturn 0;\n }\n \n+/**\n+ * path_connected - Verify that a path->dentry is below path->mnt.mnt_root\n+ * @path: nameidate to verify\n+ *\n+ * Rename can sometimes move a file or directory outside of a bind\n+ * mount, path_connected allows those cases to be detected.\n+ */\n+static bool path_connected(const struct path *path)\n+{\n+\tstruct vfsmount *mnt = path->mnt;\n+\n+\t/* Only bind mounts can have disconnected paths */\n+\tif (mnt->mnt_root == mnt->mnt_sb->s_root)\n+\t\treturn true;\n+\n+\treturn is_subdir(path->dentry, mnt->mnt_root);\n+}\n+\n static inline int nd_alloc_stack(struct nameidata *nd)\n {\n \tif (likely(nd->depth != EMBEDDED_LEVELS))\n@@ -1296,6 +1314,8 @@ static int follow_dotdot_rcu(struct nameidata *nd)\n \t\t\t\treturn -ECHILD;\n \t\t\tnd->path.dentry = parent;\n \t\t\tnd->seq = seq;\n+\t\t\tif (unlikely(!path_connected(&nd->path)))\n+\t\t\t\treturn -ENOENT;\n \t\t\tbreak;\n \t\t} else {\n \t\t\tstruct mount *mnt = real_mount(nd->path.mnt);\n@@ -1396,7 +1416,7 @@ static void follow_mount(struct path *path)\n \t}\n }\n \n-static void follow_dotdot(struct nameidata *nd)\n+static int follow_dotdot(struct nameidata *nd)\n {\n \tif (!nd->root.mnt)\n \t\tset_root(nd);\n@@ -1412,13 +1432,16 @@ static void follow_dotdot(struct nameidata *nd)\n \t\t\t/* rare case of legitimate dget_parent()... */\n \t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n \t\t\tdput(old);\n+\t\t\tif (unlikely(!path_connected(&nd->path)))\n+\t\t\t\treturn -ENOENT;\n \t\t\tbreak;\n \t\t}\n \t\tif (!follow_up(&nd->path))\n \t\t\tbreak;\n \t}\n \tfollow_mount(&nd->path);\n \tnd->inode = nd->path.dentry->d_inode;\n+\treturn 0;\n }\n \n /*\n@@ -1634,7 +1657,7 @@ static inline int handle_dots(struct nameidata *nd, int type)\n \t\tif (nd->flags & LOOKUP_RCU) {\n \t\t\treturn follow_dotdot_rcu(nd);\n \t\t} else\n-\t\t\tfollow_dotdot(nd);\n+\t\t\treturn follow_dotdot(nd);\n \t}\n \treturn 0;\n }""}","static void follow_dotdot(struct nameidata *nd)
static int follow_dotdot(struct nameidata *nd)
 {
 	if (!nd->root.mnt)
 		set_root(nd);

	while(1) {
		struct dentry *old = nd->path.dentry;

		if (nd->path.dentry == nd->root.dentry &&
		    nd->path.mnt == nd->root.mnt) {
			break;
		}
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
 			/* rare case of legitimate dget_parent()... */
 			nd->path.dentry = dget_parent(nd->path.dentry);
 			dput(old);
			if (unlikely(!path_connected(&nd->path)))
				return -ENOENT;
 			break;
 		}
 		if (!follow_up(&nd->path))
 			break;
 	}
 	follow_mount(&nd->path);
 	nd->inode = nd->path.dentry->d_inode;
	return 0;
 }
","static void follow_dotdot(struct nameidata *nd)
 {
 	if (!nd->root.mnt)
 		set_root(nd);

	while(1) {
		struct dentry *old = nd->path.dentry;

		if (nd->path.dentry == nd->root.dentry &&
		    nd->path.mnt == nd->root.mnt) {
			break;
		}
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
 			/* rare case of legitimate dget_parent()... */
 			nd->path.dentry = dget_parent(nd->path.dentry);
 			dput(old);
 			break;
 		}
 		if (!follow_up(&nd->path))
 			break;
 	}
 	follow_mount(&nd->path);
 	nd->inode = nd->path.dentry->d_inode;
 }
",C,"static int follow_dotdot(struct nameidata *nd)
			if (unlikely(!path_connected(&nd->path)))
				return -ENOENT;
	return 0;
",,,"@@ -560,6 +560,24 @@ static int __nd_alloc_stack(struct nameidata *nd)
 	return 0;
 }
 
+/**
+ * path_connected - Verify that a path->dentry is below path->mnt.mnt_root
+ * @path: nameidate to verify
+ *
+ * Rename can sometimes move a file or directory outside of a bind
+ * mount, path_connected allows those cases to be detected.
+ */
+static bool path_connected(const struct path *path)
+{
+	struct vfsmount *mnt = path->mnt;
+
+	/* Only bind mounts can have disconnected paths */
+	if (mnt->mnt_root == mnt->mnt_sb->s_root)
+		return true;
+
+	return is_subdir(path->dentry, mnt->mnt_root);
+}
+
 static inline int nd_alloc_stack(struct nameidata *nd)
 {
 	if (likely(nd->depth != EMBEDDED_LEVELS))
@@ -1296,6 +1314,8 @@ static int follow_dotdot_rcu(struct nameidata *nd)
 				return -ECHILD;
 			nd->path.dentry = parent;
 			nd->seq = seq;
+			if (unlikely(!path_connected(&nd->path)))
+				return -ENOENT;
 			break;
 		} else {
 			struct mount *mnt = real_mount(nd->path.mnt);
@@ -1396,7 +1416,7 @@ static void follow_mount(struct path *path)
 	}
 }
 
-static void follow_dotdot(struct nameidata *nd)
+static int follow_dotdot(struct nameidata *nd)
 {
 	if (!nd->root.mnt)
 		set_root(nd);
@@ -1412,13 +1432,16 @@ static void follow_dotdot(struct nameidata *nd)
 			/* rare case of legitimate dget_parent()... */
 			nd->path.dentry = dget_parent(nd->path.dentry);
 			dput(old);
+			if (unlikely(!path_connected(&nd->path)))
+				return -ENOENT;
 			break;
 		}
 		if (!follow_up(&nd->path))
 			break;
 	}
 	follow_mount(&nd->path);
 	nd->inode = nd->path.dentry->d_inode;
+	return 0;
 }
 
 /*
@@ -1634,7 +1657,7 @@ static inline int handle_dots(struct nameidata *nd, int type)
 		if (nd->flags & LOOKUP_RCU) {
 			return follow_dotdot_rcu(nd);
 		} else
-			follow_dotdot(nd);
+			return follow_dotdot(nd);
 	}
 	return 0;
 }",linux,397d425dc26da728396e66d392d5dcb8dac30c37,a03e283bf5c3d4851b4998122196ce9f849e6dfb,1,"static void follow_dotdot(struct nameidata *nd)
//fix_flaw_line_below:
//static int follow_dotdot(struct nameidata *nd)
 {
 	if (!nd->root.mnt)
 		set_root(nd);

	while(1) {
		struct dentry *old = nd->path.dentry;

		if (nd->path.dentry == nd->root.dentry &&
		    nd->path.mnt == nd->root.mnt) {
			break;
		}
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
 			/* rare case of legitimate dget_parent()... */
 			nd->path.dentry = dget_parent(nd->path.dentry);
 			dput(old);
//fix_flaw_line_below:
//			if (unlikely(!path_connected(&nd->path)))
//fix_flaw_line_below:
//				return -ENOENT;
 			break;
 		}
 		if (!follow_up(&nd->path))
 			break;
 	}
 	follow_mount(&nd->path);
 	nd->inode = nd->path.dentry->d_inode;
//fix_flaw_line_below:
//	return 0;
 }
"
2072,179808,,Local,Not required,Complete,CVE-2015-2925,https://www.cvedetails.com/cve/CVE-2015-2925/,CWE-254,Medium,Complete,Complete,,2015-11-16,6.9,"The prepend_path function in fs/dcache.c in the Linux kernel before 4.2.4 does not properly handle rename actions inside a bind mount, which allows local users to bypass an intended container protection mechanism by renaming a directory, related to a *double-chroot attack.*",2018-01-04,Bypass ,2,https://github.com/torvalds/linux/commit/397d425dc26da728396e66d392d5dcb8dac30c37,397d425dc26da728396e66d392d5dcb8dac30c37,"vfs: Test for and handle paths that are unreachable from their mnt_root

In rare cases a directory can be renamed out from under a bind mount.
In those cases without special handling it becomes possible to walk up
the directory tree to the root dentry of the filesystem and down
from the root dentry to every other file or directory on the filesystem.

Like division by zero .. from an unconnected path can not be given
a useful semantic as there is no predicting at which path component
the code will realize it is unconnected.  We certainly can not match
the current behavior as the current behavior is a security hole.

Therefore when encounting .. when following an unconnected path
return -ENOENT.

- Add a function path_connected to verify path->dentry is reachable
  from path->mnt.mnt_root.  AKA to validate that rename did not do
  something nasty to the bind mount.

  To avoid races path_connected must be called after following a path
  component to it's next path component.

Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",0,fs/namei.c,"{""sha"": ""29b927938b8ce9c78af99d0f9c8f5af5a294cefd"", ""filename"": ""fs/namei.c"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 2, ""changes"": 27, ""blob_url"": ""https://github.com/torvalds/linux/blob/397d425dc26da728396e66d392d5dcb8dac30c37/fs/namei.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/397d425dc26da728396e66d392d5dcb8dac30c37/fs/namei.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namei.c?ref=397d425dc26da728396e66d392d5dcb8dac30c37"", ""patch"": ""@@ -560,6 +560,24 @@ static int __nd_alloc_stack(struct nameidata *nd)\n \treturn 0;\n }\n \n+/**\n+ * path_connected - Verify that a path->dentry is below path->mnt.mnt_root\n+ * @path: nameidate to verify\n+ *\n+ * Rename can sometimes move a file or directory outside of a bind\n+ * mount, path_connected allows those cases to be detected.\n+ */\n+static bool path_connected(const struct path *path)\n+{\n+\tstruct vfsmount *mnt = path->mnt;\n+\n+\t/* Only bind mounts can have disconnected paths */\n+\tif (mnt->mnt_root == mnt->mnt_sb->s_root)\n+\t\treturn true;\n+\n+\treturn is_subdir(path->dentry, mnt->mnt_root);\n+}\n+\n static inline int nd_alloc_stack(struct nameidata *nd)\n {\n \tif (likely(nd->depth != EMBEDDED_LEVELS))\n@@ -1296,6 +1314,8 @@ static int follow_dotdot_rcu(struct nameidata *nd)\n \t\t\t\treturn -ECHILD;\n \t\t\tnd->path.dentry = parent;\n \t\t\tnd->seq = seq;\n+\t\t\tif (unlikely(!path_connected(&nd->path)))\n+\t\t\t\treturn -ENOENT;\n \t\t\tbreak;\n \t\t} else {\n \t\t\tstruct mount *mnt = real_mount(nd->path.mnt);\n@@ -1396,7 +1416,7 @@ static void follow_mount(struct path *path)\n \t}\n }\n \n-static void follow_dotdot(struct nameidata *nd)\n+static int follow_dotdot(struct nameidata *nd)\n {\n \tif (!nd->root.mnt)\n \t\tset_root(nd);\n@@ -1412,13 +1432,16 @@ static void follow_dotdot(struct nameidata *nd)\n \t\t\t/* rare case of legitimate dget_parent()... */\n \t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n \t\t\tdput(old);\n+\t\t\tif (unlikely(!path_connected(&nd->path)))\n+\t\t\t\treturn -ENOENT;\n \t\t\tbreak;\n \t\t}\n \t\tif (!follow_up(&nd->path))\n \t\t\tbreak;\n \t}\n \tfollow_mount(&nd->path);\n \tnd->inode = nd->path.dentry->d_inode;\n+\treturn 0;\n }\n \n /*\n@@ -1634,7 +1657,7 @@ static inline int handle_dots(struct nameidata *nd, int type)\n \t\tif (nd->flags & LOOKUP_RCU) {\n \t\t\treturn follow_dotdot_rcu(nd);\n \t\t} else\n-\t\t\tfollow_dotdot(nd);\n+\t\t\treturn follow_dotdot(nd);\n \t}\n \treturn 0;\n }""}","static int follow_dotdot_rcu(struct nameidata *nd)
{
	struct inode *inode = nd->inode;
	if (!nd->root.mnt)
		set_root_rcu(nd);

	while (1) {
		if (path_equal(&nd->path, &nd->root))
			break;
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
			struct dentry *old = nd->path.dentry;
			struct dentry *parent = old->d_parent;
			unsigned seq;

			inode = parent->d_inode;
			seq = read_seqcount_begin(&parent->d_seq);
			if (unlikely(read_seqcount_retry(&old->d_seq, nd->seq)))
 				return -ECHILD;
 			nd->path.dentry = parent;
 			nd->seq = seq;
			if (unlikely(!path_connected(&nd->path)))
				return -ENOENT;
 			break;
 		} else {
 			struct mount *mnt = real_mount(nd->path.mnt);
			struct mount *mparent = mnt->mnt_parent;
			struct dentry *mountpoint = mnt->mnt_mountpoint;
			struct inode *inode2 = mountpoint->d_inode;
			unsigned seq = read_seqcount_begin(&mountpoint->d_seq);
			if (unlikely(read_seqretry(&mount_lock, nd->m_seq)))
				return -ECHILD;
			if (&mparent->mnt == nd->path.mnt)
				break;
			/* we know that mountpoint was pinned */
			nd->path.dentry = mountpoint;
			nd->path.mnt = &mparent->mnt;
			inode = inode2;
			nd->seq = seq;
		}
	}
	while (unlikely(d_mountpoint(nd->path.dentry))) {
		struct mount *mounted;
		mounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);
		if (unlikely(read_seqretry(&mount_lock, nd->m_seq)))
			return -ECHILD;
		if (!mounted)
			break;
		nd->path.mnt = &mounted->mnt;
		nd->path.dentry = mounted->mnt.mnt_root;
		inode = nd->path.dentry->d_inode;
		nd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);
	}
	nd->inode = inode;
	return 0;
}
","static int follow_dotdot_rcu(struct nameidata *nd)
{
	struct inode *inode = nd->inode;
	if (!nd->root.mnt)
		set_root_rcu(nd);

	while (1) {
		if (path_equal(&nd->path, &nd->root))
			break;
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
			struct dentry *old = nd->path.dentry;
			struct dentry *parent = old->d_parent;
			unsigned seq;

			inode = parent->d_inode;
			seq = read_seqcount_begin(&parent->d_seq);
			if (unlikely(read_seqcount_retry(&old->d_seq, nd->seq)))
 				return -ECHILD;
 			nd->path.dentry = parent;
 			nd->seq = seq;
 			break;
 		} else {
 			struct mount *mnt = real_mount(nd->path.mnt);
			struct mount *mparent = mnt->mnt_parent;
			struct dentry *mountpoint = mnt->mnt_mountpoint;
			struct inode *inode2 = mountpoint->d_inode;
			unsigned seq = read_seqcount_begin(&mountpoint->d_seq);
			if (unlikely(read_seqretry(&mount_lock, nd->m_seq)))
				return -ECHILD;
			if (&mparent->mnt == nd->path.mnt)
				break;
			/* we know that mountpoint was pinned */
			nd->path.dentry = mountpoint;
			nd->path.mnt = &mparent->mnt;
			inode = inode2;
			nd->seq = seq;
		}
	}
	while (unlikely(d_mountpoint(nd->path.dentry))) {
		struct mount *mounted;
		mounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);
		if (unlikely(read_seqretry(&mount_lock, nd->m_seq)))
			return -ECHILD;
		if (!mounted)
			break;
		nd->path.mnt = &mounted->mnt;
		nd->path.dentry = mounted->mnt.mnt_root;
		inode = nd->path.dentry->d_inode;
		nd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);
	}
	nd->inode = inode;
	return 0;
}
",C,"			if (unlikely(!path_connected(&nd->path)))
				return -ENOENT;
",,,"@@ -560,6 +560,24 @@ static int __nd_alloc_stack(struct nameidata *nd)
 	return 0;
 }
 
+/**
+ * path_connected - Verify that a path->dentry is below path->mnt.mnt_root
+ * @path: nameidate to verify
+ *
+ * Rename can sometimes move a file or directory outside of a bind
+ * mount, path_connected allows those cases to be detected.
+ */
+static bool path_connected(const struct path *path)
+{
+	struct vfsmount *mnt = path->mnt;
+
+	/* Only bind mounts can have disconnected paths */
+	if (mnt->mnt_root == mnt->mnt_sb->s_root)
+		return true;
+
+	return is_subdir(path->dentry, mnt->mnt_root);
+}
+
 static inline int nd_alloc_stack(struct nameidata *nd)
 {
 	if (likely(nd->depth != EMBEDDED_LEVELS))
@@ -1296,6 +1314,8 @@ static int follow_dotdot_rcu(struct nameidata *nd)
 				return -ECHILD;
 			nd->path.dentry = parent;
 			nd->seq = seq;
+			if (unlikely(!path_connected(&nd->path)))
+				return -ENOENT;
 			break;
 		} else {
 			struct mount *mnt = real_mount(nd->path.mnt);
@@ -1396,7 +1416,7 @@ static void follow_mount(struct path *path)
 	}
 }
 
-static void follow_dotdot(struct nameidata *nd)
+static int follow_dotdot(struct nameidata *nd)
 {
 	if (!nd->root.mnt)
 		set_root(nd);
@@ -1412,13 +1432,16 @@ static void follow_dotdot(struct nameidata *nd)
 			/* rare case of legitimate dget_parent()... */
 			nd->path.dentry = dget_parent(nd->path.dentry);
 			dput(old);
+			if (unlikely(!path_connected(&nd->path)))
+				return -ENOENT;
 			break;
 		}
 		if (!follow_up(&nd->path))
 			break;
 	}
 	follow_mount(&nd->path);
 	nd->inode = nd->path.dentry->d_inode;
+	return 0;
 }
 
 /*
@@ -1634,7 +1657,7 @@ static inline int handle_dots(struct nameidata *nd, int type)
 		if (nd->flags & LOOKUP_RCU) {
 			return follow_dotdot_rcu(nd);
 		} else
-			follow_dotdot(nd);
+			return follow_dotdot(nd);
 	}
 	return 0;
 }",linux,397d425dc26da728396e66d392d5dcb8dac30c37,a03e283bf5c3d4851b4998122196ce9f849e6dfb,1,"static int follow_dotdot_rcu(struct nameidata *nd)
{
	struct inode *inode = nd->inode;
	if (!nd->root.mnt)
		set_root_rcu(nd);

	while (1) {
		if (path_equal(&nd->path, &nd->root))
			break;
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
			struct dentry *old = nd->path.dentry;
			struct dentry *parent = old->d_parent;
			unsigned seq;

			inode = parent->d_inode;
			seq = read_seqcount_begin(&parent->d_seq);
			if (unlikely(read_seqcount_retry(&old->d_seq, nd->seq)))
 				return -ECHILD;
 			nd->path.dentry = parent;
 			nd->seq = seq;
//fix_flaw_line_below:
//			if (unlikely(!path_connected(&nd->path)))
//fix_flaw_line_below:
//				return -ENOENT;
 			break;
 		} else {
 			struct mount *mnt = real_mount(nd->path.mnt);
			struct mount *mparent = mnt->mnt_parent;
			struct dentry *mountpoint = mnt->mnt_mountpoint;
			struct inode *inode2 = mountpoint->d_inode;
			unsigned seq = read_seqcount_begin(&mountpoint->d_seq);
			if (unlikely(read_seqretry(&mount_lock, nd->m_seq)))
				return -ECHILD;
			if (&mparent->mnt == nd->path.mnt)
				break;
			/* we know that mountpoint was pinned */
			nd->path.dentry = mountpoint;
			nd->path.mnt = &mparent->mnt;
			inode = inode2;
			nd->seq = seq;
		}
	}
	while (unlikely(d_mountpoint(nd->path.dentry))) {
		struct mount *mounted;
		mounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);
		if (unlikely(read_seqretry(&mount_lock, nd->m_seq)))
			return -ECHILD;
		if (!mounted)
			break;
		nd->path.mnt = &mounted->mnt;
		nd->path.dentry = mounted->mnt.mnt_root;
		inode = nd->path.dentry->d_inode;
		nd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);
	}
	nd->inode = inode;
	return 0;
}
"
2073,179809,,Local,Not required,Complete,CVE-2015-2925,https://www.cvedetails.com/cve/CVE-2015-2925/,CWE-254,Medium,Complete,Complete,,2015-11-16,6.9,"The prepend_path function in fs/dcache.c in the Linux kernel before 4.2.4 does not properly handle rename actions inside a bind mount, which allows local users to bypass an intended container protection mechanism by renaming a directory, related to a *double-chroot attack.*",2018-01-04,Bypass ,1,https://github.com/torvalds/linux/commit/397d425dc26da728396e66d392d5dcb8dac30c37,397d425dc26da728396e66d392d5dcb8dac30c37,"vfs: Test for and handle paths that are unreachable from their mnt_root

In rare cases a directory can be renamed out from under a bind mount.
In those cases without special handling it becomes possible to walk up
the directory tree to the root dentry of the filesystem and down
from the root dentry to every other file or directory on the filesystem.

Like division by zero .. from an unconnected path can not be given
a useful semantic as there is no predicting at which path component
the code will realize it is unconnected.  We certainly can not match
the current behavior as the current behavior is a security hole.

Therefore when encounting .. when following an unconnected path
return -ENOENT.

- Add a function path_connected to verify path->dentry is reachable
  from path->mnt.mnt_root.  AKA to validate that rename did not do
  something nasty to the bind mount.

  To avoid races path_connected must be called after following a path
  component to it's next path component.

Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",1,fs/namei.c,"{""sha"": ""29b927938b8ce9c78af99d0f9c8f5af5a294cefd"", ""filename"": ""fs/namei.c"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 2, ""changes"": 27, ""blob_url"": ""https://github.com/torvalds/linux/blob/397d425dc26da728396e66d392d5dcb8dac30c37/fs/namei.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/397d425dc26da728396e66d392d5dcb8dac30c37/fs/namei.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namei.c?ref=397d425dc26da728396e66d392d5dcb8dac30c37"", ""patch"": ""@@ -560,6 +560,24 @@ static int __nd_alloc_stack(struct nameidata *nd)\n \treturn 0;\n }\n \n+/**\n+ * path_connected - Verify that a path->dentry is below path->mnt.mnt_root\n+ * @path: nameidate to verify\n+ *\n+ * Rename can sometimes move a file or directory outside of a bind\n+ * mount, path_connected allows those cases to be detected.\n+ */\n+static bool path_connected(const struct path *path)\n+{\n+\tstruct vfsmount *mnt = path->mnt;\n+\n+\t/* Only bind mounts can have disconnected paths */\n+\tif (mnt->mnt_root == mnt->mnt_sb->s_root)\n+\t\treturn true;\n+\n+\treturn is_subdir(path->dentry, mnt->mnt_root);\n+}\n+\n static inline int nd_alloc_stack(struct nameidata *nd)\n {\n \tif (likely(nd->depth != EMBEDDED_LEVELS))\n@@ -1296,6 +1314,8 @@ static int follow_dotdot_rcu(struct nameidata *nd)\n \t\t\t\treturn -ECHILD;\n \t\t\tnd->path.dentry = parent;\n \t\t\tnd->seq = seq;\n+\t\t\tif (unlikely(!path_connected(&nd->path)))\n+\t\t\t\treturn -ENOENT;\n \t\t\tbreak;\n \t\t} else {\n \t\t\tstruct mount *mnt = real_mount(nd->path.mnt);\n@@ -1396,7 +1416,7 @@ static void follow_mount(struct path *path)\n \t}\n }\n \n-static void follow_dotdot(struct nameidata *nd)\n+static int follow_dotdot(struct nameidata *nd)\n {\n \tif (!nd->root.mnt)\n \t\tset_root(nd);\n@@ -1412,13 +1432,16 @@ static void follow_dotdot(struct nameidata *nd)\n \t\t\t/* rare case of legitimate dget_parent()... */\n \t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n \t\t\tdput(old);\n+\t\t\tif (unlikely(!path_connected(&nd->path)))\n+\t\t\t\treturn -ENOENT;\n \t\t\tbreak;\n \t\t}\n \t\tif (!follow_up(&nd->path))\n \t\t\tbreak;\n \t}\n \tfollow_mount(&nd->path);\n \tnd->inode = nd->path.dentry->d_inode;\n+\treturn 0;\n }\n \n /*\n@@ -1634,7 +1657,7 @@ static inline int handle_dots(struct nameidata *nd, int type)\n \t\tif (nd->flags & LOOKUP_RCU) {\n \t\t\treturn follow_dotdot_rcu(nd);\n \t\t} else\n-\t\t\tfollow_dotdot(nd);\n+\t\t\treturn follow_dotdot(nd);\n \t}\n \treturn 0;\n }""}","static inline int handle_dots(struct nameidata *nd, int type)
{
	if (type == LAST_DOTDOT) {
 		if (nd->flags & LOOKUP_RCU) {
 			return follow_dotdot_rcu(nd);
 		} else
			return follow_dotdot(nd);
 	}
 	return 0;
 }
","static inline int handle_dots(struct nameidata *nd, int type)
{
	if (type == LAST_DOTDOT) {
 		if (nd->flags & LOOKUP_RCU) {
 			return follow_dotdot_rcu(nd);
 		} else
			follow_dotdot(nd);
 	}
 	return 0;
 }
",C,"			return follow_dotdot(nd);
","			follow_dotdot(nd);
",,"@@ -560,6 +560,24 @@ static int __nd_alloc_stack(struct nameidata *nd)
 	return 0;
 }
 
+/**
+ * path_connected - Verify that a path->dentry is below path->mnt.mnt_root
+ * @path: nameidate to verify
+ *
+ * Rename can sometimes move a file or directory outside of a bind
+ * mount, path_connected allows those cases to be detected.
+ */
+static bool path_connected(const struct path *path)
+{
+	struct vfsmount *mnt = path->mnt;
+
+	/* Only bind mounts can have disconnected paths */
+	if (mnt->mnt_root == mnt->mnt_sb->s_root)
+		return true;
+
+	return is_subdir(path->dentry, mnt->mnt_root);
+}
+
 static inline int nd_alloc_stack(struct nameidata *nd)
 {
 	if (likely(nd->depth != EMBEDDED_LEVELS))
@@ -1296,6 +1314,8 @@ static int follow_dotdot_rcu(struct nameidata *nd)
 				return -ECHILD;
 			nd->path.dentry = parent;
 			nd->seq = seq;
+			if (unlikely(!path_connected(&nd->path)))
+				return -ENOENT;
 			break;
 		} else {
 			struct mount *mnt = real_mount(nd->path.mnt);
@@ -1396,7 +1416,7 @@ static void follow_mount(struct path *path)
 	}
 }
 
-static void follow_dotdot(struct nameidata *nd)
+static int follow_dotdot(struct nameidata *nd)
 {
 	if (!nd->root.mnt)
 		set_root(nd);
@@ -1412,13 +1432,16 @@ static void follow_dotdot(struct nameidata *nd)
 			/* rare case of legitimate dget_parent()... */
 			nd->path.dentry = dget_parent(nd->path.dentry);
 			dput(old);
+			if (unlikely(!path_connected(&nd->path)))
+				return -ENOENT;
 			break;
 		}
 		if (!follow_up(&nd->path))
 			break;
 	}
 	follow_mount(&nd->path);
 	nd->inode = nd->path.dentry->d_inode;
+	return 0;
 }
 
 /*
@@ -1634,7 +1657,7 @@ static inline int handle_dots(struct nameidata *nd, int type)
 		if (nd->flags & LOOKUP_RCU) {
 			return follow_dotdot_rcu(nd);
 		} else
-			follow_dotdot(nd);
+			return follow_dotdot(nd);
 	}
 	return 0;
 }",linux,397d425dc26da728396e66d392d5dcb8dac30c37,a03e283bf5c3d4851b4998122196ce9f849e6dfb,1,"static inline int handle_dots(struct nameidata *nd, int type)
{
	if (type == LAST_DOTDOT) {
 		if (nd->flags & LOOKUP_RCU) {
 			return follow_dotdot_rcu(nd);
 		} else
//flaw_line_below:
			follow_dotdot(nd);
//fix_flaw_line_below:
//			return follow_dotdot(nd);
 	}
 	return 0;
 }
"
2245,179981,,Remote,Not required,,CVE-2014-8160,https://www.cvedetails.com/cve/CVE-2014-8160/,CWE-254,Low,,Partial,,2015-03-02,5.0,"net/netfilter/nf_conntrack_proto_generic.c in the Linux kernel before 3.18 generates incorrect conntrack entries during handling of certain iptables rule sets for the SCTP, DCCP, GRE, and UDP-Lite protocols, which allows remote attackers to bypass intended access restrictions via packets with disallowed port numbers.",2017-01-02,Bypass ,1,https://github.com/torvalds/linux/commit/db29a9508a9246e77087c5531e45b2c88ec6988b,db29a9508a9246e77087c5531e45b2c88ec6988b,"netfilter: conntrack: disable generic tracking for known protocols

Given following iptables ruleset:

-P FORWARD DROP
-A FORWARD -m sctp --dport 9 -j ACCEPT
-A FORWARD -p tcp --dport 80 -j ACCEPT
-A FORWARD -p tcp -m conntrack -m state ESTABLISHED,RELATED -j ACCEPT

One would assume that this allows SCTP on port 9 and TCP on port 80.
Unfortunately, if the SCTP conntrack module is not loaded, this allows
*all* SCTP communication, to pass though, i.e. -p sctp -j ACCEPT,
which we think is a security issue.

This is because on the first SCTP packet on port 9, we create a dummy
""generic l4"" conntrack entry without any port information (since
conntrack doesn't know how to extract this information).

All subsequent packets that are unknown will then be in established
state since they will fallback to proto_generic and will match the
'generic' entry.

Our originally proposed version [1] completely disabled generic protocol
tracking, but Jozsef suggests to not track protocols for which a more
suitable helper is available, hence we now mitigate the issue for in
tree known ct protocol helpers only, so that at least NAT and direction
information will still be preserved for others.

 [1] http://www.spinics.net/lists/netfilter-devel/msg33430.html

Joint work with Daniel Borkmann.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
Acked-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",1,net/netfilter/nf_conntrack_proto_generic.c,"{""sha"": ""957c1db6665254645f43d0c04456015a1d4df65c"", ""filename"": ""net/netfilter/nf_conntrack_proto_generic.c"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 1, ""changes"": 26, ""blob_url"": ""https://github.com/torvalds/linux/blob/db29a9508a9246e77087c5531e45b2c88ec6988b/net/netfilter/nf_conntrack_proto_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/db29a9508a9246e77087c5531e45b2c88ec6988b/net/netfilter/nf_conntrack_proto_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/netfilter/nf_conntrack_proto_generic.c?ref=db29a9508a9246e77087c5531e45b2c88ec6988b"", ""patch"": ""@@ -14,6 +14,30 @@\n \n static unsigned int nf_ct_generic_timeout __read_mostly = 600*HZ;\n \n+static bool nf_generic_should_process(u8 proto)\n+{\n+\tswitch (proto) {\n+#ifdef CONFIG_NF_CT_PROTO_SCTP_MODULE\n+\tcase IPPROTO_SCTP:\n+\t\treturn false;\n+#endif\n+#ifdef CONFIG_NF_CT_PROTO_DCCP_MODULE\n+\tcase IPPROTO_DCCP:\n+\t\treturn false;\n+#endif\n+#ifdef CONFIG_NF_CT_PROTO_GRE_MODULE\n+\tcase IPPROTO_GRE:\n+\t\treturn false;\n+#endif\n+#ifdef CONFIG_NF_CT_PROTO_UDPLITE_MODULE\n+\tcase IPPROTO_UDPLITE:\n+\t\treturn false;\n+#endif\n+\tdefault:\n+\t\treturn true;\n+\t}\n+}\n+\n static inline struct nf_generic_net *generic_pernet(struct net *net)\n {\n \treturn &net->ct.nf_ct_proto.generic;\n@@ -67,7 +91,7 @@ static int generic_packet(struct nf_conn *ct,\n static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n \t\t\tunsigned int dataoff, unsigned int *timeouts)\n {\n-\treturn true;\n+\treturn nf_generic_should_process(nf_ct_protonum(ct));\n }\n \n #if IS_ENABLED(CONFIG_NF_CT_NETLINK_TIMEOUT)""}"," static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,
 			unsigned int dataoff, unsigned int *timeouts)
 {
	return nf_generic_should_process(nf_ct_protonum(ct));
 }
"," static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,
 			unsigned int dataoff, unsigned int *timeouts)
 {
	return true;
 }
",C,"	return nf_generic_should_process(nf_ct_protonum(ct));
","	return true;
",,"@@ -14,6 +14,30 @@
 
 static unsigned int nf_ct_generic_timeout __read_mostly = 600*HZ;
 
+static bool nf_generic_should_process(u8 proto)
+{
+	switch (proto) {
+#ifdef CONFIG_NF_CT_PROTO_SCTP_MODULE
+	case IPPROTO_SCTP:
+		return false;
+#endif
+#ifdef CONFIG_NF_CT_PROTO_DCCP_MODULE
+	case IPPROTO_DCCP:
+		return false;
+#endif
+#ifdef CONFIG_NF_CT_PROTO_GRE_MODULE
+	case IPPROTO_GRE:
+		return false;
+#endif
+#ifdef CONFIG_NF_CT_PROTO_UDPLITE_MODULE
+	case IPPROTO_UDPLITE:
+		return false;
+#endif
+	default:
+		return true;
+	}
+}
+
 static inline struct nf_generic_net *generic_pernet(struct net *net)
 {
 	return &net->ct.nf_ct_proto.generic;
@@ -67,7 +91,7 @@ static int generic_packet(struct nf_conn *ct,
 static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,
 			unsigned int dataoff, unsigned int *timeouts)
 {
-	return true;
+	return nf_generic_should_process(nf_ct_protonum(ct));
 }
 
 #if IS_ENABLED(CONFIG_NF_CT_NETLINK_TIMEOUT)",linux,db29a9508a9246e77087c5531e45b2c88ec6988b,9363dc4b599949bde338cdaba1cf7cac243e4e97,1," static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,
 			unsigned int dataoff, unsigned int *timeouts)
 {
//flaw_line_below:
	return true;
//fix_flaw_line_below:
//	return nf_generic_should_process(nf_ct_protonum(ct));
 }
"
2788,180524,,Local,Not required,Partial,CVE-2016-3672,https://www.cvedetails.com/cve/CVE-2016-3672/,CWE-254,Low,Partial,Partial,,2016-04-27,4.6,"The arch_pick_mmap_layout function in arch/x86/mm/mmap.c in the Linux kernel through 4.5.2 does not properly randomize the legacy base address, which makes it easier for local users to defeat the intended restrictions on the ADDR_NO_RANDOMIZE flag, and bypass the ASLR protection mechanism for a setuid or setgid program, by disabling stack-consumption resource limits.",2018-10-09,Bypass ,1,https://github.com/torvalds/linux/commit/8b8addf891de8a00e4d39fc32f93f7c5eb8feceb,8b8addf891de8a00e4d39fc32f93f7c5eb8feceb,"x86/mm/32: Enable full randomization on i386 and X86_32

Currently on i386 and on X86_64 when emulating X86_32 in legacy mode, only
the stack and the executable are randomized but not other mmapped files
(libraries, vDSO, etc.). This patch enables randomization for the
libraries, vDSO and mmap requests on i386 and in X86_32 in legacy mode.

By default on i386 there are 8 bits for the randomization of the libraries,
vDSO and mmaps which only uses 1MB of VA.

This patch preserves the original randomness, using 1MB of VA out of 3GB or
4GB. We think that 1MB out of 3GB is not a big cost for having the ASLR.

The first obvious security benefit is that all objects are randomized (not
only the stack and the executable) in legacy mode which highly increases
the ASLR effectiveness, otherwise the attackers may use these
non-randomized areas. But also sensitive setuid/setgid applications are
more secure because currently, attackers can disable the randomization of
these applications by setting the ulimit stack to ""unlimited"". This is a
very old and widely known trick to disable the ASLR in i386 which has been
allowed for too long.

Another trick used to disable the ASLR was to set the ADDR_NO_RANDOMIZE
personality flag, but fortunately this doesn't work on setuid/setgid
applications because there is security checks which clear Security-relevant
flags.

This patch always randomizes the mmap_legacy_base address, removing the
possibility to disable the ASLR by setting the stack to ""unlimited"".

Signed-off-by: Hector Marco-Gisbert <hecmargi@upv.es>
Acked-by: Ismael Ripoll Ripoll <iripoll@upv.es>
Acked-by: Kees Cook <keescook@chromium.org>
Acked-by: Arjan van de Ven <arjan@linux.intel.com>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Thomas Gleixner <tglx@linutronix.de>
Cc: akpm@linux-foundation.org
Cc: kees Cook <keescook@chromium.org>
Link: http://lkml.kernel.org/r/1457639460-5242-1-git-send-email-hecmargi@upv.es
Signed-off-by: Ingo Molnar <mingo@kernel.org>",1,arch/x86/mm/mmap.c,"{""sha"": ""389939f74dd5a544f16c9c4012c5a105d2420e45"", ""filename"": ""arch/x86/mm/mmap.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/torvalds/linux/blob/8b8addf891de8a00e4d39fc32f93f7c5eb8feceb/arch/x86/mm/mmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8b8addf891de8a00e4d39fc32f93f7c5eb8feceb/arch/x86/mm/mmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/mm/mmap.c?ref=8b8addf891de8a00e4d39fc32f93f7c5eb8feceb"", ""patch"": ""@@ -93,18 +93,6 @@ static unsigned long mmap_base(unsigned long rnd)\n \treturn PAGE_ALIGN(TASK_SIZE - gap - rnd);\n }\n \n-/*\n- * Bottom-up (legacy) layout on X86_32 did not support randomization, X86_64\n- * does, but not when emulating X86_32\n- */\n-static unsigned long mmap_legacy_base(unsigned long rnd)\n-{\n-\tif (mmap_is_ia32())\n-\t\treturn TASK_UNMAPPED_BASE;\n-\telse\n-\t\treturn TASK_UNMAPPED_BASE + rnd;\n-}\n-\n /*\n  * This function, called very early during the creation of a new\n  * process VM image, sets up which VM layout function to use:\n@@ -116,7 +104,7 @@ void arch_pick_mmap_layout(struct mm_struct *mm)\n \tif (current->flags & PF_RANDOMIZE)\n \t\trandom_factor = arch_mmap_rnd();\n \n-\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n+\tmm->mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor;\n \n \tif (mmap_is_legacy()) {\n \t\tmm->mmap_base = mm->mmap_legacy_base;""}","void arch_pick_mmap_layout(struct mm_struct *mm)
{
	unsigned long random_factor = 0UL;

 	if (current->flags & PF_RANDOMIZE)
 		random_factor = arch_mmap_rnd();
 
	mm->mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor;
 
 	if (mmap_is_legacy()) {
 		mm->mmap_base = mm->mmap_legacy_base;
		mm->get_unmapped_area = arch_get_unmapped_area;
	} else {
		mm->mmap_base = mmap_base(random_factor);
		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
	}
}
","void arch_pick_mmap_layout(struct mm_struct *mm)
{
	unsigned long random_factor = 0UL;

 	if (current->flags & PF_RANDOMIZE)
 		random_factor = arch_mmap_rnd();
 
	mm->mmap_legacy_base = mmap_legacy_base(random_factor);
 
 	if (mmap_is_legacy()) {
 		mm->mmap_base = mm->mmap_legacy_base;
		mm->get_unmapped_area = arch_get_unmapped_area;
	} else {
		mm->mmap_base = mmap_base(random_factor);
		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
	}
}
",C,"	mm->mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor;
","	mm->mmap_legacy_base = mmap_legacy_base(random_factor);
",,"@@ -93,18 +93,6 @@ static unsigned long mmap_base(unsigned long rnd)
 	return PAGE_ALIGN(TASK_SIZE - gap - rnd);
 }
 
-/*
- * Bottom-up (legacy) layout on X86_32 did not support randomization, X86_64
- * does, but not when emulating X86_32
- */
-static unsigned long mmap_legacy_base(unsigned long rnd)
-{
-	if (mmap_is_ia32())
-		return TASK_UNMAPPED_BASE;
-	else
-		return TASK_UNMAPPED_BASE + rnd;
-}
-
 /*
  * This function, called very early during the creation of a new
  * process VM image, sets up which VM layout function to use:
@@ -116,7 +104,7 @@ void arch_pick_mmap_layout(struct mm_struct *mm)
 	if (current->flags & PF_RANDOMIZE)
 		random_factor = arch_mmap_rnd();
 
-	mm->mmap_legacy_base = mmap_legacy_base(random_factor);
+	mm->mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor;
 
 	if (mmap_is_legacy()) {
 		mm->mmap_base = mm->mmap_legacy_base;",linux,8b8addf891de8a00e4d39fc32f93f7c5eb8feceb,cfa52c0cfa4d727aa3e457bf29aeff296c528a08,1,"void arch_pick_mmap_layout(struct mm_struct *mm)
{
	unsigned long random_factor = 0UL;

 	if (current->flags & PF_RANDOMIZE)
 		random_factor = arch_mmap_rnd();
 
//flaw_line_below:
	mm->mmap_legacy_base = mmap_legacy_base(random_factor);
//fix_flaw_line_below:
//	mm->mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor;
 
 	if (mmap_is_legacy()) {
 		mm->mmap_base = mm->mmap_legacy_base;
		mm->get_unmapped_area = arch_get_unmapped_area;
	} else {
		mm->mmap_base = mmap_base(random_factor);
		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
	}
}
"
2789,180525,,Local,Not required,Partial,CVE-2016-3672,https://www.cvedetails.com/cve/CVE-2016-3672/,CWE-254,Low,Partial,Partial,,2016-04-27,4.6,"The arch_pick_mmap_layout function in arch/x86/mm/mmap.c in the Linux kernel through 4.5.2 does not properly randomize the legacy base address, which makes it easier for local users to defeat the intended restrictions on the ADDR_NO_RANDOMIZE flag, and bypass the ASLR protection mechanism for a setuid or setgid program, by disabling stack-consumption resource limits.",2018-10-09,Bypass ,0,https://github.com/torvalds/linux/commit/8b8addf891de8a00e4d39fc32f93f7c5eb8feceb,8b8addf891de8a00e4d39fc32f93f7c5eb8feceb,"x86/mm/32: Enable full randomization on i386 and X86_32

Currently on i386 and on X86_64 when emulating X86_32 in legacy mode, only
the stack and the executable are randomized but not other mmapped files
(libraries, vDSO, etc.). This patch enables randomization for the
libraries, vDSO and mmap requests on i386 and in X86_32 in legacy mode.

By default on i386 there are 8 bits for the randomization of the libraries,
vDSO and mmaps which only uses 1MB of VA.

This patch preserves the original randomness, using 1MB of VA out of 3GB or
4GB. We think that 1MB out of 3GB is not a big cost for having the ASLR.

The first obvious security benefit is that all objects are randomized (not
only the stack and the executable) in legacy mode which highly increases
the ASLR effectiveness, otherwise the attackers may use these
non-randomized areas. But also sensitive setuid/setgid applications are
more secure because currently, attackers can disable the randomization of
these applications by setting the ulimit stack to ""unlimited"". This is a
very old and widely known trick to disable the ASLR in i386 which has been
allowed for too long.

Another trick used to disable the ASLR was to set the ADDR_NO_RANDOMIZE
personality flag, but fortunately this doesn't work on setuid/setgid
applications because there is security checks which clear Security-relevant
flags.

This patch always randomizes the mmap_legacy_base address, removing the
possibility to disable the ASLR by setting the stack to ""unlimited"".

Signed-off-by: Hector Marco-Gisbert <hecmargi@upv.es>
Acked-by: Ismael Ripoll Ripoll <iripoll@upv.es>
Acked-by: Kees Cook <keescook@chromium.org>
Acked-by: Arjan van de Ven <arjan@linux.intel.com>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Thomas Gleixner <tglx@linutronix.de>
Cc: akpm@linux-foundation.org
Cc: kees Cook <keescook@chromium.org>
Link: http://lkml.kernel.org/r/1457639460-5242-1-git-send-email-hecmargi@upv.es
Signed-off-by: Ingo Molnar <mingo@kernel.org>",6,arch/x86/mm/mmap.c,"{""sha"": ""389939f74dd5a544f16c9c4012c5a105d2420e45"", ""filename"": ""arch/x86/mm/mmap.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/torvalds/linux/blob/8b8addf891de8a00e4d39fc32f93f7c5eb8feceb/arch/x86/mm/mmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8b8addf891de8a00e4d39fc32f93f7c5eb8feceb/arch/x86/mm/mmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/mm/mmap.c?ref=8b8addf891de8a00e4d39fc32f93f7c5eb8feceb"", ""patch"": ""@@ -93,18 +93,6 @@ static unsigned long mmap_base(unsigned long rnd)\n \treturn PAGE_ALIGN(TASK_SIZE - gap - rnd);\n }\n \n-/*\n- * Bottom-up (legacy) layout on X86_32 did not support randomization, X86_64\n- * does, but not when emulating X86_32\n- */\n-static unsigned long mmap_legacy_base(unsigned long rnd)\n-{\n-\tif (mmap_is_ia32())\n-\t\treturn TASK_UNMAPPED_BASE;\n-\telse\n-\t\treturn TASK_UNMAPPED_BASE + rnd;\n-}\n-\n /*\n  * This function, called very early during the creation of a new\n  * process VM image, sets up which VM layout function to use:\n@@ -116,7 +104,7 @@ void arch_pick_mmap_layout(struct mm_struct *mm)\n \tif (current->flags & PF_RANDOMIZE)\n \t\trandom_factor = arch_mmap_rnd();\n \n-\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n+\tmm->mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor;\n \n \tif (mmap_is_legacy()) {\n \t\tmm->mmap_base = mm->mmap_legacy_base;""}","static unsigned long mmap_legacy_base(unsigned long rnd)
","static unsigned long mmap_legacy_base(unsigned long rnd)
{
	if (mmap_is_ia32())
		return TASK_UNMAPPED_BASE;
	else
		return TASK_UNMAPPED_BASE + rnd;
}
",C,,"{
	if (mmap_is_ia32())
		return TASK_UNMAPPED_BASE;
	else
		return TASK_UNMAPPED_BASE + rnd;
}
",,"@@ -93,18 +93,6 @@ static unsigned long mmap_base(unsigned long rnd)
 	return PAGE_ALIGN(TASK_SIZE - gap - rnd);
 }
 
-/*
- * Bottom-up (legacy) layout on X86_32 did not support randomization, X86_64
- * does, but not when emulating X86_32
- */
-static unsigned long mmap_legacy_base(unsigned long rnd)
-{
-	if (mmap_is_ia32())
-		return TASK_UNMAPPED_BASE;
-	else
-		return TASK_UNMAPPED_BASE + rnd;
-}
-
 /*
  * This function, called very early during the creation of a new
  * process VM image, sets up which VM layout function to use:
@@ -116,7 +104,7 @@ void arch_pick_mmap_layout(struct mm_struct *mm)
 	if (current->flags & PF_RANDOMIZE)
 		random_factor = arch_mmap_rnd();
 
-	mm->mmap_legacy_base = mmap_legacy_base(random_factor);
+	mm->mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor;
 
 	if (mmap_is_legacy()) {
 		mm->mmap_base = mm->mmap_legacy_base;",linux,8b8addf891de8a00e4d39fc32f93f7c5eb8feceb,cfa52c0cfa4d727aa3e457bf29aeff296c528a08,1,"static unsigned long mmap_legacy_base(unsigned long rnd)
//flaw_line_below:
{
//flaw_line_below:
	if (mmap_is_ia32())
//flaw_line_below:
		return TASK_UNMAPPED_BASE;
//flaw_line_below:
	else
//flaw_line_below:
		return TASK_UNMAPPED_BASE + rnd;
//flaw_line_below:
}
"
3889,181625,,Remote,Not required,,CVE-2016-10517,https://www.cvedetails.com/cve/CVE-2016-10517/,CWE-254,Medium,Partial,,,2017-10-24,4.3,"networking.c in Redis before 3.2.7 allows *Cross Protocol Scripting* because it lacks a check for POST and Host: strings, which are not valid in the Redis protocol (but commonly occur when an attack triggers an HTTP request to the Redis TCP port).",2018-08-08,,4,https://github.com/antirez/redis/commit/874804da0c014a7d704b3d285aa500098a931f50,874804da0c014a7d704b3d285aa500098a931f50,"Security: Cross Protocol Scripting protection.

This is an attempt at mitigating problems due to cross protocol
scripting, an attack targeting services using line oriented protocols
like Redis that can accept HTTP requests as valid protocol, by
discarding the invalid parts and accepting the payloads sent, for
example, via a POST request.

For this to be effective, when we detect POST and Host: and terminate
the connection asynchronously, the networking code was modified in order
to never process further input. It was later verified that in a
pipelined request containing a POST command, the successive commands are
not executed.",2,src/networking.c,"{""sha"": ""fb5341ecad122771dbc256b6cbb1124c7669e0be"", ""filename"": ""src/networking.c"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 2, ""changes"": 26, ""blob_url"": ""https://github.com/antirez/redis/blob/874804da0c014a7d704b3d285aa500098a931f50/src/networking.c"", ""raw_url"": ""https://github.com/antirez/redis/raw/874804da0c014a7d704b3d285aa500098a931f50/src/networking.c"", ""contents_url"": ""https://api.github.com/repos/antirez/redis/contents/src/networking.c?ref=874804da0c014a7d704b3d285aa500098a931f50"", ""patch"": ""@@ -1269,8 +1269,10 @@ void processInputBuffer(client *c) {\n \n         /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is\n          * written to the client. Make sure to not let the reply grow after\n-         * this flag has been set (i.e. don't process more commands). */\n-        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;\n+         * this flag has been set (i.e. don't process more commands).\n+         *\n+         * The same applies for clients we want to terminate ASAP. */\n+        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;\n \n         /* Determine request type when unknown. */\n         if (!c->reqtype) {\n@@ -1637,6 +1639,26 @@ void clientCommand(client *c) {\n     }\n }\n \n+/* This callback is bound to POST and \""Host:\"" command names. Those are not\n+ * really commands, but are used in security attacks in order to talk to\n+ * Redis instances via HTTP, with a technique called \""cross protocol scripting\""\n+ * which exploits the fact that services like Redis will discard invalid\n+ * HTTP headers and will process what follows.\n+ *\n+ * As a protection against this attack, Redis will terminate the connection\n+ * when a POST or \""Host:\"" header is seen, and will log the event from\n+ * time to time (to avoid creating a DOS as a result of too many logs). */\n+void securityWarningCommand(client *c) {\n+    static time_t logged_time;\n+    time_t now = time(NULL);\n+\n+    if (labs(now-logged_time) > 60) {\n+        serverLog(LL_WARNING,\""Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.\"");\n+        logged_time = now;\n+    }\n+    freeClientAsync(c);\n+}\n+\n /* Rewrite the command vector of the client. All the new objects ref count\n  * is incremented. The old command vector is freed, and the old objects\n  * ref count is decremented. */""}<_**next**_>{""sha"": ""71bcda7d5a315842976670f7a7e61264ecf3a1dd"", ""filename"": ""src/server.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/antirez/redis/blob/874804da0c014a7d704b3d285aa500098a931f50/src/server.c"", ""raw_url"": ""https://github.com/antirez/redis/raw/874804da0c014a7d704b3d285aa500098a931f50/src/server.c"", ""contents_url"": ""https://api.github.com/repos/antirez/redis/contents/src/server.c?ref=874804da0c014a7d704b3d285aa500098a931f50"", ""patch"": ""@@ -294,6 +294,8 @@ struct redisCommand redisCommandTable[] = {\n     {\""pfcount\"",pfcountCommand,-2,\""r\"",0,NULL,1,-1,1,0,0},\n     {\""pfmerge\"",pfmergeCommand,-2,\""wm\"",0,NULL,1,-1,1,0,0},\n     {\""pfdebug\"",pfdebugCommand,-3,\""w\"",0,NULL,0,0,0,0,0},\n+    {\""post\"",securityWarningCommand,-1,\""lt\"",0,NULL,0,0,0,0,0},\n+    {\""host:\"",securityWarningCommand,-1,\""lt\"",0,NULL,0,0,0,0,0},\n     {\""latency\"",latencyCommand,-2,\""aslt\"",0,NULL,0,0,0,0,0}\n };\n ""}<_**next**_>{""sha"": ""3fa7c3ac173f1bc17c42bf641ed39fc0cd607451"", ""filename"": ""src/server.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/antirez/redis/blob/874804da0c014a7d704b3d285aa500098a931f50/src/server.h"", ""raw_url"": ""https://github.com/antirez/redis/raw/874804da0c014a7d704b3d285aa500098a931f50/src/server.h"", ""contents_url"": ""https://api.github.com/repos/antirez/redis/contents/src/server.h?ref=874804da0c014a7d704b3d285aa500098a931f50"", ""patch"": ""@@ -1645,6 +1645,7 @@ void pfcountCommand(client *c);\n void pfmergeCommand(client *c);\n void pfdebugCommand(client *c);\n void latencyCommand(client *c);\n+void securityWarningCommand(client *c);\n \n #if defined(__GNUC__)\n void *calloc(size_t count, size_t size) __attribute__ ((deprecated));""}","void processInputBuffer(client *c) {
    server.current_client = c;
    /* Keep processing while there is something in the input buffer */
    while(sdslen(c->querybuf)) {
        /* Return if clients are paused. */
        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;

        /* Immediately abort if the client is in the middle of something. */
        if (c->flags & CLIENT_BLOCKED) break;
 
         /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
          * written to the client. Make sure to not let the reply grow after
         * this flag has been set (i.e. don't process more commands).
         *
         * The same applies for clients we want to terminate ASAP. */
        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;
 
         /* Determine request type when unknown. */
         if (!c->reqtype) {
            if (c->querybuf[0] == '*') {
                c->reqtype = PROTO_REQ_MULTIBULK;
            } else {
                c->reqtype = PROTO_REQ_INLINE;
            }
        }

        if (c->reqtype == PROTO_REQ_INLINE) {
            if (processInlineBuffer(c) != C_OK) break;
        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {
            if (processMultibulkBuffer(c) != C_OK) break;
        } else {
            serverPanic(""Unknown request type"");
        }

        /* Multibulk processing could see a <= 0 length. */
        if (c->argc == 0) {
            resetClient(c);
        } else {
            /* Only reset the client when the command was executed. */
            if (processCommand(c) == C_OK)
                resetClient(c);
            /* freeMemoryIfNeeded may flush slave output buffers. This may result
             * into a slave, that may be the active client, to be freed. */
            if (server.current_client == NULL) break;
        }
    }
    server.current_client = NULL;
}
","void processInputBuffer(client *c) {
    server.current_client = c;
    /* Keep processing while there is something in the input buffer */
    while(sdslen(c->querybuf)) {
        /* Return if clients are paused. */
        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;

        /* Immediately abort if the client is in the middle of something. */
        if (c->flags & CLIENT_BLOCKED) break;
 
         /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
          * written to the client. Make sure to not let the reply grow after
         * this flag has been set (i.e. don't process more commands). */
        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;
 
         /* Determine request type when unknown. */
         if (!c->reqtype) {
            if (c->querybuf[0] == '*') {
                c->reqtype = PROTO_REQ_MULTIBULK;
            } else {
                c->reqtype = PROTO_REQ_INLINE;
            }
        }

        if (c->reqtype == PROTO_REQ_INLINE) {
            if (processInlineBuffer(c) != C_OK) break;
        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {
            if (processMultibulkBuffer(c) != C_OK) break;
        } else {
            serverPanic(""Unknown request type"");
        }

        /* Multibulk processing could see a <= 0 length. */
        if (c->argc == 0) {
            resetClient(c);
        } else {
            /* Only reset the client when the command was executed. */
            if (processCommand(c) == C_OK)
                resetClient(c);
            /* freeMemoryIfNeeded may flush slave output buffers. This may result
             * into a slave, that may be the active client, to be freed. */
            if (server.current_client == NULL) break;
        }
    }
    server.current_client = NULL;
}
",C,"         * this flag has been set (i.e. don't process more commands).
         *
         * The same applies for clients we want to terminate ASAP. */
        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;
","         * this flag has been set (i.e. don't process more commands). */
        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;
",,"@@ -1269,8 +1269,10 @@ void processInputBuffer(client *c) {
 
         /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
          * written to the client. Make sure to not let the reply grow after
-         * this flag has been set (i.e. don't process more commands). */
-        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;
+         * this flag has been set (i.e. don't process more commands).
+         *
+         * The same applies for clients we want to terminate ASAP. */
+        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;
 
         /* Determine request type when unknown. */
         if (!c->reqtype) {
@@ -1637,6 +1639,26 @@ void clientCommand(client *c) {
     }
 }
 
+/* This callback is bound to POST and ""Host:"" command names. Those are not
+ * really commands, but are used in security attacks in order to talk to
+ * Redis instances via HTTP, with a technique called ""cross protocol scripting""
+ * which exploits the fact that services like Redis will discard invalid
+ * HTTP headers and will process what follows.
+ *
+ * As a protection against this attack, Redis will terminate the connection
+ * when a POST or ""Host:"" header is seen, and will log the event from
+ * time to time (to avoid creating a DOS as a result of too many logs). */
+void securityWarningCommand(client *c) {
+    static time_t logged_time;
+    time_t now = time(NULL);
+
+    if (labs(now-logged_time) > 60) {
+        serverLog(LL_WARNING,""Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted."");
+        logged_time = now;
+    }
+    freeClientAsync(c);
+}
+
 /* Rewrite the command vector of the client. All the new objects ref count
  * is incremented. The old command vector is freed, and the old objects
  * ref count is decremented. */",redis,874804da0c014a7d704b3d285aa500098a931f50,273cd7ff51ffa03cbef737aaadf537e828fb3e5d,1,"void processInputBuffer(client *c) {
    server.current_client = c;
    /* Keep processing while there is something in the input buffer */
    while(sdslen(c->querybuf)) {
        /* Return if clients are paused. */
        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;

        /* Immediately abort if the client is in the middle of something. */
        if (c->flags & CLIENT_BLOCKED) break;
 
         /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
          * written to the client. Make sure to not let the reply grow after
//flaw_line_below:
         * this flag has been set (i.e. don't process more commands). */
//flaw_line_below:
        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;
//fix_flaw_line_below:
//         * this flag has been set (i.e. don't process more commands).
//fix_flaw_line_below:
//         *
//fix_flaw_line_below:
//         * The same applies for clients we want to terminate ASAP. */
//fix_flaw_line_below:
//        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;
 
         /* Determine request type when unknown. */
         if (!c->reqtype) {
            if (c->querybuf[0] == '*') {
                c->reqtype = PROTO_REQ_MULTIBULK;
            } else {
                c->reqtype = PROTO_REQ_INLINE;
            }
        }

        if (c->reqtype == PROTO_REQ_INLINE) {
            if (processInlineBuffer(c) != C_OK) break;
        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {
            if (processMultibulkBuffer(c) != C_OK) break;
        } else {
            serverPanic(""Unknown request type"");
        }

        /* Multibulk processing could see a <= 0 length. */
        if (c->argc == 0) {
            resetClient(c);
        } else {
            /* Only reset the client when the command was executed. */
            if (processCommand(c) == C_OK)
                resetClient(c);
            /* freeMemoryIfNeeded may flush slave output buffers. This may result
             * into a slave, that may be the active client, to be freed. */
            if (server.current_client == NULL) break;
        }
    }
    server.current_client = NULL;
}
"
4220,181956,,Remote,Not required,Partial,CVE-2016-7797,https://www.cvedetails.com/cve/CVE-2016-7797/,CWE-254,Low,,,,2017-03-24,5.0,"Pacemaker before 1.1.15, when using pacemaker remote, might allow remote attackers to cause a denial of service (node disconnection) via an unauthenticated connection.",2018-10-30,DoS ,3,https://github.com/ClusterLabs/pacemaker/commit/5ec24a2642bd0854b884d1a9b51d12371373b410,5ec24a2642bd0854b884d1a9b51d12371373b410,Fix: remote: cl#5269 - Notify other clients of a new connection only if the handshake has completed (bsc#967388),0,lrmd/tls_backend.c,"{""sha"": ""0e0782869a9068d72fc1609cc2bfab3da39041c1"", ""filename"": ""lrmd/tls_backend.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/ClusterLabs/pacemaker/blob/5ec24a2642bd0854b884d1a9b51d12371373b410/lrmd/tls_backend.c"", ""raw_url"": ""https://github.com/ClusterLabs/pacemaker/raw/5ec24a2642bd0854b884d1a9b51d12371373b410/lrmd/tls_backend.c"", ""contents_url"": ""https://api.github.com/repos/ClusterLabs/pacemaker/contents/lrmd/tls_backend.c?ref=5ec24a2642bd0854b884d1a9b51d12371373b410"", ""patch"": ""@@ -79,6 +79,9 @@ lrmd_remote_client_msg(gpointer data)\n                 g_source_remove(client->remote->auth_timeout);\n             }\n             client->remote->auth_timeout = 0;\n+\n+            /* Alert other clients of the new connection */\n+            notify_of_new_client(client);\n         }\n         return 0;\n     }\n@@ -289,8 +292,6 @@ lrmd_remote_listen(gpointer data)\n                         &lrmd_remote_fd_cb);\n     g_hash_table_insert(client_connections, new_client->id, new_client);\n \n-    /* Alert other clients of the new connection */\n-    notify_of_new_client(new_client);\n     return TRUE;\n }\n ""}","lrmd_remote_client_msg(gpointer data)
{
    int id = 0;
    int rc = 0;
    int disconnected = 0;
    xmlNode *request = NULL;
    crm_client_t *client = data;

    if (client->remote->tls_handshake_complete == FALSE) {
        int rc = 0;

        /* Muliple calls to handshake will be required, this callback
         * will be invoked once the client sends more handshake data. */
        do {
            rc = gnutls_handshake(*client->remote->tls_session);

            if (rc < 0 && rc != GNUTLS_E_AGAIN) {
                crm_err(""Remote lrmd tls handshake failed"");
                return -1;
            }
        } while (rc == GNUTLS_E_INTERRUPTED);

        if (rc == 0) {
            crm_debug(""Remote lrmd tls handshake completed"");
            client->remote->tls_handshake_complete = TRUE;
            if (client->remote->auth_timeout) {
                 g_source_remove(client->remote->auth_timeout);
             }
             client->remote->auth_timeout = 0;

            /* Alert other clients of the new connection */
            notify_of_new_client(client);
         }
         return 0;
     }

    rc = crm_remote_ready(client->remote, 0);
    if (rc == 0) {
        /* no msg to read */
        return 0;
    } else if (rc < 0) {
        crm_info(""Client disconnected during remote client read"");
        return -1;
    }

    crm_remote_recv(client->remote, -1, &disconnected);

    request = crm_remote_parse_buffer(client->remote);
    while (request) {
        crm_element_value_int(request, F_LRMD_REMOTE_MSG_ID, &id);
        crm_trace(""processing request from remote client with remote msg id %d"", id);
        if (!client->name) {
            const char *value = crm_element_value(request, F_LRMD_CLIENTNAME);

            if (value) {
                client->name = strdup(value);
            }
        }

        lrmd_call_id++;
        if (lrmd_call_id < 1) {
            lrmd_call_id = 1;
        }

        crm_xml_add(request, F_LRMD_CLIENTID, client->id);
        crm_xml_add(request, F_LRMD_CLIENTNAME, client->name);
        crm_xml_add_int(request, F_LRMD_CALLID, lrmd_call_id);

        process_lrmd_message(client, id, request);
        free_xml(request);

        /* process all the messages in the current buffer */
        request = crm_remote_parse_buffer(client->remote);
    }

    if (disconnected) {
        crm_info(""Client disconnect detected in tls msg dispatcher."");
        return -1;
    }

    return 0;
}
","lrmd_remote_client_msg(gpointer data)
{
    int id = 0;
    int rc = 0;
    int disconnected = 0;
    xmlNode *request = NULL;
    crm_client_t *client = data;

    if (client->remote->tls_handshake_complete == FALSE) {
        int rc = 0;

        /* Muliple calls to handshake will be required, this callback
         * will be invoked once the client sends more handshake data. */
        do {
            rc = gnutls_handshake(*client->remote->tls_session);

            if (rc < 0 && rc != GNUTLS_E_AGAIN) {
                crm_err(""Remote lrmd tls handshake failed"");
                return -1;
            }
        } while (rc == GNUTLS_E_INTERRUPTED);

        if (rc == 0) {
            crm_debug(""Remote lrmd tls handshake completed"");
            client->remote->tls_handshake_complete = TRUE;
            if (client->remote->auth_timeout) {
                 g_source_remove(client->remote->auth_timeout);
             }
             client->remote->auth_timeout = 0;
         }
         return 0;
     }

    rc = crm_remote_ready(client->remote, 0);
    if (rc == 0) {
        /* no msg to read */
        return 0;
    } else if (rc < 0) {
        crm_info(""Client disconnected during remote client read"");
        return -1;
    }

    crm_remote_recv(client->remote, -1, &disconnected);

    request = crm_remote_parse_buffer(client->remote);
    while (request) {
        crm_element_value_int(request, F_LRMD_REMOTE_MSG_ID, &id);
        crm_trace(""processing request from remote client with remote msg id %d"", id);
        if (!client->name) {
            const char *value = crm_element_value(request, F_LRMD_CLIENTNAME);

            if (value) {
                client->name = strdup(value);
            }
        }

        lrmd_call_id++;
        if (lrmd_call_id < 1) {
            lrmd_call_id = 1;
        }

        crm_xml_add(request, F_LRMD_CLIENTID, client->id);
        crm_xml_add(request, F_LRMD_CLIENTNAME, client->name);
        crm_xml_add_int(request, F_LRMD_CALLID, lrmd_call_id);

        process_lrmd_message(client, id, request);
        free_xml(request);

        /* process all the messages in the current buffer */
        request = crm_remote_parse_buffer(client->remote);
    }

    if (disconnected) {
        crm_info(""Client disconnect detected in tls msg dispatcher."");
        return -1;
    }

    return 0;
}
",C,"
            /* Alert other clients of the new connection */
            notify_of_new_client(client);
",,,"@@ -79,6 +79,9 @@ lrmd_remote_client_msg(gpointer data)
                 g_source_remove(client->remote->auth_timeout);
             }
             client->remote->auth_timeout = 0;
+
+            /* Alert other clients of the new connection */
+            notify_of_new_client(client);
         }
         return 0;
     }
@@ -289,8 +292,6 @@ lrmd_remote_listen(gpointer data)
                         &lrmd_remote_fd_cb);
     g_hash_table_insert(client_connections, new_client->id, new_client);
 
-    /* Alert other clients of the new connection */
-    notify_of_new_client(new_client);
     return TRUE;
 }
 ",pacemaker,5ec24a2642bd0854b884d1a9b51d12371373b410,a5df52a28ed4a5f544ec4542cc6e542127886d0f,1,"lrmd_remote_client_msg(gpointer data)
{
    int id = 0;
    int rc = 0;
    int disconnected = 0;
    xmlNode *request = NULL;
    crm_client_t *client = data;

    if (client->remote->tls_handshake_complete == FALSE) {
        int rc = 0;

        /* Muliple calls to handshake will be required, this callback
         * will be invoked once the client sends more handshake data. */
        do {
            rc = gnutls_handshake(*client->remote->tls_session);

            if (rc < 0 && rc != GNUTLS_E_AGAIN) {
                crm_err(""Remote lrmd tls handshake failed"");
                return -1;
            }
        } while (rc == GNUTLS_E_INTERRUPTED);

        if (rc == 0) {
            crm_debug(""Remote lrmd tls handshake completed"");
            client->remote->tls_handshake_complete = TRUE;
            if (client->remote->auth_timeout) {
                 g_source_remove(client->remote->auth_timeout);
             }
             client->remote->auth_timeout = 0;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//            /* Alert other clients of the new connection */
//fix_flaw_line_below:
//            notify_of_new_client(client);
         }
         return 0;
     }

    rc = crm_remote_ready(client->remote, 0);
    if (rc == 0) {
        /* no msg to read */
        return 0;
    } else if (rc < 0) {
        crm_info(""Client disconnected during remote client read"");
        return -1;
    }

    crm_remote_recv(client->remote, -1, &disconnected);

    request = crm_remote_parse_buffer(client->remote);
    while (request) {
        crm_element_value_int(request, F_LRMD_REMOTE_MSG_ID, &id);
        crm_trace(""processing request from remote client with remote msg id %d"", id);
        if (!client->name) {
            const char *value = crm_element_value(request, F_LRMD_CLIENTNAME);

            if (value) {
                client->name = strdup(value);
            }
        }

        lrmd_call_id++;
        if (lrmd_call_id < 1) {
            lrmd_call_id = 1;
        }

        crm_xml_add(request, F_LRMD_CLIENTID, client->id);
        crm_xml_add(request, F_LRMD_CLIENTNAME, client->name);
        crm_xml_add_int(request, F_LRMD_CALLID, lrmd_call_id);

        process_lrmd_message(client, id, request);
        free_xml(request);

        /* process all the messages in the current buffer */
        request = crm_remote_parse_buffer(client->remote);
    }

    if (disconnected) {
        crm_info(""Client disconnect detected in tls msg dispatcher."");
        return -1;
    }

    return 0;
}
"
4221,181957,,Remote,Not required,Partial,CVE-2016-7797,https://www.cvedetails.com/cve/CVE-2016-7797/,CWE-254,Low,,,,2017-03-24,5.0,"Pacemaker before 1.1.15, when using pacemaker remote, might allow remote attackers to cause a denial of service (node disconnection) via an unauthenticated connection.",2018-10-30,DoS ,0,https://github.com/ClusterLabs/pacemaker/commit/5ec24a2642bd0854b884d1a9b51d12371373b410,5ec24a2642bd0854b884d1a9b51d12371373b410,Fix: remote: cl#5269 - Notify other clients of a new connection only if the handshake has completed (bsc#967388),2,lrmd/tls_backend.c,"{""sha"": ""0e0782869a9068d72fc1609cc2bfab3da39041c1"", ""filename"": ""lrmd/tls_backend.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/ClusterLabs/pacemaker/blob/5ec24a2642bd0854b884d1a9b51d12371373b410/lrmd/tls_backend.c"", ""raw_url"": ""https://github.com/ClusterLabs/pacemaker/raw/5ec24a2642bd0854b884d1a9b51d12371373b410/lrmd/tls_backend.c"", ""contents_url"": ""https://api.github.com/repos/ClusterLabs/pacemaker/contents/lrmd/tls_backend.c?ref=5ec24a2642bd0854b884d1a9b51d12371373b410"", ""patch"": ""@@ -79,6 +79,9 @@ lrmd_remote_client_msg(gpointer data)\n                 g_source_remove(client->remote->auth_timeout);\n             }\n             client->remote->auth_timeout = 0;\n+\n+            /* Alert other clients of the new connection */\n+            notify_of_new_client(client);\n         }\n         return 0;\n     }\n@@ -289,8 +292,6 @@ lrmd_remote_listen(gpointer data)\n                         &lrmd_remote_fd_cb);\n     g_hash_table_insert(client_connections, new_client->id, new_client);\n \n-    /* Alert other clients of the new connection */\n-    notify_of_new_client(new_client);\n     return TRUE;\n }\n ""}","lrmd_remote_listen(gpointer data)
{
    int csock = 0;
    int flag = 0;
    unsigned laddr = 0;
    struct sockaddr addr;
    gnutls_session_t *session = NULL;
    crm_client_t *new_client = NULL;

    static struct mainloop_fd_callbacks lrmd_remote_fd_cb = {
        .dispatch = lrmd_remote_client_msg,
        .destroy = lrmd_remote_client_destroy,
    };

    laddr = sizeof(addr);
    memset(&addr, 0, sizeof(addr));
    getsockname(ssock, &addr, &laddr);

    /* accept the connection */

    if (addr.sa_family == AF_INET6) {
        struct sockaddr_in6 sa;
        char addr_str[INET6_ADDRSTRLEN];

        laddr = sizeof(sa);
        memset(&sa, 0, sizeof(sa));
        csock = accept(ssock, &sa, &laddr);
        get_ip_str((struct sockaddr *)&sa, addr_str, INET6_ADDRSTRLEN);
        crm_info(""New remote connection from %s"", addr_str);

    } else {
        struct sockaddr_in sa;
        char addr_str[INET_ADDRSTRLEN];

        laddr = sizeof(sa);
        memset(&sa, 0, sizeof(sa));
        csock = accept(ssock, &sa, &laddr);
        get_ip_str((struct sockaddr *)&sa, addr_str, INET_ADDRSTRLEN);
        crm_info(""New remote connection from %s"", addr_str);
    }

    if (csock == -1) {
        crm_err(""accept socket failed"");
        return TRUE;
    }

    if ((flag = fcntl(csock, F_GETFL)) >= 0) {
        if (fcntl(csock, F_SETFL, flag | O_NONBLOCK) < 0) {
            crm_err(""fcntl() write failed"");
            close(csock);
            return TRUE;
        }
    } else {
        crm_err(""fcntl() read failed"");
        close(csock);
        return TRUE;
    }

    session = create_psk_tls_session(csock, GNUTLS_SERVER, psk_cred_s);
    if (session == NULL) {
        crm_err(""TLS session creation failed"");
        close(csock);
        return TRUE;
    }

    new_client = calloc(1, sizeof(crm_client_t));
    new_client->remote = calloc(1, sizeof(crm_remote_t));
    new_client->kind = CRM_CLIENT_TLS;
    new_client->remote->tls_session = session;
    new_client->id = crm_generate_uuid();
    new_client->remote->auth_timeout =
        g_timeout_add(LRMD_REMOTE_AUTH_TIMEOUT, lrmd_auth_timeout_cb, new_client);
    crm_notice(""LRMD client connection established. %p id: %s"", new_client, new_client->id);

    new_client->remote->source =
        mainloop_add_fd(""lrmd-remote-client"", G_PRIORITY_DEFAULT, csock, new_client,
                         &lrmd_remote_fd_cb);
     g_hash_table_insert(client_connections, new_client->id, new_client);
 
     return TRUE;
 }
","lrmd_remote_listen(gpointer data)
{
    int csock = 0;
    int flag = 0;
    unsigned laddr = 0;
    struct sockaddr addr;
    gnutls_session_t *session = NULL;
    crm_client_t *new_client = NULL;

    static struct mainloop_fd_callbacks lrmd_remote_fd_cb = {
        .dispatch = lrmd_remote_client_msg,
        .destroy = lrmd_remote_client_destroy,
    };

    laddr = sizeof(addr);
    memset(&addr, 0, sizeof(addr));
    getsockname(ssock, &addr, &laddr);

    /* accept the connection */

    if (addr.sa_family == AF_INET6) {
        struct sockaddr_in6 sa;
        char addr_str[INET6_ADDRSTRLEN];

        laddr = sizeof(sa);
        memset(&sa, 0, sizeof(sa));
        csock = accept(ssock, &sa, &laddr);
        get_ip_str((struct sockaddr *)&sa, addr_str, INET6_ADDRSTRLEN);
        crm_info(""New remote connection from %s"", addr_str);

    } else {
        struct sockaddr_in sa;
        char addr_str[INET_ADDRSTRLEN];

        laddr = sizeof(sa);
        memset(&sa, 0, sizeof(sa));
        csock = accept(ssock, &sa, &laddr);
        get_ip_str((struct sockaddr *)&sa, addr_str, INET_ADDRSTRLEN);
        crm_info(""New remote connection from %s"", addr_str);
    }

    if (csock == -1) {
        crm_err(""accept socket failed"");
        return TRUE;
    }

    if ((flag = fcntl(csock, F_GETFL)) >= 0) {
        if (fcntl(csock, F_SETFL, flag | O_NONBLOCK) < 0) {
            crm_err(""fcntl() write failed"");
            close(csock);
            return TRUE;
        }
    } else {
        crm_err(""fcntl() read failed"");
        close(csock);
        return TRUE;
    }

    session = create_psk_tls_session(csock, GNUTLS_SERVER, psk_cred_s);
    if (session == NULL) {
        crm_err(""TLS session creation failed"");
        close(csock);
        return TRUE;
    }

    new_client = calloc(1, sizeof(crm_client_t));
    new_client->remote = calloc(1, sizeof(crm_remote_t));
    new_client->kind = CRM_CLIENT_TLS;
    new_client->remote->tls_session = session;
    new_client->id = crm_generate_uuid();
    new_client->remote->auth_timeout =
        g_timeout_add(LRMD_REMOTE_AUTH_TIMEOUT, lrmd_auth_timeout_cb, new_client);
    crm_notice(""LRMD client connection established. %p id: %s"", new_client, new_client->id);

    new_client->remote->source =
        mainloop_add_fd(""lrmd-remote-client"", G_PRIORITY_DEFAULT, csock, new_client,
                         &lrmd_remote_fd_cb);
     g_hash_table_insert(client_connections, new_client->id, new_client);
 
    /* Alert other clients of the new connection */
    notify_of_new_client(new_client);
     return TRUE;
 }
",C,,"    /* Alert other clients of the new connection */
    notify_of_new_client(new_client);
",,"@@ -79,6 +79,9 @@ lrmd_remote_client_msg(gpointer data)
                 g_source_remove(client->remote->auth_timeout);
             }
             client->remote->auth_timeout = 0;
+
+            /* Alert other clients of the new connection */
+            notify_of_new_client(client);
         }
         return 0;
     }
@@ -289,8 +292,6 @@ lrmd_remote_listen(gpointer data)
                         &lrmd_remote_fd_cb);
     g_hash_table_insert(client_connections, new_client->id, new_client);
 
-    /* Alert other clients of the new connection */
-    notify_of_new_client(new_client);
     return TRUE;
 }
 ",pacemaker,5ec24a2642bd0854b884d1a9b51d12371373b410,a5df52a28ed4a5f544ec4542cc6e542127886d0f,1,"lrmd_remote_listen(gpointer data)
{
    int csock = 0;
    int flag = 0;
    unsigned laddr = 0;
    struct sockaddr addr;
    gnutls_session_t *session = NULL;
    crm_client_t *new_client = NULL;

    static struct mainloop_fd_callbacks lrmd_remote_fd_cb = {
        .dispatch = lrmd_remote_client_msg,
        .destroy = lrmd_remote_client_destroy,
    };

    laddr = sizeof(addr);
    memset(&addr, 0, sizeof(addr));
    getsockname(ssock, &addr, &laddr);

    /* accept the connection */

    if (addr.sa_family == AF_INET6) {
        struct sockaddr_in6 sa;
        char addr_str[INET6_ADDRSTRLEN];

        laddr = sizeof(sa);
        memset(&sa, 0, sizeof(sa));
        csock = accept(ssock, &sa, &laddr);
        get_ip_str((struct sockaddr *)&sa, addr_str, INET6_ADDRSTRLEN);
        crm_info(""New remote connection from %s"", addr_str);

    } else {
        struct sockaddr_in sa;
        char addr_str[INET_ADDRSTRLEN];

        laddr = sizeof(sa);
        memset(&sa, 0, sizeof(sa));
        csock = accept(ssock, &sa, &laddr);
        get_ip_str((struct sockaddr *)&sa, addr_str, INET_ADDRSTRLEN);
        crm_info(""New remote connection from %s"", addr_str);
    }

    if (csock == -1) {
        crm_err(""accept socket failed"");
        return TRUE;
    }

    if ((flag = fcntl(csock, F_GETFL)) >= 0) {
        if (fcntl(csock, F_SETFL, flag | O_NONBLOCK) < 0) {
            crm_err(""fcntl() write failed"");
            close(csock);
            return TRUE;
        }
    } else {
        crm_err(""fcntl() read failed"");
        close(csock);
        return TRUE;
    }

    session = create_psk_tls_session(csock, GNUTLS_SERVER, psk_cred_s);
    if (session == NULL) {
        crm_err(""TLS session creation failed"");
        close(csock);
        return TRUE;
    }

    new_client = calloc(1, sizeof(crm_client_t));
    new_client->remote = calloc(1, sizeof(crm_remote_t));
    new_client->kind = CRM_CLIENT_TLS;
    new_client->remote->tls_session = session;
    new_client->id = crm_generate_uuid();
    new_client->remote->auth_timeout =
        g_timeout_add(LRMD_REMOTE_AUTH_TIMEOUT, lrmd_auth_timeout_cb, new_client);
    crm_notice(""LRMD client connection established. %p id: %s"", new_client, new_client->id);

    new_client->remote->source =
        mainloop_add_fd(""lrmd-remote-client"", G_PRIORITY_DEFAULT, csock, new_client,
                         &lrmd_remote_fd_cb);
     g_hash_table_insert(client_connections, new_client->id, new_client);
 
//flaw_line_below:
    /* Alert other clients of the new connection */
//flaw_line_below:
    notify_of_new_client(new_client);
     return TRUE;
 }
"
4264,182000,,Remote,Not required,,CVE-2016-6271,https://www.cvedetails.com/cve/CVE-2016-6271/,CWE-254,Low,,Partial,,2017-01-18,5.0,The Bzrtp library (aka libbzrtp) 1.0.x before 1.0.4 allows man-in-the-middle attackers to conduct spoofing attacks by leveraging a missing HVI check on DHPart2 packet reception.,2017-08-02,,27,https://github.com/BelledonneCommunications/bzrtp/commit/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,Add ZRTP Commit packet hvi check on DHPart2 packet reception,1,src/packetParser.c,"{""sha"": ""95ec6d5ef51cd2f1288e74d8798b1b930db1332c"", ""filename"": ""include/packetParser.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/BelledonneCommunications/bzrtp/blob/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/include/packetParser.h"", ""raw_url"": ""https://github.com/BelledonneCommunications/bzrtp/raw/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/include/packetParser.h"", ""contents_url"": ""https://api.github.com/repos/BelledonneCommunications/bzrtp/contents/include/packetParser.h?ref=bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b"", ""patch"": ""@@ -42,6 +42,7 @@\n #define\t\tBZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN\t0xa080\n #define\t\tBZRTP_PARSER_ERROR_UNMATCHINGMAC\t\t0xa100\n #define\t\tBZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE\t0xa200\n+#define\t\tBZRTP_PARSER_ERROR_UNMATCHINGHVI\t\t0xa400\n \n #define\t\tBZRTP_BUILDER_ERROR_INVALIDPACKET\t\t0x5001\n #define\t\tBZRTP_BUILDER_ERROR_INVALIDMESSAGE\t\t0x5002""}<_**next**_>{""sha"": ""2ca5cdb67005a166d05e23ac588d674a7aa4f9bf"", ""filename"": ""src/packetParser.c"", ""status"": ""modified"", ""additions"": 27, ""deletions"": 1, ""changes"": 28, ""blob_url"": ""https://github.com/BelledonneCommunications/bzrtp/blob/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/src/packetParser.c"", ""raw_url"": ""https://github.com/BelledonneCommunications/bzrtp/raw/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/src/packetParser.c"", ""contents_url"": ""https://api.github.com/repos/BelledonneCommunications/bzrtp/contents/src/packetParser.c?ref=bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b"", ""patch"": ""@@ -438,6 +438,32 @@ int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpC\n \t\t\t\t\t\tfree (messageData);\n \t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n \t\t\t\t\t}\n+\n+\t\t\t\t\t/* Check the hvi received in the commit message  - RFC section 4.4.1.1*/\n+\t\t\t\t\t/* First compute the expected hvi */\n+\t\t\t\t\t/* hvi = hash(initiator's DHPart2 message(current zrtpPacket)) || responder's Hello message) using the agreed hash function truncated to 256 bits */\n+\t\t\t\t\t/* create a string with the messages concatenated */\n+\t\t\t\t\t{\n+\t\t\t\t\t\tuint8_t computedHvi[32];\n+\t\t\t\t\t\tuint16_t HelloMessageLength = zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;\n+\t\t\t\t\t\tuint16_t DHPartHelloMessageStringLength = zrtpPacket->messageLength + HelloMessageLength;\n+\n+\t\t\t\t\t\tuint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));\n+\n+\t\t\t\t\t\tmemcpy(DHPartHelloMessageString, input+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength);\n+\t\t\t\t\t\tmemcpy(DHPartHelloMessageString+zrtpPacket->messageLength, zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);\n+\n+\t\t\t\t\t\tzrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, computedHvi);\n+\n+\t\t\t\t\t\tfree(DHPartHelloMessageString);\n+\n+\t\t\t\t\t\t/* Compare computed and received hvi */\n+\t\t\t\t\t\tif (memcmp(computedHvi, peerCommitMessageData->hvi, 32)!=0) {\n+\t\t\t\t\t\t\tfree (messageData);\n+\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHVI;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n \t\t\t\t} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */\n \t\t\t\t\tuint8_t checkH2[32];\n \t\t\t\t\tuint8_t checkH3[32];\n@@ -482,7 +508,7 @@ int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpC\n \t\t\t\t/* attach the message structure to the packet one */\n \t\t\t\tzrtpPacket->messageData = (void *)messageData;\n \n-\t\t\t\t/* the parsed commit packet must be saved as it is used to generate the total_hash */\n+\t\t\t\t/* the parsed packet must be saved as it is used to generate the total_hash */\n \t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n \t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n \t\t\t}""}<_**next**_>{""sha"": ""faa1b8ce0edc5ba51d51e658e291915659f56089"", ""filename"": ""test/bzrtpParserTest.c"", ""status"": ""modified"", ""additions"": 49, ""deletions"": 2, ""changes"": 51, ""blob_url"": ""https://github.com/BelledonneCommunications/bzrtp/blob/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpParserTest.c"", ""raw_url"": ""https://github.com/BelledonneCommunications/bzrtp/raw/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpParserTest.c"", ""contents_url"": ""https://api.github.com/repos/BelledonneCommunications/bzrtp/contents/test/bzrtpParserTest.c?ref=bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b"", ""patch"": ""@@ -101,7 +101,8 @@ uint8_t mackeyr[32] = {0x3a, 0xa5, 0x22, 0x43, 0x26, 0x13, 0x8f, 0xd6, 0x54, 0x5\n uint8_t zrtpkeyi[16] = {0x22, 0xf6, 0xea, 0xaa, 0xa4, 0xad, 0x53, 0x30, 0x71, 0x97, 0xcc, 0x68, 0x6b, 0xb0, 0xcb, 0x55};\n uint8_t zrtpkeyr[16] = {0x09, 0x50, 0xcd, 0x9e, 0xc2, 0x78, 0x54, 0x31, 0x93, 0x2e, 0x99, 0x31, 0x15, 0x58, 0xd0, 0x2a};\n \n-void test_parser(void) {\n+\n+void test_parser_param(uint8_t hvi_trick) {\n \tint i, retval;\n \tbzrtpPacket_t *zrtpPacket;\n \n@@ -159,13 +160,34 @@ void test_parser(void) {\n \t\t/* parse a packet string from patterns */\n \t\tzrtpPacket = bzrtp_packetCheck(patternZRTPPackets[i], patternZRTPMetaData[i][0], (patternZRTPMetaData[i][1])-1, &retval);\n \t\tretval +=  bzrtp_packetParser((patternZRTPMetaData[i][2]==0x87654321)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x87654321)?context12345678->channelContext[0]:context87654321->channelContext[0], patternZRTPPackets[i], patternZRTPMetaData[i][0], zrtpPacket);\n-\t\t/*printf(\""parsing Ret val is %x index is %d\\n\"", retval, i);*/\n+\t\tif (hvi_trick==0) {\n+\t\t\tCU_ASSERT_EQUAL_FATAL(retval,0);\n+\t\t} else { /* when hvi trick is enable, the DH2 parsing shall fail and return BZRTP_PARSER_ERROR_UNMATCHINGHVI */\n+\t\t\tif (zrtpPacket->messageType==MSGTYPE_DHPART2) {\n+\t\t\t\tCU_ASSERT_EQUAL_FATAL(retval, BZRTP_PARSER_ERROR_UNMATCHINGHVI);\n+\t\t\t\t/* We shall then anyway skip the end of the test */\n+\t\t\t\t/* reset pointers to selfHello packet in order to avoid double free */\n+\t\t\t\tcontext87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;\n+\t\t\t\tcontext12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;\n+\n+\t\t\t\tbzrtp_destroyBzrtpContext(context87654321, 0x87654321);\n+\t\t\t\tbzrtp_destroyBzrtpContext(context12345678, 0x12345678);\n+\n+\t\t\t\treturn;\n+\n+\t\t\t} else {\n+\t\t\t\tCU_ASSERT_EQUAL_FATAL(retval,0);\n+\t\t\t}\n+\t\t}\n+\t\t\tbzrtp_message(\""parsing Ret val is %x index is %d\\n\"", retval, i);\n \t\t/* We must store some packets in the context if we want to be able to parse further packets */\n \t\tif (zrtpPacket->messageType==MSGTYPE_HELLO) {\n \t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n \t\t\t\tcontext12345678->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n+\t\t\t\tcontext87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n \t\t\t} else {\n \t\t\t\tcontext87654321->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n+\t\t\t\tcontext12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n \t\t\t}\n \t\t\tfreePacketFlag = 0;\n \t\t}\n@@ -205,13 +227,38 @@ void test_parser(void) {\n \t\tif (freePacketFlag == 1) {\n \t\t\tbzrtp_freeZrtpPacket(zrtpPacket);\n \t\t}\n+\n+\t\t/* modify the hvi stored in the peerPackets, this shall result in parsing failure on DH2 packet */\n+\t\tif (hvi_trick == 1) {\n+\t\t\tif (zrtpPacket->messageType==MSGTYPE_COMMIT) {\n+\t\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n+\t\t\t\t\tbzrtpCommitMessage_t *peerCommitMessageData;\n+\t\t\t\t\tpeerCommitMessageData = (bzrtpCommitMessage_t *)zrtpPacket->messageData;\n+\t\t\t\t\tpeerCommitMessageData->hvi[0]=0xFF;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n \t}\n \n+\t/* reset pointers to selfHello packet in order to avoid double free */\n+\tcontext87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;\n+\tcontext12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;\n+\n+\n \tbzrtp_destroyBzrtpContext(context87654321, 0x87654321);\n \tbzrtp_destroyBzrtpContext(context12345678, 0x12345678);\n \n }\n \n+void test_parser(void) {\n+\ttest_parser_param(0);\n+}\n+\n+void test_parser_hvi(void) {\n+\ttest_parser_param(1);\n+}\n+\n /* context structure mainly used by statemachine test, but also needed by parserComplete to get the zid Filename */\n typedef struct my_Context_struct {\n \tunsigned char nom[30]; /* nom du contexte */""}<_**next**_>{""sha"": ""74548f2c2b41187c4d83dce2dc206a710c33d77f"", ""filename"": ""test/bzrtpParserTest.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/BelledonneCommunications/bzrtp/blob/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpParserTest.h"", ""raw_url"": ""https://github.com/BelledonneCommunications/bzrtp/raw/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpParserTest.h"", ""contents_url"": ""https://api.github.com/repos/BelledonneCommunications/bzrtp/contents/test/bzrtpParserTest.h?ref=bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b"", ""patch"": ""@@ -20,5 +20,6 @@\n  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n  */\n void test_parser(void);\n+void test_parser_hvi(void);\n void test_parserComplete(void);\n void test_stateMachine(void);""}<_**next**_>{""sha"": ""a9fa90f94a9525d8a131369ac1dbc4fcf7ad780d"", ""filename"": ""test/bzrtpTest.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/BelledonneCommunications/bzrtp/blob/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpTest.c"", ""raw_url"": ""https://github.com/BelledonneCommunications/bzrtp/raw/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpTest.c"", ""contents_url"": ""https://api.github.com/repos/BelledonneCommunications/bzrtp/contents/test/bzrtpTest.c?ref=bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b"", ""patch"": ""@@ -75,6 +75,7 @@ int main(int argc, char *argv[] ) {\n \t/* Add the parser suite to the registry */\n \tparserTestSuite = CU_add_suite(\""Bzrtp ZRTP Packet Parser\"", NULL, NULL);\n \tCU_add_test(parserTestSuite, \""Parse\"", test_parser);\n+\tCU_add_test(parserTestSuite, \""Parse hvi check fail\"", test_parser_hvi);\n \tCU_add_test(parserTestSuite, \""Parse Exchange\"", test_parserComplete);\n \tCU_add_test(parserTestSuite, \""State machine\"", test_stateMachine);\n ""}","int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, const uint8_t * input, uint16_t inputLength, bzrtpPacket_t *zrtpPacket) {

	int i;

	/* now allocate and fill the correct message structure according to the message type */
	/* messageContent points to the begining of the ZRTP message */
	uint8_t *messageContent = (uint8_t *)(input+ZRTP_PACKET_HEADER_LENGTH+ZRTP_MESSAGE_HEADER_LENGTH);

	switch (zrtpPacket->messageType) {
		case MSGTYPE_HELLO : 
			{
				/* allocate a Hello message structure */
				bzrtpHelloMessage_t *messageData;
				messageData = (bzrtpHelloMessage_t *)malloc(sizeof(bzrtpHelloMessage_t));

				/* fill it */
				memcpy(messageData->version, messageContent, 4);
				messageContent +=4;
				memcpy(messageData->clientIdentifier, messageContent, 16);
				messageContent +=16;
				memcpy(messageData->H3, messageContent, 32);
				messageContent +=32;
				memcpy(messageData->ZID, messageContent, 12);
				messageContent +=12;
				messageData->S = ((*messageContent)>>6)&0x01;
				messageData->M = ((*messageContent)>>5)&0x01;
				messageData->P = ((*messageContent)>>4)&0x01;
				messageContent +=1;
				messageData->hc = MIN((*messageContent)&0x0F, 7);
				messageContent +=1;
				messageData->cc = MIN(((*messageContent)>>4)&0x0F, 7);
				messageData->ac = MIN((*messageContent)&0x0F, 7);
				messageContent +=1;
				messageData->kc = MIN(((*messageContent)>>4)&0x0F, 7);
				messageData->sc = MIN((*messageContent)&0x0F, 7);
				messageContent +=1;

				/* Check message length according to value in hc, cc, ac, kc and sc */
				if (zrtpPacket->messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4*((uint16_t)(messageData->hc)+(uint16_t)(messageData->cc)+(uint16_t)(messageData->ac)+(uint16_t)(messageData->kc)+(uint16_t)(messageData->sc))) {
					free(messageData);
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}

				/* parse the variable length part: algorithms types */
				for (i=0; i<messageData->hc; i++) {
					messageData->supportedHash[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->cc; i++) {
					messageData->supportedCipher[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->ac; i++) {
					messageData->supportedAuthTag[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->kc; i++) {
					messageData->supportedKeyAgreement[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->sc; i++) {
					messageData->supportedSas[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);
					messageContent +=4;
				}

				addMandatoryCryptoTypesIfNeeded(ZRTP_HASH_TYPE, messageData->supportedHash, &messageData->hc);
				addMandatoryCryptoTypesIfNeeded(ZRTP_CIPHERBLOCK_TYPE, messageData->supportedCipher, &messageData->cc);
				addMandatoryCryptoTypesIfNeeded(ZRTP_AUTHTAG_TYPE, messageData->supportedAuthTag, &messageData->ac);
				addMandatoryCryptoTypesIfNeeded(ZRTP_KEYAGREEMENT_TYPE, messageData->supportedKeyAgreement, &messageData->kc);
				addMandatoryCryptoTypesIfNeeded(ZRTP_SAS_TYPE, messageData->supportedSas, &messageData->sc);

				memcpy(messageData->MAC, messageContent, 8);
				
				/* attach the message structure to the packet one */
				zrtpPacket->messageData = (void *)messageData;

				/* the parsed Hello packet must be saved as it may be used to generate commit message or the total_hash */
				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */
			}
			break; /* MSGTYPE_HELLO */

		case MSGTYPE_HELLOACK :
			{
				/* check message length */
				if (zrtpPacket->messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH) {
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}


			}
			break; /* MSGTYPE_HELLOACK */

		case MSGTYPE_COMMIT:
			{
				uint8_t checkH3[32];
				uint8_t checkMAC[32];
				bzrtpHelloMessage_t *peerHelloMessageData;
				uint16_t variableLength = 0;

				/* allocate a commit message structure */
				bzrtpCommitMessage_t *messageData;
				messageData = (bzrtpCommitMessage_t *)malloc(sizeof(bzrtpCommitMessage_t));

				/* fill the structure */
				memcpy(messageData->H2, messageContent, 32);
				messageContent +=32;

				/* We have now H2, check it matches the H3 we had in the hello message H3=SHA256(H2) and that the Hello message MAC is correct */
				if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
					free (messageData);
					/* we have no Hello message in this channel, this commit shall never have arrived, discard it as invalid */
					return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
				}
				peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
				/* Check H3 = SHA256(H2) */
				bctoolbox_sha256(messageData->H2, 32, 32, checkH3);
				if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
					free (messageData);
					return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
				}
				/* Check the hello MAC message. 
				 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
				bctoolbox_hmacSha256(messageData->H2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
				if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
					free (messageData);
					return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
				}

				memcpy(messageData->ZID, messageContent, 12);
				messageContent +=12;
				messageData->hashAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);
				messageContent += 4;
				messageData->cipherAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);
				messageContent += 4;
				messageData->authTagAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);
				messageContent += 4;
				messageData->keyAgreementAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);
				messageContent += 4;
				/* commit message length depends on the key agreement type choosen (and set in the zrtpContext->keyAgreementAlgo) */
				switch(messageData->keyAgreementAlgo) {
					case ZRTP_KEYAGREEMENT_DH2k :
					case ZRTP_KEYAGREEMENT_EC25 :
					case ZRTP_KEYAGREEMENT_DH3k :
					case ZRTP_KEYAGREEMENT_EC38 :
					case ZRTP_KEYAGREEMENT_EC52 :
						variableLength = 32; /* hvi is 32 bytes length in DH Commit message format */
						break;
					case ZRTP_KEYAGREEMENT_Prsh :
						variableLength = 24; /* nonce (16 bytes) and keyID(8 bytes) are 24 bytes length in preshared Commit message format */
						break;
					case ZRTP_KEYAGREEMENT_Mult :
						variableLength = 16; /* nonce is 24 bytes length in multistream Commit message format */
						break;
					default:
						free(messageData);
						return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}

				if (zrtpPacket->messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength) {
					free(messageData);
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}
				messageData->sasAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);
				messageContent += 4;

				/* if it is a multistream or preshared commit, get the 16 bytes nonce */
				if ((messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) || (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult)) {
					memcpy(messageData->nonce, messageContent, 16);
					messageContent +=16;

					/* and the keyID for preshared commit only */
					if (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) {
						memcpy(messageData->keyID, messageContent, 8);
						messageContent +=8;
					}
				} else { /* it's a DH commit message, get the hvi */
					memcpy(messageData->hvi, messageContent, 32);
					messageContent +=32;
				}

				/* get the MAC and attach the message data to the packet structure */
				memcpy(messageData->MAC, messageContent, 8);
				zrtpPacket->messageData = (void *)messageData;

				/* the parsed commit packet must be saved as it is used to generate the total_hash */
				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */
			}
			break; /* MSGTYPE_COMMIT */
		case MSGTYPE_DHPART1 :
		case MSGTYPE_DHPART2 :
			{
				bzrtpDHPartMessage_t *messageData;

				/*check message length, depends on the selected key agreement algo set in zrtpContext */
				uint16_t pvLength = computeKeyAgreementPrivateValueLength(zrtpChannelContext->keyAgreementAlgo);
				if (pvLength == 0) {
					return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
				}

				if (zrtpPacket->messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH+pvLength) {
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}

				/* allocate a DHPart message structure and pv */
				messageData = (bzrtpDHPartMessage_t *)malloc(sizeof(bzrtpDHPartMessage_t));
				messageData->pv = (uint8_t *)malloc(pvLength*sizeof(uint8_t));

				/* fill the structure */
				memcpy(messageData->H1, messageContent, 32);
				messageContent +=32;

				/* We have now H1, check it matches the H2 we had in the commit message H2=SHA256(H1) and that the Commit message MAC is correct */
				if ( zrtpChannelContext->role == RESPONDER) { /* do it only if we are responder (we received a commit packet) */
					uint8_t checkH2[32];
					uint8_t checkMAC[32];
					bzrtpCommitMessage_t *peerCommitMessageData;

					if (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {
						free (messageData);
						/* we have no Commit message in this channel, this DHPart2 shall never have arrived, discard it as invalid */
						return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
					}
					peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;
					/* Check H2 = SHA256(H1) */
					bctoolbox_sha256(messageData->H1, 32, 32, checkH2);
					if (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
					}
					/* Check the Commit MAC message. 
					 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
					bctoolbox_hmacSha256(messageData->H1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
					if (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {
 						free (messageData);
 						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
 					}

					/* Check the hvi received in the commit message  - RFC section 4.4.1.1*/
					/* First compute the expected hvi */
					/* hvi = hash(initiator's DHPart2 message(current zrtpPacket)) || responder's Hello message) using the agreed hash function truncated to 256 bits */
					/* create a string with the messages concatenated */
					{
						uint8_t computedHvi[32];
						uint16_t HelloMessageLength = zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;
						uint16_t DHPartHelloMessageStringLength = zrtpPacket->messageLength + HelloMessageLength;

						uint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));

						memcpy(DHPartHelloMessageString, input+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength);
						memcpy(DHPartHelloMessageString+zrtpPacket->messageLength, zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);

						zrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, computedHvi);

						free(DHPartHelloMessageString);

						/* Compare computed and received hvi */
						if (memcmp(computedHvi, peerCommitMessageData->hvi, 32)!=0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGHVI;
						}
					}

 				} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */
 					uint8_t checkH2[32];
 					uint8_t checkH3[32];
					uint8_t checkMAC[32];
					bzrtpHelloMessage_t *peerHelloMessageData;

					if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
						free (messageData);
						/* we have no Hello message in this channel, this DHPart1 shall never have arrived, discard it as invalid */
						return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
					}
					peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
					/* Check H3 = SHA256(SHA256(H1)) */
					bctoolbox_sha256(messageData->H1, 32, 32, checkH2);
					bctoolbox_sha256(checkH2, 32, 32, checkH3);
					if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
					}
					/* Check the hello MAC message. 
					 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
					bctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
					if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
					}

				}

				memcpy(messageData->rs1ID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->rs2ID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->auxsecretID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->pbxsecretID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->pv, messageContent, pvLength);
				messageContent +=pvLength;
				memcpy(messageData->MAC, messageContent, 8);

 				/* attach the message structure to the packet one */
 				zrtpPacket->messageData = (void *)messageData;
 
				/* the parsed packet must be saved as it is used to generate the total_hash */
 				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
 				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */
 			}
			break; /* MSGTYPE_DHPART1 and MSGTYPE_DHPART2 */
		case MSGTYPE_CONFIRM1:
		case MSGTYPE_CONFIRM2:
			{
				uint8_t *confirmMessageKey = NULL;
				uint8_t *confirmMessageMacKey = NULL;
				bzrtpConfirmMessage_t *messageData;
				uint16_t cipherTextLength;
				uint8_t computedHmac[8];
				uint8_t *confirmPlainMessageBuffer;
				uint8_t *confirmPlainMessage;

				/* we shall first decrypt and validate the message, check we have the keys to do it */
				if (zrtpChannelContext->role == RESPONDER) { /* responder uses initiator's keys to decrypt */
					if ((zrtpChannelContext->zrtpkeyi == NULL) || (zrtpChannelContext->mackeyi == NULL)) {
						return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
					}
					confirmMessageKey = zrtpChannelContext->zrtpkeyi;
					confirmMessageMacKey = zrtpChannelContext->mackeyi;
				}

				if (zrtpChannelContext->role == INITIATOR) { /* the iniator uses responder's keys to decrypt */
					if ((zrtpChannelContext->zrtpkeyr == NULL) || (zrtpChannelContext->mackeyr == NULL)) {
						return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
					}
					confirmMessageKey = zrtpChannelContext->zrtpkeyr;
					confirmMessageMacKey = zrtpChannelContext->mackeyr;
				}
				
				/* allocate a confirm message structure */
				messageData = (bzrtpConfirmMessage_t *)malloc(sizeof(bzrtpConfirmMessage_t));

				/* get the mac and the IV */
				memcpy(messageData->confirm_mac, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->CFBIV, messageContent, 16);
				messageContent +=16;


				
				/* get the cipher text length */
				cipherTextLength = zrtpPacket->messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24; /* confirm message is header, confirm_mac(8 bytes), CFB IV(16 bytes), encrypted part */

				/* validate the mac over the cipher text */
				zrtpChannelContext->hmacFunction(confirmMessageMacKey, zrtpChannelContext->hashLength, messageContent, cipherTextLength, 8, computedHmac);
				
				if (memcmp(computedHmac, messageData->confirm_mac, 8) != 0) { /* confirm_mac doesn't match */
					free(messageData);
					return BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC;
				}

				/* get plain message */
				confirmPlainMessageBuffer = (uint8_t *)malloc(cipherTextLength*sizeof(uint8_t));
				zrtpChannelContext->cipherDecryptionFunction(confirmMessageKey, messageData->CFBIV, messageContent, cipherTextLength, confirmPlainMessageBuffer);
				confirmPlainMessage = confirmPlainMessageBuffer; /* point into the allocated buffer */

				/* parse it */
				memcpy(messageData->H0, confirmPlainMessage, 32);
				confirmPlainMessage +=33; /* +33 because next 8 bits are unused */

				/* Hash chain checking: if we are in multichannel or shared mode, we had not DHPart and then no H1 */
				if (zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult) {
					/* compute the H1=SHA256(H0) we never received */
					uint8_t checkH1[32];
					bctoolbox_sha256(messageData->H0, 32, 32, checkH1);

					/* if we are responder, we received a commit packet with H2 then check that H2=SHA256(H1) and that the commit message MAC keyed with H1 match */
					if ( zrtpChannelContext->role == RESPONDER) {
						uint8_t checkH2[32];
						uint8_t checkMAC[32];
						bzrtpCommitMessage_t *peerCommitMessageData;

						if (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {
							free (messageData);
							/* we have no Commit message in this channel, this Confirm2 shall never have arrived, discard it as invalid */
							return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
						}
						peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;
						/* Check H2 = SHA256(H1) */
						bctoolbox_sha256(checkH1, 32, 32, checkH2);
						if (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
						}
						/* Check the Commit MAC message. 
						 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
						bctoolbox_hmacSha256(checkH1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
						if (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
						}
					} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */
						uint8_t checkH2[32];
						uint8_t checkH3[32];
						uint8_t checkMAC[32];
						bzrtpHelloMessage_t *peerHelloMessageData;

						if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
							free (messageData);
							/* we have no Hello message in this channel, this Confirm1 shall never have arrived, discard it as invalid */
							return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
						}
						peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
						/* Check H3 = SHA256(SHA256(H1)) */
						bctoolbox_sha256(checkH1, 32, 32, checkH2);
						bctoolbox_sha256(checkH2, 32, 32, checkH3);
						if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
						}
						/* Check the hello MAC message. 
						 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
						bctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
						if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
						}
	
					}
				} else { /* we are in DHM mode */
					/* We have now H0, check it matches the H1 we had in the DHPart message H1=SHA256(H0) and that the DHPart message MAC is correct */
					uint8_t checkH1[32];
					uint8_t checkMAC[32];
					bzrtpDHPartMessage_t *peerDHPartMessageData;

					if (zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID] == NULL) {
						free (messageData);
						/* we have no DHPART message in this channel, this confirm shall never have arrived, discard it as invalid */
						return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
					}
					peerDHPartMessageData = (bzrtpDHPartMessage_t *)zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageData;
					/* Check H1 = SHA256(H0) */
					bctoolbox_sha256(messageData->H0, 32, 32, checkH1);
					if (memcmp(checkH1, peerDHPartMessageData->H1, 32) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
					}
					/* Check the DHPart message. 
					 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
					bctoolbox_hmacSha256(messageData->H0, 32, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
					if (memcmp(checkMAC, peerDHPartMessageData->MAC, 8) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
					}
				}

				messageData->sig_len = ((uint16_t)(confirmPlainMessage[0]&0x01))<<8 | (((uint16_t)confirmPlainMessage[1])&0x00FF);
				confirmPlainMessage += 2;
				messageData->E = ((*confirmPlainMessage)&0x08)>>3;
				messageData->V = ((*confirmPlainMessage)&0x04)>>2;
				messageData->A = ((*confirmPlainMessage)&0x02)>>1;
				messageData->D = (*confirmPlainMessage)&0x01;
				confirmPlainMessage += 1;

				messageData->cacheExpirationInterval = (((uint32_t)confirmPlainMessage[0])<<24) | (((uint32_t)confirmPlainMessage[1])<<16) | (((uint32_t)confirmPlainMessage[2])<<8) | ((uint32_t)confirmPlainMessage[3]);
				confirmPlainMessage += 4;


				/* if sig_len indicate a signature, parse it */
				if (messageData->sig_len>0) {
					memcpy(messageData->signatureBlockType, confirmPlainMessage, 4);
					confirmPlainMessage += 4;
					/* allocate memory for the signature block, sig_len is in words(32 bits) and includes the signature block type word */
					messageData->signatureBlock = (uint8_t *)malloc(4*(messageData->sig_len-1)*sizeof(uint8_t));
					memcpy(messageData->signatureBlock, confirmPlainMessage, 4*(messageData->sig_len-1));
				} else {
					messageData->signatureBlock  = NULL;
				}

				/* free plain buffer */
				free(confirmPlainMessageBuffer);

				/* the parsed commit packet must be saved as it is used to check correct packet repetition */
				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */

				/* attach the message structure to the packet one */
				zrtpPacket->messageData = (void *)messageData;
			}
			break; /* MSGTYPE_CONFIRM1 and MSGTYPE_CONFIRM2 */

		case MSGTYPE_CONF2ACK:
			/* nothing to do for this one */
			break; /* MSGTYPE_CONF2ACK */
		
		case MSGTYPE_PING:
			{
				/* allocate a ping message structure */
				bzrtpPingMessage_t *messageData;
				messageData = (bzrtpPingMessage_t *)malloc(sizeof(bzrtpPingMessage_t));

				/* fill the structure */
				memcpy(messageData->version, messageContent, 4);
				messageContent +=4;
				memcpy(messageData->endpointHash, messageContent, 8);

				/* attach the message structure to the packet one */
				zrtpPacket->messageData = (void *)messageData;
			}
			break; /* MSGTYPE_PING */

	}

	return 0;
}
","int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, const uint8_t * input, uint16_t inputLength, bzrtpPacket_t *zrtpPacket) {

	int i;

	/* now allocate and fill the correct message structure according to the message type */
	/* messageContent points to the begining of the ZRTP message */
	uint8_t *messageContent = (uint8_t *)(input+ZRTP_PACKET_HEADER_LENGTH+ZRTP_MESSAGE_HEADER_LENGTH);

	switch (zrtpPacket->messageType) {
		case MSGTYPE_HELLO : 
			{
				/* allocate a Hello message structure */
				bzrtpHelloMessage_t *messageData;
				messageData = (bzrtpHelloMessage_t *)malloc(sizeof(bzrtpHelloMessage_t));

				/* fill it */
				memcpy(messageData->version, messageContent, 4);
				messageContent +=4;
				memcpy(messageData->clientIdentifier, messageContent, 16);
				messageContent +=16;
				memcpy(messageData->H3, messageContent, 32);
				messageContent +=32;
				memcpy(messageData->ZID, messageContent, 12);
				messageContent +=12;
				messageData->S = ((*messageContent)>>6)&0x01;
				messageData->M = ((*messageContent)>>5)&0x01;
				messageData->P = ((*messageContent)>>4)&0x01;
				messageContent +=1;
				messageData->hc = MIN((*messageContent)&0x0F, 7);
				messageContent +=1;
				messageData->cc = MIN(((*messageContent)>>4)&0x0F, 7);
				messageData->ac = MIN((*messageContent)&0x0F, 7);
				messageContent +=1;
				messageData->kc = MIN(((*messageContent)>>4)&0x0F, 7);
				messageData->sc = MIN((*messageContent)&0x0F, 7);
				messageContent +=1;

				/* Check message length according to value in hc, cc, ac, kc and sc */
				if (zrtpPacket->messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4*((uint16_t)(messageData->hc)+(uint16_t)(messageData->cc)+(uint16_t)(messageData->ac)+(uint16_t)(messageData->kc)+(uint16_t)(messageData->sc))) {
					free(messageData);
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}

				/* parse the variable length part: algorithms types */
				for (i=0; i<messageData->hc; i++) {
					messageData->supportedHash[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->cc; i++) {
					messageData->supportedCipher[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->ac; i++) {
					messageData->supportedAuthTag[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->kc; i++) {
					messageData->supportedKeyAgreement[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->sc; i++) {
					messageData->supportedSas[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);
					messageContent +=4;
				}

				addMandatoryCryptoTypesIfNeeded(ZRTP_HASH_TYPE, messageData->supportedHash, &messageData->hc);
				addMandatoryCryptoTypesIfNeeded(ZRTP_CIPHERBLOCK_TYPE, messageData->supportedCipher, &messageData->cc);
				addMandatoryCryptoTypesIfNeeded(ZRTP_AUTHTAG_TYPE, messageData->supportedAuthTag, &messageData->ac);
				addMandatoryCryptoTypesIfNeeded(ZRTP_KEYAGREEMENT_TYPE, messageData->supportedKeyAgreement, &messageData->kc);
				addMandatoryCryptoTypesIfNeeded(ZRTP_SAS_TYPE, messageData->supportedSas, &messageData->sc);

				memcpy(messageData->MAC, messageContent, 8);
				
				/* attach the message structure to the packet one */
				zrtpPacket->messageData = (void *)messageData;

				/* the parsed Hello packet must be saved as it may be used to generate commit message or the total_hash */
				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */
			}
			break; /* MSGTYPE_HELLO */

		case MSGTYPE_HELLOACK :
			{
				/* check message length */
				if (zrtpPacket->messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH) {
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}


			}
			break; /* MSGTYPE_HELLOACK */

		case MSGTYPE_COMMIT:
			{
				uint8_t checkH3[32];
				uint8_t checkMAC[32];
				bzrtpHelloMessage_t *peerHelloMessageData;
				uint16_t variableLength = 0;

				/* allocate a commit message structure */
				bzrtpCommitMessage_t *messageData;
				messageData = (bzrtpCommitMessage_t *)malloc(sizeof(bzrtpCommitMessage_t));

				/* fill the structure */
				memcpy(messageData->H2, messageContent, 32);
				messageContent +=32;

				/* We have now H2, check it matches the H3 we had in the hello message H3=SHA256(H2) and that the Hello message MAC is correct */
				if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
					free (messageData);
					/* we have no Hello message in this channel, this commit shall never have arrived, discard it as invalid */
					return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
				}
				peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
				/* Check H3 = SHA256(H2) */
				bctoolbox_sha256(messageData->H2, 32, 32, checkH3);
				if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
					free (messageData);
					return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
				}
				/* Check the hello MAC message. 
				 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
				bctoolbox_hmacSha256(messageData->H2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
				if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
					free (messageData);
					return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
				}

				memcpy(messageData->ZID, messageContent, 12);
				messageContent +=12;
				messageData->hashAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);
				messageContent += 4;
				messageData->cipherAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);
				messageContent += 4;
				messageData->authTagAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);
				messageContent += 4;
				messageData->keyAgreementAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);
				messageContent += 4;
				/* commit message length depends on the key agreement type choosen (and set in the zrtpContext->keyAgreementAlgo) */
				switch(messageData->keyAgreementAlgo) {
					case ZRTP_KEYAGREEMENT_DH2k :
					case ZRTP_KEYAGREEMENT_EC25 :
					case ZRTP_KEYAGREEMENT_DH3k :
					case ZRTP_KEYAGREEMENT_EC38 :
					case ZRTP_KEYAGREEMENT_EC52 :
						variableLength = 32; /* hvi is 32 bytes length in DH Commit message format */
						break;
					case ZRTP_KEYAGREEMENT_Prsh :
						variableLength = 24; /* nonce (16 bytes) and keyID(8 bytes) are 24 bytes length in preshared Commit message format */
						break;
					case ZRTP_KEYAGREEMENT_Mult :
						variableLength = 16; /* nonce is 24 bytes length in multistream Commit message format */
						break;
					default:
						free(messageData);
						return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}

				if (zrtpPacket->messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength) {
					free(messageData);
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}
				messageData->sasAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);
				messageContent += 4;

				/* if it is a multistream or preshared commit, get the 16 bytes nonce */
				if ((messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) || (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult)) {
					memcpy(messageData->nonce, messageContent, 16);
					messageContent +=16;

					/* and the keyID for preshared commit only */
					if (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) {
						memcpy(messageData->keyID, messageContent, 8);
						messageContent +=8;
					}
				} else { /* it's a DH commit message, get the hvi */
					memcpy(messageData->hvi, messageContent, 32);
					messageContent +=32;
				}

				/* get the MAC and attach the message data to the packet structure */
				memcpy(messageData->MAC, messageContent, 8);
				zrtpPacket->messageData = (void *)messageData;

				/* the parsed commit packet must be saved as it is used to generate the total_hash */
				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */
			}
			break; /* MSGTYPE_COMMIT */
		case MSGTYPE_DHPART1 :
		case MSGTYPE_DHPART2 :
			{
				bzrtpDHPartMessage_t *messageData;

				/*check message length, depends on the selected key agreement algo set in zrtpContext */
				uint16_t pvLength = computeKeyAgreementPrivateValueLength(zrtpChannelContext->keyAgreementAlgo);
				if (pvLength == 0) {
					return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
				}

				if (zrtpPacket->messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH+pvLength) {
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}

				/* allocate a DHPart message structure and pv */
				messageData = (bzrtpDHPartMessage_t *)malloc(sizeof(bzrtpDHPartMessage_t));
				messageData->pv = (uint8_t *)malloc(pvLength*sizeof(uint8_t));

				/* fill the structure */
				memcpy(messageData->H1, messageContent, 32);
				messageContent +=32;

				/* We have now H1, check it matches the H2 we had in the commit message H2=SHA256(H1) and that the Commit message MAC is correct */
				if ( zrtpChannelContext->role == RESPONDER) { /* do it only if we are responder (we received a commit packet) */
					uint8_t checkH2[32];
					uint8_t checkMAC[32];
					bzrtpCommitMessage_t *peerCommitMessageData;

					if (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {
						free (messageData);
						/* we have no Commit message in this channel, this DHPart2 shall never have arrived, discard it as invalid */
						return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
					}
					peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;
					/* Check H2 = SHA256(H1) */
					bctoolbox_sha256(messageData->H1, 32, 32, checkH2);
					if (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
					}
					/* Check the Commit MAC message. 
					 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
					bctoolbox_hmacSha256(messageData->H1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
					if (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {
 						free (messageData);
 						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
 					}
 				} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */
 					uint8_t checkH2[32];
 					uint8_t checkH3[32];
					uint8_t checkMAC[32];
					bzrtpHelloMessage_t *peerHelloMessageData;

					if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
						free (messageData);
						/* we have no Hello message in this channel, this DHPart1 shall never have arrived, discard it as invalid */
						return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
					}
					peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
					/* Check H3 = SHA256(SHA256(H1)) */
					bctoolbox_sha256(messageData->H1, 32, 32, checkH2);
					bctoolbox_sha256(checkH2, 32, 32, checkH3);
					if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
					}
					/* Check the hello MAC message. 
					 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
					bctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
					if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
					}

				}

				memcpy(messageData->rs1ID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->rs2ID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->auxsecretID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->pbxsecretID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->pv, messageContent, pvLength);
				messageContent +=pvLength;
				memcpy(messageData->MAC, messageContent, 8);

 				/* attach the message structure to the packet one */
 				zrtpPacket->messageData = (void *)messageData;
 
				/* the parsed commit packet must be saved as it is used to generate the total_hash */
 				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
 				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */
 			}
			break; /* MSGTYPE_DHPART1 and MSGTYPE_DHPART2 */
		case MSGTYPE_CONFIRM1:
		case MSGTYPE_CONFIRM2:
			{
				uint8_t *confirmMessageKey = NULL;
				uint8_t *confirmMessageMacKey = NULL;
				bzrtpConfirmMessage_t *messageData;
				uint16_t cipherTextLength;
				uint8_t computedHmac[8];
				uint8_t *confirmPlainMessageBuffer;
				uint8_t *confirmPlainMessage;

				/* we shall first decrypt and validate the message, check we have the keys to do it */
				if (zrtpChannelContext->role == RESPONDER) { /* responder uses initiator's keys to decrypt */
					if ((zrtpChannelContext->zrtpkeyi == NULL) || (zrtpChannelContext->mackeyi == NULL)) {
						return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
					}
					confirmMessageKey = zrtpChannelContext->zrtpkeyi;
					confirmMessageMacKey = zrtpChannelContext->mackeyi;
				}

				if (zrtpChannelContext->role == INITIATOR) { /* the iniator uses responder's keys to decrypt */
					if ((zrtpChannelContext->zrtpkeyr == NULL) || (zrtpChannelContext->mackeyr == NULL)) {
						return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
					}
					confirmMessageKey = zrtpChannelContext->zrtpkeyr;
					confirmMessageMacKey = zrtpChannelContext->mackeyr;
				}
				
				/* allocate a confirm message structure */
				messageData = (bzrtpConfirmMessage_t *)malloc(sizeof(bzrtpConfirmMessage_t));

				/* get the mac and the IV */
				memcpy(messageData->confirm_mac, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->CFBIV, messageContent, 16);
				messageContent +=16;


				
				/* get the cipher text length */
				cipherTextLength = zrtpPacket->messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24; /* confirm message is header, confirm_mac(8 bytes), CFB IV(16 bytes), encrypted part */

				/* validate the mac over the cipher text */
				zrtpChannelContext->hmacFunction(confirmMessageMacKey, zrtpChannelContext->hashLength, messageContent, cipherTextLength, 8, computedHmac);
				
				if (memcmp(computedHmac, messageData->confirm_mac, 8) != 0) { /* confirm_mac doesn't match */
					free(messageData);
					return BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC;
				}

				/* get plain message */
				confirmPlainMessageBuffer = (uint8_t *)malloc(cipherTextLength*sizeof(uint8_t));
				zrtpChannelContext->cipherDecryptionFunction(confirmMessageKey, messageData->CFBIV, messageContent, cipherTextLength, confirmPlainMessageBuffer);
				confirmPlainMessage = confirmPlainMessageBuffer; /* point into the allocated buffer */

				/* parse it */
				memcpy(messageData->H0, confirmPlainMessage, 32);
				confirmPlainMessage +=33; /* +33 because next 8 bits are unused */

				/* Hash chain checking: if we are in multichannel or shared mode, we had not DHPart and then no H1 */
				if (zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult) {
					/* compute the H1=SHA256(H0) we never received */
					uint8_t checkH1[32];
					bctoolbox_sha256(messageData->H0, 32, 32, checkH1);

					/* if we are responder, we received a commit packet with H2 then check that H2=SHA256(H1) and that the commit message MAC keyed with H1 match */
					if ( zrtpChannelContext->role == RESPONDER) {
						uint8_t checkH2[32];
						uint8_t checkMAC[32];
						bzrtpCommitMessage_t *peerCommitMessageData;

						if (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {
							free (messageData);
							/* we have no Commit message in this channel, this Confirm2 shall never have arrived, discard it as invalid */
							return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
						}
						peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;
						/* Check H2 = SHA256(H1) */
						bctoolbox_sha256(checkH1, 32, 32, checkH2);
						if (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
						}
						/* Check the Commit MAC message. 
						 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
						bctoolbox_hmacSha256(checkH1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
						if (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
						}
					} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */
						uint8_t checkH2[32];
						uint8_t checkH3[32];
						uint8_t checkMAC[32];
						bzrtpHelloMessage_t *peerHelloMessageData;

						if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
							free (messageData);
							/* we have no Hello message in this channel, this Confirm1 shall never have arrived, discard it as invalid */
							return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
						}
						peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
						/* Check H3 = SHA256(SHA256(H1)) */
						bctoolbox_sha256(checkH1, 32, 32, checkH2);
						bctoolbox_sha256(checkH2, 32, 32, checkH3);
						if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
						}
						/* Check the hello MAC message. 
						 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
						bctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
						if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
						}
	
					}
				} else { /* we are in DHM mode */
					/* We have now H0, check it matches the H1 we had in the DHPart message H1=SHA256(H0) and that the DHPart message MAC is correct */
					uint8_t checkH1[32];
					uint8_t checkMAC[32];
					bzrtpDHPartMessage_t *peerDHPartMessageData;

					if (zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID] == NULL) {
						free (messageData);
						/* we have no DHPART message in this channel, this confirm shall never have arrived, discard it as invalid */
						return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
					}
					peerDHPartMessageData = (bzrtpDHPartMessage_t *)zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageData;
					/* Check H1 = SHA256(H0) */
					bctoolbox_sha256(messageData->H0, 32, 32, checkH1);
					if (memcmp(checkH1, peerDHPartMessageData->H1, 32) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
					}
					/* Check the DHPart message. 
					 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
					bctoolbox_hmacSha256(messageData->H0, 32, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
					if (memcmp(checkMAC, peerDHPartMessageData->MAC, 8) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
					}
				}

				messageData->sig_len = ((uint16_t)(confirmPlainMessage[0]&0x01))<<8 | (((uint16_t)confirmPlainMessage[1])&0x00FF);
				confirmPlainMessage += 2;
				messageData->E = ((*confirmPlainMessage)&0x08)>>3;
				messageData->V = ((*confirmPlainMessage)&0x04)>>2;
				messageData->A = ((*confirmPlainMessage)&0x02)>>1;
				messageData->D = (*confirmPlainMessage)&0x01;
				confirmPlainMessage += 1;

				messageData->cacheExpirationInterval = (((uint32_t)confirmPlainMessage[0])<<24) | (((uint32_t)confirmPlainMessage[1])<<16) | (((uint32_t)confirmPlainMessage[2])<<8) | ((uint32_t)confirmPlainMessage[3]);
				confirmPlainMessage += 4;


				/* if sig_len indicate a signature, parse it */
				if (messageData->sig_len>0) {
					memcpy(messageData->signatureBlockType, confirmPlainMessage, 4);
					confirmPlainMessage += 4;
					/* allocate memory for the signature block, sig_len is in words(32 bits) and includes the signature block type word */
					messageData->signatureBlock = (uint8_t *)malloc(4*(messageData->sig_len-1)*sizeof(uint8_t));
					memcpy(messageData->signatureBlock, confirmPlainMessage, 4*(messageData->sig_len-1));
				} else {
					messageData->signatureBlock  = NULL;
				}

				/* free plain buffer */
				free(confirmPlainMessageBuffer);

				/* the parsed commit packet must be saved as it is used to check correct packet repetition */
				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */

				/* attach the message structure to the packet one */
				zrtpPacket->messageData = (void *)messageData;
			}
			break; /* MSGTYPE_CONFIRM1 and MSGTYPE_CONFIRM2 */

		case MSGTYPE_CONF2ACK:
			/* nothing to do for this one */
			break; /* MSGTYPE_CONF2ACK */
		
		case MSGTYPE_PING:
			{
				/* allocate a ping message structure */
				bzrtpPingMessage_t *messageData;
				messageData = (bzrtpPingMessage_t *)malloc(sizeof(bzrtpPingMessage_t));

				/* fill the structure */
				memcpy(messageData->version, messageContent, 4);
				messageContent +=4;
				memcpy(messageData->endpointHash, messageContent, 8);

				/* attach the message structure to the packet one */
				zrtpPacket->messageData = (void *)messageData;
			}
			break; /* MSGTYPE_PING */

	}

	return 0;
}
",C,"
					/* Check the hvi received in the commit message  - RFC section 4.4.1.1*/
					/* First compute the expected hvi */
					/* hvi = hash(initiator's DHPart2 message(current zrtpPacket)) || responder's Hello message) using the agreed hash function truncated to 256 bits */
					/* create a string with the messages concatenated */
					{
						uint8_t computedHvi[32];
						uint16_t HelloMessageLength = zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;
						uint16_t DHPartHelloMessageStringLength = zrtpPacket->messageLength + HelloMessageLength;

						uint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));

						memcpy(DHPartHelloMessageString, input+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength);
						memcpy(DHPartHelloMessageString+zrtpPacket->messageLength, zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);

						zrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, computedHvi);

						free(DHPartHelloMessageString);

						/* Compare computed and received hvi */
						if (memcmp(computedHvi, peerCommitMessageData->hvi, 32)!=0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGHVI;
						}
					}

				/* the parsed packet must be saved as it is used to generate the total_hash */
","				/* the parsed commit packet must be saved as it is used to generate the total_hash */
",,"@@ -438,6 +438,32 @@ int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpC
 						free (messageData);
 						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
 					}
+
+					/* Check the hvi received in the commit message  - RFC section 4.4.1.1*/
+					/* First compute the expected hvi */
+					/* hvi = hash(initiator's DHPart2 message(current zrtpPacket)) || responder's Hello message) using the agreed hash function truncated to 256 bits */
+					/* create a string with the messages concatenated */
+					{
+						uint8_t computedHvi[32];
+						uint16_t HelloMessageLength = zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;
+						uint16_t DHPartHelloMessageStringLength = zrtpPacket->messageLength + HelloMessageLength;
+
+						uint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));
+
+						memcpy(DHPartHelloMessageString, input+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength);
+						memcpy(DHPartHelloMessageString+zrtpPacket->messageLength, zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);
+
+						zrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, computedHvi);
+
+						free(DHPartHelloMessageString);
+
+						/* Compare computed and received hvi */
+						if (memcmp(computedHvi, peerCommitMessageData->hvi, 32)!=0) {
+							free (messageData);
+							return BZRTP_PARSER_ERROR_UNMATCHINGHVI;
+						}
+					}
+
 				} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */
 					uint8_t checkH2[32];
 					uint8_t checkH3[32];
@@ -482,7 +508,7 @@ int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpC
 				/* attach the message structure to the packet one */
 				zrtpPacket->messageData = (void *)messageData;
 
-				/* the parsed commit packet must be saved as it is used to generate the total_hash */
+				/* the parsed packet must be saved as it is used to generate the total_hash */
 				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
 				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */
 			}",bzrtp,bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,d5d9ee8c4ae783ff4500017f535e838ed4585ba5,1,"int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, const uint8_t * input, uint16_t inputLength, bzrtpPacket_t *zrtpPacket) {

	int i;

	/* now allocate and fill the correct message structure according to the message type */
	/* messageContent points to the begining of the ZRTP message */
	uint8_t *messageContent = (uint8_t *)(input+ZRTP_PACKET_HEADER_LENGTH+ZRTP_MESSAGE_HEADER_LENGTH);

	switch (zrtpPacket->messageType) {
		case MSGTYPE_HELLO : 
			{
				/* allocate a Hello message structure */
				bzrtpHelloMessage_t *messageData;
				messageData = (bzrtpHelloMessage_t *)malloc(sizeof(bzrtpHelloMessage_t));

				/* fill it */
				memcpy(messageData->version, messageContent, 4);
				messageContent +=4;
				memcpy(messageData->clientIdentifier, messageContent, 16);
				messageContent +=16;
				memcpy(messageData->H3, messageContent, 32);
				messageContent +=32;
				memcpy(messageData->ZID, messageContent, 12);
				messageContent +=12;
				messageData->S = ((*messageContent)>>6)&0x01;
				messageData->M = ((*messageContent)>>5)&0x01;
				messageData->P = ((*messageContent)>>4)&0x01;
				messageContent +=1;
				messageData->hc = MIN((*messageContent)&0x0F, 7);
				messageContent +=1;
				messageData->cc = MIN(((*messageContent)>>4)&0x0F, 7);
				messageData->ac = MIN((*messageContent)&0x0F, 7);
				messageContent +=1;
				messageData->kc = MIN(((*messageContent)>>4)&0x0F, 7);
				messageData->sc = MIN((*messageContent)&0x0F, 7);
				messageContent +=1;

				/* Check message length according to value in hc, cc, ac, kc and sc */
				if (zrtpPacket->messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4*((uint16_t)(messageData->hc)+(uint16_t)(messageData->cc)+(uint16_t)(messageData->ac)+(uint16_t)(messageData->kc)+(uint16_t)(messageData->sc))) {
					free(messageData);
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}

				/* parse the variable length part: algorithms types */
				for (i=0; i<messageData->hc; i++) {
					messageData->supportedHash[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->cc; i++) {
					messageData->supportedCipher[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->ac; i++) {
					messageData->supportedAuthTag[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->kc; i++) {
					messageData->supportedKeyAgreement[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->sc; i++) {
					messageData->supportedSas[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);
					messageContent +=4;
				}

				addMandatoryCryptoTypesIfNeeded(ZRTP_HASH_TYPE, messageData->supportedHash, &messageData->hc);
				addMandatoryCryptoTypesIfNeeded(ZRTP_CIPHERBLOCK_TYPE, messageData->supportedCipher, &messageData->cc);
				addMandatoryCryptoTypesIfNeeded(ZRTP_AUTHTAG_TYPE, messageData->supportedAuthTag, &messageData->ac);
				addMandatoryCryptoTypesIfNeeded(ZRTP_KEYAGREEMENT_TYPE, messageData->supportedKeyAgreement, &messageData->kc);
				addMandatoryCryptoTypesIfNeeded(ZRTP_SAS_TYPE, messageData->supportedSas, &messageData->sc);

				memcpy(messageData->MAC, messageContent, 8);
				
				/* attach the message structure to the packet one */
				zrtpPacket->messageData = (void *)messageData;

				/* the parsed Hello packet must be saved as it may be used to generate commit message or the total_hash */
				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */
			}
			break; /* MSGTYPE_HELLO */

		case MSGTYPE_HELLOACK :
			{
				/* check message length */
				if (zrtpPacket->messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH) {
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}


			}
			break; /* MSGTYPE_HELLOACK */

		case MSGTYPE_COMMIT:
			{
				uint8_t checkH3[32];
				uint8_t checkMAC[32];
				bzrtpHelloMessage_t *peerHelloMessageData;
				uint16_t variableLength = 0;

				/* allocate a commit message structure */
				bzrtpCommitMessage_t *messageData;
				messageData = (bzrtpCommitMessage_t *)malloc(sizeof(bzrtpCommitMessage_t));

				/* fill the structure */
				memcpy(messageData->H2, messageContent, 32);
				messageContent +=32;

				/* We have now H2, check it matches the H3 we had in the hello message H3=SHA256(H2) and that the Hello message MAC is correct */
				if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
					free (messageData);
					/* we have no Hello message in this channel, this commit shall never have arrived, discard it as invalid */
					return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
				}
				peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
				/* Check H3 = SHA256(H2) */
				bctoolbox_sha256(messageData->H2, 32, 32, checkH3);
				if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
					free (messageData);
					return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
				}
				/* Check the hello MAC message. 
				 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
				bctoolbox_hmacSha256(messageData->H2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
				if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
					free (messageData);
					return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
				}

				memcpy(messageData->ZID, messageContent, 12);
				messageContent +=12;
				messageData->hashAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);
				messageContent += 4;
				messageData->cipherAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);
				messageContent += 4;
				messageData->authTagAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);
				messageContent += 4;
				messageData->keyAgreementAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);
				messageContent += 4;
				/* commit message length depends on the key agreement type choosen (and set in the zrtpContext->keyAgreementAlgo) */
				switch(messageData->keyAgreementAlgo) {
					case ZRTP_KEYAGREEMENT_DH2k :
					case ZRTP_KEYAGREEMENT_EC25 :
					case ZRTP_KEYAGREEMENT_DH3k :
					case ZRTP_KEYAGREEMENT_EC38 :
					case ZRTP_KEYAGREEMENT_EC52 :
						variableLength = 32; /* hvi is 32 bytes length in DH Commit message format */
						break;
					case ZRTP_KEYAGREEMENT_Prsh :
						variableLength = 24; /* nonce (16 bytes) and keyID(8 bytes) are 24 bytes length in preshared Commit message format */
						break;
					case ZRTP_KEYAGREEMENT_Mult :
						variableLength = 16; /* nonce is 24 bytes length in multistream Commit message format */
						break;
					default:
						free(messageData);
						return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}

				if (zrtpPacket->messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength) {
					free(messageData);
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}
				messageData->sasAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);
				messageContent += 4;

				/* if it is a multistream or preshared commit, get the 16 bytes nonce */
				if ((messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) || (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult)) {
					memcpy(messageData->nonce, messageContent, 16);
					messageContent +=16;

					/* and the keyID for preshared commit only */
					if (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) {
						memcpy(messageData->keyID, messageContent, 8);
						messageContent +=8;
					}
				} else { /* it's a DH commit message, get the hvi */
					memcpy(messageData->hvi, messageContent, 32);
					messageContent +=32;
				}

				/* get the MAC and attach the message data to the packet structure */
				memcpy(messageData->MAC, messageContent, 8);
				zrtpPacket->messageData = (void *)messageData;

				/* the parsed commit packet must be saved as it is used to generate the total_hash */
				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */
			}
			break; /* MSGTYPE_COMMIT */
		case MSGTYPE_DHPART1 :
		case MSGTYPE_DHPART2 :
			{
				bzrtpDHPartMessage_t *messageData;

				/*check message length, depends on the selected key agreement algo set in zrtpContext */
				uint16_t pvLength = computeKeyAgreementPrivateValueLength(zrtpChannelContext->keyAgreementAlgo);
				if (pvLength == 0) {
					return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
				}

				if (zrtpPacket->messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH+pvLength) {
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}

				/* allocate a DHPart message structure and pv */
				messageData = (bzrtpDHPartMessage_t *)malloc(sizeof(bzrtpDHPartMessage_t));
				messageData->pv = (uint8_t *)malloc(pvLength*sizeof(uint8_t));

				/* fill the structure */
				memcpy(messageData->H1, messageContent, 32);
				messageContent +=32;

				/* We have now H1, check it matches the H2 we had in the commit message H2=SHA256(H1) and that the Commit message MAC is correct */
				if ( zrtpChannelContext->role == RESPONDER) { /* do it only if we are responder (we received a commit packet) */
					uint8_t checkH2[32];
					uint8_t checkMAC[32];
					bzrtpCommitMessage_t *peerCommitMessageData;

					if (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {
						free (messageData);
						/* we have no Commit message in this channel, this DHPart2 shall never have arrived, discard it as invalid */
						return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
					}
					peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;
					/* Check H2 = SHA256(H1) */
					bctoolbox_sha256(messageData->H1, 32, 32, checkH2);
					if (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
					}
					/* Check the Commit MAC message. 
					 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
					bctoolbox_hmacSha256(messageData->H1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
					if (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {
 						free (messageData);
 						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
 					}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//					/* Check the hvi received in the commit message  - RFC section 4.4.1.1*/
//fix_flaw_line_below:
//					/* First compute the expected hvi */
//fix_flaw_line_below:
//					/* hvi = hash(initiator's DHPart2 message(current zrtpPacket)) || responder's Hello message) using the agreed hash function truncated to 256 bits */
//fix_flaw_line_below:
//					/* create a string with the messages concatenated */
//fix_flaw_line_below:
//					{
//fix_flaw_line_below:
//						uint8_t computedHvi[32];
//fix_flaw_line_below:
//						uint16_t HelloMessageLength = zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;
//fix_flaw_line_below:
//						uint16_t DHPartHelloMessageStringLength = zrtpPacket->messageLength + HelloMessageLength;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//						uint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//						memcpy(DHPartHelloMessageString, input+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength);
//fix_flaw_line_below:
//						memcpy(DHPartHelloMessageString+zrtpPacket->messageLength, zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//						zrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, computedHvi);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//						free(DHPartHelloMessageString);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//						/* Compare computed and received hvi */
//fix_flaw_line_below:
//						if (memcmp(computedHvi, peerCommitMessageData->hvi, 32)!=0) {
//fix_flaw_line_below:
//							free (messageData);
//fix_flaw_line_below:
//							return BZRTP_PARSER_ERROR_UNMATCHINGHVI;
//fix_flaw_line_below:
//						}
//fix_flaw_line_below:
//					}
//fix_flaw_line_below:
//
 				} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */
 					uint8_t checkH2[32];
 					uint8_t checkH3[32];
					uint8_t checkMAC[32];
					bzrtpHelloMessage_t *peerHelloMessageData;

					if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
						free (messageData);
						/* we have no Hello message in this channel, this DHPart1 shall never have arrived, discard it as invalid */
						return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
					}
					peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
					/* Check H3 = SHA256(SHA256(H1)) */
					bctoolbox_sha256(messageData->H1, 32, 32, checkH2);
					bctoolbox_sha256(checkH2, 32, 32, checkH3);
					if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
					}
					/* Check the hello MAC message. 
					 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
					bctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
					if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
					}

				}

				memcpy(messageData->rs1ID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->rs2ID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->auxsecretID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->pbxsecretID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->pv, messageContent, pvLength);
				messageContent +=pvLength;
				memcpy(messageData->MAC, messageContent, 8);

 				/* attach the message structure to the packet one */
 				zrtpPacket->messageData = (void *)messageData;
 
//flaw_line_below:
				/* the parsed commit packet must be saved as it is used to generate the total_hash */
//fix_flaw_line_below:
//				/* the parsed packet must be saved as it is used to generate the total_hash */
 				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
 				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */
 			}
			break; /* MSGTYPE_DHPART1 and MSGTYPE_DHPART2 */
		case MSGTYPE_CONFIRM1:
		case MSGTYPE_CONFIRM2:
			{
				uint8_t *confirmMessageKey = NULL;
				uint8_t *confirmMessageMacKey = NULL;
				bzrtpConfirmMessage_t *messageData;
				uint16_t cipherTextLength;
				uint8_t computedHmac[8];
				uint8_t *confirmPlainMessageBuffer;
				uint8_t *confirmPlainMessage;

				/* we shall first decrypt and validate the message, check we have the keys to do it */
				if (zrtpChannelContext->role == RESPONDER) { /* responder uses initiator's keys to decrypt */
					if ((zrtpChannelContext->zrtpkeyi == NULL) || (zrtpChannelContext->mackeyi == NULL)) {
						return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
					}
					confirmMessageKey = zrtpChannelContext->zrtpkeyi;
					confirmMessageMacKey = zrtpChannelContext->mackeyi;
				}

				if (zrtpChannelContext->role == INITIATOR) { /* the iniator uses responder's keys to decrypt */
					if ((zrtpChannelContext->zrtpkeyr == NULL) || (zrtpChannelContext->mackeyr == NULL)) {
						return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
					}
					confirmMessageKey = zrtpChannelContext->zrtpkeyr;
					confirmMessageMacKey = zrtpChannelContext->mackeyr;
				}
				
				/* allocate a confirm message structure */
				messageData = (bzrtpConfirmMessage_t *)malloc(sizeof(bzrtpConfirmMessage_t));

				/* get the mac and the IV */
				memcpy(messageData->confirm_mac, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->CFBIV, messageContent, 16);
				messageContent +=16;


				
				/* get the cipher text length */
				cipherTextLength = zrtpPacket->messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24; /* confirm message is header, confirm_mac(8 bytes), CFB IV(16 bytes), encrypted part */

				/* validate the mac over the cipher text */
				zrtpChannelContext->hmacFunction(confirmMessageMacKey, zrtpChannelContext->hashLength, messageContent, cipherTextLength, 8, computedHmac);
				
				if (memcmp(computedHmac, messageData->confirm_mac, 8) != 0) { /* confirm_mac doesn't match */
					free(messageData);
					return BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC;
				}

				/* get plain message */
				confirmPlainMessageBuffer = (uint8_t *)malloc(cipherTextLength*sizeof(uint8_t));
				zrtpChannelContext->cipherDecryptionFunction(confirmMessageKey, messageData->CFBIV, messageContent, cipherTextLength, confirmPlainMessageBuffer);
				confirmPlainMessage = confirmPlainMessageBuffer; /* point into the allocated buffer */

				/* parse it */
				memcpy(messageData->H0, confirmPlainMessage, 32);
				confirmPlainMessage +=33; /* +33 because next 8 bits are unused */

				/* Hash chain checking: if we are in multichannel or shared mode, we had not DHPart and then no H1 */
				if (zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult) {
					/* compute the H1=SHA256(H0) we never received */
					uint8_t checkH1[32];
					bctoolbox_sha256(messageData->H0, 32, 32, checkH1);

					/* if we are responder, we received a commit packet with H2 then check that H2=SHA256(H1) and that the commit message MAC keyed with H1 match */
					if ( zrtpChannelContext->role == RESPONDER) {
						uint8_t checkH2[32];
						uint8_t checkMAC[32];
						bzrtpCommitMessage_t *peerCommitMessageData;

						if (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {
							free (messageData);
							/* we have no Commit message in this channel, this Confirm2 shall never have arrived, discard it as invalid */
							return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
						}
						peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;
						/* Check H2 = SHA256(H1) */
						bctoolbox_sha256(checkH1, 32, 32, checkH2);
						if (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
						}
						/* Check the Commit MAC message. 
						 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
						bctoolbox_hmacSha256(checkH1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
						if (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
						}
					} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */
						uint8_t checkH2[32];
						uint8_t checkH3[32];
						uint8_t checkMAC[32];
						bzrtpHelloMessage_t *peerHelloMessageData;

						if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
							free (messageData);
							/* we have no Hello message in this channel, this Confirm1 shall never have arrived, discard it as invalid */
							return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
						}
						peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
						/* Check H3 = SHA256(SHA256(H1)) */
						bctoolbox_sha256(checkH1, 32, 32, checkH2);
						bctoolbox_sha256(checkH2, 32, 32, checkH3);
						if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
						}
						/* Check the hello MAC message. 
						 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
						bctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
						if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
						}
	
					}
				} else { /* we are in DHM mode */
					/* We have now H0, check it matches the H1 we had in the DHPart message H1=SHA256(H0) and that the DHPart message MAC is correct */
					uint8_t checkH1[32];
					uint8_t checkMAC[32];
					bzrtpDHPartMessage_t *peerDHPartMessageData;

					if (zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID] == NULL) {
						free (messageData);
						/* we have no DHPART message in this channel, this confirm shall never have arrived, discard it as invalid */
						return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
					}
					peerDHPartMessageData = (bzrtpDHPartMessage_t *)zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageData;
					/* Check H1 = SHA256(H0) */
					bctoolbox_sha256(messageData->H0, 32, 32, checkH1);
					if (memcmp(checkH1, peerDHPartMessageData->H1, 32) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
					}
					/* Check the DHPart message. 
					 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
					bctoolbox_hmacSha256(messageData->H0, 32, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
					if (memcmp(checkMAC, peerDHPartMessageData->MAC, 8) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
					}
				}

				messageData->sig_len = ((uint16_t)(confirmPlainMessage[0]&0x01))<<8 | (((uint16_t)confirmPlainMessage[1])&0x00FF);
				confirmPlainMessage += 2;
				messageData->E = ((*confirmPlainMessage)&0x08)>>3;
				messageData->V = ((*confirmPlainMessage)&0x04)>>2;
				messageData->A = ((*confirmPlainMessage)&0x02)>>1;
				messageData->D = (*confirmPlainMessage)&0x01;
				confirmPlainMessage += 1;

				messageData->cacheExpirationInterval = (((uint32_t)confirmPlainMessage[0])<<24) | (((uint32_t)confirmPlainMessage[1])<<16) | (((uint32_t)confirmPlainMessage[2])<<8) | ((uint32_t)confirmPlainMessage[3]);
				confirmPlainMessage += 4;


				/* if sig_len indicate a signature, parse it */
				if (messageData->sig_len>0) {
					memcpy(messageData->signatureBlockType, confirmPlainMessage, 4);
					confirmPlainMessage += 4;
					/* allocate memory for the signature block, sig_len is in words(32 bits) and includes the signature block type word */
					messageData->signatureBlock = (uint8_t *)malloc(4*(messageData->sig_len-1)*sizeof(uint8_t));
					memcpy(messageData->signatureBlock, confirmPlainMessage, 4*(messageData->sig_len-1));
				} else {
					messageData->signatureBlock  = NULL;
				}

				/* free plain buffer */
				free(confirmPlainMessageBuffer);

				/* the parsed commit packet must be saved as it is used to check correct packet repetition */
				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */

				/* attach the message structure to the packet one */
				zrtpPacket->messageData = (void *)messageData;
			}
			break; /* MSGTYPE_CONFIRM1 and MSGTYPE_CONFIRM2 */

		case MSGTYPE_CONF2ACK:
			/* nothing to do for this one */
			break; /* MSGTYPE_CONF2ACK */
		
		case MSGTYPE_PING:
			{
				/* allocate a ping message structure */
				bzrtpPingMessage_t *messageData;
				messageData = (bzrtpPingMessage_t *)malloc(sizeof(bzrtpPingMessage_t));

				/* fill the structure */
				memcpy(messageData->version, messageContent, 4);
				messageContent +=4;
				memcpy(messageData->endpointHash, messageContent, 8);

				/* attach the message structure to the packet one */
				zrtpPacket->messageData = (void *)messageData;
			}
			break; /* MSGTYPE_PING */

	}

	return 0;
}
"
4265,182001,,Remote,Not required,,CVE-2016-6271,https://www.cvedetails.com/cve/CVE-2016-6271/,CWE-254,Low,,Partial,,2017-01-18,5.0,The Bzrtp library (aka libbzrtp) 1.0.x before 1.0.4 allows man-in-the-middle attackers to conduct spoofing attacks by leveraging a missing HVI check on DHPart2 packet reception.,2017-08-02,,41,https://github.com/BelledonneCommunications/bzrtp/commit/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,Add ZRTP Commit packet hvi check on DHPart2 packet reception,1,test/bzrtpParserTest.c,"{""sha"": ""95ec6d5ef51cd2f1288e74d8798b1b930db1332c"", ""filename"": ""include/packetParser.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/BelledonneCommunications/bzrtp/blob/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/include/packetParser.h"", ""raw_url"": ""https://github.com/BelledonneCommunications/bzrtp/raw/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/include/packetParser.h"", ""contents_url"": ""https://api.github.com/repos/BelledonneCommunications/bzrtp/contents/include/packetParser.h?ref=bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b"", ""patch"": ""@@ -42,6 +42,7 @@\n #define\t\tBZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN\t0xa080\n #define\t\tBZRTP_PARSER_ERROR_UNMATCHINGMAC\t\t0xa100\n #define\t\tBZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE\t0xa200\n+#define\t\tBZRTP_PARSER_ERROR_UNMATCHINGHVI\t\t0xa400\n \n #define\t\tBZRTP_BUILDER_ERROR_INVALIDPACKET\t\t0x5001\n #define\t\tBZRTP_BUILDER_ERROR_INVALIDMESSAGE\t\t0x5002""}<_**next**_>{""sha"": ""2ca5cdb67005a166d05e23ac588d674a7aa4f9bf"", ""filename"": ""src/packetParser.c"", ""status"": ""modified"", ""additions"": 27, ""deletions"": 1, ""changes"": 28, ""blob_url"": ""https://github.com/BelledonneCommunications/bzrtp/blob/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/src/packetParser.c"", ""raw_url"": ""https://github.com/BelledonneCommunications/bzrtp/raw/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/src/packetParser.c"", ""contents_url"": ""https://api.github.com/repos/BelledonneCommunications/bzrtp/contents/src/packetParser.c?ref=bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b"", ""patch"": ""@@ -438,6 +438,32 @@ int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpC\n \t\t\t\t\t\tfree (messageData);\n \t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n \t\t\t\t\t}\n+\n+\t\t\t\t\t/* Check the hvi received in the commit message  - RFC section 4.4.1.1*/\n+\t\t\t\t\t/* First compute the expected hvi */\n+\t\t\t\t\t/* hvi = hash(initiator's DHPart2 message(current zrtpPacket)) || responder's Hello message) using the agreed hash function truncated to 256 bits */\n+\t\t\t\t\t/* create a string with the messages concatenated */\n+\t\t\t\t\t{\n+\t\t\t\t\t\tuint8_t computedHvi[32];\n+\t\t\t\t\t\tuint16_t HelloMessageLength = zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;\n+\t\t\t\t\t\tuint16_t DHPartHelloMessageStringLength = zrtpPacket->messageLength + HelloMessageLength;\n+\n+\t\t\t\t\t\tuint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));\n+\n+\t\t\t\t\t\tmemcpy(DHPartHelloMessageString, input+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength);\n+\t\t\t\t\t\tmemcpy(DHPartHelloMessageString+zrtpPacket->messageLength, zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);\n+\n+\t\t\t\t\t\tzrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, computedHvi);\n+\n+\t\t\t\t\t\tfree(DHPartHelloMessageString);\n+\n+\t\t\t\t\t\t/* Compare computed and received hvi */\n+\t\t\t\t\t\tif (memcmp(computedHvi, peerCommitMessageData->hvi, 32)!=0) {\n+\t\t\t\t\t\t\tfree (messageData);\n+\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHVI;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n \t\t\t\t} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */\n \t\t\t\t\tuint8_t checkH2[32];\n \t\t\t\t\tuint8_t checkH3[32];\n@@ -482,7 +508,7 @@ int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpC\n \t\t\t\t/* attach the message structure to the packet one */\n \t\t\t\tzrtpPacket->messageData = (void *)messageData;\n \n-\t\t\t\t/* the parsed commit packet must be saved as it is used to generate the total_hash */\n+\t\t\t\t/* the parsed packet must be saved as it is used to generate the total_hash */\n \t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n \t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n \t\t\t}""}<_**next**_>{""sha"": ""faa1b8ce0edc5ba51d51e658e291915659f56089"", ""filename"": ""test/bzrtpParserTest.c"", ""status"": ""modified"", ""additions"": 49, ""deletions"": 2, ""changes"": 51, ""blob_url"": ""https://github.com/BelledonneCommunications/bzrtp/blob/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpParserTest.c"", ""raw_url"": ""https://github.com/BelledonneCommunications/bzrtp/raw/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpParserTest.c"", ""contents_url"": ""https://api.github.com/repos/BelledonneCommunications/bzrtp/contents/test/bzrtpParserTest.c?ref=bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b"", ""patch"": ""@@ -101,7 +101,8 @@ uint8_t mackeyr[32] = {0x3a, 0xa5, 0x22, 0x43, 0x26, 0x13, 0x8f, 0xd6, 0x54, 0x5\n uint8_t zrtpkeyi[16] = {0x22, 0xf6, 0xea, 0xaa, 0xa4, 0xad, 0x53, 0x30, 0x71, 0x97, 0xcc, 0x68, 0x6b, 0xb0, 0xcb, 0x55};\n uint8_t zrtpkeyr[16] = {0x09, 0x50, 0xcd, 0x9e, 0xc2, 0x78, 0x54, 0x31, 0x93, 0x2e, 0x99, 0x31, 0x15, 0x58, 0xd0, 0x2a};\n \n-void test_parser(void) {\n+\n+void test_parser_param(uint8_t hvi_trick) {\n \tint i, retval;\n \tbzrtpPacket_t *zrtpPacket;\n \n@@ -159,13 +160,34 @@ void test_parser(void) {\n \t\t/* parse a packet string from patterns */\n \t\tzrtpPacket = bzrtp_packetCheck(patternZRTPPackets[i], patternZRTPMetaData[i][0], (patternZRTPMetaData[i][1])-1, &retval);\n \t\tretval +=  bzrtp_packetParser((patternZRTPMetaData[i][2]==0x87654321)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x87654321)?context12345678->channelContext[0]:context87654321->channelContext[0], patternZRTPPackets[i], patternZRTPMetaData[i][0], zrtpPacket);\n-\t\t/*printf(\""parsing Ret val is %x index is %d\\n\"", retval, i);*/\n+\t\tif (hvi_trick==0) {\n+\t\t\tCU_ASSERT_EQUAL_FATAL(retval,0);\n+\t\t} else { /* when hvi trick is enable, the DH2 parsing shall fail and return BZRTP_PARSER_ERROR_UNMATCHINGHVI */\n+\t\t\tif (zrtpPacket->messageType==MSGTYPE_DHPART2) {\n+\t\t\t\tCU_ASSERT_EQUAL_FATAL(retval, BZRTP_PARSER_ERROR_UNMATCHINGHVI);\n+\t\t\t\t/* We shall then anyway skip the end of the test */\n+\t\t\t\t/* reset pointers to selfHello packet in order to avoid double free */\n+\t\t\t\tcontext87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;\n+\t\t\t\tcontext12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;\n+\n+\t\t\t\tbzrtp_destroyBzrtpContext(context87654321, 0x87654321);\n+\t\t\t\tbzrtp_destroyBzrtpContext(context12345678, 0x12345678);\n+\n+\t\t\t\treturn;\n+\n+\t\t\t} else {\n+\t\t\t\tCU_ASSERT_EQUAL_FATAL(retval,0);\n+\t\t\t}\n+\t\t}\n+\t\t\tbzrtp_message(\""parsing Ret val is %x index is %d\\n\"", retval, i);\n \t\t/* We must store some packets in the context if we want to be able to parse further packets */\n \t\tif (zrtpPacket->messageType==MSGTYPE_HELLO) {\n \t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n \t\t\t\tcontext12345678->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n+\t\t\t\tcontext87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n \t\t\t} else {\n \t\t\t\tcontext87654321->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n+\t\t\t\tcontext12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n \t\t\t}\n \t\t\tfreePacketFlag = 0;\n \t\t}\n@@ -205,13 +227,38 @@ void test_parser(void) {\n \t\tif (freePacketFlag == 1) {\n \t\t\tbzrtp_freeZrtpPacket(zrtpPacket);\n \t\t}\n+\n+\t\t/* modify the hvi stored in the peerPackets, this shall result in parsing failure on DH2 packet */\n+\t\tif (hvi_trick == 1) {\n+\t\t\tif (zrtpPacket->messageType==MSGTYPE_COMMIT) {\n+\t\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n+\t\t\t\t\tbzrtpCommitMessage_t *peerCommitMessageData;\n+\t\t\t\t\tpeerCommitMessageData = (bzrtpCommitMessage_t *)zrtpPacket->messageData;\n+\t\t\t\t\tpeerCommitMessageData->hvi[0]=0xFF;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n \t}\n \n+\t/* reset pointers to selfHello packet in order to avoid double free */\n+\tcontext87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;\n+\tcontext12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;\n+\n+\n \tbzrtp_destroyBzrtpContext(context87654321, 0x87654321);\n \tbzrtp_destroyBzrtpContext(context12345678, 0x12345678);\n \n }\n \n+void test_parser(void) {\n+\ttest_parser_param(0);\n+}\n+\n+void test_parser_hvi(void) {\n+\ttest_parser_param(1);\n+}\n+\n /* context structure mainly used by statemachine test, but also needed by parserComplete to get the zid Filename */\n typedef struct my_Context_struct {\n \tunsigned char nom[30]; /* nom du contexte */""}<_**next**_>{""sha"": ""74548f2c2b41187c4d83dce2dc206a710c33d77f"", ""filename"": ""test/bzrtpParserTest.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/BelledonneCommunications/bzrtp/blob/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpParserTest.h"", ""raw_url"": ""https://github.com/BelledonneCommunications/bzrtp/raw/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpParserTest.h"", ""contents_url"": ""https://api.github.com/repos/BelledonneCommunications/bzrtp/contents/test/bzrtpParserTest.h?ref=bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b"", ""patch"": ""@@ -20,5 +20,6 @@\n  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n  */\n void test_parser(void);\n+void test_parser_hvi(void);\n void test_parserComplete(void);\n void test_stateMachine(void);""}<_**next**_>{""sha"": ""a9fa90f94a9525d8a131369ac1dbc4fcf7ad780d"", ""filename"": ""test/bzrtpTest.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/BelledonneCommunications/bzrtp/blob/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpTest.c"", ""raw_url"": ""https://github.com/BelledonneCommunications/bzrtp/raw/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpTest.c"", ""contents_url"": ""https://api.github.com/repos/BelledonneCommunications/bzrtp/contents/test/bzrtpTest.c?ref=bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b"", ""patch"": ""@@ -75,6 +75,7 @@ int main(int argc, char *argv[] ) {\n \t/* Add the parser suite to the registry */\n \tparserTestSuite = CU_add_suite(\""Bzrtp ZRTP Packet Parser\"", NULL, NULL);\n \tCU_add_test(parserTestSuite, \""Parse\"", test_parser);\n+\tCU_add_test(parserTestSuite, \""Parse hvi check fail\"", test_parser_hvi);\n \tCU_add_test(parserTestSuite, \""Parse Exchange\"", test_parserComplete);\n \tCU_add_test(parserTestSuite, \""State machine\"", test_stateMachine);\n ""}","void test_parser(void) {

void test_parser_param(uint8_t hvi_trick) {
 	int i, retval;
 	bzrtpPacket_t *zrtpPacket;
 
	/* Create zrtp Context to use H0-H3 chains and others */
	bzrtpContext_t *context87654321 = bzrtp_createBzrtpContext(0x87654321);
	bzrtpContext_t *context12345678 = bzrtp_createBzrtpContext(0x12345678);


	/* replace created H by the patterns one to be able to generate the correct packet */
	memcpy (context12345678->channelContext[0]->selfH[0], H12345678[0], 32);
	memcpy (context12345678->channelContext[0]->selfH[1], H12345678[1], 32);
	memcpy (context12345678->channelContext[0]->selfH[2], H12345678[2], 32);
	memcpy (context12345678->channelContext[0]->selfH[3], H12345678[3], 32);
	memcpy (context87654321->channelContext[0]->selfH[0], H87654321[0], 32);
	memcpy (context87654321->channelContext[0]->selfH[1], H87654321[1], 32);
	memcpy (context87654321->channelContext[0]->selfH[2], H87654321[2], 32);
	memcpy (context87654321->channelContext[0]->selfH[3], H87654321[3], 32);

	/* preset the key agreement algo in the contexts */
	context87654321->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;
	context12345678->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;
	context87654321->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;
	context12345678->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;
	context87654321->channelContext[0]->hashAlgo = ZRTP_HASH_S256;
	context12345678->channelContext[0]->hashAlgo = ZRTP_HASH_S256;

	updateCryptoFunctionPointers(context87654321->channelContext[0]);
	updateCryptoFunctionPointers(context12345678->channelContext[0]);

	/* set the zrtp and mac keys */
	context87654321->channelContext[0]->mackeyi = (uint8_t *)malloc(32);
	context12345678->channelContext[0]->mackeyi = (uint8_t *)malloc(32);
	context87654321->channelContext[0]->mackeyr = (uint8_t *)malloc(32);
	context12345678->channelContext[0]->mackeyr = (uint8_t *)malloc(32);

	context87654321->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);
	context12345678->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);
	context87654321->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);
	context12345678->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);

	memcpy(context12345678->channelContext[0]->mackeyi, mackeyi, 32);
	memcpy(context12345678->channelContext[0]->mackeyr, mackeyr, 32);
	memcpy(context12345678->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);
	memcpy(context12345678->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);
	memcpy(context87654321->channelContext[0]->mackeyi, mackeyi, 32);
	memcpy(context87654321->channelContext[0]->mackeyr, mackeyr, 32);
	memcpy(context87654321->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);
	memcpy(context87654321->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);

	/* set the role: 87654321 is initiator in our exchange pattern */
	context12345678->channelContext[0]->role = RESPONDER;

	for (i=0; i<TEST_PACKET_NUMBER; i++) {
		uint8_t freePacketFlag = 1;
 		/* parse a packet string from patterns */
 		zrtpPacket = bzrtp_packetCheck(patternZRTPPackets[i], patternZRTPMetaData[i][0], (patternZRTPMetaData[i][1])-1, &retval);
 		retval +=  bzrtp_packetParser((patternZRTPMetaData[i][2]==0x87654321)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x87654321)?context12345678->channelContext[0]:context87654321->channelContext[0], patternZRTPPackets[i], patternZRTPMetaData[i][0], zrtpPacket);
		if (hvi_trick==0) {
			CU_ASSERT_EQUAL_FATAL(retval,0);
		} else { /* when hvi trick is enable, the DH2 parsing shall fail and return BZRTP_PARSER_ERROR_UNMATCHINGHVI */
			if (zrtpPacket->messageType==MSGTYPE_DHPART2) {
				CU_ASSERT_EQUAL_FATAL(retval, BZRTP_PARSER_ERROR_UNMATCHINGHVI);
				/* We shall then anyway skip the end of the test */
				/* reset pointers to selfHello packet in order to avoid double free */
				context87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;
				context12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;

				bzrtp_destroyBzrtpContext(context87654321, 0x87654321);
				bzrtp_destroyBzrtpContext(context12345678, 0x12345678);

				return;

			} else {
				CU_ASSERT_EQUAL_FATAL(retval,0);
			}
		}
			bzrtp_message(""parsing Ret val is %x index is %d\n"", retval, i);
 		/* We must store some packets in the context if we want to be able to parse further packets */
 		if (zrtpPacket->messageType==MSGTYPE_HELLO) {
 			if (patternZRTPMetaData[i][2]==0x87654321) {
 				context12345678->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
				context87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
 			} else {
 				context87654321->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
				context12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
 			}
 			freePacketFlag = 0;
 		}
		if (zrtpPacket->messageType==MSGTYPE_COMMIT) {
			if (patternZRTPMetaData[i][2]==0x87654321) {
				context12345678->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;
			} else {
				context87654321->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;
			}
			freePacketFlag = 0;
		}
		if (zrtpPacket->messageType==MSGTYPE_DHPART1 || zrtpPacket->messageType==MSGTYPE_DHPART2) {
			if (patternZRTPMetaData[i][2]==0x87654321) {
				context12345678->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;
			} else {
				context87654321->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;
			}
			freePacketFlag = 0;
		}
		/* free the packet string as will be created again by the packetBuild function and might have been copied by packetParser */
		free(zrtpPacket->packetString);
		/* build a packet string from the parser packet*/
		retval = bzrtp_packetBuild((patternZRTPMetaData[i][2]==0x12345678)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x12345678)?context12345678->channelContext[0]:context87654321->channelContext[0], zrtpPacket, patternZRTPMetaData[i][1]);
		/* if (retval ==0) {
			packetDump(zrtpPacket, 1);
		} else {
			bzrtp_message(""Ret val is %x index is %d\n"", retval, i);
		}*/

		/* check they are the same */
		if (zrtpPacket->packetString != NULL) {
			CU_ASSERT_TRUE(memcmp(zrtpPacket->packetString, patternZRTPPackets[i], patternZRTPMetaData[i][0]) == 0);
		} else {
			CU_FAIL(""Unable to build packet"");
		}

 		if (freePacketFlag == 1) {
 			bzrtp_freeZrtpPacket(zrtpPacket);
 		}

		/* modify the hvi stored in the peerPackets, this shall result in parsing failure on DH2 packet */
		if (hvi_trick == 1) {
			if (zrtpPacket->messageType==MSGTYPE_COMMIT) {
				if (patternZRTPMetaData[i][2]==0x87654321) {
					bzrtpCommitMessage_t *peerCommitMessageData;
					peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpPacket->messageData;
					peerCommitMessageData->hvi[0]=0xFF;
				}
			}
		}

 	}
 
	/* reset pointers to selfHello packet in order to avoid double free */
	context87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;
	context12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;


 	bzrtp_destroyBzrtpContext(context87654321, 0x87654321);
 	bzrtp_destroyBzrtpContext(context12345678, 0x12345678);
 
 }
","void test_parser(void) {
 	int i, retval;
 	bzrtpPacket_t *zrtpPacket;
 
	/* Create zrtp Context to use H0-H3 chains and others */
	bzrtpContext_t *context87654321 = bzrtp_createBzrtpContext(0x87654321);
	bzrtpContext_t *context12345678 = bzrtp_createBzrtpContext(0x12345678);


	/* replace created H by the patterns one to be able to generate the correct packet */
	memcpy (context12345678->channelContext[0]->selfH[0], H12345678[0], 32);
	memcpy (context12345678->channelContext[0]->selfH[1], H12345678[1], 32);
	memcpy (context12345678->channelContext[0]->selfH[2], H12345678[2], 32);
	memcpy (context12345678->channelContext[0]->selfH[3], H12345678[3], 32);
	memcpy (context87654321->channelContext[0]->selfH[0], H87654321[0], 32);
	memcpy (context87654321->channelContext[0]->selfH[1], H87654321[1], 32);
	memcpy (context87654321->channelContext[0]->selfH[2], H87654321[2], 32);
	memcpy (context87654321->channelContext[0]->selfH[3], H87654321[3], 32);

	/* preset the key agreement algo in the contexts */
	context87654321->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;
	context12345678->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;
	context87654321->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;
	context12345678->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;
	context87654321->channelContext[0]->hashAlgo = ZRTP_HASH_S256;
	context12345678->channelContext[0]->hashAlgo = ZRTP_HASH_S256;

	updateCryptoFunctionPointers(context87654321->channelContext[0]);
	updateCryptoFunctionPointers(context12345678->channelContext[0]);

	/* set the zrtp and mac keys */
	context87654321->channelContext[0]->mackeyi = (uint8_t *)malloc(32);
	context12345678->channelContext[0]->mackeyi = (uint8_t *)malloc(32);
	context87654321->channelContext[0]->mackeyr = (uint8_t *)malloc(32);
	context12345678->channelContext[0]->mackeyr = (uint8_t *)malloc(32);

	context87654321->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);
	context12345678->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);
	context87654321->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);
	context12345678->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);

	memcpy(context12345678->channelContext[0]->mackeyi, mackeyi, 32);
	memcpy(context12345678->channelContext[0]->mackeyr, mackeyr, 32);
	memcpy(context12345678->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);
	memcpy(context12345678->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);
	memcpy(context87654321->channelContext[0]->mackeyi, mackeyi, 32);
	memcpy(context87654321->channelContext[0]->mackeyr, mackeyr, 32);
	memcpy(context87654321->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);
	memcpy(context87654321->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);

	/* set the role: 87654321 is initiator in our exchange pattern */
	context12345678->channelContext[0]->role = RESPONDER;

	for (i=0; i<TEST_PACKET_NUMBER; i++) {
		uint8_t freePacketFlag = 1;
 		/* parse a packet string from patterns */
 		zrtpPacket = bzrtp_packetCheck(patternZRTPPackets[i], patternZRTPMetaData[i][0], (patternZRTPMetaData[i][1])-1, &retval);
 		retval +=  bzrtp_packetParser((patternZRTPMetaData[i][2]==0x87654321)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x87654321)?context12345678->channelContext[0]:context87654321->channelContext[0], patternZRTPPackets[i], patternZRTPMetaData[i][0], zrtpPacket);
		/*printf(""parsing Ret val is %x index is %d\n"", retval, i);*/
 		/* We must store some packets in the context if we want to be able to parse further packets */
 		if (zrtpPacket->messageType==MSGTYPE_HELLO) {
 			if (patternZRTPMetaData[i][2]==0x87654321) {
 				context12345678->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
 			} else {
 				context87654321->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
 			}
 			freePacketFlag = 0;
 		}
		if (zrtpPacket->messageType==MSGTYPE_COMMIT) {
			if (patternZRTPMetaData[i][2]==0x87654321) {
				context12345678->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;
			} else {
				context87654321->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;
			}
			freePacketFlag = 0;
		}
		if (zrtpPacket->messageType==MSGTYPE_DHPART1 || zrtpPacket->messageType==MSGTYPE_DHPART2) {
			if (patternZRTPMetaData[i][2]==0x87654321) {
				context12345678->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;
			} else {
				context87654321->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;
			}
			freePacketFlag = 0;
		}
		/* free the packet string as will be created again by the packetBuild function and might have been copied by packetParser */
		free(zrtpPacket->packetString);
		/* build a packet string from the parser packet*/
		retval = bzrtp_packetBuild((patternZRTPMetaData[i][2]==0x12345678)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x12345678)?context12345678->channelContext[0]:context87654321->channelContext[0], zrtpPacket, patternZRTPMetaData[i][1]);
		/* if (retval ==0) {
			packetDump(zrtpPacket, 1);
		} else {
			bzrtp_message(""Ret val is %x index is %d\n"", retval, i);
		}*/

		/* check they are the same */
		if (zrtpPacket->packetString != NULL) {
			CU_ASSERT_TRUE(memcmp(zrtpPacket->packetString, patternZRTPPackets[i], patternZRTPMetaData[i][0]) == 0);
		} else {
			CU_FAIL(""Unable to build packet"");
		}

 		if (freePacketFlag == 1) {
 			bzrtp_freeZrtpPacket(zrtpPacket);
 		}
 	}
 
 	bzrtp_destroyBzrtpContext(context87654321, 0x87654321);
 	bzrtp_destroyBzrtpContext(context12345678, 0x12345678);
 
 }
",C,"
void test_parser_param(uint8_t hvi_trick) {
		if (hvi_trick==0) {
			CU_ASSERT_EQUAL_FATAL(retval,0);
		} else { /* when hvi trick is enable, the DH2 parsing shall fail and return BZRTP_PARSER_ERROR_UNMATCHINGHVI */
			if (zrtpPacket->messageType==MSGTYPE_DHPART2) {
				CU_ASSERT_EQUAL_FATAL(retval, BZRTP_PARSER_ERROR_UNMATCHINGHVI);
				/* We shall then anyway skip the end of the test */
				/* reset pointers to selfHello packet in order to avoid double free */
				context87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;
				context12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;

				bzrtp_destroyBzrtpContext(context87654321, 0x87654321);
				bzrtp_destroyBzrtpContext(context12345678, 0x12345678);

				return;

			} else {
				CU_ASSERT_EQUAL_FATAL(retval,0);
			}
		}
			bzrtp_message(""parsing Ret val is %x index is %d\n"", retval, i);
				context87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
				context12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;

		/* modify the hvi stored in the peerPackets, this shall result in parsing failure on DH2 packet */
		if (hvi_trick == 1) {
			if (zrtpPacket->messageType==MSGTYPE_COMMIT) {
				if (patternZRTPMetaData[i][2]==0x87654321) {
					bzrtpCommitMessage_t *peerCommitMessageData;
					peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpPacket->messageData;
					peerCommitMessageData->hvi[0]=0xFF;
				}
			}
		}

	/* reset pointers to selfHello packet in order to avoid double free */
	context87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;
	context12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;


","		/*printf(""parsing Ret val is %x index is %d\n"", retval, i);*/
",,"@@ -101,7 +101,8 @@ uint8_t mackeyr[32] = {0x3a, 0xa5, 0x22, 0x43, 0x26, 0x13, 0x8f, 0xd6, 0x54, 0x5
 uint8_t zrtpkeyi[16] = {0x22, 0xf6, 0xea, 0xaa, 0xa4, 0xad, 0x53, 0x30, 0x71, 0x97, 0xcc, 0x68, 0x6b, 0xb0, 0xcb, 0x55};
 uint8_t zrtpkeyr[16] = {0x09, 0x50, 0xcd, 0x9e, 0xc2, 0x78, 0x54, 0x31, 0x93, 0x2e, 0x99, 0x31, 0x15, 0x58, 0xd0, 0x2a};
 
-void test_parser(void) {
+
+void test_parser_param(uint8_t hvi_trick) {
 	int i, retval;
 	bzrtpPacket_t *zrtpPacket;
 
@@ -159,13 +160,34 @@ void test_parser(void) {
 		/* parse a packet string from patterns */
 		zrtpPacket = bzrtp_packetCheck(patternZRTPPackets[i], patternZRTPMetaData[i][0], (patternZRTPMetaData[i][1])-1, &retval);
 		retval +=  bzrtp_packetParser((patternZRTPMetaData[i][2]==0x87654321)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x87654321)?context12345678->channelContext[0]:context87654321->channelContext[0], patternZRTPPackets[i], patternZRTPMetaData[i][0], zrtpPacket);
-		/*printf(""parsing Ret val is %x index is %d\n"", retval, i);*/
+		if (hvi_trick==0) {
+			CU_ASSERT_EQUAL_FATAL(retval,0);
+		} else { /* when hvi trick is enable, the DH2 parsing shall fail and return BZRTP_PARSER_ERROR_UNMATCHINGHVI */
+			if (zrtpPacket->messageType==MSGTYPE_DHPART2) {
+				CU_ASSERT_EQUAL_FATAL(retval, BZRTP_PARSER_ERROR_UNMATCHINGHVI);
+				/* We shall then anyway skip the end of the test */
+				/* reset pointers to selfHello packet in order to avoid double free */
+				context87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;
+				context12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;
+
+				bzrtp_destroyBzrtpContext(context87654321, 0x87654321);
+				bzrtp_destroyBzrtpContext(context12345678, 0x12345678);
+
+				return;
+
+			} else {
+				CU_ASSERT_EQUAL_FATAL(retval,0);
+			}
+		}
+			bzrtp_message(""parsing Ret val is %x index is %d\n"", retval, i);
 		/* We must store some packets in the context if we want to be able to parse further packets */
 		if (zrtpPacket->messageType==MSGTYPE_HELLO) {
 			if (patternZRTPMetaData[i][2]==0x87654321) {
 				context12345678->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
+				context87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
 			} else {
 				context87654321->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
+				context12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
 			}
 			freePacketFlag = 0;
 		}
@@ -205,13 +227,38 @@ void test_parser(void) {
 		if (freePacketFlag == 1) {
 			bzrtp_freeZrtpPacket(zrtpPacket);
 		}
+
+		/* modify the hvi stored in the peerPackets, this shall result in parsing failure on DH2 packet */
+		if (hvi_trick == 1) {
+			if (zrtpPacket->messageType==MSGTYPE_COMMIT) {
+				if (patternZRTPMetaData[i][2]==0x87654321) {
+					bzrtpCommitMessage_t *peerCommitMessageData;
+					peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpPacket->messageData;
+					peerCommitMessageData->hvi[0]=0xFF;
+				}
+			}
+		}
+
 	}
 
+	/* reset pointers to selfHello packet in order to avoid double free */
+	context87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;
+	context12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;
+
+
 	bzrtp_destroyBzrtpContext(context87654321, 0x87654321);
 	bzrtp_destroyBzrtpContext(context12345678, 0x12345678);
 
 }
 
+void test_parser(void) {
+	test_parser_param(0);
+}
+
+void test_parser_hvi(void) {
+	test_parser_param(1);
+}
+
 /* context structure mainly used by statemachine test, but also needed by parserComplete to get the zid Filename */
 typedef struct my_Context_struct {
 	unsigned char nom[30]; /* nom du contexte */",bzrtp,bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,d5d9ee8c4ae783ff4500017f535e838ed4585ba5,1,"void test_parser(void) {
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//void test_parser_param(uint8_t hvi_trick) {
 	int i, retval;
 	bzrtpPacket_t *zrtpPacket;
 
	/* Create zrtp Context to use H0-H3 chains and others */
	bzrtpContext_t *context87654321 = bzrtp_createBzrtpContext(0x87654321);
	bzrtpContext_t *context12345678 = bzrtp_createBzrtpContext(0x12345678);


	/* replace created H by the patterns one to be able to generate the correct packet */
	memcpy (context12345678->channelContext[0]->selfH[0], H12345678[0], 32);
	memcpy (context12345678->channelContext[0]->selfH[1], H12345678[1], 32);
	memcpy (context12345678->channelContext[0]->selfH[2], H12345678[2], 32);
	memcpy (context12345678->channelContext[0]->selfH[3], H12345678[3], 32);
	memcpy (context87654321->channelContext[0]->selfH[0], H87654321[0], 32);
	memcpy (context87654321->channelContext[0]->selfH[1], H87654321[1], 32);
	memcpy (context87654321->channelContext[0]->selfH[2], H87654321[2], 32);
	memcpy (context87654321->channelContext[0]->selfH[3], H87654321[3], 32);

	/* preset the key agreement algo in the contexts */
	context87654321->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;
	context12345678->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;
	context87654321->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;
	context12345678->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;
	context87654321->channelContext[0]->hashAlgo = ZRTP_HASH_S256;
	context12345678->channelContext[0]->hashAlgo = ZRTP_HASH_S256;

	updateCryptoFunctionPointers(context87654321->channelContext[0]);
	updateCryptoFunctionPointers(context12345678->channelContext[0]);

	/* set the zrtp and mac keys */
	context87654321->channelContext[0]->mackeyi = (uint8_t *)malloc(32);
	context12345678->channelContext[0]->mackeyi = (uint8_t *)malloc(32);
	context87654321->channelContext[0]->mackeyr = (uint8_t *)malloc(32);
	context12345678->channelContext[0]->mackeyr = (uint8_t *)malloc(32);

	context87654321->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);
	context12345678->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);
	context87654321->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);
	context12345678->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);

	memcpy(context12345678->channelContext[0]->mackeyi, mackeyi, 32);
	memcpy(context12345678->channelContext[0]->mackeyr, mackeyr, 32);
	memcpy(context12345678->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);
	memcpy(context12345678->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);
	memcpy(context87654321->channelContext[0]->mackeyi, mackeyi, 32);
	memcpy(context87654321->channelContext[0]->mackeyr, mackeyr, 32);
	memcpy(context87654321->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);
	memcpy(context87654321->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);

	/* set the role: 87654321 is initiator in our exchange pattern */
	context12345678->channelContext[0]->role = RESPONDER;

	for (i=0; i<TEST_PACKET_NUMBER; i++) {
		uint8_t freePacketFlag = 1;
 		/* parse a packet string from patterns */
 		zrtpPacket = bzrtp_packetCheck(patternZRTPPackets[i], patternZRTPMetaData[i][0], (patternZRTPMetaData[i][1])-1, &retval);
 		retval +=  bzrtp_packetParser((patternZRTPMetaData[i][2]==0x87654321)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x87654321)?context12345678->channelContext[0]:context87654321->channelContext[0], patternZRTPPackets[i], patternZRTPMetaData[i][0], zrtpPacket);
//flaw_line_below:
		/*printf(""parsing Ret val is %x index is %d\n"", retval, i);*/
//fix_flaw_line_below:
//		if (hvi_trick==0) {
//fix_flaw_line_below:
//			CU_ASSERT_EQUAL_FATAL(retval,0);
//fix_flaw_line_below:
//		} else { /* when hvi trick is enable, the DH2 parsing shall fail and return BZRTP_PARSER_ERROR_UNMATCHINGHVI */
//fix_flaw_line_below:
//			if (zrtpPacket->messageType==MSGTYPE_DHPART2) {
//fix_flaw_line_below:
//				CU_ASSERT_EQUAL_FATAL(retval, BZRTP_PARSER_ERROR_UNMATCHINGHVI);
//fix_flaw_line_below:
//				/* We shall then anyway skip the end of the test */
//fix_flaw_line_below:
//				/* reset pointers to selfHello packet in order to avoid double free */
//fix_flaw_line_below:
//				context87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;
//fix_flaw_line_below:
//				context12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//				bzrtp_destroyBzrtpContext(context87654321, 0x87654321);
//fix_flaw_line_below:
//				bzrtp_destroyBzrtpContext(context12345678, 0x12345678);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//				return;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//			} else {
//fix_flaw_line_below:
//				CU_ASSERT_EQUAL_FATAL(retval,0);
//fix_flaw_line_below:
//			}
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//			bzrtp_message(""parsing Ret val is %x index is %d\n"", retval, i);
 		/* We must store some packets in the context if we want to be able to parse further packets */
 		if (zrtpPacket->messageType==MSGTYPE_HELLO) {
 			if (patternZRTPMetaData[i][2]==0x87654321) {
 				context12345678->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
//fix_flaw_line_below:
//				context87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
 			} else {
 				context87654321->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
//fix_flaw_line_below:
//				context12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
 			}
 			freePacketFlag = 0;
 		}
		if (zrtpPacket->messageType==MSGTYPE_COMMIT) {
			if (patternZRTPMetaData[i][2]==0x87654321) {
				context12345678->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;
			} else {
				context87654321->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;
			}
			freePacketFlag = 0;
		}
		if (zrtpPacket->messageType==MSGTYPE_DHPART1 || zrtpPacket->messageType==MSGTYPE_DHPART2) {
			if (patternZRTPMetaData[i][2]==0x87654321) {
				context12345678->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;
			} else {
				context87654321->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;
			}
			freePacketFlag = 0;
		}
		/* free the packet string as will be created again by the packetBuild function and might have been copied by packetParser */
		free(zrtpPacket->packetString);
		/* build a packet string from the parser packet*/
		retval = bzrtp_packetBuild((patternZRTPMetaData[i][2]==0x12345678)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x12345678)?context12345678->channelContext[0]:context87654321->channelContext[0], zrtpPacket, patternZRTPMetaData[i][1]);
		/* if (retval ==0) {
			packetDump(zrtpPacket, 1);
		} else {
			bzrtp_message(""Ret val is %x index is %d\n"", retval, i);
		}*/

		/* check they are the same */
		if (zrtpPacket->packetString != NULL) {
			CU_ASSERT_TRUE(memcmp(zrtpPacket->packetString, patternZRTPPackets[i], patternZRTPMetaData[i][0]) == 0);
		} else {
			CU_FAIL(""Unable to build packet"");
		}

 		if (freePacketFlag == 1) {
 			bzrtp_freeZrtpPacket(zrtpPacket);
 		}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//		/* modify the hvi stored in the peerPackets, this shall result in parsing failure on DH2 packet */
//fix_flaw_line_below:
//		if (hvi_trick == 1) {
//fix_flaw_line_below:
//			if (zrtpPacket->messageType==MSGTYPE_COMMIT) {
//fix_flaw_line_below:
//				if (patternZRTPMetaData[i][2]==0x87654321) {
//fix_flaw_line_below:
//					bzrtpCommitMessage_t *peerCommitMessageData;
//fix_flaw_line_below:
//					peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpPacket->messageData;
//fix_flaw_line_below:
//					peerCommitMessageData->hvi[0]=0xFF;
//fix_flaw_line_below:
//				}
//fix_flaw_line_below:
//			}
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//
 	}
 
//fix_flaw_line_below:
//	/* reset pointers to selfHello packet in order to avoid double free */
//fix_flaw_line_below:
//	context87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;
//fix_flaw_line_below:
//	context12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//
 	bzrtp_destroyBzrtpContext(context87654321, 0x87654321);
 	bzrtp_destroyBzrtpContext(context12345678, 0x12345678);
 
 }
"
4266,182002,,Remote,Not required,,CVE-2016-6271,https://www.cvedetails.com/cve/CVE-2016-6271/,CWE-254,Low,,Partial,,2017-01-18,5.0,The Bzrtp library (aka libbzrtp) 1.0.x before 1.0.4 allows man-in-the-middle attackers to conduct spoofing attacks by leveraging a missing HVI check on DHPart2 packet reception.,2017-08-02,,1,https://github.com/BelledonneCommunications/bzrtp/commit/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,Add ZRTP Commit packet hvi check on DHPart2 packet reception,0,test/bzrtpTest.c,"{""sha"": ""95ec6d5ef51cd2f1288e74d8798b1b930db1332c"", ""filename"": ""include/packetParser.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/BelledonneCommunications/bzrtp/blob/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/include/packetParser.h"", ""raw_url"": ""https://github.com/BelledonneCommunications/bzrtp/raw/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/include/packetParser.h"", ""contents_url"": ""https://api.github.com/repos/BelledonneCommunications/bzrtp/contents/include/packetParser.h?ref=bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b"", ""patch"": ""@@ -42,6 +42,7 @@\n #define\t\tBZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN\t0xa080\n #define\t\tBZRTP_PARSER_ERROR_UNMATCHINGMAC\t\t0xa100\n #define\t\tBZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE\t0xa200\n+#define\t\tBZRTP_PARSER_ERROR_UNMATCHINGHVI\t\t0xa400\n \n #define\t\tBZRTP_BUILDER_ERROR_INVALIDPACKET\t\t0x5001\n #define\t\tBZRTP_BUILDER_ERROR_INVALIDMESSAGE\t\t0x5002""}<_**next**_>{""sha"": ""2ca5cdb67005a166d05e23ac588d674a7aa4f9bf"", ""filename"": ""src/packetParser.c"", ""status"": ""modified"", ""additions"": 27, ""deletions"": 1, ""changes"": 28, ""blob_url"": ""https://github.com/BelledonneCommunications/bzrtp/blob/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/src/packetParser.c"", ""raw_url"": ""https://github.com/BelledonneCommunications/bzrtp/raw/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/src/packetParser.c"", ""contents_url"": ""https://api.github.com/repos/BelledonneCommunications/bzrtp/contents/src/packetParser.c?ref=bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b"", ""patch"": ""@@ -438,6 +438,32 @@ int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpC\n \t\t\t\t\t\tfree (messageData);\n \t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n \t\t\t\t\t}\n+\n+\t\t\t\t\t/* Check the hvi received in the commit message  - RFC section 4.4.1.1*/\n+\t\t\t\t\t/* First compute the expected hvi */\n+\t\t\t\t\t/* hvi = hash(initiator's DHPart2 message(current zrtpPacket)) || responder's Hello message) using the agreed hash function truncated to 256 bits */\n+\t\t\t\t\t/* create a string with the messages concatenated */\n+\t\t\t\t\t{\n+\t\t\t\t\t\tuint8_t computedHvi[32];\n+\t\t\t\t\t\tuint16_t HelloMessageLength = zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;\n+\t\t\t\t\t\tuint16_t DHPartHelloMessageStringLength = zrtpPacket->messageLength + HelloMessageLength;\n+\n+\t\t\t\t\t\tuint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));\n+\n+\t\t\t\t\t\tmemcpy(DHPartHelloMessageString, input+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength);\n+\t\t\t\t\t\tmemcpy(DHPartHelloMessageString+zrtpPacket->messageLength, zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);\n+\n+\t\t\t\t\t\tzrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, computedHvi);\n+\n+\t\t\t\t\t\tfree(DHPartHelloMessageString);\n+\n+\t\t\t\t\t\t/* Compare computed and received hvi */\n+\t\t\t\t\t\tif (memcmp(computedHvi, peerCommitMessageData->hvi, 32)!=0) {\n+\t\t\t\t\t\t\tfree (messageData);\n+\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHVI;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n \t\t\t\t} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */\n \t\t\t\t\tuint8_t checkH2[32];\n \t\t\t\t\tuint8_t checkH3[32];\n@@ -482,7 +508,7 @@ int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpC\n \t\t\t\t/* attach the message structure to the packet one */\n \t\t\t\tzrtpPacket->messageData = (void *)messageData;\n \n-\t\t\t\t/* the parsed commit packet must be saved as it is used to generate the total_hash */\n+\t\t\t\t/* the parsed packet must be saved as it is used to generate the total_hash */\n \t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n \t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n \t\t\t}""}<_**next**_>{""sha"": ""faa1b8ce0edc5ba51d51e658e291915659f56089"", ""filename"": ""test/bzrtpParserTest.c"", ""status"": ""modified"", ""additions"": 49, ""deletions"": 2, ""changes"": 51, ""blob_url"": ""https://github.com/BelledonneCommunications/bzrtp/blob/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpParserTest.c"", ""raw_url"": ""https://github.com/BelledonneCommunications/bzrtp/raw/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpParserTest.c"", ""contents_url"": ""https://api.github.com/repos/BelledonneCommunications/bzrtp/contents/test/bzrtpParserTest.c?ref=bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b"", ""patch"": ""@@ -101,7 +101,8 @@ uint8_t mackeyr[32] = {0x3a, 0xa5, 0x22, 0x43, 0x26, 0x13, 0x8f, 0xd6, 0x54, 0x5\n uint8_t zrtpkeyi[16] = {0x22, 0xf6, 0xea, 0xaa, 0xa4, 0xad, 0x53, 0x30, 0x71, 0x97, 0xcc, 0x68, 0x6b, 0xb0, 0xcb, 0x55};\n uint8_t zrtpkeyr[16] = {0x09, 0x50, 0xcd, 0x9e, 0xc2, 0x78, 0x54, 0x31, 0x93, 0x2e, 0x99, 0x31, 0x15, 0x58, 0xd0, 0x2a};\n \n-void test_parser(void) {\n+\n+void test_parser_param(uint8_t hvi_trick) {\n \tint i, retval;\n \tbzrtpPacket_t *zrtpPacket;\n \n@@ -159,13 +160,34 @@ void test_parser(void) {\n \t\t/* parse a packet string from patterns */\n \t\tzrtpPacket = bzrtp_packetCheck(patternZRTPPackets[i], patternZRTPMetaData[i][0], (patternZRTPMetaData[i][1])-1, &retval);\n \t\tretval +=  bzrtp_packetParser((patternZRTPMetaData[i][2]==0x87654321)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x87654321)?context12345678->channelContext[0]:context87654321->channelContext[0], patternZRTPPackets[i], patternZRTPMetaData[i][0], zrtpPacket);\n-\t\t/*printf(\""parsing Ret val is %x index is %d\\n\"", retval, i);*/\n+\t\tif (hvi_trick==0) {\n+\t\t\tCU_ASSERT_EQUAL_FATAL(retval,0);\n+\t\t} else { /* when hvi trick is enable, the DH2 parsing shall fail and return BZRTP_PARSER_ERROR_UNMATCHINGHVI */\n+\t\t\tif (zrtpPacket->messageType==MSGTYPE_DHPART2) {\n+\t\t\t\tCU_ASSERT_EQUAL_FATAL(retval, BZRTP_PARSER_ERROR_UNMATCHINGHVI);\n+\t\t\t\t/* We shall then anyway skip the end of the test */\n+\t\t\t\t/* reset pointers to selfHello packet in order to avoid double free */\n+\t\t\t\tcontext87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;\n+\t\t\t\tcontext12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;\n+\n+\t\t\t\tbzrtp_destroyBzrtpContext(context87654321, 0x87654321);\n+\t\t\t\tbzrtp_destroyBzrtpContext(context12345678, 0x12345678);\n+\n+\t\t\t\treturn;\n+\n+\t\t\t} else {\n+\t\t\t\tCU_ASSERT_EQUAL_FATAL(retval,0);\n+\t\t\t}\n+\t\t}\n+\t\t\tbzrtp_message(\""parsing Ret val is %x index is %d\\n\"", retval, i);\n \t\t/* We must store some packets in the context if we want to be able to parse further packets */\n \t\tif (zrtpPacket->messageType==MSGTYPE_HELLO) {\n \t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n \t\t\t\tcontext12345678->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n+\t\t\t\tcontext87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n \t\t\t} else {\n \t\t\t\tcontext87654321->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n+\t\t\t\tcontext12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n \t\t\t}\n \t\t\tfreePacketFlag = 0;\n \t\t}\n@@ -205,13 +227,38 @@ void test_parser(void) {\n \t\tif (freePacketFlag == 1) {\n \t\t\tbzrtp_freeZrtpPacket(zrtpPacket);\n \t\t}\n+\n+\t\t/* modify the hvi stored in the peerPackets, this shall result in parsing failure on DH2 packet */\n+\t\tif (hvi_trick == 1) {\n+\t\t\tif (zrtpPacket->messageType==MSGTYPE_COMMIT) {\n+\t\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n+\t\t\t\t\tbzrtpCommitMessage_t *peerCommitMessageData;\n+\t\t\t\t\tpeerCommitMessageData = (bzrtpCommitMessage_t *)zrtpPacket->messageData;\n+\t\t\t\t\tpeerCommitMessageData->hvi[0]=0xFF;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n \t}\n \n+\t/* reset pointers to selfHello packet in order to avoid double free */\n+\tcontext87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;\n+\tcontext12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;\n+\n+\n \tbzrtp_destroyBzrtpContext(context87654321, 0x87654321);\n \tbzrtp_destroyBzrtpContext(context12345678, 0x12345678);\n \n }\n \n+void test_parser(void) {\n+\ttest_parser_param(0);\n+}\n+\n+void test_parser_hvi(void) {\n+\ttest_parser_param(1);\n+}\n+\n /* context structure mainly used by statemachine test, but also needed by parserComplete to get the zid Filename */\n typedef struct my_Context_struct {\n \tunsigned char nom[30]; /* nom du contexte */""}<_**next**_>{""sha"": ""74548f2c2b41187c4d83dce2dc206a710c33d77f"", ""filename"": ""test/bzrtpParserTest.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/BelledonneCommunications/bzrtp/blob/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpParserTest.h"", ""raw_url"": ""https://github.com/BelledonneCommunications/bzrtp/raw/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpParserTest.h"", ""contents_url"": ""https://api.github.com/repos/BelledonneCommunications/bzrtp/contents/test/bzrtpParserTest.h?ref=bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b"", ""patch"": ""@@ -20,5 +20,6 @@\n  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n  */\n void test_parser(void);\n+void test_parser_hvi(void);\n void test_parserComplete(void);\n void test_stateMachine(void);""}<_**next**_>{""sha"": ""a9fa90f94a9525d8a131369ac1dbc4fcf7ad780d"", ""filename"": ""test/bzrtpTest.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/BelledonneCommunications/bzrtp/blob/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpTest.c"", ""raw_url"": ""https://github.com/BelledonneCommunications/bzrtp/raw/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/test/bzrtpTest.c"", ""contents_url"": ""https://api.github.com/repos/BelledonneCommunications/bzrtp/contents/test/bzrtpTest.c?ref=bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b"", ""patch"": ""@@ -75,6 +75,7 @@ int main(int argc, char *argv[] ) {\n \t/* Add the parser suite to the registry */\n \tparserTestSuite = CU_add_suite(\""Bzrtp ZRTP Packet Parser\"", NULL, NULL);\n \tCU_add_test(parserTestSuite, \""Parse\"", test_parser);\n+\tCU_add_test(parserTestSuite, \""Parse hvi check fail\"", test_parser_hvi);\n \tCU_add_test(parserTestSuite, \""Parse Exchange\"", test_parserComplete);\n \tCU_add_test(parserTestSuite, \""State machine\"", test_stateMachine);\n ""}","int main(int argc, char *argv[] ) {
	int i, fails_count=0;
	CU_pSuite cryptoUtilsTestSuite, parserTestSuite;

	CU_pSuite *suites[] = {
		&cryptoUtilsTestSuite,
		&parserTestSuite,
		NULL
	};

	if (argc>1) {
		if (argv[1][0] == '-') {
			if (strcmp(argv[1], ""-verbose"") == 0) {
				verbose = 1;
			} else {
				printf (""Usage:\n %s [-verbose] to enable extensive logging\n"", argv[0]);
				return 1;
			}
		} else {
			printf (""Usage:\n %s [-verbose] to enable extensive logging\n"", argv[0]);
			return 1;
		}
	}
#ifdef HAVE_LIBXML2
	xmlInitParser();
#endif
	
	/* initialize the CUnit test registry */
	if (CUE_SUCCESS != CU_initialize_registry()) {
		return CU_get_error();
	}

	/* Add the cryptoUtils suite to the registry */
	cryptoUtilsTestSuite = CU_add_suite(""Bzrtp Crypto Utils"", NULL, NULL);
	CU_add_test(cryptoUtilsTestSuite, ""zrtpKDF"", test_zrtpKDF);
	CU_add_test(cryptoUtilsTestSuite, ""CRC32"", test_CRC32);
	CU_add_test(cryptoUtilsTestSuite, ""algo agreement"", test_algoAgreement);
	CU_add_test(cryptoUtilsTestSuite, ""context algo setter and getter"", test_algoSetterGetter);
	CU_add_test(cryptoUtilsTestSuite, ""adding mandatory crypto algorithms if needed"", test_addMandatoryCryptoTypesIfNeeded);

 	/* Add the parser suite to the registry */
 	parserTestSuite = CU_add_suite(""Bzrtp ZRTP Packet Parser"", NULL, NULL);
 	CU_add_test(parserTestSuite, ""Parse"", test_parser);
	CU_add_test(parserTestSuite, ""Parse hvi check fail"", test_parser_hvi);
 	CU_add_test(parserTestSuite, ""Parse Exchange"", test_parserComplete);
 	CU_add_test(parserTestSuite, ""State machine"", test_stateMachine);
 
	/* Run all suites */
	for(i=0; suites[i]; i++){
		CU_basic_run_suite(*suites[i]);
		fails_count += CU_get_number_of_tests_failed();
	}
	
	/* cleanup the CUnit registry */
	CU_cleanup_registry();

#ifdef HAVE_LIBXML2
	/* cleanup libxml2 */
	xmlCleanupParser();
#endif

	return (fails_count == 0 ? 0 : 1);
}
","int main(int argc, char *argv[] ) {
	int i, fails_count=0;
	CU_pSuite cryptoUtilsTestSuite, parserTestSuite;

	CU_pSuite *suites[] = {
		&cryptoUtilsTestSuite,
		&parserTestSuite,
		NULL
	};

	if (argc>1) {
		if (argv[1][0] == '-') {
			if (strcmp(argv[1], ""-verbose"") == 0) {
				verbose = 1;
			} else {
				printf (""Usage:\n %s [-verbose] to enable extensive logging\n"", argv[0]);
				return 1;
			}
		} else {
			printf (""Usage:\n %s [-verbose] to enable extensive logging\n"", argv[0]);
			return 1;
		}
	}
#ifdef HAVE_LIBXML2
	xmlInitParser();
#endif
	
	/* initialize the CUnit test registry */
	if (CUE_SUCCESS != CU_initialize_registry()) {
		return CU_get_error();
	}

	/* Add the cryptoUtils suite to the registry */
	cryptoUtilsTestSuite = CU_add_suite(""Bzrtp Crypto Utils"", NULL, NULL);
	CU_add_test(cryptoUtilsTestSuite, ""zrtpKDF"", test_zrtpKDF);
	CU_add_test(cryptoUtilsTestSuite, ""CRC32"", test_CRC32);
	CU_add_test(cryptoUtilsTestSuite, ""algo agreement"", test_algoAgreement);
	CU_add_test(cryptoUtilsTestSuite, ""context algo setter and getter"", test_algoSetterGetter);
	CU_add_test(cryptoUtilsTestSuite, ""adding mandatory crypto algorithms if needed"", test_addMandatoryCryptoTypesIfNeeded);

 	/* Add the parser suite to the registry */
 	parserTestSuite = CU_add_suite(""Bzrtp ZRTP Packet Parser"", NULL, NULL);
 	CU_add_test(parserTestSuite, ""Parse"", test_parser);
 	CU_add_test(parserTestSuite, ""Parse Exchange"", test_parserComplete);
 	CU_add_test(parserTestSuite, ""State machine"", test_stateMachine);
 
	/* Run all suites */
	for(i=0; suites[i]; i++){
		CU_basic_run_suite(*suites[i]);
		fails_count += CU_get_number_of_tests_failed();
	}
	
	/* cleanup the CUnit registry */
	CU_cleanup_registry();

#ifdef HAVE_LIBXML2
	/* cleanup libxml2 */
	xmlCleanupParser();
#endif

	return (fails_count == 0 ? 0 : 1);
}
",C,"	CU_add_test(parserTestSuite, ""Parse hvi check fail"", test_parser_hvi);
",,,"@@ -75,6 +75,7 @@ int main(int argc, char *argv[] ) {
 	/* Add the parser suite to the registry */
 	parserTestSuite = CU_add_suite(""Bzrtp ZRTP Packet Parser"", NULL, NULL);
 	CU_add_test(parserTestSuite, ""Parse"", test_parser);
+	CU_add_test(parserTestSuite, ""Parse hvi check fail"", test_parser_hvi);
 	CU_add_test(parserTestSuite, ""Parse Exchange"", test_parserComplete);
 	CU_add_test(parserTestSuite, ""State machine"", test_stateMachine);
 ",bzrtp,bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,d5d9ee8c4ae783ff4500017f535e838ed4585ba5,1,"int main(int argc, char *argv[] ) {
	int i, fails_count=0;
	CU_pSuite cryptoUtilsTestSuite, parserTestSuite;

	CU_pSuite *suites[] = {
		&cryptoUtilsTestSuite,
		&parserTestSuite,
		NULL
	};

	if (argc>1) {
		if (argv[1][0] == '-') {
			if (strcmp(argv[1], ""-verbose"") == 0) {
				verbose = 1;
			} else {
				printf (""Usage:\n %s [-verbose] to enable extensive logging\n"", argv[0]);
				return 1;
			}
		} else {
			printf (""Usage:\n %s [-verbose] to enable extensive logging\n"", argv[0]);
			return 1;
		}
	}
#ifdef HAVE_LIBXML2
	xmlInitParser();
#endif
	
	/* initialize the CUnit test registry */
	if (CUE_SUCCESS != CU_initialize_registry()) {
		return CU_get_error();
	}

	/* Add the cryptoUtils suite to the registry */
	cryptoUtilsTestSuite = CU_add_suite(""Bzrtp Crypto Utils"", NULL, NULL);
	CU_add_test(cryptoUtilsTestSuite, ""zrtpKDF"", test_zrtpKDF);
	CU_add_test(cryptoUtilsTestSuite, ""CRC32"", test_CRC32);
	CU_add_test(cryptoUtilsTestSuite, ""algo agreement"", test_algoAgreement);
	CU_add_test(cryptoUtilsTestSuite, ""context algo setter and getter"", test_algoSetterGetter);
	CU_add_test(cryptoUtilsTestSuite, ""adding mandatory crypto algorithms if needed"", test_addMandatoryCryptoTypesIfNeeded);

 	/* Add the parser suite to the registry */
 	parserTestSuite = CU_add_suite(""Bzrtp ZRTP Packet Parser"", NULL, NULL);
 	CU_add_test(parserTestSuite, ""Parse"", test_parser);
//fix_flaw_line_below:
//	CU_add_test(parserTestSuite, ""Parse hvi check fail"", test_parser_hvi);
 	CU_add_test(parserTestSuite, ""Parse Exchange"", test_parserComplete);
 	CU_add_test(parserTestSuite, ""State machine"", test_stateMachine);
 
	/* Run all suites */
	for(i=0; suites[i]; i++){
		CU_basic_run_suite(*suites[i]);
		fails_count += CU_get_number_of_tests_failed();
	}
	
	/* cleanup the CUnit registry */
	CU_cleanup_registry();

#ifdef HAVE_LIBXML2
	/* cleanup libxml2 */
	xmlCleanupParser();
#endif

	return (fails_count == 0 ? 0 : 1);
}
"
4304,182040,,Local,Not required,,CVE-2015-7837,https://www.cvedetails.com/cve/CVE-2015-7837/,CWE-254,Low,,Partial,,2017-09-19,2.1,"The Linux kernel, as used in Red Hat Enterprise Linux 7, kernel-rt, and Enterprise MRG 2 and when booted with UEFI Secure Boot enabled, allows local users to bypass intended securelevel/secureboot restrictions by leveraging improper handling of secure_boot flag across kexec reboot.",2017-10-05,Bypass ,1,https://github.com/mjg59/linux/commit/4b2b64d5a6ebc84214755ebccd599baef7c1b798,4b2b64d5a6ebc84214755ebccd599baef7c1b798,"kexec/uefi: copy secure_boot flag in boot params across kexec reboot

Kexec reboot in case secure boot being enabled does not keep the secure
boot mode in new kernel, so later one can load unsigned kernel via legacy
kexec_load.  In this state, the system is missing the protections provided
by secure boot. Adding a patch to fix this by retain the secure_boot flag
in original kernel.

secure_boot flag in boot_params is set in EFI stub, but kexec bypasses the
stub. Fixing this issue by copying secure_boot flag across kexec reboot.

Signed-off-by: Dave Young <dyoung@redhat.com>",0,arch/x86/kernel/kexec-bzimage64.c,"{""sha"": ""61827eeb6881f429d2a7f625f541b6eaee4a05be"", ""filename"": ""arch/x86/kernel/kexec-bzimage64.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/mjg59/linux/blob/4b2b64d5a6ebc84214755ebccd599baef7c1b798/arch/x86/kernel/kexec-bzimage64.c"", ""raw_url"": ""https://github.com/mjg59/linux/raw/4b2b64d5a6ebc84214755ebccd599baef7c1b798/arch/x86/kernel/kexec-bzimage64.c"", ""contents_url"": ""https://api.github.com/repos/mjg59/linux/contents/arch/x86/kernel/kexec-bzimage64.c?ref=4b2b64d5a6ebc84214755ebccd599baef7c1b798"", ""patch"": ""@@ -180,6 +180,7 @@ setup_efi_state(struct boot_params *params, unsigned long params_load_addr,\n \tif (efi_enabled(EFI_OLD_MEMMAP))\n \t\treturn 0;\n \n+\tparams->secure_boot = boot_params.secure_boot;\n \tei->efi_loader_signature = current_ei->efi_loader_signature;\n \tei->efi_systab = current_ei->efi_systab;\n \tei->efi_systab_hi = current_ei->efi_systab_hi;""}","setup_efi_state(struct boot_params *params, unsigned long params_load_addr,
		unsigned int efi_map_offset, unsigned int efi_map_sz,
		unsigned int efi_setup_data_offset)
{
	struct efi_info *current_ei = &boot_params.efi_info;
	struct efi_info *ei = &params->efi_info;

	if (!current_ei->efi_memmap_size)
		return 0;

	/*
	 * If 1:1 mapping is not enabled, second kernel can not setup EFI
	 * and use EFI run time services. User space will have to pass
	 * acpi_rsdp=<addr> on kernel command line to make second kernel boot
	 * without efi.
	 */
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return 0;
 
	params->secure_boot = boot_params.secure_boot;
 	ei->efi_loader_signature = current_ei->efi_loader_signature;
 	ei->efi_systab = current_ei->efi_systab;
 	ei->efi_systab_hi = current_ei->efi_systab_hi;

	ei->efi_memdesc_version = current_ei->efi_memdesc_version;
	ei->efi_memdesc_size = efi_get_runtime_map_desc_size();

	setup_efi_info_memmap(params, params_load_addr, efi_map_offset,
			      efi_map_sz);
	prepare_add_efi_setup_data(params, params_load_addr,
				   efi_setup_data_offset);
	return 0;
}
","setup_efi_state(struct boot_params *params, unsigned long params_load_addr,
		unsigned int efi_map_offset, unsigned int efi_map_sz,
		unsigned int efi_setup_data_offset)
{
	struct efi_info *current_ei = &boot_params.efi_info;
	struct efi_info *ei = &params->efi_info;

	if (!current_ei->efi_memmap_size)
		return 0;

	/*
	 * If 1:1 mapping is not enabled, second kernel can not setup EFI
	 * and use EFI run time services. User space will have to pass
	 * acpi_rsdp=<addr> on kernel command line to make second kernel boot
	 * without efi.
	 */
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return 0;
 
 	ei->efi_loader_signature = current_ei->efi_loader_signature;
 	ei->efi_systab = current_ei->efi_systab;
 	ei->efi_systab_hi = current_ei->efi_systab_hi;

	ei->efi_memdesc_version = current_ei->efi_memdesc_version;
	ei->efi_memdesc_size = efi_get_runtime_map_desc_size();

	setup_efi_info_memmap(params, params_load_addr, efi_map_offset,
			      efi_map_sz);
	prepare_add_efi_setup_data(params, params_load_addr,
				   efi_setup_data_offset);
	return 0;
}
",C,"	params->secure_boot = boot_params.secure_boot;
",,,"@@ -180,6 +180,7 @@ setup_efi_state(struct boot_params *params, unsigned long params_load_addr,
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return 0;
 
+	params->secure_boot = boot_params.secure_boot;
 	ei->efi_loader_signature = current_ei->efi_loader_signature;
 	ei->efi_systab = current_ei->efi_systab;
 	ei->efi_systab_hi = current_ei->efi_systab_hi;",linux,4b2b64d5a6ebc84214755ebccd599baef7c1b798,500a87278c5c0608ba88ed8af7a35fcfa955c492,1,"setup_efi_state(struct boot_params *params, unsigned long params_load_addr,
		unsigned int efi_map_offset, unsigned int efi_map_sz,
		unsigned int efi_setup_data_offset)
{
	struct efi_info *current_ei = &boot_params.efi_info;
	struct efi_info *ei = &params->efi_info;

	if (!current_ei->efi_memmap_size)
		return 0;

	/*
	 * If 1:1 mapping is not enabled, second kernel can not setup EFI
	 * and use EFI run time services. User space will have to pass
	 * acpi_rsdp=<addr> on kernel command line to make second kernel boot
	 * without efi.
	 */
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return 0;
 
//fix_flaw_line_below:
//	params->secure_boot = boot_params.secure_boot;
 	ei->efi_loader_signature = current_ei->efi_loader_signature;
 	ei->efi_systab = current_ei->efi_systab;
 	ei->efi_systab_hi = current_ei->efi_systab_hi;

	ei->efi_memdesc_version = current_ei->efi_memdesc_version;
	ei->efi_memdesc_size = efi_get_runtime_map_desc_size();

	setup_efi_info_memmap(params, params_load_addr, efi_map_offset,
			      efi_map_sz);
	prepare_add_efi_setup_data(params, params_load_addr,
				   efi_setup_data_offset);
	return 0;
}
"
5299,183035,,Remote,Not required,,CVE-2016-10746,https://www.cvedetails.com/cve/CVE-2016-10746/,CWE-254,Low,,Partial,,2019-04-18,5.0,"libvirt-domain.c in libvirt before 1.3.1 supports virDomainGetTime API calls by guest agents with an RO connection, even though an RW connection was supposed to be required, a different vulnerability than CVE-2019-3886.",2019-05-01,,1,https://github.com/libvirt/libvirt/commit/506e9d6c2d4baaf580d489fff0690c0ff2ff588f,506e9d6c2d4baaf580d489fff0690c0ff2ff588f,"virDomainGetTime: Deny on RO connections

We have a policy that if API may end up talking to a guest agent
it should require RW connection. We don't obey the rule in
virDomainGetTime().

Signed-off-by: Michal Privoznik <mprivozn@redhat.com>",0,src/libvirt-domain.c,"{""sha"": ""9491845758570c879e28b18c4b4133ec76a48e90"", ""filename"": ""src/libvirt-domain.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/libvirt/libvirt/blob/506e9d6c2d4baaf580d489fff0690c0ff2ff588f/src/libvirt-domain.c"", ""raw_url"": ""https://github.com/libvirt/libvirt/raw/506e9d6c2d4baaf580d489fff0690c0ff2ff588f/src/libvirt-domain.c"", ""contents_url"": ""https://api.github.com/repos/libvirt/libvirt/contents/src/libvirt-domain.c?ref=506e9d6c2d4baaf580d489fff0690c0ff2ff588f"", ""patch"": ""@@ -10934,6 +10934,7 @@ virDomainGetTime(virDomainPtr dom,\n     virResetLastError();\n \n     virCheckDomainReturn(dom, -1);\n+    virCheckReadOnlyGoto(dom->conn->flags, error);\n \n     if (dom->conn->driver->domainGetTime) {\n         int ret = dom->conn->driver->domainGetTime(dom, seconds,""}","virDomainGetTime(virDomainPtr dom,
                 long long *seconds,
                 unsigned int *nseconds,
                 unsigned int flags)
{
    VIR_DOMAIN_DEBUG(dom, ""seconds=%p, nseconds=%p, flags=%x"",
                     seconds, nseconds, flags);

     virResetLastError();
 
     virCheckDomainReturn(dom, -1);
    virCheckReadOnlyGoto(dom->conn->flags, error);
 
     if (dom->conn->driver->domainGetTime) {
         int ret = dom->conn->driver->domainGetTime(dom, seconds,
                                                   nseconds, flags);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(dom->conn);
    return -1;
}
","virDomainGetTime(virDomainPtr dom,
                 long long *seconds,
                 unsigned int *nseconds,
                 unsigned int flags)
{
    VIR_DOMAIN_DEBUG(dom, ""seconds=%p, nseconds=%p, flags=%x"",
                     seconds, nseconds, flags);

     virResetLastError();
 
     virCheckDomainReturn(dom, -1);
 
     if (dom->conn->driver->domainGetTime) {
         int ret = dom->conn->driver->domainGetTime(dom, seconds,
                                                   nseconds, flags);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(dom->conn);
    return -1;
}
",C,"    virCheckReadOnlyGoto(dom->conn->flags, error);
",,,"@@ -10934,6 +10934,7 @@ virDomainGetTime(virDomainPtr dom,
     virResetLastError();
 
     virCheckDomainReturn(dom, -1);
+    virCheckReadOnlyGoto(dom->conn->flags, error);
 
     if (dom->conn->driver->domainGetTime) {
         int ret = dom->conn->driver->domainGetTime(dom, seconds,",libvirt,506e9d6c2d4baaf580d489fff0690c0ff2ff588f,95c370f0eead8ab0bedf333d54019f55aa001116,1,"virDomainGetTime(virDomainPtr dom,
                 long long *seconds,
                 unsigned int *nseconds,
                 unsigned int flags)
{
    VIR_DOMAIN_DEBUG(dom, ""seconds=%p, nseconds=%p, flags=%x"",
                     seconds, nseconds, flags);

     virResetLastError();
 
     virCheckDomainReturn(dom, -1);
//fix_flaw_line_below:
//    virCheckReadOnlyGoto(dom->conn->flags, error);
 
     if (dom->conn->driver->domainGetTime) {
         int ret = dom->conn->driver->domainGetTime(dom, seconds,
                                                   nseconds, flags);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(dom->conn);
    return -1;
}
"
5362,183098,,Local,Not required,Complete,CVE-2015-2925,https://www.cvedetails.com/cve/CVE-2015-2925/,CWE-254,Medium,Complete,Complete,,2015-11-16,6.9,"The prepend_path function in fs/dcache.c in the Linux kernel before 4.2.4 does not properly handle rename actions inside a bind mount, which allows local users to bypass an intended container protection mechanism by renaming a directory, related to a *double-chroot attack.*",2018-01-04,Bypass ,7,https://github.com/torvalds/linux/commit/cde93be45a8a90d8c264c776fab63487b5038a65,cde93be45a8a90d8c264c776fab63487b5038a65,"dcache: Handle escaped paths in prepend_path

A rename can result in a dentry that by walking up d_parent
will never reach it's mnt_root.  For lack of a better term
I call this an escaped path.

prepend_path is called by four different functions __d_path,
d_absolute_path, d_path, and getcwd.

__d_path only wants to see paths are connected to the root it passes
in.  So __d_path needs prepend_path to return an error.

d_absolute_path similarly wants to see paths that are connected to
some root.  Escaped paths are not connected to any mnt_root so
d_absolute_path needs prepend_path to return an error greater
than 1.  So escaped paths will be treated like paths on lazily
unmounted mounts.

getcwd needs to prepend ""(unreachable)"" so getcwd also needs
prepend_path to return an error.

d_path is the interesting hold out.  d_path just wants to print
something, and does not care about the weird cases.  Which raises
the question what should be printed?

Given that <escaped_path>/<anything> should result in -ENOENT I
believe it is desirable for escaped paths to be printed as empty
paths.  As there are not really any meaninful path components when
considered from the perspective of a mount tree.

So tweak prepend_path to return an empty path with an new error
code of 3 when it encounters an escaped path.

Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",0,fs/dcache.c,"{""sha"": ""e3b44ca75a1b3ab2a1099197c46c604d169b37d5"", ""filename"": ""fs/dcache.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/cde93be45a8a90d8c264c776fab63487b5038a65/fs/dcache.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/cde93be45a8a90d8c264c776fab63487b5038a65/fs/dcache.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/dcache.c?ref=cde93be45a8a90d8c264c776fab63487b5038a65"", ""patch"": ""@@ -2926,6 +2926,13 @@ static int prepend_path(const struct path *path,\n \n \t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n \t\t\tstruct mount *parent = ACCESS_ONCE(mnt->mnt_parent);\n+\t\t\t/* Escaped? */\n+\t\t\tif (dentry != vfsmnt->mnt_root) {\n+\t\t\t\tbptr = *buffer;\n+\t\t\t\tblen = *buflen;\n+\t\t\t\terror = 3;\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t\t/* Global root? */\n \t\t\tif (mnt != parent) {\n \t\t\t\tdentry = ACCESS_ONCE(mnt->mnt_mountpoint);""}","static int prepend_path(const struct path *path,
			const struct path *root,
			char **buffer, int *buflen)
{
	struct dentry *dentry;
	struct vfsmount *vfsmnt;
	struct mount *mnt;
	int error = 0;
	unsigned seq, m_seq = 0;
	char *bptr;
	int blen;

	rcu_read_lock();
restart_mnt:
	read_seqbegin_or_lock(&mount_lock, &m_seq);
	seq = 0;
	rcu_read_lock();
restart:
	bptr = *buffer;
	blen = *buflen;
	error = 0;
	dentry = path->dentry;
	vfsmnt = path->mnt;
	mnt = real_mount(vfsmnt);
	read_seqbegin_or_lock(&rename_lock, &seq);
	while (dentry != root->dentry || vfsmnt != root->mnt) {
		struct dentry * parent;
 
 		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
 			struct mount *parent = ACCESS_ONCE(mnt->mnt_parent);
			/* Escaped? */
			if (dentry != vfsmnt->mnt_root) {
				bptr = *buffer;
				blen = *buflen;
				error = 3;
				break;
			}
 			/* Global root? */
 			if (mnt != parent) {
 				dentry = ACCESS_ONCE(mnt->mnt_mountpoint);
				mnt = parent;
				vfsmnt = &mnt->mnt;
				continue;
			}
			if (!error)
				error = is_mounted(vfsmnt) ? 1 : 2;
			break;
		}
		parent = dentry->d_parent;
		prefetch(parent);
		error = prepend_name(&bptr, &blen, &dentry->d_name);
		if (error)
			break;

		dentry = parent;
	}
	if (!(seq & 1))
		rcu_read_unlock();
	if (need_seqretry(&rename_lock, seq)) {
		seq = 1;
		goto restart;
	}
	done_seqretry(&rename_lock, seq);

	if (!(m_seq & 1))
		rcu_read_unlock();
	if (need_seqretry(&mount_lock, m_seq)) {
		m_seq = 1;
		goto restart_mnt;
	}
	done_seqretry(&mount_lock, m_seq);

	if (error >= 0 && bptr == *buffer) {
		if (--blen < 0)
			error = -ENAMETOOLONG;
		else
			*--bptr = '/';
	}
	*buffer = bptr;
	*buflen = blen;
	return error;
}
","static int prepend_path(const struct path *path,
			const struct path *root,
			char **buffer, int *buflen)
{
	struct dentry *dentry;
	struct vfsmount *vfsmnt;
	struct mount *mnt;
	int error = 0;
	unsigned seq, m_seq = 0;
	char *bptr;
	int blen;

	rcu_read_lock();
restart_mnt:
	read_seqbegin_or_lock(&mount_lock, &m_seq);
	seq = 0;
	rcu_read_lock();
restart:
	bptr = *buffer;
	blen = *buflen;
	error = 0;
	dentry = path->dentry;
	vfsmnt = path->mnt;
	mnt = real_mount(vfsmnt);
	read_seqbegin_or_lock(&rename_lock, &seq);
	while (dentry != root->dentry || vfsmnt != root->mnt) {
		struct dentry * parent;
 
 		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
 			struct mount *parent = ACCESS_ONCE(mnt->mnt_parent);
 			/* Global root? */
 			if (mnt != parent) {
 				dentry = ACCESS_ONCE(mnt->mnt_mountpoint);
				mnt = parent;
				vfsmnt = &mnt->mnt;
				continue;
			}
			if (!error)
				error = is_mounted(vfsmnt) ? 1 : 2;
			break;
		}
		parent = dentry->d_parent;
		prefetch(parent);
		error = prepend_name(&bptr, &blen, &dentry->d_name);
		if (error)
			break;

		dentry = parent;
	}
	if (!(seq & 1))
		rcu_read_unlock();
	if (need_seqretry(&rename_lock, seq)) {
		seq = 1;
		goto restart;
	}
	done_seqretry(&rename_lock, seq);

	if (!(m_seq & 1))
		rcu_read_unlock();
	if (need_seqretry(&mount_lock, m_seq)) {
		m_seq = 1;
		goto restart_mnt;
	}
	done_seqretry(&mount_lock, m_seq);

	if (error >= 0 && bptr == *buffer) {
		if (--blen < 0)
			error = -ENAMETOOLONG;
		else
			*--bptr = '/';
	}
	*buffer = bptr;
	*buflen = blen;
	return error;
}
",C,"			/* Escaped? */
			if (dentry != vfsmnt->mnt_root) {
				bptr = *buffer;
				blen = *buflen;
				error = 3;
				break;
			}
",,,"@@ -2926,6 +2926,13 @@ static int prepend_path(const struct path *path,
 
 		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
 			struct mount *parent = ACCESS_ONCE(mnt->mnt_parent);
+			/* Escaped? */
+			if (dentry != vfsmnt->mnt_root) {
+				bptr = *buffer;
+				blen = *buflen;
+				error = 3;
+				break;
+			}
 			/* Global root? */
 			if (mnt != parent) {
 				dentry = ACCESS_ONCE(mnt->mnt_mountpoint);",linux,cde93be45a8a90d8c264c776fab63487b5038a65,6f179af88f60b32c2855e7f3e16ea8e336a7043f,1,"static int prepend_path(const struct path *path,
			const struct path *root,
			char **buffer, int *buflen)
{
	struct dentry *dentry;
	struct vfsmount *vfsmnt;
	struct mount *mnt;
	int error = 0;
	unsigned seq, m_seq = 0;
	char *bptr;
	int blen;

	rcu_read_lock();
restart_mnt:
	read_seqbegin_or_lock(&mount_lock, &m_seq);
	seq = 0;
	rcu_read_lock();
restart:
	bptr = *buffer;
	blen = *buflen;
	error = 0;
	dentry = path->dentry;
	vfsmnt = path->mnt;
	mnt = real_mount(vfsmnt);
	read_seqbegin_or_lock(&rename_lock, &seq);
	while (dentry != root->dentry || vfsmnt != root->mnt) {
		struct dentry * parent;
 
 		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
 			struct mount *parent = ACCESS_ONCE(mnt->mnt_parent);
//fix_flaw_line_below:
//			/* Escaped? */
//fix_flaw_line_below:
//			if (dentry != vfsmnt->mnt_root) {
//fix_flaw_line_below:
//				bptr = *buffer;
//fix_flaw_line_below:
//				blen = *buflen;
//fix_flaw_line_below:
//				error = 3;
//fix_flaw_line_below:
//				break;
//fix_flaw_line_below:
//			}
 			/* Global root? */
 			if (mnt != parent) {
 				dentry = ACCESS_ONCE(mnt->mnt_mountpoint);
				mnt = parent;
				vfsmnt = &mnt->mnt;
				continue;
			}
			if (!error)
				error = is_mounted(vfsmnt) ? 1 : 2;
			break;
		}
		parent = dentry->d_parent;
		prefetch(parent);
		error = prepend_name(&bptr, &blen, &dentry->d_name);
		if (error)
			break;

		dentry = parent;
	}
	if (!(seq & 1))
		rcu_read_unlock();
	if (need_seqretry(&rename_lock, seq)) {
		seq = 1;
		goto restart;
	}
	done_seqretry(&rename_lock, seq);

	if (!(m_seq & 1))
		rcu_read_unlock();
	if (need_seqretry(&mount_lock, m_seq)) {
		m_seq = 1;
		goto restart_mnt;
	}
	done_seqretry(&mount_lock, m_seq);

	if (error >= 0 && bptr == *buffer) {
		if (--blen < 0)
			error = -ENAMETOOLONG;
		else
			*--bptr = '/';
	}
	*buffer = bptr;
	*buflen = blen;
	return error;
}
"
8021,185757,,Remote,Not required,,CVE-2015-1296,https://www.cvedetails.com/cve/CVE-2015-1296/,CWE-254,Low,,Partial,,2015-09-03,5.0,"The UnescapeURLWithAdjustmentsImpl implementation in net/base/escape.cc in Google Chrome before 45.0.2454.85 does not prevent display of Unicode LOCK characters in the omnibox, which makes it easier for remote attackers to spoof the SSL lock icon by placing one of these characters at the end of a URL, as demonstrated by the omnibox in localizations for right-to-left languages.",2016-12-21,,2,https://github.com/chromium/chromium/commit/5fc08cfb098acce49344d2e89cc27c915903f81c,5fc08cfb098acce49344d2e89cc27c915903f81c,"Clean up Android DownloadManager code as most download now go through Chrome Network stack

The only exception is OMA DRM download.
And it only applies to context menu download interception.
Clean up the remaining unused code now.

BUG=647755

Review-Url: https://codereview.chromium.org/2371773003
Cr-Commit-Position: refs/heads/master@{#421332}",5,chrome/browser/android/download/chrome_download_delegate.cc,"{""sha"": ""0ef10538498fe7fb6a1a58f56601e42b101111a6"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 125, ""changes"": 159, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -9,7 +9,6 @@\n import android.app.DownloadManager;\n import android.content.Context;\n import android.content.DialogInterface;\n-import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -60,62 +59,18 @@ public boolean onInfoBarButtonClicked(boolean confirm) {\n                 if (confirm) {\n                     DownloadUtils.showDownloadStartToast(mContext);\n                 }\n-                mPendingRequest = null;\n-                return closeBlankTab();\n-            } else if (confirm) {\n-                // User confirmed the download.\n-                if (mPendingRequest.isGETRequest()) {\n-                    final DownloadInfo info = mPendingRequest;\n-                    new AsyncTask<Void, Void, Pair<String, String>>() {\n-                        @Override\n-                        protected Pair<String, String> doInBackground(Void... params) {\n-                            Pair<String, String> result = getDownloadDirectoryNameAndFullPath();\n-                            String fullDirPath = result.second;\n-                            return doesFileAlreadyExists(fullDirPath, info.getFileName())\n-                                    ? result : null;\n-                        }\n-\n-                        @Override\n-                        protected void onPostExecute(Pair<String, String> result) {\n-                            if (result != null) {\n-                                // File already exists.\n-                                String dirName = result.first;\n-                                String fullDirPath = result.second;\n-                                launchDownloadInfoBar(info, dirName, fullDirPath);\n-                            } else {\n-                                enqueueDownloadManagerRequest(info);\n-                            }\n-                        }\n-                    }.execute();\n-                } else {\n-                    DownloadInfo newDownloadInfo =\n-                            DownloadInfo.Builder.fromDownloadInfo(mPendingRequest).build();\n-                    DownloadManagerService.getDownloadManagerService(mContext).onDownloadCompleted(\n-                            newDownloadInfo);\n-                }\n-                mPendingRequest = null;\n-                return false;\n-            } else {\n-                // User did not accept the download, discard the file if it is a POST download.\n-                if (!mPendingRequest.isGETRequest()) {\n-                    discardFile(mPendingRequest.getFilePath());\n-                }\n-                mPendingRequest = null;\n-                return closeBlankTab();\n             }\n+            mPendingRequest = null;\n+            return closeBlankTab();\n         }\n \n         @Override\n         public void onInfoBarDismissed() {\n-            if (mPendingRequest != null) {\n-                if (mPendingRequest.getDownloadGuid() != null) {\n-                    assert mTab != null;\n-                    nativeDangerousDownloadValidated(\n-                            mTab, mPendingRequest.getDownloadGuid(), false);\n-                } else if (!mPendingRequest.isGETRequest()) {\n-                    // Infobar was dismissed, discard the file if a POST download is pending.\n-                    discardFile(mPendingRequest.getFilePath());\n-                }\n+            if (mPendingRequest == null) return;\n+            if (mPendingRequest.getDownloadGuid() != null) {\n+                assert mTab != null;\n+                nativeDangerousDownloadValidated(\n+                        mTab, mPendingRequest.getDownloadGuid(), false);\n             }\n             // Forget the pending request.\n             mPendingRequest = null;\n@@ -151,38 +106,6 @@ public void onDestroyed(Tab tab) {\n         nativeInit(tab.getWebContents());\n     }\n \n-    @CalledByNative\n-    private void requestHttpGetDownload(String url, String userAgent, String contentDisposition,\n-            String mimeType, String cookie, String referer, boolean hasUserGesture,\n-            String filename, long contentLength, boolean mustDownload) {\n-        // If we're dealing with A/V content that's not explicitly marked for download, check if it\n-        // is streamable.\n-        if (!mustDownload) {\n-            // Query the package manager to see if there's a registered handler that matches.\n-            Intent intent = new Intent(Intent.ACTION_VIEW);\n-            intent.setDataAndType(Uri.parse(url), mimeType);\n-            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n-            // If the intent is resolved to ourselves, we don't want to attempt to load the url\n-            // only to try and download it again.\n-            if (DownloadManagerService.openIntent(mContext, intent, false)) {\n-                return;\n-            }\n-        }\n-        DownloadInfo downloadInfo = new DownloadInfo.Builder()\n-                .setUrl(url)\n-                .setUserAgent(userAgent)\n-                .setContentDisposition(contentDisposition)\n-                .setMimeType(mimeType)\n-                .setCookie(cookie)\n-                .setReferer(referer)\n-                .setHasUserGesture(hasUserGesture)\n-                .setFileName(filename)\n-                .setContentLength(contentLength)\n-                .setIsGETRequest(true)\n-                .build();\n-        onDownloadStartNoStream(downloadInfo);\n-    }\n-\n     /**\n      * Notify the host application a download should be done, even if there is a\n      * streaming viewer available for this type.\n@@ -232,7 +155,7 @@ protected void onPostExecute(Object[] result) {\n                 // The proper fix would be to let chrome knows which frame originated the request.\n                 if (\""application/x-shockwave-flash\"".equals(newInfo.getMimeType())) return;\n \n-                if (isDangerousFile(fileName, newMimeType)) {\n+                if (isDangerousFile(fileName)) {\n                     confirmDangerousDownload(newInfo);\n                 } else {\n                     // Not a dangerous file, proceed.\n@@ -480,8 +403,8 @@ private void alertDownloadFailure(String fileName, int reason) {\n      * @param mimeType MIME type of the content.\n      */\n     @CalledByNative\n-    private void onDownloadStarted(String filename, String mimeType) {\n-        if (!isDangerousFile(filename, mimeType)) {\n+    private void onDownloadStarted(String filename) {\n+        if (!isDangerousFile(filename)) {\n             DownloadUtils.showDownloadStartToast(mContext);\n             closeBlankTab();\n         }\n@@ -543,22 +466,10 @@ static String getFileExtension(String url, String filename) {\n      * Check whether a file is dangerous.\n      *\n      * @param filename Name of the file.\n-     * @param mimeType MIME type of the content.\n-     * @return true if the file is dangerous, or false otherwise.\n-     */\n-    protected boolean isDangerousFile(String filename, String mimeType) {\n-        return nativeIsDownloadDangerous(filename) || isDangerousExtension(\n-                MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType));\n-    }\n-\n-    /**\n-     * Check whether a file extension is dangerous.\n-     *\n-     * @param ext Extension of the file.\n      * @return true if the file is dangerous, or false otherwise.\n      */\n-    private static boolean isDangerousExtension(String ext) {\n-        return \""apk\"".equals(ext);\n+    protected boolean isDangerousFile(String filename) {\n+        return nativeIsDownloadDangerous(filename);\n     }\n \n     /**\n@@ -617,32 +528,30 @@ public boolean shouldInterceptContextMenuDownload(String url) {\n         String path = uri.getPath();\n         // OMA downloads have extension \""dm\"" or \""dd\"". For the latter, it\n         // can be handled when native download completes.\n-        if (path != null && (path.endsWith(\"".dm\""))) {\n-            if (mTab == null) return true;\n-            String fileName = URLUtil.guessFileName(\n-                    url, null, OMADownloadHandler.OMA_DRM_MESSAGE_MIME);\n-            final DownloadInfo downloadInfo =\n-                    new DownloadInfo.Builder().setUrl(url).setFileName(fileName).build();\n-            WindowAndroid window = mTab.getWindowAndroid();\n-            if (window.hasPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n-                onDownloadStartNoStream(downloadInfo);\n-            } else if (window.canRequestPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n-                PermissionCallback permissionCallback = new PermissionCallback() {\n-                    @Override\n-                    public void onRequestPermissionsResult(\n-                            String[] permissions, int[] grantResults) {\n-                        if (grantResults.length > 0\n-                                && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n-                            onDownloadStartNoStream(downloadInfo);\n-                        }\n+        if (path == null || !path.endsWith(\"".dm\"")) return false;\n+        if (mTab == null) return true;\n+        String fileName = URLUtil.guessFileName(\n+                url, null, OMADownloadHandler.OMA_DRM_MESSAGE_MIME);\n+        final DownloadInfo downloadInfo =\n+                new DownloadInfo.Builder().setUrl(url).setFileName(fileName).build();\n+        WindowAndroid window = mTab.getWindowAndroid();\n+        if (window.hasPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n+            onDownloadStartNoStream(downloadInfo);\n+        } else if (window.canRequestPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n+            PermissionCallback permissionCallback = new PermissionCallback() {\n+                @Override\n+                public void onRequestPermissionsResult(\n+                        String[] permissions, int[] grantResults) {\n+                    if (grantResults.length > 0\n+                            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n+                        onDownloadStartNoStream(downloadInfo);\n                     }\n-                };\n-                window.requestPermissions(\n-                        new String[] {permission.WRITE_EXTERNAL_STORAGE}, permissionCallback);\n-            }\n-            return true;\n+                }\n+            };\n+            window.requestPermissions(\n+                    new String[] {permission.WRITE_EXTERNAL_STORAGE}, permissionCallback);\n         }\n-        return false;\n+        return true;\n     }\n \n     protected Context getContext() {""}<_**next**_>{""sha"": ""974663c8e9682cfacd171b069e0420ab8f132a36"", ""filename"": ""chrome/browser/android/download/chrome_download_delegate.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 40, ""changes"": 42, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/chrome_download_delegate.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -142,49 +142,11 @@ void ChromeDownloadDelegate::SetJavaRef(JNIEnv* env, jobject jobj) {\n   java_ref_ = env->NewGlobalRef(jobj);\n }\n \n-void ChromeDownloadDelegate::RequestHTTPGetDownload(\n-    const std::string& url,\n-    const std::string& user_agent,\n-    const std::string& content_disposition,\n-    const std::string& mime_type,\n-    const std::string& cookie,\n-    const std::string& referer,\n-    const base::string16& file_name,\n-    int64_t content_length,\n-    bool has_user_gesture,\n-    bool must_download) {\n-  JNIEnv* env = base::android::AttachCurrentThread();\n-  ScopedJavaLocalRef<jstring> jurl =\n-      ConvertUTF8ToJavaString(env, url);\n-  ScopedJavaLocalRef<jstring> juser_agent =\n-      ConvertUTF8ToJavaString(env, user_agent);\n-  ScopedJavaLocalRef<jstring> jcontent_disposition =\n-      ConvertUTF8ToJavaString(env, content_disposition);\n-  ScopedJavaLocalRef<jstring> jmime_type =\n-      ConvertUTF8ToJavaString(env, mime_type);\n-  ScopedJavaLocalRef<jstring> jcookie =\n-      ConvertUTF8ToJavaString(env, cookie);\n-  ScopedJavaLocalRef<jstring> jreferer =\n-      ConvertUTF8ToJavaString(env, referer);\n-\n-  // net::GetSuggestedFilename will fallback to \""download\"" as filename.\n-  ScopedJavaLocalRef<jstring> jfilename =\n-      base::android::ConvertUTF16ToJavaString(env, file_name);\n-  Java_ChromeDownloadDelegate_requestHttpGetDownload(\n-      env, java_ref_, jurl, juser_agent, jcontent_disposition, jmime_type,\n-      jcookie, jreferer, has_user_gesture, jfilename, content_length,\n-      must_download);\n-}\n-\n-void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename,\n-                                               const std::string& mime_type) {\n+void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename) {\n   JNIEnv* env = base::android::AttachCurrentThread();\n   ScopedJavaLocalRef<jstring> jfilename = ConvertUTF8ToJavaString(\n       env, filename);\n-  ScopedJavaLocalRef<jstring> jmime_type =\n-      ConvertUTF8ToJavaString(env, mime_type);\n-  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename,\n-                                                jmime_type);\n+  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename);\n }\n \n void ChromeDownloadDelegate::OnDangerousDownload(const std::string& filename,""}<_**next**_>{""sha"": ""2fd96f342f171386656ddfea85d6de88e06582d7"", ""filename"": ""chrome/browser/android/download/chrome_download_delegate.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 12, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/chrome_download_delegate.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -19,18 +19,7 @@ class ChromeDownloadDelegate\n \n   void SetJavaRef(JNIEnv*, jobject obj);\n \n-  void RequestHTTPGetDownload(const std::string& url,\n-                              const std::string& user_agent,\n-                              const std::string& content_disposition,\n-                              const std::string& mime_type,\n-                              const std::string& cookie,\n-                              const std::string& referer,\n-                              const base::string16& file_name,\n-                              int64_t content_length,\n-                              bool has_user_geature,\n-                              bool must_download);\n-  void OnDownloadStarted(const std::string& filename,\n-                         const std::string& mime_type);\n+  void OnDownloadStarted(const std::string& filename);\n   void OnDangerousDownload(const std::string& filename,\n                            const std::string& guid);\n   void RequestFileAccess(intptr_t callback_id);""}<_**next**_>{""sha"": ""337b8ab62358f9e4b403d26def62ed649ef237f2"", ""filename"": ""chrome/browser/android/download/download_controller.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 62, ""changes"": 63, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -234,66 +234,6 @@ bool DownloadController::HasFileAccessPermission(\n       env, GetJavaObject()->Controller(env), jwindow_android);\n }\n \n-void DownloadController::CreateGETDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download,\n-    const DownloadInfo& info) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n-\n-  // We are yielding the UI thread and render_view_host may go away by\n-  // the time we come back. Pass along render_process_id and render_view_id\n-  // to retrieve it later (if it still exists).\n-  BrowserThread::PostTask(\n-      BrowserThread::UI, FROM_HERE,\n-      base::Bind(&DownloadController::StartAndroidDownload,\n-                 base::Unretained(this),\n-                 wc_getter, must_download, info));\n-}\n-\n-void DownloadController::StartAndroidDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n-\n-  WebContents* web_contents = wc_getter.Run();\n-  if (!web_contents) {\n-    // The view went away. Can't proceed.\n-    LOG(ERROR) << \""Download failed on URL:\"" << info.url.spec();\n-    return;\n-  }\n-\n-  AcquireFileAccessPermission(\n-      web_contents,\n-      base::Bind(&DownloadController::StartAndroidDownloadInternal,\n-                 base::Unretained(this), wc_getter, must_download, info));\n-}\n-\n-void DownloadController::StartAndroidDownloadInternal(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info, bool allowed) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n-  if (!allowed)\n-    return;\n-\n-  WebContents* web_contents = wc_getter.Run();\n-  // The view went away. Can't proceed.\n-  if (!web_contents)\n-    return;\n-\n-  base::string16 filename = net::GetSuggestedFilename(\n-      info.url, info.content_disposition,\n-      std::string(),  // referrer_charset\n-      std::string(),  // suggested_name\n-      info.original_mime_type,\n-      default_file_name_);\n-  ChromeDownloadDelegate::FromWebContents(web_contents)->RequestHTTPGetDownload(\n-      info.url.spec(), info.user_agent,\n-      info.content_disposition, info.original_mime_type,\n-      info.cookie, info.referer, filename,\n-      info.total_bytes, info.has_user_gesture,\n-      must_download);\n-}\n-\n void DownloadController::OnDownloadStarted(\n     DownloadItem* download_item) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n@@ -305,8 +245,7 @@ void DownloadController::OnDownloadStarted(\n   download_item->AddObserver(this);\n \n   ChromeDownloadDelegate::FromWebContents(web_contents)->OnDownloadStarted(\n-      download_item->GetTargetFilePath().BaseName().value(),\n-      download_item->GetMimeType());\n+      download_item->GetTargetFilePath().BaseName().value());\n }\n \n void DownloadController::OnDownloadUpdated(DownloadItem* item) {""}<_**next**_>{""sha"": ""163e815daa80f5bafac9c06f2c25c89bbc403f03"", ""filename"": ""chrome/browser/android/download/download_controller.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 14, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -76,10 +76,6 @@ class DownloadController : public DownloadControllerBase {\n   bool HasFileAccessPermission(ui::WindowAndroid* window_android);\n \n   // DownloadControllerBase implementation.\n-  void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) override;\n   void OnDownloadStarted(content::DownloadItem* download_item) override;\n   void StartContextMenuDownload(const content::ContextMenuParams& params,\n                                 content::WebContents* web_contents,\n@@ -92,16 +88,6 @@ class DownloadController : public DownloadControllerBase {\n   // DownloadItem::Observer interface.\n   void OnDownloadUpdated(content::DownloadItem* item) override;\n \n-  void StartAndroidDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info);\n-  void StartAndroidDownloadInternal(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info,\n-      bool allowed);\n-\n   // The download item contains dangerous file types.\n   void OnDangerousDownload(content::DownloadItem *item);\n ""}<_**next**_>{""sha"": ""c317ed4063275fd9796169235f064d41df342cb3"", ""filename"": ""chrome/browser/android/download/download_controller_base.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller_base.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -59,13 +59,6 @@ class DownloadControllerBase : public content::DownloadItem::Observer {\n   static void SetDownloadControllerBase(\n       DownloadControllerBase* download_controller);\n \n-  // Starts a new download request with Android. Should be called on the\n-  // UI thread.\n-  virtual void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) = 0;\n-\n   // Should be called when a download is started. It can be either a GET\n   // request with authentication or a POST request. Notifies the embedding\n   // app about the download. Should be called on the UI thread.""}<_**next**_>{""sha"": ""df198c6cd9a9c5dc6ef1241ae896207a74511397"", ""filename"": ""chrome/browser/android/download/mock_download_controller.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/mock_download_controller.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -17,11 +17,6 @@ MockDownloadController::MockDownloadController()\n \n MockDownloadController::~MockDownloadController() {}\n \n-void MockDownloadController::CreateGETDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info) {\n-}\n-\n void MockDownloadController::OnDownloadStarted(\n     content::DownloadItem* download_item) {\n }""}<_**next**_>{""sha"": ""399fcaf4fcb37454d5e20a48acd5fd5fdf724da7"", ""filename"": ""chrome/browser/android/download/mock_download_controller.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/mock_download_controller.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -25,10 +25,6 @@ class MockDownloadController : public DownloadControllerBase {\n   ~MockDownloadController() override;\n \n   // DownloadControllerBase implementation.\n-  void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) override;\n   void OnDownloadStarted(content::DownloadItem* download_item) override;\n   void StartContextMenuDownload(\n       const content::ContextMenuParams& params,""}","void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename,
void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename) {
   JNIEnv* env = base::android::AttachCurrentThread();
   ScopedJavaLocalRef<jstring> jfilename = ConvertUTF8ToJavaString(
       env, filename);
  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename);
 }
","void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename,
                                               const std::string& mime_type) {
   JNIEnv* env = base::android::AttachCurrentThread();
   ScopedJavaLocalRef<jstring> jfilename = ConvertUTF8ToJavaString(
       env, filename);
  ScopedJavaLocalRef<jstring> jmime_type =
      ConvertUTF8ToJavaString(env, mime_type);
  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename,
                                                jmime_type);
 }
",C,"void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename) {
  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename);
","                                               const std::string& mime_type) {
  ScopedJavaLocalRef<jstring> jmime_type =
      ConvertUTF8ToJavaString(env, mime_type);
  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename,
                                                jmime_type);
",,"@@ -142,49 +142,11 @@ void ChromeDownloadDelegate::SetJavaRef(JNIEnv* env, jobject jobj) {
   java_ref_ = env->NewGlobalRef(jobj);
 }
 
-void ChromeDownloadDelegate::RequestHTTPGetDownload(
-    const std::string& url,
-    const std::string& user_agent,
-    const std::string& content_disposition,
-    const std::string& mime_type,
-    const std::string& cookie,
-    const std::string& referer,
-    const base::string16& file_name,
-    int64_t content_length,
-    bool has_user_gesture,
-    bool must_download) {
-  JNIEnv* env = base::android::AttachCurrentThread();
-  ScopedJavaLocalRef<jstring> jurl =
-      ConvertUTF8ToJavaString(env, url);
-  ScopedJavaLocalRef<jstring> juser_agent =
-      ConvertUTF8ToJavaString(env, user_agent);
-  ScopedJavaLocalRef<jstring> jcontent_disposition =
-      ConvertUTF8ToJavaString(env, content_disposition);
-  ScopedJavaLocalRef<jstring> jmime_type =
-      ConvertUTF8ToJavaString(env, mime_type);
-  ScopedJavaLocalRef<jstring> jcookie =
-      ConvertUTF8ToJavaString(env, cookie);
-  ScopedJavaLocalRef<jstring> jreferer =
-      ConvertUTF8ToJavaString(env, referer);
-
-  // net::GetSuggestedFilename will fallback to ""download"" as filename.
-  ScopedJavaLocalRef<jstring> jfilename =
-      base::android::ConvertUTF16ToJavaString(env, file_name);
-  Java_ChromeDownloadDelegate_requestHttpGetDownload(
-      env, java_ref_, jurl, juser_agent, jcontent_disposition, jmime_type,
-      jcookie, jreferer, has_user_gesture, jfilename, content_length,
-      must_download);
-}
-
-void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename,
-                                               const std::string& mime_type) {
+void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename) {
   JNIEnv* env = base::android::AttachCurrentThread();
   ScopedJavaLocalRef<jstring> jfilename = ConvertUTF8ToJavaString(
       env, filename);
-  ScopedJavaLocalRef<jstring> jmime_type =
-      ConvertUTF8ToJavaString(env, mime_type);
-  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename,
-                                                jmime_type);
+  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename);
 }
 
 void ChromeDownloadDelegate::OnDangerousDownload(const std::string& filename,",Chrome,5fc08cfb098acce49344d2e89cc27c915903f81c,832443eec1ac13b31d044967e8e36469bc4d28c5,1,"void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename,
//flaw_line_below:
                                               const std::string& mime_type) {
//fix_flaw_line_below:
//void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename) {
   JNIEnv* env = base::android::AttachCurrentThread();
   ScopedJavaLocalRef<jstring> jfilename = ConvertUTF8ToJavaString(
       env, filename);
//flaw_line_below:
  ScopedJavaLocalRef<jstring> jmime_type =
//flaw_line_below:
      ConvertUTF8ToJavaString(env, mime_type);
//flaw_line_below:
  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename,
//flaw_line_below:
                                                jmime_type);
//fix_flaw_line_below:
//  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename);
 }
"
8022,185758,,Remote,Not required,,CVE-2015-1296,https://www.cvedetails.com/cve/CVE-2015-1296/,CWE-254,Low,,Partial,,2015-09-03,5.0,"The UnescapeURLWithAdjustmentsImpl implementation in net/base/escape.cc in Google Chrome before 45.0.2454.85 does not prevent display of Unicode LOCK characters in the omnibox, which makes it easier for remote attackers to spoof the SSL lock icon by placing one of these characters at the end of a URL, as demonstrated by the omnibox in localizations for right-to-left languages.",2016-12-21,,0,https://github.com/chromium/chromium/commit/5fc08cfb098acce49344d2e89cc27c915903f81c,5fc08cfb098acce49344d2e89cc27c915903f81c,"Clean up Android DownloadManager code as most download now go through Chrome Network stack

The only exception is OMA DRM download.
And it only applies to context menu download interception.
Clean up the remaining unused code now.

BUG=647755

Review-Url: https://codereview.chromium.org/2371773003
Cr-Commit-Position: refs/heads/master@{#421332}",30,chrome/browser/android/download/chrome_download_delegate.cc,"{""sha"": ""0ef10538498fe7fb6a1a58f56601e42b101111a6"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 125, ""changes"": 159, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -9,7 +9,6 @@\n import android.app.DownloadManager;\n import android.content.Context;\n import android.content.DialogInterface;\n-import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -60,62 +59,18 @@ public boolean onInfoBarButtonClicked(boolean confirm) {\n                 if (confirm) {\n                     DownloadUtils.showDownloadStartToast(mContext);\n                 }\n-                mPendingRequest = null;\n-                return closeBlankTab();\n-            } else if (confirm) {\n-                // User confirmed the download.\n-                if (mPendingRequest.isGETRequest()) {\n-                    final DownloadInfo info = mPendingRequest;\n-                    new AsyncTask<Void, Void, Pair<String, String>>() {\n-                        @Override\n-                        protected Pair<String, String> doInBackground(Void... params) {\n-                            Pair<String, String> result = getDownloadDirectoryNameAndFullPath();\n-                            String fullDirPath = result.second;\n-                            return doesFileAlreadyExists(fullDirPath, info.getFileName())\n-                                    ? result : null;\n-                        }\n-\n-                        @Override\n-                        protected void onPostExecute(Pair<String, String> result) {\n-                            if (result != null) {\n-                                // File already exists.\n-                                String dirName = result.first;\n-                                String fullDirPath = result.second;\n-                                launchDownloadInfoBar(info, dirName, fullDirPath);\n-                            } else {\n-                                enqueueDownloadManagerRequest(info);\n-                            }\n-                        }\n-                    }.execute();\n-                } else {\n-                    DownloadInfo newDownloadInfo =\n-                            DownloadInfo.Builder.fromDownloadInfo(mPendingRequest).build();\n-                    DownloadManagerService.getDownloadManagerService(mContext).onDownloadCompleted(\n-                            newDownloadInfo);\n-                }\n-                mPendingRequest = null;\n-                return false;\n-            } else {\n-                // User did not accept the download, discard the file if it is a POST download.\n-                if (!mPendingRequest.isGETRequest()) {\n-                    discardFile(mPendingRequest.getFilePath());\n-                }\n-                mPendingRequest = null;\n-                return closeBlankTab();\n             }\n+            mPendingRequest = null;\n+            return closeBlankTab();\n         }\n \n         @Override\n         public void onInfoBarDismissed() {\n-            if (mPendingRequest != null) {\n-                if (mPendingRequest.getDownloadGuid() != null) {\n-                    assert mTab != null;\n-                    nativeDangerousDownloadValidated(\n-                            mTab, mPendingRequest.getDownloadGuid(), false);\n-                } else if (!mPendingRequest.isGETRequest()) {\n-                    // Infobar was dismissed, discard the file if a POST download is pending.\n-                    discardFile(mPendingRequest.getFilePath());\n-                }\n+            if (mPendingRequest == null) return;\n+            if (mPendingRequest.getDownloadGuid() != null) {\n+                assert mTab != null;\n+                nativeDangerousDownloadValidated(\n+                        mTab, mPendingRequest.getDownloadGuid(), false);\n             }\n             // Forget the pending request.\n             mPendingRequest = null;\n@@ -151,38 +106,6 @@ public void onDestroyed(Tab tab) {\n         nativeInit(tab.getWebContents());\n     }\n \n-    @CalledByNative\n-    private void requestHttpGetDownload(String url, String userAgent, String contentDisposition,\n-            String mimeType, String cookie, String referer, boolean hasUserGesture,\n-            String filename, long contentLength, boolean mustDownload) {\n-        // If we're dealing with A/V content that's not explicitly marked for download, check if it\n-        // is streamable.\n-        if (!mustDownload) {\n-            // Query the package manager to see if there's a registered handler that matches.\n-            Intent intent = new Intent(Intent.ACTION_VIEW);\n-            intent.setDataAndType(Uri.parse(url), mimeType);\n-            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n-            // If the intent is resolved to ourselves, we don't want to attempt to load the url\n-            // only to try and download it again.\n-            if (DownloadManagerService.openIntent(mContext, intent, false)) {\n-                return;\n-            }\n-        }\n-        DownloadInfo downloadInfo = new DownloadInfo.Builder()\n-                .setUrl(url)\n-                .setUserAgent(userAgent)\n-                .setContentDisposition(contentDisposition)\n-                .setMimeType(mimeType)\n-                .setCookie(cookie)\n-                .setReferer(referer)\n-                .setHasUserGesture(hasUserGesture)\n-                .setFileName(filename)\n-                .setContentLength(contentLength)\n-                .setIsGETRequest(true)\n-                .build();\n-        onDownloadStartNoStream(downloadInfo);\n-    }\n-\n     /**\n      * Notify the host application a download should be done, even if there is a\n      * streaming viewer available for this type.\n@@ -232,7 +155,7 @@ protected void onPostExecute(Object[] result) {\n                 // The proper fix would be to let chrome knows which frame originated the request.\n                 if (\""application/x-shockwave-flash\"".equals(newInfo.getMimeType())) return;\n \n-                if (isDangerousFile(fileName, newMimeType)) {\n+                if (isDangerousFile(fileName)) {\n                     confirmDangerousDownload(newInfo);\n                 } else {\n                     // Not a dangerous file, proceed.\n@@ -480,8 +403,8 @@ private void alertDownloadFailure(String fileName, int reason) {\n      * @param mimeType MIME type of the content.\n      */\n     @CalledByNative\n-    private void onDownloadStarted(String filename, String mimeType) {\n-        if (!isDangerousFile(filename, mimeType)) {\n+    private void onDownloadStarted(String filename) {\n+        if (!isDangerousFile(filename)) {\n             DownloadUtils.showDownloadStartToast(mContext);\n             closeBlankTab();\n         }\n@@ -543,22 +466,10 @@ static String getFileExtension(String url, String filename) {\n      * Check whether a file is dangerous.\n      *\n      * @param filename Name of the file.\n-     * @param mimeType MIME type of the content.\n-     * @return true if the file is dangerous, or false otherwise.\n-     */\n-    protected boolean isDangerousFile(String filename, String mimeType) {\n-        return nativeIsDownloadDangerous(filename) || isDangerousExtension(\n-                MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType));\n-    }\n-\n-    /**\n-     * Check whether a file extension is dangerous.\n-     *\n-     * @param ext Extension of the file.\n      * @return true if the file is dangerous, or false otherwise.\n      */\n-    private static boolean isDangerousExtension(String ext) {\n-        return \""apk\"".equals(ext);\n+    protected boolean isDangerousFile(String filename) {\n+        return nativeIsDownloadDangerous(filename);\n     }\n \n     /**\n@@ -617,32 +528,30 @@ public boolean shouldInterceptContextMenuDownload(String url) {\n         String path = uri.getPath();\n         // OMA downloads have extension \""dm\"" or \""dd\"". For the latter, it\n         // can be handled when native download completes.\n-        if (path != null && (path.endsWith(\"".dm\""))) {\n-            if (mTab == null) return true;\n-            String fileName = URLUtil.guessFileName(\n-                    url, null, OMADownloadHandler.OMA_DRM_MESSAGE_MIME);\n-            final DownloadInfo downloadInfo =\n-                    new DownloadInfo.Builder().setUrl(url).setFileName(fileName).build();\n-            WindowAndroid window = mTab.getWindowAndroid();\n-            if (window.hasPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n-                onDownloadStartNoStream(downloadInfo);\n-            } else if (window.canRequestPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n-                PermissionCallback permissionCallback = new PermissionCallback() {\n-                    @Override\n-                    public void onRequestPermissionsResult(\n-                            String[] permissions, int[] grantResults) {\n-                        if (grantResults.length > 0\n-                                && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n-                            onDownloadStartNoStream(downloadInfo);\n-                        }\n+        if (path == null || !path.endsWith(\"".dm\"")) return false;\n+        if (mTab == null) return true;\n+        String fileName = URLUtil.guessFileName(\n+                url, null, OMADownloadHandler.OMA_DRM_MESSAGE_MIME);\n+        final DownloadInfo downloadInfo =\n+                new DownloadInfo.Builder().setUrl(url).setFileName(fileName).build();\n+        WindowAndroid window = mTab.getWindowAndroid();\n+        if (window.hasPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n+            onDownloadStartNoStream(downloadInfo);\n+        } else if (window.canRequestPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n+            PermissionCallback permissionCallback = new PermissionCallback() {\n+                @Override\n+                public void onRequestPermissionsResult(\n+                        String[] permissions, int[] grantResults) {\n+                    if (grantResults.length > 0\n+                            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n+                        onDownloadStartNoStream(downloadInfo);\n                     }\n-                };\n-                window.requestPermissions(\n-                        new String[] {permission.WRITE_EXTERNAL_STORAGE}, permissionCallback);\n-            }\n-            return true;\n+                }\n+            };\n+            window.requestPermissions(\n+                    new String[] {permission.WRITE_EXTERNAL_STORAGE}, permissionCallback);\n         }\n-        return false;\n+        return true;\n     }\n \n     protected Context getContext() {""}<_**next**_>{""sha"": ""974663c8e9682cfacd171b069e0420ab8f132a36"", ""filename"": ""chrome/browser/android/download/chrome_download_delegate.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 40, ""changes"": 42, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/chrome_download_delegate.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -142,49 +142,11 @@ void ChromeDownloadDelegate::SetJavaRef(JNIEnv* env, jobject jobj) {\n   java_ref_ = env->NewGlobalRef(jobj);\n }\n \n-void ChromeDownloadDelegate::RequestHTTPGetDownload(\n-    const std::string& url,\n-    const std::string& user_agent,\n-    const std::string& content_disposition,\n-    const std::string& mime_type,\n-    const std::string& cookie,\n-    const std::string& referer,\n-    const base::string16& file_name,\n-    int64_t content_length,\n-    bool has_user_gesture,\n-    bool must_download) {\n-  JNIEnv* env = base::android::AttachCurrentThread();\n-  ScopedJavaLocalRef<jstring> jurl =\n-      ConvertUTF8ToJavaString(env, url);\n-  ScopedJavaLocalRef<jstring> juser_agent =\n-      ConvertUTF8ToJavaString(env, user_agent);\n-  ScopedJavaLocalRef<jstring> jcontent_disposition =\n-      ConvertUTF8ToJavaString(env, content_disposition);\n-  ScopedJavaLocalRef<jstring> jmime_type =\n-      ConvertUTF8ToJavaString(env, mime_type);\n-  ScopedJavaLocalRef<jstring> jcookie =\n-      ConvertUTF8ToJavaString(env, cookie);\n-  ScopedJavaLocalRef<jstring> jreferer =\n-      ConvertUTF8ToJavaString(env, referer);\n-\n-  // net::GetSuggestedFilename will fallback to \""download\"" as filename.\n-  ScopedJavaLocalRef<jstring> jfilename =\n-      base::android::ConvertUTF16ToJavaString(env, file_name);\n-  Java_ChromeDownloadDelegate_requestHttpGetDownload(\n-      env, java_ref_, jurl, juser_agent, jcontent_disposition, jmime_type,\n-      jcookie, jreferer, has_user_gesture, jfilename, content_length,\n-      must_download);\n-}\n-\n-void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename,\n-                                               const std::string& mime_type) {\n+void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename) {\n   JNIEnv* env = base::android::AttachCurrentThread();\n   ScopedJavaLocalRef<jstring> jfilename = ConvertUTF8ToJavaString(\n       env, filename);\n-  ScopedJavaLocalRef<jstring> jmime_type =\n-      ConvertUTF8ToJavaString(env, mime_type);\n-  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename,\n-                                                jmime_type);\n+  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename);\n }\n \n void ChromeDownloadDelegate::OnDangerousDownload(const std::string& filename,""}<_**next**_>{""sha"": ""2fd96f342f171386656ddfea85d6de88e06582d7"", ""filename"": ""chrome/browser/android/download/chrome_download_delegate.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 12, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/chrome_download_delegate.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -19,18 +19,7 @@ class ChromeDownloadDelegate\n \n   void SetJavaRef(JNIEnv*, jobject obj);\n \n-  void RequestHTTPGetDownload(const std::string& url,\n-                              const std::string& user_agent,\n-                              const std::string& content_disposition,\n-                              const std::string& mime_type,\n-                              const std::string& cookie,\n-                              const std::string& referer,\n-                              const base::string16& file_name,\n-                              int64_t content_length,\n-                              bool has_user_geature,\n-                              bool must_download);\n-  void OnDownloadStarted(const std::string& filename,\n-                         const std::string& mime_type);\n+  void OnDownloadStarted(const std::string& filename);\n   void OnDangerousDownload(const std::string& filename,\n                            const std::string& guid);\n   void RequestFileAccess(intptr_t callback_id);""}<_**next**_>{""sha"": ""337b8ab62358f9e4b403d26def62ed649ef237f2"", ""filename"": ""chrome/browser/android/download/download_controller.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 62, ""changes"": 63, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -234,66 +234,6 @@ bool DownloadController::HasFileAccessPermission(\n       env, GetJavaObject()->Controller(env), jwindow_android);\n }\n \n-void DownloadController::CreateGETDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download,\n-    const DownloadInfo& info) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n-\n-  // We are yielding the UI thread and render_view_host may go away by\n-  // the time we come back. Pass along render_process_id and render_view_id\n-  // to retrieve it later (if it still exists).\n-  BrowserThread::PostTask(\n-      BrowserThread::UI, FROM_HERE,\n-      base::Bind(&DownloadController::StartAndroidDownload,\n-                 base::Unretained(this),\n-                 wc_getter, must_download, info));\n-}\n-\n-void DownloadController::StartAndroidDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n-\n-  WebContents* web_contents = wc_getter.Run();\n-  if (!web_contents) {\n-    // The view went away. Can't proceed.\n-    LOG(ERROR) << \""Download failed on URL:\"" << info.url.spec();\n-    return;\n-  }\n-\n-  AcquireFileAccessPermission(\n-      web_contents,\n-      base::Bind(&DownloadController::StartAndroidDownloadInternal,\n-                 base::Unretained(this), wc_getter, must_download, info));\n-}\n-\n-void DownloadController::StartAndroidDownloadInternal(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info, bool allowed) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n-  if (!allowed)\n-    return;\n-\n-  WebContents* web_contents = wc_getter.Run();\n-  // The view went away. Can't proceed.\n-  if (!web_contents)\n-    return;\n-\n-  base::string16 filename = net::GetSuggestedFilename(\n-      info.url, info.content_disposition,\n-      std::string(),  // referrer_charset\n-      std::string(),  // suggested_name\n-      info.original_mime_type,\n-      default_file_name_);\n-  ChromeDownloadDelegate::FromWebContents(web_contents)->RequestHTTPGetDownload(\n-      info.url.spec(), info.user_agent,\n-      info.content_disposition, info.original_mime_type,\n-      info.cookie, info.referer, filename,\n-      info.total_bytes, info.has_user_gesture,\n-      must_download);\n-}\n-\n void DownloadController::OnDownloadStarted(\n     DownloadItem* download_item) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n@@ -305,8 +245,7 @@ void DownloadController::OnDownloadStarted(\n   download_item->AddObserver(this);\n \n   ChromeDownloadDelegate::FromWebContents(web_contents)->OnDownloadStarted(\n-      download_item->GetTargetFilePath().BaseName().value(),\n-      download_item->GetMimeType());\n+      download_item->GetTargetFilePath().BaseName().value());\n }\n \n void DownloadController::OnDownloadUpdated(DownloadItem* item) {""}<_**next**_>{""sha"": ""163e815daa80f5bafac9c06f2c25c89bbc403f03"", ""filename"": ""chrome/browser/android/download/download_controller.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 14, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -76,10 +76,6 @@ class DownloadController : public DownloadControllerBase {\n   bool HasFileAccessPermission(ui::WindowAndroid* window_android);\n \n   // DownloadControllerBase implementation.\n-  void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) override;\n   void OnDownloadStarted(content::DownloadItem* download_item) override;\n   void StartContextMenuDownload(const content::ContextMenuParams& params,\n                                 content::WebContents* web_contents,\n@@ -92,16 +88,6 @@ class DownloadController : public DownloadControllerBase {\n   // DownloadItem::Observer interface.\n   void OnDownloadUpdated(content::DownloadItem* item) override;\n \n-  void StartAndroidDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info);\n-  void StartAndroidDownloadInternal(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info,\n-      bool allowed);\n-\n   // The download item contains dangerous file types.\n   void OnDangerousDownload(content::DownloadItem *item);\n ""}<_**next**_>{""sha"": ""c317ed4063275fd9796169235f064d41df342cb3"", ""filename"": ""chrome/browser/android/download/download_controller_base.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller_base.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -59,13 +59,6 @@ class DownloadControllerBase : public content::DownloadItem::Observer {\n   static void SetDownloadControllerBase(\n       DownloadControllerBase* download_controller);\n \n-  // Starts a new download request with Android. Should be called on the\n-  // UI thread.\n-  virtual void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) = 0;\n-\n   // Should be called when a download is started. It can be either a GET\n   // request with authentication or a POST request. Notifies the embedding\n   // app about the download. Should be called on the UI thread.""}<_**next**_>{""sha"": ""df198c6cd9a9c5dc6ef1241ae896207a74511397"", ""filename"": ""chrome/browser/android/download/mock_download_controller.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/mock_download_controller.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -17,11 +17,6 @@ MockDownloadController::MockDownloadController()\n \n MockDownloadController::~MockDownloadController() {}\n \n-void MockDownloadController::CreateGETDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info) {\n-}\n-\n void MockDownloadController::OnDownloadStarted(\n     content::DownloadItem* download_item) {\n }""}<_**next**_>{""sha"": ""399fcaf4fcb37454d5e20a48acd5fd5fdf724da7"", ""filename"": ""chrome/browser/android/download/mock_download_controller.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/mock_download_controller.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -25,10 +25,6 @@ class MockDownloadController : public DownloadControllerBase {\n   ~MockDownloadController() override;\n \n   // DownloadControllerBase implementation.\n-  void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) override;\n   void OnDownloadStarted(content::DownloadItem* download_item) override;\n   void StartContextMenuDownload(\n       const content::ContextMenuParams& params,""}","void ChromeDownloadDelegate::RequestHTTPGetDownload(
","void ChromeDownloadDelegate::RequestHTTPGetDownload(
    const std::string& url,
    const std::string& user_agent,
    const std::string& content_disposition,
    const std::string& mime_type,
    const std::string& cookie,
    const std::string& referer,
    const base::string16& file_name,
    int64_t content_length,
    bool has_user_gesture,
    bool must_download) {
  JNIEnv* env = base::android::AttachCurrentThread();
  ScopedJavaLocalRef<jstring> jurl =
      ConvertUTF8ToJavaString(env, url);
  ScopedJavaLocalRef<jstring> juser_agent =
      ConvertUTF8ToJavaString(env, user_agent);
  ScopedJavaLocalRef<jstring> jcontent_disposition =
      ConvertUTF8ToJavaString(env, content_disposition);
  ScopedJavaLocalRef<jstring> jmime_type =
      ConvertUTF8ToJavaString(env, mime_type);
  ScopedJavaLocalRef<jstring> jcookie =
      ConvertUTF8ToJavaString(env, cookie);
  ScopedJavaLocalRef<jstring> jreferer =
      ConvertUTF8ToJavaString(env, referer);
  ScopedJavaLocalRef<jstring> jfilename =
      base::android::ConvertUTF16ToJavaString(env, file_name);
  Java_ChromeDownloadDelegate_requestHttpGetDownload(
      env, java_ref_, jurl, juser_agent, jcontent_disposition, jmime_type,
      jcookie, jreferer, has_user_gesture, jfilename, content_length,
      must_download);
}
",C,,"    const std::string& url,
    const std::string& user_agent,
    const std::string& content_disposition,
    const std::string& mime_type,
    const std::string& cookie,
    const std::string& referer,
    const base::string16& file_name,
    int64_t content_length,
    bool has_user_gesture,
    bool must_download) {
  JNIEnv* env = base::android::AttachCurrentThread();
  ScopedJavaLocalRef<jstring> jurl =
      ConvertUTF8ToJavaString(env, url);
  ScopedJavaLocalRef<jstring> juser_agent =
      ConvertUTF8ToJavaString(env, user_agent);
  ScopedJavaLocalRef<jstring> jcontent_disposition =
      ConvertUTF8ToJavaString(env, content_disposition);
  ScopedJavaLocalRef<jstring> jmime_type =
      ConvertUTF8ToJavaString(env, mime_type);
  ScopedJavaLocalRef<jstring> jcookie =
      ConvertUTF8ToJavaString(env, cookie);
  ScopedJavaLocalRef<jstring> jreferer =
      ConvertUTF8ToJavaString(env, referer);
  ScopedJavaLocalRef<jstring> jfilename =
      base::android::ConvertUTF16ToJavaString(env, file_name);
  Java_ChromeDownloadDelegate_requestHttpGetDownload(
      env, java_ref_, jurl, juser_agent, jcontent_disposition, jmime_type,
      jcookie, jreferer, has_user_gesture, jfilename, content_length,
      must_download);
}
",,"@@ -142,49 +142,11 @@ void ChromeDownloadDelegate::SetJavaRef(JNIEnv* env, jobject jobj) {
   java_ref_ = env->NewGlobalRef(jobj);
 }
 
-void ChromeDownloadDelegate::RequestHTTPGetDownload(
-    const std::string& url,
-    const std::string& user_agent,
-    const std::string& content_disposition,
-    const std::string& mime_type,
-    const std::string& cookie,
-    const std::string& referer,
-    const base::string16& file_name,
-    int64_t content_length,
-    bool has_user_gesture,
-    bool must_download) {
-  JNIEnv* env = base::android::AttachCurrentThread();
-  ScopedJavaLocalRef<jstring> jurl =
-      ConvertUTF8ToJavaString(env, url);
-  ScopedJavaLocalRef<jstring> juser_agent =
-      ConvertUTF8ToJavaString(env, user_agent);
-  ScopedJavaLocalRef<jstring> jcontent_disposition =
-      ConvertUTF8ToJavaString(env, content_disposition);
-  ScopedJavaLocalRef<jstring> jmime_type =
-      ConvertUTF8ToJavaString(env, mime_type);
-  ScopedJavaLocalRef<jstring> jcookie =
-      ConvertUTF8ToJavaString(env, cookie);
-  ScopedJavaLocalRef<jstring> jreferer =
-      ConvertUTF8ToJavaString(env, referer);
-
-  // net::GetSuggestedFilename will fallback to ""download"" as filename.
-  ScopedJavaLocalRef<jstring> jfilename =
-      base::android::ConvertUTF16ToJavaString(env, file_name);
-  Java_ChromeDownloadDelegate_requestHttpGetDownload(
-      env, java_ref_, jurl, juser_agent, jcontent_disposition, jmime_type,
-      jcookie, jreferer, has_user_gesture, jfilename, content_length,
-      must_download);
-}
-
-void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename,
-                                               const std::string& mime_type) {
+void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename) {
   JNIEnv* env = base::android::AttachCurrentThread();
   ScopedJavaLocalRef<jstring> jfilename = ConvertUTF8ToJavaString(
       env, filename);
-  ScopedJavaLocalRef<jstring> jmime_type =
-      ConvertUTF8ToJavaString(env, mime_type);
-  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename,
-                                                jmime_type);
+  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename);
 }
 
 void ChromeDownloadDelegate::OnDangerousDownload(const std::string& filename,",Chrome,5fc08cfb098acce49344d2e89cc27c915903f81c,832443eec1ac13b31d044967e8e36469bc4d28c5,1,"void ChromeDownloadDelegate::RequestHTTPGetDownload(
//flaw_line_below:
    const std::string& url,
//flaw_line_below:
    const std::string& user_agent,
//flaw_line_below:
    const std::string& content_disposition,
//flaw_line_below:
    const std::string& mime_type,
//flaw_line_below:
    const std::string& cookie,
//flaw_line_below:
    const std::string& referer,
//flaw_line_below:
    const base::string16& file_name,
//flaw_line_below:
    int64_t content_length,
//flaw_line_below:
    bool has_user_gesture,
//flaw_line_below:
    bool must_download) {
//flaw_line_below:
  JNIEnv* env = base::android::AttachCurrentThread();
//flaw_line_below:
  ScopedJavaLocalRef<jstring> jurl =
//flaw_line_below:
      ConvertUTF8ToJavaString(env, url);
//flaw_line_below:
  ScopedJavaLocalRef<jstring> juser_agent =
//flaw_line_below:
      ConvertUTF8ToJavaString(env, user_agent);
//flaw_line_below:
  ScopedJavaLocalRef<jstring> jcontent_disposition =
//flaw_line_below:
      ConvertUTF8ToJavaString(env, content_disposition);
//flaw_line_below:
  ScopedJavaLocalRef<jstring> jmime_type =
//flaw_line_below:
      ConvertUTF8ToJavaString(env, mime_type);
//flaw_line_below:
  ScopedJavaLocalRef<jstring> jcookie =
//flaw_line_below:
      ConvertUTF8ToJavaString(env, cookie);
//flaw_line_below:
  ScopedJavaLocalRef<jstring> jreferer =
//flaw_line_below:
      ConvertUTF8ToJavaString(env, referer);
//flaw_line_below:

//flaw_line_below:
  // net::GetSuggestedFilename will fallback to ""download"" as filename.
//flaw_line_below:
  ScopedJavaLocalRef<jstring> jfilename =
//flaw_line_below:
      base::android::ConvertUTF16ToJavaString(env, file_name);
//flaw_line_below:
  Java_ChromeDownloadDelegate_requestHttpGetDownload(
//flaw_line_below:
      env, java_ref_, jurl, juser_agent, jcontent_disposition, jmime_type,
//flaw_line_below:
      jcookie, jreferer, has_user_gesture, jfilename, content_length,
//flaw_line_below:
      must_download);
//flaw_line_below:
}
"
8023,185759,,Remote,Not required,,CVE-2015-1296,https://www.cvedetails.com/cve/CVE-2015-1296/,CWE-254,Low,,Partial,,2015-09-03,5.0,"The UnescapeURLWithAdjustmentsImpl implementation in net/base/escape.cc in Google Chrome before 45.0.2454.85 does not prevent display of Unicode LOCK characters in the omnibox, which makes it easier for remote attackers to spoof the SSL lock icon by placing one of these characters at the end of a URL, as demonstrated by the omnibox in localizations for right-to-left languages.",2016-12-21,,0,https://github.com/chromium/chromium/commit/5fc08cfb098acce49344d2e89cc27c915903f81c,5fc08cfb098acce49344d2e89cc27c915903f81c,"Clean up Android DownloadManager code as most download now go through Chrome Network stack

The only exception is OMA DRM download.
And it only applies to context menu download interception.
Clean up the remaining unused code now.

BUG=647755

Review-Url: https://codereview.chromium.org/2371773003
Cr-Commit-Position: refs/heads/master@{#421332}",10,chrome/browser/android/download/download_controller.cc,"{""sha"": ""0ef10538498fe7fb6a1a58f56601e42b101111a6"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 125, ""changes"": 159, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -9,7 +9,6 @@\n import android.app.DownloadManager;\n import android.content.Context;\n import android.content.DialogInterface;\n-import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -60,62 +59,18 @@ public boolean onInfoBarButtonClicked(boolean confirm) {\n                 if (confirm) {\n                     DownloadUtils.showDownloadStartToast(mContext);\n                 }\n-                mPendingRequest = null;\n-                return closeBlankTab();\n-            } else if (confirm) {\n-                // User confirmed the download.\n-                if (mPendingRequest.isGETRequest()) {\n-                    final DownloadInfo info = mPendingRequest;\n-                    new AsyncTask<Void, Void, Pair<String, String>>() {\n-                        @Override\n-                        protected Pair<String, String> doInBackground(Void... params) {\n-                            Pair<String, String> result = getDownloadDirectoryNameAndFullPath();\n-                            String fullDirPath = result.second;\n-                            return doesFileAlreadyExists(fullDirPath, info.getFileName())\n-                                    ? result : null;\n-                        }\n-\n-                        @Override\n-                        protected void onPostExecute(Pair<String, String> result) {\n-                            if (result != null) {\n-                                // File already exists.\n-                                String dirName = result.first;\n-                                String fullDirPath = result.second;\n-                                launchDownloadInfoBar(info, dirName, fullDirPath);\n-                            } else {\n-                                enqueueDownloadManagerRequest(info);\n-                            }\n-                        }\n-                    }.execute();\n-                } else {\n-                    DownloadInfo newDownloadInfo =\n-                            DownloadInfo.Builder.fromDownloadInfo(mPendingRequest).build();\n-                    DownloadManagerService.getDownloadManagerService(mContext).onDownloadCompleted(\n-                            newDownloadInfo);\n-                }\n-                mPendingRequest = null;\n-                return false;\n-            } else {\n-                // User did not accept the download, discard the file if it is a POST download.\n-                if (!mPendingRequest.isGETRequest()) {\n-                    discardFile(mPendingRequest.getFilePath());\n-                }\n-                mPendingRequest = null;\n-                return closeBlankTab();\n             }\n+            mPendingRequest = null;\n+            return closeBlankTab();\n         }\n \n         @Override\n         public void onInfoBarDismissed() {\n-            if (mPendingRequest != null) {\n-                if (mPendingRequest.getDownloadGuid() != null) {\n-                    assert mTab != null;\n-                    nativeDangerousDownloadValidated(\n-                            mTab, mPendingRequest.getDownloadGuid(), false);\n-                } else if (!mPendingRequest.isGETRequest()) {\n-                    // Infobar was dismissed, discard the file if a POST download is pending.\n-                    discardFile(mPendingRequest.getFilePath());\n-                }\n+            if (mPendingRequest == null) return;\n+            if (mPendingRequest.getDownloadGuid() != null) {\n+                assert mTab != null;\n+                nativeDangerousDownloadValidated(\n+                        mTab, mPendingRequest.getDownloadGuid(), false);\n             }\n             // Forget the pending request.\n             mPendingRequest = null;\n@@ -151,38 +106,6 @@ public void onDestroyed(Tab tab) {\n         nativeInit(tab.getWebContents());\n     }\n \n-    @CalledByNative\n-    private void requestHttpGetDownload(String url, String userAgent, String contentDisposition,\n-            String mimeType, String cookie, String referer, boolean hasUserGesture,\n-            String filename, long contentLength, boolean mustDownload) {\n-        // If we're dealing with A/V content that's not explicitly marked for download, check if it\n-        // is streamable.\n-        if (!mustDownload) {\n-            // Query the package manager to see if there's a registered handler that matches.\n-            Intent intent = new Intent(Intent.ACTION_VIEW);\n-            intent.setDataAndType(Uri.parse(url), mimeType);\n-            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n-            // If the intent is resolved to ourselves, we don't want to attempt to load the url\n-            // only to try and download it again.\n-            if (DownloadManagerService.openIntent(mContext, intent, false)) {\n-                return;\n-            }\n-        }\n-        DownloadInfo downloadInfo = new DownloadInfo.Builder()\n-                .setUrl(url)\n-                .setUserAgent(userAgent)\n-                .setContentDisposition(contentDisposition)\n-                .setMimeType(mimeType)\n-                .setCookie(cookie)\n-                .setReferer(referer)\n-                .setHasUserGesture(hasUserGesture)\n-                .setFileName(filename)\n-                .setContentLength(contentLength)\n-                .setIsGETRequest(true)\n-                .build();\n-        onDownloadStartNoStream(downloadInfo);\n-    }\n-\n     /**\n      * Notify the host application a download should be done, even if there is a\n      * streaming viewer available for this type.\n@@ -232,7 +155,7 @@ protected void onPostExecute(Object[] result) {\n                 // The proper fix would be to let chrome knows which frame originated the request.\n                 if (\""application/x-shockwave-flash\"".equals(newInfo.getMimeType())) return;\n \n-                if (isDangerousFile(fileName, newMimeType)) {\n+                if (isDangerousFile(fileName)) {\n                     confirmDangerousDownload(newInfo);\n                 } else {\n                     // Not a dangerous file, proceed.\n@@ -480,8 +403,8 @@ private void alertDownloadFailure(String fileName, int reason) {\n      * @param mimeType MIME type of the content.\n      */\n     @CalledByNative\n-    private void onDownloadStarted(String filename, String mimeType) {\n-        if (!isDangerousFile(filename, mimeType)) {\n+    private void onDownloadStarted(String filename) {\n+        if (!isDangerousFile(filename)) {\n             DownloadUtils.showDownloadStartToast(mContext);\n             closeBlankTab();\n         }\n@@ -543,22 +466,10 @@ static String getFileExtension(String url, String filename) {\n      * Check whether a file is dangerous.\n      *\n      * @param filename Name of the file.\n-     * @param mimeType MIME type of the content.\n-     * @return true if the file is dangerous, or false otherwise.\n-     */\n-    protected boolean isDangerousFile(String filename, String mimeType) {\n-        return nativeIsDownloadDangerous(filename) || isDangerousExtension(\n-                MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType));\n-    }\n-\n-    /**\n-     * Check whether a file extension is dangerous.\n-     *\n-     * @param ext Extension of the file.\n      * @return true if the file is dangerous, or false otherwise.\n      */\n-    private static boolean isDangerousExtension(String ext) {\n-        return \""apk\"".equals(ext);\n+    protected boolean isDangerousFile(String filename) {\n+        return nativeIsDownloadDangerous(filename);\n     }\n \n     /**\n@@ -617,32 +528,30 @@ public boolean shouldInterceptContextMenuDownload(String url) {\n         String path = uri.getPath();\n         // OMA downloads have extension \""dm\"" or \""dd\"". For the latter, it\n         // can be handled when native download completes.\n-        if (path != null && (path.endsWith(\"".dm\""))) {\n-            if (mTab == null) return true;\n-            String fileName = URLUtil.guessFileName(\n-                    url, null, OMADownloadHandler.OMA_DRM_MESSAGE_MIME);\n-            final DownloadInfo downloadInfo =\n-                    new DownloadInfo.Builder().setUrl(url).setFileName(fileName).build();\n-            WindowAndroid window = mTab.getWindowAndroid();\n-            if (window.hasPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n-                onDownloadStartNoStream(downloadInfo);\n-            } else if (window.canRequestPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n-                PermissionCallback permissionCallback = new PermissionCallback() {\n-                    @Override\n-                    public void onRequestPermissionsResult(\n-                            String[] permissions, int[] grantResults) {\n-                        if (grantResults.length > 0\n-                                && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n-                            onDownloadStartNoStream(downloadInfo);\n-                        }\n+        if (path == null || !path.endsWith(\"".dm\"")) return false;\n+        if (mTab == null) return true;\n+        String fileName = URLUtil.guessFileName(\n+                url, null, OMADownloadHandler.OMA_DRM_MESSAGE_MIME);\n+        final DownloadInfo downloadInfo =\n+                new DownloadInfo.Builder().setUrl(url).setFileName(fileName).build();\n+        WindowAndroid window = mTab.getWindowAndroid();\n+        if (window.hasPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n+            onDownloadStartNoStream(downloadInfo);\n+        } else if (window.canRequestPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n+            PermissionCallback permissionCallback = new PermissionCallback() {\n+                @Override\n+                public void onRequestPermissionsResult(\n+                        String[] permissions, int[] grantResults) {\n+                    if (grantResults.length > 0\n+                            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n+                        onDownloadStartNoStream(downloadInfo);\n                     }\n-                };\n-                window.requestPermissions(\n-                        new String[] {permission.WRITE_EXTERNAL_STORAGE}, permissionCallback);\n-            }\n-            return true;\n+                }\n+            };\n+            window.requestPermissions(\n+                    new String[] {permission.WRITE_EXTERNAL_STORAGE}, permissionCallback);\n         }\n-        return false;\n+        return true;\n     }\n \n     protected Context getContext() {""}<_**next**_>{""sha"": ""974663c8e9682cfacd171b069e0420ab8f132a36"", ""filename"": ""chrome/browser/android/download/chrome_download_delegate.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 40, ""changes"": 42, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/chrome_download_delegate.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -142,49 +142,11 @@ void ChromeDownloadDelegate::SetJavaRef(JNIEnv* env, jobject jobj) {\n   java_ref_ = env->NewGlobalRef(jobj);\n }\n \n-void ChromeDownloadDelegate::RequestHTTPGetDownload(\n-    const std::string& url,\n-    const std::string& user_agent,\n-    const std::string& content_disposition,\n-    const std::string& mime_type,\n-    const std::string& cookie,\n-    const std::string& referer,\n-    const base::string16& file_name,\n-    int64_t content_length,\n-    bool has_user_gesture,\n-    bool must_download) {\n-  JNIEnv* env = base::android::AttachCurrentThread();\n-  ScopedJavaLocalRef<jstring> jurl =\n-      ConvertUTF8ToJavaString(env, url);\n-  ScopedJavaLocalRef<jstring> juser_agent =\n-      ConvertUTF8ToJavaString(env, user_agent);\n-  ScopedJavaLocalRef<jstring> jcontent_disposition =\n-      ConvertUTF8ToJavaString(env, content_disposition);\n-  ScopedJavaLocalRef<jstring> jmime_type =\n-      ConvertUTF8ToJavaString(env, mime_type);\n-  ScopedJavaLocalRef<jstring> jcookie =\n-      ConvertUTF8ToJavaString(env, cookie);\n-  ScopedJavaLocalRef<jstring> jreferer =\n-      ConvertUTF8ToJavaString(env, referer);\n-\n-  // net::GetSuggestedFilename will fallback to \""download\"" as filename.\n-  ScopedJavaLocalRef<jstring> jfilename =\n-      base::android::ConvertUTF16ToJavaString(env, file_name);\n-  Java_ChromeDownloadDelegate_requestHttpGetDownload(\n-      env, java_ref_, jurl, juser_agent, jcontent_disposition, jmime_type,\n-      jcookie, jreferer, has_user_gesture, jfilename, content_length,\n-      must_download);\n-}\n-\n-void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename,\n-                                               const std::string& mime_type) {\n+void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename) {\n   JNIEnv* env = base::android::AttachCurrentThread();\n   ScopedJavaLocalRef<jstring> jfilename = ConvertUTF8ToJavaString(\n       env, filename);\n-  ScopedJavaLocalRef<jstring> jmime_type =\n-      ConvertUTF8ToJavaString(env, mime_type);\n-  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename,\n-                                                jmime_type);\n+  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename);\n }\n \n void ChromeDownloadDelegate::OnDangerousDownload(const std::string& filename,""}<_**next**_>{""sha"": ""2fd96f342f171386656ddfea85d6de88e06582d7"", ""filename"": ""chrome/browser/android/download/chrome_download_delegate.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 12, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/chrome_download_delegate.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -19,18 +19,7 @@ class ChromeDownloadDelegate\n \n   void SetJavaRef(JNIEnv*, jobject obj);\n \n-  void RequestHTTPGetDownload(const std::string& url,\n-                              const std::string& user_agent,\n-                              const std::string& content_disposition,\n-                              const std::string& mime_type,\n-                              const std::string& cookie,\n-                              const std::string& referer,\n-                              const base::string16& file_name,\n-                              int64_t content_length,\n-                              bool has_user_geature,\n-                              bool must_download);\n-  void OnDownloadStarted(const std::string& filename,\n-                         const std::string& mime_type);\n+  void OnDownloadStarted(const std::string& filename);\n   void OnDangerousDownload(const std::string& filename,\n                            const std::string& guid);\n   void RequestFileAccess(intptr_t callback_id);""}<_**next**_>{""sha"": ""337b8ab62358f9e4b403d26def62ed649ef237f2"", ""filename"": ""chrome/browser/android/download/download_controller.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 62, ""changes"": 63, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -234,66 +234,6 @@ bool DownloadController::HasFileAccessPermission(\n       env, GetJavaObject()->Controller(env), jwindow_android);\n }\n \n-void DownloadController::CreateGETDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download,\n-    const DownloadInfo& info) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n-\n-  // We are yielding the UI thread and render_view_host may go away by\n-  // the time we come back. Pass along render_process_id and render_view_id\n-  // to retrieve it later (if it still exists).\n-  BrowserThread::PostTask(\n-      BrowserThread::UI, FROM_HERE,\n-      base::Bind(&DownloadController::StartAndroidDownload,\n-                 base::Unretained(this),\n-                 wc_getter, must_download, info));\n-}\n-\n-void DownloadController::StartAndroidDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n-\n-  WebContents* web_contents = wc_getter.Run();\n-  if (!web_contents) {\n-    // The view went away. Can't proceed.\n-    LOG(ERROR) << \""Download failed on URL:\"" << info.url.spec();\n-    return;\n-  }\n-\n-  AcquireFileAccessPermission(\n-      web_contents,\n-      base::Bind(&DownloadController::StartAndroidDownloadInternal,\n-                 base::Unretained(this), wc_getter, must_download, info));\n-}\n-\n-void DownloadController::StartAndroidDownloadInternal(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info, bool allowed) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n-  if (!allowed)\n-    return;\n-\n-  WebContents* web_contents = wc_getter.Run();\n-  // The view went away. Can't proceed.\n-  if (!web_contents)\n-    return;\n-\n-  base::string16 filename = net::GetSuggestedFilename(\n-      info.url, info.content_disposition,\n-      std::string(),  // referrer_charset\n-      std::string(),  // suggested_name\n-      info.original_mime_type,\n-      default_file_name_);\n-  ChromeDownloadDelegate::FromWebContents(web_contents)->RequestHTTPGetDownload(\n-      info.url.spec(), info.user_agent,\n-      info.content_disposition, info.original_mime_type,\n-      info.cookie, info.referer, filename,\n-      info.total_bytes, info.has_user_gesture,\n-      must_download);\n-}\n-\n void DownloadController::OnDownloadStarted(\n     DownloadItem* download_item) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n@@ -305,8 +245,7 @@ void DownloadController::OnDownloadStarted(\n   download_item->AddObserver(this);\n \n   ChromeDownloadDelegate::FromWebContents(web_contents)->OnDownloadStarted(\n-      download_item->GetTargetFilePath().BaseName().value(),\n-      download_item->GetMimeType());\n+      download_item->GetTargetFilePath().BaseName().value());\n }\n \n void DownloadController::OnDownloadUpdated(DownloadItem* item) {""}<_**next**_>{""sha"": ""163e815daa80f5bafac9c06f2c25c89bbc403f03"", ""filename"": ""chrome/browser/android/download/download_controller.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 14, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -76,10 +76,6 @@ class DownloadController : public DownloadControllerBase {\n   bool HasFileAccessPermission(ui::WindowAndroid* window_android);\n \n   // DownloadControllerBase implementation.\n-  void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) override;\n   void OnDownloadStarted(content::DownloadItem* download_item) override;\n   void StartContextMenuDownload(const content::ContextMenuParams& params,\n                                 content::WebContents* web_contents,\n@@ -92,16 +88,6 @@ class DownloadController : public DownloadControllerBase {\n   // DownloadItem::Observer interface.\n   void OnDownloadUpdated(content::DownloadItem* item) override;\n \n-  void StartAndroidDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info);\n-  void StartAndroidDownloadInternal(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info,\n-      bool allowed);\n-\n   // The download item contains dangerous file types.\n   void OnDangerousDownload(content::DownloadItem *item);\n ""}<_**next**_>{""sha"": ""c317ed4063275fd9796169235f064d41df342cb3"", ""filename"": ""chrome/browser/android/download/download_controller_base.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller_base.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -59,13 +59,6 @@ class DownloadControllerBase : public content::DownloadItem::Observer {\n   static void SetDownloadControllerBase(\n       DownloadControllerBase* download_controller);\n \n-  // Starts a new download request with Android. Should be called on the\n-  // UI thread.\n-  virtual void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) = 0;\n-\n   // Should be called when a download is started. It can be either a GET\n   // request with authentication or a POST request. Notifies the embedding\n   // app about the download. Should be called on the UI thread.""}<_**next**_>{""sha"": ""df198c6cd9a9c5dc6ef1241ae896207a74511397"", ""filename"": ""chrome/browser/android/download/mock_download_controller.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/mock_download_controller.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -17,11 +17,6 @@ MockDownloadController::MockDownloadController()\n \n MockDownloadController::~MockDownloadController() {}\n \n-void MockDownloadController::CreateGETDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info) {\n-}\n-\n void MockDownloadController::OnDownloadStarted(\n     content::DownloadItem* download_item) {\n }""}<_**next**_>{""sha"": ""399fcaf4fcb37454d5e20a48acd5fd5fdf724da7"", ""filename"": ""chrome/browser/android/download/mock_download_controller.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/mock_download_controller.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -25,10 +25,6 @@ class MockDownloadController : public DownloadControllerBase {\n   ~MockDownloadController() override;\n \n   // DownloadControllerBase implementation.\n-  void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) override;\n   void OnDownloadStarted(content::DownloadItem* download_item) override;\n   void StartContextMenuDownload(\n       const content::ContextMenuParams& params,""}","void DownloadController::CreateGETDownload(
","void DownloadController::CreateGETDownload(
    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
    bool must_download,
    const DownloadInfo& info) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&DownloadController::StartAndroidDownload,
                 base::Unretained(this),
                 wc_getter, must_download, info));
}
",C,,"    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
    bool must_download,
    const DownloadInfo& info) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&DownloadController::StartAndroidDownload,
                 base::Unretained(this),
                 wc_getter, must_download, info));
}
",,"@@ -234,66 +234,6 @@ bool DownloadController::HasFileAccessPermission(
       env, GetJavaObject()->Controller(env), jwindow_android);
 }
 
-void DownloadController::CreateGETDownload(
-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
-    bool must_download,
-    const DownloadInfo& info) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  // We are yielding the UI thread and render_view_host may go away by
-  // the time we come back. Pass along render_process_id and render_view_id
-  // to retrieve it later (if it still exists).
-  BrowserThread::PostTask(
-      BrowserThread::UI, FROM_HERE,
-      base::Bind(&DownloadController::StartAndroidDownload,
-                 base::Unretained(this),
-                 wc_getter, must_download, info));
-}
-
-void DownloadController::StartAndroidDownload(
-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
-    bool must_download, const DownloadInfo& info) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  WebContents* web_contents = wc_getter.Run();
-  if (!web_contents) {
-    // The view went away. Can't proceed.
-    LOG(ERROR) << ""Download failed on URL:"" << info.url.spec();
-    return;
-  }
-
-  AcquireFileAccessPermission(
-      web_contents,
-      base::Bind(&DownloadController::StartAndroidDownloadInternal,
-                 base::Unretained(this), wc_getter, must_download, info));
-}
-
-void DownloadController::StartAndroidDownloadInternal(
-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
-    bool must_download, const DownloadInfo& info, bool allowed) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  if (!allowed)
-    return;
-
-  WebContents* web_contents = wc_getter.Run();
-  // The view went away. Can't proceed.
-  if (!web_contents)
-    return;
-
-  base::string16 filename = net::GetSuggestedFilename(
-      info.url, info.content_disposition,
-      std::string(),  // referrer_charset
-      std::string(),  // suggested_name
-      info.original_mime_type,
-      default_file_name_);
-  ChromeDownloadDelegate::FromWebContents(web_contents)->RequestHTTPGetDownload(
-      info.url.spec(), info.user_agent,
-      info.content_disposition, info.original_mime_type,
-      info.cookie, info.referer, filename,
-      info.total_bytes, info.has_user_gesture,
-      must_download);
-}
-
 void DownloadController::OnDownloadStarted(
     DownloadItem* download_item) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
@@ -305,8 +245,7 @@ void DownloadController::OnDownloadStarted(
   download_item->AddObserver(this);
 
   ChromeDownloadDelegate::FromWebContents(web_contents)->OnDownloadStarted(
-      download_item->GetTargetFilePath().BaseName().value(),
-      download_item->GetMimeType());
+      download_item->GetTargetFilePath().BaseName().value());
 }
 
 void DownloadController::OnDownloadUpdated(DownloadItem* item) {",Chrome,5fc08cfb098acce49344d2e89cc27c915903f81c,832443eec1ac13b31d044967e8e36469bc4d28c5,1,"void DownloadController::CreateGETDownload(
//flaw_line_below:
    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
//flaw_line_below:
    bool must_download,
//flaw_line_below:
    const DownloadInfo& info) {
//flaw_line_below:
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
//flaw_line_below:

//flaw_line_below:
  // We are yielding the UI thread and render_view_host may go away by
//flaw_line_below:
  // the time we come back. Pass along render_process_id and render_view_id
//flaw_line_below:
  // to retrieve it later (if it still exists).
//flaw_line_below:
  BrowserThread::PostTask(
//flaw_line_below:
      BrowserThread::UI, FROM_HERE,
//flaw_line_below:
      base::Bind(&DownloadController::StartAndroidDownload,
//flaw_line_below:
                 base::Unretained(this),
//flaw_line_below:
                 wc_getter, must_download, info));
//flaw_line_below:
}
"
8024,185760,,Remote,Not required,,CVE-2015-1296,https://www.cvedetails.com/cve/CVE-2015-1296/,CWE-254,Low,,Partial,,2015-09-03,5.0,"The UnescapeURLWithAdjustmentsImpl implementation in net/base/escape.cc in Google Chrome before 45.0.2454.85 does not prevent display of Unicode LOCK characters in the omnibox, which makes it easier for remote attackers to spoof the SSL lock icon by placing one of these characters at the end of a URL, as demonstrated by the omnibox in localizations for right-to-left languages.",2016-12-21,,1,https://github.com/chromium/chromium/commit/5fc08cfb098acce49344d2e89cc27c915903f81c,5fc08cfb098acce49344d2e89cc27c915903f81c,"Clean up Android DownloadManager code as most download now go through Chrome Network stack

The only exception is OMA DRM download.
And it only applies to context menu download interception.
Clean up the remaining unused code now.

BUG=647755

Review-Url: https://codereview.chromium.org/2371773003
Cr-Commit-Position: refs/heads/master@{#421332}",2,chrome/browser/android/download/download_controller.cc,"{""sha"": ""0ef10538498fe7fb6a1a58f56601e42b101111a6"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 125, ""changes"": 159, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -9,7 +9,6 @@\n import android.app.DownloadManager;\n import android.content.Context;\n import android.content.DialogInterface;\n-import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -60,62 +59,18 @@ public boolean onInfoBarButtonClicked(boolean confirm) {\n                 if (confirm) {\n                     DownloadUtils.showDownloadStartToast(mContext);\n                 }\n-                mPendingRequest = null;\n-                return closeBlankTab();\n-            } else if (confirm) {\n-                // User confirmed the download.\n-                if (mPendingRequest.isGETRequest()) {\n-                    final DownloadInfo info = mPendingRequest;\n-                    new AsyncTask<Void, Void, Pair<String, String>>() {\n-                        @Override\n-                        protected Pair<String, String> doInBackground(Void... params) {\n-                            Pair<String, String> result = getDownloadDirectoryNameAndFullPath();\n-                            String fullDirPath = result.second;\n-                            return doesFileAlreadyExists(fullDirPath, info.getFileName())\n-                                    ? result : null;\n-                        }\n-\n-                        @Override\n-                        protected void onPostExecute(Pair<String, String> result) {\n-                            if (result != null) {\n-                                // File already exists.\n-                                String dirName = result.first;\n-                                String fullDirPath = result.second;\n-                                launchDownloadInfoBar(info, dirName, fullDirPath);\n-                            } else {\n-                                enqueueDownloadManagerRequest(info);\n-                            }\n-                        }\n-                    }.execute();\n-                } else {\n-                    DownloadInfo newDownloadInfo =\n-                            DownloadInfo.Builder.fromDownloadInfo(mPendingRequest).build();\n-                    DownloadManagerService.getDownloadManagerService(mContext).onDownloadCompleted(\n-                            newDownloadInfo);\n-                }\n-                mPendingRequest = null;\n-                return false;\n-            } else {\n-                // User did not accept the download, discard the file if it is a POST download.\n-                if (!mPendingRequest.isGETRequest()) {\n-                    discardFile(mPendingRequest.getFilePath());\n-                }\n-                mPendingRequest = null;\n-                return closeBlankTab();\n             }\n+            mPendingRequest = null;\n+            return closeBlankTab();\n         }\n \n         @Override\n         public void onInfoBarDismissed() {\n-            if (mPendingRequest != null) {\n-                if (mPendingRequest.getDownloadGuid() != null) {\n-                    assert mTab != null;\n-                    nativeDangerousDownloadValidated(\n-                            mTab, mPendingRequest.getDownloadGuid(), false);\n-                } else if (!mPendingRequest.isGETRequest()) {\n-                    // Infobar was dismissed, discard the file if a POST download is pending.\n-                    discardFile(mPendingRequest.getFilePath());\n-                }\n+            if (mPendingRequest == null) return;\n+            if (mPendingRequest.getDownloadGuid() != null) {\n+                assert mTab != null;\n+                nativeDangerousDownloadValidated(\n+                        mTab, mPendingRequest.getDownloadGuid(), false);\n             }\n             // Forget the pending request.\n             mPendingRequest = null;\n@@ -151,38 +106,6 @@ public void onDestroyed(Tab tab) {\n         nativeInit(tab.getWebContents());\n     }\n \n-    @CalledByNative\n-    private void requestHttpGetDownload(String url, String userAgent, String contentDisposition,\n-            String mimeType, String cookie, String referer, boolean hasUserGesture,\n-            String filename, long contentLength, boolean mustDownload) {\n-        // If we're dealing with A/V content that's not explicitly marked for download, check if it\n-        // is streamable.\n-        if (!mustDownload) {\n-            // Query the package manager to see if there's a registered handler that matches.\n-            Intent intent = new Intent(Intent.ACTION_VIEW);\n-            intent.setDataAndType(Uri.parse(url), mimeType);\n-            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n-            // If the intent is resolved to ourselves, we don't want to attempt to load the url\n-            // only to try and download it again.\n-            if (DownloadManagerService.openIntent(mContext, intent, false)) {\n-                return;\n-            }\n-        }\n-        DownloadInfo downloadInfo = new DownloadInfo.Builder()\n-                .setUrl(url)\n-                .setUserAgent(userAgent)\n-                .setContentDisposition(contentDisposition)\n-                .setMimeType(mimeType)\n-                .setCookie(cookie)\n-                .setReferer(referer)\n-                .setHasUserGesture(hasUserGesture)\n-                .setFileName(filename)\n-                .setContentLength(contentLength)\n-                .setIsGETRequest(true)\n-                .build();\n-        onDownloadStartNoStream(downloadInfo);\n-    }\n-\n     /**\n      * Notify the host application a download should be done, even if there is a\n      * streaming viewer available for this type.\n@@ -232,7 +155,7 @@ protected void onPostExecute(Object[] result) {\n                 // The proper fix would be to let chrome knows which frame originated the request.\n                 if (\""application/x-shockwave-flash\"".equals(newInfo.getMimeType())) return;\n \n-                if (isDangerousFile(fileName, newMimeType)) {\n+                if (isDangerousFile(fileName)) {\n                     confirmDangerousDownload(newInfo);\n                 } else {\n                     // Not a dangerous file, proceed.\n@@ -480,8 +403,8 @@ private void alertDownloadFailure(String fileName, int reason) {\n      * @param mimeType MIME type of the content.\n      */\n     @CalledByNative\n-    private void onDownloadStarted(String filename, String mimeType) {\n-        if (!isDangerousFile(filename, mimeType)) {\n+    private void onDownloadStarted(String filename) {\n+        if (!isDangerousFile(filename)) {\n             DownloadUtils.showDownloadStartToast(mContext);\n             closeBlankTab();\n         }\n@@ -543,22 +466,10 @@ static String getFileExtension(String url, String filename) {\n      * Check whether a file is dangerous.\n      *\n      * @param filename Name of the file.\n-     * @param mimeType MIME type of the content.\n-     * @return true if the file is dangerous, or false otherwise.\n-     */\n-    protected boolean isDangerousFile(String filename, String mimeType) {\n-        return nativeIsDownloadDangerous(filename) || isDangerousExtension(\n-                MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType));\n-    }\n-\n-    /**\n-     * Check whether a file extension is dangerous.\n-     *\n-     * @param ext Extension of the file.\n      * @return true if the file is dangerous, or false otherwise.\n      */\n-    private static boolean isDangerousExtension(String ext) {\n-        return \""apk\"".equals(ext);\n+    protected boolean isDangerousFile(String filename) {\n+        return nativeIsDownloadDangerous(filename);\n     }\n \n     /**\n@@ -617,32 +528,30 @@ public boolean shouldInterceptContextMenuDownload(String url) {\n         String path = uri.getPath();\n         // OMA downloads have extension \""dm\"" or \""dd\"". For the latter, it\n         // can be handled when native download completes.\n-        if (path != null && (path.endsWith(\"".dm\""))) {\n-            if (mTab == null) return true;\n-            String fileName = URLUtil.guessFileName(\n-                    url, null, OMADownloadHandler.OMA_DRM_MESSAGE_MIME);\n-            final DownloadInfo downloadInfo =\n-                    new DownloadInfo.Builder().setUrl(url).setFileName(fileName).build();\n-            WindowAndroid window = mTab.getWindowAndroid();\n-            if (window.hasPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n-                onDownloadStartNoStream(downloadInfo);\n-            } else if (window.canRequestPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n-                PermissionCallback permissionCallback = new PermissionCallback() {\n-                    @Override\n-                    public void onRequestPermissionsResult(\n-                            String[] permissions, int[] grantResults) {\n-                        if (grantResults.length > 0\n-                                && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n-                            onDownloadStartNoStream(downloadInfo);\n-                        }\n+        if (path == null || !path.endsWith(\"".dm\"")) return false;\n+        if (mTab == null) return true;\n+        String fileName = URLUtil.guessFileName(\n+                url, null, OMADownloadHandler.OMA_DRM_MESSAGE_MIME);\n+        final DownloadInfo downloadInfo =\n+                new DownloadInfo.Builder().setUrl(url).setFileName(fileName).build();\n+        WindowAndroid window = mTab.getWindowAndroid();\n+        if (window.hasPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n+            onDownloadStartNoStream(downloadInfo);\n+        } else if (window.canRequestPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n+            PermissionCallback permissionCallback = new PermissionCallback() {\n+                @Override\n+                public void onRequestPermissionsResult(\n+                        String[] permissions, int[] grantResults) {\n+                    if (grantResults.length > 0\n+                            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n+                        onDownloadStartNoStream(downloadInfo);\n                     }\n-                };\n-                window.requestPermissions(\n-                        new String[] {permission.WRITE_EXTERNAL_STORAGE}, permissionCallback);\n-            }\n-            return true;\n+                }\n+            };\n+            window.requestPermissions(\n+                    new String[] {permission.WRITE_EXTERNAL_STORAGE}, permissionCallback);\n         }\n-        return false;\n+        return true;\n     }\n \n     protected Context getContext() {""}<_**next**_>{""sha"": ""974663c8e9682cfacd171b069e0420ab8f132a36"", ""filename"": ""chrome/browser/android/download/chrome_download_delegate.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 40, ""changes"": 42, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/chrome_download_delegate.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -142,49 +142,11 @@ void ChromeDownloadDelegate::SetJavaRef(JNIEnv* env, jobject jobj) {\n   java_ref_ = env->NewGlobalRef(jobj);\n }\n \n-void ChromeDownloadDelegate::RequestHTTPGetDownload(\n-    const std::string& url,\n-    const std::string& user_agent,\n-    const std::string& content_disposition,\n-    const std::string& mime_type,\n-    const std::string& cookie,\n-    const std::string& referer,\n-    const base::string16& file_name,\n-    int64_t content_length,\n-    bool has_user_gesture,\n-    bool must_download) {\n-  JNIEnv* env = base::android::AttachCurrentThread();\n-  ScopedJavaLocalRef<jstring> jurl =\n-      ConvertUTF8ToJavaString(env, url);\n-  ScopedJavaLocalRef<jstring> juser_agent =\n-      ConvertUTF8ToJavaString(env, user_agent);\n-  ScopedJavaLocalRef<jstring> jcontent_disposition =\n-      ConvertUTF8ToJavaString(env, content_disposition);\n-  ScopedJavaLocalRef<jstring> jmime_type =\n-      ConvertUTF8ToJavaString(env, mime_type);\n-  ScopedJavaLocalRef<jstring> jcookie =\n-      ConvertUTF8ToJavaString(env, cookie);\n-  ScopedJavaLocalRef<jstring> jreferer =\n-      ConvertUTF8ToJavaString(env, referer);\n-\n-  // net::GetSuggestedFilename will fallback to \""download\"" as filename.\n-  ScopedJavaLocalRef<jstring> jfilename =\n-      base::android::ConvertUTF16ToJavaString(env, file_name);\n-  Java_ChromeDownloadDelegate_requestHttpGetDownload(\n-      env, java_ref_, jurl, juser_agent, jcontent_disposition, jmime_type,\n-      jcookie, jreferer, has_user_gesture, jfilename, content_length,\n-      must_download);\n-}\n-\n-void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename,\n-                                               const std::string& mime_type) {\n+void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename) {\n   JNIEnv* env = base::android::AttachCurrentThread();\n   ScopedJavaLocalRef<jstring> jfilename = ConvertUTF8ToJavaString(\n       env, filename);\n-  ScopedJavaLocalRef<jstring> jmime_type =\n-      ConvertUTF8ToJavaString(env, mime_type);\n-  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename,\n-                                                jmime_type);\n+  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename);\n }\n \n void ChromeDownloadDelegate::OnDangerousDownload(const std::string& filename,""}<_**next**_>{""sha"": ""2fd96f342f171386656ddfea85d6de88e06582d7"", ""filename"": ""chrome/browser/android/download/chrome_download_delegate.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 12, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/chrome_download_delegate.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -19,18 +19,7 @@ class ChromeDownloadDelegate\n \n   void SetJavaRef(JNIEnv*, jobject obj);\n \n-  void RequestHTTPGetDownload(const std::string& url,\n-                              const std::string& user_agent,\n-                              const std::string& content_disposition,\n-                              const std::string& mime_type,\n-                              const std::string& cookie,\n-                              const std::string& referer,\n-                              const base::string16& file_name,\n-                              int64_t content_length,\n-                              bool has_user_geature,\n-                              bool must_download);\n-  void OnDownloadStarted(const std::string& filename,\n-                         const std::string& mime_type);\n+  void OnDownloadStarted(const std::string& filename);\n   void OnDangerousDownload(const std::string& filename,\n                            const std::string& guid);\n   void RequestFileAccess(intptr_t callback_id);""}<_**next**_>{""sha"": ""337b8ab62358f9e4b403d26def62ed649ef237f2"", ""filename"": ""chrome/browser/android/download/download_controller.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 62, ""changes"": 63, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -234,66 +234,6 @@ bool DownloadController::HasFileAccessPermission(\n       env, GetJavaObject()->Controller(env), jwindow_android);\n }\n \n-void DownloadController::CreateGETDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download,\n-    const DownloadInfo& info) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n-\n-  // We are yielding the UI thread and render_view_host may go away by\n-  // the time we come back. Pass along render_process_id and render_view_id\n-  // to retrieve it later (if it still exists).\n-  BrowserThread::PostTask(\n-      BrowserThread::UI, FROM_HERE,\n-      base::Bind(&DownloadController::StartAndroidDownload,\n-                 base::Unretained(this),\n-                 wc_getter, must_download, info));\n-}\n-\n-void DownloadController::StartAndroidDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n-\n-  WebContents* web_contents = wc_getter.Run();\n-  if (!web_contents) {\n-    // The view went away. Can't proceed.\n-    LOG(ERROR) << \""Download failed on URL:\"" << info.url.spec();\n-    return;\n-  }\n-\n-  AcquireFileAccessPermission(\n-      web_contents,\n-      base::Bind(&DownloadController::StartAndroidDownloadInternal,\n-                 base::Unretained(this), wc_getter, must_download, info));\n-}\n-\n-void DownloadController::StartAndroidDownloadInternal(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info, bool allowed) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n-  if (!allowed)\n-    return;\n-\n-  WebContents* web_contents = wc_getter.Run();\n-  // The view went away. Can't proceed.\n-  if (!web_contents)\n-    return;\n-\n-  base::string16 filename = net::GetSuggestedFilename(\n-      info.url, info.content_disposition,\n-      std::string(),  // referrer_charset\n-      std::string(),  // suggested_name\n-      info.original_mime_type,\n-      default_file_name_);\n-  ChromeDownloadDelegate::FromWebContents(web_contents)->RequestHTTPGetDownload(\n-      info.url.spec(), info.user_agent,\n-      info.content_disposition, info.original_mime_type,\n-      info.cookie, info.referer, filename,\n-      info.total_bytes, info.has_user_gesture,\n-      must_download);\n-}\n-\n void DownloadController::OnDownloadStarted(\n     DownloadItem* download_item) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n@@ -305,8 +245,7 @@ void DownloadController::OnDownloadStarted(\n   download_item->AddObserver(this);\n \n   ChromeDownloadDelegate::FromWebContents(web_contents)->OnDownloadStarted(\n-      download_item->GetTargetFilePath().BaseName().value(),\n-      download_item->GetMimeType());\n+      download_item->GetTargetFilePath().BaseName().value());\n }\n \n void DownloadController::OnDownloadUpdated(DownloadItem* item) {""}<_**next**_>{""sha"": ""163e815daa80f5bafac9c06f2c25c89bbc403f03"", ""filename"": ""chrome/browser/android/download/download_controller.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 14, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -76,10 +76,6 @@ class DownloadController : public DownloadControllerBase {\n   bool HasFileAccessPermission(ui::WindowAndroid* window_android);\n \n   // DownloadControllerBase implementation.\n-  void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) override;\n   void OnDownloadStarted(content::DownloadItem* download_item) override;\n   void StartContextMenuDownload(const content::ContextMenuParams& params,\n                                 content::WebContents* web_contents,\n@@ -92,16 +88,6 @@ class DownloadController : public DownloadControllerBase {\n   // DownloadItem::Observer interface.\n   void OnDownloadUpdated(content::DownloadItem* item) override;\n \n-  void StartAndroidDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info);\n-  void StartAndroidDownloadInternal(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info,\n-      bool allowed);\n-\n   // The download item contains dangerous file types.\n   void OnDangerousDownload(content::DownloadItem *item);\n ""}<_**next**_>{""sha"": ""c317ed4063275fd9796169235f064d41df342cb3"", ""filename"": ""chrome/browser/android/download/download_controller_base.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller_base.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -59,13 +59,6 @@ class DownloadControllerBase : public content::DownloadItem::Observer {\n   static void SetDownloadControllerBase(\n       DownloadControllerBase* download_controller);\n \n-  // Starts a new download request with Android. Should be called on the\n-  // UI thread.\n-  virtual void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) = 0;\n-\n   // Should be called when a download is started. It can be either a GET\n   // request with authentication or a POST request. Notifies the embedding\n   // app about the download. Should be called on the UI thread.""}<_**next**_>{""sha"": ""df198c6cd9a9c5dc6ef1241ae896207a74511397"", ""filename"": ""chrome/browser/android/download/mock_download_controller.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/mock_download_controller.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -17,11 +17,6 @@ MockDownloadController::MockDownloadController()\n \n MockDownloadController::~MockDownloadController() {}\n \n-void MockDownloadController::CreateGETDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info) {\n-}\n-\n void MockDownloadController::OnDownloadStarted(\n     content::DownloadItem* download_item) {\n }""}<_**next**_>{""sha"": ""399fcaf4fcb37454d5e20a48acd5fd5fdf724da7"", ""filename"": ""chrome/browser/android/download/mock_download_controller.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/mock_download_controller.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -25,10 +25,6 @@ class MockDownloadController : public DownloadControllerBase {\n   ~MockDownloadController() override;\n \n   // DownloadControllerBase implementation.\n-  void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) override;\n   void OnDownloadStarted(content::DownloadItem* download_item) override;\n   void StartContextMenuDownload(\n       const content::ContextMenuParams& params,""}"," void DownloadController::OnDownloadStarted(
     DownloadItem* download_item) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
  WebContents* web_contents = download_item->GetWebContents();
  if (!web_contents)
    return;

   download_item->AddObserver(this);
 
   ChromeDownloadDelegate::FromWebContents(web_contents)->OnDownloadStarted(
      download_item->GetTargetFilePath().BaseName().value());
 }
"," void DownloadController::OnDownloadStarted(
     DownloadItem* download_item) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
  WebContents* web_contents = download_item->GetWebContents();
  if (!web_contents)
    return;

   download_item->AddObserver(this);
 
   ChromeDownloadDelegate::FromWebContents(web_contents)->OnDownloadStarted(
      download_item->GetTargetFilePath().BaseName().value(),
      download_item->GetMimeType());
 }
",C,"      download_item->GetTargetFilePath().BaseName().value());
","      download_item->GetTargetFilePath().BaseName().value(),
      download_item->GetMimeType());
",,"@@ -234,66 +234,6 @@ bool DownloadController::HasFileAccessPermission(
       env, GetJavaObject()->Controller(env), jwindow_android);
 }
 
-void DownloadController::CreateGETDownload(
-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
-    bool must_download,
-    const DownloadInfo& info) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  // We are yielding the UI thread and render_view_host may go away by
-  // the time we come back. Pass along render_process_id and render_view_id
-  // to retrieve it later (if it still exists).
-  BrowserThread::PostTask(
-      BrowserThread::UI, FROM_HERE,
-      base::Bind(&DownloadController::StartAndroidDownload,
-                 base::Unretained(this),
-                 wc_getter, must_download, info));
-}
-
-void DownloadController::StartAndroidDownload(
-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
-    bool must_download, const DownloadInfo& info) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  WebContents* web_contents = wc_getter.Run();
-  if (!web_contents) {
-    // The view went away. Can't proceed.
-    LOG(ERROR) << ""Download failed on URL:"" << info.url.spec();
-    return;
-  }
-
-  AcquireFileAccessPermission(
-      web_contents,
-      base::Bind(&DownloadController::StartAndroidDownloadInternal,
-                 base::Unretained(this), wc_getter, must_download, info));
-}
-
-void DownloadController::StartAndroidDownloadInternal(
-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
-    bool must_download, const DownloadInfo& info, bool allowed) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  if (!allowed)
-    return;
-
-  WebContents* web_contents = wc_getter.Run();
-  // The view went away. Can't proceed.
-  if (!web_contents)
-    return;
-
-  base::string16 filename = net::GetSuggestedFilename(
-      info.url, info.content_disposition,
-      std::string(),  // referrer_charset
-      std::string(),  // suggested_name
-      info.original_mime_type,
-      default_file_name_);
-  ChromeDownloadDelegate::FromWebContents(web_contents)->RequestHTTPGetDownload(
-      info.url.spec(), info.user_agent,
-      info.content_disposition, info.original_mime_type,
-      info.cookie, info.referer, filename,
-      info.total_bytes, info.has_user_gesture,
-      must_download);
-}
-
 void DownloadController::OnDownloadStarted(
     DownloadItem* download_item) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
@@ -305,8 +245,7 @@ void DownloadController::OnDownloadStarted(
   download_item->AddObserver(this);
 
   ChromeDownloadDelegate::FromWebContents(web_contents)->OnDownloadStarted(
-      download_item->GetTargetFilePath().BaseName().value(),
-      download_item->GetMimeType());
+      download_item->GetTargetFilePath().BaseName().value());
 }
 
 void DownloadController::OnDownloadUpdated(DownloadItem* item) {",Chrome,5fc08cfb098acce49344d2e89cc27c915903f81c,832443eec1ac13b31d044967e8e36469bc4d28c5,1," void DownloadController::OnDownloadStarted(
     DownloadItem* download_item) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
  WebContents* web_contents = download_item->GetWebContents();
  if (!web_contents)
    return;

  // Register for updates to the DownloadItem.
   download_item->AddObserver(this);
 
   ChromeDownloadDelegate::FromWebContents(web_contents)->OnDownloadStarted(
//flaw_line_below:
      download_item->GetTargetFilePath().BaseName().value(),
//flaw_line_below:
      download_item->GetMimeType());
//fix_flaw_line_below:
//      download_item->GetTargetFilePath().BaseName().value());
 }
"
8025,185761,,Remote,Not required,,CVE-2015-1296,https://www.cvedetails.com/cve/CVE-2015-1296/,CWE-254,Low,,Partial,,2015-09-03,5.0,"The UnescapeURLWithAdjustmentsImpl implementation in net/base/escape.cc in Google Chrome before 45.0.2454.85 does not prevent display of Unicode LOCK characters in the omnibox, which makes it easier for remote attackers to spoof the SSL lock icon by placing one of these characters at the end of a URL, as demonstrated by the omnibox in localizations for right-to-left languages.",2016-12-21,,0,https://github.com/chromium/chromium/commit/5fc08cfb098acce49344d2e89cc27c915903f81c,5fc08cfb098acce49344d2e89cc27c915903f81c,"Clean up Android DownloadManager code as most download now go through Chrome Network stack

The only exception is OMA DRM download.
And it only applies to context menu download interception.
Clean up the remaining unused code now.

BUG=647755

Review-Url: https://codereview.chromium.org/2371773003
Cr-Commit-Position: refs/heads/master@{#421332}",13,chrome/browser/android/download/download_controller.cc,"{""sha"": ""0ef10538498fe7fb6a1a58f56601e42b101111a6"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 125, ""changes"": 159, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -9,7 +9,6 @@\n import android.app.DownloadManager;\n import android.content.Context;\n import android.content.DialogInterface;\n-import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -60,62 +59,18 @@ public boolean onInfoBarButtonClicked(boolean confirm) {\n                 if (confirm) {\n                     DownloadUtils.showDownloadStartToast(mContext);\n                 }\n-                mPendingRequest = null;\n-                return closeBlankTab();\n-            } else if (confirm) {\n-                // User confirmed the download.\n-                if (mPendingRequest.isGETRequest()) {\n-                    final DownloadInfo info = mPendingRequest;\n-                    new AsyncTask<Void, Void, Pair<String, String>>() {\n-                        @Override\n-                        protected Pair<String, String> doInBackground(Void... params) {\n-                            Pair<String, String> result = getDownloadDirectoryNameAndFullPath();\n-                            String fullDirPath = result.second;\n-                            return doesFileAlreadyExists(fullDirPath, info.getFileName())\n-                                    ? result : null;\n-                        }\n-\n-                        @Override\n-                        protected void onPostExecute(Pair<String, String> result) {\n-                            if (result != null) {\n-                                // File already exists.\n-                                String dirName = result.first;\n-                                String fullDirPath = result.second;\n-                                launchDownloadInfoBar(info, dirName, fullDirPath);\n-                            } else {\n-                                enqueueDownloadManagerRequest(info);\n-                            }\n-                        }\n-                    }.execute();\n-                } else {\n-                    DownloadInfo newDownloadInfo =\n-                            DownloadInfo.Builder.fromDownloadInfo(mPendingRequest).build();\n-                    DownloadManagerService.getDownloadManagerService(mContext).onDownloadCompleted(\n-                            newDownloadInfo);\n-                }\n-                mPendingRequest = null;\n-                return false;\n-            } else {\n-                // User did not accept the download, discard the file if it is a POST download.\n-                if (!mPendingRequest.isGETRequest()) {\n-                    discardFile(mPendingRequest.getFilePath());\n-                }\n-                mPendingRequest = null;\n-                return closeBlankTab();\n             }\n+            mPendingRequest = null;\n+            return closeBlankTab();\n         }\n \n         @Override\n         public void onInfoBarDismissed() {\n-            if (mPendingRequest != null) {\n-                if (mPendingRequest.getDownloadGuid() != null) {\n-                    assert mTab != null;\n-                    nativeDangerousDownloadValidated(\n-                            mTab, mPendingRequest.getDownloadGuid(), false);\n-                } else if (!mPendingRequest.isGETRequest()) {\n-                    // Infobar was dismissed, discard the file if a POST download is pending.\n-                    discardFile(mPendingRequest.getFilePath());\n-                }\n+            if (mPendingRequest == null) return;\n+            if (mPendingRequest.getDownloadGuid() != null) {\n+                assert mTab != null;\n+                nativeDangerousDownloadValidated(\n+                        mTab, mPendingRequest.getDownloadGuid(), false);\n             }\n             // Forget the pending request.\n             mPendingRequest = null;\n@@ -151,38 +106,6 @@ public void onDestroyed(Tab tab) {\n         nativeInit(tab.getWebContents());\n     }\n \n-    @CalledByNative\n-    private void requestHttpGetDownload(String url, String userAgent, String contentDisposition,\n-            String mimeType, String cookie, String referer, boolean hasUserGesture,\n-            String filename, long contentLength, boolean mustDownload) {\n-        // If we're dealing with A/V content that's not explicitly marked for download, check if it\n-        // is streamable.\n-        if (!mustDownload) {\n-            // Query the package manager to see if there's a registered handler that matches.\n-            Intent intent = new Intent(Intent.ACTION_VIEW);\n-            intent.setDataAndType(Uri.parse(url), mimeType);\n-            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n-            // If the intent is resolved to ourselves, we don't want to attempt to load the url\n-            // only to try and download it again.\n-            if (DownloadManagerService.openIntent(mContext, intent, false)) {\n-                return;\n-            }\n-        }\n-        DownloadInfo downloadInfo = new DownloadInfo.Builder()\n-                .setUrl(url)\n-                .setUserAgent(userAgent)\n-                .setContentDisposition(contentDisposition)\n-                .setMimeType(mimeType)\n-                .setCookie(cookie)\n-                .setReferer(referer)\n-                .setHasUserGesture(hasUserGesture)\n-                .setFileName(filename)\n-                .setContentLength(contentLength)\n-                .setIsGETRequest(true)\n-                .build();\n-        onDownloadStartNoStream(downloadInfo);\n-    }\n-\n     /**\n      * Notify the host application a download should be done, even if there is a\n      * streaming viewer available for this type.\n@@ -232,7 +155,7 @@ protected void onPostExecute(Object[] result) {\n                 // The proper fix would be to let chrome knows which frame originated the request.\n                 if (\""application/x-shockwave-flash\"".equals(newInfo.getMimeType())) return;\n \n-                if (isDangerousFile(fileName, newMimeType)) {\n+                if (isDangerousFile(fileName)) {\n                     confirmDangerousDownload(newInfo);\n                 } else {\n                     // Not a dangerous file, proceed.\n@@ -480,8 +403,8 @@ private void alertDownloadFailure(String fileName, int reason) {\n      * @param mimeType MIME type of the content.\n      */\n     @CalledByNative\n-    private void onDownloadStarted(String filename, String mimeType) {\n-        if (!isDangerousFile(filename, mimeType)) {\n+    private void onDownloadStarted(String filename) {\n+        if (!isDangerousFile(filename)) {\n             DownloadUtils.showDownloadStartToast(mContext);\n             closeBlankTab();\n         }\n@@ -543,22 +466,10 @@ static String getFileExtension(String url, String filename) {\n      * Check whether a file is dangerous.\n      *\n      * @param filename Name of the file.\n-     * @param mimeType MIME type of the content.\n-     * @return true if the file is dangerous, or false otherwise.\n-     */\n-    protected boolean isDangerousFile(String filename, String mimeType) {\n-        return nativeIsDownloadDangerous(filename) || isDangerousExtension(\n-                MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType));\n-    }\n-\n-    /**\n-     * Check whether a file extension is dangerous.\n-     *\n-     * @param ext Extension of the file.\n      * @return true if the file is dangerous, or false otherwise.\n      */\n-    private static boolean isDangerousExtension(String ext) {\n-        return \""apk\"".equals(ext);\n+    protected boolean isDangerousFile(String filename) {\n+        return nativeIsDownloadDangerous(filename);\n     }\n \n     /**\n@@ -617,32 +528,30 @@ public boolean shouldInterceptContextMenuDownload(String url) {\n         String path = uri.getPath();\n         // OMA downloads have extension \""dm\"" or \""dd\"". For the latter, it\n         // can be handled when native download completes.\n-        if (path != null && (path.endsWith(\"".dm\""))) {\n-            if (mTab == null) return true;\n-            String fileName = URLUtil.guessFileName(\n-                    url, null, OMADownloadHandler.OMA_DRM_MESSAGE_MIME);\n-            final DownloadInfo downloadInfo =\n-                    new DownloadInfo.Builder().setUrl(url).setFileName(fileName).build();\n-            WindowAndroid window = mTab.getWindowAndroid();\n-            if (window.hasPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n-                onDownloadStartNoStream(downloadInfo);\n-            } else if (window.canRequestPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n-                PermissionCallback permissionCallback = new PermissionCallback() {\n-                    @Override\n-                    public void onRequestPermissionsResult(\n-                            String[] permissions, int[] grantResults) {\n-                        if (grantResults.length > 0\n-                                && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n-                            onDownloadStartNoStream(downloadInfo);\n-                        }\n+        if (path == null || !path.endsWith(\"".dm\"")) return false;\n+        if (mTab == null) return true;\n+        String fileName = URLUtil.guessFileName(\n+                url, null, OMADownloadHandler.OMA_DRM_MESSAGE_MIME);\n+        final DownloadInfo downloadInfo =\n+                new DownloadInfo.Builder().setUrl(url).setFileName(fileName).build();\n+        WindowAndroid window = mTab.getWindowAndroid();\n+        if (window.hasPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n+            onDownloadStartNoStream(downloadInfo);\n+        } else if (window.canRequestPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n+            PermissionCallback permissionCallback = new PermissionCallback() {\n+                @Override\n+                public void onRequestPermissionsResult(\n+                        String[] permissions, int[] grantResults) {\n+                    if (grantResults.length > 0\n+                            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n+                        onDownloadStartNoStream(downloadInfo);\n                     }\n-                };\n-                window.requestPermissions(\n-                        new String[] {permission.WRITE_EXTERNAL_STORAGE}, permissionCallback);\n-            }\n-            return true;\n+                }\n+            };\n+            window.requestPermissions(\n+                    new String[] {permission.WRITE_EXTERNAL_STORAGE}, permissionCallback);\n         }\n-        return false;\n+        return true;\n     }\n \n     protected Context getContext() {""}<_**next**_>{""sha"": ""974663c8e9682cfacd171b069e0420ab8f132a36"", ""filename"": ""chrome/browser/android/download/chrome_download_delegate.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 40, ""changes"": 42, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/chrome_download_delegate.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -142,49 +142,11 @@ void ChromeDownloadDelegate::SetJavaRef(JNIEnv* env, jobject jobj) {\n   java_ref_ = env->NewGlobalRef(jobj);\n }\n \n-void ChromeDownloadDelegate::RequestHTTPGetDownload(\n-    const std::string& url,\n-    const std::string& user_agent,\n-    const std::string& content_disposition,\n-    const std::string& mime_type,\n-    const std::string& cookie,\n-    const std::string& referer,\n-    const base::string16& file_name,\n-    int64_t content_length,\n-    bool has_user_gesture,\n-    bool must_download) {\n-  JNIEnv* env = base::android::AttachCurrentThread();\n-  ScopedJavaLocalRef<jstring> jurl =\n-      ConvertUTF8ToJavaString(env, url);\n-  ScopedJavaLocalRef<jstring> juser_agent =\n-      ConvertUTF8ToJavaString(env, user_agent);\n-  ScopedJavaLocalRef<jstring> jcontent_disposition =\n-      ConvertUTF8ToJavaString(env, content_disposition);\n-  ScopedJavaLocalRef<jstring> jmime_type =\n-      ConvertUTF8ToJavaString(env, mime_type);\n-  ScopedJavaLocalRef<jstring> jcookie =\n-      ConvertUTF8ToJavaString(env, cookie);\n-  ScopedJavaLocalRef<jstring> jreferer =\n-      ConvertUTF8ToJavaString(env, referer);\n-\n-  // net::GetSuggestedFilename will fallback to \""download\"" as filename.\n-  ScopedJavaLocalRef<jstring> jfilename =\n-      base::android::ConvertUTF16ToJavaString(env, file_name);\n-  Java_ChromeDownloadDelegate_requestHttpGetDownload(\n-      env, java_ref_, jurl, juser_agent, jcontent_disposition, jmime_type,\n-      jcookie, jreferer, has_user_gesture, jfilename, content_length,\n-      must_download);\n-}\n-\n-void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename,\n-                                               const std::string& mime_type) {\n+void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename) {\n   JNIEnv* env = base::android::AttachCurrentThread();\n   ScopedJavaLocalRef<jstring> jfilename = ConvertUTF8ToJavaString(\n       env, filename);\n-  ScopedJavaLocalRef<jstring> jmime_type =\n-      ConvertUTF8ToJavaString(env, mime_type);\n-  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename,\n-                                                jmime_type);\n+  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename);\n }\n \n void ChromeDownloadDelegate::OnDangerousDownload(const std::string& filename,""}<_**next**_>{""sha"": ""2fd96f342f171386656ddfea85d6de88e06582d7"", ""filename"": ""chrome/browser/android/download/chrome_download_delegate.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 12, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/chrome_download_delegate.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -19,18 +19,7 @@ class ChromeDownloadDelegate\n \n   void SetJavaRef(JNIEnv*, jobject obj);\n \n-  void RequestHTTPGetDownload(const std::string& url,\n-                              const std::string& user_agent,\n-                              const std::string& content_disposition,\n-                              const std::string& mime_type,\n-                              const std::string& cookie,\n-                              const std::string& referer,\n-                              const base::string16& file_name,\n-                              int64_t content_length,\n-                              bool has_user_geature,\n-                              bool must_download);\n-  void OnDownloadStarted(const std::string& filename,\n-                         const std::string& mime_type);\n+  void OnDownloadStarted(const std::string& filename);\n   void OnDangerousDownload(const std::string& filename,\n                            const std::string& guid);\n   void RequestFileAccess(intptr_t callback_id);""}<_**next**_>{""sha"": ""337b8ab62358f9e4b403d26def62ed649ef237f2"", ""filename"": ""chrome/browser/android/download/download_controller.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 62, ""changes"": 63, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -234,66 +234,6 @@ bool DownloadController::HasFileAccessPermission(\n       env, GetJavaObject()->Controller(env), jwindow_android);\n }\n \n-void DownloadController::CreateGETDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download,\n-    const DownloadInfo& info) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n-\n-  // We are yielding the UI thread and render_view_host may go away by\n-  // the time we come back. Pass along render_process_id and render_view_id\n-  // to retrieve it later (if it still exists).\n-  BrowserThread::PostTask(\n-      BrowserThread::UI, FROM_HERE,\n-      base::Bind(&DownloadController::StartAndroidDownload,\n-                 base::Unretained(this),\n-                 wc_getter, must_download, info));\n-}\n-\n-void DownloadController::StartAndroidDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n-\n-  WebContents* web_contents = wc_getter.Run();\n-  if (!web_contents) {\n-    // The view went away. Can't proceed.\n-    LOG(ERROR) << \""Download failed on URL:\"" << info.url.spec();\n-    return;\n-  }\n-\n-  AcquireFileAccessPermission(\n-      web_contents,\n-      base::Bind(&DownloadController::StartAndroidDownloadInternal,\n-                 base::Unretained(this), wc_getter, must_download, info));\n-}\n-\n-void DownloadController::StartAndroidDownloadInternal(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info, bool allowed) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n-  if (!allowed)\n-    return;\n-\n-  WebContents* web_contents = wc_getter.Run();\n-  // The view went away. Can't proceed.\n-  if (!web_contents)\n-    return;\n-\n-  base::string16 filename = net::GetSuggestedFilename(\n-      info.url, info.content_disposition,\n-      std::string(),  // referrer_charset\n-      std::string(),  // suggested_name\n-      info.original_mime_type,\n-      default_file_name_);\n-  ChromeDownloadDelegate::FromWebContents(web_contents)->RequestHTTPGetDownload(\n-      info.url.spec(), info.user_agent,\n-      info.content_disposition, info.original_mime_type,\n-      info.cookie, info.referer, filename,\n-      info.total_bytes, info.has_user_gesture,\n-      must_download);\n-}\n-\n void DownloadController::OnDownloadStarted(\n     DownloadItem* download_item) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n@@ -305,8 +245,7 @@ void DownloadController::OnDownloadStarted(\n   download_item->AddObserver(this);\n \n   ChromeDownloadDelegate::FromWebContents(web_contents)->OnDownloadStarted(\n-      download_item->GetTargetFilePath().BaseName().value(),\n-      download_item->GetMimeType());\n+      download_item->GetTargetFilePath().BaseName().value());\n }\n \n void DownloadController::OnDownloadUpdated(DownloadItem* item) {""}<_**next**_>{""sha"": ""163e815daa80f5bafac9c06f2c25c89bbc403f03"", ""filename"": ""chrome/browser/android/download/download_controller.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 14, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -76,10 +76,6 @@ class DownloadController : public DownloadControllerBase {\n   bool HasFileAccessPermission(ui::WindowAndroid* window_android);\n \n   // DownloadControllerBase implementation.\n-  void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) override;\n   void OnDownloadStarted(content::DownloadItem* download_item) override;\n   void StartContextMenuDownload(const content::ContextMenuParams& params,\n                                 content::WebContents* web_contents,\n@@ -92,16 +88,6 @@ class DownloadController : public DownloadControllerBase {\n   // DownloadItem::Observer interface.\n   void OnDownloadUpdated(content::DownloadItem* item) override;\n \n-  void StartAndroidDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info);\n-  void StartAndroidDownloadInternal(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info,\n-      bool allowed);\n-\n   // The download item contains dangerous file types.\n   void OnDangerousDownload(content::DownloadItem *item);\n ""}<_**next**_>{""sha"": ""c317ed4063275fd9796169235f064d41df342cb3"", ""filename"": ""chrome/browser/android/download/download_controller_base.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller_base.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -59,13 +59,6 @@ class DownloadControllerBase : public content::DownloadItem::Observer {\n   static void SetDownloadControllerBase(\n       DownloadControllerBase* download_controller);\n \n-  // Starts a new download request with Android. Should be called on the\n-  // UI thread.\n-  virtual void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) = 0;\n-\n   // Should be called when a download is started. It can be either a GET\n   // request with authentication or a POST request. Notifies the embedding\n   // app about the download. Should be called on the UI thread.""}<_**next**_>{""sha"": ""df198c6cd9a9c5dc6ef1241ae896207a74511397"", ""filename"": ""chrome/browser/android/download/mock_download_controller.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/mock_download_controller.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -17,11 +17,6 @@ MockDownloadController::MockDownloadController()\n \n MockDownloadController::~MockDownloadController() {}\n \n-void MockDownloadController::CreateGETDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info) {\n-}\n-\n void MockDownloadController::OnDownloadStarted(\n     content::DownloadItem* download_item) {\n }""}<_**next**_>{""sha"": ""399fcaf4fcb37454d5e20a48acd5fd5fdf724da7"", ""filename"": ""chrome/browser/android/download/mock_download_controller.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/mock_download_controller.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -25,10 +25,6 @@ class MockDownloadController : public DownloadControllerBase {\n   ~MockDownloadController() override;\n \n   // DownloadControllerBase implementation.\n-  void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) override;\n   void OnDownloadStarted(content::DownloadItem* download_item) override;\n   void StartContextMenuDownload(\n       const content::ContextMenuParams& params,""}","void DownloadController::StartAndroidDownload(
","void DownloadController::StartAndroidDownload(
    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
    bool must_download, const DownloadInfo& info) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  WebContents* web_contents = wc_getter.Run();
  if (!web_contents) {
    LOG(ERROR) << ""Download failed on URL:"" << info.url.spec();
    return;
  }
  AcquireFileAccessPermission(
      web_contents,
      base::Bind(&DownloadController::StartAndroidDownloadInternal,
                 base::Unretained(this), wc_getter, must_download, info));
}
",C,,"    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
    bool must_download, const DownloadInfo& info) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  WebContents* web_contents = wc_getter.Run();
  if (!web_contents) {
    LOG(ERROR) << ""Download failed on URL:"" << info.url.spec();
    return;
  }
  AcquireFileAccessPermission(
      web_contents,
      base::Bind(&DownloadController::StartAndroidDownloadInternal,
                 base::Unretained(this), wc_getter, must_download, info));
}
",,"@@ -234,66 +234,6 @@ bool DownloadController::HasFileAccessPermission(
       env, GetJavaObject()->Controller(env), jwindow_android);
 }
 
-void DownloadController::CreateGETDownload(
-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
-    bool must_download,
-    const DownloadInfo& info) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  // We are yielding the UI thread and render_view_host may go away by
-  // the time we come back. Pass along render_process_id and render_view_id
-  // to retrieve it later (if it still exists).
-  BrowserThread::PostTask(
-      BrowserThread::UI, FROM_HERE,
-      base::Bind(&DownloadController::StartAndroidDownload,
-                 base::Unretained(this),
-                 wc_getter, must_download, info));
-}
-
-void DownloadController::StartAndroidDownload(
-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
-    bool must_download, const DownloadInfo& info) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  WebContents* web_contents = wc_getter.Run();
-  if (!web_contents) {
-    // The view went away. Can't proceed.
-    LOG(ERROR) << ""Download failed on URL:"" << info.url.spec();
-    return;
-  }
-
-  AcquireFileAccessPermission(
-      web_contents,
-      base::Bind(&DownloadController::StartAndroidDownloadInternal,
-                 base::Unretained(this), wc_getter, must_download, info));
-}
-
-void DownloadController::StartAndroidDownloadInternal(
-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
-    bool must_download, const DownloadInfo& info, bool allowed) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  if (!allowed)
-    return;
-
-  WebContents* web_contents = wc_getter.Run();
-  // The view went away. Can't proceed.
-  if (!web_contents)
-    return;
-
-  base::string16 filename = net::GetSuggestedFilename(
-      info.url, info.content_disposition,
-      std::string(),  // referrer_charset
-      std::string(),  // suggested_name
-      info.original_mime_type,
-      default_file_name_);
-  ChromeDownloadDelegate::FromWebContents(web_contents)->RequestHTTPGetDownload(
-      info.url.spec(), info.user_agent,
-      info.content_disposition, info.original_mime_type,
-      info.cookie, info.referer, filename,
-      info.total_bytes, info.has_user_gesture,
-      must_download);
-}
-
 void DownloadController::OnDownloadStarted(
     DownloadItem* download_item) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
@@ -305,8 +245,7 @@ void DownloadController::OnDownloadStarted(
   download_item->AddObserver(this);
 
   ChromeDownloadDelegate::FromWebContents(web_contents)->OnDownloadStarted(
-      download_item->GetTargetFilePath().BaseName().value(),
-      download_item->GetMimeType());
+      download_item->GetTargetFilePath().BaseName().value());
 }
 
 void DownloadController::OnDownloadUpdated(DownloadItem* item) {",Chrome,5fc08cfb098acce49344d2e89cc27c915903f81c,832443eec1ac13b31d044967e8e36469bc4d28c5,1,"void DownloadController::StartAndroidDownload(
//flaw_line_below:
    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
//flaw_line_below:
    bool must_download, const DownloadInfo& info) {
//flaw_line_below:
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
//flaw_line_below:

//flaw_line_below:
  WebContents* web_contents = wc_getter.Run();
//flaw_line_below:
  if (!web_contents) {
//flaw_line_below:
    // The view went away. Can't proceed.
//flaw_line_below:
    LOG(ERROR) << ""Download failed on URL:"" << info.url.spec();
//flaw_line_below:
    return;
//flaw_line_below:
  }
//flaw_line_below:

//flaw_line_below:
  AcquireFileAccessPermission(
//flaw_line_below:
      web_contents,
//flaw_line_below:
      base::Bind(&DownloadController::StartAndroidDownloadInternal,
//flaw_line_below:
                 base::Unretained(this), wc_getter, must_download, info));
//flaw_line_below:
}
"
8026,185762,,Remote,Not required,,CVE-2015-1296,https://www.cvedetails.com/cve/CVE-2015-1296/,CWE-254,Low,,Partial,,2015-09-03,5.0,"The UnescapeURLWithAdjustmentsImpl implementation in net/base/escape.cc in Google Chrome before 45.0.2454.85 does not prevent display of Unicode LOCK characters in the omnibox, which makes it easier for remote attackers to spoof the SSL lock icon by placing one of these characters at the end of a URL, as demonstrated by the omnibox in localizations for right-to-left languages.",2016-12-21,,0,https://github.com/chromium/chromium/commit/5fc08cfb098acce49344d2e89cc27c915903f81c,5fc08cfb098acce49344d2e89cc27c915903f81c,"Clean up Android DownloadManager code as most download now go through Chrome Network stack

The only exception is OMA DRM download.
And it only applies to context menu download interception.
Clean up the remaining unused code now.

BUG=647755

Review-Url: https://codereview.chromium.org/2371773003
Cr-Commit-Position: refs/heads/master@{#421332}",21,chrome/browser/android/download/download_controller.cc,"{""sha"": ""0ef10538498fe7fb6a1a58f56601e42b101111a6"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 125, ""changes"": 159, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -9,7 +9,6 @@\n import android.app.DownloadManager;\n import android.content.Context;\n import android.content.DialogInterface;\n-import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -60,62 +59,18 @@ public boolean onInfoBarButtonClicked(boolean confirm) {\n                 if (confirm) {\n                     DownloadUtils.showDownloadStartToast(mContext);\n                 }\n-                mPendingRequest = null;\n-                return closeBlankTab();\n-            } else if (confirm) {\n-                // User confirmed the download.\n-                if (mPendingRequest.isGETRequest()) {\n-                    final DownloadInfo info = mPendingRequest;\n-                    new AsyncTask<Void, Void, Pair<String, String>>() {\n-                        @Override\n-                        protected Pair<String, String> doInBackground(Void... params) {\n-                            Pair<String, String> result = getDownloadDirectoryNameAndFullPath();\n-                            String fullDirPath = result.second;\n-                            return doesFileAlreadyExists(fullDirPath, info.getFileName())\n-                                    ? result : null;\n-                        }\n-\n-                        @Override\n-                        protected void onPostExecute(Pair<String, String> result) {\n-                            if (result != null) {\n-                                // File already exists.\n-                                String dirName = result.first;\n-                                String fullDirPath = result.second;\n-                                launchDownloadInfoBar(info, dirName, fullDirPath);\n-                            } else {\n-                                enqueueDownloadManagerRequest(info);\n-                            }\n-                        }\n-                    }.execute();\n-                } else {\n-                    DownloadInfo newDownloadInfo =\n-                            DownloadInfo.Builder.fromDownloadInfo(mPendingRequest).build();\n-                    DownloadManagerService.getDownloadManagerService(mContext).onDownloadCompleted(\n-                            newDownloadInfo);\n-                }\n-                mPendingRequest = null;\n-                return false;\n-            } else {\n-                // User did not accept the download, discard the file if it is a POST download.\n-                if (!mPendingRequest.isGETRequest()) {\n-                    discardFile(mPendingRequest.getFilePath());\n-                }\n-                mPendingRequest = null;\n-                return closeBlankTab();\n             }\n+            mPendingRequest = null;\n+            return closeBlankTab();\n         }\n \n         @Override\n         public void onInfoBarDismissed() {\n-            if (mPendingRequest != null) {\n-                if (mPendingRequest.getDownloadGuid() != null) {\n-                    assert mTab != null;\n-                    nativeDangerousDownloadValidated(\n-                            mTab, mPendingRequest.getDownloadGuid(), false);\n-                } else if (!mPendingRequest.isGETRequest()) {\n-                    // Infobar was dismissed, discard the file if a POST download is pending.\n-                    discardFile(mPendingRequest.getFilePath());\n-                }\n+            if (mPendingRequest == null) return;\n+            if (mPendingRequest.getDownloadGuid() != null) {\n+                assert mTab != null;\n+                nativeDangerousDownloadValidated(\n+                        mTab, mPendingRequest.getDownloadGuid(), false);\n             }\n             // Forget the pending request.\n             mPendingRequest = null;\n@@ -151,38 +106,6 @@ public void onDestroyed(Tab tab) {\n         nativeInit(tab.getWebContents());\n     }\n \n-    @CalledByNative\n-    private void requestHttpGetDownload(String url, String userAgent, String contentDisposition,\n-            String mimeType, String cookie, String referer, boolean hasUserGesture,\n-            String filename, long contentLength, boolean mustDownload) {\n-        // If we're dealing with A/V content that's not explicitly marked for download, check if it\n-        // is streamable.\n-        if (!mustDownload) {\n-            // Query the package manager to see if there's a registered handler that matches.\n-            Intent intent = new Intent(Intent.ACTION_VIEW);\n-            intent.setDataAndType(Uri.parse(url), mimeType);\n-            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n-            // If the intent is resolved to ourselves, we don't want to attempt to load the url\n-            // only to try and download it again.\n-            if (DownloadManagerService.openIntent(mContext, intent, false)) {\n-                return;\n-            }\n-        }\n-        DownloadInfo downloadInfo = new DownloadInfo.Builder()\n-                .setUrl(url)\n-                .setUserAgent(userAgent)\n-                .setContentDisposition(contentDisposition)\n-                .setMimeType(mimeType)\n-                .setCookie(cookie)\n-                .setReferer(referer)\n-                .setHasUserGesture(hasUserGesture)\n-                .setFileName(filename)\n-                .setContentLength(contentLength)\n-                .setIsGETRequest(true)\n-                .build();\n-        onDownloadStartNoStream(downloadInfo);\n-    }\n-\n     /**\n      * Notify the host application a download should be done, even if there is a\n      * streaming viewer available for this type.\n@@ -232,7 +155,7 @@ protected void onPostExecute(Object[] result) {\n                 // The proper fix would be to let chrome knows which frame originated the request.\n                 if (\""application/x-shockwave-flash\"".equals(newInfo.getMimeType())) return;\n \n-                if (isDangerousFile(fileName, newMimeType)) {\n+                if (isDangerousFile(fileName)) {\n                     confirmDangerousDownload(newInfo);\n                 } else {\n                     // Not a dangerous file, proceed.\n@@ -480,8 +403,8 @@ private void alertDownloadFailure(String fileName, int reason) {\n      * @param mimeType MIME type of the content.\n      */\n     @CalledByNative\n-    private void onDownloadStarted(String filename, String mimeType) {\n-        if (!isDangerousFile(filename, mimeType)) {\n+    private void onDownloadStarted(String filename) {\n+        if (!isDangerousFile(filename)) {\n             DownloadUtils.showDownloadStartToast(mContext);\n             closeBlankTab();\n         }\n@@ -543,22 +466,10 @@ static String getFileExtension(String url, String filename) {\n      * Check whether a file is dangerous.\n      *\n      * @param filename Name of the file.\n-     * @param mimeType MIME type of the content.\n-     * @return true if the file is dangerous, or false otherwise.\n-     */\n-    protected boolean isDangerousFile(String filename, String mimeType) {\n-        return nativeIsDownloadDangerous(filename) || isDangerousExtension(\n-                MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType));\n-    }\n-\n-    /**\n-     * Check whether a file extension is dangerous.\n-     *\n-     * @param ext Extension of the file.\n      * @return true if the file is dangerous, or false otherwise.\n      */\n-    private static boolean isDangerousExtension(String ext) {\n-        return \""apk\"".equals(ext);\n+    protected boolean isDangerousFile(String filename) {\n+        return nativeIsDownloadDangerous(filename);\n     }\n \n     /**\n@@ -617,32 +528,30 @@ public boolean shouldInterceptContextMenuDownload(String url) {\n         String path = uri.getPath();\n         // OMA downloads have extension \""dm\"" or \""dd\"". For the latter, it\n         // can be handled when native download completes.\n-        if (path != null && (path.endsWith(\"".dm\""))) {\n-            if (mTab == null) return true;\n-            String fileName = URLUtil.guessFileName(\n-                    url, null, OMADownloadHandler.OMA_DRM_MESSAGE_MIME);\n-            final DownloadInfo downloadInfo =\n-                    new DownloadInfo.Builder().setUrl(url).setFileName(fileName).build();\n-            WindowAndroid window = mTab.getWindowAndroid();\n-            if (window.hasPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n-                onDownloadStartNoStream(downloadInfo);\n-            } else if (window.canRequestPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n-                PermissionCallback permissionCallback = new PermissionCallback() {\n-                    @Override\n-                    public void onRequestPermissionsResult(\n-                            String[] permissions, int[] grantResults) {\n-                        if (grantResults.length > 0\n-                                && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n-                            onDownloadStartNoStream(downloadInfo);\n-                        }\n+        if (path == null || !path.endsWith(\"".dm\"")) return false;\n+        if (mTab == null) return true;\n+        String fileName = URLUtil.guessFileName(\n+                url, null, OMADownloadHandler.OMA_DRM_MESSAGE_MIME);\n+        final DownloadInfo downloadInfo =\n+                new DownloadInfo.Builder().setUrl(url).setFileName(fileName).build();\n+        WindowAndroid window = mTab.getWindowAndroid();\n+        if (window.hasPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n+            onDownloadStartNoStream(downloadInfo);\n+        } else if (window.canRequestPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n+            PermissionCallback permissionCallback = new PermissionCallback() {\n+                @Override\n+                public void onRequestPermissionsResult(\n+                        String[] permissions, int[] grantResults) {\n+                    if (grantResults.length > 0\n+                            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n+                        onDownloadStartNoStream(downloadInfo);\n                     }\n-                };\n-                window.requestPermissions(\n-                        new String[] {permission.WRITE_EXTERNAL_STORAGE}, permissionCallback);\n-            }\n-            return true;\n+                }\n+            };\n+            window.requestPermissions(\n+                    new String[] {permission.WRITE_EXTERNAL_STORAGE}, permissionCallback);\n         }\n-        return false;\n+        return true;\n     }\n \n     protected Context getContext() {""}<_**next**_>{""sha"": ""974663c8e9682cfacd171b069e0420ab8f132a36"", ""filename"": ""chrome/browser/android/download/chrome_download_delegate.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 40, ""changes"": 42, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/chrome_download_delegate.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -142,49 +142,11 @@ void ChromeDownloadDelegate::SetJavaRef(JNIEnv* env, jobject jobj) {\n   java_ref_ = env->NewGlobalRef(jobj);\n }\n \n-void ChromeDownloadDelegate::RequestHTTPGetDownload(\n-    const std::string& url,\n-    const std::string& user_agent,\n-    const std::string& content_disposition,\n-    const std::string& mime_type,\n-    const std::string& cookie,\n-    const std::string& referer,\n-    const base::string16& file_name,\n-    int64_t content_length,\n-    bool has_user_gesture,\n-    bool must_download) {\n-  JNIEnv* env = base::android::AttachCurrentThread();\n-  ScopedJavaLocalRef<jstring> jurl =\n-      ConvertUTF8ToJavaString(env, url);\n-  ScopedJavaLocalRef<jstring> juser_agent =\n-      ConvertUTF8ToJavaString(env, user_agent);\n-  ScopedJavaLocalRef<jstring> jcontent_disposition =\n-      ConvertUTF8ToJavaString(env, content_disposition);\n-  ScopedJavaLocalRef<jstring> jmime_type =\n-      ConvertUTF8ToJavaString(env, mime_type);\n-  ScopedJavaLocalRef<jstring> jcookie =\n-      ConvertUTF8ToJavaString(env, cookie);\n-  ScopedJavaLocalRef<jstring> jreferer =\n-      ConvertUTF8ToJavaString(env, referer);\n-\n-  // net::GetSuggestedFilename will fallback to \""download\"" as filename.\n-  ScopedJavaLocalRef<jstring> jfilename =\n-      base::android::ConvertUTF16ToJavaString(env, file_name);\n-  Java_ChromeDownloadDelegate_requestHttpGetDownload(\n-      env, java_ref_, jurl, juser_agent, jcontent_disposition, jmime_type,\n-      jcookie, jreferer, has_user_gesture, jfilename, content_length,\n-      must_download);\n-}\n-\n-void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename,\n-                                               const std::string& mime_type) {\n+void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename) {\n   JNIEnv* env = base::android::AttachCurrentThread();\n   ScopedJavaLocalRef<jstring> jfilename = ConvertUTF8ToJavaString(\n       env, filename);\n-  ScopedJavaLocalRef<jstring> jmime_type =\n-      ConvertUTF8ToJavaString(env, mime_type);\n-  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename,\n-                                                jmime_type);\n+  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename);\n }\n \n void ChromeDownloadDelegate::OnDangerousDownload(const std::string& filename,""}<_**next**_>{""sha"": ""2fd96f342f171386656ddfea85d6de88e06582d7"", ""filename"": ""chrome/browser/android/download/chrome_download_delegate.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 12, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/chrome_download_delegate.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -19,18 +19,7 @@ class ChromeDownloadDelegate\n \n   void SetJavaRef(JNIEnv*, jobject obj);\n \n-  void RequestHTTPGetDownload(const std::string& url,\n-                              const std::string& user_agent,\n-                              const std::string& content_disposition,\n-                              const std::string& mime_type,\n-                              const std::string& cookie,\n-                              const std::string& referer,\n-                              const base::string16& file_name,\n-                              int64_t content_length,\n-                              bool has_user_geature,\n-                              bool must_download);\n-  void OnDownloadStarted(const std::string& filename,\n-                         const std::string& mime_type);\n+  void OnDownloadStarted(const std::string& filename);\n   void OnDangerousDownload(const std::string& filename,\n                            const std::string& guid);\n   void RequestFileAccess(intptr_t callback_id);""}<_**next**_>{""sha"": ""337b8ab62358f9e4b403d26def62ed649ef237f2"", ""filename"": ""chrome/browser/android/download/download_controller.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 62, ""changes"": 63, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -234,66 +234,6 @@ bool DownloadController::HasFileAccessPermission(\n       env, GetJavaObject()->Controller(env), jwindow_android);\n }\n \n-void DownloadController::CreateGETDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download,\n-    const DownloadInfo& info) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n-\n-  // We are yielding the UI thread and render_view_host may go away by\n-  // the time we come back. Pass along render_process_id and render_view_id\n-  // to retrieve it later (if it still exists).\n-  BrowserThread::PostTask(\n-      BrowserThread::UI, FROM_HERE,\n-      base::Bind(&DownloadController::StartAndroidDownload,\n-                 base::Unretained(this),\n-                 wc_getter, must_download, info));\n-}\n-\n-void DownloadController::StartAndroidDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n-\n-  WebContents* web_contents = wc_getter.Run();\n-  if (!web_contents) {\n-    // The view went away. Can't proceed.\n-    LOG(ERROR) << \""Download failed on URL:\"" << info.url.spec();\n-    return;\n-  }\n-\n-  AcquireFileAccessPermission(\n-      web_contents,\n-      base::Bind(&DownloadController::StartAndroidDownloadInternal,\n-                 base::Unretained(this), wc_getter, must_download, info));\n-}\n-\n-void DownloadController::StartAndroidDownloadInternal(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info, bool allowed) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n-  if (!allowed)\n-    return;\n-\n-  WebContents* web_contents = wc_getter.Run();\n-  // The view went away. Can't proceed.\n-  if (!web_contents)\n-    return;\n-\n-  base::string16 filename = net::GetSuggestedFilename(\n-      info.url, info.content_disposition,\n-      std::string(),  // referrer_charset\n-      std::string(),  // suggested_name\n-      info.original_mime_type,\n-      default_file_name_);\n-  ChromeDownloadDelegate::FromWebContents(web_contents)->RequestHTTPGetDownload(\n-      info.url.spec(), info.user_agent,\n-      info.content_disposition, info.original_mime_type,\n-      info.cookie, info.referer, filename,\n-      info.total_bytes, info.has_user_gesture,\n-      must_download);\n-}\n-\n void DownloadController::OnDownloadStarted(\n     DownloadItem* download_item) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n@@ -305,8 +245,7 @@ void DownloadController::OnDownloadStarted(\n   download_item->AddObserver(this);\n \n   ChromeDownloadDelegate::FromWebContents(web_contents)->OnDownloadStarted(\n-      download_item->GetTargetFilePath().BaseName().value(),\n-      download_item->GetMimeType());\n+      download_item->GetTargetFilePath().BaseName().value());\n }\n \n void DownloadController::OnDownloadUpdated(DownloadItem* item) {""}<_**next**_>{""sha"": ""163e815daa80f5bafac9c06f2c25c89bbc403f03"", ""filename"": ""chrome/browser/android/download/download_controller.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 14, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -76,10 +76,6 @@ class DownloadController : public DownloadControllerBase {\n   bool HasFileAccessPermission(ui::WindowAndroid* window_android);\n \n   // DownloadControllerBase implementation.\n-  void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) override;\n   void OnDownloadStarted(content::DownloadItem* download_item) override;\n   void StartContextMenuDownload(const content::ContextMenuParams& params,\n                                 content::WebContents* web_contents,\n@@ -92,16 +88,6 @@ class DownloadController : public DownloadControllerBase {\n   // DownloadItem::Observer interface.\n   void OnDownloadUpdated(content::DownloadItem* item) override;\n \n-  void StartAndroidDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info);\n-  void StartAndroidDownloadInternal(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info,\n-      bool allowed);\n-\n   // The download item contains dangerous file types.\n   void OnDangerousDownload(content::DownloadItem *item);\n ""}<_**next**_>{""sha"": ""c317ed4063275fd9796169235f064d41df342cb3"", ""filename"": ""chrome/browser/android/download/download_controller_base.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller_base.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -59,13 +59,6 @@ class DownloadControllerBase : public content::DownloadItem::Observer {\n   static void SetDownloadControllerBase(\n       DownloadControllerBase* download_controller);\n \n-  // Starts a new download request with Android. Should be called on the\n-  // UI thread.\n-  virtual void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) = 0;\n-\n   // Should be called when a download is started. It can be either a GET\n   // request with authentication or a POST request. Notifies the embedding\n   // app about the download. Should be called on the UI thread.""}<_**next**_>{""sha"": ""df198c6cd9a9c5dc6ef1241ae896207a74511397"", ""filename"": ""chrome/browser/android/download/mock_download_controller.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/mock_download_controller.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -17,11 +17,6 @@ MockDownloadController::MockDownloadController()\n \n MockDownloadController::~MockDownloadController() {}\n \n-void MockDownloadController::CreateGETDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info) {\n-}\n-\n void MockDownloadController::OnDownloadStarted(\n     content::DownloadItem* download_item) {\n }""}<_**next**_>{""sha"": ""399fcaf4fcb37454d5e20a48acd5fd5fdf724da7"", ""filename"": ""chrome/browser/android/download/mock_download_controller.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/mock_download_controller.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -25,10 +25,6 @@ class MockDownloadController : public DownloadControllerBase {\n   ~MockDownloadController() override;\n \n   // DownloadControllerBase implementation.\n-  void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) override;\n   void OnDownloadStarted(content::DownloadItem* download_item) override;\n   void StartContextMenuDownload(\n       const content::ContextMenuParams& params,""}","void DownloadController::StartAndroidDownloadInternal(
","void DownloadController::StartAndroidDownloadInternal(
    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
    bool must_download, const DownloadInfo& info, bool allowed) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  if (!allowed)
    return;
  WebContents* web_contents = wc_getter.Run();
  if (!web_contents)
    return;
  base::string16 filename = net::GetSuggestedFilename(
      info.url, info.content_disposition,
      std::string(),  // referrer_charset
      std::string(),  // suggested_name
      info.original_mime_type,
      default_file_name_);
  ChromeDownloadDelegate::FromWebContents(web_contents)->RequestHTTPGetDownload(
      info.url.spec(), info.user_agent,
      info.content_disposition, info.original_mime_type,
      info.cookie, info.referer, filename,
      info.total_bytes, info.has_user_gesture,
      must_download);
}
",C,,"    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
    bool must_download, const DownloadInfo& info, bool allowed) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  if (!allowed)
    return;
  WebContents* web_contents = wc_getter.Run();
  if (!web_contents)
    return;
  base::string16 filename = net::GetSuggestedFilename(
      info.url, info.content_disposition,
      std::string(),  // referrer_charset
      std::string(),  // suggested_name
      info.original_mime_type,
      default_file_name_);
  ChromeDownloadDelegate::FromWebContents(web_contents)->RequestHTTPGetDownload(
      info.url.spec(), info.user_agent,
      info.content_disposition, info.original_mime_type,
      info.cookie, info.referer, filename,
      info.total_bytes, info.has_user_gesture,
      must_download);
}
",,"@@ -234,66 +234,6 @@ bool DownloadController::HasFileAccessPermission(
       env, GetJavaObject()->Controller(env), jwindow_android);
 }
 
-void DownloadController::CreateGETDownload(
-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
-    bool must_download,
-    const DownloadInfo& info) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  // We are yielding the UI thread and render_view_host may go away by
-  // the time we come back. Pass along render_process_id and render_view_id
-  // to retrieve it later (if it still exists).
-  BrowserThread::PostTask(
-      BrowserThread::UI, FROM_HERE,
-      base::Bind(&DownloadController::StartAndroidDownload,
-                 base::Unretained(this),
-                 wc_getter, must_download, info));
-}
-
-void DownloadController::StartAndroidDownload(
-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
-    bool must_download, const DownloadInfo& info) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  WebContents* web_contents = wc_getter.Run();
-  if (!web_contents) {
-    // The view went away. Can't proceed.
-    LOG(ERROR) << ""Download failed on URL:"" << info.url.spec();
-    return;
-  }
-
-  AcquireFileAccessPermission(
-      web_contents,
-      base::Bind(&DownloadController::StartAndroidDownloadInternal,
-                 base::Unretained(this), wc_getter, must_download, info));
-}
-
-void DownloadController::StartAndroidDownloadInternal(
-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
-    bool must_download, const DownloadInfo& info, bool allowed) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  if (!allowed)
-    return;
-
-  WebContents* web_contents = wc_getter.Run();
-  // The view went away. Can't proceed.
-  if (!web_contents)
-    return;
-
-  base::string16 filename = net::GetSuggestedFilename(
-      info.url, info.content_disposition,
-      std::string(),  // referrer_charset
-      std::string(),  // suggested_name
-      info.original_mime_type,
-      default_file_name_);
-  ChromeDownloadDelegate::FromWebContents(web_contents)->RequestHTTPGetDownload(
-      info.url.spec(), info.user_agent,
-      info.content_disposition, info.original_mime_type,
-      info.cookie, info.referer, filename,
-      info.total_bytes, info.has_user_gesture,
-      must_download);
-}
-
 void DownloadController::OnDownloadStarted(
     DownloadItem* download_item) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
@@ -305,8 +245,7 @@ void DownloadController::OnDownloadStarted(
   download_item->AddObserver(this);
 
   ChromeDownloadDelegate::FromWebContents(web_contents)->OnDownloadStarted(
-      download_item->GetTargetFilePath().BaseName().value(),
-      download_item->GetMimeType());
+      download_item->GetTargetFilePath().BaseName().value());
 }
 
 void DownloadController::OnDownloadUpdated(DownloadItem* item) {",Chrome,5fc08cfb098acce49344d2e89cc27c915903f81c,832443eec1ac13b31d044967e8e36469bc4d28c5,1,"void DownloadController::StartAndroidDownloadInternal(
//flaw_line_below:
    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
//flaw_line_below:
    bool must_download, const DownloadInfo& info, bool allowed) {
//flaw_line_below:
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
//flaw_line_below:
  if (!allowed)
//flaw_line_below:
    return;
//flaw_line_below:

//flaw_line_below:
  WebContents* web_contents = wc_getter.Run();
//flaw_line_below:
  // The view went away. Can't proceed.
//flaw_line_below:
  if (!web_contents)
//flaw_line_below:
    return;
//flaw_line_below:

//flaw_line_below:
  base::string16 filename = net::GetSuggestedFilename(
//flaw_line_below:
      info.url, info.content_disposition,
//flaw_line_below:
      std::string(),  // referrer_charset
//flaw_line_below:
      std::string(),  // suggested_name
//flaw_line_below:
      info.original_mime_type,
//flaw_line_below:
      default_file_name_);
//flaw_line_below:
  ChromeDownloadDelegate::FromWebContents(web_contents)->RequestHTTPGetDownload(
//flaw_line_below:
      info.url.spec(), info.user_agent,
//flaw_line_below:
      info.content_disposition, info.original_mime_type,
//flaw_line_below:
      info.cookie, info.referer, filename,
//flaw_line_below:
      info.total_bytes, info.has_user_gesture,
//flaw_line_below:
      must_download);
//flaw_line_below:
}
"
8027,185763,,Remote,Not required,,CVE-2015-1296,https://www.cvedetails.com/cve/CVE-2015-1296/,CWE-254,Low,,Partial,,2015-09-03,5.0,"The UnescapeURLWithAdjustmentsImpl implementation in net/base/escape.cc in Google Chrome before 45.0.2454.85 does not prevent display of Unicode LOCK characters in the omnibox, which makes it easier for remote attackers to spoof the SSL lock icon by placing one of these characters at the end of a URL, as demonstrated by the omnibox in localizations for right-to-left languages.",2016-12-21,,0,https://github.com/chromium/chromium/commit/5fc08cfb098acce49344d2e89cc27c915903f81c,5fc08cfb098acce49344d2e89cc27c915903f81c,"Clean up Android DownloadManager code as most download now go through Chrome Network stack

The only exception is OMA DRM download.
And it only applies to context menu download interception.
Clean up the remaining unused code now.

BUG=647755

Review-Url: https://codereview.chromium.org/2371773003
Cr-Commit-Position: refs/heads/master@{#421332}",3,chrome/browser/android/download/mock_download_controller.cc,"{""sha"": ""0ef10538498fe7fb6a1a58f56601e42b101111a6"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 125, ""changes"": 159, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/download/ChromeDownloadDelegate.java?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -9,7 +9,6 @@\n import android.app.DownloadManager;\n import android.content.Context;\n import android.content.DialogInterface;\n-import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -60,62 +59,18 @@ public boolean onInfoBarButtonClicked(boolean confirm) {\n                 if (confirm) {\n                     DownloadUtils.showDownloadStartToast(mContext);\n                 }\n-                mPendingRequest = null;\n-                return closeBlankTab();\n-            } else if (confirm) {\n-                // User confirmed the download.\n-                if (mPendingRequest.isGETRequest()) {\n-                    final DownloadInfo info = mPendingRequest;\n-                    new AsyncTask<Void, Void, Pair<String, String>>() {\n-                        @Override\n-                        protected Pair<String, String> doInBackground(Void... params) {\n-                            Pair<String, String> result = getDownloadDirectoryNameAndFullPath();\n-                            String fullDirPath = result.second;\n-                            return doesFileAlreadyExists(fullDirPath, info.getFileName())\n-                                    ? result : null;\n-                        }\n-\n-                        @Override\n-                        protected void onPostExecute(Pair<String, String> result) {\n-                            if (result != null) {\n-                                // File already exists.\n-                                String dirName = result.first;\n-                                String fullDirPath = result.second;\n-                                launchDownloadInfoBar(info, dirName, fullDirPath);\n-                            } else {\n-                                enqueueDownloadManagerRequest(info);\n-                            }\n-                        }\n-                    }.execute();\n-                } else {\n-                    DownloadInfo newDownloadInfo =\n-                            DownloadInfo.Builder.fromDownloadInfo(mPendingRequest).build();\n-                    DownloadManagerService.getDownloadManagerService(mContext).onDownloadCompleted(\n-                            newDownloadInfo);\n-                }\n-                mPendingRequest = null;\n-                return false;\n-            } else {\n-                // User did not accept the download, discard the file if it is a POST download.\n-                if (!mPendingRequest.isGETRequest()) {\n-                    discardFile(mPendingRequest.getFilePath());\n-                }\n-                mPendingRequest = null;\n-                return closeBlankTab();\n             }\n+            mPendingRequest = null;\n+            return closeBlankTab();\n         }\n \n         @Override\n         public void onInfoBarDismissed() {\n-            if (mPendingRequest != null) {\n-                if (mPendingRequest.getDownloadGuid() != null) {\n-                    assert mTab != null;\n-                    nativeDangerousDownloadValidated(\n-                            mTab, mPendingRequest.getDownloadGuid(), false);\n-                } else if (!mPendingRequest.isGETRequest()) {\n-                    // Infobar was dismissed, discard the file if a POST download is pending.\n-                    discardFile(mPendingRequest.getFilePath());\n-                }\n+            if (mPendingRequest == null) return;\n+            if (mPendingRequest.getDownloadGuid() != null) {\n+                assert mTab != null;\n+                nativeDangerousDownloadValidated(\n+                        mTab, mPendingRequest.getDownloadGuid(), false);\n             }\n             // Forget the pending request.\n             mPendingRequest = null;\n@@ -151,38 +106,6 @@ public void onDestroyed(Tab tab) {\n         nativeInit(tab.getWebContents());\n     }\n \n-    @CalledByNative\n-    private void requestHttpGetDownload(String url, String userAgent, String contentDisposition,\n-            String mimeType, String cookie, String referer, boolean hasUserGesture,\n-            String filename, long contentLength, boolean mustDownload) {\n-        // If we're dealing with A/V content that's not explicitly marked for download, check if it\n-        // is streamable.\n-        if (!mustDownload) {\n-            // Query the package manager to see if there's a registered handler that matches.\n-            Intent intent = new Intent(Intent.ACTION_VIEW);\n-            intent.setDataAndType(Uri.parse(url), mimeType);\n-            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n-            // If the intent is resolved to ourselves, we don't want to attempt to load the url\n-            // only to try and download it again.\n-            if (DownloadManagerService.openIntent(mContext, intent, false)) {\n-                return;\n-            }\n-        }\n-        DownloadInfo downloadInfo = new DownloadInfo.Builder()\n-                .setUrl(url)\n-                .setUserAgent(userAgent)\n-                .setContentDisposition(contentDisposition)\n-                .setMimeType(mimeType)\n-                .setCookie(cookie)\n-                .setReferer(referer)\n-                .setHasUserGesture(hasUserGesture)\n-                .setFileName(filename)\n-                .setContentLength(contentLength)\n-                .setIsGETRequest(true)\n-                .build();\n-        onDownloadStartNoStream(downloadInfo);\n-    }\n-\n     /**\n      * Notify the host application a download should be done, even if there is a\n      * streaming viewer available for this type.\n@@ -232,7 +155,7 @@ protected void onPostExecute(Object[] result) {\n                 // The proper fix would be to let chrome knows which frame originated the request.\n                 if (\""application/x-shockwave-flash\"".equals(newInfo.getMimeType())) return;\n \n-                if (isDangerousFile(fileName, newMimeType)) {\n+                if (isDangerousFile(fileName)) {\n                     confirmDangerousDownload(newInfo);\n                 } else {\n                     // Not a dangerous file, proceed.\n@@ -480,8 +403,8 @@ private void alertDownloadFailure(String fileName, int reason) {\n      * @param mimeType MIME type of the content.\n      */\n     @CalledByNative\n-    private void onDownloadStarted(String filename, String mimeType) {\n-        if (!isDangerousFile(filename, mimeType)) {\n+    private void onDownloadStarted(String filename) {\n+        if (!isDangerousFile(filename)) {\n             DownloadUtils.showDownloadStartToast(mContext);\n             closeBlankTab();\n         }\n@@ -543,22 +466,10 @@ static String getFileExtension(String url, String filename) {\n      * Check whether a file is dangerous.\n      *\n      * @param filename Name of the file.\n-     * @param mimeType MIME type of the content.\n-     * @return true if the file is dangerous, or false otherwise.\n-     */\n-    protected boolean isDangerousFile(String filename, String mimeType) {\n-        return nativeIsDownloadDangerous(filename) || isDangerousExtension(\n-                MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType));\n-    }\n-\n-    /**\n-     * Check whether a file extension is dangerous.\n-     *\n-     * @param ext Extension of the file.\n      * @return true if the file is dangerous, or false otherwise.\n      */\n-    private static boolean isDangerousExtension(String ext) {\n-        return \""apk\"".equals(ext);\n+    protected boolean isDangerousFile(String filename) {\n+        return nativeIsDownloadDangerous(filename);\n     }\n \n     /**\n@@ -617,32 +528,30 @@ public boolean shouldInterceptContextMenuDownload(String url) {\n         String path = uri.getPath();\n         // OMA downloads have extension \""dm\"" or \""dd\"". For the latter, it\n         // can be handled when native download completes.\n-        if (path != null && (path.endsWith(\"".dm\""))) {\n-            if (mTab == null) return true;\n-            String fileName = URLUtil.guessFileName(\n-                    url, null, OMADownloadHandler.OMA_DRM_MESSAGE_MIME);\n-            final DownloadInfo downloadInfo =\n-                    new DownloadInfo.Builder().setUrl(url).setFileName(fileName).build();\n-            WindowAndroid window = mTab.getWindowAndroid();\n-            if (window.hasPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n-                onDownloadStartNoStream(downloadInfo);\n-            } else if (window.canRequestPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n-                PermissionCallback permissionCallback = new PermissionCallback() {\n-                    @Override\n-                    public void onRequestPermissionsResult(\n-                            String[] permissions, int[] grantResults) {\n-                        if (grantResults.length > 0\n-                                && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n-                            onDownloadStartNoStream(downloadInfo);\n-                        }\n+        if (path == null || !path.endsWith(\"".dm\"")) return false;\n+        if (mTab == null) return true;\n+        String fileName = URLUtil.guessFileName(\n+                url, null, OMADownloadHandler.OMA_DRM_MESSAGE_MIME);\n+        final DownloadInfo downloadInfo =\n+                new DownloadInfo.Builder().setUrl(url).setFileName(fileName).build();\n+        WindowAndroid window = mTab.getWindowAndroid();\n+        if (window.hasPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n+            onDownloadStartNoStream(downloadInfo);\n+        } else if (window.canRequestPermission(permission.WRITE_EXTERNAL_STORAGE)) {\n+            PermissionCallback permissionCallback = new PermissionCallback() {\n+                @Override\n+                public void onRequestPermissionsResult(\n+                        String[] permissions, int[] grantResults) {\n+                    if (grantResults.length > 0\n+                            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n+                        onDownloadStartNoStream(downloadInfo);\n                     }\n-                };\n-                window.requestPermissions(\n-                        new String[] {permission.WRITE_EXTERNAL_STORAGE}, permissionCallback);\n-            }\n-            return true;\n+                }\n+            };\n+            window.requestPermissions(\n+                    new String[] {permission.WRITE_EXTERNAL_STORAGE}, permissionCallback);\n         }\n-        return false;\n+        return true;\n     }\n \n     protected Context getContext() {""}<_**next**_>{""sha"": ""974663c8e9682cfacd171b069e0420ab8f132a36"", ""filename"": ""chrome/browser/android/download/chrome_download_delegate.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 40, ""changes"": 42, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/chrome_download_delegate.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -142,49 +142,11 @@ void ChromeDownloadDelegate::SetJavaRef(JNIEnv* env, jobject jobj) {\n   java_ref_ = env->NewGlobalRef(jobj);\n }\n \n-void ChromeDownloadDelegate::RequestHTTPGetDownload(\n-    const std::string& url,\n-    const std::string& user_agent,\n-    const std::string& content_disposition,\n-    const std::string& mime_type,\n-    const std::string& cookie,\n-    const std::string& referer,\n-    const base::string16& file_name,\n-    int64_t content_length,\n-    bool has_user_gesture,\n-    bool must_download) {\n-  JNIEnv* env = base::android::AttachCurrentThread();\n-  ScopedJavaLocalRef<jstring> jurl =\n-      ConvertUTF8ToJavaString(env, url);\n-  ScopedJavaLocalRef<jstring> juser_agent =\n-      ConvertUTF8ToJavaString(env, user_agent);\n-  ScopedJavaLocalRef<jstring> jcontent_disposition =\n-      ConvertUTF8ToJavaString(env, content_disposition);\n-  ScopedJavaLocalRef<jstring> jmime_type =\n-      ConvertUTF8ToJavaString(env, mime_type);\n-  ScopedJavaLocalRef<jstring> jcookie =\n-      ConvertUTF8ToJavaString(env, cookie);\n-  ScopedJavaLocalRef<jstring> jreferer =\n-      ConvertUTF8ToJavaString(env, referer);\n-\n-  // net::GetSuggestedFilename will fallback to \""download\"" as filename.\n-  ScopedJavaLocalRef<jstring> jfilename =\n-      base::android::ConvertUTF16ToJavaString(env, file_name);\n-  Java_ChromeDownloadDelegate_requestHttpGetDownload(\n-      env, java_ref_, jurl, juser_agent, jcontent_disposition, jmime_type,\n-      jcookie, jreferer, has_user_gesture, jfilename, content_length,\n-      must_download);\n-}\n-\n-void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename,\n-                                               const std::string& mime_type) {\n+void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename) {\n   JNIEnv* env = base::android::AttachCurrentThread();\n   ScopedJavaLocalRef<jstring> jfilename = ConvertUTF8ToJavaString(\n       env, filename);\n-  ScopedJavaLocalRef<jstring> jmime_type =\n-      ConvertUTF8ToJavaString(env, mime_type);\n-  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename,\n-                                                jmime_type);\n+  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename);\n }\n \n void ChromeDownloadDelegate::OnDangerousDownload(const std::string& filename,""}<_**next**_>{""sha"": ""2fd96f342f171386656ddfea85d6de88e06582d7"", ""filename"": ""chrome/browser/android/download/chrome_download_delegate.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 12, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/chrome_download_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/chrome_download_delegate.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -19,18 +19,7 @@ class ChromeDownloadDelegate\n \n   void SetJavaRef(JNIEnv*, jobject obj);\n \n-  void RequestHTTPGetDownload(const std::string& url,\n-                              const std::string& user_agent,\n-                              const std::string& content_disposition,\n-                              const std::string& mime_type,\n-                              const std::string& cookie,\n-                              const std::string& referer,\n-                              const base::string16& file_name,\n-                              int64_t content_length,\n-                              bool has_user_geature,\n-                              bool must_download);\n-  void OnDownloadStarted(const std::string& filename,\n-                         const std::string& mime_type);\n+  void OnDownloadStarted(const std::string& filename);\n   void OnDangerousDownload(const std::string& filename,\n                            const std::string& guid);\n   void RequestFileAccess(intptr_t callback_id);""}<_**next**_>{""sha"": ""337b8ab62358f9e4b403d26def62ed649ef237f2"", ""filename"": ""chrome/browser/android/download/download_controller.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 62, ""changes"": 63, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -234,66 +234,6 @@ bool DownloadController::HasFileAccessPermission(\n       env, GetJavaObject()->Controller(env), jwindow_android);\n }\n \n-void DownloadController::CreateGETDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download,\n-    const DownloadInfo& info) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n-\n-  // We are yielding the UI thread and render_view_host may go away by\n-  // the time we come back. Pass along render_process_id and render_view_id\n-  // to retrieve it later (if it still exists).\n-  BrowserThread::PostTask(\n-      BrowserThread::UI, FROM_HERE,\n-      base::Bind(&DownloadController::StartAndroidDownload,\n-                 base::Unretained(this),\n-                 wc_getter, must_download, info));\n-}\n-\n-void DownloadController::StartAndroidDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n-\n-  WebContents* web_contents = wc_getter.Run();\n-  if (!web_contents) {\n-    // The view went away. Can't proceed.\n-    LOG(ERROR) << \""Download failed on URL:\"" << info.url.spec();\n-    return;\n-  }\n-\n-  AcquireFileAccessPermission(\n-      web_contents,\n-      base::Bind(&DownloadController::StartAndroidDownloadInternal,\n-                 base::Unretained(this), wc_getter, must_download, info));\n-}\n-\n-void DownloadController::StartAndroidDownloadInternal(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info, bool allowed) {\n-  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n-  if (!allowed)\n-    return;\n-\n-  WebContents* web_contents = wc_getter.Run();\n-  // The view went away. Can't proceed.\n-  if (!web_contents)\n-    return;\n-\n-  base::string16 filename = net::GetSuggestedFilename(\n-      info.url, info.content_disposition,\n-      std::string(),  // referrer_charset\n-      std::string(),  // suggested_name\n-      info.original_mime_type,\n-      default_file_name_);\n-  ChromeDownloadDelegate::FromWebContents(web_contents)->RequestHTTPGetDownload(\n-      info.url.spec(), info.user_agent,\n-      info.content_disposition, info.original_mime_type,\n-      info.cookie, info.referer, filename,\n-      info.total_bytes, info.has_user_gesture,\n-      must_download);\n-}\n-\n void DownloadController::OnDownloadStarted(\n     DownloadItem* download_item) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n@@ -305,8 +245,7 @@ void DownloadController::OnDownloadStarted(\n   download_item->AddObserver(this);\n \n   ChromeDownloadDelegate::FromWebContents(web_contents)->OnDownloadStarted(\n-      download_item->GetTargetFilePath().BaseName().value(),\n-      download_item->GetMimeType());\n+      download_item->GetTargetFilePath().BaseName().value());\n }\n \n void DownloadController::OnDownloadUpdated(DownloadItem* item) {""}<_**next**_>{""sha"": ""163e815daa80f5bafac9c06f2c25c89bbc403f03"", ""filename"": ""chrome/browser/android/download/download_controller.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 14, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -76,10 +76,6 @@ class DownloadController : public DownloadControllerBase {\n   bool HasFileAccessPermission(ui::WindowAndroid* window_android);\n \n   // DownloadControllerBase implementation.\n-  void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) override;\n   void OnDownloadStarted(content::DownloadItem* download_item) override;\n   void StartContextMenuDownload(const content::ContextMenuParams& params,\n                                 content::WebContents* web_contents,\n@@ -92,16 +88,6 @@ class DownloadController : public DownloadControllerBase {\n   // DownloadItem::Observer interface.\n   void OnDownloadUpdated(content::DownloadItem* item) override;\n \n-  void StartAndroidDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info);\n-  void StartAndroidDownloadInternal(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info,\n-      bool allowed);\n-\n   // The download item contains dangerous file types.\n   void OnDangerousDownload(content::DownloadItem *item);\n ""}<_**next**_>{""sha"": ""c317ed4063275fd9796169235f064d41df342cb3"", ""filename"": ""chrome/browser/android/download/download_controller_base.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/download_controller_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/download_controller_base.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -59,13 +59,6 @@ class DownloadControllerBase : public content::DownloadItem::Observer {\n   static void SetDownloadControllerBase(\n       DownloadControllerBase* download_controller);\n \n-  // Starts a new download request with Android. Should be called on the\n-  // UI thread.\n-  virtual void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) = 0;\n-\n   // Should be called when a download is started. It can be either a GET\n   // request with authentication or a POST request. Notifies the embedding\n   // app about the download. Should be called on the UI thread.""}<_**next**_>{""sha"": ""df198c6cd9a9c5dc6ef1241ae896207a74511397"", ""filename"": ""chrome/browser/android/download/mock_download_controller.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/mock_download_controller.cc?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -17,11 +17,6 @@ MockDownloadController::MockDownloadController()\n \n MockDownloadController::~MockDownloadController() {}\n \n-void MockDownloadController::CreateGETDownload(\n-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-    bool must_download, const DownloadInfo& info) {\n-}\n-\n void MockDownloadController::OnDownloadStarted(\n     content::DownloadItem* download_item) {\n }""}<_**next**_>{""sha"": ""399fcaf4fcb37454d5e20a48acd5fd5fdf724da7"", ""filename"": ""chrome/browser/android/download/mock_download_controller.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fc08cfb098acce49344d2e89cc27c915903f81c/chrome/browser/android/download/mock_download_controller.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/download/mock_download_controller.h?ref=5fc08cfb098acce49344d2e89cc27c915903f81c"", ""patch"": ""@@ -25,10 +25,6 @@ class MockDownloadController : public DownloadControllerBase {\n   ~MockDownloadController() override;\n \n   // DownloadControllerBase implementation.\n-  void CreateGETDownload(\n-      const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n-      bool must_download,\n-      const DownloadInfo& info) override;\n   void OnDownloadStarted(content::DownloadItem* download_item) override;\n   void StartContextMenuDownload(\n       const content::ContextMenuParams& params,""}","void MockDownloadController::CreateGETDownload(
","void MockDownloadController::CreateGETDownload(
    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
    bool must_download, const DownloadInfo& info) {
}
",C,,"    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
    bool must_download, const DownloadInfo& info) {
}
",,"@@ -17,11 +17,6 @@ MockDownloadController::MockDownloadController()
 
 MockDownloadController::~MockDownloadController() {}
 
-void MockDownloadController::CreateGETDownload(
-    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
-    bool must_download, const DownloadInfo& info) {
-}
-
 void MockDownloadController::OnDownloadStarted(
     content::DownloadItem* download_item) {
 }",Chrome,5fc08cfb098acce49344d2e89cc27c915903f81c,832443eec1ac13b31d044967e8e36469bc4d28c5,1,"void MockDownloadController::CreateGETDownload(
//flaw_line_below:
    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
//flaw_line_below:
    bool must_download, const DownloadInfo& info) {
//flaw_line_below:
}
"
8029,185765,,Remote,Not required,,CVE-2015-1300,https://www.cvedetails.com/cve/CVE-2015-1300/,CWE-254,Low,Partial,,,2015-09-03,5.0,"The FrameFetchContext::updateTimingInfoForIFrameNavigation function in core/loader/FrameFetchContext.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not properly restrict the availability of IFRAME Resource Timing API times, which allows remote attackers to obtain sensitive information via crafted JavaScript code that leverages a history.back call.",2016-12-21,+Info ,1,https://github.com/chromium/chromium/commit/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,"Use pdf compositor service for printing when OOPIF is enabled

When OOPIF is enabled (by site-per-process flag or
top-document-isolation feature), use the pdf compositor service for
converting PaintRecord to PDF on renderers.

In the future, this will make compositing PDF from multiple renderers
possible.

TBR=jzfeng@chromium.org
BUG=455764

Change-Id: I3c28f03f4358e4228239fe1a33384f85e7716e8f
Reviewed-on: https://chromium-review.googlesource.com/699765
Commit-Queue: Wei Li <weili@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Cr-Commit-Position: refs/heads/master@{#511616}",0,chrome/browser/printing/print_preview_dialog_controller.cc,"{""sha"": ""78193d61b9f59cdc78ed504e7a6939379d4f52d5"", ""filename"": ""chrome/browser/chrome_content_browser_manifest_overlay.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chrome_content_browser_manifest_overlay.json?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -44,6 +44,7 @@\n         \""local_state\"": [ \""pref_client\"" ],\n         \""nacl_broker\"": [ \""browser\"" ],\n         \""nacl_loader\"": [ \""browser\"" ],\n+        \""pdf_compositor\"": [ \""compositor\"" ],\n         \""profile_import\"": [ \""import\"" ],\n         \""profiling\"": [ \""profiling\"" ],\n         \""proxy_resolver\"": [ \""factory\"" ],""}<_**next**_>{""sha"": ""449ec7465b049d91941d3413bafcb8ee1904d417"", ""filename"": ""chrome/browser/printing/print_preview_dialog_controller.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_dialog_controller.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -29,6 +29,7 @@\n #include \""chrome/common/chrome_paths.h\""\n #include \""chrome/common/url_constants.h\""\n #include \""components/guest_view/browser/guest_view_base.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/web_modal/web_contents_modal_dialog_host.h\""\n #include \""content/public/browser/host_zoom_map.h\""\n #include \""content/public/browser/navigation_controller.h\""\n@@ -376,6 +377,7 @@ WebContents* PrintPreviewDialogController::CreatePrintPreviewDialog(\n   content::HostZoomMap::Get(preview_dialog->GetSiteInstance())\n       ->SetZoomLevelForHostAndScheme(print_url.scheme(), print_url.host(), 0);\n   PrintViewManager::CreateForWebContents(preview_dialog);\n+  CreateCompositeClientIfNeeded(preview_dialog, true /* for_preview */);\n   extensions::ChromeExtensionWebContentsObserver::CreateForWebContents(\n       preview_dialog);\n ""}<_**next**_>{""sha"": ""cda7ad2e7612be69842877448291d3be54317a64"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.cc"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 22, ""changes"": 116, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -14,18 +14,22 @@\n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/ref_counted_memory.h\""\n #include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n #include \""chrome/browser/browser_process.h\""\n #include \""chrome/browser/printing/print_job_manager.h\""\n #include \""chrome/browser/printing/print_preview_dialog_controller.h\""\n #include \""chrome/browser/printing/print_view_manager.h\""\n #include \""chrome/browser/printing/printer_query.h\""\n #include \""chrome/browser/ui/webui/print_preview/print_preview_ui.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""content/public/browser/web_ui.h\""\n #include \""printing/page_size_margins.h\""\n #include \""printing/print_job_constants.h\""\n+#include \""printing/print_settings.h\""\n \n using content::BrowserThread;\n using content::WebContents;\n@@ -69,7 +73,7 @@ scoped_refptr<base::RefCountedBytes> GetDataFromHandle(\n \n PrintPreviewMessageHandler::PrintPreviewMessageHandler(\n     WebContents* web_contents)\n-    : content::WebContentsObserver(web_contents) {\n+    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {\n   DCHECK(web_contents);\n }\n \n@@ -129,13 +133,21 @@ void PrintPreviewMessageHandler::OnDidPreviewPage(\n   if (!print_preview_ui)\n     return;\n \n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  DCHECK(data_bytes);\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    // Use utility process to convert skia metafile to pdf.\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,\n+                       weak_ptr_factory_.GetWeakPtr(), params.page_number,\n+                       params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewPageReady(\n+        page_number, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n@@ -152,18 +164,20 @@ void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n   if (!print_preview_ui)\n     return;\n \n-  // TODO(joth): This seems like a good match for using RefCountedStaticMemory\n-  // to avoid the memory copy, but the SetPrintPreviewData call chain below\n-  // needs updating to accept the RefCountedMemory* base class.\n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  if (!data_bytes || !data_bytes->size())\n-    return;\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnPreviewDataIsAvailable(\n-      params.expected_pages_count, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,\n+                       weak_ptr_factory_.GetWeakPtr(),\n+                       params.expected_pages_count, params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewDocumentReady(\n+        params.expected_pages_count, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnPrintPreviewFailed(int document_cookie) {\n@@ -214,6 +228,65 @@ void PrintPreviewMessageHandler::OnSetOptionsFromDocument(\n   print_preview_ui->OnSetOptionsFromDocument(params);\n }\n \n+void PrintPreviewMessageHandler::NotifyUIPreviewPageReady(\n+    int page_number,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  DCHECK(data_bytes);\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnDidPreviewPage(page_number, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::NotifyUIPreviewDocumentReady(\n+    int page_count,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  if (!data_bytes || !data_bytes->size())\n+    return;\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnPreviewDataIsAvailable(page_count, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfPageDone(\n+    int page_number,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewPageReady(\n+      page_number, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfDocumentDone(\n+    int page_count,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewDocumentReady(\n+      page_count, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n bool PrintPreviewMessageHandler::OnMessageReceived(\n     const IPC::Message& message,\n     content::RenderFrameHost* render_frame_host) {\n@@ -231,8 +304,7 @@ bool PrintPreviewMessageHandler::OnMessageReceived(\n   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,\n                         OnDidGetPreviewPageCount)\n-    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,\n-                        OnDidPreviewPage)\n+    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,\n                         OnMetafileReadyForPrinting)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,""}<_**next**_>{""sha"": ""71ca9d5bb1ee142ed3dbbfaa34cd8ab5d3018002"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.h"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,6 +7,9 @@\n \n #include \""base/compiler_specific.h\""\n #include \""base/macros.h\""\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/weak_ptr.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/web_contents_observer.h\""\n #include \""content/public/browser/web_contents_user_data.h\""\n \n@@ -70,6 +73,27 @@ class PrintPreviewMessageHandler\n   void OnSetOptionsFromDocument(\n       const PrintHostMsg_SetOptionsFromDocument_Params& params);\n \n+  void NotifyUIPreviewPageReady(\n+      int page_number,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+  void NotifyUIPreviewDocumentReady(\n+      int page_count,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+\n+  // Callbacks for pdf compositor client.\n+  void OnCompositePdfPageDone(int page_number,\n+                              int request_id,\n+                              mojom::PdfCompositor::Status status,\n+                              mojo::ScopedSharedBufferHandle handle);\n+  void OnCompositePdfDocumentDone(int page_count,\n+                                  int request_id,\n+                                  mojom::PdfCompositor::Status status,\n+                                  mojo::ScopedSharedBufferHandle handle);\n+\n+  base::WeakPtrFactory<PrintPreviewMessageHandler> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintPreviewMessageHandler);\n };\n ""}<_**next**_>{""sha"": ""f4fed9d2753dbd8b374dfb9b6f006cf51010d5cf"", ""filename"": ""chrome/browser/printing/print_view_manager_base.cc"", ""status"": ""modified"", ""additions"": 64, ""deletions"": 25, ""changes"": 89, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -11,6 +11,7 @@\n #include \""base/bind.h\""\n #include \""base/location.h\""\n #include \""base/memory/ptr_util.h\""\n+#include \""base/memory/shared_memory.h\""\n #include \""base/message_loop/message_loop.h\""\n #include \""base/run_loop.h\""\n #include \""base/single_thread_task_runner.h\""\n@@ -28,6 +29,8 @@\n #include \""chrome/common/pref_names.h\""\n #include \""chrome/grit/generated_resources.h\""\n #include \""components/prefs/pref_service.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/notification_details.h\""\n@@ -36,8 +39,10 @@\n #include \""content/public/browser/render_frame_host.h\""\n #include \""content/public/browser/render_view_host.h\""\n #include \""content/public/browser/web_contents.h\""\n+#include \""mojo/public/cpp/system/buffer.h\""\n #include \""printing/features/features.h\""\n #include \""printing/pdf_metafile_skia.h\""\n+#include \""printing/print_settings.h\""\n #include \""printing/printed_document.h\""\n #include \""ui/base/l10n/l10n_util.h\""\n \n@@ -78,7 +83,8 @@ PrintViewManagerBase::PrintViewManagerBase(content::WebContents* web_contents)\n #if !defined(OS_MACOSX)\n       expecting_first_page_(true),\n #endif\n-      queue_(g_browser_process->print_job_manager()->queue()) {\n+      queue_(g_browser_process->print_job_manager()->queue()),\n+      weak_ptr_factory_(this) {\n   DCHECK(queue_.get());\n   Profile* profile =\n       Profile::FromBrowserContext(web_contents->GetBrowserContext());\n@@ -127,8 +133,24 @@ void PrintViewManagerBase::OnDidGetPrintedPagesCount(int cookie,\n   OpportunisticallyCreatePrintJob(cookie);\n }\n \n+void PrintViewManagerBase::OnComposePdfDone(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+\n+  UpdateForPrintedPage(\n+      params, true,\n+      PrintCompositeClient::GetShmFromMojoHandle(std::move(handle)));\n+}\n+\n void PrintViewManagerBase::OnDidPrintPage(\n-  const PrintHostMsg_DidPrintPage_Params& params) {\n+    const PrintHostMsg_DidPrintPage_Params& params) {\n+  // Ready to composite. Starting a print job.\n   if (!OpportunisticallyCreatePrintJob(params.document_cookie))\n     return;\n \n@@ -154,8 +176,18 @@ void PrintViewManagerBase::OnDidPrintPage(\n       web_contents()->Stop();\n       return;\n     }\n+\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    if (IsOopifEnabled() && !client->for_preview() &&\n+        !document->settings().is_modifiable()) {\n+      client->DoComposite(\n+          params.metafile_data_handle, params.data_size,\n+          base::BindOnce(&PrintViewManagerBase::OnComposePdfDone,\n+                         weak_ptr_factory_.GetWeakPtr(), params));\n+      return;\n+    }\n     shared_buf =\n-        base::MakeUnique<base::SharedMemory>(params.metafile_data_handle, true);\n+        std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);\n     if (!shared_buf->Map(params.data_size)) {\n       NOTREACHED() << \""couldn't map\"";\n       web_contents()->Stop();\n@@ -170,22 +202,24 @@ void PrintViewManagerBase::OnDidPrintPage(\n     }\n   }\n \n-  std::unique_ptr<PdfMetafileSkia> metafile(\n-      new PdfMetafileSkia(SkiaDocumentType::PDF));\n-  if (metafile_must_be_valid) {\n-    if (!metafile->InitFromData(shared_buf->memory(), params.data_size)) {\n-      NOTREACHED() << \""Invalid metafile header\"";\n-      web_contents()->Stop();\n-      return;\n-    }\n-  }\n+  UpdateForPrintedPage(params, metafile_must_be_valid, std::move(shared_buf));\n+}\n+\n+void PrintViewManagerBase::UpdateForPrintedPage(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    bool has_valid_page_data,\n+    std::unique_ptr<base::SharedMemory> shared_buf) {\n+  PrintedDocument* document = print_job_->document();\n+  if (!document)\n+    return;\n \n #if defined(OS_WIN)\n   print_job_->AppendPrintedPage(params.page_number);\n-  if (metafile_must_be_valid) {\n-    scoped_refptr<base::RefCountedBytes> bytes = new base::RefCountedBytes(\n+  if (has_valid_page_data) {\n+    scoped_refptr<base::RefCountedBytes> bytes(new base::RefCountedBytes(\n         reinterpret_cast<const unsigned char*>(shared_buf->memory()),\n-        params.data_size);\n+        shared_buf->mapped_size()));\n+\n     document->DebugDumpData(bytes.get(), FILE_PATH_LITERAL(\"".pdf\""));\n \n     const auto& settings = document->settings();\n@@ -203,22 +237,27 @@ void PrintViewManagerBase::OnDidPrintPage(\n       // Update : The missing letters seem to have been caused by the same\n       // problem as https://crbug.com/659604 which was resolved. GDI printing\n       // seems to work with the fix for this bug applied.\n-      bool print_text_with_gdi = settings.print_text_with_gdi() &&\n-                                 !settings.printer_is_xps() &&\n-                                 base::FeatureList::IsEnabled(\n-                                     features::kGdiTextPrinting);\n+      bool print_text_with_gdi =\n+          settings.print_text_with_gdi() && !settings.printer_is_xps() &&\n+          base::FeatureList::IsEnabled(features::kGdiTextPrinting);\n       print_job_->StartPdfToEmfConversion(\n           bytes, params.page_size, params.content_area, print_text_with_gdi);\n     }\n   }\n #else\n+  std::unique_ptr<PdfMetafileSkia> metafile =\n+      std::make_unique<PdfMetafileSkia>(SkiaDocumentType::PDF);\n+  if (has_valid_page_data) {\n+    if (!metafile->InitFromData(shared_buf->memory(),\n+                                shared_buf->mapped_size())) {\n+      NOTREACHED() << \""Invalid metafile header\"";\n+      web_contents()->Stop();\n+      return;\n+    }\n+  }\n+\n   // Update the rendered document. It will send notifications to the listener.\n-  document->SetPage(params.page_number,\n-                    std::move(metafile),\n-#if defined(OS_WIN)\n-                    0.0f /* dummy shrink_factor */,\n-#endif\n-                    params.page_size,\n+  document->SetPage(params.page_number, std::move(metafile), params.page_size,\n                     params.content_area);\n \n   ShouldQuitFromInnerMessageLoop();""}<_**next**_>{""sha"": ""e9706e34f8c96f224196aa8ffc993b44a9247cf9"", ""filename"": ""chrome/browser/printing/print_view_manager_base.h"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 1, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -9,16 +9,23 @@\n \n #include \""base/macros.h\""\n #include \""base/memory/ref_counted.h\""\n+#include \""base/memory/weak_ptr.h\""\n #include \""base/strings/string16.h\""\n #include \""build/build_config.h\""\n #include \""components/prefs/pref_member.h\""\n #include \""components/printing/browser/print_manager.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/notification_observer.h\""\n #include \""content/public/browser/notification_registrar.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n #include \""printing/features/features.h\""\n \n struct PrintHostMsg_DidPrintPage_Params;\n \n+namespace base {\n+class SharedMemory;\n+}\n+\n namespace content {\n class RenderFrameHost;\n }\n@@ -82,9 +89,19 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   // IPC Message handlers.\n   void OnDidGetPrintedPagesCount(int cookie, int number_pages) override;\n-  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n   void OnPrintingFailed(int cookie) override;\n   void OnShowInvalidPrinterSettingsError();\n+  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n+\n+  // Handle extra tasks once a page or doc is printed.\n+  void UpdateForPrintedPage(const PrintHostMsg_DidPrintPage_Params& params,\n+                            bool has_valid_page_data,\n+                            std::unique_ptr<base::SharedMemory> shared_buf);\n+\n+  // IPC message handlers for service.\n+  void OnComposePdfDone(const PrintHostMsg_DidPrintPage_Params& params,\n+                        mojom::PdfCompositor::Status status,\n+                        mojo::ScopedSharedBufferHandle handle);\n \n   // Processes a NOTIFY_PRINT_JOB_EVENT notification.\n   void OnNotifyPrintJobEvent(const JobEventDetails& event_details);\n@@ -163,6 +180,8 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   scoped_refptr<printing::PrintQueriesQueue> queue_;\n \n+  base::WeakPtrFactory<PrintViewManagerBase> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintViewManagerBase);\n };\n ""}<_**next**_>{""sha"": ""3560d1c793977a5c2fe67253c9cf9509dbe596a1"", ""filename"": ""chrome/browser/printing/printing_init.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/printing_init.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""chrome/browser/printing/printing_init.h\""\n \n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""printing/features/features.h\""\n \n@@ -23,6 +24,7 @@ void InitializePrinting(content::WebContents* web_contents) {\n #else\n   printing::PrintViewManagerBasic::CreateForWebContents(web_contents);\n #endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)\n+  CreateCompositeClientIfNeeded(web_contents, false /* for_preview */);\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""84901e64744b737a1810f2e3c513498bfea57fb6"", ""filename"": ""chrome/browser/ui/BUILD.gn"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3475,7 +3475,10 @@ split_static_library(\""ui\"") {\n   }\n \n   if (enable_basic_printing || enable_print_preview) {\n-    deps += [ \""//printing\"" ]\n+    deps += [\n+      \""//components/printing/browser\"",\n+      \""//printing\"",\n+    ]\n     if (use_cups) {\n       configs += [ \""//printing:cups\"" ]\n     }""}<_**next**_>{""sha"": ""20c22c6758f1b3353627d510ee4cfe71ef980b8b"", ""filename"": ""chrome/utility/chrome_content_utility_client.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/utility/chrome_content_utility_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -73,7 +73,7 @@\n \n #if BUILDFLAG(ENABLE_PRINTING)\n #include \""chrome/common/chrome_content_client.h\""\n-#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""  // nogncheck\n #include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""  // nogncheck\n #endif\n ""}<_**next**_>{""sha"": ""154e773645fadb49d560d3b3aa8cb4e1f3511e43"", ""filename"": ""components/printing/browser/BUILD.gn"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,8 @@\n \n static_library(\""browser\"") {\n   sources = [\n+    \""print_composite_client.cc\"",\n+    \""print_composite_client.h\"",\n     \""print_manager.cc\"",\n     \""print_manager.h\"",\n     \""print_manager_utils.cc\"",\n@@ -17,6 +19,9 @@ static_library(\""browser\"") {\n   deps = [\n     \""//base\"",\n     \""//components/printing/common\"",\n+    \""//components/printing/service/public/cpp:client\"",\n+    \""//mojo/public/cpp/system:system\"",\n     \""//printing\"",\n+    \""//services/service_manager/public/cpp\"",\n   ]\n }""}<_**next**_>{""sha"": ""f67625c944f981351fc84c69ea9c9f156b285839"", ""filename"": ""components/printing/browser/DEPS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/DEPS?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -1,3 +1,6 @@\n include_rules = [\n+  \""+components/printing/service/public/cpp\"",\n   \""+content/public/browser\"",\n+  \""+mojo/public/cpp/system\"",\n+  \""+services/service_manager/public/cpp\"",\n ]""}<_**next**_>{""sha"": ""e105223f7f9335c2aec939ac0fe4b4a5dbdfa97b"", ""filename"": ""components/printing/browser/print_composite_client.cc"", ""status"": ""added"", ""additions"": 79, ""deletions"": 0, ""changes"": 79, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,79 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""components/printing/browser/print_composite_client.h\""\n+\n+#include <memory>\n+#include <utility>\n+\n+#include \""base/threading/thread_task_runner_handle.h\""\n+#include \""content/public/browser/browser_thread.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n+#include \""services/service_manager/public/cpp/connector.h\""\n+\n+DEFINE_WEB_CONTENTS_USER_DATA_KEY(printing::PrintCompositeClient);\n+\n+namespace printing {\n+\n+PrintCompositeClient::PrintCompositeClient(content::WebContents* web_contents)\n+    : for_preview_(false) {}\n+\n+PrintCompositeClient::~PrintCompositeClient() {}\n+\n+void PrintCompositeClient::CreateConnectorRequest() {\n+  connector_ = service_manager::Connector::Create(&connector_request_);\n+  content::ServiceManagerConnection::GetForProcess()\n+      ->GetConnector()\n+      ->BindConnectorRequest(std::move(connector_request_));\n+}\n+\n+void PrintCompositeClient::DoComposite(\n+    base::SharedMemoryHandle handle,\n+    uint32_t data_size,\n+    mojom::PdfCompositor::CompositePdfCallback callback) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  DCHECK(data_size);\n+\n+  if (!connector_)\n+    CreateConnectorRequest();\n+  Composite(connector_.get(), handle, data_size, std::move(callback),\n+            base::ThreadTaskRunnerHandle::Get());\n+}\n+\n+std::unique_ptr<base::SharedMemory> PrintCompositeClient::GetShmFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  base::SharedMemoryHandle memory_handle;\n+  size_t memory_size = 0;\n+  bool read_only_flag = false;\n+\n+  const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n+      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n+  if (result != MOJO_RESULT_OK)\n+    return nullptr;\n+  DCHECK_GT(memory_size, 0u);\n+\n+  std::unique_ptr<base::SharedMemory> shm =\n+      base::MakeUnique<base::SharedMemory>(memory_handle, true /* read_only */);\n+  if (!shm->Map(memory_size)) {\n+    DLOG(ERROR) << \""Map shared memory failed.\"";\n+    return nullptr;\n+  }\n+  return shm;\n+}\n+\n+scoped_refptr<base::RefCountedBytes>\n+PrintCompositeClient::GetDataFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  std::unique_ptr<base::SharedMemory> shm =\n+      GetShmFromMojoHandle(std::move(handle));\n+  if (!shm)\n+    return nullptr;\n+\n+  return base::MakeRefCounted<base::RefCountedBytes>(\n+      reinterpret_cast<const unsigned char*>(shm->memory()),\n+      shm->mapped_size());\n+}\n+\n+}  // namespace printing""}<_**next**_>{""sha"": ""d63b34123520f5d66dbafe7c878c84f77725a91c"", ""filename"": ""components/printing/browser/print_composite_client.h"", ""status"": ""added"", ""additions"": 49, ""deletions"": 0, ""changes"": 49, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,49 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+#define COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_client.h\""\n+#include \""content/public/browser/web_contents_observer.h\""\n+#include \""content/public/browser/web_contents_user_data.h\""\n+\n+namespace printing {\n+\n+class PrintCompositeClient\n+    : public PdfCompositorClient,\n+      public content::WebContentsUserData<PrintCompositeClient> {\n+ public:\n+  explicit PrintCompositeClient(content::WebContents* web_contents);\n+  ~PrintCompositeClient() override;\n+\n+  void DoComposite(base::SharedMemoryHandle handle,\n+                   uint32_t data_size,\n+                   mojom::PdfCompositor::CompositePdfCallback callback);\n+\n+  void set_for_preview(bool for_preview) { for_preview_ = for_preview; }\n+  bool for_preview() const { return for_preview_; }\n+\n+  // Utility functions.\n+  static std::unique_ptr<base::SharedMemory> GetShmFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+  static scoped_refptr<base::RefCountedBytes> GetDataFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+\n+ private:\n+  void CreateConnectorRequest();\n+\n+  service_manager::mojom::ConnectorRequest connector_request_;\n+  std::unique_ptr<service_manager::Connector> connector_;\n+  bool for_preview_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(PrintCompositeClient);\n+};\n+\n+}  // namespace printing\n+\n+#endif  // COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_""}<_**next**_>{""sha"": ""844fcf5bd23513e52fa2a2eb7d9d958762e11ddf"", ""filename"": ""components/printing/browser/print_manager_utils.cc"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 1, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3,11 +3,43 @@\n // found in the LICENSE file.\n \n #include \""components/printing/browser/print_manager_utils.h\""\n+\n+#include \""base/command_line.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n #include \""components/printing/common/print_messages.h\""\n+#include \""content/public/common/content_features.h\""\n+#include \""content/public/common/content_switches.h\""\n #include \""printing/print_settings.h\""\n \n namespace printing {\n \n+// A temporary flag which makes supporting both paths for OOPIF and non-OOPIF\n+// printing easier.\n+static bool g_oopif_enabled = false;\n+\n+void SetOopifEnabled() {\n+  g_oopif_enabled = true;\n+}\n+\n+bool IsOopifEnabled() {\n+  return g_oopif_enabled;\n+}\n+\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview) {\n+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n+          switches::kSitePerProcess) ||\n+      base::FeatureList::IsEnabled(features::kTopDocumentIsolation)) {\n+    // For cases need to support OOPIFs.\n+    PrintCompositeClient::CreateForWebContents(web_contents);\n+    if (for_preview) {\n+      PrintCompositeClient::FromWebContents(web_contents)\n+          ->set_for_preview(true);\n+    }\n+    SetOopifEnabled();\n+  }\n+}\n+\n void RenderParamsFromPrintSettings(const PrintSettings& settings,\n                                    PrintMsg_Print_Params* params) {\n   params->page_size = settings.page_setup_device_units().physical_size();\n@@ -32,7 +64,8 @@ void RenderParamsFromPrintSettings(const PrintSettings& settings,\n   params->display_header_footer = settings.display_header_footer();\n   params->title = settings.title();\n   params->url = settings.url();\n-  params->printed_doc_type = SkiaDocumentType::PDF;\n+  params->printed_doc_type =\n+      IsOopifEnabled() ? SkiaDocumentType::MSKP : SkiaDocumentType::PDF;\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""5b2b62a7dbf5599fbb51940906b2ed4697c5d0a2"", ""filename"": ""components/printing/browser/print_manager_utils.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,10 +7,22 @@\n \n struct PrintMsg_Print_Params;\n \n+namespace content {\n+class WebContents;\n+}\n+\n namespace printing {\n \n class PrintSettings;\n \n+void SetOopifEnabled(bool enabled);\n+bool IsOopifEnabled();\n+\n+// Check on the current feature settings to decide whether we need to\n+// create a PDF compositor client for this |web_contents|.\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview);\n+\n // Converts given settings to Print_Params and stores them in the output\n // parameter |params|.\n void RenderParamsFromPrintSettings(const PrintSettings& settings,""}<_**next**_>{""sha"": ""231fe97661ab55076dcd33cbc9dc12eeb29cbe83"", ""filename"": ""headless/lib/browser/headless_web_contents_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/headless/lib/browser/headless_web_contents_impl.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -322,6 +322,7 @@ HeadlessWebContentsImpl::HeadlessWebContentsImpl(\n       weak_ptr_factory_(this) {\n #if BUILDFLAG(ENABLE_BASIC_PRINTING) && !defined(CHROME_MULTIPLE_DLL_CHILD)\n   HeadlessPrintManager::CreateForWebContents(web_contents);\n+// TODO(weili): Add support for printing OOPIFs.\n #endif\n   web_contents->GetMutableRendererPrefs()->accept_languages =\n       browser_context->options()->accept_language();""}","WebContents* PrintPreviewDialogController::CreatePrintPreviewDialog(
    WebContents* initiator) {
  base::AutoReset<bool> auto_reset(&is_creating_print_preview_dialog_, true);

  ConstrainedWebDialogDelegate* web_dialog_delegate =
      ShowConstrainedWebDialog(initiator->GetBrowserContext(),
                               new PrintPreviewDialogDelegate(initiator),
                               initiator);

  WebContents* preview_dialog = web_dialog_delegate->GetWebContents();

  GURL print_url(chrome::kChromeUIPrintURL);
   content::HostZoomMap::Get(preview_dialog->GetSiteInstance())
       ->SetZoomLevelForHostAndScheme(print_url.scheme(), print_url.host(), 0);
   PrintViewManager::CreateForWebContents(preview_dialog);
  CreateCompositeClientIfNeeded(preview_dialog, true /* for_preview */);
   extensions::ChromeExtensionWebContentsObserver::CreateForWebContents(
       preview_dialog);
 
  preview_dialog_map_[preview_dialog] = initiator;
  waiting_for_new_preview_page_ = true;

  task_manager::WebContentsTags::CreateForPrintingContents(preview_dialog);

  AddObservers(initiator);
  AddObservers(preview_dialog);

  return preview_dialog;
}
","WebContents* PrintPreviewDialogController::CreatePrintPreviewDialog(
    WebContents* initiator) {
  base::AutoReset<bool> auto_reset(&is_creating_print_preview_dialog_, true);

  ConstrainedWebDialogDelegate* web_dialog_delegate =
      ShowConstrainedWebDialog(initiator->GetBrowserContext(),
                               new PrintPreviewDialogDelegate(initiator),
                               initiator);

  WebContents* preview_dialog = web_dialog_delegate->GetWebContents();

  GURL print_url(chrome::kChromeUIPrintURL);
   content::HostZoomMap::Get(preview_dialog->GetSiteInstance())
       ->SetZoomLevelForHostAndScheme(print_url.scheme(), print_url.host(), 0);
   PrintViewManager::CreateForWebContents(preview_dialog);
   extensions::ChromeExtensionWebContentsObserver::CreateForWebContents(
       preview_dialog);
 
  preview_dialog_map_[preview_dialog] = initiator;
  waiting_for_new_preview_page_ = true;

  task_manager::WebContentsTags::CreateForPrintingContents(preview_dialog);

  AddObservers(initiator);
  AddObservers(preview_dialog);

  return preview_dialog;
}
",C,"  CreateCompositeClientIfNeeded(preview_dialog, true /* for_preview */);
",,,"@@ -29,6 +29,7 @@
 #include ""chrome/common/chrome_paths.h""
 #include ""chrome/common/url_constants.h""
 #include ""components/guest_view/browser/guest_view_base.h""
+#include ""components/printing/browser/print_manager_utils.h""
 #include ""components/web_modal/web_contents_modal_dialog_host.h""
 #include ""content/public/browser/host_zoom_map.h""
 #include ""content/public/browser/navigation_controller.h""
@@ -376,6 +377,7 @@ WebContents* PrintPreviewDialogController::CreatePrintPreviewDialog(
   content::HostZoomMap::Get(preview_dialog->GetSiteInstance())
       ->SetZoomLevelForHostAndScheme(print_url.scheme(), print_url.host(), 0);
   PrintViewManager::CreateForWebContents(preview_dialog);
+  CreateCompositeClientIfNeeded(preview_dialog, true /* for_preview */);
   extensions::ChromeExtensionWebContentsObserver::CreateForWebContents(
       preview_dialog);
 ",Chrome,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,896aab1971cb86907e97ea09726b3872fbfde09a,1,"WebContents* PrintPreviewDialogController::CreatePrintPreviewDialog(
    WebContents* initiator) {
  base::AutoReset<bool> auto_reset(&is_creating_print_preview_dialog_, true);

  // The dialog delegates are deleted when the dialog is closed.
  ConstrainedWebDialogDelegate* web_dialog_delegate =
      ShowConstrainedWebDialog(initiator->GetBrowserContext(),
                               new PrintPreviewDialogDelegate(initiator),
                               initiator);

  WebContents* preview_dialog = web_dialog_delegate->GetWebContents();

  // Clear the zoom level for the print preview dialog so it isn't affected by
  // the default zoom level. This also controls the zoom level of the OOP PDF
  // extension when iframed by the print preview dialog.
  GURL print_url(chrome::kChromeUIPrintURL);
   content::HostZoomMap::Get(preview_dialog->GetSiteInstance())
       ->SetZoomLevelForHostAndScheme(print_url.scheme(), print_url.host(), 0);
   PrintViewManager::CreateForWebContents(preview_dialog);
//fix_flaw_line_below:
//  CreateCompositeClientIfNeeded(preview_dialog, true /* for_preview */);
   extensions::ChromeExtensionWebContentsObserver::CreateForWebContents(
       preview_dialog);
 
  // Add an entry to the map.
  preview_dialog_map_[preview_dialog] = initiator;
  waiting_for_new_preview_page_ = true;

  // Make the print preview WebContents show up in the task manager.
  task_manager::WebContentsTags::CreateForPrintingContents(preview_dialog);

  AddObservers(initiator);
  AddObservers(preview_dialog);

  return preview_dialog;
}
"
8030,185766,,Remote,Not required,,CVE-2015-1300,https://www.cvedetails.com/cve/CVE-2015-1300/,CWE-254,Low,Partial,,,2015-09-03,5.0,"The FrameFetchContext::updateTimingInfoForIFrameNavigation function in core/loader/FrameFetchContext.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not properly restrict the availability of IFRAME Resource Timing API times, which allows remote attackers to obtain sensitive information via crafted JavaScript code that leverages a history.back call.",2016-12-21,+Info ,15,https://github.com/chromium/chromium/commit/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,"Use pdf compositor service for printing when OOPIF is enabled

When OOPIF is enabled (by site-per-process flag or
top-document-isolation feature), use the pdf compositor service for
converting PaintRecord to PDF on renderers.

In the future, this will make compositing PDF from multiple renderers
possible.

TBR=jzfeng@chromium.org
BUG=455764

Change-Id: I3c28f03f4358e4228239fe1a33384f85e7716e8f
Reviewed-on: https://chromium-review.googlesource.com/699765
Commit-Queue: Wei Li <weili@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Cr-Commit-Position: refs/heads/master@{#511616}",6,chrome/browser/printing/print_preview_message_handler.cc,"{""sha"": ""78193d61b9f59cdc78ed504e7a6939379d4f52d5"", ""filename"": ""chrome/browser/chrome_content_browser_manifest_overlay.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chrome_content_browser_manifest_overlay.json?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -44,6 +44,7 @@\n         \""local_state\"": [ \""pref_client\"" ],\n         \""nacl_broker\"": [ \""browser\"" ],\n         \""nacl_loader\"": [ \""browser\"" ],\n+        \""pdf_compositor\"": [ \""compositor\"" ],\n         \""profile_import\"": [ \""import\"" ],\n         \""profiling\"": [ \""profiling\"" ],\n         \""proxy_resolver\"": [ \""factory\"" ],""}<_**next**_>{""sha"": ""449ec7465b049d91941d3413bafcb8ee1904d417"", ""filename"": ""chrome/browser/printing/print_preview_dialog_controller.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_dialog_controller.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -29,6 +29,7 @@\n #include \""chrome/common/chrome_paths.h\""\n #include \""chrome/common/url_constants.h\""\n #include \""components/guest_view/browser/guest_view_base.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/web_modal/web_contents_modal_dialog_host.h\""\n #include \""content/public/browser/host_zoom_map.h\""\n #include \""content/public/browser/navigation_controller.h\""\n@@ -376,6 +377,7 @@ WebContents* PrintPreviewDialogController::CreatePrintPreviewDialog(\n   content::HostZoomMap::Get(preview_dialog->GetSiteInstance())\n       ->SetZoomLevelForHostAndScheme(print_url.scheme(), print_url.host(), 0);\n   PrintViewManager::CreateForWebContents(preview_dialog);\n+  CreateCompositeClientIfNeeded(preview_dialog, true /* for_preview */);\n   extensions::ChromeExtensionWebContentsObserver::CreateForWebContents(\n       preview_dialog);\n ""}<_**next**_>{""sha"": ""cda7ad2e7612be69842877448291d3be54317a64"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.cc"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 22, ""changes"": 116, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -14,18 +14,22 @@\n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/ref_counted_memory.h\""\n #include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n #include \""chrome/browser/browser_process.h\""\n #include \""chrome/browser/printing/print_job_manager.h\""\n #include \""chrome/browser/printing/print_preview_dialog_controller.h\""\n #include \""chrome/browser/printing/print_view_manager.h\""\n #include \""chrome/browser/printing/printer_query.h\""\n #include \""chrome/browser/ui/webui/print_preview/print_preview_ui.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""content/public/browser/web_ui.h\""\n #include \""printing/page_size_margins.h\""\n #include \""printing/print_job_constants.h\""\n+#include \""printing/print_settings.h\""\n \n using content::BrowserThread;\n using content::WebContents;\n@@ -69,7 +73,7 @@ scoped_refptr<base::RefCountedBytes> GetDataFromHandle(\n \n PrintPreviewMessageHandler::PrintPreviewMessageHandler(\n     WebContents* web_contents)\n-    : content::WebContentsObserver(web_contents) {\n+    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {\n   DCHECK(web_contents);\n }\n \n@@ -129,13 +133,21 @@ void PrintPreviewMessageHandler::OnDidPreviewPage(\n   if (!print_preview_ui)\n     return;\n \n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  DCHECK(data_bytes);\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    // Use utility process to convert skia metafile to pdf.\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,\n+                       weak_ptr_factory_.GetWeakPtr(), params.page_number,\n+                       params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewPageReady(\n+        page_number, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n@@ -152,18 +164,20 @@ void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n   if (!print_preview_ui)\n     return;\n \n-  // TODO(joth): This seems like a good match for using RefCountedStaticMemory\n-  // to avoid the memory copy, but the SetPrintPreviewData call chain below\n-  // needs updating to accept the RefCountedMemory* base class.\n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  if (!data_bytes || !data_bytes->size())\n-    return;\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnPreviewDataIsAvailable(\n-      params.expected_pages_count, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,\n+                       weak_ptr_factory_.GetWeakPtr(),\n+                       params.expected_pages_count, params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewDocumentReady(\n+        params.expected_pages_count, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnPrintPreviewFailed(int document_cookie) {\n@@ -214,6 +228,65 @@ void PrintPreviewMessageHandler::OnSetOptionsFromDocument(\n   print_preview_ui->OnSetOptionsFromDocument(params);\n }\n \n+void PrintPreviewMessageHandler::NotifyUIPreviewPageReady(\n+    int page_number,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  DCHECK(data_bytes);\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnDidPreviewPage(page_number, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::NotifyUIPreviewDocumentReady(\n+    int page_count,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  if (!data_bytes || !data_bytes->size())\n+    return;\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnPreviewDataIsAvailable(page_count, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfPageDone(\n+    int page_number,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewPageReady(\n+      page_number, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfDocumentDone(\n+    int page_count,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewDocumentReady(\n+      page_count, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n bool PrintPreviewMessageHandler::OnMessageReceived(\n     const IPC::Message& message,\n     content::RenderFrameHost* render_frame_host) {\n@@ -231,8 +304,7 @@ bool PrintPreviewMessageHandler::OnMessageReceived(\n   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,\n                         OnDidGetPreviewPageCount)\n-    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,\n-                        OnDidPreviewPage)\n+    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,\n                         OnMetafileReadyForPrinting)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,""}<_**next**_>{""sha"": ""71ca9d5bb1ee142ed3dbbfaa34cd8ab5d3018002"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.h"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,6 +7,9 @@\n \n #include \""base/compiler_specific.h\""\n #include \""base/macros.h\""\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/weak_ptr.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/web_contents_observer.h\""\n #include \""content/public/browser/web_contents_user_data.h\""\n \n@@ -70,6 +73,27 @@ class PrintPreviewMessageHandler\n   void OnSetOptionsFromDocument(\n       const PrintHostMsg_SetOptionsFromDocument_Params& params);\n \n+  void NotifyUIPreviewPageReady(\n+      int page_number,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+  void NotifyUIPreviewDocumentReady(\n+      int page_count,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+\n+  // Callbacks for pdf compositor client.\n+  void OnCompositePdfPageDone(int page_number,\n+                              int request_id,\n+                              mojom::PdfCompositor::Status status,\n+                              mojo::ScopedSharedBufferHandle handle);\n+  void OnCompositePdfDocumentDone(int page_count,\n+                                  int request_id,\n+                                  mojom::PdfCompositor::Status status,\n+                                  mojo::ScopedSharedBufferHandle handle);\n+\n+  base::WeakPtrFactory<PrintPreviewMessageHandler> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintPreviewMessageHandler);\n };\n ""}<_**next**_>{""sha"": ""f4fed9d2753dbd8b374dfb9b6f006cf51010d5cf"", ""filename"": ""chrome/browser/printing/print_view_manager_base.cc"", ""status"": ""modified"", ""additions"": 64, ""deletions"": 25, ""changes"": 89, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -11,6 +11,7 @@\n #include \""base/bind.h\""\n #include \""base/location.h\""\n #include \""base/memory/ptr_util.h\""\n+#include \""base/memory/shared_memory.h\""\n #include \""base/message_loop/message_loop.h\""\n #include \""base/run_loop.h\""\n #include \""base/single_thread_task_runner.h\""\n@@ -28,6 +29,8 @@\n #include \""chrome/common/pref_names.h\""\n #include \""chrome/grit/generated_resources.h\""\n #include \""components/prefs/pref_service.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/notification_details.h\""\n@@ -36,8 +39,10 @@\n #include \""content/public/browser/render_frame_host.h\""\n #include \""content/public/browser/render_view_host.h\""\n #include \""content/public/browser/web_contents.h\""\n+#include \""mojo/public/cpp/system/buffer.h\""\n #include \""printing/features/features.h\""\n #include \""printing/pdf_metafile_skia.h\""\n+#include \""printing/print_settings.h\""\n #include \""printing/printed_document.h\""\n #include \""ui/base/l10n/l10n_util.h\""\n \n@@ -78,7 +83,8 @@ PrintViewManagerBase::PrintViewManagerBase(content::WebContents* web_contents)\n #if !defined(OS_MACOSX)\n       expecting_first_page_(true),\n #endif\n-      queue_(g_browser_process->print_job_manager()->queue()) {\n+      queue_(g_browser_process->print_job_manager()->queue()),\n+      weak_ptr_factory_(this) {\n   DCHECK(queue_.get());\n   Profile* profile =\n       Profile::FromBrowserContext(web_contents->GetBrowserContext());\n@@ -127,8 +133,24 @@ void PrintViewManagerBase::OnDidGetPrintedPagesCount(int cookie,\n   OpportunisticallyCreatePrintJob(cookie);\n }\n \n+void PrintViewManagerBase::OnComposePdfDone(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+\n+  UpdateForPrintedPage(\n+      params, true,\n+      PrintCompositeClient::GetShmFromMojoHandle(std::move(handle)));\n+}\n+\n void PrintViewManagerBase::OnDidPrintPage(\n-  const PrintHostMsg_DidPrintPage_Params& params) {\n+    const PrintHostMsg_DidPrintPage_Params& params) {\n+  // Ready to composite. Starting a print job.\n   if (!OpportunisticallyCreatePrintJob(params.document_cookie))\n     return;\n \n@@ -154,8 +176,18 @@ void PrintViewManagerBase::OnDidPrintPage(\n       web_contents()->Stop();\n       return;\n     }\n+\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    if (IsOopifEnabled() && !client->for_preview() &&\n+        !document->settings().is_modifiable()) {\n+      client->DoComposite(\n+          params.metafile_data_handle, params.data_size,\n+          base::BindOnce(&PrintViewManagerBase::OnComposePdfDone,\n+                         weak_ptr_factory_.GetWeakPtr(), params));\n+      return;\n+    }\n     shared_buf =\n-        base::MakeUnique<base::SharedMemory>(params.metafile_data_handle, true);\n+        std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);\n     if (!shared_buf->Map(params.data_size)) {\n       NOTREACHED() << \""couldn't map\"";\n       web_contents()->Stop();\n@@ -170,22 +202,24 @@ void PrintViewManagerBase::OnDidPrintPage(\n     }\n   }\n \n-  std::unique_ptr<PdfMetafileSkia> metafile(\n-      new PdfMetafileSkia(SkiaDocumentType::PDF));\n-  if (metafile_must_be_valid) {\n-    if (!metafile->InitFromData(shared_buf->memory(), params.data_size)) {\n-      NOTREACHED() << \""Invalid metafile header\"";\n-      web_contents()->Stop();\n-      return;\n-    }\n-  }\n+  UpdateForPrintedPage(params, metafile_must_be_valid, std::move(shared_buf));\n+}\n+\n+void PrintViewManagerBase::UpdateForPrintedPage(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    bool has_valid_page_data,\n+    std::unique_ptr<base::SharedMemory> shared_buf) {\n+  PrintedDocument* document = print_job_->document();\n+  if (!document)\n+    return;\n \n #if defined(OS_WIN)\n   print_job_->AppendPrintedPage(params.page_number);\n-  if (metafile_must_be_valid) {\n-    scoped_refptr<base::RefCountedBytes> bytes = new base::RefCountedBytes(\n+  if (has_valid_page_data) {\n+    scoped_refptr<base::RefCountedBytes> bytes(new base::RefCountedBytes(\n         reinterpret_cast<const unsigned char*>(shared_buf->memory()),\n-        params.data_size);\n+        shared_buf->mapped_size()));\n+\n     document->DebugDumpData(bytes.get(), FILE_PATH_LITERAL(\"".pdf\""));\n \n     const auto& settings = document->settings();\n@@ -203,22 +237,27 @@ void PrintViewManagerBase::OnDidPrintPage(\n       // Update : The missing letters seem to have been caused by the same\n       // problem as https://crbug.com/659604 which was resolved. GDI printing\n       // seems to work with the fix for this bug applied.\n-      bool print_text_with_gdi = settings.print_text_with_gdi() &&\n-                                 !settings.printer_is_xps() &&\n-                                 base::FeatureList::IsEnabled(\n-                                     features::kGdiTextPrinting);\n+      bool print_text_with_gdi =\n+          settings.print_text_with_gdi() && !settings.printer_is_xps() &&\n+          base::FeatureList::IsEnabled(features::kGdiTextPrinting);\n       print_job_->StartPdfToEmfConversion(\n           bytes, params.page_size, params.content_area, print_text_with_gdi);\n     }\n   }\n #else\n+  std::unique_ptr<PdfMetafileSkia> metafile =\n+      std::make_unique<PdfMetafileSkia>(SkiaDocumentType::PDF);\n+  if (has_valid_page_data) {\n+    if (!metafile->InitFromData(shared_buf->memory(),\n+                                shared_buf->mapped_size())) {\n+      NOTREACHED() << \""Invalid metafile header\"";\n+      web_contents()->Stop();\n+      return;\n+    }\n+  }\n+\n   // Update the rendered document. It will send notifications to the listener.\n-  document->SetPage(params.page_number,\n-                    std::move(metafile),\n-#if defined(OS_WIN)\n-                    0.0f /* dummy shrink_factor */,\n-#endif\n-                    params.page_size,\n+  document->SetPage(params.page_number, std::move(metafile), params.page_size,\n                     params.content_area);\n \n   ShouldQuitFromInnerMessageLoop();""}<_**next**_>{""sha"": ""e9706e34f8c96f224196aa8ffc993b44a9247cf9"", ""filename"": ""chrome/browser/printing/print_view_manager_base.h"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 1, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -9,16 +9,23 @@\n \n #include \""base/macros.h\""\n #include \""base/memory/ref_counted.h\""\n+#include \""base/memory/weak_ptr.h\""\n #include \""base/strings/string16.h\""\n #include \""build/build_config.h\""\n #include \""components/prefs/pref_member.h\""\n #include \""components/printing/browser/print_manager.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/notification_observer.h\""\n #include \""content/public/browser/notification_registrar.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n #include \""printing/features/features.h\""\n \n struct PrintHostMsg_DidPrintPage_Params;\n \n+namespace base {\n+class SharedMemory;\n+}\n+\n namespace content {\n class RenderFrameHost;\n }\n@@ -82,9 +89,19 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   // IPC Message handlers.\n   void OnDidGetPrintedPagesCount(int cookie, int number_pages) override;\n-  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n   void OnPrintingFailed(int cookie) override;\n   void OnShowInvalidPrinterSettingsError();\n+  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n+\n+  // Handle extra tasks once a page or doc is printed.\n+  void UpdateForPrintedPage(const PrintHostMsg_DidPrintPage_Params& params,\n+                            bool has_valid_page_data,\n+                            std::unique_ptr<base::SharedMemory> shared_buf);\n+\n+  // IPC message handlers for service.\n+  void OnComposePdfDone(const PrintHostMsg_DidPrintPage_Params& params,\n+                        mojom::PdfCompositor::Status status,\n+                        mojo::ScopedSharedBufferHandle handle);\n \n   // Processes a NOTIFY_PRINT_JOB_EVENT notification.\n   void OnNotifyPrintJobEvent(const JobEventDetails& event_details);\n@@ -163,6 +180,8 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   scoped_refptr<printing::PrintQueriesQueue> queue_;\n \n+  base::WeakPtrFactory<PrintViewManagerBase> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintViewManagerBase);\n };\n ""}<_**next**_>{""sha"": ""3560d1c793977a5c2fe67253c9cf9509dbe596a1"", ""filename"": ""chrome/browser/printing/printing_init.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/printing_init.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""chrome/browser/printing/printing_init.h\""\n \n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""printing/features/features.h\""\n \n@@ -23,6 +24,7 @@ void InitializePrinting(content::WebContents* web_contents) {\n #else\n   printing::PrintViewManagerBasic::CreateForWebContents(web_contents);\n #endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)\n+  CreateCompositeClientIfNeeded(web_contents, false /* for_preview */);\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""84901e64744b737a1810f2e3c513498bfea57fb6"", ""filename"": ""chrome/browser/ui/BUILD.gn"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3475,7 +3475,10 @@ split_static_library(\""ui\"") {\n   }\n \n   if (enable_basic_printing || enable_print_preview) {\n-    deps += [ \""//printing\"" ]\n+    deps += [\n+      \""//components/printing/browser\"",\n+      \""//printing\"",\n+    ]\n     if (use_cups) {\n       configs += [ \""//printing:cups\"" ]\n     }""}<_**next**_>{""sha"": ""20c22c6758f1b3353627d510ee4cfe71ef980b8b"", ""filename"": ""chrome/utility/chrome_content_utility_client.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/utility/chrome_content_utility_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -73,7 +73,7 @@\n \n #if BUILDFLAG(ENABLE_PRINTING)\n #include \""chrome/common/chrome_content_client.h\""\n-#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""  // nogncheck\n #include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""  // nogncheck\n #endif\n ""}<_**next**_>{""sha"": ""154e773645fadb49d560d3b3aa8cb4e1f3511e43"", ""filename"": ""components/printing/browser/BUILD.gn"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,8 @@\n \n static_library(\""browser\"") {\n   sources = [\n+    \""print_composite_client.cc\"",\n+    \""print_composite_client.h\"",\n     \""print_manager.cc\"",\n     \""print_manager.h\"",\n     \""print_manager_utils.cc\"",\n@@ -17,6 +19,9 @@ static_library(\""browser\"") {\n   deps = [\n     \""//base\"",\n     \""//components/printing/common\"",\n+    \""//components/printing/service/public/cpp:client\"",\n+    \""//mojo/public/cpp/system:system\"",\n     \""//printing\"",\n+    \""//services/service_manager/public/cpp\"",\n   ]\n }""}<_**next**_>{""sha"": ""f67625c944f981351fc84c69ea9c9f156b285839"", ""filename"": ""components/printing/browser/DEPS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/DEPS?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -1,3 +1,6 @@\n include_rules = [\n+  \""+components/printing/service/public/cpp\"",\n   \""+content/public/browser\"",\n+  \""+mojo/public/cpp/system\"",\n+  \""+services/service_manager/public/cpp\"",\n ]""}<_**next**_>{""sha"": ""e105223f7f9335c2aec939ac0fe4b4a5dbdfa97b"", ""filename"": ""components/printing/browser/print_composite_client.cc"", ""status"": ""added"", ""additions"": 79, ""deletions"": 0, ""changes"": 79, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,79 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""components/printing/browser/print_composite_client.h\""\n+\n+#include <memory>\n+#include <utility>\n+\n+#include \""base/threading/thread_task_runner_handle.h\""\n+#include \""content/public/browser/browser_thread.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n+#include \""services/service_manager/public/cpp/connector.h\""\n+\n+DEFINE_WEB_CONTENTS_USER_DATA_KEY(printing::PrintCompositeClient);\n+\n+namespace printing {\n+\n+PrintCompositeClient::PrintCompositeClient(content::WebContents* web_contents)\n+    : for_preview_(false) {}\n+\n+PrintCompositeClient::~PrintCompositeClient() {}\n+\n+void PrintCompositeClient::CreateConnectorRequest() {\n+  connector_ = service_manager::Connector::Create(&connector_request_);\n+  content::ServiceManagerConnection::GetForProcess()\n+      ->GetConnector()\n+      ->BindConnectorRequest(std::move(connector_request_));\n+}\n+\n+void PrintCompositeClient::DoComposite(\n+    base::SharedMemoryHandle handle,\n+    uint32_t data_size,\n+    mojom::PdfCompositor::CompositePdfCallback callback) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  DCHECK(data_size);\n+\n+  if (!connector_)\n+    CreateConnectorRequest();\n+  Composite(connector_.get(), handle, data_size, std::move(callback),\n+            base::ThreadTaskRunnerHandle::Get());\n+}\n+\n+std::unique_ptr<base::SharedMemory> PrintCompositeClient::GetShmFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  base::SharedMemoryHandle memory_handle;\n+  size_t memory_size = 0;\n+  bool read_only_flag = false;\n+\n+  const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n+      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n+  if (result != MOJO_RESULT_OK)\n+    return nullptr;\n+  DCHECK_GT(memory_size, 0u);\n+\n+  std::unique_ptr<base::SharedMemory> shm =\n+      base::MakeUnique<base::SharedMemory>(memory_handle, true /* read_only */);\n+  if (!shm->Map(memory_size)) {\n+    DLOG(ERROR) << \""Map shared memory failed.\"";\n+    return nullptr;\n+  }\n+  return shm;\n+}\n+\n+scoped_refptr<base::RefCountedBytes>\n+PrintCompositeClient::GetDataFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  std::unique_ptr<base::SharedMemory> shm =\n+      GetShmFromMojoHandle(std::move(handle));\n+  if (!shm)\n+    return nullptr;\n+\n+  return base::MakeRefCounted<base::RefCountedBytes>(\n+      reinterpret_cast<const unsigned char*>(shm->memory()),\n+      shm->mapped_size());\n+}\n+\n+}  // namespace printing""}<_**next**_>{""sha"": ""d63b34123520f5d66dbafe7c878c84f77725a91c"", ""filename"": ""components/printing/browser/print_composite_client.h"", ""status"": ""added"", ""additions"": 49, ""deletions"": 0, ""changes"": 49, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,49 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+#define COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_client.h\""\n+#include \""content/public/browser/web_contents_observer.h\""\n+#include \""content/public/browser/web_contents_user_data.h\""\n+\n+namespace printing {\n+\n+class PrintCompositeClient\n+    : public PdfCompositorClient,\n+      public content::WebContentsUserData<PrintCompositeClient> {\n+ public:\n+  explicit PrintCompositeClient(content::WebContents* web_contents);\n+  ~PrintCompositeClient() override;\n+\n+  void DoComposite(base::SharedMemoryHandle handle,\n+                   uint32_t data_size,\n+                   mojom::PdfCompositor::CompositePdfCallback callback);\n+\n+  void set_for_preview(bool for_preview) { for_preview_ = for_preview; }\n+  bool for_preview() const { return for_preview_; }\n+\n+  // Utility functions.\n+  static std::unique_ptr<base::SharedMemory> GetShmFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+  static scoped_refptr<base::RefCountedBytes> GetDataFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+\n+ private:\n+  void CreateConnectorRequest();\n+\n+  service_manager::mojom::ConnectorRequest connector_request_;\n+  std::unique_ptr<service_manager::Connector> connector_;\n+  bool for_preview_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(PrintCompositeClient);\n+};\n+\n+}  // namespace printing\n+\n+#endif  // COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_""}<_**next**_>{""sha"": ""844fcf5bd23513e52fa2a2eb7d9d958762e11ddf"", ""filename"": ""components/printing/browser/print_manager_utils.cc"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 1, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3,11 +3,43 @@\n // found in the LICENSE file.\n \n #include \""components/printing/browser/print_manager_utils.h\""\n+\n+#include \""base/command_line.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n #include \""components/printing/common/print_messages.h\""\n+#include \""content/public/common/content_features.h\""\n+#include \""content/public/common/content_switches.h\""\n #include \""printing/print_settings.h\""\n \n namespace printing {\n \n+// A temporary flag which makes supporting both paths for OOPIF and non-OOPIF\n+// printing easier.\n+static bool g_oopif_enabled = false;\n+\n+void SetOopifEnabled() {\n+  g_oopif_enabled = true;\n+}\n+\n+bool IsOopifEnabled() {\n+  return g_oopif_enabled;\n+}\n+\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview) {\n+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n+          switches::kSitePerProcess) ||\n+      base::FeatureList::IsEnabled(features::kTopDocumentIsolation)) {\n+    // For cases need to support OOPIFs.\n+    PrintCompositeClient::CreateForWebContents(web_contents);\n+    if (for_preview) {\n+      PrintCompositeClient::FromWebContents(web_contents)\n+          ->set_for_preview(true);\n+    }\n+    SetOopifEnabled();\n+  }\n+}\n+\n void RenderParamsFromPrintSettings(const PrintSettings& settings,\n                                    PrintMsg_Print_Params* params) {\n   params->page_size = settings.page_setup_device_units().physical_size();\n@@ -32,7 +64,8 @@ void RenderParamsFromPrintSettings(const PrintSettings& settings,\n   params->display_header_footer = settings.display_header_footer();\n   params->title = settings.title();\n   params->url = settings.url();\n-  params->printed_doc_type = SkiaDocumentType::PDF;\n+  params->printed_doc_type =\n+      IsOopifEnabled() ? SkiaDocumentType::MSKP : SkiaDocumentType::PDF;\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""5b2b62a7dbf5599fbb51940906b2ed4697c5d0a2"", ""filename"": ""components/printing/browser/print_manager_utils.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,10 +7,22 @@\n \n struct PrintMsg_Print_Params;\n \n+namespace content {\n+class WebContents;\n+}\n+\n namespace printing {\n \n class PrintSettings;\n \n+void SetOopifEnabled(bool enabled);\n+bool IsOopifEnabled();\n+\n+// Check on the current feature settings to decide whether we need to\n+// create a PDF compositor client for this |web_contents|.\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview);\n+\n // Converts given settings to Print_Params and stores them in the output\n // parameter |params|.\n void RenderParamsFromPrintSettings(const PrintSettings& settings,""}<_**next**_>{""sha"": ""231fe97661ab55076dcd33cbc9dc12eeb29cbe83"", ""filename"": ""headless/lib/browser/headless_web_contents_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/headless/lib/browser/headless_web_contents_impl.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -322,6 +322,7 @@ HeadlessWebContentsImpl::HeadlessWebContentsImpl(\n       weak_ptr_factory_(this) {\n #if BUILDFLAG(ENABLE_BASIC_PRINTING) && !defined(CHROME_MULTIPLE_DLL_CHILD)\n   HeadlessPrintManager::CreateForWebContents(web_contents);\n+// TODO(weili): Add support for printing OOPIFs.\n #endif\n   web_contents->GetMutableRendererPrefs()->accept_languages =\n       browser_context->options()->accept_language();""}","void PrintPreviewMessageHandler::OnDidPreviewPage(
    const PrintHostMsg_DidPreviewPage_Params& params) {
  int page_number = params.page_number;
  if (page_number < FIRST_PAGE_INDEX || !params.data_size)
    return;

  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
   if (!print_preview_ui)
     return;
 
  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {
    auto* client = PrintCompositeClient::FromWebContents(web_contents());
    DCHECK(client);

    // Use utility process to convert skia metafile to pdf.
    client->DoComposite(
        params.metafile_data_handle, params.data_size,
        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,
                       weak_ptr_factory_.GetWeakPtr(), params.page_number,
                       params.preview_request_id));
  } else {
    NotifyUIPreviewPageReady(
        page_number, params.preview_request_id,
        GetDataFromHandle(params.metafile_data_handle, params.data_size));
  }
 }
","void PrintPreviewMessageHandler::OnDidPreviewPage(
    const PrintHostMsg_DidPreviewPage_Params& params) {
  int page_number = params.page_number;
  if (page_number < FIRST_PAGE_INDEX || !params.data_size)
    return;

  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
   if (!print_preview_ui)
     return;
 
  scoped_refptr<base::RefCountedBytes> data_bytes =
      GetDataFromHandle(params.metafile_data_handle, params.data_size);
  DCHECK(data_bytes);
  print_preview_ui->SetPrintPreviewDataForIndex(page_number,
                                                std::move(data_bytes));
  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);
 }
",C,"  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {
    auto* client = PrintCompositeClient::FromWebContents(web_contents());
    DCHECK(client);

    // Use utility process to convert skia metafile to pdf.
    client->DoComposite(
        params.metafile_data_handle, params.data_size,
        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,
                       weak_ptr_factory_.GetWeakPtr(), params.page_number,
                       params.preview_request_id));
  } else {
    NotifyUIPreviewPageReady(
        page_number, params.preview_request_id,
        GetDataFromHandle(params.metafile_data_handle, params.data_size));
  }
","  scoped_refptr<base::RefCountedBytes> data_bytes =
      GetDataFromHandle(params.metafile_data_handle, params.data_size);
  DCHECK(data_bytes);
  print_preview_ui->SetPrintPreviewDataForIndex(page_number,
                                                std::move(data_bytes));
  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);
",,"@@ -14,18 +14,22 @@
 #include ""base/memory/ref_counted.h""
 #include ""base/memory/ref_counted_memory.h""
 #include ""base/memory/shared_memory.h""
+#include ""base/memory/shared_memory_handle.h""
 #include ""chrome/browser/browser_process.h""
 #include ""chrome/browser/printing/print_job_manager.h""
 #include ""chrome/browser/printing/print_preview_dialog_controller.h""
 #include ""chrome/browser/printing/print_view_manager.h""
 #include ""chrome/browser/printing/printer_query.h""
 #include ""chrome/browser/ui/webui/print_preview/print_preview_ui.h""
+#include ""components/printing/browser/print_composite_client.h""
+#include ""components/printing/browser/print_manager_utils.h""
 #include ""components/printing/common/print_messages.h""
 #include ""content/public/browser/browser_thread.h""
 #include ""content/public/browser/web_contents.h""
 #include ""content/public/browser/web_ui.h""
 #include ""printing/page_size_margins.h""
 #include ""printing/print_job_constants.h""
+#include ""printing/print_settings.h""
 
 using content::BrowserThread;
 using content::WebContents;
@@ -69,7 +73,7 @@ scoped_refptr<base::RefCountedBytes> GetDataFromHandle(
 
 PrintPreviewMessageHandler::PrintPreviewMessageHandler(
     WebContents* web_contents)
-    : content::WebContentsObserver(web_contents) {
+    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {
   DCHECK(web_contents);
 }
 
@@ -129,13 +133,21 @@ void PrintPreviewMessageHandler::OnDidPreviewPage(
   if (!print_preview_ui)
     return;
 
-  scoped_refptr<base::RefCountedBytes> data_bytes =
-      GetDataFromHandle(params.metafile_data_handle, params.data_size);
-  DCHECK(data_bytes);
-
-  print_preview_ui->SetPrintPreviewDataForIndex(page_number,
-                                                std::move(data_bytes));
-  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);
+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {
+    auto* client = PrintCompositeClient::FromWebContents(web_contents());
+    DCHECK(client);
+
+    // Use utility process to convert skia metafile to pdf.
+    client->DoComposite(
+        params.metafile_data_handle, params.data_size,
+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,
+                       weak_ptr_factory_.GetWeakPtr(), params.page_number,
+                       params.preview_request_id));
+  } else {
+    NotifyUIPreviewPageReady(
+        page_number, params.preview_request_id,
+        GetDataFromHandle(params.metafile_data_handle, params.data_size));
+  }
 }
 
 void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(
@@ -152,18 +164,20 @@ void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(
   if (!print_preview_ui)
     return;
 
-  // TODO(joth): This seems like a good match for using RefCountedStaticMemory
-  // to avoid the memory copy, but the SetPrintPreviewData call chain below
-  // needs updating to accept the RefCountedMemory* base class.
-  scoped_refptr<base::RefCountedBytes> data_bytes =
-      GetDataFromHandle(params.metafile_data_handle, params.data_size);
-  if (!data_bytes || !data_bytes->size())
-    return;
-
-  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,
-                                                std::move(data_bytes));
-  print_preview_ui->OnPreviewDataIsAvailable(
-      params.expected_pages_count, params.preview_request_id);
+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {
+    auto* client = PrintCompositeClient::FromWebContents(web_contents());
+    DCHECK(client);
+
+    client->DoComposite(
+        params.metafile_data_handle, params.data_size,
+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,
+                       weak_ptr_factory_.GetWeakPtr(),
+                       params.expected_pages_count, params.preview_request_id));
+  } else {
+    NotifyUIPreviewDocumentReady(
+        params.expected_pages_count, params.preview_request_id,
+        GetDataFromHandle(params.metafile_data_handle, params.data_size));
+  }
 }
 
 void PrintPreviewMessageHandler::OnPrintPreviewFailed(int document_cookie) {
@@ -214,6 +228,65 @@ void PrintPreviewMessageHandler::OnSetOptionsFromDocument(
   print_preview_ui->OnSetOptionsFromDocument(params);
 }
 
+void PrintPreviewMessageHandler::NotifyUIPreviewPageReady(
+    int page_number,
+    int request_id,
+    scoped_refptr<base::RefCountedBytes> data_bytes) {
+  DCHECK(data_bytes);
+
+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
+  if (!print_preview_ui)
+    return;
+  print_preview_ui->SetPrintPreviewDataForIndex(page_number,
+                                                std::move(data_bytes));
+  print_preview_ui->OnDidPreviewPage(page_number, request_id);
+}
+
+void PrintPreviewMessageHandler::NotifyUIPreviewDocumentReady(
+    int page_count,
+    int request_id,
+    scoped_refptr<base::RefCountedBytes> data_bytes) {
+  if (!data_bytes || !data_bytes->size())
+    return;
+
+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
+  if (!print_preview_ui)
+    return;
+  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,
+                                                std::move(data_bytes));
+  print_preview_ui->OnPreviewDataIsAvailable(page_count, request_id);
+}
+
+void PrintPreviewMessageHandler::OnCompositePdfPageDone(
+    int page_number,
+    int request_id,
+    mojom::PdfCompositor::Status status,
+    mojo::ScopedSharedBufferHandle handle) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  if (status != mojom::PdfCompositor::Status::SUCCESS) {
+    DLOG(ERROR) << ""Compositing pdf failed with error "" << status;
+    return;
+  }
+  NotifyUIPreviewPageReady(
+      page_number, request_id,
+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));
+}
+
+void PrintPreviewMessageHandler::OnCompositePdfDocumentDone(
+    int page_count,
+    int request_id,
+    mojom::PdfCompositor::Status status,
+    mojo::ScopedSharedBufferHandle handle) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  if (status != mojom::PdfCompositor::Status::SUCCESS) {
+    DLOG(ERROR) << ""Compositing pdf failed with error "" << status;
+    return;
+  }
+  NotifyUIPreviewDocumentReady(
+      page_count, request_id,
+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));
+}
+
 bool PrintPreviewMessageHandler::OnMessageReceived(
     const IPC::Message& message,
     content::RenderFrameHost* render_frame_host) {
@@ -231,8 +304,7 @@ bool PrintPreviewMessageHandler::OnMessageReceived(
   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)
     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,
                         OnDidGetPreviewPageCount)
-    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,
-                        OnDidPreviewPage)
+    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)
     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,
                         OnMetafileReadyForPrinting)
     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,",Chrome,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,896aab1971cb86907e97ea09726b3872fbfde09a,1,"void PrintPreviewMessageHandler::OnDidPreviewPage(
    const PrintHostMsg_DidPreviewPage_Params& params) {
  int page_number = params.page_number;
  if (page_number < FIRST_PAGE_INDEX || !params.data_size)
    return;

  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
   if (!print_preview_ui)
     return;
 
//flaw_line_below:
  scoped_refptr<base::RefCountedBytes> data_bytes =
//flaw_line_below:
      GetDataFromHandle(params.metafile_data_handle, params.data_size);
//flaw_line_below:
  DCHECK(data_bytes);
//flaw_line_below:

//flaw_line_below:
  print_preview_ui->SetPrintPreviewDataForIndex(page_number,
//flaw_line_below:
                                                std::move(data_bytes));
//flaw_line_below:
  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);
//fix_flaw_line_below:
//  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {
//fix_flaw_line_below:
//    auto* client = PrintCompositeClient::FromWebContents(web_contents());
//fix_flaw_line_below:
//    DCHECK(client);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    // Use utility process to convert skia metafile to pdf.
//fix_flaw_line_below:
//    client->DoComposite(
//fix_flaw_line_below:
//        params.metafile_data_handle, params.data_size,
//fix_flaw_line_below:
//        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,
//fix_flaw_line_below:
//                       weak_ptr_factory_.GetWeakPtr(), params.page_number,
//fix_flaw_line_below:
//                       params.preview_request_id));
//fix_flaw_line_below:
//  } else {
//fix_flaw_line_below:
//    NotifyUIPreviewPageReady(
//fix_flaw_line_below:
//        page_number, params.preview_request_id,
//fix_flaw_line_below:
//        GetDataFromHandle(params.metafile_data_handle, params.data_size));
//fix_flaw_line_below:
//  }
 }
"
8031,185767,,Remote,Not required,,CVE-2015-1300,https://www.cvedetails.com/cve/CVE-2015-1300/,CWE-254,Low,Partial,,,2015-09-03,5.0,"The FrameFetchContext::updateTimingInfoForIFrameNavigation function in core/loader/FrameFetchContext.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not properly restrict the availability of IFRAME Resource Timing API times, which allows remote attackers to obtain sensitive information via crafted JavaScript code that leverages a history.back call.",2016-12-21,+Info ,1,https://github.com/chromium/chromium/commit/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,"Use pdf compositor service for printing when OOPIF is enabled

When OOPIF is enabled (by site-per-process flag or
top-document-isolation feature), use the pdf compositor service for
converting PaintRecord to PDF on renderers.

In the future, this will make compositing PDF from multiple renderers
possible.

TBR=jzfeng@chromium.org
BUG=455764

Change-Id: I3c28f03f4358e4228239fe1a33384f85e7716e8f
Reviewed-on: https://chromium-review.googlesource.com/699765
Commit-Queue: Wei Li <weili@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Cr-Commit-Position: refs/heads/master@{#511616}",2,chrome/browser/printing/print_preview_message_handler.cc,"{""sha"": ""78193d61b9f59cdc78ed504e7a6939379d4f52d5"", ""filename"": ""chrome/browser/chrome_content_browser_manifest_overlay.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chrome_content_browser_manifest_overlay.json?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -44,6 +44,7 @@\n         \""local_state\"": [ \""pref_client\"" ],\n         \""nacl_broker\"": [ \""browser\"" ],\n         \""nacl_loader\"": [ \""browser\"" ],\n+        \""pdf_compositor\"": [ \""compositor\"" ],\n         \""profile_import\"": [ \""import\"" ],\n         \""profiling\"": [ \""profiling\"" ],\n         \""proxy_resolver\"": [ \""factory\"" ],""}<_**next**_>{""sha"": ""449ec7465b049d91941d3413bafcb8ee1904d417"", ""filename"": ""chrome/browser/printing/print_preview_dialog_controller.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_dialog_controller.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -29,6 +29,7 @@\n #include \""chrome/common/chrome_paths.h\""\n #include \""chrome/common/url_constants.h\""\n #include \""components/guest_view/browser/guest_view_base.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/web_modal/web_contents_modal_dialog_host.h\""\n #include \""content/public/browser/host_zoom_map.h\""\n #include \""content/public/browser/navigation_controller.h\""\n@@ -376,6 +377,7 @@ WebContents* PrintPreviewDialogController::CreatePrintPreviewDialog(\n   content::HostZoomMap::Get(preview_dialog->GetSiteInstance())\n       ->SetZoomLevelForHostAndScheme(print_url.scheme(), print_url.host(), 0);\n   PrintViewManager::CreateForWebContents(preview_dialog);\n+  CreateCompositeClientIfNeeded(preview_dialog, true /* for_preview */);\n   extensions::ChromeExtensionWebContentsObserver::CreateForWebContents(\n       preview_dialog);\n ""}<_**next**_>{""sha"": ""cda7ad2e7612be69842877448291d3be54317a64"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.cc"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 22, ""changes"": 116, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -14,18 +14,22 @@\n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/ref_counted_memory.h\""\n #include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n #include \""chrome/browser/browser_process.h\""\n #include \""chrome/browser/printing/print_job_manager.h\""\n #include \""chrome/browser/printing/print_preview_dialog_controller.h\""\n #include \""chrome/browser/printing/print_view_manager.h\""\n #include \""chrome/browser/printing/printer_query.h\""\n #include \""chrome/browser/ui/webui/print_preview/print_preview_ui.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""content/public/browser/web_ui.h\""\n #include \""printing/page_size_margins.h\""\n #include \""printing/print_job_constants.h\""\n+#include \""printing/print_settings.h\""\n \n using content::BrowserThread;\n using content::WebContents;\n@@ -69,7 +73,7 @@ scoped_refptr<base::RefCountedBytes> GetDataFromHandle(\n \n PrintPreviewMessageHandler::PrintPreviewMessageHandler(\n     WebContents* web_contents)\n-    : content::WebContentsObserver(web_contents) {\n+    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {\n   DCHECK(web_contents);\n }\n \n@@ -129,13 +133,21 @@ void PrintPreviewMessageHandler::OnDidPreviewPage(\n   if (!print_preview_ui)\n     return;\n \n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  DCHECK(data_bytes);\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    // Use utility process to convert skia metafile to pdf.\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,\n+                       weak_ptr_factory_.GetWeakPtr(), params.page_number,\n+                       params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewPageReady(\n+        page_number, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n@@ -152,18 +164,20 @@ void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n   if (!print_preview_ui)\n     return;\n \n-  // TODO(joth): This seems like a good match for using RefCountedStaticMemory\n-  // to avoid the memory copy, but the SetPrintPreviewData call chain below\n-  // needs updating to accept the RefCountedMemory* base class.\n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  if (!data_bytes || !data_bytes->size())\n-    return;\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnPreviewDataIsAvailable(\n-      params.expected_pages_count, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,\n+                       weak_ptr_factory_.GetWeakPtr(),\n+                       params.expected_pages_count, params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewDocumentReady(\n+        params.expected_pages_count, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnPrintPreviewFailed(int document_cookie) {\n@@ -214,6 +228,65 @@ void PrintPreviewMessageHandler::OnSetOptionsFromDocument(\n   print_preview_ui->OnSetOptionsFromDocument(params);\n }\n \n+void PrintPreviewMessageHandler::NotifyUIPreviewPageReady(\n+    int page_number,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  DCHECK(data_bytes);\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnDidPreviewPage(page_number, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::NotifyUIPreviewDocumentReady(\n+    int page_count,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  if (!data_bytes || !data_bytes->size())\n+    return;\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnPreviewDataIsAvailable(page_count, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfPageDone(\n+    int page_number,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewPageReady(\n+      page_number, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfDocumentDone(\n+    int page_count,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewDocumentReady(\n+      page_count, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n bool PrintPreviewMessageHandler::OnMessageReceived(\n     const IPC::Message& message,\n     content::RenderFrameHost* render_frame_host) {\n@@ -231,8 +304,7 @@ bool PrintPreviewMessageHandler::OnMessageReceived(\n   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,\n                         OnDidGetPreviewPageCount)\n-    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,\n-                        OnDidPreviewPage)\n+    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,\n                         OnMetafileReadyForPrinting)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,""}<_**next**_>{""sha"": ""71ca9d5bb1ee142ed3dbbfaa34cd8ab5d3018002"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.h"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,6 +7,9 @@\n \n #include \""base/compiler_specific.h\""\n #include \""base/macros.h\""\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/weak_ptr.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/web_contents_observer.h\""\n #include \""content/public/browser/web_contents_user_data.h\""\n \n@@ -70,6 +73,27 @@ class PrintPreviewMessageHandler\n   void OnSetOptionsFromDocument(\n       const PrintHostMsg_SetOptionsFromDocument_Params& params);\n \n+  void NotifyUIPreviewPageReady(\n+      int page_number,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+  void NotifyUIPreviewDocumentReady(\n+      int page_count,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+\n+  // Callbacks for pdf compositor client.\n+  void OnCompositePdfPageDone(int page_number,\n+                              int request_id,\n+                              mojom::PdfCompositor::Status status,\n+                              mojo::ScopedSharedBufferHandle handle);\n+  void OnCompositePdfDocumentDone(int page_count,\n+                                  int request_id,\n+                                  mojom::PdfCompositor::Status status,\n+                                  mojo::ScopedSharedBufferHandle handle);\n+\n+  base::WeakPtrFactory<PrintPreviewMessageHandler> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintPreviewMessageHandler);\n };\n ""}<_**next**_>{""sha"": ""f4fed9d2753dbd8b374dfb9b6f006cf51010d5cf"", ""filename"": ""chrome/browser/printing/print_view_manager_base.cc"", ""status"": ""modified"", ""additions"": 64, ""deletions"": 25, ""changes"": 89, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -11,6 +11,7 @@\n #include \""base/bind.h\""\n #include \""base/location.h\""\n #include \""base/memory/ptr_util.h\""\n+#include \""base/memory/shared_memory.h\""\n #include \""base/message_loop/message_loop.h\""\n #include \""base/run_loop.h\""\n #include \""base/single_thread_task_runner.h\""\n@@ -28,6 +29,8 @@\n #include \""chrome/common/pref_names.h\""\n #include \""chrome/grit/generated_resources.h\""\n #include \""components/prefs/pref_service.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/notification_details.h\""\n@@ -36,8 +39,10 @@\n #include \""content/public/browser/render_frame_host.h\""\n #include \""content/public/browser/render_view_host.h\""\n #include \""content/public/browser/web_contents.h\""\n+#include \""mojo/public/cpp/system/buffer.h\""\n #include \""printing/features/features.h\""\n #include \""printing/pdf_metafile_skia.h\""\n+#include \""printing/print_settings.h\""\n #include \""printing/printed_document.h\""\n #include \""ui/base/l10n/l10n_util.h\""\n \n@@ -78,7 +83,8 @@ PrintViewManagerBase::PrintViewManagerBase(content::WebContents* web_contents)\n #if !defined(OS_MACOSX)\n       expecting_first_page_(true),\n #endif\n-      queue_(g_browser_process->print_job_manager()->queue()) {\n+      queue_(g_browser_process->print_job_manager()->queue()),\n+      weak_ptr_factory_(this) {\n   DCHECK(queue_.get());\n   Profile* profile =\n       Profile::FromBrowserContext(web_contents->GetBrowserContext());\n@@ -127,8 +133,24 @@ void PrintViewManagerBase::OnDidGetPrintedPagesCount(int cookie,\n   OpportunisticallyCreatePrintJob(cookie);\n }\n \n+void PrintViewManagerBase::OnComposePdfDone(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+\n+  UpdateForPrintedPage(\n+      params, true,\n+      PrintCompositeClient::GetShmFromMojoHandle(std::move(handle)));\n+}\n+\n void PrintViewManagerBase::OnDidPrintPage(\n-  const PrintHostMsg_DidPrintPage_Params& params) {\n+    const PrintHostMsg_DidPrintPage_Params& params) {\n+  // Ready to composite. Starting a print job.\n   if (!OpportunisticallyCreatePrintJob(params.document_cookie))\n     return;\n \n@@ -154,8 +176,18 @@ void PrintViewManagerBase::OnDidPrintPage(\n       web_contents()->Stop();\n       return;\n     }\n+\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    if (IsOopifEnabled() && !client->for_preview() &&\n+        !document->settings().is_modifiable()) {\n+      client->DoComposite(\n+          params.metafile_data_handle, params.data_size,\n+          base::BindOnce(&PrintViewManagerBase::OnComposePdfDone,\n+                         weak_ptr_factory_.GetWeakPtr(), params));\n+      return;\n+    }\n     shared_buf =\n-        base::MakeUnique<base::SharedMemory>(params.metafile_data_handle, true);\n+        std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);\n     if (!shared_buf->Map(params.data_size)) {\n       NOTREACHED() << \""couldn't map\"";\n       web_contents()->Stop();\n@@ -170,22 +202,24 @@ void PrintViewManagerBase::OnDidPrintPage(\n     }\n   }\n \n-  std::unique_ptr<PdfMetafileSkia> metafile(\n-      new PdfMetafileSkia(SkiaDocumentType::PDF));\n-  if (metafile_must_be_valid) {\n-    if (!metafile->InitFromData(shared_buf->memory(), params.data_size)) {\n-      NOTREACHED() << \""Invalid metafile header\"";\n-      web_contents()->Stop();\n-      return;\n-    }\n-  }\n+  UpdateForPrintedPage(params, metafile_must_be_valid, std::move(shared_buf));\n+}\n+\n+void PrintViewManagerBase::UpdateForPrintedPage(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    bool has_valid_page_data,\n+    std::unique_ptr<base::SharedMemory> shared_buf) {\n+  PrintedDocument* document = print_job_->document();\n+  if (!document)\n+    return;\n \n #if defined(OS_WIN)\n   print_job_->AppendPrintedPage(params.page_number);\n-  if (metafile_must_be_valid) {\n-    scoped_refptr<base::RefCountedBytes> bytes = new base::RefCountedBytes(\n+  if (has_valid_page_data) {\n+    scoped_refptr<base::RefCountedBytes> bytes(new base::RefCountedBytes(\n         reinterpret_cast<const unsigned char*>(shared_buf->memory()),\n-        params.data_size);\n+        shared_buf->mapped_size()));\n+\n     document->DebugDumpData(bytes.get(), FILE_PATH_LITERAL(\"".pdf\""));\n \n     const auto& settings = document->settings();\n@@ -203,22 +237,27 @@ void PrintViewManagerBase::OnDidPrintPage(\n       // Update : The missing letters seem to have been caused by the same\n       // problem as https://crbug.com/659604 which was resolved. GDI printing\n       // seems to work with the fix for this bug applied.\n-      bool print_text_with_gdi = settings.print_text_with_gdi() &&\n-                                 !settings.printer_is_xps() &&\n-                                 base::FeatureList::IsEnabled(\n-                                     features::kGdiTextPrinting);\n+      bool print_text_with_gdi =\n+          settings.print_text_with_gdi() && !settings.printer_is_xps() &&\n+          base::FeatureList::IsEnabled(features::kGdiTextPrinting);\n       print_job_->StartPdfToEmfConversion(\n           bytes, params.page_size, params.content_area, print_text_with_gdi);\n     }\n   }\n #else\n+  std::unique_ptr<PdfMetafileSkia> metafile =\n+      std::make_unique<PdfMetafileSkia>(SkiaDocumentType::PDF);\n+  if (has_valid_page_data) {\n+    if (!metafile->InitFromData(shared_buf->memory(),\n+                                shared_buf->mapped_size())) {\n+      NOTREACHED() << \""Invalid metafile header\"";\n+      web_contents()->Stop();\n+      return;\n+    }\n+  }\n+\n   // Update the rendered document. It will send notifications to the listener.\n-  document->SetPage(params.page_number,\n-                    std::move(metafile),\n-#if defined(OS_WIN)\n-                    0.0f /* dummy shrink_factor */,\n-#endif\n-                    params.page_size,\n+  document->SetPage(params.page_number, std::move(metafile), params.page_size,\n                     params.content_area);\n \n   ShouldQuitFromInnerMessageLoop();""}<_**next**_>{""sha"": ""e9706e34f8c96f224196aa8ffc993b44a9247cf9"", ""filename"": ""chrome/browser/printing/print_view_manager_base.h"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 1, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -9,16 +9,23 @@\n \n #include \""base/macros.h\""\n #include \""base/memory/ref_counted.h\""\n+#include \""base/memory/weak_ptr.h\""\n #include \""base/strings/string16.h\""\n #include \""build/build_config.h\""\n #include \""components/prefs/pref_member.h\""\n #include \""components/printing/browser/print_manager.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/notification_observer.h\""\n #include \""content/public/browser/notification_registrar.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n #include \""printing/features/features.h\""\n \n struct PrintHostMsg_DidPrintPage_Params;\n \n+namespace base {\n+class SharedMemory;\n+}\n+\n namespace content {\n class RenderFrameHost;\n }\n@@ -82,9 +89,19 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   // IPC Message handlers.\n   void OnDidGetPrintedPagesCount(int cookie, int number_pages) override;\n-  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n   void OnPrintingFailed(int cookie) override;\n   void OnShowInvalidPrinterSettingsError();\n+  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n+\n+  // Handle extra tasks once a page or doc is printed.\n+  void UpdateForPrintedPage(const PrintHostMsg_DidPrintPage_Params& params,\n+                            bool has_valid_page_data,\n+                            std::unique_ptr<base::SharedMemory> shared_buf);\n+\n+  // IPC message handlers for service.\n+  void OnComposePdfDone(const PrintHostMsg_DidPrintPage_Params& params,\n+                        mojom::PdfCompositor::Status status,\n+                        mojo::ScopedSharedBufferHandle handle);\n \n   // Processes a NOTIFY_PRINT_JOB_EVENT notification.\n   void OnNotifyPrintJobEvent(const JobEventDetails& event_details);\n@@ -163,6 +180,8 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   scoped_refptr<printing::PrintQueriesQueue> queue_;\n \n+  base::WeakPtrFactory<PrintViewManagerBase> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintViewManagerBase);\n };\n ""}<_**next**_>{""sha"": ""3560d1c793977a5c2fe67253c9cf9509dbe596a1"", ""filename"": ""chrome/browser/printing/printing_init.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/printing_init.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""chrome/browser/printing/printing_init.h\""\n \n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""printing/features/features.h\""\n \n@@ -23,6 +24,7 @@ void InitializePrinting(content::WebContents* web_contents) {\n #else\n   printing::PrintViewManagerBasic::CreateForWebContents(web_contents);\n #endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)\n+  CreateCompositeClientIfNeeded(web_contents, false /* for_preview */);\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""84901e64744b737a1810f2e3c513498bfea57fb6"", ""filename"": ""chrome/browser/ui/BUILD.gn"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3475,7 +3475,10 @@ split_static_library(\""ui\"") {\n   }\n \n   if (enable_basic_printing || enable_print_preview) {\n-    deps += [ \""//printing\"" ]\n+    deps += [\n+      \""//components/printing/browser\"",\n+      \""//printing\"",\n+    ]\n     if (use_cups) {\n       configs += [ \""//printing:cups\"" ]\n     }""}<_**next**_>{""sha"": ""20c22c6758f1b3353627d510ee4cfe71ef980b8b"", ""filename"": ""chrome/utility/chrome_content_utility_client.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/utility/chrome_content_utility_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -73,7 +73,7 @@\n \n #if BUILDFLAG(ENABLE_PRINTING)\n #include \""chrome/common/chrome_content_client.h\""\n-#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""  // nogncheck\n #include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""  // nogncheck\n #endif\n ""}<_**next**_>{""sha"": ""154e773645fadb49d560d3b3aa8cb4e1f3511e43"", ""filename"": ""components/printing/browser/BUILD.gn"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,8 @@\n \n static_library(\""browser\"") {\n   sources = [\n+    \""print_composite_client.cc\"",\n+    \""print_composite_client.h\"",\n     \""print_manager.cc\"",\n     \""print_manager.h\"",\n     \""print_manager_utils.cc\"",\n@@ -17,6 +19,9 @@ static_library(\""browser\"") {\n   deps = [\n     \""//base\"",\n     \""//components/printing/common\"",\n+    \""//components/printing/service/public/cpp:client\"",\n+    \""//mojo/public/cpp/system:system\"",\n     \""//printing\"",\n+    \""//services/service_manager/public/cpp\"",\n   ]\n }""}<_**next**_>{""sha"": ""f67625c944f981351fc84c69ea9c9f156b285839"", ""filename"": ""components/printing/browser/DEPS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/DEPS?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -1,3 +1,6 @@\n include_rules = [\n+  \""+components/printing/service/public/cpp\"",\n   \""+content/public/browser\"",\n+  \""+mojo/public/cpp/system\"",\n+  \""+services/service_manager/public/cpp\"",\n ]""}<_**next**_>{""sha"": ""e105223f7f9335c2aec939ac0fe4b4a5dbdfa97b"", ""filename"": ""components/printing/browser/print_composite_client.cc"", ""status"": ""added"", ""additions"": 79, ""deletions"": 0, ""changes"": 79, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,79 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""components/printing/browser/print_composite_client.h\""\n+\n+#include <memory>\n+#include <utility>\n+\n+#include \""base/threading/thread_task_runner_handle.h\""\n+#include \""content/public/browser/browser_thread.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n+#include \""services/service_manager/public/cpp/connector.h\""\n+\n+DEFINE_WEB_CONTENTS_USER_DATA_KEY(printing::PrintCompositeClient);\n+\n+namespace printing {\n+\n+PrintCompositeClient::PrintCompositeClient(content::WebContents* web_contents)\n+    : for_preview_(false) {}\n+\n+PrintCompositeClient::~PrintCompositeClient() {}\n+\n+void PrintCompositeClient::CreateConnectorRequest() {\n+  connector_ = service_manager::Connector::Create(&connector_request_);\n+  content::ServiceManagerConnection::GetForProcess()\n+      ->GetConnector()\n+      ->BindConnectorRequest(std::move(connector_request_));\n+}\n+\n+void PrintCompositeClient::DoComposite(\n+    base::SharedMemoryHandle handle,\n+    uint32_t data_size,\n+    mojom::PdfCompositor::CompositePdfCallback callback) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  DCHECK(data_size);\n+\n+  if (!connector_)\n+    CreateConnectorRequest();\n+  Composite(connector_.get(), handle, data_size, std::move(callback),\n+            base::ThreadTaskRunnerHandle::Get());\n+}\n+\n+std::unique_ptr<base::SharedMemory> PrintCompositeClient::GetShmFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  base::SharedMemoryHandle memory_handle;\n+  size_t memory_size = 0;\n+  bool read_only_flag = false;\n+\n+  const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n+      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n+  if (result != MOJO_RESULT_OK)\n+    return nullptr;\n+  DCHECK_GT(memory_size, 0u);\n+\n+  std::unique_ptr<base::SharedMemory> shm =\n+      base::MakeUnique<base::SharedMemory>(memory_handle, true /* read_only */);\n+  if (!shm->Map(memory_size)) {\n+    DLOG(ERROR) << \""Map shared memory failed.\"";\n+    return nullptr;\n+  }\n+  return shm;\n+}\n+\n+scoped_refptr<base::RefCountedBytes>\n+PrintCompositeClient::GetDataFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  std::unique_ptr<base::SharedMemory> shm =\n+      GetShmFromMojoHandle(std::move(handle));\n+  if (!shm)\n+    return nullptr;\n+\n+  return base::MakeRefCounted<base::RefCountedBytes>(\n+      reinterpret_cast<const unsigned char*>(shm->memory()),\n+      shm->mapped_size());\n+}\n+\n+}  // namespace printing""}<_**next**_>{""sha"": ""d63b34123520f5d66dbafe7c878c84f77725a91c"", ""filename"": ""components/printing/browser/print_composite_client.h"", ""status"": ""added"", ""additions"": 49, ""deletions"": 0, ""changes"": 49, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,49 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+#define COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_client.h\""\n+#include \""content/public/browser/web_contents_observer.h\""\n+#include \""content/public/browser/web_contents_user_data.h\""\n+\n+namespace printing {\n+\n+class PrintCompositeClient\n+    : public PdfCompositorClient,\n+      public content::WebContentsUserData<PrintCompositeClient> {\n+ public:\n+  explicit PrintCompositeClient(content::WebContents* web_contents);\n+  ~PrintCompositeClient() override;\n+\n+  void DoComposite(base::SharedMemoryHandle handle,\n+                   uint32_t data_size,\n+                   mojom::PdfCompositor::CompositePdfCallback callback);\n+\n+  void set_for_preview(bool for_preview) { for_preview_ = for_preview; }\n+  bool for_preview() const { return for_preview_; }\n+\n+  // Utility functions.\n+  static std::unique_ptr<base::SharedMemory> GetShmFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+  static scoped_refptr<base::RefCountedBytes> GetDataFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+\n+ private:\n+  void CreateConnectorRequest();\n+\n+  service_manager::mojom::ConnectorRequest connector_request_;\n+  std::unique_ptr<service_manager::Connector> connector_;\n+  bool for_preview_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(PrintCompositeClient);\n+};\n+\n+}  // namespace printing\n+\n+#endif  // COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_""}<_**next**_>{""sha"": ""844fcf5bd23513e52fa2a2eb7d9d958762e11ddf"", ""filename"": ""components/printing/browser/print_manager_utils.cc"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 1, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3,11 +3,43 @@\n // found in the LICENSE file.\n \n #include \""components/printing/browser/print_manager_utils.h\""\n+\n+#include \""base/command_line.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n #include \""components/printing/common/print_messages.h\""\n+#include \""content/public/common/content_features.h\""\n+#include \""content/public/common/content_switches.h\""\n #include \""printing/print_settings.h\""\n \n namespace printing {\n \n+// A temporary flag which makes supporting both paths for OOPIF and non-OOPIF\n+// printing easier.\n+static bool g_oopif_enabled = false;\n+\n+void SetOopifEnabled() {\n+  g_oopif_enabled = true;\n+}\n+\n+bool IsOopifEnabled() {\n+  return g_oopif_enabled;\n+}\n+\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview) {\n+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n+          switches::kSitePerProcess) ||\n+      base::FeatureList::IsEnabled(features::kTopDocumentIsolation)) {\n+    // For cases need to support OOPIFs.\n+    PrintCompositeClient::CreateForWebContents(web_contents);\n+    if (for_preview) {\n+      PrintCompositeClient::FromWebContents(web_contents)\n+          ->set_for_preview(true);\n+    }\n+    SetOopifEnabled();\n+  }\n+}\n+\n void RenderParamsFromPrintSettings(const PrintSettings& settings,\n                                    PrintMsg_Print_Params* params) {\n   params->page_size = settings.page_setup_device_units().physical_size();\n@@ -32,7 +64,8 @@ void RenderParamsFromPrintSettings(const PrintSettings& settings,\n   params->display_header_footer = settings.display_header_footer();\n   params->title = settings.title();\n   params->url = settings.url();\n-  params->printed_doc_type = SkiaDocumentType::PDF;\n+  params->printed_doc_type =\n+      IsOopifEnabled() ? SkiaDocumentType::MSKP : SkiaDocumentType::PDF;\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""5b2b62a7dbf5599fbb51940906b2ed4697c5d0a2"", ""filename"": ""components/printing/browser/print_manager_utils.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,10 +7,22 @@\n \n struct PrintMsg_Print_Params;\n \n+namespace content {\n+class WebContents;\n+}\n+\n namespace printing {\n \n class PrintSettings;\n \n+void SetOopifEnabled(bool enabled);\n+bool IsOopifEnabled();\n+\n+// Check on the current feature settings to decide whether we need to\n+// create a PDF compositor client for this |web_contents|.\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview);\n+\n // Converts given settings to Print_Params and stores them in the output\n // parameter |params|.\n void RenderParamsFromPrintSettings(const PrintSettings& settings,""}<_**next**_>{""sha"": ""231fe97661ab55076dcd33cbc9dc12eeb29cbe83"", ""filename"": ""headless/lib/browser/headless_web_contents_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/headless/lib/browser/headless_web_contents_impl.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -322,6 +322,7 @@ HeadlessWebContentsImpl::HeadlessWebContentsImpl(\n       weak_ptr_factory_(this) {\n #if BUILDFLAG(ENABLE_BASIC_PRINTING) && !defined(CHROME_MULTIPLE_DLL_CHILD)\n   HeadlessPrintManager::CreateForWebContents(web_contents);\n+// TODO(weili): Add support for printing OOPIFs.\n #endif\n   web_contents->GetMutableRendererPrefs()->accept_languages =\n       browser_context->options()->accept_language();""}"," bool PrintPreviewMessageHandler::OnMessageReceived(
     const IPC::Message& message,
     content::RenderFrameHost* render_frame_host) {
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP_WITH_PARAM(PrintPreviewMessageHandler, message,
                                   render_frame_host)
    IPC_MESSAGE_HANDLER(PrintHostMsg_RequestPrintPreview,
                        OnRequestPrintPreview)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  if (handled)
    return true;

  handled = true;
   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)
     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,
                         OnDidGetPreviewPageCount)
    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)
     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,
                         OnMetafileReadyForPrinting)
     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,
                        OnPrintPreviewFailed)
    IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetDefaultPageLayout,
                        OnDidGetDefaultPageLayout)
    IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewCancelled,
                        OnPrintPreviewCancelled)
    IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewInvalidPrinterSettings,
                        OnInvalidPrinterSettings)
    IPC_MESSAGE_HANDLER(PrintHostMsg_SetOptionsFromDocument,
                        OnSetOptionsFromDocument)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  return handled;
}
"," bool PrintPreviewMessageHandler::OnMessageReceived(
     const IPC::Message& message,
     content::RenderFrameHost* render_frame_host) {
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP_WITH_PARAM(PrintPreviewMessageHandler, message,
                                   render_frame_host)
    IPC_MESSAGE_HANDLER(PrintHostMsg_RequestPrintPreview,
                        OnRequestPrintPreview)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  if (handled)
    return true;

  handled = true;
   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)
     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,
                         OnDidGetPreviewPageCount)
    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,
                        OnDidPreviewPage)
     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,
                         OnMetafileReadyForPrinting)
     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,
                        OnPrintPreviewFailed)
    IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetDefaultPageLayout,
                        OnDidGetDefaultPageLayout)
    IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewCancelled,
                        OnPrintPreviewCancelled)
    IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewInvalidPrinterSettings,
                        OnInvalidPrinterSettings)
    IPC_MESSAGE_HANDLER(PrintHostMsg_SetOptionsFromDocument,
                        OnSetOptionsFromDocument)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  return handled;
}
",C,"    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)
","    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,
                        OnDidPreviewPage)
",,"@@ -14,18 +14,22 @@
 #include ""base/memory/ref_counted.h""
 #include ""base/memory/ref_counted_memory.h""
 #include ""base/memory/shared_memory.h""
+#include ""base/memory/shared_memory_handle.h""
 #include ""chrome/browser/browser_process.h""
 #include ""chrome/browser/printing/print_job_manager.h""
 #include ""chrome/browser/printing/print_preview_dialog_controller.h""
 #include ""chrome/browser/printing/print_view_manager.h""
 #include ""chrome/browser/printing/printer_query.h""
 #include ""chrome/browser/ui/webui/print_preview/print_preview_ui.h""
+#include ""components/printing/browser/print_composite_client.h""
+#include ""components/printing/browser/print_manager_utils.h""
 #include ""components/printing/common/print_messages.h""
 #include ""content/public/browser/browser_thread.h""
 #include ""content/public/browser/web_contents.h""
 #include ""content/public/browser/web_ui.h""
 #include ""printing/page_size_margins.h""
 #include ""printing/print_job_constants.h""
+#include ""printing/print_settings.h""
 
 using content::BrowserThread;
 using content::WebContents;
@@ -69,7 +73,7 @@ scoped_refptr<base::RefCountedBytes> GetDataFromHandle(
 
 PrintPreviewMessageHandler::PrintPreviewMessageHandler(
     WebContents* web_contents)
-    : content::WebContentsObserver(web_contents) {
+    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {
   DCHECK(web_contents);
 }
 
@@ -129,13 +133,21 @@ void PrintPreviewMessageHandler::OnDidPreviewPage(
   if (!print_preview_ui)
     return;
 
-  scoped_refptr<base::RefCountedBytes> data_bytes =
-      GetDataFromHandle(params.metafile_data_handle, params.data_size);
-  DCHECK(data_bytes);
-
-  print_preview_ui->SetPrintPreviewDataForIndex(page_number,
-                                                std::move(data_bytes));
-  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);
+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {
+    auto* client = PrintCompositeClient::FromWebContents(web_contents());
+    DCHECK(client);
+
+    // Use utility process to convert skia metafile to pdf.
+    client->DoComposite(
+        params.metafile_data_handle, params.data_size,
+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,
+                       weak_ptr_factory_.GetWeakPtr(), params.page_number,
+                       params.preview_request_id));
+  } else {
+    NotifyUIPreviewPageReady(
+        page_number, params.preview_request_id,
+        GetDataFromHandle(params.metafile_data_handle, params.data_size));
+  }
 }
 
 void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(
@@ -152,18 +164,20 @@ void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(
   if (!print_preview_ui)
     return;
 
-  // TODO(joth): This seems like a good match for using RefCountedStaticMemory
-  // to avoid the memory copy, but the SetPrintPreviewData call chain below
-  // needs updating to accept the RefCountedMemory* base class.
-  scoped_refptr<base::RefCountedBytes> data_bytes =
-      GetDataFromHandle(params.metafile_data_handle, params.data_size);
-  if (!data_bytes || !data_bytes->size())
-    return;
-
-  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,
-                                                std::move(data_bytes));
-  print_preview_ui->OnPreviewDataIsAvailable(
-      params.expected_pages_count, params.preview_request_id);
+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {
+    auto* client = PrintCompositeClient::FromWebContents(web_contents());
+    DCHECK(client);
+
+    client->DoComposite(
+        params.metafile_data_handle, params.data_size,
+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,
+                       weak_ptr_factory_.GetWeakPtr(),
+                       params.expected_pages_count, params.preview_request_id));
+  } else {
+    NotifyUIPreviewDocumentReady(
+        params.expected_pages_count, params.preview_request_id,
+        GetDataFromHandle(params.metafile_data_handle, params.data_size));
+  }
 }
 
 void PrintPreviewMessageHandler::OnPrintPreviewFailed(int document_cookie) {
@@ -214,6 +228,65 @@ void PrintPreviewMessageHandler::OnSetOptionsFromDocument(
   print_preview_ui->OnSetOptionsFromDocument(params);
 }
 
+void PrintPreviewMessageHandler::NotifyUIPreviewPageReady(
+    int page_number,
+    int request_id,
+    scoped_refptr<base::RefCountedBytes> data_bytes) {
+  DCHECK(data_bytes);
+
+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
+  if (!print_preview_ui)
+    return;
+  print_preview_ui->SetPrintPreviewDataForIndex(page_number,
+                                                std::move(data_bytes));
+  print_preview_ui->OnDidPreviewPage(page_number, request_id);
+}
+
+void PrintPreviewMessageHandler::NotifyUIPreviewDocumentReady(
+    int page_count,
+    int request_id,
+    scoped_refptr<base::RefCountedBytes> data_bytes) {
+  if (!data_bytes || !data_bytes->size())
+    return;
+
+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
+  if (!print_preview_ui)
+    return;
+  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,
+                                                std::move(data_bytes));
+  print_preview_ui->OnPreviewDataIsAvailable(page_count, request_id);
+}
+
+void PrintPreviewMessageHandler::OnCompositePdfPageDone(
+    int page_number,
+    int request_id,
+    mojom::PdfCompositor::Status status,
+    mojo::ScopedSharedBufferHandle handle) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  if (status != mojom::PdfCompositor::Status::SUCCESS) {
+    DLOG(ERROR) << ""Compositing pdf failed with error "" << status;
+    return;
+  }
+  NotifyUIPreviewPageReady(
+      page_number, request_id,
+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));
+}
+
+void PrintPreviewMessageHandler::OnCompositePdfDocumentDone(
+    int page_count,
+    int request_id,
+    mojom::PdfCompositor::Status status,
+    mojo::ScopedSharedBufferHandle handle) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  if (status != mojom::PdfCompositor::Status::SUCCESS) {
+    DLOG(ERROR) << ""Compositing pdf failed with error "" << status;
+    return;
+  }
+  NotifyUIPreviewDocumentReady(
+      page_count, request_id,
+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));
+}
+
 bool PrintPreviewMessageHandler::OnMessageReceived(
     const IPC::Message& message,
     content::RenderFrameHost* render_frame_host) {
@@ -231,8 +304,7 @@ bool PrintPreviewMessageHandler::OnMessageReceived(
   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)
     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,
                         OnDidGetPreviewPageCount)
-    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,
-                        OnDidPreviewPage)
+    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)
     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,
                         OnMetafileReadyForPrinting)
     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,",Chrome,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,896aab1971cb86907e97ea09726b3872fbfde09a,1," bool PrintPreviewMessageHandler::OnMessageReceived(
     const IPC::Message& message,
     content::RenderFrameHost* render_frame_host) {
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP_WITH_PARAM(PrintPreviewMessageHandler, message,
                                   render_frame_host)
    IPC_MESSAGE_HANDLER(PrintHostMsg_RequestPrintPreview,
                        OnRequestPrintPreview)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  if (handled)
    return true;

  handled = true;
   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)
     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,
                         OnDidGetPreviewPageCount)
//flaw_line_below:
    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,
//flaw_line_below:
                        OnDidPreviewPage)
//fix_flaw_line_below:
//    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)
     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,
                         OnMetafileReadyForPrinting)
     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,
                        OnPrintPreviewFailed)
    IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetDefaultPageLayout,
                        OnDidGetDefaultPageLayout)
    IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewCancelled,
                        OnPrintPreviewCancelled)
    IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewInvalidPrinterSettings,
                        OnInvalidPrinterSettings)
    IPC_MESSAGE_HANDLER(PrintHostMsg_SetOptionsFromDocument,
                        OnSetOptionsFromDocument)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  return handled;
}
"
8032,185768,,Remote,Not required,,CVE-2015-1300,https://www.cvedetails.com/cve/CVE-2015-1300/,CWE-254,Low,Partial,,,2015-09-03,5.0,"The FrameFetchContext::updateTimingInfoForIFrameNavigation function in core/loader/FrameFetchContext.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not properly restrict the availability of IFRAME Resource Timing API times, which allows remote attackers to obtain sensitive information via crafted JavaScript code that leverages a history.back call.",2016-12-21,+Info ,14,https://github.com/chromium/chromium/commit/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,"Use pdf compositor service for printing when OOPIF is enabled

When OOPIF is enabled (by site-per-process flag or
top-document-isolation feature), use the pdf compositor service for
converting PaintRecord to PDF on renderers.

In the future, this will make compositing PDF from multiple renderers
possible.

TBR=jzfeng@chromium.org
BUG=455764

Change-Id: I3c28f03f4358e4228239fe1a33384f85e7716e8f
Reviewed-on: https://chromium-review.googlesource.com/699765
Commit-Queue: Wei Li <weili@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Cr-Commit-Position: refs/heads/master@{#511616}",8,chrome/browser/printing/print_preview_message_handler.cc,"{""sha"": ""78193d61b9f59cdc78ed504e7a6939379d4f52d5"", ""filename"": ""chrome/browser/chrome_content_browser_manifest_overlay.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chrome_content_browser_manifest_overlay.json?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -44,6 +44,7 @@\n         \""local_state\"": [ \""pref_client\"" ],\n         \""nacl_broker\"": [ \""browser\"" ],\n         \""nacl_loader\"": [ \""browser\"" ],\n+        \""pdf_compositor\"": [ \""compositor\"" ],\n         \""profile_import\"": [ \""import\"" ],\n         \""profiling\"": [ \""profiling\"" ],\n         \""proxy_resolver\"": [ \""factory\"" ],""}<_**next**_>{""sha"": ""449ec7465b049d91941d3413bafcb8ee1904d417"", ""filename"": ""chrome/browser/printing/print_preview_dialog_controller.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_dialog_controller.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -29,6 +29,7 @@\n #include \""chrome/common/chrome_paths.h\""\n #include \""chrome/common/url_constants.h\""\n #include \""components/guest_view/browser/guest_view_base.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/web_modal/web_contents_modal_dialog_host.h\""\n #include \""content/public/browser/host_zoom_map.h\""\n #include \""content/public/browser/navigation_controller.h\""\n@@ -376,6 +377,7 @@ WebContents* PrintPreviewDialogController::CreatePrintPreviewDialog(\n   content::HostZoomMap::Get(preview_dialog->GetSiteInstance())\n       ->SetZoomLevelForHostAndScheme(print_url.scheme(), print_url.host(), 0);\n   PrintViewManager::CreateForWebContents(preview_dialog);\n+  CreateCompositeClientIfNeeded(preview_dialog, true /* for_preview */);\n   extensions::ChromeExtensionWebContentsObserver::CreateForWebContents(\n       preview_dialog);\n ""}<_**next**_>{""sha"": ""cda7ad2e7612be69842877448291d3be54317a64"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.cc"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 22, ""changes"": 116, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -14,18 +14,22 @@\n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/ref_counted_memory.h\""\n #include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n #include \""chrome/browser/browser_process.h\""\n #include \""chrome/browser/printing/print_job_manager.h\""\n #include \""chrome/browser/printing/print_preview_dialog_controller.h\""\n #include \""chrome/browser/printing/print_view_manager.h\""\n #include \""chrome/browser/printing/printer_query.h\""\n #include \""chrome/browser/ui/webui/print_preview/print_preview_ui.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""content/public/browser/web_ui.h\""\n #include \""printing/page_size_margins.h\""\n #include \""printing/print_job_constants.h\""\n+#include \""printing/print_settings.h\""\n \n using content::BrowserThread;\n using content::WebContents;\n@@ -69,7 +73,7 @@ scoped_refptr<base::RefCountedBytes> GetDataFromHandle(\n \n PrintPreviewMessageHandler::PrintPreviewMessageHandler(\n     WebContents* web_contents)\n-    : content::WebContentsObserver(web_contents) {\n+    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {\n   DCHECK(web_contents);\n }\n \n@@ -129,13 +133,21 @@ void PrintPreviewMessageHandler::OnDidPreviewPage(\n   if (!print_preview_ui)\n     return;\n \n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  DCHECK(data_bytes);\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    // Use utility process to convert skia metafile to pdf.\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,\n+                       weak_ptr_factory_.GetWeakPtr(), params.page_number,\n+                       params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewPageReady(\n+        page_number, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n@@ -152,18 +164,20 @@ void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n   if (!print_preview_ui)\n     return;\n \n-  // TODO(joth): This seems like a good match for using RefCountedStaticMemory\n-  // to avoid the memory copy, but the SetPrintPreviewData call chain below\n-  // needs updating to accept the RefCountedMemory* base class.\n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  if (!data_bytes || !data_bytes->size())\n-    return;\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnPreviewDataIsAvailable(\n-      params.expected_pages_count, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,\n+                       weak_ptr_factory_.GetWeakPtr(),\n+                       params.expected_pages_count, params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewDocumentReady(\n+        params.expected_pages_count, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnPrintPreviewFailed(int document_cookie) {\n@@ -214,6 +228,65 @@ void PrintPreviewMessageHandler::OnSetOptionsFromDocument(\n   print_preview_ui->OnSetOptionsFromDocument(params);\n }\n \n+void PrintPreviewMessageHandler::NotifyUIPreviewPageReady(\n+    int page_number,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  DCHECK(data_bytes);\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnDidPreviewPage(page_number, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::NotifyUIPreviewDocumentReady(\n+    int page_count,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  if (!data_bytes || !data_bytes->size())\n+    return;\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnPreviewDataIsAvailable(page_count, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfPageDone(\n+    int page_number,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewPageReady(\n+      page_number, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfDocumentDone(\n+    int page_count,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewDocumentReady(\n+      page_count, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n bool PrintPreviewMessageHandler::OnMessageReceived(\n     const IPC::Message& message,\n     content::RenderFrameHost* render_frame_host) {\n@@ -231,8 +304,7 @@ bool PrintPreviewMessageHandler::OnMessageReceived(\n   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,\n                         OnDidGetPreviewPageCount)\n-    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,\n-                        OnDidPreviewPage)\n+    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,\n                         OnMetafileReadyForPrinting)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,""}<_**next**_>{""sha"": ""71ca9d5bb1ee142ed3dbbfaa34cd8ab5d3018002"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.h"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,6 +7,9 @@\n \n #include \""base/compiler_specific.h\""\n #include \""base/macros.h\""\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/weak_ptr.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/web_contents_observer.h\""\n #include \""content/public/browser/web_contents_user_data.h\""\n \n@@ -70,6 +73,27 @@ class PrintPreviewMessageHandler\n   void OnSetOptionsFromDocument(\n       const PrintHostMsg_SetOptionsFromDocument_Params& params);\n \n+  void NotifyUIPreviewPageReady(\n+      int page_number,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+  void NotifyUIPreviewDocumentReady(\n+      int page_count,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+\n+  // Callbacks for pdf compositor client.\n+  void OnCompositePdfPageDone(int page_number,\n+                              int request_id,\n+                              mojom::PdfCompositor::Status status,\n+                              mojo::ScopedSharedBufferHandle handle);\n+  void OnCompositePdfDocumentDone(int page_count,\n+                                  int request_id,\n+                                  mojom::PdfCompositor::Status status,\n+                                  mojo::ScopedSharedBufferHandle handle);\n+\n+  base::WeakPtrFactory<PrintPreviewMessageHandler> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintPreviewMessageHandler);\n };\n ""}<_**next**_>{""sha"": ""f4fed9d2753dbd8b374dfb9b6f006cf51010d5cf"", ""filename"": ""chrome/browser/printing/print_view_manager_base.cc"", ""status"": ""modified"", ""additions"": 64, ""deletions"": 25, ""changes"": 89, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -11,6 +11,7 @@\n #include \""base/bind.h\""\n #include \""base/location.h\""\n #include \""base/memory/ptr_util.h\""\n+#include \""base/memory/shared_memory.h\""\n #include \""base/message_loop/message_loop.h\""\n #include \""base/run_loop.h\""\n #include \""base/single_thread_task_runner.h\""\n@@ -28,6 +29,8 @@\n #include \""chrome/common/pref_names.h\""\n #include \""chrome/grit/generated_resources.h\""\n #include \""components/prefs/pref_service.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/notification_details.h\""\n@@ -36,8 +39,10 @@\n #include \""content/public/browser/render_frame_host.h\""\n #include \""content/public/browser/render_view_host.h\""\n #include \""content/public/browser/web_contents.h\""\n+#include \""mojo/public/cpp/system/buffer.h\""\n #include \""printing/features/features.h\""\n #include \""printing/pdf_metafile_skia.h\""\n+#include \""printing/print_settings.h\""\n #include \""printing/printed_document.h\""\n #include \""ui/base/l10n/l10n_util.h\""\n \n@@ -78,7 +83,8 @@ PrintViewManagerBase::PrintViewManagerBase(content::WebContents* web_contents)\n #if !defined(OS_MACOSX)\n       expecting_first_page_(true),\n #endif\n-      queue_(g_browser_process->print_job_manager()->queue()) {\n+      queue_(g_browser_process->print_job_manager()->queue()),\n+      weak_ptr_factory_(this) {\n   DCHECK(queue_.get());\n   Profile* profile =\n       Profile::FromBrowserContext(web_contents->GetBrowserContext());\n@@ -127,8 +133,24 @@ void PrintViewManagerBase::OnDidGetPrintedPagesCount(int cookie,\n   OpportunisticallyCreatePrintJob(cookie);\n }\n \n+void PrintViewManagerBase::OnComposePdfDone(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+\n+  UpdateForPrintedPage(\n+      params, true,\n+      PrintCompositeClient::GetShmFromMojoHandle(std::move(handle)));\n+}\n+\n void PrintViewManagerBase::OnDidPrintPage(\n-  const PrintHostMsg_DidPrintPage_Params& params) {\n+    const PrintHostMsg_DidPrintPage_Params& params) {\n+  // Ready to composite. Starting a print job.\n   if (!OpportunisticallyCreatePrintJob(params.document_cookie))\n     return;\n \n@@ -154,8 +176,18 @@ void PrintViewManagerBase::OnDidPrintPage(\n       web_contents()->Stop();\n       return;\n     }\n+\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    if (IsOopifEnabled() && !client->for_preview() &&\n+        !document->settings().is_modifiable()) {\n+      client->DoComposite(\n+          params.metafile_data_handle, params.data_size,\n+          base::BindOnce(&PrintViewManagerBase::OnComposePdfDone,\n+                         weak_ptr_factory_.GetWeakPtr(), params));\n+      return;\n+    }\n     shared_buf =\n-        base::MakeUnique<base::SharedMemory>(params.metafile_data_handle, true);\n+        std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);\n     if (!shared_buf->Map(params.data_size)) {\n       NOTREACHED() << \""couldn't map\"";\n       web_contents()->Stop();\n@@ -170,22 +202,24 @@ void PrintViewManagerBase::OnDidPrintPage(\n     }\n   }\n \n-  std::unique_ptr<PdfMetafileSkia> metafile(\n-      new PdfMetafileSkia(SkiaDocumentType::PDF));\n-  if (metafile_must_be_valid) {\n-    if (!metafile->InitFromData(shared_buf->memory(), params.data_size)) {\n-      NOTREACHED() << \""Invalid metafile header\"";\n-      web_contents()->Stop();\n-      return;\n-    }\n-  }\n+  UpdateForPrintedPage(params, metafile_must_be_valid, std::move(shared_buf));\n+}\n+\n+void PrintViewManagerBase::UpdateForPrintedPage(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    bool has_valid_page_data,\n+    std::unique_ptr<base::SharedMemory> shared_buf) {\n+  PrintedDocument* document = print_job_->document();\n+  if (!document)\n+    return;\n \n #if defined(OS_WIN)\n   print_job_->AppendPrintedPage(params.page_number);\n-  if (metafile_must_be_valid) {\n-    scoped_refptr<base::RefCountedBytes> bytes = new base::RefCountedBytes(\n+  if (has_valid_page_data) {\n+    scoped_refptr<base::RefCountedBytes> bytes(new base::RefCountedBytes(\n         reinterpret_cast<const unsigned char*>(shared_buf->memory()),\n-        params.data_size);\n+        shared_buf->mapped_size()));\n+\n     document->DebugDumpData(bytes.get(), FILE_PATH_LITERAL(\"".pdf\""));\n \n     const auto& settings = document->settings();\n@@ -203,22 +237,27 @@ void PrintViewManagerBase::OnDidPrintPage(\n       // Update : The missing letters seem to have been caused by the same\n       // problem as https://crbug.com/659604 which was resolved. GDI printing\n       // seems to work with the fix for this bug applied.\n-      bool print_text_with_gdi = settings.print_text_with_gdi() &&\n-                                 !settings.printer_is_xps() &&\n-                                 base::FeatureList::IsEnabled(\n-                                     features::kGdiTextPrinting);\n+      bool print_text_with_gdi =\n+          settings.print_text_with_gdi() && !settings.printer_is_xps() &&\n+          base::FeatureList::IsEnabled(features::kGdiTextPrinting);\n       print_job_->StartPdfToEmfConversion(\n           bytes, params.page_size, params.content_area, print_text_with_gdi);\n     }\n   }\n #else\n+  std::unique_ptr<PdfMetafileSkia> metafile =\n+      std::make_unique<PdfMetafileSkia>(SkiaDocumentType::PDF);\n+  if (has_valid_page_data) {\n+    if (!metafile->InitFromData(shared_buf->memory(),\n+                                shared_buf->mapped_size())) {\n+      NOTREACHED() << \""Invalid metafile header\"";\n+      web_contents()->Stop();\n+      return;\n+    }\n+  }\n+\n   // Update the rendered document. It will send notifications to the listener.\n-  document->SetPage(params.page_number,\n-                    std::move(metafile),\n-#if defined(OS_WIN)\n-                    0.0f /* dummy shrink_factor */,\n-#endif\n-                    params.page_size,\n+  document->SetPage(params.page_number, std::move(metafile), params.page_size,\n                     params.content_area);\n \n   ShouldQuitFromInnerMessageLoop();""}<_**next**_>{""sha"": ""e9706e34f8c96f224196aa8ffc993b44a9247cf9"", ""filename"": ""chrome/browser/printing/print_view_manager_base.h"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 1, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -9,16 +9,23 @@\n \n #include \""base/macros.h\""\n #include \""base/memory/ref_counted.h\""\n+#include \""base/memory/weak_ptr.h\""\n #include \""base/strings/string16.h\""\n #include \""build/build_config.h\""\n #include \""components/prefs/pref_member.h\""\n #include \""components/printing/browser/print_manager.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/notification_observer.h\""\n #include \""content/public/browser/notification_registrar.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n #include \""printing/features/features.h\""\n \n struct PrintHostMsg_DidPrintPage_Params;\n \n+namespace base {\n+class SharedMemory;\n+}\n+\n namespace content {\n class RenderFrameHost;\n }\n@@ -82,9 +89,19 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   // IPC Message handlers.\n   void OnDidGetPrintedPagesCount(int cookie, int number_pages) override;\n-  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n   void OnPrintingFailed(int cookie) override;\n   void OnShowInvalidPrinterSettingsError();\n+  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n+\n+  // Handle extra tasks once a page or doc is printed.\n+  void UpdateForPrintedPage(const PrintHostMsg_DidPrintPage_Params& params,\n+                            bool has_valid_page_data,\n+                            std::unique_ptr<base::SharedMemory> shared_buf);\n+\n+  // IPC message handlers for service.\n+  void OnComposePdfDone(const PrintHostMsg_DidPrintPage_Params& params,\n+                        mojom::PdfCompositor::Status status,\n+                        mojo::ScopedSharedBufferHandle handle);\n \n   // Processes a NOTIFY_PRINT_JOB_EVENT notification.\n   void OnNotifyPrintJobEvent(const JobEventDetails& event_details);\n@@ -163,6 +180,8 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   scoped_refptr<printing::PrintQueriesQueue> queue_;\n \n+  base::WeakPtrFactory<PrintViewManagerBase> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintViewManagerBase);\n };\n ""}<_**next**_>{""sha"": ""3560d1c793977a5c2fe67253c9cf9509dbe596a1"", ""filename"": ""chrome/browser/printing/printing_init.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/printing_init.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""chrome/browser/printing/printing_init.h\""\n \n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""printing/features/features.h\""\n \n@@ -23,6 +24,7 @@ void InitializePrinting(content::WebContents* web_contents) {\n #else\n   printing::PrintViewManagerBasic::CreateForWebContents(web_contents);\n #endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)\n+  CreateCompositeClientIfNeeded(web_contents, false /* for_preview */);\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""84901e64744b737a1810f2e3c513498bfea57fb6"", ""filename"": ""chrome/browser/ui/BUILD.gn"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3475,7 +3475,10 @@ split_static_library(\""ui\"") {\n   }\n \n   if (enable_basic_printing || enable_print_preview) {\n-    deps += [ \""//printing\"" ]\n+    deps += [\n+      \""//components/printing/browser\"",\n+      \""//printing\"",\n+    ]\n     if (use_cups) {\n       configs += [ \""//printing:cups\"" ]\n     }""}<_**next**_>{""sha"": ""20c22c6758f1b3353627d510ee4cfe71ef980b8b"", ""filename"": ""chrome/utility/chrome_content_utility_client.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/utility/chrome_content_utility_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -73,7 +73,7 @@\n \n #if BUILDFLAG(ENABLE_PRINTING)\n #include \""chrome/common/chrome_content_client.h\""\n-#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""  // nogncheck\n #include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""  // nogncheck\n #endif\n ""}<_**next**_>{""sha"": ""154e773645fadb49d560d3b3aa8cb4e1f3511e43"", ""filename"": ""components/printing/browser/BUILD.gn"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,8 @@\n \n static_library(\""browser\"") {\n   sources = [\n+    \""print_composite_client.cc\"",\n+    \""print_composite_client.h\"",\n     \""print_manager.cc\"",\n     \""print_manager.h\"",\n     \""print_manager_utils.cc\"",\n@@ -17,6 +19,9 @@ static_library(\""browser\"") {\n   deps = [\n     \""//base\"",\n     \""//components/printing/common\"",\n+    \""//components/printing/service/public/cpp:client\"",\n+    \""//mojo/public/cpp/system:system\"",\n     \""//printing\"",\n+    \""//services/service_manager/public/cpp\"",\n   ]\n }""}<_**next**_>{""sha"": ""f67625c944f981351fc84c69ea9c9f156b285839"", ""filename"": ""components/printing/browser/DEPS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/DEPS?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -1,3 +1,6 @@\n include_rules = [\n+  \""+components/printing/service/public/cpp\"",\n   \""+content/public/browser\"",\n+  \""+mojo/public/cpp/system\"",\n+  \""+services/service_manager/public/cpp\"",\n ]""}<_**next**_>{""sha"": ""e105223f7f9335c2aec939ac0fe4b4a5dbdfa97b"", ""filename"": ""components/printing/browser/print_composite_client.cc"", ""status"": ""added"", ""additions"": 79, ""deletions"": 0, ""changes"": 79, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,79 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""components/printing/browser/print_composite_client.h\""\n+\n+#include <memory>\n+#include <utility>\n+\n+#include \""base/threading/thread_task_runner_handle.h\""\n+#include \""content/public/browser/browser_thread.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n+#include \""services/service_manager/public/cpp/connector.h\""\n+\n+DEFINE_WEB_CONTENTS_USER_DATA_KEY(printing::PrintCompositeClient);\n+\n+namespace printing {\n+\n+PrintCompositeClient::PrintCompositeClient(content::WebContents* web_contents)\n+    : for_preview_(false) {}\n+\n+PrintCompositeClient::~PrintCompositeClient() {}\n+\n+void PrintCompositeClient::CreateConnectorRequest() {\n+  connector_ = service_manager::Connector::Create(&connector_request_);\n+  content::ServiceManagerConnection::GetForProcess()\n+      ->GetConnector()\n+      ->BindConnectorRequest(std::move(connector_request_));\n+}\n+\n+void PrintCompositeClient::DoComposite(\n+    base::SharedMemoryHandle handle,\n+    uint32_t data_size,\n+    mojom::PdfCompositor::CompositePdfCallback callback) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  DCHECK(data_size);\n+\n+  if (!connector_)\n+    CreateConnectorRequest();\n+  Composite(connector_.get(), handle, data_size, std::move(callback),\n+            base::ThreadTaskRunnerHandle::Get());\n+}\n+\n+std::unique_ptr<base::SharedMemory> PrintCompositeClient::GetShmFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  base::SharedMemoryHandle memory_handle;\n+  size_t memory_size = 0;\n+  bool read_only_flag = false;\n+\n+  const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n+      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n+  if (result != MOJO_RESULT_OK)\n+    return nullptr;\n+  DCHECK_GT(memory_size, 0u);\n+\n+  std::unique_ptr<base::SharedMemory> shm =\n+      base::MakeUnique<base::SharedMemory>(memory_handle, true /* read_only */);\n+  if (!shm->Map(memory_size)) {\n+    DLOG(ERROR) << \""Map shared memory failed.\"";\n+    return nullptr;\n+  }\n+  return shm;\n+}\n+\n+scoped_refptr<base::RefCountedBytes>\n+PrintCompositeClient::GetDataFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  std::unique_ptr<base::SharedMemory> shm =\n+      GetShmFromMojoHandle(std::move(handle));\n+  if (!shm)\n+    return nullptr;\n+\n+  return base::MakeRefCounted<base::RefCountedBytes>(\n+      reinterpret_cast<const unsigned char*>(shm->memory()),\n+      shm->mapped_size());\n+}\n+\n+}  // namespace printing""}<_**next**_>{""sha"": ""d63b34123520f5d66dbafe7c878c84f77725a91c"", ""filename"": ""components/printing/browser/print_composite_client.h"", ""status"": ""added"", ""additions"": 49, ""deletions"": 0, ""changes"": 49, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,49 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+#define COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_client.h\""\n+#include \""content/public/browser/web_contents_observer.h\""\n+#include \""content/public/browser/web_contents_user_data.h\""\n+\n+namespace printing {\n+\n+class PrintCompositeClient\n+    : public PdfCompositorClient,\n+      public content::WebContentsUserData<PrintCompositeClient> {\n+ public:\n+  explicit PrintCompositeClient(content::WebContents* web_contents);\n+  ~PrintCompositeClient() override;\n+\n+  void DoComposite(base::SharedMemoryHandle handle,\n+                   uint32_t data_size,\n+                   mojom::PdfCompositor::CompositePdfCallback callback);\n+\n+  void set_for_preview(bool for_preview) { for_preview_ = for_preview; }\n+  bool for_preview() const { return for_preview_; }\n+\n+  // Utility functions.\n+  static std::unique_ptr<base::SharedMemory> GetShmFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+  static scoped_refptr<base::RefCountedBytes> GetDataFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+\n+ private:\n+  void CreateConnectorRequest();\n+\n+  service_manager::mojom::ConnectorRequest connector_request_;\n+  std::unique_ptr<service_manager::Connector> connector_;\n+  bool for_preview_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(PrintCompositeClient);\n+};\n+\n+}  // namespace printing\n+\n+#endif  // COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_""}<_**next**_>{""sha"": ""844fcf5bd23513e52fa2a2eb7d9d958762e11ddf"", ""filename"": ""components/printing/browser/print_manager_utils.cc"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 1, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3,11 +3,43 @@\n // found in the LICENSE file.\n \n #include \""components/printing/browser/print_manager_utils.h\""\n+\n+#include \""base/command_line.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n #include \""components/printing/common/print_messages.h\""\n+#include \""content/public/common/content_features.h\""\n+#include \""content/public/common/content_switches.h\""\n #include \""printing/print_settings.h\""\n \n namespace printing {\n \n+// A temporary flag which makes supporting both paths for OOPIF and non-OOPIF\n+// printing easier.\n+static bool g_oopif_enabled = false;\n+\n+void SetOopifEnabled() {\n+  g_oopif_enabled = true;\n+}\n+\n+bool IsOopifEnabled() {\n+  return g_oopif_enabled;\n+}\n+\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview) {\n+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n+          switches::kSitePerProcess) ||\n+      base::FeatureList::IsEnabled(features::kTopDocumentIsolation)) {\n+    // For cases need to support OOPIFs.\n+    PrintCompositeClient::CreateForWebContents(web_contents);\n+    if (for_preview) {\n+      PrintCompositeClient::FromWebContents(web_contents)\n+          ->set_for_preview(true);\n+    }\n+    SetOopifEnabled();\n+  }\n+}\n+\n void RenderParamsFromPrintSettings(const PrintSettings& settings,\n                                    PrintMsg_Print_Params* params) {\n   params->page_size = settings.page_setup_device_units().physical_size();\n@@ -32,7 +64,8 @@ void RenderParamsFromPrintSettings(const PrintSettings& settings,\n   params->display_header_footer = settings.display_header_footer();\n   params->title = settings.title();\n   params->url = settings.url();\n-  params->printed_doc_type = SkiaDocumentType::PDF;\n+  params->printed_doc_type =\n+      IsOopifEnabled() ? SkiaDocumentType::MSKP : SkiaDocumentType::PDF;\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""5b2b62a7dbf5599fbb51940906b2ed4697c5d0a2"", ""filename"": ""components/printing/browser/print_manager_utils.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,10 +7,22 @@\n \n struct PrintMsg_Print_Params;\n \n+namespace content {\n+class WebContents;\n+}\n+\n namespace printing {\n \n class PrintSettings;\n \n+void SetOopifEnabled(bool enabled);\n+bool IsOopifEnabled();\n+\n+// Check on the current feature settings to decide whether we need to\n+// create a PDF compositor client for this |web_contents|.\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview);\n+\n // Converts given settings to Print_Params and stores them in the output\n // parameter |params|.\n void RenderParamsFromPrintSettings(const PrintSettings& settings,""}<_**next**_>{""sha"": ""231fe97661ab55076dcd33cbc9dc12eeb29cbe83"", ""filename"": ""headless/lib/browser/headless_web_contents_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/headless/lib/browser/headless_web_contents_impl.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -322,6 +322,7 @@ HeadlessWebContentsImpl::HeadlessWebContentsImpl(\n       weak_ptr_factory_(this) {\n #if BUILDFLAG(ENABLE_BASIC_PRINTING) && !defined(CHROME_MULTIPLE_DLL_CHILD)\n   HeadlessPrintManager::CreateForWebContents(web_contents);\n+// TODO(weili): Add support for printing OOPIFs.\n #endif\n   web_contents->GetMutableRendererPrefs()->accept_languages =\n       browser_context->options()->accept_language();""}"," void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(
    const PrintHostMsg_DidPreviewDocument_Params& params) {
  StopWorker(params.document_cookie);

  if (params.expected_pages_count <= 0) {
    NOTREACHED();
    return;
  }

  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
   if (!print_preview_ui)
     return;
 
  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {
    auto* client = PrintCompositeClient::FromWebContents(web_contents());
    DCHECK(client);

    client->DoComposite(
        params.metafile_data_handle, params.data_size,
        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,
                       weak_ptr_factory_.GetWeakPtr(),
                       params.expected_pages_count, params.preview_request_id));
  } else {
    NotifyUIPreviewDocumentReady(
        params.expected_pages_count, params.preview_request_id,
        GetDataFromHandle(params.metafile_data_handle, params.data_size));
  }
 }
"," void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(
    const PrintHostMsg_DidPreviewDocument_Params& params) {
  StopWorker(params.document_cookie);

  if (params.expected_pages_count <= 0) {
    NOTREACHED();
    return;
  }

  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
   if (!print_preview_ui)
     return;
 
  scoped_refptr<base::RefCountedBytes> data_bytes =
      GetDataFromHandle(params.metafile_data_handle, params.data_size);
  if (!data_bytes || !data_bytes->size())
    return;
  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,
                                                std::move(data_bytes));
  print_preview_ui->OnPreviewDataIsAvailable(
      params.expected_pages_count, params.preview_request_id);
 }
",C,"  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {
    auto* client = PrintCompositeClient::FromWebContents(web_contents());
    DCHECK(client);

    client->DoComposite(
        params.metafile_data_handle, params.data_size,
        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,
                       weak_ptr_factory_.GetWeakPtr(),
                       params.expected_pages_count, params.preview_request_id));
  } else {
    NotifyUIPreviewDocumentReady(
        params.expected_pages_count, params.preview_request_id,
        GetDataFromHandle(params.metafile_data_handle, params.data_size));
  }
","  scoped_refptr<base::RefCountedBytes> data_bytes =
      GetDataFromHandle(params.metafile_data_handle, params.data_size);
  if (!data_bytes || !data_bytes->size())
    return;
  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,
                                                std::move(data_bytes));
  print_preview_ui->OnPreviewDataIsAvailable(
      params.expected_pages_count, params.preview_request_id);
",,"@@ -14,18 +14,22 @@
 #include ""base/memory/ref_counted.h""
 #include ""base/memory/ref_counted_memory.h""
 #include ""base/memory/shared_memory.h""
+#include ""base/memory/shared_memory_handle.h""
 #include ""chrome/browser/browser_process.h""
 #include ""chrome/browser/printing/print_job_manager.h""
 #include ""chrome/browser/printing/print_preview_dialog_controller.h""
 #include ""chrome/browser/printing/print_view_manager.h""
 #include ""chrome/browser/printing/printer_query.h""
 #include ""chrome/browser/ui/webui/print_preview/print_preview_ui.h""
+#include ""components/printing/browser/print_composite_client.h""
+#include ""components/printing/browser/print_manager_utils.h""
 #include ""components/printing/common/print_messages.h""
 #include ""content/public/browser/browser_thread.h""
 #include ""content/public/browser/web_contents.h""
 #include ""content/public/browser/web_ui.h""
 #include ""printing/page_size_margins.h""
 #include ""printing/print_job_constants.h""
+#include ""printing/print_settings.h""
 
 using content::BrowserThread;
 using content::WebContents;
@@ -69,7 +73,7 @@ scoped_refptr<base::RefCountedBytes> GetDataFromHandle(
 
 PrintPreviewMessageHandler::PrintPreviewMessageHandler(
     WebContents* web_contents)
-    : content::WebContentsObserver(web_contents) {
+    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {
   DCHECK(web_contents);
 }
 
@@ -129,13 +133,21 @@ void PrintPreviewMessageHandler::OnDidPreviewPage(
   if (!print_preview_ui)
     return;
 
-  scoped_refptr<base::RefCountedBytes> data_bytes =
-      GetDataFromHandle(params.metafile_data_handle, params.data_size);
-  DCHECK(data_bytes);
-
-  print_preview_ui->SetPrintPreviewDataForIndex(page_number,
-                                                std::move(data_bytes));
-  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);
+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {
+    auto* client = PrintCompositeClient::FromWebContents(web_contents());
+    DCHECK(client);
+
+    // Use utility process to convert skia metafile to pdf.
+    client->DoComposite(
+        params.metafile_data_handle, params.data_size,
+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,
+                       weak_ptr_factory_.GetWeakPtr(), params.page_number,
+                       params.preview_request_id));
+  } else {
+    NotifyUIPreviewPageReady(
+        page_number, params.preview_request_id,
+        GetDataFromHandle(params.metafile_data_handle, params.data_size));
+  }
 }
 
 void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(
@@ -152,18 +164,20 @@ void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(
   if (!print_preview_ui)
     return;
 
-  // TODO(joth): This seems like a good match for using RefCountedStaticMemory
-  // to avoid the memory copy, but the SetPrintPreviewData call chain below
-  // needs updating to accept the RefCountedMemory* base class.
-  scoped_refptr<base::RefCountedBytes> data_bytes =
-      GetDataFromHandle(params.metafile_data_handle, params.data_size);
-  if (!data_bytes || !data_bytes->size())
-    return;
-
-  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,
-                                                std::move(data_bytes));
-  print_preview_ui->OnPreviewDataIsAvailable(
-      params.expected_pages_count, params.preview_request_id);
+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {
+    auto* client = PrintCompositeClient::FromWebContents(web_contents());
+    DCHECK(client);
+
+    client->DoComposite(
+        params.metafile_data_handle, params.data_size,
+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,
+                       weak_ptr_factory_.GetWeakPtr(),
+                       params.expected_pages_count, params.preview_request_id));
+  } else {
+    NotifyUIPreviewDocumentReady(
+        params.expected_pages_count, params.preview_request_id,
+        GetDataFromHandle(params.metafile_data_handle, params.data_size));
+  }
 }
 
 void PrintPreviewMessageHandler::OnPrintPreviewFailed(int document_cookie) {
@@ -214,6 +228,65 @@ void PrintPreviewMessageHandler::OnSetOptionsFromDocument(
   print_preview_ui->OnSetOptionsFromDocument(params);
 }
 
+void PrintPreviewMessageHandler::NotifyUIPreviewPageReady(
+    int page_number,
+    int request_id,
+    scoped_refptr<base::RefCountedBytes> data_bytes) {
+  DCHECK(data_bytes);
+
+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
+  if (!print_preview_ui)
+    return;
+  print_preview_ui->SetPrintPreviewDataForIndex(page_number,
+                                                std::move(data_bytes));
+  print_preview_ui->OnDidPreviewPage(page_number, request_id);
+}
+
+void PrintPreviewMessageHandler::NotifyUIPreviewDocumentReady(
+    int page_count,
+    int request_id,
+    scoped_refptr<base::RefCountedBytes> data_bytes) {
+  if (!data_bytes || !data_bytes->size())
+    return;
+
+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
+  if (!print_preview_ui)
+    return;
+  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,
+                                                std::move(data_bytes));
+  print_preview_ui->OnPreviewDataIsAvailable(page_count, request_id);
+}
+
+void PrintPreviewMessageHandler::OnCompositePdfPageDone(
+    int page_number,
+    int request_id,
+    mojom::PdfCompositor::Status status,
+    mojo::ScopedSharedBufferHandle handle) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  if (status != mojom::PdfCompositor::Status::SUCCESS) {
+    DLOG(ERROR) << ""Compositing pdf failed with error "" << status;
+    return;
+  }
+  NotifyUIPreviewPageReady(
+      page_number, request_id,
+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));
+}
+
+void PrintPreviewMessageHandler::OnCompositePdfDocumentDone(
+    int page_count,
+    int request_id,
+    mojom::PdfCompositor::Status status,
+    mojo::ScopedSharedBufferHandle handle) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  if (status != mojom::PdfCompositor::Status::SUCCESS) {
+    DLOG(ERROR) << ""Compositing pdf failed with error "" << status;
+    return;
+  }
+  NotifyUIPreviewDocumentReady(
+      page_count, request_id,
+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));
+}
+
 bool PrintPreviewMessageHandler::OnMessageReceived(
     const IPC::Message& message,
     content::RenderFrameHost* render_frame_host) {
@@ -231,8 +304,7 @@ bool PrintPreviewMessageHandler::OnMessageReceived(
   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)
     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,
                         OnDidGetPreviewPageCount)
-    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,
-                        OnDidPreviewPage)
+    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)
     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,
                         OnMetafileReadyForPrinting)
     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,",Chrome,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,896aab1971cb86907e97ea09726b3872fbfde09a,1," void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(
    const PrintHostMsg_DidPreviewDocument_Params& params) {
  // Always try to stop the worker.
  StopWorker(params.document_cookie);

  if (params.expected_pages_count <= 0) {
    NOTREACHED();
    return;
  }

  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
   if (!print_preview_ui)
     return;
 
//flaw_line_below:
  // TODO(joth): This seems like a good match for using RefCountedStaticMemory
//flaw_line_below:
  // to avoid the memory copy, but the SetPrintPreviewData call chain below
//flaw_line_below:
  // needs updating to accept the RefCountedMemory* base class.
//flaw_line_below:
  scoped_refptr<base::RefCountedBytes> data_bytes =
//flaw_line_below:
      GetDataFromHandle(params.metafile_data_handle, params.data_size);
//flaw_line_below:
  if (!data_bytes || !data_bytes->size())
//flaw_line_below:
    return;
//flaw_line_below:

//flaw_line_below:
  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,
//flaw_line_below:
                                                std::move(data_bytes));
//flaw_line_below:
  print_preview_ui->OnPreviewDataIsAvailable(
//flaw_line_below:
      params.expected_pages_count, params.preview_request_id);
//fix_flaw_line_below:
//  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {
//fix_flaw_line_below:
//    auto* client = PrintCompositeClient::FromWebContents(web_contents());
//fix_flaw_line_below:
//    DCHECK(client);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    client->DoComposite(
//fix_flaw_line_below:
//        params.metafile_data_handle, params.data_size,
//fix_flaw_line_below:
//        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,
//fix_flaw_line_below:
//                       weak_ptr_factory_.GetWeakPtr(),
//fix_flaw_line_below:
//                       params.expected_pages_count, params.preview_request_id));
//fix_flaw_line_below:
//  } else {
//fix_flaw_line_below:
//    NotifyUIPreviewDocumentReady(
//fix_flaw_line_below:
//        params.expected_pages_count, params.preview_request_id,
//fix_flaw_line_below:
//        GetDataFromHandle(params.metafile_data_handle, params.data_size));
//fix_flaw_line_below:
//  }
 }
"
8033,185769,,Remote,Not required,,CVE-2015-1300,https://www.cvedetails.com/cve/CVE-2015-1300/,CWE-254,Low,Partial,,,2015-09-03,5.0,"The FrameFetchContext::updateTimingInfoForIFrameNavigation function in core/loader/FrameFetchContext.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not properly restrict the availability of IFRAME Resource Timing API times, which allows remote attackers to obtain sensitive information via crafted JavaScript code that leverages a history.back call.",2016-12-21,+Info ,1,https://github.com/chromium/chromium/commit/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,"Use pdf compositor service for printing when OOPIF is enabled

When OOPIF is enabled (by site-per-process flag or
top-document-isolation feature), use the pdf compositor service for
converting PaintRecord to PDF on renderers.

In the future, this will make compositing PDF from multiple renderers
possible.

TBR=jzfeng@chromium.org
BUG=455764

Change-Id: I3c28f03f4358e4228239fe1a33384f85e7716e8f
Reviewed-on: https://chromium-review.googlesource.com/699765
Commit-Queue: Wei Li <weili@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Cr-Commit-Position: refs/heads/master@{#511616}",1,chrome/browser/printing/print_preview_message_handler.cc,"{""sha"": ""78193d61b9f59cdc78ed504e7a6939379d4f52d5"", ""filename"": ""chrome/browser/chrome_content_browser_manifest_overlay.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chrome_content_browser_manifest_overlay.json?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -44,6 +44,7 @@\n         \""local_state\"": [ \""pref_client\"" ],\n         \""nacl_broker\"": [ \""browser\"" ],\n         \""nacl_loader\"": [ \""browser\"" ],\n+        \""pdf_compositor\"": [ \""compositor\"" ],\n         \""profile_import\"": [ \""import\"" ],\n         \""profiling\"": [ \""profiling\"" ],\n         \""proxy_resolver\"": [ \""factory\"" ],""}<_**next**_>{""sha"": ""449ec7465b049d91941d3413bafcb8ee1904d417"", ""filename"": ""chrome/browser/printing/print_preview_dialog_controller.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_dialog_controller.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -29,6 +29,7 @@\n #include \""chrome/common/chrome_paths.h\""\n #include \""chrome/common/url_constants.h\""\n #include \""components/guest_view/browser/guest_view_base.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/web_modal/web_contents_modal_dialog_host.h\""\n #include \""content/public/browser/host_zoom_map.h\""\n #include \""content/public/browser/navigation_controller.h\""\n@@ -376,6 +377,7 @@ WebContents* PrintPreviewDialogController::CreatePrintPreviewDialog(\n   content::HostZoomMap::Get(preview_dialog->GetSiteInstance())\n       ->SetZoomLevelForHostAndScheme(print_url.scheme(), print_url.host(), 0);\n   PrintViewManager::CreateForWebContents(preview_dialog);\n+  CreateCompositeClientIfNeeded(preview_dialog, true /* for_preview */);\n   extensions::ChromeExtensionWebContentsObserver::CreateForWebContents(\n       preview_dialog);\n ""}<_**next**_>{""sha"": ""cda7ad2e7612be69842877448291d3be54317a64"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.cc"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 22, ""changes"": 116, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -14,18 +14,22 @@\n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/ref_counted_memory.h\""\n #include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n #include \""chrome/browser/browser_process.h\""\n #include \""chrome/browser/printing/print_job_manager.h\""\n #include \""chrome/browser/printing/print_preview_dialog_controller.h\""\n #include \""chrome/browser/printing/print_view_manager.h\""\n #include \""chrome/browser/printing/printer_query.h\""\n #include \""chrome/browser/ui/webui/print_preview/print_preview_ui.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""content/public/browser/web_ui.h\""\n #include \""printing/page_size_margins.h\""\n #include \""printing/print_job_constants.h\""\n+#include \""printing/print_settings.h\""\n \n using content::BrowserThread;\n using content::WebContents;\n@@ -69,7 +73,7 @@ scoped_refptr<base::RefCountedBytes> GetDataFromHandle(\n \n PrintPreviewMessageHandler::PrintPreviewMessageHandler(\n     WebContents* web_contents)\n-    : content::WebContentsObserver(web_contents) {\n+    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {\n   DCHECK(web_contents);\n }\n \n@@ -129,13 +133,21 @@ void PrintPreviewMessageHandler::OnDidPreviewPage(\n   if (!print_preview_ui)\n     return;\n \n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  DCHECK(data_bytes);\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    // Use utility process to convert skia metafile to pdf.\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,\n+                       weak_ptr_factory_.GetWeakPtr(), params.page_number,\n+                       params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewPageReady(\n+        page_number, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n@@ -152,18 +164,20 @@ void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n   if (!print_preview_ui)\n     return;\n \n-  // TODO(joth): This seems like a good match for using RefCountedStaticMemory\n-  // to avoid the memory copy, but the SetPrintPreviewData call chain below\n-  // needs updating to accept the RefCountedMemory* base class.\n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  if (!data_bytes || !data_bytes->size())\n-    return;\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnPreviewDataIsAvailable(\n-      params.expected_pages_count, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,\n+                       weak_ptr_factory_.GetWeakPtr(),\n+                       params.expected_pages_count, params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewDocumentReady(\n+        params.expected_pages_count, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnPrintPreviewFailed(int document_cookie) {\n@@ -214,6 +228,65 @@ void PrintPreviewMessageHandler::OnSetOptionsFromDocument(\n   print_preview_ui->OnSetOptionsFromDocument(params);\n }\n \n+void PrintPreviewMessageHandler::NotifyUIPreviewPageReady(\n+    int page_number,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  DCHECK(data_bytes);\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnDidPreviewPage(page_number, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::NotifyUIPreviewDocumentReady(\n+    int page_count,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  if (!data_bytes || !data_bytes->size())\n+    return;\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnPreviewDataIsAvailable(page_count, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfPageDone(\n+    int page_number,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewPageReady(\n+      page_number, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfDocumentDone(\n+    int page_count,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewDocumentReady(\n+      page_count, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n bool PrintPreviewMessageHandler::OnMessageReceived(\n     const IPC::Message& message,\n     content::RenderFrameHost* render_frame_host) {\n@@ -231,8 +304,7 @@ bool PrintPreviewMessageHandler::OnMessageReceived(\n   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,\n                         OnDidGetPreviewPageCount)\n-    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,\n-                        OnDidPreviewPage)\n+    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,\n                         OnMetafileReadyForPrinting)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,""}<_**next**_>{""sha"": ""71ca9d5bb1ee142ed3dbbfaa34cd8ab5d3018002"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.h"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,6 +7,9 @@\n \n #include \""base/compiler_specific.h\""\n #include \""base/macros.h\""\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/weak_ptr.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/web_contents_observer.h\""\n #include \""content/public/browser/web_contents_user_data.h\""\n \n@@ -70,6 +73,27 @@ class PrintPreviewMessageHandler\n   void OnSetOptionsFromDocument(\n       const PrintHostMsg_SetOptionsFromDocument_Params& params);\n \n+  void NotifyUIPreviewPageReady(\n+      int page_number,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+  void NotifyUIPreviewDocumentReady(\n+      int page_count,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+\n+  // Callbacks for pdf compositor client.\n+  void OnCompositePdfPageDone(int page_number,\n+                              int request_id,\n+                              mojom::PdfCompositor::Status status,\n+                              mojo::ScopedSharedBufferHandle handle);\n+  void OnCompositePdfDocumentDone(int page_count,\n+                                  int request_id,\n+                                  mojom::PdfCompositor::Status status,\n+                                  mojo::ScopedSharedBufferHandle handle);\n+\n+  base::WeakPtrFactory<PrintPreviewMessageHandler> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintPreviewMessageHandler);\n };\n ""}<_**next**_>{""sha"": ""f4fed9d2753dbd8b374dfb9b6f006cf51010d5cf"", ""filename"": ""chrome/browser/printing/print_view_manager_base.cc"", ""status"": ""modified"", ""additions"": 64, ""deletions"": 25, ""changes"": 89, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -11,6 +11,7 @@\n #include \""base/bind.h\""\n #include \""base/location.h\""\n #include \""base/memory/ptr_util.h\""\n+#include \""base/memory/shared_memory.h\""\n #include \""base/message_loop/message_loop.h\""\n #include \""base/run_loop.h\""\n #include \""base/single_thread_task_runner.h\""\n@@ -28,6 +29,8 @@\n #include \""chrome/common/pref_names.h\""\n #include \""chrome/grit/generated_resources.h\""\n #include \""components/prefs/pref_service.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/notification_details.h\""\n@@ -36,8 +39,10 @@\n #include \""content/public/browser/render_frame_host.h\""\n #include \""content/public/browser/render_view_host.h\""\n #include \""content/public/browser/web_contents.h\""\n+#include \""mojo/public/cpp/system/buffer.h\""\n #include \""printing/features/features.h\""\n #include \""printing/pdf_metafile_skia.h\""\n+#include \""printing/print_settings.h\""\n #include \""printing/printed_document.h\""\n #include \""ui/base/l10n/l10n_util.h\""\n \n@@ -78,7 +83,8 @@ PrintViewManagerBase::PrintViewManagerBase(content::WebContents* web_contents)\n #if !defined(OS_MACOSX)\n       expecting_first_page_(true),\n #endif\n-      queue_(g_browser_process->print_job_manager()->queue()) {\n+      queue_(g_browser_process->print_job_manager()->queue()),\n+      weak_ptr_factory_(this) {\n   DCHECK(queue_.get());\n   Profile* profile =\n       Profile::FromBrowserContext(web_contents->GetBrowserContext());\n@@ -127,8 +133,24 @@ void PrintViewManagerBase::OnDidGetPrintedPagesCount(int cookie,\n   OpportunisticallyCreatePrintJob(cookie);\n }\n \n+void PrintViewManagerBase::OnComposePdfDone(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+\n+  UpdateForPrintedPage(\n+      params, true,\n+      PrintCompositeClient::GetShmFromMojoHandle(std::move(handle)));\n+}\n+\n void PrintViewManagerBase::OnDidPrintPage(\n-  const PrintHostMsg_DidPrintPage_Params& params) {\n+    const PrintHostMsg_DidPrintPage_Params& params) {\n+  // Ready to composite. Starting a print job.\n   if (!OpportunisticallyCreatePrintJob(params.document_cookie))\n     return;\n \n@@ -154,8 +176,18 @@ void PrintViewManagerBase::OnDidPrintPage(\n       web_contents()->Stop();\n       return;\n     }\n+\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    if (IsOopifEnabled() && !client->for_preview() &&\n+        !document->settings().is_modifiable()) {\n+      client->DoComposite(\n+          params.metafile_data_handle, params.data_size,\n+          base::BindOnce(&PrintViewManagerBase::OnComposePdfDone,\n+                         weak_ptr_factory_.GetWeakPtr(), params));\n+      return;\n+    }\n     shared_buf =\n-        base::MakeUnique<base::SharedMemory>(params.metafile_data_handle, true);\n+        std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);\n     if (!shared_buf->Map(params.data_size)) {\n       NOTREACHED() << \""couldn't map\"";\n       web_contents()->Stop();\n@@ -170,22 +202,24 @@ void PrintViewManagerBase::OnDidPrintPage(\n     }\n   }\n \n-  std::unique_ptr<PdfMetafileSkia> metafile(\n-      new PdfMetafileSkia(SkiaDocumentType::PDF));\n-  if (metafile_must_be_valid) {\n-    if (!metafile->InitFromData(shared_buf->memory(), params.data_size)) {\n-      NOTREACHED() << \""Invalid metafile header\"";\n-      web_contents()->Stop();\n-      return;\n-    }\n-  }\n+  UpdateForPrintedPage(params, metafile_must_be_valid, std::move(shared_buf));\n+}\n+\n+void PrintViewManagerBase::UpdateForPrintedPage(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    bool has_valid_page_data,\n+    std::unique_ptr<base::SharedMemory> shared_buf) {\n+  PrintedDocument* document = print_job_->document();\n+  if (!document)\n+    return;\n \n #if defined(OS_WIN)\n   print_job_->AppendPrintedPage(params.page_number);\n-  if (metafile_must_be_valid) {\n-    scoped_refptr<base::RefCountedBytes> bytes = new base::RefCountedBytes(\n+  if (has_valid_page_data) {\n+    scoped_refptr<base::RefCountedBytes> bytes(new base::RefCountedBytes(\n         reinterpret_cast<const unsigned char*>(shared_buf->memory()),\n-        params.data_size);\n+        shared_buf->mapped_size()));\n+\n     document->DebugDumpData(bytes.get(), FILE_PATH_LITERAL(\"".pdf\""));\n \n     const auto& settings = document->settings();\n@@ -203,22 +237,27 @@ void PrintViewManagerBase::OnDidPrintPage(\n       // Update : The missing letters seem to have been caused by the same\n       // problem as https://crbug.com/659604 which was resolved. GDI printing\n       // seems to work with the fix for this bug applied.\n-      bool print_text_with_gdi = settings.print_text_with_gdi() &&\n-                                 !settings.printer_is_xps() &&\n-                                 base::FeatureList::IsEnabled(\n-                                     features::kGdiTextPrinting);\n+      bool print_text_with_gdi =\n+          settings.print_text_with_gdi() && !settings.printer_is_xps() &&\n+          base::FeatureList::IsEnabled(features::kGdiTextPrinting);\n       print_job_->StartPdfToEmfConversion(\n           bytes, params.page_size, params.content_area, print_text_with_gdi);\n     }\n   }\n #else\n+  std::unique_ptr<PdfMetafileSkia> metafile =\n+      std::make_unique<PdfMetafileSkia>(SkiaDocumentType::PDF);\n+  if (has_valid_page_data) {\n+    if (!metafile->InitFromData(shared_buf->memory(),\n+                                shared_buf->mapped_size())) {\n+      NOTREACHED() << \""Invalid metafile header\"";\n+      web_contents()->Stop();\n+      return;\n+    }\n+  }\n+\n   // Update the rendered document. It will send notifications to the listener.\n-  document->SetPage(params.page_number,\n-                    std::move(metafile),\n-#if defined(OS_WIN)\n-                    0.0f /* dummy shrink_factor */,\n-#endif\n-                    params.page_size,\n+  document->SetPage(params.page_number, std::move(metafile), params.page_size,\n                     params.content_area);\n \n   ShouldQuitFromInnerMessageLoop();""}<_**next**_>{""sha"": ""e9706e34f8c96f224196aa8ffc993b44a9247cf9"", ""filename"": ""chrome/browser/printing/print_view_manager_base.h"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 1, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -9,16 +9,23 @@\n \n #include \""base/macros.h\""\n #include \""base/memory/ref_counted.h\""\n+#include \""base/memory/weak_ptr.h\""\n #include \""base/strings/string16.h\""\n #include \""build/build_config.h\""\n #include \""components/prefs/pref_member.h\""\n #include \""components/printing/browser/print_manager.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/notification_observer.h\""\n #include \""content/public/browser/notification_registrar.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n #include \""printing/features/features.h\""\n \n struct PrintHostMsg_DidPrintPage_Params;\n \n+namespace base {\n+class SharedMemory;\n+}\n+\n namespace content {\n class RenderFrameHost;\n }\n@@ -82,9 +89,19 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   // IPC Message handlers.\n   void OnDidGetPrintedPagesCount(int cookie, int number_pages) override;\n-  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n   void OnPrintingFailed(int cookie) override;\n   void OnShowInvalidPrinterSettingsError();\n+  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n+\n+  // Handle extra tasks once a page or doc is printed.\n+  void UpdateForPrintedPage(const PrintHostMsg_DidPrintPage_Params& params,\n+                            bool has_valid_page_data,\n+                            std::unique_ptr<base::SharedMemory> shared_buf);\n+\n+  // IPC message handlers for service.\n+  void OnComposePdfDone(const PrintHostMsg_DidPrintPage_Params& params,\n+                        mojom::PdfCompositor::Status status,\n+                        mojo::ScopedSharedBufferHandle handle);\n \n   // Processes a NOTIFY_PRINT_JOB_EVENT notification.\n   void OnNotifyPrintJobEvent(const JobEventDetails& event_details);\n@@ -163,6 +180,8 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   scoped_refptr<printing::PrintQueriesQueue> queue_;\n \n+  base::WeakPtrFactory<PrintViewManagerBase> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintViewManagerBase);\n };\n ""}<_**next**_>{""sha"": ""3560d1c793977a5c2fe67253c9cf9509dbe596a1"", ""filename"": ""chrome/browser/printing/printing_init.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/printing_init.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""chrome/browser/printing/printing_init.h\""\n \n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""printing/features/features.h\""\n \n@@ -23,6 +24,7 @@ void InitializePrinting(content::WebContents* web_contents) {\n #else\n   printing::PrintViewManagerBasic::CreateForWebContents(web_contents);\n #endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)\n+  CreateCompositeClientIfNeeded(web_contents, false /* for_preview */);\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""84901e64744b737a1810f2e3c513498bfea57fb6"", ""filename"": ""chrome/browser/ui/BUILD.gn"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3475,7 +3475,10 @@ split_static_library(\""ui\"") {\n   }\n \n   if (enable_basic_printing || enable_print_preview) {\n-    deps += [ \""//printing\"" ]\n+    deps += [\n+      \""//components/printing/browser\"",\n+      \""//printing\"",\n+    ]\n     if (use_cups) {\n       configs += [ \""//printing:cups\"" ]\n     }""}<_**next**_>{""sha"": ""20c22c6758f1b3353627d510ee4cfe71ef980b8b"", ""filename"": ""chrome/utility/chrome_content_utility_client.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/utility/chrome_content_utility_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -73,7 +73,7 @@\n \n #if BUILDFLAG(ENABLE_PRINTING)\n #include \""chrome/common/chrome_content_client.h\""\n-#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""  // nogncheck\n #include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""  // nogncheck\n #endif\n ""}<_**next**_>{""sha"": ""154e773645fadb49d560d3b3aa8cb4e1f3511e43"", ""filename"": ""components/printing/browser/BUILD.gn"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,8 @@\n \n static_library(\""browser\"") {\n   sources = [\n+    \""print_composite_client.cc\"",\n+    \""print_composite_client.h\"",\n     \""print_manager.cc\"",\n     \""print_manager.h\"",\n     \""print_manager_utils.cc\"",\n@@ -17,6 +19,9 @@ static_library(\""browser\"") {\n   deps = [\n     \""//base\"",\n     \""//components/printing/common\"",\n+    \""//components/printing/service/public/cpp:client\"",\n+    \""//mojo/public/cpp/system:system\"",\n     \""//printing\"",\n+    \""//services/service_manager/public/cpp\"",\n   ]\n }""}<_**next**_>{""sha"": ""f67625c944f981351fc84c69ea9c9f156b285839"", ""filename"": ""components/printing/browser/DEPS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/DEPS?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -1,3 +1,6 @@\n include_rules = [\n+  \""+components/printing/service/public/cpp\"",\n   \""+content/public/browser\"",\n+  \""+mojo/public/cpp/system\"",\n+  \""+services/service_manager/public/cpp\"",\n ]""}<_**next**_>{""sha"": ""e105223f7f9335c2aec939ac0fe4b4a5dbdfa97b"", ""filename"": ""components/printing/browser/print_composite_client.cc"", ""status"": ""added"", ""additions"": 79, ""deletions"": 0, ""changes"": 79, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,79 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""components/printing/browser/print_composite_client.h\""\n+\n+#include <memory>\n+#include <utility>\n+\n+#include \""base/threading/thread_task_runner_handle.h\""\n+#include \""content/public/browser/browser_thread.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n+#include \""services/service_manager/public/cpp/connector.h\""\n+\n+DEFINE_WEB_CONTENTS_USER_DATA_KEY(printing::PrintCompositeClient);\n+\n+namespace printing {\n+\n+PrintCompositeClient::PrintCompositeClient(content::WebContents* web_contents)\n+    : for_preview_(false) {}\n+\n+PrintCompositeClient::~PrintCompositeClient() {}\n+\n+void PrintCompositeClient::CreateConnectorRequest() {\n+  connector_ = service_manager::Connector::Create(&connector_request_);\n+  content::ServiceManagerConnection::GetForProcess()\n+      ->GetConnector()\n+      ->BindConnectorRequest(std::move(connector_request_));\n+}\n+\n+void PrintCompositeClient::DoComposite(\n+    base::SharedMemoryHandle handle,\n+    uint32_t data_size,\n+    mojom::PdfCompositor::CompositePdfCallback callback) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  DCHECK(data_size);\n+\n+  if (!connector_)\n+    CreateConnectorRequest();\n+  Composite(connector_.get(), handle, data_size, std::move(callback),\n+            base::ThreadTaskRunnerHandle::Get());\n+}\n+\n+std::unique_ptr<base::SharedMemory> PrintCompositeClient::GetShmFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  base::SharedMemoryHandle memory_handle;\n+  size_t memory_size = 0;\n+  bool read_only_flag = false;\n+\n+  const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n+      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n+  if (result != MOJO_RESULT_OK)\n+    return nullptr;\n+  DCHECK_GT(memory_size, 0u);\n+\n+  std::unique_ptr<base::SharedMemory> shm =\n+      base::MakeUnique<base::SharedMemory>(memory_handle, true /* read_only */);\n+  if (!shm->Map(memory_size)) {\n+    DLOG(ERROR) << \""Map shared memory failed.\"";\n+    return nullptr;\n+  }\n+  return shm;\n+}\n+\n+scoped_refptr<base::RefCountedBytes>\n+PrintCompositeClient::GetDataFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  std::unique_ptr<base::SharedMemory> shm =\n+      GetShmFromMojoHandle(std::move(handle));\n+  if (!shm)\n+    return nullptr;\n+\n+  return base::MakeRefCounted<base::RefCountedBytes>(\n+      reinterpret_cast<const unsigned char*>(shm->memory()),\n+      shm->mapped_size());\n+}\n+\n+}  // namespace printing""}<_**next**_>{""sha"": ""d63b34123520f5d66dbafe7c878c84f77725a91c"", ""filename"": ""components/printing/browser/print_composite_client.h"", ""status"": ""added"", ""additions"": 49, ""deletions"": 0, ""changes"": 49, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,49 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+#define COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_client.h\""\n+#include \""content/public/browser/web_contents_observer.h\""\n+#include \""content/public/browser/web_contents_user_data.h\""\n+\n+namespace printing {\n+\n+class PrintCompositeClient\n+    : public PdfCompositorClient,\n+      public content::WebContentsUserData<PrintCompositeClient> {\n+ public:\n+  explicit PrintCompositeClient(content::WebContents* web_contents);\n+  ~PrintCompositeClient() override;\n+\n+  void DoComposite(base::SharedMemoryHandle handle,\n+                   uint32_t data_size,\n+                   mojom::PdfCompositor::CompositePdfCallback callback);\n+\n+  void set_for_preview(bool for_preview) { for_preview_ = for_preview; }\n+  bool for_preview() const { return for_preview_; }\n+\n+  // Utility functions.\n+  static std::unique_ptr<base::SharedMemory> GetShmFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+  static scoped_refptr<base::RefCountedBytes> GetDataFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+\n+ private:\n+  void CreateConnectorRequest();\n+\n+  service_manager::mojom::ConnectorRequest connector_request_;\n+  std::unique_ptr<service_manager::Connector> connector_;\n+  bool for_preview_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(PrintCompositeClient);\n+};\n+\n+}  // namespace printing\n+\n+#endif  // COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_""}<_**next**_>{""sha"": ""844fcf5bd23513e52fa2a2eb7d9d958762e11ddf"", ""filename"": ""components/printing/browser/print_manager_utils.cc"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 1, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3,11 +3,43 @@\n // found in the LICENSE file.\n \n #include \""components/printing/browser/print_manager_utils.h\""\n+\n+#include \""base/command_line.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n #include \""components/printing/common/print_messages.h\""\n+#include \""content/public/common/content_features.h\""\n+#include \""content/public/common/content_switches.h\""\n #include \""printing/print_settings.h\""\n \n namespace printing {\n \n+// A temporary flag which makes supporting both paths for OOPIF and non-OOPIF\n+// printing easier.\n+static bool g_oopif_enabled = false;\n+\n+void SetOopifEnabled() {\n+  g_oopif_enabled = true;\n+}\n+\n+bool IsOopifEnabled() {\n+  return g_oopif_enabled;\n+}\n+\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview) {\n+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n+          switches::kSitePerProcess) ||\n+      base::FeatureList::IsEnabled(features::kTopDocumentIsolation)) {\n+    // For cases need to support OOPIFs.\n+    PrintCompositeClient::CreateForWebContents(web_contents);\n+    if (for_preview) {\n+      PrintCompositeClient::FromWebContents(web_contents)\n+          ->set_for_preview(true);\n+    }\n+    SetOopifEnabled();\n+  }\n+}\n+\n void RenderParamsFromPrintSettings(const PrintSettings& settings,\n                                    PrintMsg_Print_Params* params) {\n   params->page_size = settings.page_setup_device_units().physical_size();\n@@ -32,7 +64,8 @@ void RenderParamsFromPrintSettings(const PrintSettings& settings,\n   params->display_header_footer = settings.display_header_footer();\n   params->title = settings.title();\n   params->url = settings.url();\n-  params->printed_doc_type = SkiaDocumentType::PDF;\n+  params->printed_doc_type =\n+      IsOopifEnabled() ? SkiaDocumentType::MSKP : SkiaDocumentType::PDF;\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""5b2b62a7dbf5599fbb51940906b2ed4697c5d0a2"", ""filename"": ""components/printing/browser/print_manager_utils.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,10 +7,22 @@\n \n struct PrintMsg_Print_Params;\n \n+namespace content {\n+class WebContents;\n+}\n+\n namespace printing {\n \n class PrintSettings;\n \n+void SetOopifEnabled(bool enabled);\n+bool IsOopifEnabled();\n+\n+// Check on the current feature settings to decide whether we need to\n+// create a PDF compositor client for this |web_contents|.\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview);\n+\n // Converts given settings to Print_Params and stores them in the output\n // parameter |params|.\n void RenderParamsFromPrintSettings(const PrintSettings& settings,""}<_**next**_>{""sha"": ""231fe97661ab55076dcd33cbc9dc12eeb29cbe83"", ""filename"": ""headless/lib/browser/headless_web_contents_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/headless/lib/browser/headless_web_contents_impl.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -322,6 +322,7 @@ HeadlessWebContentsImpl::HeadlessWebContentsImpl(\n       weak_ptr_factory_(this) {\n #if BUILDFLAG(ENABLE_BASIC_PRINTING) && !defined(CHROME_MULTIPLE_DLL_CHILD)\n   HeadlessPrintManager::CreateForWebContents(web_contents);\n+// TODO(weili): Add support for printing OOPIFs.\n #endif\n   web_contents->GetMutableRendererPrefs()->accept_languages =\n       browser_context->options()->accept_language();""}"," PrintPreviewMessageHandler::PrintPreviewMessageHandler(
     WebContents* web_contents)
    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {
   DCHECK(web_contents);
 }
"," PrintPreviewMessageHandler::PrintPreviewMessageHandler(
     WebContents* web_contents)
    : content::WebContentsObserver(web_contents) {
   DCHECK(web_contents);
 }
",C,"    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {
","    : content::WebContentsObserver(web_contents) {
",,"@@ -14,18 +14,22 @@
 #include ""base/memory/ref_counted.h""
 #include ""base/memory/ref_counted_memory.h""
 #include ""base/memory/shared_memory.h""
+#include ""base/memory/shared_memory_handle.h""
 #include ""chrome/browser/browser_process.h""
 #include ""chrome/browser/printing/print_job_manager.h""
 #include ""chrome/browser/printing/print_preview_dialog_controller.h""
 #include ""chrome/browser/printing/print_view_manager.h""
 #include ""chrome/browser/printing/printer_query.h""
 #include ""chrome/browser/ui/webui/print_preview/print_preview_ui.h""
+#include ""components/printing/browser/print_composite_client.h""
+#include ""components/printing/browser/print_manager_utils.h""
 #include ""components/printing/common/print_messages.h""
 #include ""content/public/browser/browser_thread.h""
 #include ""content/public/browser/web_contents.h""
 #include ""content/public/browser/web_ui.h""
 #include ""printing/page_size_margins.h""
 #include ""printing/print_job_constants.h""
+#include ""printing/print_settings.h""
 
 using content::BrowserThread;
 using content::WebContents;
@@ -69,7 +73,7 @@ scoped_refptr<base::RefCountedBytes> GetDataFromHandle(
 
 PrintPreviewMessageHandler::PrintPreviewMessageHandler(
     WebContents* web_contents)
-    : content::WebContentsObserver(web_contents) {
+    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {
   DCHECK(web_contents);
 }
 
@@ -129,13 +133,21 @@ void PrintPreviewMessageHandler::OnDidPreviewPage(
   if (!print_preview_ui)
     return;
 
-  scoped_refptr<base::RefCountedBytes> data_bytes =
-      GetDataFromHandle(params.metafile_data_handle, params.data_size);
-  DCHECK(data_bytes);
-
-  print_preview_ui->SetPrintPreviewDataForIndex(page_number,
-                                                std::move(data_bytes));
-  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);
+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {
+    auto* client = PrintCompositeClient::FromWebContents(web_contents());
+    DCHECK(client);
+
+    // Use utility process to convert skia metafile to pdf.
+    client->DoComposite(
+        params.metafile_data_handle, params.data_size,
+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,
+                       weak_ptr_factory_.GetWeakPtr(), params.page_number,
+                       params.preview_request_id));
+  } else {
+    NotifyUIPreviewPageReady(
+        page_number, params.preview_request_id,
+        GetDataFromHandle(params.metafile_data_handle, params.data_size));
+  }
 }
 
 void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(
@@ -152,18 +164,20 @@ void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(
   if (!print_preview_ui)
     return;
 
-  // TODO(joth): This seems like a good match for using RefCountedStaticMemory
-  // to avoid the memory copy, but the SetPrintPreviewData call chain below
-  // needs updating to accept the RefCountedMemory* base class.
-  scoped_refptr<base::RefCountedBytes> data_bytes =
-      GetDataFromHandle(params.metafile_data_handle, params.data_size);
-  if (!data_bytes || !data_bytes->size())
-    return;
-
-  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,
-                                                std::move(data_bytes));
-  print_preview_ui->OnPreviewDataIsAvailable(
-      params.expected_pages_count, params.preview_request_id);
+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {
+    auto* client = PrintCompositeClient::FromWebContents(web_contents());
+    DCHECK(client);
+
+    client->DoComposite(
+        params.metafile_data_handle, params.data_size,
+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,
+                       weak_ptr_factory_.GetWeakPtr(),
+                       params.expected_pages_count, params.preview_request_id));
+  } else {
+    NotifyUIPreviewDocumentReady(
+        params.expected_pages_count, params.preview_request_id,
+        GetDataFromHandle(params.metafile_data_handle, params.data_size));
+  }
 }
 
 void PrintPreviewMessageHandler::OnPrintPreviewFailed(int document_cookie) {
@@ -214,6 +228,65 @@ void PrintPreviewMessageHandler::OnSetOptionsFromDocument(
   print_preview_ui->OnSetOptionsFromDocument(params);
 }
 
+void PrintPreviewMessageHandler::NotifyUIPreviewPageReady(
+    int page_number,
+    int request_id,
+    scoped_refptr<base::RefCountedBytes> data_bytes) {
+  DCHECK(data_bytes);
+
+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
+  if (!print_preview_ui)
+    return;
+  print_preview_ui->SetPrintPreviewDataForIndex(page_number,
+                                                std::move(data_bytes));
+  print_preview_ui->OnDidPreviewPage(page_number, request_id);
+}
+
+void PrintPreviewMessageHandler::NotifyUIPreviewDocumentReady(
+    int page_count,
+    int request_id,
+    scoped_refptr<base::RefCountedBytes> data_bytes) {
+  if (!data_bytes || !data_bytes->size())
+    return;
+
+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
+  if (!print_preview_ui)
+    return;
+  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,
+                                                std::move(data_bytes));
+  print_preview_ui->OnPreviewDataIsAvailable(page_count, request_id);
+}
+
+void PrintPreviewMessageHandler::OnCompositePdfPageDone(
+    int page_number,
+    int request_id,
+    mojom::PdfCompositor::Status status,
+    mojo::ScopedSharedBufferHandle handle) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  if (status != mojom::PdfCompositor::Status::SUCCESS) {
+    DLOG(ERROR) << ""Compositing pdf failed with error "" << status;
+    return;
+  }
+  NotifyUIPreviewPageReady(
+      page_number, request_id,
+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));
+}
+
+void PrintPreviewMessageHandler::OnCompositePdfDocumentDone(
+    int page_count,
+    int request_id,
+    mojom::PdfCompositor::Status status,
+    mojo::ScopedSharedBufferHandle handle) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  if (status != mojom::PdfCompositor::Status::SUCCESS) {
+    DLOG(ERROR) << ""Compositing pdf failed with error "" << status;
+    return;
+  }
+  NotifyUIPreviewDocumentReady(
+      page_count, request_id,
+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));
+}
+
 bool PrintPreviewMessageHandler::OnMessageReceived(
     const IPC::Message& message,
     content::RenderFrameHost* render_frame_host) {
@@ -231,8 +304,7 @@ bool PrintPreviewMessageHandler::OnMessageReceived(
   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)
     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,
                         OnDidGetPreviewPageCount)
-    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,
-                        OnDidPreviewPage)
+    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)
     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,
                         OnMetafileReadyForPrinting)
     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,",Chrome,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,896aab1971cb86907e97ea09726b3872fbfde09a,1," PrintPreviewMessageHandler::PrintPreviewMessageHandler(
     WebContents* web_contents)
//flaw_line_below:
    : content::WebContentsObserver(web_contents) {
//fix_flaw_line_below:
//    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {
   DCHECK(web_contents);
 }
"
8034,185770,,Remote,Not required,,CVE-2015-1300,https://www.cvedetails.com/cve/CVE-2015-1300/,CWE-254,Low,Partial,,,2015-09-03,5.0,"The FrameFetchContext::updateTimingInfoForIFrameNavigation function in core/loader/FrameFetchContext.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not properly restrict the availability of IFRAME Resource Timing API times, which allows remote attackers to obtain sensitive information via crafted JavaScript code that leverages a history.back call.",2016-12-21,+Info ,42,https://github.com/chromium/chromium/commit/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,"Use pdf compositor service for printing when OOPIF is enabled

When OOPIF is enabled (by site-per-process flag or
top-document-isolation feature), use the pdf compositor service for
converting PaintRecord to PDF on renderers.

In the future, this will make compositing PDF from multiple renderers
possible.

TBR=jzfeng@chromium.org
BUG=455764

Change-Id: I3c28f03f4358e4228239fe1a33384f85e7716e8f
Reviewed-on: https://chromium-review.googlesource.com/699765
Commit-Queue: Wei Li <weili@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Cr-Commit-Position: refs/heads/master@{#511616}",24,chrome/browser/printing/print_view_manager_base.cc,"{""sha"": ""78193d61b9f59cdc78ed504e7a6939379d4f52d5"", ""filename"": ""chrome/browser/chrome_content_browser_manifest_overlay.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chrome_content_browser_manifest_overlay.json?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -44,6 +44,7 @@\n         \""local_state\"": [ \""pref_client\"" ],\n         \""nacl_broker\"": [ \""browser\"" ],\n         \""nacl_loader\"": [ \""browser\"" ],\n+        \""pdf_compositor\"": [ \""compositor\"" ],\n         \""profile_import\"": [ \""import\"" ],\n         \""profiling\"": [ \""profiling\"" ],\n         \""proxy_resolver\"": [ \""factory\"" ],""}<_**next**_>{""sha"": ""449ec7465b049d91941d3413bafcb8ee1904d417"", ""filename"": ""chrome/browser/printing/print_preview_dialog_controller.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_dialog_controller.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -29,6 +29,7 @@\n #include \""chrome/common/chrome_paths.h\""\n #include \""chrome/common/url_constants.h\""\n #include \""components/guest_view/browser/guest_view_base.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/web_modal/web_contents_modal_dialog_host.h\""\n #include \""content/public/browser/host_zoom_map.h\""\n #include \""content/public/browser/navigation_controller.h\""\n@@ -376,6 +377,7 @@ WebContents* PrintPreviewDialogController::CreatePrintPreviewDialog(\n   content::HostZoomMap::Get(preview_dialog->GetSiteInstance())\n       ->SetZoomLevelForHostAndScheme(print_url.scheme(), print_url.host(), 0);\n   PrintViewManager::CreateForWebContents(preview_dialog);\n+  CreateCompositeClientIfNeeded(preview_dialog, true /* for_preview */);\n   extensions::ChromeExtensionWebContentsObserver::CreateForWebContents(\n       preview_dialog);\n ""}<_**next**_>{""sha"": ""cda7ad2e7612be69842877448291d3be54317a64"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.cc"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 22, ""changes"": 116, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -14,18 +14,22 @@\n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/ref_counted_memory.h\""\n #include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n #include \""chrome/browser/browser_process.h\""\n #include \""chrome/browser/printing/print_job_manager.h\""\n #include \""chrome/browser/printing/print_preview_dialog_controller.h\""\n #include \""chrome/browser/printing/print_view_manager.h\""\n #include \""chrome/browser/printing/printer_query.h\""\n #include \""chrome/browser/ui/webui/print_preview/print_preview_ui.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""content/public/browser/web_ui.h\""\n #include \""printing/page_size_margins.h\""\n #include \""printing/print_job_constants.h\""\n+#include \""printing/print_settings.h\""\n \n using content::BrowserThread;\n using content::WebContents;\n@@ -69,7 +73,7 @@ scoped_refptr<base::RefCountedBytes> GetDataFromHandle(\n \n PrintPreviewMessageHandler::PrintPreviewMessageHandler(\n     WebContents* web_contents)\n-    : content::WebContentsObserver(web_contents) {\n+    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {\n   DCHECK(web_contents);\n }\n \n@@ -129,13 +133,21 @@ void PrintPreviewMessageHandler::OnDidPreviewPage(\n   if (!print_preview_ui)\n     return;\n \n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  DCHECK(data_bytes);\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    // Use utility process to convert skia metafile to pdf.\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,\n+                       weak_ptr_factory_.GetWeakPtr(), params.page_number,\n+                       params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewPageReady(\n+        page_number, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n@@ -152,18 +164,20 @@ void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n   if (!print_preview_ui)\n     return;\n \n-  // TODO(joth): This seems like a good match for using RefCountedStaticMemory\n-  // to avoid the memory copy, but the SetPrintPreviewData call chain below\n-  // needs updating to accept the RefCountedMemory* base class.\n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  if (!data_bytes || !data_bytes->size())\n-    return;\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnPreviewDataIsAvailable(\n-      params.expected_pages_count, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,\n+                       weak_ptr_factory_.GetWeakPtr(),\n+                       params.expected_pages_count, params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewDocumentReady(\n+        params.expected_pages_count, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnPrintPreviewFailed(int document_cookie) {\n@@ -214,6 +228,65 @@ void PrintPreviewMessageHandler::OnSetOptionsFromDocument(\n   print_preview_ui->OnSetOptionsFromDocument(params);\n }\n \n+void PrintPreviewMessageHandler::NotifyUIPreviewPageReady(\n+    int page_number,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  DCHECK(data_bytes);\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnDidPreviewPage(page_number, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::NotifyUIPreviewDocumentReady(\n+    int page_count,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  if (!data_bytes || !data_bytes->size())\n+    return;\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnPreviewDataIsAvailable(page_count, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfPageDone(\n+    int page_number,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewPageReady(\n+      page_number, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfDocumentDone(\n+    int page_count,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewDocumentReady(\n+      page_count, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n bool PrintPreviewMessageHandler::OnMessageReceived(\n     const IPC::Message& message,\n     content::RenderFrameHost* render_frame_host) {\n@@ -231,8 +304,7 @@ bool PrintPreviewMessageHandler::OnMessageReceived(\n   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,\n                         OnDidGetPreviewPageCount)\n-    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,\n-                        OnDidPreviewPage)\n+    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,\n                         OnMetafileReadyForPrinting)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,""}<_**next**_>{""sha"": ""71ca9d5bb1ee142ed3dbbfaa34cd8ab5d3018002"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.h"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,6 +7,9 @@\n \n #include \""base/compiler_specific.h\""\n #include \""base/macros.h\""\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/weak_ptr.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/web_contents_observer.h\""\n #include \""content/public/browser/web_contents_user_data.h\""\n \n@@ -70,6 +73,27 @@ class PrintPreviewMessageHandler\n   void OnSetOptionsFromDocument(\n       const PrintHostMsg_SetOptionsFromDocument_Params& params);\n \n+  void NotifyUIPreviewPageReady(\n+      int page_number,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+  void NotifyUIPreviewDocumentReady(\n+      int page_count,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+\n+  // Callbacks for pdf compositor client.\n+  void OnCompositePdfPageDone(int page_number,\n+                              int request_id,\n+                              mojom::PdfCompositor::Status status,\n+                              mojo::ScopedSharedBufferHandle handle);\n+  void OnCompositePdfDocumentDone(int page_count,\n+                                  int request_id,\n+                                  mojom::PdfCompositor::Status status,\n+                                  mojo::ScopedSharedBufferHandle handle);\n+\n+  base::WeakPtrFactory<PrintPreviewMessageHandler> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintPreviewMessageHandler);\n };\n ""}<_**next**_>{""sha"": ""f4fed9d2753dbd8b374dfb9b6f006cf51010d5cf"", ""filename"": ""chrome/browser/printing/print_view_manager_base.cc"", ""status"": ""modified"", ""additions"": 64, ""deletions"": 25, ""changes"": 89, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -11,6 +11,7 @@\n #include \""base/bind.h\""\n #include \""base/location.h\""\n #include \""base/memory/ptr_util.h\""\n+#include \""base/memory/shared_memory.h\""\n #include \""base/message_loop/message_loop.h\""\n #include \""base/run_loop.h\""\n #include \""base/single_thread_task_runner.h\""\n@@ -28,6 +29,8 @@\n #include \""chrome/common/pref_names.h\""\n #include \""chrome/grit/generated_resources.h\""\n #include \""components/prefs/pref_service.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/notification_details.h\""\n@@ -36,8 +39,10 @@\n #include \""content/public/browser/render_frame_host.h\""\n #include \""content/public/browser/render_view_host.h\""\n #include \""content/public/browser/web_contents.h\""\n+#include \""mojo/public/cpp/system/buffer.h\""\n #include \""printing/features/features.h\""\n #include \""printing/pdf_metafile_skia.h\""\n+#include \""printing/print_settings.h\""\n #include \""printing/printed_document.h\""\n #include \""ui/base/l10n/l10n_util.h\""\n \n@@ -78,7 +83,8 @@ PrintViewManagerBase::PrintViewManagerBase(content::WebContents* web_contents)\n #if !defined(OS_MACOSX)\n       expecting_first_page_(true),\n #endif\n-      queue_(g_browser_process->print_job_manager()->queue()) {\n+      queue_(g_browser_process->print_job_manager()->queue()),\n+      weak_ptr_factory_(this) {\n   DCHECK(queue_.get());\n   Profile* profile =\n       Profile::FromBrowserContext(web_contents->GetBrowserContext());\n@@ -127,8 +133,24 @@ void PrintViewManagerBase::OnDidGetPrintedPagesCount(int cookie,\n   OpportunisticallyCreatePrintJob(cookie);\n }\n \n+void PrintViewManagerBase::OnComposePdfDone(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+\n+  UpdateForPrintedPage(\n+      params, true,\n+      PrintCompositeClient::GetShmFromMojoHandle(std::move(handle)));\n+}\n+\n void PrintViewManagerBase::OnDidPrintPage(\n-  const PrintHostMsg_DidPrintPage_Params& params) {\n+    const PrintHostMsg_DidPrintPage_Params& params) {\n+  // Ready to composite. Starting a print job.\n   if (!OpportunisticallyCreatePrintJob(params.document_cookie))\n     return;\n \n@@ -154,8 +176,18 @@ void PrintViewManagerBase::OnDidPrintPage(\n       web_contents()->Stop();\n       return;\n     }\n+\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    if (IsOopifEnabled() && !client->for_preview() &&\n+        !document->settings().is_modifiable()) {\n+      client->DoComposite(\n+          params.metafile_data_handle, params.data_size,\n+          base::BindOnce(&PrintViewManagerBase::OnComposePdfDone,\n+                         weak_ptr_factory_.GetWeakPtr(), params));\n+      return;\n+    }\n     shared_buf =\n-        base::MakeUnique<base::SharedMemory>(params.metafile_data_handle, true);\n+        std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);\n     if (!shared_buf->Map(params.data_size)) {\n       NOTREACHED() << \""couldn't map\"";\n       web_contents()->Stop();\n@@ -170,22 +202,24 @@ void PrintViewManagerBase::OnDidPrintPage(\n     }\n   }\n \n-  std::unique_ptr<PdfMetafileSkia> metafile(\n-      new PdfMetafileSkia(SkiaDocumentType::PDF));\n-  if (metafile_must_be_valid) {\n-    if (!metafile->InitFromData(shared_buf->memory(), params.data_size)) {\n-      NOTREACHED() << \""Invalid metafile header\"";\n-      web_contents()->Stop();\n-      return;\n-    }\n-  }\n+  UpdateForPrintedPage(params, metafile_must_be_valid, std::move(shared_buf));\n+}\n+\n+void PrintViewManagerBase::UpdateForPrintedPage(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    bool has_valid_page_data,\n+    std::unique_ptr<base::SharedMemory> shared_buf) {\n+  PrintedDocument* document = print_job_->document();\n+  if (!document)\n+    return;\n \n #if defined(OS_WIN)\n   print_job_->AppendPrintedPage(params.page_number);\n-  if (metafile_must_be_valid) {\n-    scoped_refptr<base::RefCountedBytes> bytes = new base::RefCountedBytes(\n+  if (has_valid_page_data) {\n+    scoped_refptr<base::RefCountedBytes> bytes(new base::RefCountedBytes(\n         reinterpret_cast<const unsigned char*>(shared_buf->memory()),\n-        params.data_size);\n+        shared_buf->mapped_size()));\n+\n     document->DebugDumpData(bytes.get(), FILE_PATH_LITERAL(\"".pdf\""));\n \n     const auto& settings = document->settings();\n@@ -203,22 +237,27 @@ void PrintViewManagerBase::OnDidPrintPage(\n       // Update : The missing letters seem to have been caused by the same\n       // problem as https://crbug.com/659604 which was resolved. GDI printing\n       // seems to work with the fix for this bug applied.\n-      bool print_text_with_gdi = settings.print_text_with_gdi() &&\n-                                 !settings.printer_is_xps() &&\n-                                 base::FeatureList::IsEnabled(\n-                                     features::kGdiTextPrinting);\n+      bool print_text_with_gdi =\n+          settings.print_text_with_gdi() && !settings.printer_is_xps() &&\n+          base::FeatureList::IsEnabled(features::kGdiTextPrinting);\n       print_job_->StartPdfToEmfConversion(\n           bytes, params.page_size, params.content_area, print_text_with_gdi);\n     }\n   }\n #else\n+  std::unique_ptr<PdfMetafileSkia> metafile =\n+      std::make_unique<PdfMetafileSkia>(SkiaDocumentType::PDF);\n+  if (has_valid_page_data) {\n+    if (!metafile->InitFromData(shared_buf->memory(),\n+                                shared_buf->mapped_size())) {\n+      NOTREACHED() << \""Invalid metafile header\"";\n+      web_contents()->Stop();\n+      return;\n+    }\n+  }\n+\n   // Update the rendered document. It will send notifications to the listener.\n-  document->SetPage(params.page_number,\n-                    std::move(metafile),\n-#if defined(OS_WIN)\n-                    0.0f /* dummy shrink_factor */,\n-#endif\n-                    params.page_size,\n+  document->SetPage(params.page_number, std::move(metafile), params.page_size,\n                     params.content_area);\n \n   ShouldQuitFromInnerMessageLoop();""}<_**next**_>{""sha"": ""e9706e34f8c96f224196aa8ffc993b44a9247cf9"", ""filename"": ""chrome/browser/printing/print_view_manager_base.h"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 1, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -9,16 +9,23 @@\n \n #include \""base/macros.h\""\n #include \""base/memory/ref_counted.h\""\n+#include \""base/memory/weak_ptr.h\""\n #include \""base/strings/string16.h\""\n #include \""build/build_config.h\""\n #include \""components/prefs/pref_member.h\""\n #include \""components/printing/browser/print_manager.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/notification_observer.h\""\n #include \""content/public/browser/notification_registrar.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n #include \""printing/features/features.h\""\n \n struct PrintHostMsg_DidPrintPage_Params;\n \n+namespace base {\n+class SharedMemory;\n+}\n+\n namespace content {\n class RenderFrameHost;\n }\n@@ -82,9 +89,19 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   // IPC Message handlers.\n   void OnDidGetPrintedPagesCount(int cookie, int number_pages) override;\n-  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n   void OnPrintingFailed(int cookie) override;\n   void OnShowInvalidPrinterSettingsError();\n+  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n+\n+  // Handle extra tasks once a page or doc is printed.\n+  void UpdateForPrintedPage(const PrintHostMsg_DidPrintPage_Params& params,\n+                            bool has_valid_page_data,\n+                            std::unique_ptr<base::SharedMemory> shared_buf);\n+\n+  // IPC message handlers for service.\n+  void OnComposePdfDone(const PrintHostMsg_DidPrintPage_Params& params,\n+                        mojom::PdfCompositor::Status status,\n+                        mojo::ScopedSharedBufferHandle handle);\n \n   // Processes a NOTIFY_PRINT_JOB_EVENT notification.\n   void OnNotifyPrintJobEvent(const JobEventDetails& event_details);\n@@ -163,6 +180,8 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   scoped_refptr<printing::PrintQueriesQueue> queue_;\n \n+  base::WeakPtrFactory<PrintViewManagerBase> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintViewManagerBase);\n };\n ""}<_**next**_>{""sha"": ""3560d1c793977a5c2fe67253c9cf9509dbe596a1"", ""filename"": ""chrome/browser/printing/printing_init.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/printing_init.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""chrome/browser/printing/printing_init.h\""\n \n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""printing/features/features.h\""\n \n@@ -23,6 +24,7 @@ void InitializePrinting(content::WebContents* web_contents) {\n #else\n   printing::PrintViewManagerBasic::CreateForWebContents(web_contents);\n #endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)\n+  CreateCompositeClientIfNeeded(web_contents, false /* for_preview */);\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""84901e64744b737a1810f2e3c513498bfea57fb6"", ""filename"": ""chrome/browser/ui/BUILD.gn"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3475,7 +3475,10 @@ split_static_library(\""ui\"") {\n   }\n \n   if (enable_basic_printing || enable_print_preview) {\n-    deps += [ \""//printing\"" ]\n+    deps += [\n+      \""//components/printing/browser\"",\n+      \""//printing\"",\n+    ]\n     if (use_cups) {\n       configs += [ \""//printing:cups\"" ]\n     }""}<_**next**_>{""sha"": ""20c22c6758f1b3353627d510ee4cfe71ef980b8b"", ""filename"": ""chrome/utility/chrome_content_utility_client.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/utility/chrome_content_utility_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -73,7 +73,7 @@\n \n #if BUILDFLAG(ENABLE_PRINTING)\n #include \""chrome/common/chrome_content_client.h\""\n-#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""  // nogncheck\n #include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""  // nogncheck\n #endif\n ""}<_**next**_>{""sha"": ""154e773645fadb49d560d3b3aa8cb4e1f3511e43"", ""filename"": ""components/printing/browser/BUILD.gn"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,8 @@\n \n static_library(\""browser\"") {\n   sources = [\n+    \""print_composite_client.cc\"",\n+    \""print_composite_client.h\"",\n     \""print_manager.cc\"",\n     \""print_manager.h\"",\n     \""print_manager_utils.cc\"",\n@@ -17,6 +19,9 @@ static_library(\""browser\"") {\n   deps = [\n     \""//base\"",\n     \""//components/printing/common\"",\n+    \""//components/printing/service/public/cpp:client\"",\n+    \""//mojo/public/cpp/system:system\"",\n     \""//printing\"",\n+    \""//services/service_manager/public/cpp\"",\n   ]\n }""}<_**next**_>{""sha"": ""f67625c944f981351fc84c69ea9c9f156b285839"", ""filename"": ""components/printing/browser/DEPS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/DEPS?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -1,3 +1,6 @@\n include_rules = [\n+  \""+components/printing/service/public/cpp\"",\n   \""+content/public/browser\"",\n+  \""+mojo/public/cpp/system\"",\n+  \""+services/service_manager/public/cpp\"",\n ]""}<_**next**_>{""sha"": ""e105223f7f9335c2aec939ac0fe4b4a5dbdfa97b"", ""filename"": ""components/printing/browser/print_composite_client.cc"", ""status"": ""added"", ""additions"": 79, ""deletions"": 0, ""changes"": 79, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,79 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""components/printing/browser/print_composite_client.h\""\n+\n+#include <memory>\n+#include <utility>\n+\n+#include \""base/threading/thread_task_runner_handle.h\""\n+#include \""content/public/browser/browser_thread.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n+#include \""services/service_manager/public/cpp/connector.h\""\n+\n+DEFINE_WEB_CONTENTS_USER_DATA_KEY(printing::PrintCompositeClient);\n+\n+namespace printing {\n+\n+PrintCompositeClient::PrintCompositeClient(content::WebContents* web_contents)\n+    : for_preview_(false) {}\n+\n+PrintCompositeClient::~PrintCompositeClient() {}\n+\n+void PrintCompositeClient::CreateConnectorRequest() {\n+  connector_ = service_manager::Connector::Create(&connector_request_);\n+  content::ServiceManagerConnection::GetForProcess()\n+      ->GetConnector()\n+      ->BindConnectorRequest(std::move(connector_request_));\n+}\n+\n+void PrintCompositeClient::DoComposite(\n+    base::SharedMemoryHandle handle,\n+    uint32_t data_size,\n+    mojom::PdfCompositor::CompositePdfCallback callback) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  DCHECK(data_size);\n+\n+  if (!connector_)\n+    CreateConnectorRequest();\n+  Composite(connector_.get(), handle, data_size, std::move(callback),\n+            base::ThreadTaskRunnerHandle::Get());\n+}\n+\n+std::unique_ptr<base::SharedMemory> PrintCompositeClient::GetShmFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  base::SharedMemoryHandle memory_handle;\n+  size_t memory_size = 0;\n+  bool read_only_flag = false;\n+\n+  const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n+      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n+  if (result != MOJO_RESULT_OK)\n+    return nullptr;\n+  DCHECK_GT(memory_size, 0u);\n+\n+  std::unique_ptr<base::SharedMemory> shm =\n+      base::MakeUnique<base::SharedMemory>(memory_handle, true /* read_only */);\n+  if (!shm->Map(memory_size)) {\n+    DLOG(ERROR) << \""Map shared memory failed.\"";\n+    return nullptr;\n+  }\n+  return shm;\n+}\n+\n+scoped_refptr<base::RefCountedBytes>\n+PrintCompositeClient::GetDataFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  std::unique_ptr<base::SharedMemory> shm =\n+      GetShmFromMojoHandle(std::move(handle));\n+  if (!shm)\n+    return nullptr;\n+\n+  return base::MakeRefCounted<base::RefCountedBytes>(\n+      reinterpret_cast<const unsigned char*>(shm->memory()),\n+      shm->mapped_size());\n+}\n+\n+}  // namespace printing""}<_**next**_>{""sha"": ""d63b34123520f5d66dbafe7c878c84f77725a91c"", ""filename"": ""components/printing/browser/print_composite_client.h"", ""status"": ""added"", ""additions"": 49, ""deletions"": 0, ""changes"": 49, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,49 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+#define COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_client.h\""\n+#include \""content/public/browser/web_contents_observer.h\""\n+#include \""content/public/browser/web_contents_user_data.h\""\n+\n+namespace printing {\n+\n+class PrintCompositeClient\n+    : public PdfCompositorClient,\n+      public content::WebContentsUserData<PrintCompositeClient> {\n+ public:\n+  explicit PrintCompositeClient(content::WebContents* web_contents);\n+  ~PrintCompositeClient() override;\n+\n+  void DoComposite(base::SharedMemoryHandle handle,\n+                   uint32_t data_size,\n+                   mojom::PdfCompositor::CompositePdfCallback callback);\n+\n+  void set_for_preview(bool for_preview) { for_preview_ = for_preview; }\n+  bool for_preview() const { return for_preview_; }\n+\n+  // Utility functions.\n+  static std::unique_ptr<base::SharedMemory> GetShmFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+  static scoped_refptr<base::RefCountedBytes> GetDataFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+\n+ private:\n+  void CreateConnectorRequest();\n+\n+  service_manager::mojom::ConnectorRequest connector_request_;\n+  std::unique_ptr<service_manager::Connector> connector_;\n+  bool for_preview_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(PrintCompositeClient);\n+};\n+\n+}  // namespace printing\n+\n+#endif  // COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_""}<_**next**_>{""sha"": ""844fcf5bd23513e52fa2a2eb7d9d958762e11ddf"", ""filename"": ""components/printing/browser/print_manager_utils.cc"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 1, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3,11 +3,43 @@\n // found in the LICENSE file.\n \n #include \""components/printing/browser/print_manager_utils.h\""\n+\n+#include \""base/command_line.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n #include \""components/printing/common/print_messages.h\""\n+#include \""content/public/common/content_features.h\""\n+#include \""content/public/common/content_switches.h\""\n #include \""printing/print_settings.h\""\n \n namespace printing {\n \n+// A temporary flag which makes supporting both paths for OOPIF and non-OOPIF\n+// printing easier.\n+static bool g_oopif_enabled = false;\n+\n+void SetOopifEnabled() {\n+  g_oopif_enabled = true;\n+}\n+\n+bool IsOopifEnabled() {\n+  return g_oopif_enabled;\n+}\n+\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview) {\n+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n+          switches::kSitePerProcess) ||\n+      base::FeatureList::IsEnabled(features::kTopDocumentIsolation)) {\n+    // For cases need to support OOPIFs.\n+    PrintCompositeClient::CreateForWebContents(web_contents);\n+    if (for_preview) {\n+      PrintCompositeClient::FromWebContents(web_contents)\n+          ->set_for_preview(true);\n+    }\n+    SetOopifEnabled();\n+  }\n+}\n+\n void RenderParamsFromPrintSettings(const PrintSettings& settings,\n                                    PrintMsg_Print_Params* params) {\n   params->page_size = settings.page_setup_device_units().physical_size();\n@@ -32,7 +64,8 @@ void RenderParamsFromPrintSettings(const PrintSettings& settings,\n   params->display_header_footer = settings.display_header_footer();\n   params->title = settings.title();\n   params->url = settings.url();\n-  params->printed_doc_type = SkiaDocumentType::PDF;\n+  params->printed_doc_type =\n+      IsOopifEnabled() ? SkiaDocumentType::MSKP : SkiaDocumentType::PDF;\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""5b2b62a7dbf5599fbb51940906b2ed4697c5d0a2"", ""filename"": ""components/printing/browser/print_manager_utils.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,10 +7,22 @@\n \n struct PrintMsg_Print_Params;\n \n+namespace content {\n+class WebContents;\n+}\n+\n namespace printing {\n \n class PrintSettings;\n \n+void SetOopifEnabled(bool enabled);\n+bool IsOopifEnabled();\n+\n+// Check on the current feature settings to decide whether we need to\n+// create a PDF compositor client for this |web_contents|.\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview);\n+\n // Converts given settings to Print_Params and stores them in the output\n // parameter |params|.\n void RenderParamsFromPrintSettings(const PrintSettings& settings,""}<_**next**_>{""sha"": ""231fe97661ab55076dcd33cbc9dc12eeb29cbe83"", ""filename"": ""headless/lib/browser/headless_web_contents_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/headless/lib/browser/headless_web_contents_impl.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -322,6 +322,7 @@ HeadlessWebContentsImpl::HeadlessWebContentsImpl(\n       weak_ptr_factory_(this) {\n #if BUILDFLAG(ENABLE_BASIC_PRINTING) && !defined(CHROME_MULTIPLE_DLL_CHILD)\n   HeadlessPrintManager::CreateForWebContents(web_contents);\n+// TODO(weili): Add support for printing OOPIFs.\n #endif\n   web_contents->GetMutableRendererPrefs()->accept_languages =\n       browser_context->options()->accept_language();""}"," void PrintViewManagerBase::OnDidPrintPage(
    const PrintHostMsg_DidPrintPage_Params& params) {
  // Ready to composite. Starting a print job.
   if (!OpportunisticallyCreatePrintJob(params.document_cookie))
     return;
 
  PrintedDocument* document = print_job_->document();
  if (!document || params.document_cookie != document->cookie()) {
    return;
  }

#if defined(OS_MACOSX)
  const bool metafile_must_be_valid = true;
#else
  const bool metafile_must_be_valid = expecting_first_page_;
  expecting_first_page_ = false;
#endif

  std::unique_ptr<base::SharedMemory> shared_buf;
  if (metafile_must_be_valid) {
    if (!base::SharedMemory::IsHandleValid(params.metafile_data_handle)) {
      NOTREACHED() << ""invalid memory handle"";
       web_contents()->Stop();
       return;
     }

    auto* client = PrintCompositeClient::FromWebContents(web_contents());
    if (IsOopifEnabled() && !client->for_preview() &&
        !document->settings().is_modifiable()) {
      client->DoComposite(
          params.metafile_data_handle, params.data_size,
          base::BindOnce(&PrintViewManagerBase::OnComposePdfDone,
                         weak_ptr_factory_.GetWeakPtr(), params));
      return;
    }
     shared_buf =
        std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);
     if (!shared_buf->Map(params.data_size)) {
       NOTREACHED() << ""couldn't map"";
       web_contents()->Stop();
      return;
    }
  } else {
    if (base::SharedMemory::IsHandleValid(params.metafile_data_handle)) {
      NOTREACHED() << ""unexpected valid memory handle"";
      web_contents()->Stop();
      base::SharedMemory::CloseHandle(params.metafile_data_handle);
      return;
     }
   }
 
  UpdateForPrintedPage(params, metafile_must_be_valid, std::move(shared_buf));
}

void PrintViewManagerBase::UpdateForPrintedPage(
    const PrintHostMsg_DidPrintPage_Params& params,
    bool has_valid_page_data,
    std::unique_ptr<base::SharedMemory> shared_buf) {
  PrintedDocument* document = print_job_->document();
  if (!document)
    return;
 
 #if defined(OS_WIN)
   print_job_->AppendPrintedPage(params.page_number);
  if (has_valid_page_data) {
    scoped_refptr<base::RefCountedBytes> bytes(new base::RefCountedBytes(
         reinterpret_cast<const unsigned char*>(shared_buf->memory()),
        shared_buf->mapped_size()));

     document->DebugDumpData(bytes.get(), FILE_PATH_LITERAL("".pdf""));
 
     const auto& settings = document->settings();
    if (settings.printer_is_textonly()) {
      print_job_->StartPdfToTextConversion(bytes, params.page_size);
    } else if ((settings.printer_is_ps2() || settings.printer_is_ps3()) &&
               !base::FeatureList::IsEnabled(
                   features::kDisablePostScriptPrinting)) {
      print_job_->StartPdfToPostScriptConversion(bytes, params.content_area,
                                                 params.physical_offsets,
                                                 settings.printer_is_ps2());
    } else {
      bool print_text_with_gdi =
          settings.print_text_with_gdi() && !settings.printer_is_xps() &&
          base::FeatureList::IsEnabled(features::kGdiTextPrinting);
       print_job_->StartPdfToEmfConversion(
           bytes, params.page_size, params.content_area, print_text_with_gdi);
     }
   }
 #else
  std::unique_ptr<PdfMetafileSkia> metafile =
      std::make_unique<PdfMetafileSkia>(SkiaDocumentType::PDF);
  if (has_valid_page_data) {
    if (!metafile->InitFromData(shared_buf->memory(),
                                shared_buf->mapped_size())) {
      NOTREACHED() << ""Invalid metafile header"";
      web_contents()->Stop();
      return;
    }
  }

  document->SetPage(params.page_number, std::move(metafile), params.page_size,
                     params.content_area);
 
   ShouldQuitFromInnerMessageLoop();
#endif
}
"," void PrintViewManagerBase::OnDidPrintPage(
  const PrintHostMsg_DidPrintPage_Params& params) {
   if (!OpportunisticallyCreatePrintJob(params.document_cookie))
     return;
 
  PrintedDocument* document = print_job_->document();
  if (!document || params.document_cookie != document->cookie()) {
    return;
  }

#if defined(OS_MACOSX)
  const bool metafile_must_be_valid = true;
#else
  const bool metafile_must_be_valid = expecting_first_page_;
  expecting_first_page_ = false;
#endif

  std::unique_ptr<base::SharedMemory> shared_buf;
  if (metafile_must_be_valid) {
    if (!base::SharedMemory::IsHandleValid(params.metafile_data_handle)) {
      NOTREACHED() << ""invalid memory handle"";
       web_contents()->Stop();
       return;
     }
     shared_buf =
        base::MakeUnique<base::SharedMemory>(params.metafile_data_handle, true);
     if (!shared_buf->Map(params.data_size)) {
       NOTREACHED() << ""couldn't map"";
       web_contents()->Stop();
      return;
    }
  } else {
    if (base::SharedMemory::IsHandleValid(params.metafile_data_handle)) {
      NOTREACHED() << ""unexpected valid memory handle"";
      web_contents()->Stop();
      base::SharedMemory::CloseHandle(params.metafile_data_handle);
      return;
     }
   }
 
  std::unique_ptr<PdfMetafileSkia> metafile(
      new PdfMetafileSkia(SkiaDocumentType::PDF));
  if (metafile_must_be_valid) {
    if (!metafile->InitFromData(shared_buf->memory(), params.data_size)) {
      NOTREACHED() << ""Invalid metafile header"";
      web_contents()->Stop();
      return;
    }
  }
 
 #if defined(OS_WIN)
   print_job_->AppendPrintedPage(params.page_number);
  if (metafile_must_be_valid) {
    scoped_refptr<base::RefCountedBytes> bytes = new base::RefCountedBytes(
         reinterpret_cast<const unsigned char*>(shared_buf->memory()),
        params.data_size);
     document->DebugDumpData(bytes.get(), FILE_PATH_LITERAL("".pdf""));
 
     const auto& settings = document->settings();
    if (settings.printer_is_textonly()) {
      print_job_->StartPdfToTextConversion(bytes, params.page_size);
    } else if ((settings.printer_is_ps2() || settings.printer_is_ps3()) &&
               !base::FeatureList::IsEnabled(
                   features::kDisablePostScriptPrinting)) {
      print_job_->StartPdfToPostScriptConversion(bytes, params.content_area,
                                                 params.physical_offsets,
                                                 settings.printer_is_ps2());
    } else {
      bool print_text_with_gdi = settings.print_text_with_gdi() &&
                                 !settings.printer_is_xps() &&
                                 base::FeatureList::IsEnabled(
                                     features::kGdiTextPrinting);
       print_job_->StartPdfToEmfConversion(
           bytes, params.page_size, params.content_area, print_text_with_gdi);
     }
   }
 #else
  document->SetPage(params.page_number,
                    std::move(metafile),
#if defined(OS_WIN)
                    0.0f /* dummy shrink_factor */,
#endif
                    params.page_size,
                     params.content_area);
 
   ShouldQuitFromInnerMessageLoop();
#endif
}
",C,"    const PrintHostMsg_DidPrintPage_Params& params) {
  // Ready to composite. Starting a print job.

    auto* client = PrintCompositeClient::FromWebContents(web_contents());
    if (IsOopifEnabled() && !client->for_preview() &&
        !document->settings().is_modifiable()) {
      client->DoComposite(
          params.metafile_data_handle, params.data_size,
          base::BindOnce(&PrintViewManagerBase::OnComposePdfDone,
                         weak_ptr_factory_.GetWeakPtr(), params));
      return;
    }
        std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);
  UpdateForPrintedPage(params, metafile_must_be_valid, std::move(shared_buf));
}

void PrintViewManagerBase::UpdateForPrintedPage(
    const PrintHostMsg_DidPrintPage_Params& params,
    bool has_valid_page_data,
    std::unique_ptr<base::SharedMemory> shared_buf) {
  PrintedDocument* document = print_job_->document();
  if (!document)
    return;
  if (has_valid_page_data) {
    scoped_refptr<base::RefCountedBytes> bytes(new base::RefCountedBytes(
        shared_buf->mapped_size()));

      bool print_text_with_gdi =
          settings.print_text_with_gdi() && !settings.printer_is_xps() &&
          base::FeatureList::IsEnabled(features::kGdiTextPrinting);
  std::unique_ptr<PdfMetafileSkia> metafile =
      std::make_unique<PdfMetafileSkia>(SkiaDocumentType::PDF);
  if (has_valid_page_data) {
    if (!metafile->InitFromData(shared_buf->memory(),
                                shared_buf->mapped_size())) {
      NOTREACHED() << ""Invalid metafile header"";
      web_contents()->Stop();
      return;
    }
  }

  document->SetPage(params.page_number, std::move(metafile), params.page_size,
","  const PrintHostMsg_DidPrintPage_Params& params) {
        base::MakeUnique<base::SharedMemory>(params.metafile_data_handle, true);
  std::unique_ptr<PdfMetafileSkia> metafile(
      new PdfMetafileSkia(SkiaDocumentType::PDF));
  if (metafile_must_be_valid) {
    if (!metafile->InitFromData(shared_buf->memory(), params.data_size)) {
      NOTREACHED() << ""Invalid metafile header"";
      web_contents()->Stop();
      return;
    }
  }
  if (metafile_must_be_valid) {
    scoped_refptr<base::RefCountedBytes> bytes = new base::RefCountedBytes(
        params.data_size);
      bool print_text_with_gdi = settings.print_text_with_gdi() &&
                                 !settings.printer_is_xps() &&
                                 base::FeatureList::IsEnabled(
                                     features::kGdiTextPrinting);
  document->SetPage(params.page_number,
                    std::move(metafile),
#if defined(OS_WIN)
                    0.0f /* dummy shrink_factor */,
#endif
                    params.page_size,
",,"@@ -11,6 +11,7 @@
 #include ""base/bind.h""
 #include ""base/location.h""
 #include ""base/memory/ptr_util.h""
+#include ""base/memory/shared_memory.h""
 #include ""base/message_loop/message_loop.h""
 #include ""base/run_loop.h""
 #include ""base/single_thread_task_runner.h""
@@ -28,6 +29,8 @@
 #include ""chrome/common/pref_names.h""
 #include ""chrome/grit/generated_resources.h""
 #include ""components/prefs/pref_service.h""
+#include ""components/printing/browser/print_composite_client.h""
+#include ""components/printing/browser/print_manager_utils.h""
 #include ""components/printing/common/print_messages.h""
 #include ""content/public/browser/browser_thread.h""
 #include ""content/public/browser/notification_details.h""
@@ -36,8 +39,10 @@
 #include ""content/public/browser/render_frame_host.h""
 #include ""content/public/browser/render_view_host.h""
 #include ""content/public/browser/web_contents.h""
+#include ""mojo/public/cpp/system/buffer.h""
 #include ""printing/features/features.h""
 #include ""printing/pdf_metafile_skia.h""
+#include ""printing/print_settings.h""
 #include ""printing/printed_document.h""
 #include ""ui/base/l10n/l10n_util.h""
 
@@ -78,7 +83,8 @@ PrintViewManagerBase::PrintViewManagerBase(content::WebContents* web_contents)
 #if !defined(OS_MACOSX)
       expecting_first_page_(true),
 #endif
-      queue_(g_browser_process->print_job_manager()->queue()) {
+      queue_(g_browser_process->print_job_manager()->queue()),
+      weak_ptr_factory_(this) {
   DCHECK(queue_.get());
   Profile* profile =
       Profile::FromBrowserContext(web_contents->GetBrowserContext());
@@ -127,8 +133,24 @@ void PrintViewManagerBase::OnDidGetPrintedPagesCount(int cookie,
   OpportunisticallyCreatePrintJob(cookie);
 }
 
+void PrintViewManagerBase::OnComposePdfDone(
+    const PrintHostMsg_DidPrintPage_Params& params,
+    mojom::PdfCompositor::Status status,
+    mojo::ScopedSharedBufferHandle handle) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  if (status != mojom::PdfCompositor::Status::SUCCESS) {
+    DLOG(ERROR) << ""Compositing pdf failed with error "" << status;
+    return;
+  }
+
+  UpdateForPrintedPage(
+      params, true,
+      PrintCompositeClient::GetShmFromMojoHandle(std::move(handle)));
+}
+
 void PrintViewManagerBase::OnDidPrintPage(
-  const PrintHostMsg_DidPrintPage_Params& params) {
+    const PrintHostMsg_DidPrintPage_Params& params) {
+  // Ready to composite. Starting a print job.
   if (!OpportunisticallyCreatePrintJob(params.document_cookie))
     return;
 
@@ -154,8 +176,18 @@ void PrintViewManagerBase::OnDidPrintPage(
       web_contents()->Stop();
       return;
     }
+
+    auto* client = PrintCompositeClient::FromWebContents(web_contents());
+    if (IsOopifEnabled() && !client->for_preview() &&
+        !document->settings().is_modifiable()) {
+      client->DoComposite(
+          params.metafile_data_handle, params.data_size,
+          base::BindOnce(&PrintViewManagerBase::OnComposePdfDone,
+                         weak_ptr_factory_.GetWeakPtr(), params));
+      return;
+    }
     shared_buf =
-        base::MakeUnique<base::SharedMemory>(params.metafile_data_handle, true);
+        std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);
     if (!shared_buf->Map(params.data_size)) {
       NOTREACHED() << ""couldn't map"";
       web_contents()->Stop();
@@ -170,22 +202,24 @@ void PrintViewManagerBase::OnDidPrintPage(
     }
   }
 
-  std::unique_ptr<PdfMetafileSkia> metafile(
-      new PdfMetafileSkia(SkiaDocumentType::PDF));
-  if (metafile_must_be_valid) {
-    if (!metafile->InitFromData(shared_buf->memory(), params.data_size)) {
-      NOTREACHED() << ""Invalid metafile header"";
-      web_contents()->Stop();
-      return;
-    }
-  }
+  UpdateForPrintedPage(params, metafile_must_be_valid, std::move(shared_buf));
+}
+
+void PrintViewManagerBase::UpdateForPrintedPage(
+    const PrintHostMsg_DidPrintPage_Params& params,
+    bool has_valid_page_data,
+    std::unique_ptr<base::SharedMemory> shared_buf) {
+  PrintedDocument* document = print_job_->document();
+  if (!document)
+    return;
 
 #if defined(OS_WIN)
   print_job_->AppendPrintedPage(params.page_number);
-  if (metafile_must_be_valid) {
-    scoped_refptr<base::RefCountedBytes> bytes = new base::RefCountedBytes(
+  if (has_valid_page_data) {
+    scoped_refptr<base::RefCountedBytes> bytes(new base::RefCountedBytes(
         reinterpret_cast<const unsigned char*>(shared_buf->memory()),
-        params.data_size);
+        shared_buf->mapped_size()));
+
     document->DebugDumpData(bytes.get(), FILE_PATH_LITERAL("".pdf""));
 
     const auto& settings = document->settings();
@@ -203,22 +237,27 @@ void PrintViewManagerBase::OnDidPrintPage(
       // Update : The missing letters seem to have been caused by the same
       // problem as https://crbug.com/659604 which was resolved. GDI printing
       // seems to work with the fix for this bug applied.
-      bool print_text_with_gdi = settings.print_text_with_gdi() &&
-                                 !settings.printer_is_xps() &&
-                                 base::FeatureList::IsEnabled(
-                                     features::kGdiTextPrinting);
+      bool print_text_with_gdi =
+          settings.print_text_with_gdi() && !settings.printer_is_xps() &&
+          base::FeatureList::IsEnabled(features::kGdiTextPrinting);
       print_job_->StartPdfToEmfConversion(
           bytes, params.page_size, params.content_area, print_text_with_gdi);
     }
   }
 #else
+  std::unique_ptr<PdfMetafileSkia> metafile =
+      std::make_unique<PdfMetafileSkia>(SkiaDocumentType::PDF);
+  if (has_valid_page_data) {
+    if (!metafile->InitFromData(shared_buf->memory(),
+                                shared_buf->mapped_size())) {
+      NOTREACHED() << ""Invalid metafile header"";
+      web_contents()->Stop();
+      return;
+    }
+  }
+
   // Update the rendered document. It will send notifications to the listener.
-  document->SetPage(params.page_number,
-                    std::move(metafile),
-#if defined(OS_WIN)
-                    0.0f /* dummy shrink_factor */,
-#endif
-                    params.page_size,
+  document->SetPage(params.page_number, std::move(metafile), params.page_size,
                     params.content_area);
 
   ShouldQuitFromInnerMessageLoop();",Chrome,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,896aab1971cb86907e97ea09726b3872fbfde09a,1," void PrintViewManagerBase::OnDidPrintPage(
//flaw_line_below:
  const PrintHostMsg_DidPrintPage_Params& params) {
//fix_flaw_line_below:
//    const PrintHostMsg_DidPrintPage_Params& params) {
//fix_flaw_line_below:
//  // Ready to composite. Starting a print job.
   if (!OpportunisticallyCreatePrintJob(params.document_cookie))
     return;
 
  PrintedDocument* document = print_job_->document();
  if (!document || params.document_cookie != document->cookie()) {
    // Out of sync. It may happen since we are completely asynchronous. Old
    // spurious messages can be received if one of the processes is overloaded.
    return;
  }

#if defined(OS_MACOSX)
  const bool metafile_must_be_valid = true;
#else
  const bool metafile_must_be_valid = expecting_first_page_;
  expecting_first_page_ = false;
#endif

  // Only used when |metafile_must_be_valid| is true.
  std::unique_ptr<base::SharedMemory> shared_buf;
  if (metafile_must_be_valid) {
    if (!base::SharedMemory::IsHandleValid(params.metafile_data_handle)) {
      NOTREACHED() << ""invalid memory handle"";
       web_contents()->Stop();
       return;
     }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    auto* client = PrintCompositeClient::FromWebContents(web_contents());
//fix_flaw_line_below:
//    if (IsOopifEnabled() && !client->for_preview() &&
//fix_flaw_line_below:
//        !document->settings().is_modifiable()) {
//fix_flaw_line_below:
//      client->DoComposite(
//fix_flaw_line_below:
//          params.metafile_data_handle, params.data_size,
//fix_flaw_line_below:
//          base::BindOnce(&PrintViewManagerBase::OnComposePdfDone,
//fix_flaw_line_below:
//                         weak_ptr_factory_.GetWeakPtr(), params));
//fix_flaw_line_below:
//      return;
//fix_flaw_line_below:
//    }
     shared_buf =
//flaw_line_below:
        base::MakeUnique<base::SharedMemory>(params.metafile_data_handle, true);
//fix_flaw_line_below:
//        std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);
     if (!shared_buf->Map(params.data_size)) {
       NOTREACHED() << ""couldn't map"";
       web_contents()->Stop();
      return;
    }
  } else {
    if (base::SharedMemory::IsHandleValid(params.metafile_data_handle)) {
      NOTREACHED() << ""unexpected valid memory handle"";
      web_contents()->Stop();
      base::SharedMemory::CloseHandle(params.metafile_data_handle);
      return;
     }
   }
 
//flaw_line_below:
  std::unique_ptr<PdfMetafileSkia> metafile(
//flaw_line_below:
      new PdfMetafileSkia(SkiaDocumentType::PDF));
//flaw_line_below:
  if (metafile_must_be_valid) {
//flaw_line_below:
    if (!metafile->InitFromData(shared_buf->memory(), params.data_size)) {
//flaw_line_below:
      NOTREACHED() << ""Invalid metafile header"";
//flaw_line_below:
      web_contents()->Stop();
//flaw_line_below:
      return;
//flaw_line_below:
    }
//flaw_line_below:
  }
//fix_flaw_line_below:
//  UpdateForPrintedPage(params, metafile_must_be_valid, std::move(shared_buf));
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//void PrintViewManagerBase::UpdateForPrintedPage(
//fix_flaw_line_below:
//    const PrintHostMsg_DidPrintPage_Params& params,
//fix_flaw_line_below:
//    bool has_valid_page_data,
//fix_flaw_line_below:
//    std::unique_ptr<base::SharedMemory> shared_buf) {
//fix_flaw_line_below:
//  PrintedDocument* document = print_job_->document();
//fix_flaw_line_below:
//  if (!document)
//fix_flaw_line_below:
//    return;
 
 #if defined(OS_WIN)
   print_job_->AppendPrintedPage(params.page_number);
//flaw_line_below:
  if (metafile_must_be_valid) {
//flaw_line_below:
    scoped_refptr<base::RefCountedBytes> bytes = new base::RefCountedBytes(
//fix_flaw_line_below:
//  if (has_valid_page_data) {
//fix_flaw_line_below:
//    scoped_refptr<base::RefCountedBytes> bytes(new base::RefCountedBytes(
         reinterpret_cast<const unsigned char*>(shared_buf->memory()),
//flaw_line_below:
        params.data_size);
//fix_flaw_line_below:
//        shared_buf->mapped_size()));
//fix_flaw_line_below:
//
     document->DebugDumpData(bytes.get(), FILE_PATH_LITERAL("".pdf""));
 
     const auto& settings = document->settings();
    if (settings.printer_is_textonly()) {
      print_job_->StartPdfToTextConversion(bytes, params.page_size);
    } else if ((settings.printer_is_ps2() || settings.printer_is_ps3()) &&
               !base::FeatureList::IsEnabled(
                   features::kDisablePostScriptPrinting)) {
      print_job_->StartPdfToPostScriptConversion(bytes, params.content_area,
                                                 params.physical_offsets,
                                                 settings.printer_is_ps2());
    } else {
      // TODO(thestig): Figure out why rendering text with GDI results in random
      // missing characters for some users. https://crbug.com/658606
       // Update : The missing letters seem to have been caused by the same
       // problem as https://crbug.com/659604 which was resolved. GDI printing
       // seems to work with the fix for this bug applied.
//flaw_line_below:
      bool print_text_with_gdi = settings.print_text_with_gdi() &&
//flaw_line_below:
                                 !settings.printer_is_xps() &&
//flaw_line_below:
                                 base::FeatureList::IsEnabled(
//flaw_line_below:
                                     features::kGdiTextPrinting);
//fix_flaw_line_below:
//      bool print_text_with_gdi =
//fix_flaw_line_below:
//          settings.print_text_with_gdi() && !settings.printer_is_xps() &&
//fix_flaw_line_below:
//          base::FeatureList::IsEnabled(features::kGdiTextPrinting);
       print_job_->StartPdfToEmfConversion(
           bytes, params.page_size, params.content_area, print_text_with_gdi);
     }
   }
 #else
//fix_flaw_line_below:
//  std::unique_ptr<PdfMetafileSkia> metafile =
//fix_flaw_line_below:
//      std::make_unique<PdfMetafileSkia>(SkiaDocumentType::PDF);
//fix_flaw_line_below:
//  if (has_valid_page_data) {
//fix_flaw_line_below:
//    if (!metafile->InitFromData(shared_buf->memory(),
//fix_flaw_line_below:
//                                shared_buf->mapped_size())) {
//fix_flaw_line_below:
//      NOTREACHED() << ""Invalid metafile header"";
//fix_flaw_line_below:
//      web_contents()->Stop();
//fix_flaw_line_below:
//      return;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   // Update the rendered document. It will send notifications to the listener.
//flaw_line_below:
  document->SetPage(params.page_number,
//flaw_line_below:
                    std::move(metafile),
//flaw_line_below:
#if defined(OS_WIN)
//flaw_line_below:
                    0.0f /* dummy shrink_factor */,
//flaw_line_below:
#endif
//flaw_line_below:
                    params.page_size,
//fix_flaw_line_below:
//  document->SetPage(params.page_number, std::move(metafile), params.page_size,
                     params.content_area);
 
   ShouldQuitFromInnerMessageLoop();
#endif
}
"
8035,185771,,Remote,Not required,,CVE-2015-1300,https://www.cvedetails.com/cve/CVE-2015-1300/,CWE-254,Low,Partial,,,2015-09-03,5.0,"The FrameFetchContext::updateTimingInfoForIFrameNavigation function in core/loader/FrameFetchContext.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not properly restrict the availability of IFRAME Resource Timing API times, which allows remote attackers to obtain sensitive information via crafted JavaScript code that leverages a history.back call.",2016-12-21,+Info ,2,https://github.com/chromium/chromium/commit/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,"Use pdf compositor service for printing when OOPIF is enabled

When OOPIF is enabled (by site-per-process flag or
top-document-isolation feature), use the pdf compositor service for
converting PaintRecord to PDF on renderers.

In the future, this will make compositing PDF from multiple renderers
possible.

TBR=jzfeng@chromium.org
BUG=455764

Change-Id: I3c28f03f4358e4228239fe1a33384f85e7716e8f
Reviewed-on: https://chromium-review.googlesource.com/699765
Commit-Queue: Wei Li <weili@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Cr-Commit-Position: refs/heads/master@{#511616}",1,chrome/browser/printing/print_view_manager_base.cc,"{""sha"": ""78193d61b9f59cdc78ed504e7a6939379d4f52d5"", ""filename"": ""chrome/browser/chrome_content_browser_manifest_overlay.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chrome_content_browser_manifest_overlay.json?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -44,6 +44,7 @@\n         \""local_state\"": [ \""pref_client\"" ],\n         \""nacl_broker\"": [ \""browser\"" ],\n         \""nacl_loader\"": [ \""browser\"" ],\n+        \""pdf_compositor\"": [ \""compositor\"" ],\n         \""profile_import\"": [ \""import\"" ],\n         \""profiling\"": [ \""profiling\"" ],\n         \""proxy_resolver\"": [ \""factory\"" ],""}<_**next**_>{""sha"": ""449ec7465b049d91941d3413bafcb8ee1904d417"", ""filename"": ""chrome/browser/printing/print_preview_dialog_controller.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_dialog_controller.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -29,6 +29,7 @@\n #include \""chrome/common/chrome_paths.h\""\n #include \""chrome/common/url_constants.h\""\n #include \""components/guest_view/browser/guest_view_base.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/web_modal/web_contents_modal_dialog_host.h\""\n #include \""content/public/browser/host_zoom_map.h\""\n #include \""content/public/browser/navigation_controller.h\""\n@@ -376,6 +377,7 @@ WebContents* PrintPreviewDialogController::CreatePrintPreviewDialog(\n   content::HostZoomMap::Get(preview_dialog->GetSiteInstance())\n       ->SetZoomLevelForHostAndScheme(print_url.scheme(), print_url.host(), 0);\n   PrintViewManager::CreateForWebContents(preview_dialog);\n+  CreateCompositeClientIfNeeded(preview_dialog, true /* for_preview */);\n   extensions::ChromeExtensionWebContentsObserver::CreateForWebContents(\n       preview_dialog);\n ""}<_**next**_>{""sha"": ""cda7ad2e7612be69842877448291d3be54317a64"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.cc"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 22, ""changes"": 116, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -14,18 +14,22 @@\n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/ref_counted_memory.h\""\n #include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n #include \""chrome/browser/browser_process.h\""\n #include \""chrome/browser/printing/print_job_manager.h\""\n #include \""chrome/browser/printing/print_preview_dialog_controller.h\""\n #include \""chrome/browser/printing/print_view_manager.h\""\n #include \""chrome/browser/printing/printer_query.h\""\n #include \""chrome/browser/ui/webui/print_preview/print_preview_ui.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""content/public/browser/web_ui.h\""\n #include \""printing/page_size_margins.h\""\n #include \""printing/print_job_constants.h\""\n+#include \""printing/print_settings.h\""\n \n using content::BrowserThread;\n using content::WebContents;\n@@ -69,7 +73,7 @@ scoped_refptr<base::RefCountedBytes> GetDataFromHandle(\n \n PrintPreviewMessageHandler::PrintPreviewMessageHandler(\n     WebContents* web_contents)\n-    : content::WebContentsObserver(web_contents) {\n+    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {\n   DCHECK(web_contents);\n }\n \n@@ -129,13 +133,21 @@ void PrintPreviewMessageHandler::OnDidPreviewPage(\n   if (!print_preview_ui)\n     return;\n \n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  DCHECK(data_bytes);\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    // Use utility process to convert skia metafile to pdf.\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,\n+                       weak_ptr_factory_.GetWeakPtr(), params.page_number,\n+                       params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewPageReady(\n+        page_number, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n@@ -152,18 +164,20 @@ void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n   if (!print_preview_ui)\n     return;\n \n-  // TODO(joth): This seems like a good match for using RefCountedStaticMemory\n-  // to avoid the memory copy, but the SetPrintPreviewData call chain below\n-  // needs updating to accept the RefCountedMemory* base class.\n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  if (!data_bytes || !data_bytes->size())\n-    return;\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnPreviewDataIsAvailable(\n-      params.expected_pages_count, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,\n+                       weak_ptr_factory_.GetWeakPtr(),\n+                       params.expected_pages_count, params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewDocumentReady(\n+        params.expected_pages_count, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnPrintPreviewFailed(int document_cookie) {\n@@ -214,6 +228,65 @@ void PrintPreviewMessageHandler::OnSetOptionsFromDocument(\n   print_preview_ui->OnSetOptionsFromDocument(params);\n }\n \n+void PrintPreviewMessageHandler::NotifyUIPreviewPageReady(\n+    int page_number,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  DCHECK(data_bytes);\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnDidPreviewPage(page_number, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::NotifyUIPreviewDocumentReady(\n+    int page_count,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  if (!data_bytes || !data_bytes->size())\n+    return;\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnPreviewDataIsAvailable(page_count, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfPageDone(\n+    int page_number,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewPageReady(\n+      page_number, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfDocumentDone(\n+    int page_count,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewDocumentReady(\n+      page_count, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n bool PrintPreviewMessageHandler::OnMessageReceived(\n     const IPC::Message& message,\n     content::RenderFrameHost* render_frame_host) {\n@@ -231,8 +304,7 @@ bool PrintPreviewMessageHandler::OnMessageReceived(\n   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,\n                         OnDidGetPreviewPageCount)\n-    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,\n-                        OnDidPreviewPage)\n+    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,\n                         OnMetafileReadyForPrinting)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,""}<_**next**_>{""sha"": ""71ca9d5bb1ee142ed3dbbfaa34cd8ab5d3018002"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.h"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,6 +7,9 @@\n \n #include \""base/compiler_specific.h\""\n #include \""base/macros.h\""\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/weak_ptr.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/web_contents_observer.h\""\n #include \""content/public/browser/web_contents_user_data.h\""\n \n@@ -70,6 +73,27 @@ class PrintPreviewMessageHandler\n   void OnSetOptionsFromDocument(\n       const PrintHostMsg_SetOptionsFromDocument_Params& params);\n \n+  void NotifyUIPreviewPageReady(\n+      int page_number,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+  void NotifyUIPreviewDocumentReady(\n+      int page_count,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+\n+  // Callbacks for pdf compositor client.\n+  void OnCompositePdfPageDone(int page_number,\n+                              int request_id,\n+                              mojom::PdfCompositor::Status status,\n+                              mojo::ScopedSharedBufferHandle handle);\n+  void OnCompositePdfDocumentDone(int page_count,\n+                                  int request_id,\n+                                  mojom::PdfCompositor::Status status,\n+                                  mojo::ScopedSharedBufferHandle handle);\n+\n+  base::WeakPtrFactory<PrintPreviewMessageHandler> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintPreviewMessageHandler);\n };\n ""}<_**next**_>{""sha"": ""f4fed9d2753dbd8b374dfb9b6f006cf51010d5cf"", ""filename"": ""chrome/browser/printing/print_view_manager_base.cc"", ""status"": ""modified"", ""additions"": 64, ""deletions"": 25, ""changes"": 89, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -11,6 +11,7 @@\n #include \""base/bind.h\""\n #include \""base/location.h\""\n #include \""base/memory/ptr_util.h\""\n+#include \""base/memory/shared_memory.h\""\n #include \""base/message_loop/message_loop.h\""\n #include \""base/run_loop.h\""\n #include \""base/single_thread_task_runner.h\""\n@@ -28,6 +29,8 @@\n #include \""chrome/common/pref_names.h\""\n #include \""chrome/grit/generated_resources.h\""\n #include \""components/prefs/pref_service.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/notification_details.h\""\n@@ -36,8 +39,10 @@\n #include \""content/public/browser/render_frame_host.h\""\n #include \""content/public/browser/render_view_host.h\""\n #include \""content/public/browser/web_contents.h\""\n+#include \""mojo/public/cpp/system/buffer.h\""\n #include \""printing/features/features.h\""\n #include \""printing/pdf_metafile_skia.h\""\n+#include \""printing/print_settings.h\""\n #include \""printing/printed_document.h\""\n #include \""ui/base/l10n/l10n_util.h\""\n \n@@ -78,7 +83,8 @@ PrintViewManagerBase::PrintViewManagerBase(content::WebContents* web_contents)\n #if !defined(OS_MACOSX)\n       expecting_first_page_(true),\n #endif\n-      queue_(g_browser_process->print_job_manager()->queue()) {\n+      queue_(g_browser_process->print_job_manager()->queue()),\n+      weak_ptr_factory_(this) {\n   DCHECK(queue_.get());\n   Profile* profile =\n       Profile::FromBrowserContext(web_contents->GetBrowserContext());\n@@ -127,8 +133,24 @@ void PrintViewManagerBase::OnDidGetPrintedPagesCount(int cookie,\n   OpportunisticallyCreatePrintJob(cookie);\n }\n \n+void PrintViewManagerBase::OnComposePdfDone(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+\n+  UpdateForPrintedPage(\n+      params, true,\n+      PrintCompositeClient::GetShmFromMojoHandle(std::move(handle)));\n+}\n+\n void PrintViewManagerBase::OnDidPrintPage(\n-  const PrintHostMsg_DidPrintPage_Params& params) {\n+    const PrintHostMsg_DidPrintPage_Params& params) {\n+  // Ready to composite. Starting a print job.\n   if (!OpportunisticallyCreatePrintJob(params.document_cookie))\n     return;\n \n@@ -154,8 +176,18 @@ void PrintViewManagerBase::OnDidPrintPage(\n       web_contents()->Stop();\n       return;\n     }\n+\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    if (IsOopifEnabled() && !client->for_preview() &&\n+        !document->settings().is_modifiable()) {\n+      client->DoComposite(\n+          params.metafile_data_handle, params.data_size,\n+          base::BindOnce(&PrintViewManagerBase::OnComposePdfDone,\n+                         weak_ptr_factory_.GetWeakPtr(), params));\n+      return;\n+    }\n     shared_buf =\n-        base::MakeUnique<base::SharedMemory>(params.metafile_data_handle, true);\n+        std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);\n     if (!shared_buf->Map(params.data_size)) {\n       NOTREACHED() << \""couldn't map\"";\n       web_contents()->Stop();\n@@ -170,22 +202,24 @@ void PrintViewManagerBase::OnDidPrintPage(\n     }\n   }\n \n-  std::unique_ptr<PdfMetafileSkia> metafile(\n-      new PdfMetafileSkia(SkiaDocumentType::PDF));\n-  if (metafile_must_be_valid) {\n-    if (!metafile->InitFromData(shared_buf->memory(), params.data_size)) {\n-      NOTREACHED() << \""Invalid metafile header\"";\n-      web_contents()->Stop();\n-      return;\n-    }\n-  }\n+  UpdateForPrintedPage(params, metafile_must_be_valid, std::move(shared_buf));\n+}\n+\n+void PrintViewManagerBase::UpdateForPrintedPage(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    bool has_valid_page_data,\n+    std::unique_ptr<base::SharedMemory> shared_buf) {\n+  PrintedDocument* document = print_job_->document();\n+  if (!document)\n+    return;\n \n #if defined(OS_WIN)\n   print_job_->AppendPrintedPage(params.page_number);\n-  if (metafile_must_be_valid) {\n-    scoped_refptr<base::RefCountedBytes> bytes = new base::RefCountedBytes(\n+  if (has_valid_page_data) {\n+    scoped_refptr<base::RefCountedBytes> bytes(new base::RefCountedBytes(\n         reinterpret_cast<const unsigned char*>(shared_buf->memory()),\n-        params.data_size);\n+        shared_buf->mapped_size()));\n+\n     document->DebugDumpData(bytes.get(), FILE_PATH_LITERAL(\"".pdf\""));\n \n     const auto& settings = document->settings();\n@@ -203,22 +237,27 @@ void PrintViewManagerBase::OnDidPrintPage(\n       // Update : The missing letters seem to have been caused by the same\n       // problem as https://crbug.com/659604 which was resolved. GDI printing\n       // seems to work with the fix for this bug applied.\n-      bool print_text_with_gdi = settings.print_text_with_gdi() &&\n-                                 !settings.printer_is_xps() &&\n-                                 base::FeatureList::IsEnabled(\n-                                     features::kGdiTextPrinting);\n+      bool print_text_with_gdi =\n+          settings.print_text_with_gdi() && !settings.printer_is_xps() &&\n+          base::FeatureList::IsEnabled(features::kGdiTextPrinting);\n       print_job_->StartPdfToEmfConversion(\n           bytes, params.page_size, params.content_area, print_text_with_gdi);\n     }\n   }\n #else\n+  std::unique_ptr<PdfMetafileSkia> metafile =\n+      std::make_unique<PdfMetafileSkia>(SkiaDocumentType::PDF);\n+  if (has_valid_page_data) {\n+    if (!metafile->InitFromData(shared_buf->memory(),\n+                                shared_buf->mapped_size())) {\n+      NOTREACHED() << \""Invalid metafile header\"";\n+      web_contents()->Stop();\n+      return;\n+    }\n+  }\n+\n   // Update the rendered document. It will send notifications to the listener.\n-  document->SetPage(params.page_number,\n-                    std::move(metafile),\n-#if defined(OS_WIN)\n-                    0.0f /* dummy shrink_factor */,\n-#endif\n-                    params.page_size,\n+  document->SetPage(params.page_number, std::move(metafile), params.page_size,\n                     params.content_area);\n \n   ShouldQuitFromInnerMessageLoop();""}<_**next**_>{""sha"": ""e9706e34f8c96f224196aa8ffc993b44a9247cf9"", ""filename"": ""chrome/browser/printing/print_view_manager_base.h"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 1, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -9,16 +9,23 @@\n \n #include \""base/macros.h\""\n #include \""base/memory/ref_counted.h\""\n+#include \""base/memory/weak_ptr.h\""\n #include \""base/strings/string16.h\""\n #include \""build/build_config.h\""\n #include \""components/prefs/pref_member.h\""\n #include \""components/printing/browser/print_manager.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/notification_observer.h\""\n #include \""content/public/browser/notification_registrar.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n #include \""printing/features/features.h\""\n \n struct PrintHostMsg_DidPrintPage_Params;\n \n+namespace base {\n+class SharedMemory;\n+}\n+\n namespace content {\n class RenderFrameHost;\n }\n@@ -82,9 +89,19 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   // IPC Message handlers.\n   void OnDidGetPrintedPagesCount(int cookie, int number_pages) override;\n-  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n   void OnPrintingFailed(int cookie) override;\n   void OnShowInvalidPrinterSettingsError();\n+  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n+\n+  // Handle extra tasks once a page or doc is printed.\n+  void UpdateForPrintedPage(const PrintHostMsg_DidPrintPage_Params& params,\n+                            bool has_valid_page_data,\n+                            std::unique_ptr<base::SharedMemory> shared_buf);\n+\n+  // IPC message handlers for service.\n+  void OnComposePdfDone(const PrintHostMsg_DidPrintPage_Params& params,\n+                        mojom::PdfCompositor::Status status,\n+                        mojo::ScopedSharedBufferHandle handle);\n \n   // Processes a NOTIFY_PRINT_JOB_EVENT notification.\n   void OnNotifyPrintJobEvent(const JobEventDetails& event_details);\n@@ -163,6 +180,8 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   scoped_refptr<printing::PrintQueriesQueue> queue_;\n \n+  base::WeakPtrFactory<PrintViewManagerBase> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintViewManagerBase);\n };\n ""}<_**next**_>{""sha"": ""3560d1c793977a5c2fe67253c9cf9509dbe596a1"", ""filename"": ""chrome/browser/printing/printing_init.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/printing_init.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""chrome/browser/printing/printing_init.h\""\n \n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""printing/features/features.h\""\n \n@@ -23,6 +24,7 @@ void InitializePrinting(content::WebContents* web_contents) {\n #else\n   printing::PrintViewManagerBasic::CreateForWebContents(web_contents);\n #endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)\n+  CreateCompositeClientIfNeeded(web_contents, false /* for_preview */);\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""84901e64744b737a1810f2e3c513498bfea57fb6"", ""filename"": ""chrome/browser/ui/BUILD.gn"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3475,7 +3475,10 @@ split_static_library(\""ui\"") {\n   }\n \n   if (enable_basic_printing || enable_print_preview) {\n-    deps += [ \""//printing\"" ]\n+    deps += [\n+      \""//components/printing/browser\"",\n+      \""//printing\"",\n+    ]\n     if (use_cups) {\n       configs += [ \""//printing:cups\"" ]\n     }""}<_**next**_>{""sha"": ""20c22c6758f1b3353627d510ee4cfe71ef980b8b"", ""filename"": ""chrome/utility/chrome_content_utility_client.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/utility/chrome_content_utility_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -73,7 +73,7 @@\n \n #if BUILDFLAG(ENABLE_PRINTING)\n #include \""chrome/common/chrome_content_client.h\""\n-#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""  // nogncheck\n #include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""  // nogncheck\n #endif\n ""}<_**next**_>{""sha"": ""154e773645fadb49d560d3b3aa8cb4e1f3511e43"", ""filename"": ""components/printing/browser/BUILD.gn"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,8 @@\n \n static_library(\""browser\"") {\n   sources = [\n+    \""print_composite_client.cc\"",\n+    \""print_composite_client.h\"",\n     \""print_manager.cc\"",\n     \""print_manager.h\"",\n     \""print_manager_utils.cc\"",\n@@ -17,6 +19,9 @@ static_library(\""browser\"") {\n   deps = [\n     \""//base\"",\n     \""//components/printing/common\"",\n+    \""//components/printing/service/public/cpp:client\"",\n+    \""//mojo/public/cpp/system:system\"",\n     \""//printing\"",\n+    \""//services/service_manager/public/cpp\"",\n   ]\n }""}<_**next**_>{""sha"": ""f67625c944f981351fc84c69ea9c9f156b285839"", ""filename"": ""components/printing/browser/DEPS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/DEPS?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -1,3 +1,6 @@\n include_rules = [\n+  \""+components/printing/service/public/cpp\"",\n   \""+content/public/browser\"",\n+  \""+mojo/public/cpp/system\"",\n+  \""+services/service_manager/public/cpp\"",\n ]""}<_**next**_>{""sha"": ""e105223f7f9335c2aec939ac0fe4b4a5dbdfa97b"", ""filename"": ""components/printing/browser/print_composite_client.cc"", ""status"": ""added"", ""additions"": 79, ""deletions"": 0, ""changes"": 79, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,79 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""components/printing/browser/print_composite_client.h\""\n+\n+#include <memory>\n+#include <utility>\n+\n+#include \""base/threading/thread_task_runner_handle.h\""\n+#include \""content/public/browser/browser_thread.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n+#include \""services/service_manager/public/cpp/connector.h\""\n+\n+DEFINE_WEB_CONTENTS_USER_DATA_KEY(printing::PrintCompositeClient);\n+\n+namespace printing {\n+\n+PrintCompositeClient::PrintCompositeClient(content::WebContents* web_contents)\n+    : for_preview_(false) {}\n+\n+PrintCompositeClient::~PrintCompositeClient() {}\n+\n+void PrintCompositeClient::CreateConnectorRequest() {\n+  connector_ = service_manager::Connector::Create(&connector_request_);\n+  content::ServiceManagerConnection::GetForProcess()\n+      ->GetConnector()\n+      ->BindConnectorRequest(std::move(connector_request_));\n+}\n+\n+void PrintCompositeClient::DoComposite(\n+    base::SharedMemoryHandle handle,\n+    uint32_t data_size,\n+    mojom::PdfCompositor::CompositePdfCallback callback) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  DCHECK(data_size);\n+\n+  if (!connector_)\n+    CreateConnectorRequest();\n+  Composite(connector_.get(), handle, data_size, std::move(callback),\n+            base::ThreadTaskRunnerHandle::Get());\n+}\n+\n+std::unique_ptr<base::SharedMemory> PrintCompositeClient::GetShmFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  base::SharedMemoryHandle memory_handle;\n+  size_t memory_size = 0;\n+  bool read_only_flag = false;\n+\n+  const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n+      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n+  if (result != MOJO_RESULT_OK)\n+    return nullptr;\n+  DCHECK_GT(memory_size, 0u);\n+\n+  std::unique_ptr<base::SharedMemory> shm =\n+      base::MakeUnique<base::SharedMemory>(memory_handle, true /* read_only */);\n+  if (!shm->Map(memory_size)) {\n+    DLOG(ERROR) << \""Map shared memory failed.\"";\n+    return nullptr;\n+  }\n+  return shm;\n+}\n+\n+scoped_refptr<base::RefCountedBytes>\n+PrintCompositeClient::GetDataFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  std::unique_ptr<base::SharedMemory> shm =\n+      GetShmFromMojoHandle(std::move(handle));\n+  if (!shm)\n+    return nullptr;\n+\n+  return base::MakeRefCounted<base::RefCountedBytes>(\n+      reinterpret_cast<const unsigned char*>(shm->memory()),\n+      shm->mapped_size());\n+}\n+\n+}  // namespace printing""}<_**next**_>{""sha"": ""d63b34123520f5d66dbafe7c878c84f77725a91c"", ""filename"": ""components/printing/browser/print_composite_client.h"", ""status"": ""added"", ""additions"": 49, ""deletions"": 0, ""changes"": 49, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,49 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+#define COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_client.h\""\n+#include \""content/public/browser/web_contents_observer.h\""\n+#include \""content/public/browser/web_contents_user_data.h\""\n+\n+namespace printing {\n+\n+class PrintCompositeClient\n+    : public PdfCompositorClient,\n+      public content::WebContentsUserData<PrintCompositeClient> {\n+ public:\n+  explicit PrintCompositeClient(content::WebContents* web_contents);\n+  ~PrintCompositeClient() override;\n+\n+  void DoComposite(base::SharedMemoryHandle handle,\n+                   uint32_t data_size,\n+                   mojom::PdfCompositor::CompositePdfCallback callback);\n+\n+  void set_for_preview(bool for_preview) { for_preview_ = for_preview; }\n+  bool for_preview() const { return for_preview_; }\n+\n+  // Utility functions.\n+  static std::unique_ptr<base::SharedMemory> GetShmFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+  static scoped_refptr<base::RefCountedBytes> GetDataFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+\n+ private:\n+  void CreateConnectorRequest();\n+\n+  service_manager::mojom::ConnectorRequest connector_request_;\n+  std::unique_ptr<service_manager::Connector> connector_;\n+  bool for_preview_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(PrintCompositeClient);\n+};\n+\n+}  // namespace printing\n+\n+#endif  // COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_""}<_**next**_>{""sha"": ""844fcf5bd23513e52fa2a2eb7d9d958762e11ddf"", ""filename"": ""components/printing/browser/print_manager_utils.cc"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 1, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3,11 +3,43 @@\n // found in the LICENSE file.\n \n #include \""components/printing/browser/print_manager_utils.h\""\n+\n+#include \""base/command_line.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n #include \""components/printing/common/print_messages.h\""\n+#include \""content/public/common/content_features.h\""\n+#include \""content/public/common/content_switches.h\""\n #include \""printing/print_settings.h\""\n \n namespace printing {\n \n+// A temporary flag which makes supporting both paths for OOPIF and non-OOPIF\n+// printing easier.\n+static bool g_oopif_enabled = false;\n+\n+void SetOopifEnabled() {\n+  g_oopif_enabled = true;\n+}\n+\n+bool IsOopifEnabled() {\n+  return g_oopif_enabled;\n+}\n+\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview) {\n+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n+          switches::kSitePerProcess) ||\n+      base::FeatureList::IsEnabled(features::kTopDocumentIsolation)) {\n+    // For cases need to support OOPIFs.\n+    PrintCompositeClient::CreateForWebContents(web_contents);\n+    if (for_preview) {\n+      PrintCompositeClient::FromWebContents(web_contents)\n+          ->set_for_preview(true);\n+    }\n+    SetOopifEnabled();\n+  }\n+}\n+\n void RenderParamsFromPrintSettings(const PrintSettings& settings,\n                                    PrintMsg_Print_Params* params) {\n   params->page_size = settings.page_setup_device_units().physical_size();\n@@ -32,7 +64,8 @@ void RenderParamsFromPrintSettings(const PrintSettings& settings,\n   params->display_header_footer = settings.display_header_footer();\n   params->title = settings.title();\n   params->url = settings.url();\n-  params->printed_doc_type = SkiaDocumentType::PDF;\n+  params->printed_doc_type =\n+      IsOopifEnabled() ? SkiaDocumentType::MSKP : SkiaDocumentType::PDF;\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""5b2b62a7dbf5599fbb51940906b2ed4697c5d0a2"", ""filename"": ""components/printing/browser/print_manager_utils.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,10 +7,22 @@\n \n struct PrintMsg_Print_Params;\n \n+namespace content {\n+class WebContents;\n+}\n+\n namespace printing {\n \n class PrintSettings;\n \n+void SetOopifEnabled(bool enabled);\n+bool IsOopifEnabled();\n+\n+// Check on the current feature settings to decide whether we need to\n+// create a PDF compositor client for this |web_contents|.\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview);\n+\n // Converts given settings to Print_Params and stores them in the output\n // parameter |params|.\n void RenderParamsFromPrintSettings(const PrintSettings& settings,""}<_**next**_>{""sha"": ""231fe97661ab55076dcd33cbc9dc12eeb29cbe83"", ""filename"": ""headless/lib/browser/headless_web_contents_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/headless/lib/browser/headless_web_contents_impl.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -322,6 +322,7 @@ HeadlessWebContentsImpl::HeadlessWebContentsImpl(\n       weak_ptr_factory_(this) {\n #if BUILDFLAG(ENABLE_BASIC_PRINTING) && !defined(CHROME_MULTIPLE_DLL_CHILD)\n   HeadlessPrintManager::CreateForWebContents(web_contents);\n+// TODO(weili): Add support for printing OOPIFs.\n #endif\n   web_contents->GetMutableRendererPrefs()->accept_languages =\n       browser_context->options()->accept_language();""}","PrintViewManagerBase::PrintViewManagerBase(content::WebContents* web_contents)
    : PrintManager(web_contents),
      printing_rfh_(nullptr),
      printing_succeeded_(false),
      inside_inner_message_loop_(false),
 #if !defined(OS_MACOSX)
       expecting_first_page_(true),
 #endif
      queue_(g_browser_process->print_job_manager()->queue()),
      weak_ptr_factory_(this) {
   DCHECK(queue_.get());
   Profile* profile =
       Profile::FromBrowserContext(web_contents->GetBrowserContext());
  printing_enabled_.Init(
      prefs::kPrintingEnabled, profile->GetPrefs(),
      base::Bind(&PrintViewManagerBase::UpdatePrintingEnabled,
                 base::Unretained(this)));
}
","PrintViewManagerBase::PrintViewManagerBase(content::WebContents* web_contents)
    : PrintManager(web_contents),
      printing_rfh_(nullptr),
      printing_succeeded_(false),
      inside_inner_message_loop_(false),
 #if !defined(OS_MACOSX)
       expecting_first_page_(true),
 #endif
      queue_(g_browser_process->print_job_manager()->queue()) {
   DCHECK(queue_.get());
   Profile* profile =
       Profile::FromBrowserContext(web_contents->GetBrowserContext());
  printing_enabled_.Init(
      prefs::kPrintingEnabled, profile->GetPrefs(),
      base::Bind(&PrintViewManagerBase::UpdatePrintingEnabled,
                 base::Unretained(this)));
}
",C,"      queue_(g_browser_process->print_job_manager()->queue()),
      weak_ptr_factory_(this) {
","      queue_(g_browser_process->print_job_manager()->queue()) {
",,"@@ -11,6 +11,7 @@
 #include ""base/bind.h""
 #include ""base/location.h""
 #include ""base/memory/ptr_util.h""
+#include ""base/memory/shared_memory.h""
 #include ""base/message_loop/message_loop.h""
 #include ""base/run_loop.h""
 #include ""base/single_thread_task_runner.h""
@@ -28,6 +29,8 @@
 #include ""chrome/common/pref_names.h""
 #include ""chrome/grit/generated_resources.h""
 #include ""components/prefs/pref_service.h""
+#include ""components/printing/browser/print_composite_client.h""
+#include ""components/printing/browser/print_manager_utils.h""
 #include ""components/printing/common/print_messages.h""
 #include ""content/public/browser/browser_thread.h""
 #include ""content/public/browser/notification_details.h""
@@ -36,8 +39,10 @@
 #include ""content/public/browser/render_frame_host.h""
 #include ""content/public/browser/render_view_host.h""
 #include ""content/public/browser/web_contents.h""
+#include ""mojo/public/cpp/system/buffer.h""
 #include ""printing/features/features.h""
 #include ""printing/pdf_metafile_skia.h""
+#include ""printing/print_settings.h""
 #include ""printing/printed_document.h""
 #include ""ui/base/l10n/l10n_util.h""
 
@@ -78,7 +83,8 @@ PrintViewManagerBase::PrintViewManagerBase(content::WebContents* web_contents)
 #if !defined(OS_MACOSX)
       expecting_first_page_(true),
 #endif
-      queue_(g_browser_process->print_job_manager()->queue()) {
+      queue_(g_browser_process->print_job_manager()->queue()),
+      weak_ptr_factory_(this) {
   DCHECK(queue_.get());
   Profile* profile =
       Profile::FromBrowserContext(web_contents->GetBrowserContext());
@@ -127,8 +133,24 @@ void PrintViewManagerBase::OnDidGetPrintedPagesCount(int cookie,
   OpportunisticallyCreatePrintJob(cookie);
 }
 
+void PrintViewManagerBase::OnComposePdfDone(
+    const PrintHostMsg_DidPrintPage_Params& params,
+    mojom::PdfCompositor::Status status,
+    mojo::ScopedSharedBufferHandle handle) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  if (status != mojom::PdfCompositor::Status::SUCCESS) {
+    DLOG(ERROR) << ""Compositing pdf failed with error "" << status;
+    return;
+  }
+
+  UpdateForPrintedPage(
+      params, true,
+      PrintCompositeClient::GetShmFromMojoHandle(std::move(handle)));
+}
+
 void PrintViewManagerBase::OnDidPrintPage(
-  const PrintHostMsg_DidPrintPage_Params& params) {
+    const PrintHostMsg_DidPrintPage_Params& params) {
+  // Ready to composite. Starting a print job.
   if (!OpportunisticallyCreatePrintJob(params.document_cookie))
     return;
 
@@ -154,8 +176,18 @@ void PrintViewManagerBase::OnDidPrintPage(
       web_contents()->Stop();
       return;
     }
+
+    auto* client = PrintCompositeClient::FromWebContents(web_contents());
+    if (IsOopifEnabled() && !client->for_preview() &&
+        !document->settings().is_modifiable()) {
+      client->DoComposite(
+          params.metafile_data_handle, params.data_size,
+          base::BindOnce(&PrintViewManagerBase::OnComposePdfDone,
+                         weak_ptr_factory_.GetWeakPtr(), params));
+      return;
+    }
     shared_buf =
-        base::MakeUnique<base::SharedMemory>(params.metafile_data_handle, true);
+        std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);
     if (!shared_buf->Map(params.data_size)) {
       NOTREACHED() << ""couldn't map"";
       web_contents()->Stop();
@@ -170,22 +202,24 @@ void PrintViewManagerBase::OnDidPrintPage(
     }
   }
 
-  std::unique_ptr<PdfMetafileSkia> metafile(
-      new PdfMetafileSkia(SkiaDocumentType::PDF));
-  if (metafile_must_be_valid) {
-    if (!metafile->InitFromData(shared_buf->memory(), params.data_size)) {
-      NOTREACHED() << ""Invalid metafile header"";
-      web_contents()->Stop();
-      return;
-    }
-  }
+  UpdateForPrintedPage(params, metafile_must_be_valid, std::move(shared_buf));
+}
+
+void PrintViewManagerBase::UpdateForPrintedPage(
+    const PrintHostMsg_DidPrintPage_Params& params,
+    bool has_valid_page_data,
+    std::unique_ptr<base::SharedMemory> shared_buf) {
+  PrintedDocument* document = print_job_->document();
+  if (!document)
+    return;
 
 #if defined(OS_WIN)
   print_job_->AppendPrintedPage(params.page_number);
-  if (metafile_must_be_valid) {
-    scoped_refptr<base::RefCountedBytes> bytes = new base::RefCountedBytes(
+  if (has_valid_page_data) {
+    scoped_refptr<base::RefCountedBytes> bytes(new base::RefCountedBytes(
         reinterpret_cast<const unsigned char*>(shared_buf->memory()),
-        params.data_size);
+        shared_buf->mapped_size()));
+
     document->DebugDumpData(bytes.get(), FILE_PATH_LITERAL("".pdf""));
 
     const auto& settings = document->settings();
@@ -203,22 +237,27 @@ void PrintViewManagerBase::OnDidPrintPage(
       // Update : The missing letters seem to have been caused by the same
       // problem as https://crbug.com/659604 which was resolved. GDI printing
       // seems to work with the fix for this bug applied.
-      bool print_text_with_gdi = settings.print_text_with_gdi() &&
-                                 !settings.printer_is_xps() &&
-                                 base::FeatureList::IsEnabled(
-                                     features::kGdiTextPrinting);
+      bool print_text_with_gdi =
+          settings.print_text_with_gdi() && !settings.printer_is_xps() &&
+          base::FeatureList::IsEnabled(features::kGdiTextPrinting);
       print_job_->StartPdfToEmfConversion(
           bytes, params.page_size, params.content_area, print_text_with_gdi);
     }
   }
 #else
+  std::unique_ptr<PdfMetafileSkia> metafile =
+      std::make_unique<PdfMetafileSkia>(SkiaDocumentType::PDF);
+  if (has_valid_page_data) {
+    if (!metafile->InitFromData(shared_buf->memory(),
+                                shared_buf->mapped_size())) {
+      NOTREACHED() << ""Invalid metafile header"";
+      web_contents()->Stop();
+      return;
+    }
+  }
+
   // Update the rendered document. It will send notifications to the listener.
-  document->SetPage(params.page_number,
-                    std::move(metafile),
-#if defined(OS_WIN)
-                    0.0f /* dummy shrink_factor */,
-#endif
-                    params.page_size,
+  document->SetPage(params.page_number, std::move(metafile), params.page_size,
                     params.content_area);
 
   ShouldQuitFromInnerMessageLoop();",Chrome,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,896aab1971cb86907e97ea09726b3872fbfde09a,1,"PrintViewManagerBase::PrintViewManagerBase(content::WebContents* web_contents)
    : PrintManager(web_contents),
      printing_rfh_(nullptr),
      printing_succeeded_(false),
      inside_inner_message_loop_(false),
 #if !defined(OS_MACOSX)
       expecting_first_page_(true),
 #endif
//flaw_line_below:
      queue_(g_browser_process->print_job_manager()->queue()) {
//fix_flaw_line_below:
//      queue_(g_browser_process->print_job_manager()->queue()),
//fix_flaw_line_below:
//      weak_ptr_factory_(this) {
   DCHECK(queue_.get());
   Profile* profile =
       Profile::FromBrowserContext(web_contents->GetBrowserContext());
  printing_enabled_.Init(
      prefs::kPrintingEnabled, profile->GetPrefs(),
      base::Bind(&PrintViewManagerBase::UpdatePrintingEnabled,
                 base::Unretained(this)));
}
"
8036,185772,,Remote,Not required,,CVE-2015-1300,https://www.cvedetails.com/cve/CVE-2015-1300/,CWE-254,Low,Partial,,,2015-09-03,5.0,"The FrameFetchContext::updateTimingInfoForIFrameNavigation function in core/loader/FrameFetchContext.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not properly restrict the availability of IFRAME Resource Timing API times, which allows remote attackers to obtain sensitive information via crafted JavaScript code that leverages a history.back call.",2016-12-21,+Info ,1,https://github.com/chromium/chromium/commit/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,"Use pdf compositor service for printing when OOPIF is enabled

When OOPIF is enabled (by site-per-process flag or
top-document-isolation feature), use the pdf compositor service for
converting PaintRecord to PDF on renderers.

In the future, this will make compositing PDF from multiple renderers
possible.

TBR=jzfeng@chromium.org
BUG=455764

Change-Id: I3c28f03f4358e4228239fe1a33384f85e7716e8f
Reviewed-on: https://chromium-review.googlesource.com/699765
Commit-Queue: Wei Li <weili@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Cr-Commit-Position: refs/heads/master@{#511616}",0,chrome/browser/printing/printing_init.cc,"{""sha"": ""78193d61b9f59cdc78ed504e7a6939379d4f52d5"", ""filename"": ""chrome/browser/chrome_content_browser_manifest_overlay.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chrome_content_browser_manifest_overlay.json?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -44,6 +44,7 @@\n         \""local_state\"": [ \""pref_client\"" ],\n         \""nacl_broker\"": [ \""browser\"" ],\n         \""nacl_loader\"": [ \""browser\"" ],\n+        \""pdf_compositor\"": [ \""compositor\"" ],\n         \""profile_import\"": [ \""import\"" ],\n         \""profiling\"": [ \""profiling\"" ],\n         \""proxy_resolver\"": [ \""factory\"" ],""}<_**next**_>{""sha"": ""449ec7465b049d91941d3413bafcb8ee1904d417"", ""filename"": ""chrome/browser/printing/print_preview_dialog_controller.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_dialog_controller.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -29,6 +29,7 @@\n #include \""chrome/common/chrome_paths.h\""\n #include \""chrome/common/url_constants.h\""\n #include \""components/guest_view/browser/guest_view_base.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/web_modal/web_contents_modal_dialog_host.h\""\n #include \""content/public/browser/host_zoom_map.h\""\n #include \""content/public/browser/navigation_controller.h\""\n@@ -376,6 +377,7 @@ WebContents* PrintPreviewDialogController::CreatePrintPreviewDialog(\n   content::HostZoomMap::Get(preview_dialog->GetSiteInstance())\n       ->SetZoomLevelForHostAndScheme(print_url.scheme(), print_url.host(), 0);\n   PrintViewManager::CreateForWebContents(preview_dialog);\n+  CreateCompositeClientIfNeeded(preview_dialog, true /* for_preview */);\n   extensions::ChromeExtensionWebContentsObserver::CreateForWebContents(\n       preview_dialog);\n ""}<_**next**_>{""sha"": ""cda7ad2e7612be69842877448291d3be54317a64"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.cc"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 22, ""changes"": 116, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -14,18 +14,22 @@\n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/ref_counted_memory.h\""\n #include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n #include \""chrome/browser/browser_process.h\""\n #include \""chrome/browser/printing/print_job_manager.h\""\n #include \""chrome/browser/printing/print_preview_dialog_controller.h\""\n #include \""chrome/browser/printing/print_view_manager.h\""\n #include \""chrome/browser/printing/printer_query.h\""\n #include \""chrome/browser/ui/webui/print_preview/print_preview_ui.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""content/public/browser/web_ui.h\""\n #include \""printing/page_size_margins.h\""\n #include \""printing/print_job_constants.h\""\n+#include \""printing/print_settings.h\""\n \n using content::BrowserThread;\n using content::WebContents;\n@@ -69,7 +73,7 @@ scoped_refptr<base::RefCountedBytes> GetDataFromHandle(\n \n PrintPreviewMessageHandler::PrintPreviewMessageHandler(\n     WebContents* web_contents)\n-    : content::WebContentsObserver(web_contents) {\n+    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {\n   DCHECK(web_contents);\n }\n \n@@ -129,13 +133,21 @@ void PrintPreviewMessageHandler::OnDidPreviewPage(\n   if (!print_preview_ui)\n     return;\n \n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  DCHECK(data_bytes);\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    // Use utility process to convert skia metafile to pdf.\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,\n+                       weak_ptr_factory_.GetWeakPtr(), params.page_number,\n+                       params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewPageReady(\n+        page_number, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n@@ -152,18 +164,20 @@ void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n   if (!print_preview_ui)\n     return;\n \n-  // TODO(joth): This seems like a good match for using RefCountedStaticMemory\n-  // to avoid the memory copy, but the SetPrintPreviewData call chain below\n-  // needs updating to accept the RefCountedMemory* base class.\n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  if (!data_bytes || !data_bytes->size())\n-    return;\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnPreviewDataIsAvailable(\n-      params.expected_pages_count, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,\n+                       weak_ptr_factory_.GetWeakPtr(),\n+                       params.expected_pages_count, params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewDocumentReady(\n+        params.expected_pages_count, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnPrintPreviewFailed(int document_cookie) {\n@@ -214,6 +228,65 @@ void PrintPreviewMessageHandler::OnSetOptionsFromDocument(\n   print_preview_ui->OnSetOptionsFromDocument(params);\n }\n \n+void PrintPreviewMessageHandler::NotifyUIPreviewPageReady(\n+    int page_number,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  DCHECK(data_bytes);\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnDidPreviewPage(page_number, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::NotifyUIPreviewDocumentReady(\n+    int page_count,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  if (!data_bytes || !data_bytes->size())\n+    return;\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnPreviewDataIsAvailable(page_count, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfPageDone(\n+    int page_number,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewPageReady(\n+      page_number, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfDocumentDone(\n+    int page_count,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewDocumentReady(\n+      page_count, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n bool PrintPreviewMessageHandler::OnMessageReceived(\n     const IPC::Message& message,\n     content::RenderFrameHost* render_frame_host) {\n@@ -231,8 +304,7 @@ bool PrintPreviewMessageHandler::OnMessageReceived(\n   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,\n                         OnDidGetPreviewPageCount)\n-    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,\n-                        OnDidPreviewPage)\n+    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,\n                         OnMetafileReadyForPrinting)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,""}<_**next**_>{""sha"": ""71ca9d5bb1ee142ed3dbbfaa34cd8ab5d3018002"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.h"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,6 +7,9 @@\n \n #include \""base/compiler_specific.h\""\n #include \""base/macros.h\""\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/weak_ptr.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/web_contents_observer.h\""\n #include \""content/public/browser/web_contents_user_data.h\""\n \n@@ -70,6 +73,27 @@ class PrintPreviewMessageHandler\n   void OnSetOptionsFromDocument(\n       const PrintHostMsg_SetOptionsFromDocument_Params& params);\n \n+  void NotifyUIPreviewPageReady(\n+      int page_number,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+  void NotifyUIPreviewDocumentReady(\n+      int page_count,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+\n+  // Callbacks for pdf compositor client.\n+  void OnCompositePdfPageDone(int page_number,\n+                              int request_id,\n+                              mojom::PdfCompositor::Status status,\n+                              mojo::ScopedSharedBufferHandle handle);\n+  void OnCompositePdfDocumentDone(int page_count,\n+                                  int request_id,\n+                                  mojom::PdfCompositor::Status status,\n+                                  mojo::ScopedSharedBufferHandle handle);\n+\n+  base::WeakPtrFactory<PrintPreviewMessageHandler> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintPreviewMessageHandler);\n };\n ""}<_**next**_>{""sha"": ""f4fed9d2753dbd8b374dfb9b6f006cf51010d5cf"", ""filename"": ""chrome/browser/printing/print_view_manager_base.cc"", ""status"": ""modified"", ""additions"": 64, ""deletions"": 25, ""changes"": 89, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -11,6 +11,7 @@\n #include \""base/bind.h\""\n #include \""base/location.h\""\n #include \""base/memory/ptr_util.h\""\n+#include \""base/memory/shared_memory.h\""\n #include \""base/message_loop/message_loop.h\""\n #include \""base/run_loop.h\""\n #include \""base/single_thread_task_runner.h\""\n@@ -28,6 +29,8 @@\n #include \""chrome/common/pref_names.h\""\n #include \""chrome/grit/generated_resources.h\""\n #include \""components/prefs/pref_service.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/notification_details.h\""\n@@ -36,8 +39,10 @@\n #include \""content/public/browser/render_frame_host.h\""\n #include \""content/public/browser/render_view_host.h\""\n #include \""content/public/browser/web_contents.h\""\n+#include \""mojo/public/cpp/system/buffer.h\""\n #include \""printing/features/features.h\""\n #include \""printing/pdf_metafile_skia.h\""\n+#include \""printing/print_settings.h\""\n #include \""printing/printed_document.h\""\n #include \""ui/base/l10n/l10n_util.h\""\n \n@@ -78,7 +83,8 @@ PrintViewManagerBase::PrintViewManagerBase(content::WebContents* web_contents)\n #if !defined(OS_MACOSX)\n       expecting_first_page_(true),\n #endif\n-      queue_(g_browser_process->print_job_manager()->queue()) {\n+      queue_(g_browser_process->print_job_manager()->queue()),\n+      weak_ptr_factory_(this) {\n   DCHECK(queue_.get());\n   Profile* profile =\n       Profile::FromBrowserContext(web_contents->GetBrowserContext());\n@@ -127,8 +133,24 @@ void PrintViewManagerBase::OnDidGetPrintedPagesCount(int cookie,\n   OpportunisticallyCreatePrintJob(cookie);\n }\n \n+void PrintViewManagerBase::OnComposePdfDone(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+\n+  UpdateForPrintedPage(\n+      params, true,\n+      PrintCompositeClient::GetShmFromMojoHandle(std::move(handle)));\n+}\n+\n void PrintViewManagerBase::OnDidPrintPage(\n-  const PrintHostMsg_DidPrintPage_Params& params) {\n+    const PrintHostMsg_DidPrintPage_Params& params) {\n+  // Ready to composite. Starting a print job.\n   if (!OpportunisticallyCreatePrintJob(params.document_cookie))\n     return;\n \n@@ -154,8 +176,18 @@ void PrintViewManagerBase::OnDidPrintPage(\n       web_contents()->Stop();\n       return;\n     }\n+\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    if (IsOopifEnabled() && !client->for_preview() &&\n+        !document->settings().is_modifiable()) {\n+      client->DoComposite(\n+          params.metafile_data_handle, params.data_size,\n+          base::BindOnce(&PrintViewManagerBase::OnComposePdfDone,\n+                         weak_ptr_factory_.GetWeakPtr(), params));\n+      return;\n+    }\n     shared_buf =\n-        base::MakeUnique<base::SharedMemory>(params.metafile_data_handle, true);\n+        std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);\n     if (!shared_buf->Map(params.data_size)) {\n       NOTREACHED() << \""couldn't map\"";\n       web_contents()->Stop();\n@@ -170,22 +202,24 @@ void PrintViewManagerBase::OnDidPrintPage(\n     }\n   }\n \n-  std::unique_ptr<PdfMetafileSkia> metafile(\n-      new PdfMetafileSkia(SkiaDocumentType::PDF));\n-  if (metafile_must_be_valid) {\n-    if (!metafile->InitFromData(shared_buf->memory(), params.data_size)) {\n-      NOTREACHED() << \""Invalid metafile header\"";\n-      web_contents()->Stop();\n-      return;\n-    }\n-  }\n+  UpdateForPrintedPage(params, metafile_must_be_valid, std::move(shared_buf));\n+}\n+\n+void PrintViewManagerBase::UpdateForPrintedPage(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    bool has_valid_page_data,\n+    std::unique_ptr<base::SharedMemory> shared_buf) {\n+  PrintedDocument* document = print_job_->document();\n+  if (!document)\n+    return;\n \n #if defined(OS_WIN)\n   print_job_->AppendPrintedPage(params.page_number);\n-  if (metafile_must_be_valid) {\n-    scoped_refptr<base::RefCountedBytes> bytes = new base::RefCountedBytes(\n+  if (has_valid_page_data) {\n+    scoped_refptr<base::RefCountedBytes> bytes(new base::RefCountedBytes(\n         reinterpret_cast<const unsigned char*>(shared_buf->memory()),\n-        params.data_size);\n+        shared_buf->mapped_size()));\n+\n     document->DebugDumpData(bytes.get(), FILE_PATH_LITERAL(\"".pdf\""));\n \n     const auto& settings = document->settings();\n@@ -203,22 +237,27 @@ void PrintViewManagerBase::OnDidPrintPage(\n       // Update : The missing letters seem to have been caused by the same\n       // problem as https://crbug.com/659604 which was resolved. GDI printing\n       // seems to work with the fix for this bug applied.\n-      bool print_text_with_gdi = settings.print_text_with_gdi() &&\n-                                 !settings.printer_is_xps() &&\n-                                 base::FeatureList::IsEnabled(\n-                                     features::kGdiTextPrinting);\n+      bool print_text_with_gdi =\n+          settings.print_text_with_gdi() && !settings.printer_is_xps() &&\n+          base::FeatureList::IsEnabled(features::kGdiTextPrinting);\n       print_job_->StartPdfToEmfConversion(\n           bytes, params.page_size, params.content_area, print_text_with_gdi);\n     }\n   }\n #else\n+  std::unique_ptr<PdfMetafileSkia> metafile =\n+      std::make_unique<PdfMetafileSkia>(SkiaDocumentType::PDF);\n+  if (has_valid_page_data) {\n+    if (!metafile->InitFromData(shared_buf->memory(),\n+                                shared_buf->mapped_size())) {\n+      NOTREACHED() << \""Invalid metafile header\"";\n+      web_contents()->Stop();\n+      return;\n+    }\n+  }\n+\n   // Update the rendered document. It will send notifications to the listener.\n-  document->SetPage(params.page_number,\n-                    std::move(metafile),\n-#if defined(OS_WIN)\n-                    0.0f /* dummy shrink_factor */,\n-#endif\n-                    params.page_size,\n+  document->SetPage(params.page_number, std::move(metafile), params.page_size,\n                     params.content_area);\n \n   ShouldQuitFromInnerMessageLoop();""}<_**next**_>{""sha"": ""e9706e34f8c96f224196aa8ffc993b44a9247cf9"", ""filename"": ""chrome/browser/printing/print_view_manager_base.h"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 1, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -9,16 +9,23 @@\n \n #include \""base/macros.h\""\n #include \""base/memory/ref_counted.h\""\n+#include \""base/memory/weak_ptr.h\""\n #include \""base/strings/string16.h\""\n #include \""build/build_config.h\""\n #include \""components/prefs/pref_member.h\""\n #include \""components/printing/browser/print_manager.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/notification_observer.h\""\n #include \""content/public/browser/notification_registrar.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n #include \""printing/features/features.h\""\n \n struct PrintHostMsg_DidPrintPage_Params;\n \n+namespace base {\n+class SharedMemory;\n+}\n+\n namespace content {\n class RenderFrameHost;\n }\n@@ -82,9 +89,19 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   // IPC Message handlers.\n   void OnDidGetPrintedPagesCount(int cookie, int number_pages) override;\n-  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n   void OnPrintingFailed(int cookie) override;\n   void OnShowInvalidPrinterSettingsError();\n+  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n+\n+  // Handle extra tasks once a page or doc is printed.\n+  void UpdateForPrintedPage(const PrintHostMsg_DidPrintPage_Params& params,\n+                            bool has_valid_page_data,\n+                            std::unique_ptr<base::SharedMemory> shared_buf);\n+\n+  // IPC message handlers for service.\n+  void OnComposePdfDone(const PrintHostMsg_DidPrintPage_Params& params,\n+                        mojom::PdfCompositor::Status status,\n+                        mojo::ScopedSharedBufferHandle handle);\n \n   // Processes a NOTIFY_PRINT_JOB_EVENT notification.\n   void OnNotifyPrintJobEvent(const JobEventDetails& event_details);\n@@ -163,6 +180,8 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   scoped_refptr<printing::PrintQueriesQueue> queue_;\n \n+  base::WeakPtrFactory<PrintViewManagerBase> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintViewManagerBase);\n };\n ""}<_**next**_>{""sha"": ""3560d1c793977a5c2fe67253c9cf9509dbe596a1"", ""filename"": ""chrome/browser/printing/printing_init.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/printing_init.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""chrome/browser/printing/printing_init.h\""\n \n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""printing/features/features.h\""\n \n@@ -23,6 +24,7 @@ void InitializePrinting(content::WebContents* web_contents) {\n #else\n   printing::PrintViewManagerBasic::CreateForWebContents(web_contents);\n #endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)\n+  CreateCompositeClientIfNeeded(web_contents, false /* for_preview */);\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""84901e64744b737a1810f2e3c513498bfea57fb6"", ""filename"": ""chrome/browser/ui/BUILD.gn"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3475,7 +3475,10 @@ split_static_library(\""ui\"") {\n   }\n \n   if (enable_basic_printing || enable_print_preview) {\n-    deps += [ \""//printing\"" ]\n+    deps += [\n+      \""//components/printing/browser\"",\n+      \""//printing\"",\n+    ]\n     if (use_cups) {\n       configs += [ \""//printing:cups\"" ]\n     }""}<_**next**_>{""sha"": ""20c22c6758f1b3353627d510ee4cfe71ef980b8b"", ""filename"": ""chrome/utility/chrome_content_utility_client.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/utility/chrome_content_utility_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -73,7 +73,7 @@\n \n #if BUILDFLAG(ENABLE_PRINTING)\n #include \""chrome/common/chrome_content_client.h\""\n-#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""  // nogncheck\n #include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""  // nogncheck\n #endif\n ""}<_**next**_>{""sha"": ""154e773645fadb49d560d3b3aa8cb4e1f3511e43"", ""filename"": ""components/printing/browser/BUILD.gn"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,8 @@\n \n static_library(\""browser\"") {\n   sources = [\n+    \""print_composite_client.cc\"",\n+    \""print_composite_client.h\"",\n     \""print_manager.cc\"",\n     \""print_manager.h\"",\n     \""print_manager_utils.cc\"",\n@@ -17,6 +19,9 @@ static_library(\""browser\"") {\n   deps = [\n     \""//base\"",\n     \""//components/printing/common\"",\n+    \""//components/printing/service/public/cpp:client\"",\n+    \""//mojo/public/cpp/system:system\"",\n     \""//printing\"",\n+    \""//services/service_manager/public/cpp\"",\n   ]\n }""}<_**next**_>{""sha"": ""f67625c944f981351fc84c69ea9c9f156b285839"", ""filename"": ""components/printing/browser/DEPS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/DEPS?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -1,3 +1,6 @@\n include_rules = [\n+  \""+components/printing/service/public/cpp\"",\n   \""+content/public/browser\"",\n+  \""+mojo/public/cpp/system\"",\n+  \""+services/service_manager/public/cpp\"",\n ]""}<_**next**_>{""sha"": ""e105223f7f9335c2aec939ac0fe4b4a5dbdfa97b"", ""filename"": ""components/printing/browser/print_composite_client.cc"", ""status"": ""added"", ""additions"": 79, ""deletions"": 0, ""changes"": 79, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,79 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""components/printing/browser/print_composite_client.h\""\n+\n+#include <memory>\n+#include <utility>\n+\n+#include \""base/threading/thread_task_runner_handle.h\""\n+#include \""content/public/browser/browser_thread.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n+#include \""services/service_manager/public/cpp/connector.h\""\n+\n+DEFINE_WEB_CONTENTS_USER_DATA_KEY(printing::PrintCompositeClient);\n+\n+namespace printing {\n+\n+PrintCompositeClient::PrintCompositeClient(content::WebContents* web_contents)\n+    : for_preview_(false) {}\n+\n+PrintCompositeClient::~PrintCompositeClient() {}\n+\n+void PrintCompositeClient::CreateConnectorRequest() {\n+  connector_ = service_manager::Connector::Create(&connector_request_);\n+  content::ServiceManagerConnection::GetForProcess()\n+      ->GetConnector()\n+      ->BindConnectorRequest(std::move(connector_request_));\n+}\n+\n+void PrintCompositeClient::DoComposite(\n+    base::SharedMemoryHandle handle,\n+    uint32_t data_size,\n+    mojom::PdfCompositor::CompositePdfCallback callback) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  DCHECK(data_size);\n+\n+  if (!connector_)\n+    CreateConnectorRequest();\n+  Composite(connector_.get(), handle, data_size, std::move(callback),\n+            base::ThreadTaskRunnerHandle::Get());\n+}\n+\n+std::unique_ptr<base::SharedMemory> PrintCompositeClient::GetShmFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  base::SharedMemoryHandle memory_handle;\n+  size_t memory_size = 0;\n+  bool read_only_flag = false;\n+\n+  const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n+      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n+  if (result != MOJO_RESULT_OK)\n+    return nullptr;\n+  DCHECK_GT(memory_size, 0u);\n+\n+  std::unique_ptr<base::SharedMemory> shm =\n+      base::MakeUnique<base::SharedMemory>(memory_handle, true /* read_only */);\n+  if (!shm->Map(memory_size)) {\n+    DLOG(ERROR) << \""Map shared memory failed.\"";\n+    return nullptr;\n+  }\n+  return shm;\n+}\n+\n+scoped_refptr<base::RefCountedBytes>\n+PrintCompositeClient::GetDataFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  std::unique_ptr<base::SharedMemory> shm =\n+      GetShmFromMojoHandle(std::move(handle));\n+  if (!shm)\n+    return nullptr;\n+\n+  return base::MakeRefCounted<base::RefCountedBytes>(\n+      reinterpret_cast<const unsigned char*>(shm->memory()),\n+      shm->mapped_size());\n+}\n+\n+}  // namespace printing""}<_**next**_>{""sha"": ""d63b34123520f5d66dbafe7c878c84f77725a91c"", ""filename"": ""components/printing/browser/print_composite_client.h"", ""status"": ""added"", ""additions"": 49, ""deletions"": 0, ""changes"": 49, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,49 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+#define COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_client.h\""\n+#include \""content/public/browser/web_contents_observer.h\""\n+#include \""content/public/browser/web_contents_user_data.h\""\n+\n+namespace printing {\n+\n+class PrintCompositeClient\n+    : public PdfCompositorClient,\n+      public content::WebContentsUserData<PrintCompositeClient> {\n+ public:\n+  explicit PrintCompositeClient(content::WebContents* web_contents);\n+  ~PrintCompositeClient() override;\n+\n+  void DoComposite(base::SharedMemoryHandle handle,\n+                   uint32_t data_size,\n+                   mojom::PdfCompositor::CompositePdfCallback callback);\n+\n+  void set_for_preview(bool for_preview) { for_preview_ = for_preview; }\n+  bool for_preview() const { return for_preview_; }\n+\n+  // Utility functions.\n+  static std::unique_ptr<base::SharedMemory> GetShmFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+  static scoped_refptr<base::RefCountedBytes> GetDataFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+\n+ private:\n+  void CreateConnectorRequest();\n+\n+  service_manager::mojom::ConnectorRequest connector_request_;\n+  std::unique_ptr<service_manager::Connector> connector_;\n+  bool for_preview_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(PrintCompositeClient);\n+};\n+\n+}  // namespace printing\n+\n+#endif  // COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_""}<_**next**_>{""sha"": ""844fcf5bd23513e52fa2a2eb7d9d958762e11ddf"", ""filename"": ""components/printing/browser/print_manager_utils.cc"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 1, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3,11 +3,43 @@\n // found in the LICENSE file.\n \n #include \""components/printing/browser/print_manager_utils.h\""\n+\n+#include \""base/command_line.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n #include \""components/printing/common/print_messages.h\""\n+#include \""content/public/common/content_features.h\""\n+#include \""content/public/common/content_switches.h\""\n #include \""printing/print_settings.h\""\n \n namespace printing {\n \n+// A temporary flag which makes supporting both paths for OOPIF and non-OOPIF\n+// printing easier.\n+static bool g_oopif_enabled = false;\n+\n+void SetOopifEnabled() {\n+  g_oopif_enabled = true;\n+}\n+\n+bool IsOopifEnabled() {\n+  return g_oopif_enabled;\n+}\n+\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview) {\n+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n+          switches::kSitePerProcess) ||\n+      base::FeatureList::IsEnabled(features::kTopDocumentIsolation)) {\n+    // For cases need to support OOPIFs.\n+    PrintCompositeClient::CreateForWebContents(web_contents);\n+    if (for_preview) {\n+      PrintCompositeClient::FromWebContents(web_contents)\n+          ->set_for_preview(true);\n+    }\n+    SetOopifEnabled();\n+  }\n+}\n+\n void RenderParamsFromPrintSettings(const PrintSettings& settings,\n                                    PrintMsg_Print_Params* params) {\n   params->page_size = settings.page_setup_device_units().physical_size();\n@@ -32,7 +64,8 @@ void RenderParamsFromPrintSettings(const PrintSettings& settings,\n   params->display_header_footer = settings.display_header_footer();\n   params->title = settings.title();\n   params->url = settings.url();\n-  params->printed_doc_type = SkiaDocumentType::PDF;\n+  params->printed_doc_type =\n+      IsOopifEnabled() ? SkiaDocumentType::MSKP : SkiaDocumentType::PDF;\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""5b2b62a7dbf5599fbb51940906b2ed4697c5d0a2"", ""filename"": ""components/printing/browser/print_manager_utils.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,10 +7,22 @@\n \n struct PrintMsg_Print_Params;\n \n+namespace content {\n+class WebContents;\n+}\n+\n namespace printing {\n \n class PrintSettings;\n \n+void SetOopifEnabled(bool enabled);\n+bool IsOopifEnabled();\n+\n+// Check on the current feature settings to decide whether we need to\n+// create a PDF compositor client for this |web_contents|.\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview);\n+\n // Converts given settings to Print_Params and stores them in the output\n // parameter |params|.\n void RenderParamsFromPrintSettings(const PrintSettings& settings,""}<_**next**_>{""sha"": ""231fe97661ab55076dcd33cbc9dc12eeb29cbe83"", ""filename"": ""headless/lib/browser/headless_web_contents_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/headless/lib/browser/headless_web_contents_impl.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -322,6 +322,7 @@ HeadlessWebContentsImpl::HeadlessWebContentsImpl(\n       weak_ptr_factory_(this) {\n #if BUILDFLAG(ENABLE_BASIC_PRINTING) && !defined(CHROME_MULTIPLE_DLL_CHILD)\n   HeadlessPrintManager::CreateForWebContents(web_contents);\n+// TODO(weili): Add support for printing OOPIFs.\n #endif\n   web_contents->GetMutableRendererPrefs()->accept_languages =\n       browser_context->options()->accept_language();""}","void InitializePrinting(content::WebContents* web_contents) {
#if BUILDFLAG(ENABLE_PRINT_PREVIEW)
  printing::PrintViewManager::CreateForWebContents(web_contents);
  printing::PrintPreviewMessageHandler::CreateForWebContents(web_contents);
 #else
   printing::PrintViewManagerBasic::CreateForWebContents(web_contents);
 #endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)
  CreateCompositeClientIfNeeded(web_contents, false /* for_preview */);
 }
","void InitializePrinting(content::WebContents* web_contents) {
#if BUILDFLAG(ENABLE_PRINT_PREVIEW)
  printing::PrintViewManager::CreateForWebContents(web_contents);
  printing::PrintPreviewMessageHandler::CreateForWebContents(web_contents);
 #else
   printing::PrintViewManagerBasic::CreateForWebContents(web_contents);
 #endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)
 }
",C,"  CreateCompositeClientIfNeeded(web_contents, false /* for_preview */);
",,,"@@ -4,6 +4,7 @@
 
 #include ""chrome/browser/printing/printing_init.h""
 
+#include ""components/printing/browser/print_manager_utils.h""
 #include ""content/public/browser/web_contents.h""
 #include ""printing/features/features.h""
 
@@ -23,6 +24,7 @@ void InitializePrinting(content::WebContents* web_contents) {
 #else
   printing::PrintViewManagerBasic::CreateForWebContents(web_contents);
 #endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)
+  CreateCompositeClientIfNeeded(web_contents, false /* for_preview */);
 }
 
 }  // namespace printing",Chrome,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,896aab1971cb86907e97ea09726b3872fbfde09a,1,"void InitializePrinting(content::WebContents* web_contents) {
#if BUILDFLAG(ENABLE_PRINT_PREVIEW)
  printing::PrintViewManager::CreateForWebContents(web_contents);
  printing::PrintPreviewMessageHandler::CreateForWebContents(web_contents);
 #else
   printing::PrintViewManagerBasic::CreateForWebContents(web_contents);
 #endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)
//fix_flaw_line_below:
//  CreateCompositeClientIfNeeded(web_contents, false /* for_preview */);
 }
"
8037,185773,,Remote,Not required,,CVE-2015-1300,https://www.cvedetails.com/cve/CVE-2015-1300/,CWE-254,Low,Partial,,,2015-09-03,5.0,"The FrameFetchContext::updateTimingInfoForIFrameNavigation function in core/loader/FrameFetchContext.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not properly restrict the availability of IFRAME Resource Timing API times, which allows remote attackers to obtain sensitive information via crafted JavaScript code that leverages a history.back call.",2016-12-21,+Info ,2,https://github.com/chromium/chromium/commit/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,"Use pdf compositor service for printing when OOPIF is enabled

When OOPIF is enabled (by site-per-process flag or
top-document-isolation feature), use the pdf compositor service for
converting PaintRecord to PDF on renderers.

In the future, this will make compositing PDF from multiple renderers
possible.

TBR=jzfeng@chromium.org
BUG=455764

Change-Id: I3c28f03f4358e4228239fe1a33384f85e7716e8f
Reviewed-on: https://chromium-review.googlesource.com/699765
Commit-Queue: Wei Li <weili@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Cr-Commit-Position: refs/heads/master@{#511616}",1,components/printing/browser/print_manager_utils.cc,"{""sha"": ""78193d61b9f59cdc78ed504e7a6939379d4f52d5"", ""filename"": ""chrome/browser/chrome_content_browser_manifest_overlay.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chrome_content_browser_manifest_overlay.json?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -44,6 +44,7 @@\n         \""local_state\"": [ \""pref_client\"" ],\n         \""nacl_broker\"": [ \""browser\"" ],\n         \""nacl_loader\"": [ \""browser\"" ],\n+        \""pdf_compositor\"": [ \""compositor\"" ],\n         \""profile_import\"": [ \""import\"" ],\n         \""profiling\"": [ \""profiling\"" ],\n         \""proxy_resolver\"": [ \""factory\"" ],""}<_**next**_>{""sha"": ""449ec7465b049d91941d3413bafcb8ee1904d417"", ""filename"": ""chrome/browser/printing/print_preview_dialog_controller.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_dialog_controller.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -29,6 +29,7 @@\n #include \""chrome/common/chrome_paths.h\""\n #include \""chrome/common/url_constants.h\""\n #include \""components/guest_view/browser/guest_view_base.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/web_modal/web_contents_modal_dialog_host.h\""\n #include \""content/public/browser/host_zoom_map.h\""\n #include \""content/public/browser/navigation_controller.h\""\n@@ -376,6 +377,7 @@ WebContents* PrintPreviewDialogController::CreatePrintPreviewDialog(\n   content::HostZoomMap::Get(preview_dialog->GetSiteInstance())\n       ->SetZoomLevelForHostAndScheme(print_url.scheme(), print_url.host(), 0);\n   PrintViewManager::CreateForWebContents(preview_dialog);\n+  CreateCompositeClientIfNeeded(preview_dialog, true /* for_preview */);\n   extensions::ChromeExtensionWebContentsObserver::CreateForWebContents(\n       preview_dialog);\n ""}<_**next**_>{""sha"": ""cda7ad2e7612be69842877448291d3be54317a64"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.cc"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 22, ""changes"": 116, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -14,18 +14,22 @@\n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/ref_counted_memory.h\""\n #include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n #include \""chrome/browser/browser_process.h\""\n #include \""chrome/browser/printing/print_job_manager.h\""\n #include \""chrome/browser/printing/print_preview_dialog_controller.h\""\n #include \""chrome/browser/printing/print_view_manager.h\""\n #include \""chrome/browser/printing/printer_query.h\""\n #include \""chrome/browser/ui/webui/print_preview/print_preview_ui.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""content/public/browser/web_ui.h\""\n #include \""printing/page_size_margins.h\""\n #include \""printing/print_job_constants.h\""\n+#include \""printing/print_settings.h\""\n \n using content::BrowserThread;\n using content::WebContents;\n@@ -69,7 +73,7 @@ scoped_refptr<base::RefCountedBytes> GetDataFromHandle(\n \n PrintPreviewMessageHandler::PrintPreviewMessageHandler(\n     WebContents* web_contents)\n-    : content::WebContentsObserver(web_contents) {\n+    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {\n   DCHECK(web_contents);\n }\n \n@@ -129,13 +133,21 @@ void PrintPreviewMessageHandler::OnDidPreviewPage(\n   if (!print_preview_ui)\n     return;\n \n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  DCHECK(data_bytes);\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    // Use utility process to convert skia metafile to pdf.\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,\n+                       weak_ptr_factory_.GetWeakPtr(), params.page_number,\n+                       params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewPageReady(\n+        page_number, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n@@ -152,18 +164,20 @@ void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n   if (!print_preview_ui)\n     return;\n \n-  // TODO(joth): This seems like a good match for using RefCountedStaticMemory\n-  // to avoid the memory copy, but the SetPrintPreviewData call chain below\n-  // needs updating to accept the RefCountedMemory* base class.\n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  if (!data_bytes || !data_bytes->size())\n-    return;\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnPreviewDataIsAvailable(\n-      params.expected_pages_count, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,\n+                       weak_ptr_factory_.GetWeakPtr(),\n+                       params.expected_pages_count, params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewDocumentReady(\n+        params.expected_pages_count, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnPrintPreviewFailed(int document_cookie) {\n@@ -214,6 +228,65 @@ void PrintPreviewMessageHandler::OnSetOptionsFromDocument(\n   print_preview_ui->OnSetOptionsFromDocument(params);\n }\n \n+void PrintPreviewMessageHandler::NotifyUIPreviewPageReady(\n+    int page_number,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  DCHECK(data_bytes);\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnDidPreviewPage(page_number, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::NotifyUIPreviewDocumentReady(\n+    int page_count,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  if (!data_bytes || !data_bytes->size())\n+    return;\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnPreviewDataIsAvailable(page_count, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfPageDone(\n+    int page_number,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewPageReady(\n+      page_number, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfDocumentDone(\n+    int page_count,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewDocumentReady(\n+      page_count, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n bool PrintPreviewMessageHandler::OnMessageReceived(\n     const IPC::Message& message,\n     content::RenderFrameHost* render_frame_host) {\n@@ -231,8 +304,7 @@ bool PrintPreviewMessageHandler::OnMessageReceived(\n   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,\n                         OnDidGetPreviewPageCount)\n-    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,\n-                        OnDidPreviewPage)\n+    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,\n                         OnMetafileReadyForPrinting)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,""}<_**next**_>{""sha"": ""71ca9d5bb1ee142ed3dbbfaa34cd8ab5d3018002"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.h"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,6 +7,9 @@\n \n #include \""base/compiler_specific.h\""\n #include \""base/macros.h\""\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/weak_ptr.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/web_contents_observer.h\""\n #include \""content/public/browser/web_contents_user_data.h\""\n \n@@ -70,6 +73,27 @@ class PrintPreviewMessageHandler\n   void OnSetOptionsFromDocument(\n       const PrintHostMsg_SetOptionsFromDocument_Params& params);\n \n+  void NotifyUIPreviewPageReady(\n+      int page_number,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+  void NotifyUIPreviewDocumentReady(\n+      int page_count,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+\n+  // Callbacks for pdf compositor client.\n+  void OnCompositePdfPageDone(int page_number,\n+                              int request_id,\n+                              mojom::PdfCompositor::Status status,\n+                              mojo::ScopedSharedBufferHandle handle);\n+  void OnCompositePdfDocumentDone(int page_count,\n+                                  int request_id,\n+                                  mojom::PdfCompositor::Status status,\n+                                  mojo::ScopedSharedBufferHandle handle);\n+\n+  base::WeakPtrFactory<PrintPreviewMessageHandler> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintPreviewMessageHandler);\n };\n ""}<_**next**_>{""sha"": ""f4fed9d2753dbd8b374dfb9b6f006cf51010d5cf"", ""filename"": ""chrome/browser/printing/print_view_manager_base.cc"", ""status"": ""modified"", ""additions"": 64, ""deletions"": 25, ""changes"": 89, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -11,6 +11,7 @@\n #include \""base/bind.h\""\n #include \""base/location.h\""\n #include \""base/memory/ptr_util.h\""\n+#include \""base/memory/shared_memory.h\""\n #include \""base/message_loop/message_loop.h\""\n #include \""base/run_loop.h\""\n #include \""base/single_thread_task_runner.h\""\n@@ -28,6 +29,8 @@\n #include \""chrome/common/pref_names.h\""\n #include \""chrome/grit/generated_resources.h\""\n #include \""components/prefs/pref_service.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/notification_details.h\""\n@@ -36,8 +39,10 @@\n #include \""content/public/browser/render_frame_host.h\""\n #include \""content/public/browser/render_view_host.h\""\n #include \""content/public/browser/web_contents.h\""\n+#include \""mojo/public/cpp/system/buffer.h\""\n #include \""printing/features/features.h\""\n #include \""printing/pdf_metafile_skia.h\""\n+#include \""printing/print_settings.h\""\n #include \""printing/printed_document.h\""\n #include \""ui/base/l10n/l10n_util.h\""\n \n@@ -78,7 +83,8 @@ PrintViewManagerBase::PrintViewManagerBase(content::WebContents* web_contents)\n #if !defined(OS_MACOSX)\n       expecting_first_page_(true),\n #endif\n-      queue_(g_browser_process->print_job_manager()->queue()) {\n+      queue_(g_browser_process->print_job_manager()->queue()),\n+      weak_ptr_factory_(this) {\n   DCHECK(queue_.get());\n   Profile* profile =\n       Profile::FromBrowserContext(web_contents->GetBrowserContext());\n@@ -127,8 +133,24 @@ void PrintViewManagerBase::OnDidGetPrintedPagesCount(int cookie,\n   OpportunisticallyCreatePrintJob(cookie);\n }\n \n+void PrintViewManagerBase::OnComposePdfDone(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+\n+  UpdateForPrintedPage(\n+      params, true,\n+      PrintCompositeClient::GetShmFromMojoHandle(std::move(handle)));\n+}\n+\n void PrintViewManagerBase::OnDidPrintPage(\n-  const PrintHostMsg_DidPrintPage_Params& params) {\n+    const PrintHostMsg_DidPrintPage_Params& params) {\n+  // Ready to composite. Starting a print job.\n   if (!OpportunisticallyCreatePrintJob(params.document_cookie))\n     return;\n \n@@ -154,8 +176,18 @@ void PrintViewManagerBase::OnDidPrintPage(\n       web_contents()->Stop();\n       return;\n     }\n+\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    if (IsOopifEnabled() && !client->for_preview() &&\n+        !document->settings().is_modifiable()) {\n+      client->DoComposite(\n+          params.metafile_data_handle, params.data_size,\n+          base::BindOnce(&PrintViewManagerBase::OnComposePdfDone,\n+                         weak_ptr_factory_.GetWeakPtr(), params));\n+      return;\n+    }\n     shared_buf =\n-        base::MakeUnique<base::SharedMemory>(params.metafile_data_handle, true);\n+        std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);\n     if (!shared_buf->Map(params.data_size)) {\n       NOTREACHED() << \""couldn't map\"";\n       web_contents()->Stop();\n@@ -170,22 +202,24 @@ void PrintViewManagerBase::OnDidPrintPage(\n     }\n   }\n \n-  std::unique_ptr<PdfMetafileSkia> metafile(\n-      new PdfMetafileSkia(SkiaDocumentType::PDF));\n-  if (metafile_must_be_valid) {\n-    if (!metafile->InitFromData(shared_buf->memory(), params.data_size)) {\n-      NOTREACHED() << \""Invalid metafile header\"";\n-      web_contents()->Stop();\n-      return;\n-    }\n-  }\n+  UpdateForPrintedPage(params, metafile_must_be_valid, std::move(shared_buf));\n+}\n+\n+void PrintViewManagerBase::UpdateForPrintedPage(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    bool has_valid_page_data,\n+    std::unique_ptr<base::SharedMemory> shared_buf) {\n+  PrintedDocument* document = print_job_->document();\n+  if (!document)\n+    return;\n \n #if defined(OS_WIN)\n   print_job_->AppendPrintedPage(params.page_number);\n-  if (metafile_must_be_valid) {\n-    scoped_refptr<base::RefCountedBytes> bytes = new base::RefCountedBytes(\n+  if (has_valid_page_data) {\n+    scoped_refptr<base::RefCountedBytes> bytes(new base::RefCountedBytes(\n         reinterpret_cast<const unsigned char*>(shared_buf->memory()),\n-        params.data_size);\n+        shared_buf->mapped_size()));\n+\n     document->DebugDumpData(bytes.get(), FILE_PATH_LITERAL(\"".pdf\""));\n \n     const auto& settings = document->settings();\n@@ -203,22 +237,27 @@ void PrintViewManagerBase::OnDidPrintPage(\n       // Update : The missing letters seem to have been caused by the same\n       // problem as https://crbug.com/659604 which was resolved. GDI printing\n       // seems to work with the fix for this bug applied.\n-      bool print_text_with_gdi = settings.print_text_with_gdi() &&\n-                                 !settings.printer_is_xps() &&\n-                                 base::FeatureList::IsEnabled(\n-                                     features::kGdiTextPrinting);\n+      bool print_text_with_gdi =\n+          settings.print_text_with_gdi() && !settings.printer_is_xps() &&\n+          base::FeatureList::IsEnabled(features::kGdiTextPrinting);\n       print_job_->StartPdfToEmfConversion(\n           bytes, params.page_size, params.content_area, print_text_with_gdi);\n     }\n   }\n #else\n+  std::unique_ptr<PdfMetafileSkia> metafile =\n+      std::make_unique<PdfMetafileSkia>(SkiaDocumentType::PDF);\n+  if (has_valid_page_data) {\n+    if (!metafile->InitFromData(shared_buf->memory(),\n+                                shared_buf->mapped_size())) {\n+      NOTREACHED() << \""Invalid metafile header\"";\n+      web_contents()->Stop();\n+      return;\n+    }\n+  }\n+\n   // Update the rendered document. It will send notifications to the listener.\n-  document->SetPage(params.page_number,\n-                    std::move(metafile),\n-#if defined(OS_WIN)\n-                    0.0f /* dummy shrink_factor */,\n-#endif\n-                    params.page_size,\n+  document->SetPage(params.page_number, std::move(metafile), params.page_size,\n                     params.content_area);\n \n   ShouldQuitFromInnerMessageLoop();""}<_**next**_>{""sha"": ""e9706e34f8c96f224196aa8ffc993b44a9247cf9"", ""filename"": ""chrome/browser/printing/print_view_manager_base.h"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 1, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -9,16 +9,23 @@\n \n #include \""base/macros.h\""\n #include \""base/memory/ref_counted.h\""\n+#include \""base/memory/weak_ptr.h\""\n #include \""base/strings/string16.h\""\n #include \""build/build_config.h\""\n #include \""components/prefs/pref_member.h\""\n #include \""components/printing/browser/print_manager.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/notification_observer.h\""\n #include \""content/public/browser/notification_registrar.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n #include \""printing/features/features.h\""\n \n struct PrintHostMsg_DidPrintPage_Params;\n \n+namespace base {\n+class SharedMemory;\n+}\n+\n namespace content {\n class RenderFrameHost;\n }\n@@ -82,9 +89,19 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   // IPC Message handlers.\n   void OnDidGetPrintedPagesCount(int cookie, int number_pages) override;\n-  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n   void OnPrintingFailed(int cookie) override;\n   void OnShowInvalidPrinterSettingsError();\n+  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n+\n+  // Handle extra tasks once a page or doc is printed.\n+  void UpdateForPrintedPage(const PrintHostMsg_DidPrintPage_Params& params,\n+                            bool has_valid_page_data,\n+                            std::unique_ptr<base::SharedMemory> shared_buf);\n+\n+  // IPC message handlers for service.\n+  void OnComposePdfDone(const PrintHostMsg_DidPrintPage_Params& params,\n+                        mojom::PdfCompositor::Status status,\n+                        mojo::ScopedSharedBufferHandle handle);\n \n   // Processes a NOTIFY_PRINT_JOB_EVENT notification.\n   void OnNotifyPrintJobEvent(const JobEventDetails& event_details);\n@@ -163,6 +180,8 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   scoped_refptr<printing::PrintQueriesQueue> queue_;\n \n+  base::WeakPtrFactory<PrintViewManagerBase> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintViewManagerBase);\n };\n ""}<_**next**_>{""sha"": ""3560d1c793977a5c2fe67253c9cf9509dbe596a1"", ""filename"": ""chrome/browser/printing/printing_init.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/printing_init.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""chrome/browser/printing/printing_init.h\""\n \n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""printing/features/features.h\""\n \n@@ -23,6 +24,7 @@ void InitializePrinting(content::WebContents* web_contents) {\n #else\n   printing::PrintViewManagerBasic::CreateForWebContents(web_contents);\n #endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)\n+  CreateCompositeClientIfNeeded(web_contents, false /* for_preview */);\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""84901e64744b737a1810f2e3c513498bfea57fb6"", ""filename"": ""chrome/browser/ui/BUILD.gn"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3475,7 +3475,10 @@ split_static_library(\""ui\"") {\n   }\n \n   if (enable_basic_printing || enable_print_preview) {\n-    deps += [ \""//printing\"" ]\n+    deps += [\n+      \""//components/printing/browser\"",\n+      \""//printing\"",\n+    ]\n     if (use_cups) {\n       configs += [ \""//printing:cups\"" ]\n     }""}<_**next**_>{""sha"": ""20c22c6758f1b3353627d510ee4cfe71ef980b8b"", ""filename"": ""chrome/utility/chrome_content_utility_client.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/utility/chrome_content_utility_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -73,7 +73,7 @@\n \n #if BUILDFLAG(ENABLE_PRINTING)\n #include \""chrome/common/chrome_content_client.h\""\n-#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""  // nogncheck\n #include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""  // nogncheck\n #endif\n ""}<_**next**_>{""sha"": ""154e773645fadb49d560d3b3aa8cb4e1f3511e43"", ""filename"": ""components/printing/browser/BUILD.gn"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,8 @@\n \n static_library(\""browser\"") {\n   sources = [\n+    \""print_composite_client.cc\"",\n+    \""print_composite_client.h\"",\n     \""print_manager.cc\"",\n     \""print_manager.h\"",\n     \""print_manager_utils.cc\"",\n@@ -17,6 +19,9 @@ static_library(\""browser\"") {\n   deps = [\n     \""//base\"",\n     \""//components/printing/common\"",\n+    \""//components/printing/service/public/cpp:client\"",\n+    \""//mojo/public/cpp/system:system\"",\n     \""//printing\"",\n+    \""//services/service_manager/public/cpp\"",\n   ]\n }""}<_**next**_>{""sha"": ""f67625c944f981351fc84c69ea9c9f156b285839"", ""filename"": ""components/printing/browser/DEPS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/DEPS?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -1,3 +1,6 @@\n include_rules = [\n+  \""+components/printing/service/public/cpp\"",\n   \""+content/public/browser\"",\n+  \""+mojo/public/cpp/system\"",\n+  \""+services/service_manager/public/cpp\"",\n ]""}<_**next**_>{""sha"": ""e105223f7f9335c2aec939ac0fe4b4a5dbdfa97b"", ""filename"": ""components/printing/browser/print_composite_client.cc"", ""status"": ""added"", ""additions"": 79, ""deletions"": 0, ""changes"": 79, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,79 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""components/printing/browser/print_composite_client.h\""\n+\n+#include <memory>\n+#include <utility>\n+\n+#include \""base/threading/thread_task_runner_handle.h\""\n+#include \""content/public/browser/browser_thread.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n+#include \""services/service_manager/public/cpp/connector.h\""\n+\n+DEFINE_WEB_CONTENTS_USER_DATA_KEY(printing::PrintCompositeClient);\n+\n+namespace printing {\n+\n+PrintCompositeClient::PrintCompositeClient(content::WebContents* web_contents)\n+    : for_preview_(false) {}\n+\n+PrintCompositeClient::~PrintCompositeClient() {}\n+\n+void PrintCompositeClient::CreateConnectorRequest() {\n+  connector_ = service_manager::Connector::Create(&connector_request_);\n+  content::ServiceManagerConnection::GetForProcess()\n+      ->GetConnector()\n+      ->BindConnectorRequest(std::move(connector_request_));\n+}\n+\n+void PrintCompositeClient::DoComposite(\n+    base::SharedMemoryHandle handle,\n+    uint32_t data_size,\n+    mojom::PdfCompositor::CompositePdfCallback callback) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  DCHECK(data_size);\n+\n+  if (!connector_)\n+    CreateConnectorRequest();\n+  Composite(connector_.get(), handle, data_size, std::move(callback),\n+            base::ThreadTaskRunnerHandle::Get());\n+}\n+\n+std::unique_ptr<base::SharedMemory> PrintCompositeClient::GetShmFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  base::SharedMemoryHandle memory_handle;\n+  size_t memory_size = 0;\n+  bool read_only_flag = false;\n+\n+  const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n+      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n+  if (result != MOJO_RESULT_OK)\n+    return nullptr;\n+  DCHECK_GT(memory_size, 0u);\n+\n+  std::unique_ptr<base::SharedMemory> shm =\n+      base::MakeUnique<base::SharedMemory>(memory_handle, true /* read_only */);\n+  if (!shm->Map(memory_size)) {\n+    DLOG(ERROR) << \""Map shared memory failed.\"";\n+    return nullptr;\n+  }\n+  return shm;\n+}\n+\n+scoped_refptr<base::RefCountedBytes>\n+PrintCompositeClient::GetDataFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  std::unique_ptr<base::SharedMemory> shm =\n+      GetShmFromMojoHandle(std::move(handle));\n+  if (!shm)\n+    return nullptr;\n+\n+  return base::MakeRefCounted<base::RefCountedBytes>(\n+      reinterpret_cast<const unsigned char*>(shm->memory()),\n+      shm->mapped_size());\n+}\n+\n+}  // namespace printing""}<_**next**_>{""sha"": ""d63b34123520f5d66dbafe7c878c84f77725a91c"", ""filename"": ""components/printing/browser/print_composite_client.h"", ""status"": ""added"", ""additions"": 49, ""deletions"": 0, ""changes"": 49, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,49 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+#define COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_client.h\""\n+#include \""content/public/browser/web_contents_observer.h\""\n+#include \""content/public/browser/web_contents_user_data.h\""\n+\n+namespace printing {\n+\n+class PrintCompositeClient\n+    : public PdfCompositorClient,\n+      public content::WebContentsUserData<PrintCompositeClient> {\n+ public:\n+  explicit PrintCompositeClient(content::WebContents* web_contents);\n+  ~PrintCompositeClient() override;\n+\n+  void DoComposite(base::SharedMemoryHandle handle,\n+                   uint32_t data_size,\n+                   mojom::PdfCompositor::CompositePdfCallback callback);\n+\n+  void set_for_preview(bool for_preview) { for_preview_ = for_preview; }\n+  bool for_preview() const { return for_preview_; }\n+\n+  // Utility functions.\n+  static std::unique_ptr<base::SharedMemory> GetShmFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+  static scoped_refptr<base::RefCountedBytes> GetDataFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+\n+ private:\n+  void CreateConnectorRequest();\n+\n+  service_manager::mojom::ConnectorRequest connector_request_;\n+  std::unique_ptr<service_manager::Connector> connector_;\n+  bool for_preview_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(PrintCompositeClient);\n+};\n+\n+}  // namespace printing\n+\n+#endif  // COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_""}<_**next**_>{""sha"": ""844fcf5bd23513e52fa2a2eb7d9d958762e11ddf"", ""filename"": ""components/printing/browser/print_manager_utils.cc"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 1, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3,11 +3,43 @@\n // found in the LICENSE file.\n \n #include \""components/printing/browser/print_manager_utils.h\""\n+\n+#include \""base/command_line.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n #include \""components/printing/common/print_messages.h\""\n+#include \""content/public/common/content_features.h\""\n+#include \""content/public/common/content_switches.h\""\n #include \""printing/print_settings.h\""\n \n namespace printing {\n \n+// A temporary flag which makes supporting both paths for OOPIF and non-OOPIF\n+// printing easier.\n+static bool g_oopif_enabled = false;\n+\n+void SetOopifEnabled() {\n+  g_oopif_enabled = true;\n+}\n+\n+bool IsOopifEnabled() {\n+  return g_oopif_enabled;\n+}\n+\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview) {\n+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n+          switches::kSitePerProcess) ||\n+      base::FeatureList::IsEnabled(features::kTopDocumentIsolation)) {\n+    // For cases need to support OOPIFs.\n+    PrintCompositeClient::CreateForWebContents(web_contents);\n+    if (for_preview) {\n+      PrintCompositeClient::FromWebContents(web_contents)\n+          ->set_for_preview(true);\n+    }\n+    SetOopifEnabled();\n+  }\n+}\n+\n void RenderParamsFromPrintSettings(const PrintSettings& settings,\n                                    PrintMsg_Print_Params* params) {\n   params->page_size = settings.page_setup_device_units().physical_size();\n@@ -32,7 +64,8 @@ void RenderParamsFromPrintSettings(const PrintSettings& settings,\n   params->display_header_footer = settings.display_header_footer();\n   params->title = settings.title();\n   params->url = settings.url();\n-  params->printed_doc_type = SkiaDocumentType::PDF;\n+  params->printed_doc_type =\n+      IsOopifEnabled() ? SkiaDocumentType::MSKP : SkiaDocumentType::PDF;\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""5b2b62a7dbf5599fbb51940906b2ed4697c5d0a2"", ""filename"": ""components/printing/browser/print_manager_utils.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,10 +7,22 @@\n \n struct PrintMsg_Print_Params;\n \n+namespace content {\n+class WebContents;\n+}\n+\n namespace printing {\n \n class PrintSettings;\n \n+void SetOopifEnabled(bool enabled);\n+bool IsOopifEnabled();\n+\n+// Check on the current feature settings to decide whether we need to\n+// create a PDF compositor client for this |web_contents|.\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview);\n+\n // Converts given settings to Print_Params and stores them in the output\n // parameter |params|.\n void RenderParamsFromPrintSettings(const PrintSettings& settings,""}<_**next**_>{""sha"": ""231fe97661ab55076dcd33cbc9dc12eeb29cbe83"", ""filename"": ""headless/lib/browser/headless_web_contents_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/headless/lib/browser/headless_web_contents_impl.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -322,6 +322,7 @@ HeadlessWebContentsImpl::HeadlessWebContentsImpl(\n       weak_ptr_factory_(this) {\n #if BUILDFLAG(ENABLE_BASIC_PRINTING) && !defined(CHROME_MULTIPLE_DLL_CHILD)\n   HeadlessPrintManager::CreateForWebContents(web_contents);\n+// TODO(weili): Add support for printing OOPIFs.\n #endif\n   web_contents->GetMutableRendererPrefs()->accept_languages =\n       browser_context->options()->accept_language();""}"," void RenderParamsFromPrintSettings(const PrintSettings& settings,
                                    PrintMsg_Print_Params* params) {
   params->page_size = settings.page_setup_device_units().physical_size();
  params->content_size.SetSize(
      settings.page_setup_device_units().content_area().width(),
      settings.page_setup_device_units().content_area().height());
  params->printable_area.SetRect(
      settings.page_setup_device_units().printable_area().x(),
      settings.page_setup_device_units().printable_area().y(),
      settings.page_setup_device_units().printable_area().width(),
      settings.page_setup_device_units().printable_area().height());
  params->margin_top = settings.page_setup_device_units().content_area().y();
  params->margin_left = settings.page_setup_device_units().content_area().x();
  params->dpi = settings.dpi();
  params->scale_factor = settings.scale_factor();
  params->rasterize_pdf = settings.rasterize_pdf();
  params->document_cookie = 0;
  params->selection_only = settings.selection_only();
  params->supports_alpha_blend = settings.supports_alpha_blend();
  params->should_print_backgrounds = settings.should_print_backgrounds();
   params->display_header_footer = settings.display_header_footer();
   params->title = settings.title();
   params->url = settings.url();
  params->printed_doc_type =
      IsOopifEnabled() ? SkiaDocumentType::MSKP : SkiaDocumentType::PDF;
 }
"," void RenderParamsFromPrintSettings(const PrintSettings& settings,
                                    PrintMsg_Print_Params* params) {
   params->page_size = settings.page_setup_device_units().physical_size();
  params->content_size.SetSize(
      settings.page_setup_device_units().content_area().width(),
      settings.page_setup_device_units().content_area().height());
  params->printable_area.SetRect(
      settings.page_setup_device_units().printable_area().x(),
      settings.page_setup_device_units().printable_area().y(),
      settings.page_setup_device_units().printable_area().width(),
      settings.page_setup_device_units().printable_area().height());
  params->margin_top = settings.page_setup_device_units().content_area().y();
  params->margin_left = settings.page_setup_device_units().content_area().x();
  params->dpi = settings.dpi();
  params->scale_factor = settings.scale_factor();
  params->rasterize_pdf = settings.rasterize_pdf();
  params->document_cookie = 0;
  params->selection_only = settings.selection_only();
  params->supports_alpha_blend = settings.supports_alpha_blend();
  params->should_print_backgrounds = settings.should_print_backgrounds();
   params->display_header_footer = settings.display_header_footer();
   params->title = settings.title();
   params->url = settings.url();
  params->printed_doc_type = SkiaDocumentType::PDF;
 }
",C,"  params->printed_doc_type =
      IsOopifEnabled() ? SkiaDocumentType::MSKP : SkiaDocumentType::PDF;
","  params->printed_doc_type = SkiaDocumentType::PDF;
",,"@@ -3,11 +3,43 @@
 // found in the LICENSE file.
 
 #include ""components/printing/browser/print_manager_utils.h""
+
+#include ""base/command_line.h""
+#include ""components/printing/browser/print_composite_client.h""
 #include ""components/printing/common/print_messages.h""
+#include ""content/public/common/content_features.h""
+#include ""content/public/common/content_switches.h""
 #include ""printing/print_settings.h""
 
 namespace printing {
 
+// A temporary flag which makes supporting both paths for OOPIF and non-OOPIF
+// printing easier.
+static bool g_oopif_enabled = false;
+
+void SetOopifEnabled() {
+  g_oopif_enabled = true;
+}
+
+bool IsOopifEnabled() {
+  return g_oopif_enabled;
+}
+
+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,
+                                   bool for_preview) {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kSitePerProcess) ||
+      base::FeatureList::IsEnabled(features::kTopDocumentIsolation)) {
+    // For cases need to support OOPIFs.
+    PrintCompositeClient::CreateForWebContents(web_contents);
+    if (for_preview) {
+      PrintCompositeClient::FromWebContents(web_contents)
+          ->set_for_preview(true);
+    }
+    SetOopifEnabled();
+  }
+}
+
 void RenderParamsFromPrintSettings(const PrintSettings& settings,
                                    PrintMsg_Print_Params* params) {
   params->page_size = settings.page_setup_device_units().physical_size();
@@ -32,7 +64,8 @@ void RenderParamsFromPrintSettings(const PrintSettings& settings,
   params->display_header_footer = settings.display_header_footer();
   params->title = settings.title();
   params->url = settings.url();
-  params->printed_doc_type = SkiaDocumentType::PDF;
+  params->printed_doc_type =
+      IsOopifEnabled() ? SkiaDocumentType::MSKP : SkiaDocumentType::PDF;
 }
 
 }  // namespace printing",Chrome,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,896aab1971cb86907e97ea09726b3872fbfde09a,1," void RenderParamsFromPrintSettings(const PrintSettings& settings,
                                    PrintMsg_Print_Params* params) {
   params->page_size = settings.page_setup_device_units().physical_size();
  params->content_size.SetSize(
      settings.page_setup_device_units().content_area().width(),
      settings.page_setup_device_units().content_area().height());
  params->printable_area.SetRect(
      settings.page_setup_device_units().printable_area().x(),
      settings.page_setup_device_units().printable_area().y(),
      settings.page_setup_device_units().printable_area().width(),
      settings.page_setup_device_units().printable_area().height());
  params->margin_top = settings.page_setup_device_units().content_area().y();
  params->margin_left = settings.page_setup_device_units().content_area().x();
  params->dpi = settings.dpi();
  params->scale_factor = settings.scale_factor();
  params->rasterize_pdf = settings.rasterize_pdf();
  // Always use an invalid cookie.
  params->document_cookie = 0;
  params->selection_only = settings.selection_only();
  params->supports_alpha_blend = settings.supports_alpha_blend();
  params->should_print_backgrounds = settings.should_print_backgrounds();
   params->display_header_footer = settings.display_header_footer();
   params->title = settings.title();
   params->url = settings.url();
//flaw_line_below:
  params->printed_doc_type = SkiaDocumentType::PDF;
//fix_flaw_line_below:
//  params->printed_doc_type =
//fix_flaw_line_below:
//      IsOopifEnabled() ? SkiaDocumentType::MSKP : SkiaDocumentType::PDF;
 }
"
8038,185774,,Remote,Not required,,CVE-2015-1300,https://www.cvedetails.com/cve/CVE-2015-1300/,CWE-254,Low,Partial,,,2015-09-03,5.0,"The FrameFetchContext::updateTimingInfoForIFrameNavigation function in core/loader/FrameFetchContext.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not properly restrict the availability of IFRAME Resource Timing API times, which allows remote attackers to obtain sensitive information via crafted JavaScript code that leverages a history.back call.",2016-12-21,+Info ,0,https://github.com/chromium/chromium/commit/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,"Use pdf compositor service for printing when OOPIF is enabled

When OOPIF is enabled (by site-per-process flag or
top-document-isolation feature), use the pdf compositor service for
converting PaintRecord to PDF on renderers.

In the future, this will make compositing PDF from multiple renderers
possible.

TBR=jzfeng@chromium.org
BUG=455764

Change-Id: I3c28f03f4358e4228239fe1a33384f85e7716e8f
Reviewed-on: https://chromium-review.googlesource.com/699765
Commit-Queue: Wei Li <weili@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Cr-Commit-Position: refs/heads/master@{#511616}",0,headless/lib/browser/headless_web_contents_impl.cc,"{""sha"": ""78193d61b9f59cdc78ed504e7a6939379d4f52d5"", ""filename"": ""chrome/browser/chrome_content_browser_manifest_overlay.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chrome_content_browser_manifest_overlay.json?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -44,6 +44,7 @@\n         \""local_state\"": [ \""pref_client\"" ],\n         \""nacl_broker\"": [ \""browser\"" ],\n         \""nacl_loader\"": [ \""browser\"" ],\n+        \""pdf_compositor\"": [ \""compositor\"" ],\n         \""profile_import\"": [ \""import\"" ],\n         \""profiling\"": [ \""profiling\"" ],\n         \""proxy_resolver\"": [ \""factory\"" ],""}<_**next**_>{""sha"": ""449ec7465b049d91941d3413bafcb8ee1904d417"", ""filename"": ""chrome/browser/printing/print_preview_dialog_controller.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_dialog_controller.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -29,6 +29,7 @@\n #include \""chrome/common/chrome_paths.h\""\n #include \""chrome/common/url_constants.h\""\n #include \""components/guest_view/browser/guest_view_base.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/web_modal/web_contents_modal_dialog_host.h\""\n #include \""content/public/browser/host_zoom_map.h\""\n #include \""content/public/browser/navigation_controller.h\""\n@@ -376,6 +377,7 @@ WebContents* PrintPreviewDialogController::CreatePrintPreviewDialog(\n   content::HostZoomMap::Get(preview_dialog->GetSiteInstance())\n       ->SetZoomLevelForHostAndScheme(print_url.scheme(), print_url.host(), 0);\n   PrintViewManager::CreateForWebContents(preview_dialog);\n+  CreateCompositeClientIfNeeded(preview_dialog, true /* for_preview */);\n   extensions::ChromeExtensionWebContentsObserver::CreateForWebContents(\n       preview_dialog);\n ""}<_**next**_>{""sha"": ""cda7ad2e7612be69842877448291d3be54317a64"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.cc"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 22, ""changes"": 116, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -14,18 +14,22 @@\n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/ref_counted_memory.h\""\n #include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n #include \""chrome/browser/browser_process.h\""\n #include \""chrome/browser/printing/print_job_manager.h\""\n #include \""chrome/browser/printing/print_preview_dialog_controller.h\""\n #include \""chrome/browser/printing/print_view_manager.h\""\n #include \""chrome/browser/printing/printer_query.h\""\n #include \""chrome/browser/ui/webui/print_preview/print_preview_ui.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""content/public/browser/web_ui.h\""\n #include \""printing/page_size_margins.h\""\n #include \""printing/print_job_constants.h\""\n+#include \""printing/print_settings.h\""\n \n using content::BrowserThread;\n using content::WebContents;\n@@ -69,7 +73,7 @@ scoped_refptr<base::RefCountedBytes> GetDataFromHandle(\n \n PrintPreviewMessageHandler::PrintPreviewMessageHandler(\n     WebContents* web_contents)\n-    : content::WebContentsObserver(web_contents) {\n+    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {\n   DCHECK(web_contents);\n }\n \n@@ -129,13 +133,21 @@ void PrintPreviewMessageHandler::OnDidPreviewPage(\n   if (!print_preview_ui)\n     return;\n \n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  DCHECK(data_bytes);\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    // Use utility process to convert skia metafile to pdf.\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,\n+                       weak_ptr_factory_.GetWeakPtr(), params.page_number,\n+                       params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewPageReady(\n+        page_number, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n@@ -152,18 +164,20 @@ void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n   if (!print_preview_ui)\n     return;\n \n-  // TODO(joth): This seems like a good match for using RefCountedStaticMemory\n-  // to avoid the memory copy, but the SetPrintPreviewData call chain below\n-  // needs updating to accept the RefCountedMemory* base class.\n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  if (!data_bytes || !data_bytes->size())\n-    return;\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnPreviewDataIsAvailable(\n-      params.expected_pages_count, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,\n+                       weak_ptr_factory_.GetWeakPtr(),\n+                       params.expected_pages_count, params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewDocumentReady(\n+        params.expected_pages_count, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnPrintPreviewFailed(int document_cookie) {\n@@ -214,6 +228,65 @@ void PrintPreviewMessageHandler::OnSetOptionsFromDocument(\n   print_preview_ui->OnSetOptionsFromDocument(params);\n }\n \n+void PrintPreviewMessageHandler::NotifyUIPreviewPageReady(\n+    int page_number,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  DCHECK(data_bytes);\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnDidPreviewPage(page_number, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::NotifyUIPreviewDocumentReady(\n+    int page_count,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  if (!data_bytes || !data_bytes->size())\n+    return;\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnPreviewDataIsAvailable(page_count, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfPageDone(\n+    int page_number,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewPageReady(\n+      page_number, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfDocumentDone(\n+    int page_count,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewDocumentReady(\n+      page_count, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n bool PrintPreviewMessageHandler::OnMessageReceived(\n     const IPC::Message& message,\n     content::RenderFrameHost* render_frame_host) {\n@@ -231,8 +304,7 @@ bool PrintPreviewMessageHandler::OnMessageReceived(\n   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,\n                         OnDidGetPreviewPageCount)\n-    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,\n-                        OnDidPreviewPage)\n+    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,\n                         OnMetafileReadyForPrinting)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,""}<_**next**_>{""sha"": ""71ca9d5bb1ee142ed3dbbfaa34cd8ab5d3018002"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.h"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,6 +7,9 @@\n \n #include \""base/compiler_specific.h\""\n #include \""base/macros.h\""\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/weak_ptr.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/web_contents_observer.h\""\n #include \""content/public/browser/web_contents_user_data.h\""\n \n@@ -70,6 +73,27 @@ class PrintPreviewMessageHandler\n   void OnSetOptionsFromDocument(\n       const PrintHostMsg_SetOptionsFromDocument_Params& params);\n \n+  void NotifyUIPreviewPageReady(\n+      int page_number,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+  void NotifyUIPreviewDocumentReady(\n+      int page_count,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+\n+  // Callbacks for pdf compositor client.\n+  void OnCompositePdfPageDone(int page_number,\n+                              int request_id,\n+                              mojom::PdfCompositor::Status status,\n+                              mojo::ScopedSharedBufferHandle handle);\n+  void OnCompositePdfDocumentDone(int page_count,\n+                                  int request_id,\n+                                  mojom::PdfCompositor::Status status,\n+                                  mojo::ScopedSharedBufferHandle handle);\n+\n+  base::WeakPtrFactory<PrintPreviewMessageHandler> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintPreviewMessageHandler);\n };\n ""}<_**next**_>{""sha"": ""f4fed9d2753dbd8b374dfb9b6f006cf51010d5cf"", ""filename"": ""chrome/browser/printing/print_view_manager_base.cc"", ""status"": ""modified"", ""additions"": 64, ""deletions"": 25, ""changes"": 89, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -11,6 +11,7 @@\n #include \""base/bind.h\""\n #include \""base/location.h\""\n #include \""base/memory/ptr_util.h\""\n+#include \""base/memory/shared_memory.h\""\n #include \""base/message_loop/message_loop.h\""\n #include \""base/run_loop.h\""\n #include \""base/single_thread_task_runner.h\""\n@@ -28,6 +29,8 @@\n #include \""chrome/common/pref_names.h\""\n #include \""chrome/grit/generated_resources.h\""\n #include \""components/prefs/pref_service.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/notification_details.h\""\n@@ -36,8 +39,10 @@\n #include \""content/public/browser/render_frame_host.h\""\n #include \""content/public/browser/render_view_host.h\""\n #include \""content/public/browser/web_contents.h\""\n+#include \""mojo/public/cpp/system/buffer.h\""\n #include \""printing/features/features.h\""\n #include \""printing/pdf_metafile_skia.h\""\n+#include \""printing/print_settings.h\""\n #include \""printing/printed_document.h\""\n #include \""ui/base/l10n/l10n_util.h\""\n \n@@ -78,7 +83,8 @@ PrintViewManagerBase::PrintViewManagerBase(content::WebContents* web_contents)\n #if !defined(OS_MACOSX)\n       expecting_first_page_(true),\n #endif\n-      queue_(g_browser_process->print_job_manager()->queue()) {\n+      queue_(g_browser_process->print_job_manager()->queue()),\n+      weak_ptr_factory_(this) {\n   DCHECK(queue_.get());\n   Profile* profile =\n       Profile::FromBrowserContext(web_contents->GetBrowserContext());\n@@ -127,8 +133,24 @@ void PrintViewManagerBase::OnDidGetPrintedPagesCount(int cookie,\n   OpportunisticallyCreatePrintJob(cookie);\n }\n \n+void PrintViewManagerBase::OnComposePdfDone(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+\n+  UpdateForPrintedPage(\n+      params, true,\n+      PrintCompositeClient::GetShmFromMojoHandle(std::move(handle)));\n+}\n+\n void PrintViewManagerBase::OnDidPrintPage(\n-  const PrintHostMsg_DidPrintPage_Params& params) {\n+    const PrintHostMsg_DidPrintPage_Params& params) {\n+  // Ready to composite. Starting a print job.\n   if (!OpportunisticallyCreatePrintJob(params.document_cookie))\n     return;\n \n@@ -154,8 +176,18 @@ void PrintViewManagerBase::OnDidPrintPage(\n       web_contents()->Stop();\n       return;\n     }\n+\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    if (IsOopifEnabled() && !client->for_preview() &&\n+        !document->settings().is_modifiable()) {\n+      client->DoComposite(\n+          params.metafile_data_handle, params.data_size,\n+          base::BindOnce(&PrintViewManagerBase::OnComposePdfDone,\n+                         weak_ptr_factory_.GetWeakPtr(), params));\n+      return;\n+    }\n     shared_buf =\n-        base::MakeUnique<base::SharedMemory>(params.metafile_data_handle, true);\n+        std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);\n     if (!shared_buf->Map(params.data_size)) {\n       NOTREACHED() << \""couldn't map\"";\n       web_contents()->Stop();\n@@ -170,22 +202,24 @@ void PrintViewManagerBase::OnDidPrintPage(\n     }\n   }\n \n-  std::unique_ptr<PdfMetafileSkia> metafile(\n-      new PdfMetafileSkia(SkiaDocumentType::PDF));\n-  if (metafile_must_be_valid) {\n-    if (!metafile->InitFromData(shared_buf->memory(), params.data_size)) {\n-      NOTREACHED() << \""Invalid metafile header\"";\n-      web_contents()->Stop();\n-      return;\n-    }\n-  }\n+  UpdateForPrintedPage(params, metafile_must_be_valid, std::move(shared_buf));\n+}\n+\n+void PrintViewManagerBase::UpdateForPrintedPage(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    bool has_valid_page_data,\n+    std::unique_ptr<base::SharedMemory> shared_buf) {\n+  PrintedDocument* document = print_job_->document();\n+  if (!document)\n+    return;\n \n #if defined(OS_WIN)\n   print_job_->AppendPrintedPage(params.page_number);\n-  if (metafile_must_be_valid) {\n-    scoped_refptr<base::RefCountedBytes> bytes = new base::RefCountedBytes(\n+  if (has_valid_page_data) {\n+    scoped_refptr<base::RefCountedBytes> bytes(new base::RefCountedBytes(\n         reinterpret_cast<const unsigned char*>(shared_buf->memory()),\n-        params.data_size);\n+        shared_buf->mapped_size()));\n+\n     document->DebugDumpData(bytes.get(), FILE_PATH_LITERAL(\"".pdf\""));\n \n     const auto& settings = document->settings();\n@@ -203,22 +237,27 @@ void PrintViewManagerBase::OnDidPrintPage(\n       // Update : The missing letters seem to have been caused by the same\n       // problem as https://crbug.com/659604 which was resolved. GDI printing\n       // seems to work with the fix for this bug applied.\n-      bool print_text_with_gdi = settings.print_text_with_gdi() &&\n-                                 !settings.printer_is_xps() &&\n-                                 base::FeatureList::IsEnabled(\n-                                     features::kGdiTextPrinting);\n+      bool print_text_with_gdi =\n+          settings.print_text_with_gdi() && !settings.printer_is_xps() &&\n+          base::FeatureList::IsEnabled(features::kGdiTextPrinting);\n       print_job_->StartPdfToEmfConversion(\n           bytes, params.page_size, params.content_area, print_text_with_gdi);\n     }\n   }\n #else\n+  std::unique_ptr<PdfMetafileSkia> metafile =\n+      std::make_unique<PdfMetafileSkia>(SkiaDocumentType::PDF);\n+  if (has_valid_page_data) {\n+    if (!metafile->InitFromData(shared_buf->memory(),\n+                                shared_buf->mapped_size())) {\n+      NOTREACHED() << \""Invalid metafile header\"";\n+      web_contents()->Stop();\n+      return;\n+    }\n+  }\n+\n   // Update the rendered document. It will send notifications to the listener.\n-  document->SetPage(params.page_number,\n-                    std::move(metafile),\n-#if defined(OS_WIN)\n-                    0.0f /* dummy shrink_factor */,\n-#endif\n-                    params.page_size,\n+  document->SetPage(params.page_number, std::move(metafile), params.page_size,\n                     params.content_area);\n \n   ShouldQuitFromInnerMessageLoop();""}<_**next**_>{""sha"": ""e9706e34f8c96f224196aa8ffc993b44a9247cf9"", ""filename"": ""chrome/browser/printing/print_view_manager_base.h"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 1, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -9,16 +9,23 @@\n \n #include \""base/macros.h\""\n #include \""base/memory/ref_counted.h\""\n+#include \""base/memory/weak_ptr.h\""\n #include \""base/strings/string16.h\""\n #include \""build/build_config.h\""\n #include \""components/prefs/pref_member.h\""\n #include \""components/printing/browser/print_manager.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/notification_observer.h\""\n #include \""content/public/browser/notification_registrar.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n #include \""printing/features/features.h\""\n \n struct PrintHostMsg_DidPrintPage_Params;\n \n+namespace base {\n+class SharedMemory;\n+}\n+\n namespace content {\n class RenderFrameHost;\n }\n@@ -82,9 +89,19 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   // IPC Message handlers.\n   void OnDidGetPrintedPagesCount(int cookie, int number_pages) override;\n-  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n   void OnPrintingFailed(int cookie) override;\n   void OnShowInvalidPrinterSettingsError();\n+  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n+\n+  // Handle extra tasks once a page or doc is printed.\n+  void UpdateForPrintedPage(const PrintHostMsg_DidPrintPage_Params& params,\n+                            bool has_valid_page_data,\n+                            std::unique_ptr<base::SharedMemory> shared_buf);\n+\n+  // IPC message handlers for service.\n+  void OnComposePdfDone(const PrintHostMsg_DidPrintPage_Params& params,\n+                        mojom::PdfCompositor::Status status,\n+                        mojo::ScopedSharedBufferHandle handle);\n \n   // Processes a NOTIFY_PRINT_JOB_EVENT notification.\n   void OnNotifyPrintJobEvent(const JobEventDetails& event_details);\n@@ -163,6 +180,8 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   scoped_refptr<printing::PrintQueriesQueue> queue_;\n \n+  base::WeakPtrFactory<PrintViewManagerBase> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintViewManagerBase);\n };\n ""}<_**next**_>{""sha"": ""3560d1c793977a5c2fe67253c9cf9509dbe596a1"", ""filename"": ""chrome/browser/printing/printing_init.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/printing_init.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""chrome/browser/printing/printing_init.h\""\n \n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""printing/features/features.h\""\n \n@@ -23,6 +24,7 @@ void InitializePrinting(content::WebContents* web_contents) {\n #else\n   printing::PrintViewManagerBasic::CreateForWebContents(web_contents);\n #endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)\n+  CreateCompositeClientIfNeeded(web_contents, false /* for_preview */);\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""84901e64744b737a1810f2e3c513498bfea57fb6"", ""filename"": ""chrome/browser/ui/BUILD.gn"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3475,7 +3475,10 @@ split_static_library(\""ui\"") {\n   }\n \n   if (enable_basic_printing || enable_print_preview) {\n-    deps += [ \""//printing\"" ]\n+    deps += [\n+      \""//components/printing/browser\"",\n+      \""//printing\"",\n+    ]\n     if (use_cups) {\n       configs += [ \""//printing:cups\"" ]\n     }""}<_**next**_>{""sha"": ""20c22c6758f1b3353627d510ee4cfe71ef980b8b"", ""filename"": ""chrome/utility/chrome_content_utility_client.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/utility/chrome_content_utility_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -73,7 +73,7 @@\n \n #if BUILDFLAG(ENABLE_PRINTING)\n #include \""chrome/common/chrome_content_client.h\""\n-#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""  // nogncheck\n #include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""  // nogncheck\n #endif\n ""}<_**next**_>{""sha"": ""154e773645fadb49d560d3b3aa8cb4e1f3511e43"", ""filename"": ""components/printing/browser/BUILD.gn"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,8 @@\n \n static_library(\""browser\"") {\n   sources = [\n+    \""print_composite_client.cc\"",\n+    \""print_composite_client.h\"",\n     \""print_manager.cc\"",\n     \""print_manager.h\"",\n     \""print_manager_utils.cc\"",\n@@ -17,6 +19,9 @@ static_library(\""browser\"") {\n   deps = [\n     \""//base\"",\n     \""//components/printing/common\"",\n+    \""//components/printing/service/public/cpp:client\"",\n+    \""//mojo/public/cpp/system:system\"",\n     \""//printing\"",\n+    \""//services/service_manager/public/cpp\"",\n   ]\n }""}<_**next**_>{""sha"": ""f67625c944f981351fc84c69ea9c9f156b285839"", ""filename"": ""components/printing/browser/DEPS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/DEPS?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -1,3 +1,6 @@\n include_rules = [\n+  \""+components/printing/service/public/cpp\"",\n   \""+content/public/browser\"",\n+  \""+mojo/public/cpp/system\"",\n+  \""+services/service_manager/public/cpp\"",\n ]""}<_**next**_>{""sha"": ""e105223f7f9335c2aec939ac0fe4b4a5dbdfa97b"", ""filename"": ""components/printing/browser/print_composite_client.cc"", ""status"": ""added"", ""additions"": 79, ""deletions"": 0, ""changes"": 79, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,79 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""components/printing/browser/print_composite_client.h\""\n+\n+#include <memory>\n+#include <utility>\n+\n+#include \""base/threading/thread_task_runner_handle.h\""\n+#include \""content/public/browser/browser_thread.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n+#include \""services/service_manager/public/cpp/connector.h\""\n+\n+DEFINE_WEB_CONTENTS_USER_DATA_KEY(printing::PrintCompositeClient);\n+\n+namespace printing {\n+\n+PrintCompositeClient::PrintCompositeClient(content::WebContents* web_contents)\n+    : for_preview_(false) {}\n+\n+PrintCompositeClient::~PrintCompositeClient() {}\n+\n+void PrintCompositeClient::CreateConnectorRequest() {\n+  connector_ = service_manager::Connector::Create(&connector_request_);\n+  content::ServiceManagerConnection::GetForProcess()\n+      ->GetConnector()\n+      ->BindConnectorRequest(std::move(connector_request_));\n+}\n+\n+void PrintCompositeClient::DoComposite(\n+    base::SharedMemoryHandle handle,\n+    uint32_t data_size,\n+    mojom::PdfCompositor::CompositePdfCallback callback) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  DCHECK(data_size);\n+\n+  if (!connector_)\n+    CreateConnectorRequest();\n+  Composite(connector_.get(), handle, data_size, std::move(callback),\n+            base::ThreadTaskRunnerHandle::Get());\n+}\n+\n+std::unique_ptr<base::SharedMemory> PrintCompositeClient::GetShmFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  base::SharedMemoryHandle memory_handle;\n+  size_t memory_size = 0;\n+  bool read_only_flag = false;\n+\n+  const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n+      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n+  if (result != MOJO_RESULT_OK)\n+    return nullptr;\n+  DCHECK_GT(memory_size, 0u);\n+\n+  std::unique_ptr<base::SharedMemory> shm =\n+      base::MakeUnique<base::SharedMemory>(memory_handle, true /* read_only */);\n+  if (!shm->Map(memory_size)) {\n+    DLOG(ERROR) << \""Map shared memory failed.\"";\n+    return nullptr;\n+  }\n+  return shm;\n+}\n+\n+scoped_refptr<base::RefCountedBytes>\n+PrintCompositeClient::GetDataFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  std::unique_ptr<base::SharedMemory> shm =\n+      GetShmFromMojoHandle(std::move(handle));\n+  if (!shm)\n+    return nullptr;\n+\n+  return base::MakeRefCounted<base::RefCountedBytes>(\n+      reinterpret_cast<const unsigned char*>(shm->memory()),\n+      shm->mapped_size());\n+}\n+\n+}  // namespace printing""}<_**next**_>{""sha"": ""d63b34123520f5d66dbafe7c878c84f77725a91c"", ""filename"": ""components/printing/browser/print_composite_client.h"", ""status"": ""added"", ""additions"": 49, ""deletions"": 0, ""changes"": 49, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,49 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+#define COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_client.h\""\n+#include \""content/public/browser/web_contents_observer.h\""\n+#include \""content/public/browser/web_contents_user_data.h\""\n+\n+namespace printing {\n+\n+class PrintCompositeClient\n+    : public PdfCompositorClient,\n+      public content::WebContentsUserData<PrintCompositeClient> {\n+ public:\n+  explicit PrintCompositeClient(content::WebContents* web_contents);\n+  ~PrintCompositeClient() override;\n+\n+  void DoComposite(base::SharedMemoryHandle handle,\n+                   uint32_t data_size,\n+                   mojom::PdfCompositor::CompositePdfCallback callback);\n+\n+  void set_for_preview(bool for_preview) { for_preview_ = for_preview; }\n+  bool for_preview() const { return for_preview_; }\n+\n+  // Utility functions.\n+  static std::unique_ptr<base::SharedMemory> GetShmFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+  static scoped_refptr<base::RefCountedBytes> GetDataFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+\n+ private:\n+  void CreateConnectorRequest();\n+\n+  service_manager::mojom::ConnectorRequest connector_request_;\n+  std::unique_ptr<service_manager::Connector> connector_;\n+  bool for_preview_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(PrintCompositeClient);\n+};\n+\n+}  // namespace printing\n+\n+#endif  // COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_""}<_**next**_>{""sha"": ""844fcf5bd23513e52fa2a2eb7d9d958762e11ddf"", ""filename"": ""components/printing/browser/print_manager_utils.cc"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 1, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3,11 +3,43 @@\n // found in the LICENSE file.\n \n #include \""components/printing/browser/print_manager_utils.h\""\n+\n+#include \""base/command_line.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n #include \""components/printing/common/print_messages.h\""\n+#include \""content/public/common/content_features.h\""\n+#include \""content/public/common/content_switches.h\""\n #include \""printing/print_settings.h\""\n \n namespace printing {\n \n+// A temporary flag which makes supporting both paths for OOPIF and non-OOPIF\n+// printing easier.\n+static bool g_oopif_enabled = false;\n+\n+void SetOopifEnabled() {\n+  g_oopif_enabled = true;\n+}\n+\n+bool IsOopifEnabled() {\n+  return g_oopif_enabled;\n+}\n+\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview) {\n+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n+          switches::kSitePerProcess) ||\n+      base::FeatureList::IsEnabled(features::kTopDocumentIsolation)) {\n+    // For cases need to support OOPIFs.\n+    PrintCompositeClient::CreateForWebContents(web_contents);\n+    if (for_preview) {\n+      PrintCompositeClient::FromWebContents(web_contents)\n+          ->set_for_preview(true);\n+    }\n+    SetOopifEnabled();\n+  }\n+}\n+\n void RenderParamsFromPrintSettings(const PrintSettings& settings,\n                                    PrintMsg_Print_Params* params) {\n   params->page_size = settings.page_setup_device_units().physical_size();\n@@ -32,7 +64,8 @@ void RenderParamsFromPrintSettings(const PrintSettings& settings,\n   params->display_header_footer = settings.display_header_footer();\n   params->title = settings.title();\n   params->url = settings.url();\n-  params->printed_doc_type = SkiaDocumentType::PDF;\n+  params->printed_doc_type =\n+      IsOopifEnabled() ? SkiaDocumentType::MSKP : SkiaDocumentType::PDF;\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""5b2b62a7dbf5599fbb51940906b2ed4697c5d0a2"", ""filename"": ""components/printing/browser/print_manager_utils.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,10 +7,22 @@\n \n struct PrintMsg_Print_Params;\n \n+namespace content {\n+class WebContents;\n+}\n+\n namespace printing {\n \n class PrintSettings;\n \n+void SetOopifEnabled(bool enabled);\n+bool IsOopifEnabled();\n+\n+// Check on the current feature settings to decide whether we need to\n+// create a PDF compositor client for this |web_contents|.\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview);\n+\n // Converts given settings to Print_Params and stores them in the output\n // parameter |params|.\n void RenderParamsFromPrintSettings(const PrintSettings& settings,""}<_**next**_>{""sha"": ""231fe97661ab55076dcd33cbc9dc12eeb29cbe83"", ""filename"": ""headless/lib/browser/headless_web_contents_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/headless/lib/browser/headless_web_contents_impl.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -322,6 +322,7 @@ HeadlessWebContentsImpl::HeadlessWebContentsImpl(\n       weak_ptr_factory_(this) {\n #if BUILDFLAG(ENABLE_BASIC_PRINTING) && !defined(CHROME_MULTIPLE_DLL_CHILD)\n   HeadlessPrintManager::CreateForWebContents(web_contents);\n+// TODO(weili): Add support for printing OOPIFs.\n #endif\n   web_contents->GetMutableRendererPrefs()->accept_languages =\n       browser_context->options()->accept_language();""}","HeadlessWebContentsImpl::HeadlessWebContentsImpl(
    content::WebContents* web_contents,
    HeadlessBrowserContextImpl* browser_context)
    : content::WebContentsObserver(web_contents),
      web_contents_delegate_(new HeadlessWebContentsImpl::Delegate(this)),
      web_contents_(web_contents),
      agent_host_(content::DevToolsAgentHost::GetOrCreateFor(web_contents)),
      inject_mojo_services_into_isolated_world_(false),
      browser_context_(browser_context),
      render_process_host_(web_contents->GetMainFrame()->GetProcess()),
       weak_ptr_factory_(this) {
 #if BUILDFLAG(ENABLE_BASIC_PRINTING) && !defined(CHROME_MULTIPLE_DLL_CHILD)
   HeadlessPrintManager::CreateForWebContents(web_contents);
//// TODO(weili): Add support for printing OOPIFs.
 #endif
   web_contents->GetMutableRendererPrefs()->accept_languages =
       browser_context->options()->accept_language();
  web_contents_->SetDelegate(web_contents_delegate_.get());
  render_process_host_->AddObserver(this);
  agent_host_->AddObserver(this);
}
","HeadlessWebContentsImpl::HeadlessWebContentsImpl(
    content::WebContents* web_contents,
    HeadlessBrowserContextImpl* browser_context)
    : content::WebContentsObserver(web_contents),
      web_contents_delegate_(new HeadlessWebContentsImpl::Delegate(this)),
      web_contents_(web_contents),
      agent_host_(content::DevToolsAgentHost::GetOrCreateFor(web_contents)),
      inject_mojo_services_into_isolated_world_(false),
      browser_context_(browser_context),
      render_process_host_(web_contents->GetMainFrame()->GetProcess()),
       weak_ptr_factory_(this) {
 #if BUILDFLAG(ENABLE_BASIC_PRINTING) && !defined(CHROME_MULTIPLE_DLL_CHILD)
   HeadlessPrintManager::CreateForWebContents(web_contents);
//// TODO(weili): Add support for printing OOPIFs.
 #endif
   web_contents->GetMutableRendererPrefs()->accept_languages =
       browser_context->options()->accept_language();
  web_contents_->SetDelegate(web_contents_delegate_.get());
  render_process_host_->AddObserver(this);
  agent_host_->AddObserver(this);
}
",C,,,,"@@ -322,6 +322,7 @@ HeadlessWebContentsImpl::HeadlessWebContentsImpl(
       weak_ptr_factory_(this) {
 #if BUILDFLAG(ENABLE_BASIC_PRINTING) && !defined(CHROME_MULTIPLE_DLL_CHILD)
   HeadlessPrintManager::CreateForWebContents(web_contents);
+// TODO(weili): Add support for printing OOPIFs.
 #endif
   web_contents->GetMutableRendererPrefs()->accept_languages =
       browser_context->options()->accept_language();",Chrome,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,896aab1971cb86907e97ea09726b3872fbfde09a,1,"HeadlessWebContentsImpl::HeadlessWebContentsImpl(
    content::WebContents* web_contents,
    HeadlessBrowserContextImpl* browser_context)
    : content::WebContentsObserver(web_contents),
      web_contents_delegate_(new HeadlessWebContentsImpl::Delegate(this)),
      web_contents_(web_contents),
      agent_host_(content::DevToolsAgentHost::GetOrCreateFor(web_contents)),
      inject_mojo_services_into_isolated_world_(false),
      browser_context_(browser_context),
      render_process_host_(web_contents->GetMainFrame()->GetProcess()),
       weak_ptr_factory_(this) {
 #if BUILDFLAG(ENABLE_BASIC_PRINTING) && !defined(CHROME_MULTIPLE_DLL_CHILD)
   HeadlessPrintManager::CreateForWebContents(web_contents);
//fix_flaw_line_below:
//// TODO(weili): Add support for printing OOPIFs.
 #endif
   web_contents->GetMutableRendererPrefs()->accept_languages =
       browser_context->options()->accept_language();
  web_contents_->SetDelegate(web_contents_delegate_.get());
  render_process_host_->AddObserver(this);
  agent_host_->AddObserver(this);
}
"
8043,185779,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}"," bool AXARIAGridCell::isAriaColumnHeader() const {
   const AtomicString& role = getAttribute(HTMLNames::roleAttr);
  return equalIgnoringASCIICase(role, ""columnheader"");
 }
"," bool AXARIAGridCell::isAriaColumnHeader() const {
   const AtomicString& role = getAttribute(HTMLNames::roleAttr);
  return equalIgnoringCase(role, ""columnheader"");
 }
",C,"  return equalIgnoringASCIICase(role, ""columnheader"");
","  return equalIgnoringCase(role, ""columnheader"");
",,"@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,
 
 bool AXARIAGridCell::isAriaColumnHeader() const {
   const AtomicString& role = getAttribute(HTMLNames::roleAttr);
-  return equalIgnoringCase(role, ""columnheader"");
+  return equalIgnoringASCIICase(role, ""columnheader"");
 }
 
 bool AXARIAGridCell::isAriaRowHeader() const {
   const AtomicString& role = getAttribute(HTMLNames::roleAttr);
-  return equalIgnoringCase(role, ""rowheader"");
+  return equalIgnoringASCIICase(role, ""rowheader"");
 }
 
 AXObject* AXARIAGridCell::parentTable() const {",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1," bool AXARIAGridCell::isAriaColumnHeader() const {
   const AtomicString& role = getAttribute(HTMLNames::roleAttr);
//flaw_line_below:
  return equalIgnoringCase(role, ""columnheader"");
//fix_flaw_line_below:
//  return equalIgnoringASCIICase(role, ""columnheader"");
 }
"
8044,185780,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}"," bool AXARIAGridCell::isAriaRowHeader() const {
   const AtomicString& role = getAttribute(HTMLNames::roleAttr);
  return equalIgnoringASCIICase(role, ""rowheader"");
 }
"," bool AXARIAGridCell::isAriaRowHeader() const {
   const AtomicString& role = getAttribute(HTMLNames::roleAttr);
  return equalIgnoringCase(role, ""rowheader"");
 }
",C,"  return equalIgnoringASCIICase(role, ""rowheader"");
","  return equalIgnoringCase(role, ""rowheader"");
",,"@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,
 
 bool AXARIAGridCell::isAriaColumnHeader() const {
   const AtomicString& role = getAttribute(HTMLNames::roleAttr);
-  return equalIgnoringCase(role, ""columnheader"");
+  return equalIgnoringASCIICase(role, ""columnheader"");
 }
 
 bool AXARIAGridCell::isAriaRowHeader() const {
   const AtomicString& role = getAttribute(HTMLNames::roleAttr);
-  return equalIgnoringCase(role, ""rowheader"");
+  return equalIgnoringASCIICase(role, ""rowheader"");
 }
 
 AXObject* AXARIAGridCell::parentTable() const {",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1," bool AXARIAGridCell::isAriaRowHeader() const {
   const AtomicString& role = getAttribute(HTMLNames::roleAttr);
//flaw_line_below:
  return equalIgnoringCase(role, ""rowheader"");
//fix_flaw_line_below:
//  return equalIgnoringASCIICase(role, ""rowheader"");
 }
"
8045,185781,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","AXObjectInclusion AXLayoutObject::defaultObjectInclusion(
    IgnoredReasons* ignoredReasons) const {

  if (!m_layoutObject) {
    if (ignoredReasons)
      ignoredReasons->push_back(IgnoredReason(AXNotRendered));
    return IgnoreObject;
  }

   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {
    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
       return DefaultBehavior;
 
     if (ignoredReasons)
      ignoredReasons->push_back(IgnoredReason(AXNotVisible));
    return IgnoreObject;
  }

  return AXObject::defaultObjectInclusion(ignoredReasons);
}
","AXObjectInclusion AXLayoutObject::defaultObjectInclusion(
    IgnoredReasons* ignoredReasons) const {

  if (!m_layoutObject) {
    if (ignoredReasons)
      ignoredReasons->push_back(IgnoredReason(AXNotRendered));
    return IgnoreObject;
  }

   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {
    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
       return DefaultBehavior;
 
     if (ignoredReasons)
      ignoredReasons->push_back(IgnoredReason(AXNotVisible));
    return IgnoreObject;
  }

  return AXObject::defaultObjectInclusion(ignoredReasons);
}
",C,"    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
","    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
",,"@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {
     return false;
 
   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);
-  if (equalIgnoringCase(ariaSelected, ""true""))
+  if (equalIgnoringASCIICase(ariaSelected, ""true""))
     return true;
 
   AXObject* focusedObject = axObjectCache().focusedObject();
@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(
   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {
     // aria-hidden is meant to override visibility as the determinant in AX
     // hierarchy inclusion.
-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
       return DefaultBehavior;
 
     if (ignoredReasons)
@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {
 
 bool AXLayoutObject::supportsARIADragging() const {
   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);
-  return equalIgnoringCase(grabbed, ""true"") ||
-         equalIgnoringCase(grabbed, ""false"");
+  return equalIgnoringASCIICase(grabbed, ""true"") ||
+         equalIgnoringASCIICase(grabbed, ""false"");
 }
 
 bool AXLayoutObject::supportsARIADropping() const {
@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(
   if (!m_layoutObject)
     return false;
 
-  return equalIgnoringCase(getAttribute(attributeName), ""true"");
+  return equalIgnoringASCIICase(getAttribute(attributeName), ""true"");
 }
 
 }  // namespace blink",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"AXObjectInclusion AXLayoutObject::defaultObjectInclusion(
    IgnoredReasons* ignoredReasons) const {
  // The following cases can apply to any element that's a subclass of
  // AXLayoutObject.

  if (!m_layoutObject) {
    if (ignoredReasons)
      ignoredReasons->push_back(IgnoredReason(AXNotRendered));
    return IgnoreObject;
  }

   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {
     // aria-hidden is meant to override visibility as the determinant in AX
     // hierarchy inclusion.
//flaw_line_below:
    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
//fix_flaw_line_below:
//    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
       return DefaultBehavior;
 
     if (ignoredReasons)
      ignoredReasons->push_back(IgnoredReason(AXNotVisible));
    return IgnoreObject;
  }

  return AXObject::defaultObjectInclusion(ignoredReasons);
}
"
8046,185782,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","bool AXLayoutObject::elementAttributeValue(
    const QualifiedName& attributeName) const {
   if (!m_layoutObject)
     return false;
 
  return equalIgnoringASCIICase(getAttribute(attributeName), ""true"");
 }
","bool AXLayoutObject::elementAttributeValue(
    const QualifiedName& attributeName) const {
   if (!m_layoutObject)
     return false;
 
  return equalIgnoringCase(getAttribute(attributeName), ""true"");
 }
",C,"  return equalIgnoringASCIICase(getAttribute(attributeName), ""true"");
","  return equalIgnoringCase(getAttribute(attributeName), ""true"");
",,"@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {
     return false;
 
   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);
-  if (equalIgnoringCase(ariaSelected, ""true""))
+  if (equalIgnoringASCIICase(ariaSelected, ""true""))
     return true;
 
   AXObject* focusedObject = axObjectCache().focusedObject();
@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(
   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {
     // aria-hidden is meant to override visibility as the determinant in AX
     // hierarchy inclusion.
-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
       return DefaultBehavior;
 
     if (ignoredReasons)
@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {
 
 bool AXLayoutObject::supportsARIADragging() const {
   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);
-  return equalIgnoringCase(grabbed, ""true"") ||
-         equalIgnoringCase(grabbed, ""false"");
+  return equalIgnoringASCIICase(grabbed, ""true"") ||
+         equalIgnoringASCIICase(grabbed, ""false"");
 }
 
 bool AXLayoutObject::supportsARIADropping() const {
@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(
   if (!m_layoutObject)
     return false;
 
-  return equalIgnoringCase(getAttribute(attributeName), ""true"");
+  return equalIgnoringASCIICase(getAttribute(attributeName), ""true"");
 }
 
 }  // namespace blink",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"bool AXLayoutObject::elementAttributeValue(
    const QualifiedName& attributeName) const {
   if (!m_layoutObject)
     return false;
 
//flaw_line_below:
  return equalIgnoringCase(getAttribute(attributeName), ""true"");
//fix_flaw_line_below:
//  return equalIgnoringASCIICase(getAttribute(attributeName), ""true"");
 }
"
8047,185783,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","bool AXLayoutObject::isSelected() const {
  if (!getLayoutObject() || !getNode())
     return false;
 
   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);
  if (equalIgnoringASCIICase(ariaSelected, ""true""))
     return true;
 
   AXObject* focusedObject = axObjectCache().focusedObject();
  if (ariaRoleAttribute() == ListBoxOptionRole && focusedObject &&
      focusedObject->activeDescendant() == this) {
    return true;
  }

  if (isTabItem() && isTabItemSelected())
    return true;

  return false;
}
","bool AXLayoutObject::isSelected() const {
  if (!getLayoutObject() || !getNode())
     return false;
 
   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);
  if (equalIgnoringCase(ariaSelected, ""true""))
     return true;
 
   AXObject* focusedObject = axObjectCache().focusedObject();
  if (ariaRoleAttribute() == ListBoxOptionRole && focusedObject &&
      focusedObject->activeDescendant() == this) {
    return true;
  }

  if (isTabItem() && isTabItemSelected())
    return true;

  return false;
}
",C,"  if (equalIgnoringASCIICase(ariaSelected, ""true""))
","  if (equalIgnoringCase(ariaSelected, ""true""))
",,"@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {
     return false;
 
   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);
-  if (equalIgnoringCase(ariaSelected, ""true""))
+  if (equalIgnoringASCIICase(ariaSelected, ""true""))
     return true;
 
   AXObject* focusedObject = axObjectCache().focusedObject();
@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(
   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {
     // aria-hidden is meant to override visibility as the determinant in AX
     // hierarchy inclusion.
-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
       return DefaultBehavior;
 
     if (ignoredReasons)
@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {
 
 bool AXLayoutObject::supportsARIADragging() const {
   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);
-  return equalIgnoringCase(grabbed, ""true"") ||
-         equalIgnoringCase(grabbed, ""false"");
+  return equalIgnoringASCIICase(grabbed, ""true"") ||
+         equalIgnoringASCIICase(grabbed, ""false"");
 }
 
 bool AXLayoutObject::supportsARIADropping() const {
@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(
   if (!m_layoutObject)
     return false;
 
-  return equalIgnoringCase(getAttribute(attributeName), ""true"");
+  return equalIgnoringASCIICase(getAttribute(attributeName), ""true"");
 }
 
 }  // namespace blink",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"bool AXLayoutObject::isSelected() const {
  if (!getLayoutObject() || !getNode())
     return false;
 
   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);
//flaw_line_below:
  if (equalIgnoringCase(ariaSelected, ""true""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(ariaSelected, ""true""))
     return true;
 
   AXObject* focusedObject = axObjectCache().focusedObject();
  if (ariaRoleAttribute() == ListBoxOptionRole && focusedObject &&
      focusedObject->activeDescendant() == this) {
    return true;
  }

  if (isTabItem() && isTabItemSelected())
    return true;

  return false;
}
"
8048,185784,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,2,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",2,third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}"," bool AXLayoutObject::supportsARIADragging() const {
   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);
  return equalIgnoringASCIICase(grabbed, ""true"") ||
         equalIgnoringASCIICase(grabbed, ""false"");
 }
"," bool AXLayoutObject::supportsARIADragging() const {
   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);
  return equalIgnoringCase(grabbed, ""true"") ||
         equalIgnoringCase(grabbed, ""false"");
 }
",C,"  return equalIgnoringASCIICase(grabbed, ""true"") ||
         equalIgnoringASCIICase(grabbed, ""false"");
","  return equalIgnoringCase(grabbed, ""true"") ||
         equalIgnoringCase(grabbed, ""false"");
",,"@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {
     return false;
 
   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);
-  if (equalIgnoringCase(ariaSelected, ""true""))
+  if (equalIgnoringASCIICase(ariaSelected, ""true""))
     return true;
 
   AXObject* focusedObject = axObjectCache().focusedObject();
@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(
   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {
     // aria-hidden is meant to override visibility as the determinant in AX
     // hierarchy inclusion.
-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
       return DefaultBehavior;
 
     if (ignoredReasons)
@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {
 
 bool AXLayoutObject::supportsARIADragging() const {
   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);
-  return equalIgnoringCase(grabbed, ""true"") ||
-         equalIgnoringCase(grabbed, ""false"");
+  return equalIgnoringASCIICase(grabbed, ""true"") ||
+         equalIgnoringASCIICase(grabbed, ""false"");
 }
 
 bool AXLayoutObject::supportsARIADropping() const {
@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(
   if (!m_layoutObject)
     return false;
 
-  return equalIgnoringCase(getAttribute(attributeName), ""true"");
+  return equalIgnoringASCIICase(getAttribute(attributeName), ""true"");
 }
 
 }  // namespace blink",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1," bool AXLayoutObject::supportsARIADragging() const {
   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);
//flaw_line_below:
  return equalIgnoringCase(grabbed, ""true"") ||
//flaw_line_below:
         equalIgnoringCase(grabbed, ""false"");
//fix_flaw_line_below:
//  return equalIgnoringASCIICase(grabbed, ""true"") ||
//fix_flaw_line_below:
//         equalIgnoringASCIICase(grabbed, ""false"");
 }
"
8049,185785,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","bool AXListBoxOption::isEnabled() const {
   if (!getNode())
     return false;
 
  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), ""true""))
     return false;
 
   if (toElement(getNode())->hasAttribute(disabledAttr))
    return false;

  return true;
}
","bool AXListBoxOption::isEnabled() const {
   if (!getNode())
     return false;
 
  if (equalIgnoringCase(getAttribute(aria_disabledAttr), ""true""))
     return false;
 
   if (toElement(getNode())->hasAttribute(disabledAttr))
    return false;

  return true;
}
",C,"  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), ""true""))
","  if (equalIgnoringCase(getAttribute(aria_disabledAttr), ""true""))
",,"@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {
   if (!getNode())
     return false;
 
-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), ""true""))
     return false;
 
   if (toElement(getNode())->hasAttribute(disabledAttr))",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"bool AXListBoxOption::isEnabled() const {
   if (!getNode())
     return false;
 
//flaw_line_below:
  if (equalIgnoringCase(getAttribute(aria_disabledAttr), ""true""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), ""true""))
     return false;
 
   if (toElement(getNode())->hasAttribute(disabledAttr))
    return false;

  return true;
}
"
8050,185786,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,8,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",7,third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","AriaCurrentState AXNodeObject::ariaCurrentState() const {
  const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
  if (attributeValue.isEmpty() ||
      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   if (!attributeValue.isEmpty())
    return AriaCurrentStateTrue;

  return AXObject::ariaCurrentState();
}
","AriaCurrentState AXNodeObject::ariaCurrentState() const {
  const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
  if (equalIgnoringCase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
  if (equalIgnoringCase(attributeValue, ""page""))
     return AriaCurrentStatePage;
  if (equalIgnoringCase(attributeValue, ""step""))
     return AriaCurrentStateStep;
  if (equalIgnoringCase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
  if (equalIgnoringCase(attributeValue, ""date""))
     return AriaCurrentStateDate;
  if (equalIgnoringCase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   if (!attributeValue.isEmpty())
    return AriaCurrentStateTrue;

  return AXObject::ariaCurrentState();
}
",C,"  if (attributeValue.isEmpty() ||
      equalIgnoringASCIICase(attributeValue, ""false""))
  if (equalIgnoringASCIICase(attributeValue, ""true""))
  if (equalIgnoringASCIICase(attributeValue, ""page""))
  if (equalIgnoringASCIICase(attributeValue, ""step""))
  if (equalIgnoringASCIICase(attributeValue, ""location""))
  if (equalIgnoringASCIICase(attributeValue, ""date""))
  if (equalIgnoringASCIICase(attributeValue, ""time""))
","  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
  if (equalIgnoringCase(attributeValue, ""true""))
  if (equalIgnoringCase(attributeValue, ""page""))
  if (equalIgnoringCase(attributeValue, ""step""))
  if (equalIgnoringCase(attributeValue, ""location""))
  if (equalIgnoringCase(attributeValue, ""date""))
  if (equalIgnoringCase(attributeValue, ""time""))
",,"@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {
            AXSparseAttributeClient& attributeMap,
            const AtomicString& value) override {
     attributeMap.addBoolAttribute(m_attribute,
-                                  equalIgnoringCase(value, ""true""));
+                                  equalIgnoringASCIICase(value, ""true""));
   }
 };
 
@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(
   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {
     return false;
   // Both ""true"" (case-insensitive) and the empty string count as true.
   return contentEditableValue.isEmpty() ||
-         equalIgnoringCase(contentEditableValue, ""true"");
+         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
 
 bool AXNodeObject::isTextControl() const {
@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
-    if (equalIgnoringCase(siblingAriaRole, role))
+    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {
 bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
-  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
-  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
-      if (equalIgnoringCase(
+      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
-  if (equalIgnoringCase(expanded, ""true""))
+  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
-  if (equalIgnoringCase(expanded, ""false""))
+  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
-    if (equalIgnoringCase(modal, ""true""))
+    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
-    if (equalIgnoringCase(modal, ""false""))
+    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {
   // ARIA button with aria-pressed not undefined, then check for aria-pressed
   // attribute rather than getNode()->active()
   if (ariaRoleAttribute() == ToggleButtonRole) {
-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
-        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }
@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {
 }
 
 bool AXNodeObject::canSetValueAttribute() const {
-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
-  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
+  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
-  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
+  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
-  if (!equalIgnoringCase(type, ""color""))
+  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
   // HTMLInputElement::value always returns a string parseable by Color.
@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
+  if (attributeValue.isEmpty() ||
+      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
-  if (equalIgnoringCase(attributeValue, ""page""))
+  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
-  if (equalIgnoringCase(attributeValue, ""step""))
+  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
-  if (equalIgnoringCase(attributeValue, ""location""))
+  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
-  if (equalIgnoringCase(attributeValue, ""date""))
+  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
-  if (equalIgnoringCase(attributeValue, ""time""))
+  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   // An unknown value should return true.
   if (!attributeValue.isEmpty())
@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
 InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
-  if (equalIgnoringCase(attributeValue, ""false""))
+  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
-  if (equalIgnoringCase(attributeValue, ""spelling""))
+  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
-  if (equalIgnoringCase(attributeValue, ""grammar""))
+  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   // A yet unknown value.
   if (!attributeValue.isEmpty())
@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,
     // true if any ancestor is hidden, but we need to be able to compute the
     // accessible name of object inside hidden subtrees (for example, if
     // aria-labelledby points to an object that's hidden).
-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
     // If we're going between two layoutObjects that are in separate",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"AriaCurrentState AXNodeObject::ariaCurrentState() const {
  const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
//flaw_line_below:
  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
//fix_flaw_line_below:
//  if (attributeValue.isEmpty() ||
//fix_flaw_line_below:
//      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
//flaw_line_below:
  if (equalIgnoringCase(attributeValue, ""true""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
//flaw_line_below:
  if (equalIgnoringCase(attributeValue, ""page""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
//flaw_line_below:
  if (equalIgnoringCase(attributeValue, ""step""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
//flaw_line_below:
  if (equalIgnoringCase(attributeValue, ""location""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
//flaw_line_below:
  if (equalIgnoringCase(attributeValue, ""date""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
//flaw_line_below:
  if (equalIgnoringCase(attributeValue, ""time""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   // An unknown value should return true.
   if (!attributeValue.isEmpty())
    return AriaCurrentStateTrue;

  return AXObject::ariaCurrentState();
}
"
8051,185787,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}"," bool AXNodeObject::canSetValueAttribute() const {
  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
    return true;

  if (isTextControl() && !isNativeTextControl())
    return true;

  return !isReadOnly();
}
"," bool AXNodeObject::canSetValueAttribute() const {
  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
    return true;

  if (isTextControl() && !isNativeTextControl())
    return true;

  return !isReadOnly();
}
",C,"  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
","  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
",,"@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {
            AXSparseAttributeClient& attributeMap,
            const AtomicString& value) override {
     attributeMap.addBoolAttribute(m_attribute,
-                                  equalIgnoringCase(value, ""true""));
+                                  equalIgnoringASCIICase(value, ""true""));
   }
 };
 
@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(
   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {
     return false;
   // Both ""true"" (case-insensitive) and the empty string count as true.
   return contentEditableValue.isEmpty() ||
-         equalIgnoringCase(contentEditableValue, ""true"");
+         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
 
 bool AXNodeObject::isTextControl() const {
@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
-    if (equalIgnoringCase(siblingAriaRole, role))
+    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {
 bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
-  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
-  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
-      if (equalIgnoringCase(
+      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
-  if (equalIgnoringCase(expanded, ""true""))
+  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
-  if (equalIgnoringCase(expanded, ""false""))
+  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
-    if (equalIgnoringCase(modal, ""true""))
+    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
-    if (equalIgnoringCase(modal, ""false""))
+    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {
   // ARIA button with aria-pressed not undefined, then check for aria-pressed
   // attribute rather than getNode()->active()
   if (ariaRoleAttribute() == ToggleButtonRole) {
-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
-        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }
@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {
 }
 
 bool AXNodeObject::canSetValueAttribute() const {
-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
-  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
+  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
-  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
+  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
-  if (!equalIgnoringCase(type, ""color""))
+  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
   // HTMLInputElement::value always returns a string parseable by Color.
@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
+  if (attributeValue.isEmpty() ||
+      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
-  if (equalIgnoringCase(attributeValue, ""page""))
+  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
-  if (equalIgnoringCase(attributeValue, ""step""))
+  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
-  if (equalIgnoringCase(attributeValue, ""location""))
+  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
-  if (equalIgnoringCase(attributeValue, ""date""))
+  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
-  if (equalIgnoringCase(attributeValue, ""time""))
+  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   // An unknown value should return true.
   if (!attributeValue.isEmpty())
@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
 InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
-  if (equalIgnoringCase(attributeValue, ""false""))
+  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
-  if (equalIgnoringCase(attributeValue, ""spelling""))
+  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
-  if (equalIgnoringCase(attributeValue, ""grammar""))
+  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   // A yet unknown value.
   if (!attributeValue.isEmpty())
@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,
     // true if any ancestor is hidden, but we need to be able to compute the
     // accessible name of object inside hidden subtrees (for example, if
     // aria-labelledby points to an object that's hidden).
-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
     // If we're going between two layoutObjects that are in separate",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1," bool AXNodeObject::canSetValueAttribute() const {
//flaw_line_below:
  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
    return true;

  if (isTextControl() && !isNativeTextControl())
    return true;

  // Any node could be contenteditable, so isReadOnly should be relied upon
  // for this information for all elements.
  return !isReadOnly();
}
"
8052,185788,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","RGBA32 AXNodeObject::colorValue() const {
  if (!isHTMLInputElement(getNode()) || !isColorWell())
    return AXObject::colorValue();
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
  Color color;
  bool success = color.setFromString(input->value());
  DCHECK(success);
  return color.rgb();
}
","RGBA32 AXNodeObject::colorValue() const {
  if (!isHTMLInputElement(getNode()) || !isColorWell())
    return AXObject::colorValue();
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
  if (!equalIgnoringCase(type, ""color""))
     return AXObject::colorValue();
 
  Color color;
  bool success = color.setFromString(input->value());
  DCHECK(success);
  return color.rgb();
}
",C,"  if (!equalIgnoringASCIICase(type, ""color""))
","  if (!equalIgnoringCase(type, ""color""))
",,"@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {
            AXSparseAttributeClient& attributeMap,
            const AtomicString& value) override {
     attributeMap.addBoolAttribute(m_attribute,
-                                  equalIgnoringCase(value, ""true""));
+                                  equalIgnoringASCIICase(value, ""true""));
   }
 };
 
@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(
   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {
     return false;
   // Both ""true"" (case-insensitive) and the empty string count as true.
   return contentEditableValue.isEmpty() ||
-         equalIgnoringCase(contentEditableValue, ""true"");
+         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
 
 bool AXNodeObject::isTextControl() const {
@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
-    if (equalIgnoringCase(siblingAriaRole, role))
+    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {
 bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
-  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
-  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
-      if (equalIgnoringCase(
+      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
-  if (equalIgnoringCase(expanded, ""true""))
+  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
-  if (equalIgnoringCase(expanded, ""false""))
+  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
-    if (equalIgnoringCase(modal, ""true""))
+    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
-    if (equalIgnoringCase(modal, ""false""))
+    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {
   // ARIA button with aria-pressed not undefined, then check for aria-pressed
   // attribute rather than getNode()->active()
   if (ariaRoleAttribute() == ToggleButtonRole) {
-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
-        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }
@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {
 }
 
 bool AXNodeObject::canSetValueAttribute() const {
-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
-  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
+  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
-  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
+  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
-  if (!equalIgnoringCase(type, ""color""))
+  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
   // HTMLInputElement::value always returns a string parseable by Color.
@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
+  if (attributeValue.isEmpty() ||
+      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
-  if (equalIgnoringCase(attributeValue, ""page""))
+  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
-  if (equalIgnoringCase(attributeValue, ""step""))
+  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
-  if (equalIgnoringCase(attributeValue, ""location""))
+  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
-  if (equalIgnoringCase(attributeValue, ""date""))
+  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
-  if (equalIgnoringCase(attributeValue, ""time""))
+  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   // An unknown value should return true.
   if (!attributeValue.isEmpty())
@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
 InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
-  if (equalIgnoringCase(attributeValue, ""false""))
+  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
-  if (equalIgnoringCase(attributeValue, ""spelling""))
+  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
-  if (equalIgnoringCase(attributeValue, ""grammar""))
+  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   // A yet unknown value.
   if (!attributeValue.isEmpty())
@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,
     // true if any ancestor is hidden, but we need to be able to compute the
     // accessible name of object inside hidden subtrees (for example, if
     // aria-labelledby points to an object that's hidden).
-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
     // If we're going between two layoutObjects that are in separate",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"RGBA32 AXNodeObject::colorValue() const {
  if (!isHTMLInputElement(getNode()) || !isColorWell())
    return AXObject::colorValue();
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
//flaw_line_below:
  if (!equalIgnoringCase(type, ""color""))
//fix_flaw_line_below:
//  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
   // HTMLInputElement::value always returns a string parseable by Color.
  Color color;
  bool success = color.setFromString(input->value());
  DCHECK(success);
  return color.rgb();
}
"
8053,185789,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","bool AXNodeObject::computeAccessibilityIsIgnored(
    IgnoredReasons* ignoredReasons) const {
#if DCHECK_IS_ON()
  ASSERT(m_initialized);
#endif

  if (isDescendantOfLeafNode()) {
    if (ignoredReasons)
      ignoredReasons->push_back(
          IgnoredReason(AXAncestorIsLeafNode, leafNodeAncestor()));
    return true;
  }

  AXObject* controlObject = correspondingControlForLabelElement();
  if (controlObject && controlObject->isCheckboxOrRadio() &&
      controlObject->nameFromLabelElement()) {
    if (ignoredReasons) {
      HTMLLabelElement* label = labelElementContainer();
      if (label && label != getNode()) {
        AXObject* labelAXObject = axObjectCache().getOrCreate(label);
        ignoredReasons->push_back(
            IgnoredReason(AXLabelContainer, labelAXObject));
      }

      ignoredReasons->push_back(IgnoredReason(AXLabelFor, controlObject));
    }
    return true;
  }

   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
  }

  if (m_role == UnknownRole) {
    if (ignoredReasons)
      ignoredReasons->push_back(IgnoredReason(AXUninteresting));
    return true;
  }
  return false;
}
","bool AXNodeObject::computeAccessibilityIsIgnored(
    IgnoredReasons* ignoredReasons) const {
#if DCHECK_IS_ON()
  ASSERT(m_initialized);
#endif

  if (isDescendantOfLeafNode()) {
    if (ignoredReasons)
      ignoredReasons->push_back(
          IgnoredReason(AXAncestorIsLeafNode, leafNodeAncestor()));
    return true;
  }

  AXObject* controlObject = correspondingControlForLabelElement();
  if (controlObject && controlObject->isCheckboxOrRadio() &&
      controlObject->nameFromLabelElement()) {
    if (ignoredReasons) {
      HTMLLabelElement* label = labelElementContainer();
      if (label && label != getNode()) {
        AXObject* labelAXObject = axObjectCache().getOrCreate(label);
        ignoredReasons->push_back(
            IgnoredReason(AXLabelContainer, labelAXObject));
      }

      ignoredReasons->push_back(IgnoredReason(AXLabelFor, controlObject));
    }
    return true;
  }

   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
  }

  if (m_role == UnknownRole) {
    if (ignoredReasons)
      ignoredReasons->push_back(IgnoredReason(AXUninteresting));
    return true;
  }
  return false;
}
",C,"      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
","      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
",,"@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {
            AXSparseAttributeClient& attributeMap,
            const AtomicString& value) override {
     attributeMap.addBoolAttribute(m_attribute,
-                                  equalIgnoringCase(value, ""true""));
+                                  equalIgnoringASCIICase(value, ""true""));
   }
 };
 
@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(
   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {
     return false;
   // Both ""true"" (case-insensitive) and the empty string count as true.
   return contentEditableValue.isEmpty() ||
-         equalIgnoringCase(contentEditableValue, ""true"");
+         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
 
 bool AXNodeObject::isTextControl() const {
@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
-    if (equalIgnoringCase(siblingAriaRole, role))
+    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {
 bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
-  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
-  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
-      if (equalIgnoringCase(
+      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
-  if (equalIgnoringCase(expanded, ""true""))
+  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
-  if (equalIgnoringCase(expanded, ""false""))
+  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
-    if (equalIgnoringCase(modal, ""true""))
+    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
-    if (equalIgnoringCase(modal, ""false""))
+    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {
   // ARIA button with aria-pressed not undefined, then check for aria-pressed
   // attribute rather than getNode()->active()
   if (ariaRoleAttribute() == ToggleButtonRole) {
-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
-        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }
@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {
 }
 
 bool AXNodeObject::canSetValueAttribute() const {
-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
-  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
+  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
-  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
+  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
-  if (!equalIgnoringCase(type, ""color""))
+  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
   // HTMLInputElement::value always returns a string parseable by Color.
@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
+  if (attributeValue.isEmpty() ||
+      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
-  if (equalIgnoringCase(attributeValue, ""page""))
+  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
-  if (equalIgnoringCase(attributeValue, ""step""))
+  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
-  if (equalIgnoringCase(attributeValue, ""location""))
+  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
-  if (equalIgnoringCase(attributeValue, ""date""))
+  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
-  if (equalIgnoringCase(attributeValue, ""time""))
+  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   // An unknown value should return true.
   if (!attributeValue.isEmpty())
@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
 InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
-  if (equalIgnoringCase(attributeValue, ""false""))
+  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
-  if (equalIgnoringCase(attributeValue, ""spelling""))
+  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
-  if (equalIgnoringCase(attributeValue, ""grammar""))
+  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   // A yet unknown value.
   if (!attributeValue.isEmpty())
@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,
     // true if any ancestor is hidden, but we need to be able to compute the
     // accessible name of object inside hidden subtrees (for example, if
     // aria-labelledby points to an object that's hidden).
-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
     // If we're going between two layoutObjects that are in separate",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"bool AXNodeObject::computeAccessibilityIsIgnored(
    IgnoredReasons* ignoredReasons) const {
#if DCHECK_IS_ON()
  // Double-check that an AXObject is never accessed before
  // it's been initialized.
  ASSERT(m_initialized);
#endif

  // If this element is within a parent that cannot have children, it should not
  // be exposed.
  if (isDescendantOfLeafNode()) {
    if (ignoredReasons)
      ignoredReasons->push_back(
          IgnoredReason(AXAncestorIsLeafNode, leafNodeAncestor()));
    return true;
  }

  // Ignore labels that are already referenced by a control.
  AXObject* controlObject = correspondingControlForLabelElement();
  if (controlObject && controlObject->isCheckboxOrRadio() &&
      controlObject->nameFromLabelElement()) {
    if (ignoredReasons) {
      HTMLLabelElement* label = labelElementContainer();
      if (label && label != getNode()) {
        AXObject* labelAXObject = axObjectCache().getOrCreate(label);
        ignoredReasons->push_back(
            IgnoredReason(AXLabelContainer, labelAXObject));
      }

      ignoredReasons->push_back(IgnoredReason(AXLabelFor, controlObject));
    }
    return true;
  }

   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
//flaw_line_below:
      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
//fix_flaw_line_below:
//      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
  }

  if (m_role == UnknownRole) {
    if (ignoredReasons)
      ignoredReasons->push_back(IgnoredReason(AXUninteresting));
    return true;
  }
  return false;
}
"
8054,185790,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,4,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",4,third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}"," InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   if (!attributeValue.isEmpty())
    return InvalidStateOther;

  if (getNode() && getNode()->isElementNode() &&
      toElement(getNode())->isFormControlElement()) {
    HTMLFormControlElement* element = toHTMLFormControlElement(getNode());
    HeapVector<Member<HTMLFormControlElement>> invalidControls;
    bool isInvalid =
        !element->checkValidity(&invalidControls, CheckValidityDispatchNoEvent);
    return isInvalid ? InvalidStateTrue : InvalidStateFalse;
  }

  return AXObject::getInvalidState();
}
"," InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
  if (equalIgnoringCase(attributeValue, ""false""))
     return InvalidStateFalse;
  if (equalIgnoringCase(attributeValue, ""true""))
     return InvalidStateTrue;
  if (equalIgnoringCase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
  if (equalIgnoringCase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   if (!attributeValue.isEmpty())
    return InvalidStateOther;

  if (getNode() && getNode()->isElementNode() &&
      toElement(getNode())->isFormControlElement()) {
    HTMLFormControlElement* element = toHTMLFormControlElement(getNode());
    HeapVector<Member<HTMLFormControlElement>> invalidControls;
    bool isInvalid =
        !element->checkValidity(&invalidControls, CheckValidityDispatchNoEvent);
    return isInvalid ? InvalidStateTrue : InvalidStateFalse;
  }

  return AXObject::getInvalidState();
}
",C,"  if (equalIgnoringASCIICase(attributeValue, ""false""))
  if (equalIgnoringASCIICase(attributeValue, ""true""))
  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
","  if (equalIgnoringCase(attributeValue, ""false""))
  if (equalIgnoringCase(attributeValue, ""true""))
  if (equalIgnoringCase(attributeValue, ""spelling""))
  if (equalIgnoringCase(attributeValue, ""grammar""))
",,"@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {
            AXSparseAttributeClient& attributeMap,
            const AtomicString& value) override {
     attributeMap.addBoolAttribute(m_attribute,
-                                  equalIgnoringCase(value, ""true""));
+                                  equalIgnoringASCIICase(value, ""true""));
   }
 };
 
@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(
   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {
     return false;
   // Both ""true"" (case-insensitive) and the empty string count as true.
   return contentEditableValue.isEmpty() ||
-         equalIgnoringCase(contentEditableValue, ""true"");
+         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
 
 bool AXNodeObject::isTextControl() const {
@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
-    if (equalIgnoringCase(siblingAriaRole, role))
+    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {
 bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
-  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
-  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
-      if (equalIgnoringCase(
+      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
-  if (equalIgnoringCase(expanded, ""true""))
+  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
-  if (equalIgnoringCase(expanded, ""false""))
+  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
-    if (equalIgnoringCase(modal, ""true""))
+    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
-    if (equalIgnoringCase(modal, ""false""))
+    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {
   // ARIA button with aria-pressed not undefined, then check for aria-pressed
   // attribute rather than getNode()->active()
   if (ariaRoleAttribute() == ToggleButtonRole) {
-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
-        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }
@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {
 }
 
 bool AXNodeObject::canSetValueAttribute() const {
-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
-  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
+  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
-  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
+  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
-  if (!equalIgnoringCase(type, ""color""))
+  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
   // HTMLInputElement::value always returns a string parseable by Color.
@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
+  if (attributeValue.isEmpty() ||
+      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
-  if (equalIgnoringCase(attributeValue, ""page""))
+  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
-  if (equalIgnoringCase(attributeValue, ""step""))
+  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
-  if (equalIgnoringCase(attributeValue, ""location""))
+  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
-  if (equalIgnoringCase(attributeValue, ""date""))
+  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
-  if (equalIgnoringCase(attributeValue, ""time""))
+  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   // An unknown value should return true.
   if (!attributeValue.isEmpty())
@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
 InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
-  if (equalIgnoringCase(attributeValue, ""false""))
+  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
-  if (equalIgnoringCase(attributeValue, ""spelling""))
+  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
-  if (equalIgnoringCase(attributeValue, ""grammar""))
+  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   // A yet unknown value.
   if (!attributeValue.isEmpty())
@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,
     // true if any ancestor is hidden, but we need to be able to compute the
     // accessible name of object inside hidden subtrees (for example, if
     // aria-labelledby points to an object that's hidden).
-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
     // If we're going between two layoutObjects that are in separate",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1," InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
//flaw_line_below:
  if (equalIgnoringCase(attributeValue, ""false""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
//flaw_line_below:
  if (equalIgnoringCase(attributeValue, ""true""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
//flaw_line_below:
  if (equalIgnoringCase(attributeValue, ""spelling""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
//flaw_line_below:
  if (equalIgnoringCase(attributeValue, ""grammar""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   // A yet unknown value.
   if (!attributeValue.isEmpty())
    return InvalidStateOther;

  if (getNode() && getNode()->isElementNode() &&
      toElement(getNode())->isFormControlElement()) {
    HTMLFormControlElement* element = toHTMLFormControlElement(getNode());
    HeapVector<Member<HTMLFormControlElement>> invalidControls;
    bool isInvalid =
        !element->checkValidity(&invalidControls, CheckValidityDispatchNoEvent);
    return isInvalid ? InvalidStateTrue : InvalidStateFalse;
  }

  return AXObject::getInvalidState();
}
"
8055,185791,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","bool AXNodeObject::hasContentEditableAttributeSet() const {
  const AtomicString& contentEditableValue = getAttribute(contenteditableAttr);
  if (contentEditableValue.isNull())
     return false;
   return contentEditableValue.isEmpty() ||
         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
","bool AXNodeObject::hasContentEditableAttributeSet() const {
  const AtomicString& contentEditableValue = getAttribute(contenteditableAttr);
  if (contentEditableValue.isNull())
     return false;
   return contentEditableValue.isEmpty() ||
         equalIgnoringCase(contentEditableValue, ""true"");
 }
",C,"         equalIgnoringASCIICase(contentEditableValue, ""true"");
","         equalIgnoringCase(contentEditableValue, ""true"");
",,"@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {
            AXSparseAttributeClient& attributeMap,
            const AtomicString& value) override {
     attributeMap.addBoolAttribute(m_attribute,
-                                  equalIgnoringCase(value, ""true""));
+                                  equalIgnoringASCIICase(value, ""true""));
   }
 };
 
@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(
   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {
     return false;
   // Both ""true"" (case-insensitive) and the empty string count as true.
   return contentEditableValue.isEmpty() ||
-         equalIgnoringCase(contentEditableValue, ""true"");
+         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
 
 bool AXNodeObject::isTextControl() const {
@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
-    if (equalIgnoringCase(siblingAriaRole, role))
+    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {
 bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
-  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
-  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
-      if (equalIgnoringCase(
+      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
-  if (equalIgnoringCase(expanded, ""true""))
+  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
-  if (equalIgnoringCase(expanded, ""false""))
+  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
-    if (equalIgnoringCase(modal, ""true""))
+    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
-    if (equalIgnoringCase(modal, ""false""))
+    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {
   // ARIA button with aria-pressed not undefined, then check for aria-pressed
   // attribute rather than getNode()->active()
   if (ariaRoleAttribute() == ToggleButtonRole) {
-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
-        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }
@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {
 }
 
 bool AXNodeObject::canSetValueAttribute() const {
-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
-  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
+  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
-  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
+  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
-  if (!equalIgnoringCase(type, ""color""))
+  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
   // HTMLInputElement::value always returns a string parseable by Color.
@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
+  if (attributeValue.isEmpty() ||
+      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
-  if (equalIgnoringCase(attributeValue, ""page""))
+  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
-  if (equalIgnoringCase(attributeValue, ""step""))
+  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
-  if (equalIgnoringCase(attributeValue, ""location""))
+  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
-  if (equalIgnoringCase(attributeValue, ""date""))
+  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
-  if (equalIgnoringCase(attributeValue, ""time""))
+  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   // An unknown value should return true.
   if (!attributeValue.isEmpty())
@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
 InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
-  if (equalIgnoringCase(attributeValue, ""false""))
+  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
-  if (equalIgnoringCase(attributeValue, ""spelling""))
+  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
-  if (equalIgnoringCase(attributeValue, ""grammar""))
+  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   // A yet unknown value.
   if (!attributeValue.isEmpty())
@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,
     // true if any ancestor is hidden, but we need to be able to compute the
     // accessible name of object inside hidden subtrees (for example, if
     // aria-labelledby points to an object that's hidden).
-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
     // If we're going between two layoutObjects that are in separate",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"bool AXNodeObject::hasContentEditableAttributeSet() const {
  const AtomicString& contentEditableValue = getAttribute(contenteditableAttr);
  if (contentEditableValue.isNull())
     return false;
   // Both ""true"" (case-insensitive) and the empty string count as true.
   return contentEditableValue.isEmpty() ||
//flaw_line_below:
         equalIgnoringCase(contentEditableValue, ""true"");
//fix_flaw_line_below:
//         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
"
8056,185792,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","bool AXNodeObject::isChecked() const {
  Node* node = this->getNode();
  if (!node)
    return false;

  if (isHTMLInputElement(*node))
    return toHTMLInputElement(*node).shouldAppearChecked();

  switch (ariaRoleAttribute()) {
    case CheckBoxRole:
    case MenuItemCheckBoxRole:
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
      return false;
    default:
      break;
  }

  return false;
}
","bool AXNodeObject::isChecked() const {
  Node* node = this->getNode();
  if (!node)
    return false;

  if (isHTMLInputElement(*node))
    return toHTMLInputElement(*node).shouldAppearChecked();

  switch (ariaRoleAttribute()) {
    case CheckBoxRole:
    case MenuItemCheckBoxRole:
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
      if (equalIgnoringCase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
      return false;
    default:
      break;
  }

  return false;
}
",C,"      if (equalIgnoringASCIICase(
","      if (equalIgnoringCase(
",,"@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {
            AXSparseAttributeClient& attributeMap,
            const AtomicString& value) override {
     attributeMap.addBoolAttribute(m_attribute,
-                                  equalIgnoringCase(value, ""true""));
+                                  equalIgnoringASCIICase(value, ""true""));
   }
 };
 
@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(
   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {
     return false;
   // Both ""true"" (case-insensitive) and the empty string count as true.
   return contentEditableValue.isEmpty() ||
-         equalIgnoringCase(contentEditableValue, ""true"");
+         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
 
 bool AXNodeObject::isTextControl() const {
@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
-    if (equalIgnoringCase(siblingAriaRole, role))
+    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {
 bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
-  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
-  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
-      if (equalIgnoringCase(
+      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
-  if (equalIgnoringCase(expanded, ""true""))
+  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
-  if (equalIgnoringCase(expanded, ""false""))
+  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
-    if (equalIgnoringCase(modal, ""true""))
+    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
-    if (equalIgnoringCase(modal, ""false""))
+    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {
   // ARIA button with aria-pressed not undefined, then check for aria-pressed
   // attribute rather than getNode()->active()
   if (ariaRoleAttribute() == ToggleButtonRole) {
-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
-        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }
@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {
 }
 
 bool AXNodeObject::canSetValueAttribute() const {
-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
-  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
+  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
-  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
+  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
-  if (!equalIgnoringCase(type, ""color""))
+  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
   // HTMLInputElement::value always returns a string parseable by Color.
@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
+  if (attributeValue.isEmpty() ||
+      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
-  if (equalIgnoringCase(attributeValue, ""page""))
+  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
-  if (equalIgnoringCase(attributeValue, ""step""))
+  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
-  if (equalIgnoringCase(attributeValue, ""location""))
+  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
-  if (equalIgnoringCase(attributeValue, ""date""))
+  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
-  if (equalIgnoringCase(attributeValue, ""time""))
+  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   // An unknown value should return true.
   if (!attributeValue.isEmpty())
@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
 InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
-  if (equalIgnoringCase(attributeValue, ""false""))
+  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
-  if (equalIgnoringCase(attributeValue, ""spelling""))
+  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
-  if (equalIgnoringCase(attributeValue, ""grammar""))
+  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   // A yet unknown value.
   if (!attributeValue.isEmpty())
@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,
     // true if any ancestor is hidden, but we need to be able to compute the
     // accessible name of object inside hidden subtrees (for example, if
     // aria-labelledby points to an object that's hidden).
-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
     // If we're going between two layoutObjects that are in separate",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"bool AXNodeObject::isChecked() const {
  Node* node = this->getNode();
  if (!node)
    return false;

  // First test for native checkedness semantics
  if (isHTMLInputElement(*node))
    return toHTMLInputElement(*node).shouldAppearChecked();

  // Else, if this is an ARIA role checkbox or radio or menuitemcheckbox
  // or menuitemradio or switch, respect the aria-checked attribute
  switch (ariaRoleAttribute()) {
    case CheckBoxRole:
    case MenuItemCheckBoxRole:
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
//flaw_line_below:
      if (equalIgnoringCase(
//fix_flaw_line_below:
//      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
      return false;
    default:
      break;
  }

  // Otherwise it's not checked
  return false;
}
"
8057,185793,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,2,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",2,third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","AccessibilityExpanded AXNodeObject::isExpanded() const {
  if (getNode() && isHTMLSummaryElement(*getNode())) {
    if (getNode()->parentNode() &&
        isHTMLDetailsElement(getNode()->parentNode()))
      return toElement(getNode()->parentNode())->hasAttribute(openAttr)
                 ? ExpandedExpanded
                 : ExpandedCollapsed;
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
}
","AccessibilityExpanded AXNodeObject::isExpanded() const {
  if (getNode() && isHTMLSummaryElement(*getNode())) {
    if (getNode()->parentNode() &&
        isHTMLDetailsElement(getNode()->parentNode()))
      return toElement(getNode()->parentNode())->hasAttribute(openAttr)
                 ? ExpandedExpanded
                 : ExpandedCollapsed;
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
  if (equalIgnoringCase(expanded, ""true""))
     return ExpandedExpanded;
  if (equalIgnoringCase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
}
",C,"  if (equalIgnoringASCIICase(expanded, ""true""))
  if (equalIgnoringASCIICase(expanded, ""false""))
","  if (equalIgnoringCase(expanded, ""true""))
  if (equalIgnoringCase(expanded, ""false""))
",,"@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {
            AXSparseAttributeClient& attributeMap,
            const AtomicString& value) override {
     attributeMap.addBoolAttribute(m_attribute,
-                                  equalIgnoringCase(value, ""true""));
+                                  equalIgnoringASCIICase(value, ""true""));
   }
 };
 
@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(
   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {
     return false;
   // Both ""true"" (case-insensitive) and the empty string count as true.
   return contentEditableValue.isEmpty() ||
-         equalIgnoringCase(contentEditableValue, ""true"");
+         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
 
 bool AXNodeObject::isTextControl() const {
@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
-    if (equalIgnoringCase(siblingAriaRole, role))
+    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {
 bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
-  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
-  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
-      if (equalIgnoringCase(
+      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
-  if (equalIgnoringCase(expanded, ""true""))
+  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
-  if (equalIgnoringCase(expanded, ""false""))
+  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
-    if (equalIgnoringCase(modal, ""true""))
+    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
-    if (equalIgnoringCase(modal, ""false""))
+    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {
   // ARIA button with aria-pressed not undefined, then check for aria-pressed
   // attribute rather than getNode()->active()
   if (ariaRoleAttribute() == ToggleButtonRole) {
-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
-        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }
@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {
 }
 
 bool AXNodeObject::canSetValueAttribute() const {
-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
-  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
+  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
-  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
+  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
-  if (!equalIgnoringCase(type, ""color""))
+  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
   // HTMLInputElement::value always returns a string parseable by Color.
@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
+  if (attributeValue.isEmpty() ||
+      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
-  if (equalIgnoringCase(attributeValue, ""page""))
+  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
-  if (equalIgnoringCase(attributeValue, ""step""))
+  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
-  if (equalIgnoringCase(attributeValue, ""location""))
+  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
-  if (equalIgnoringCase(attributeValue, ""date""))
+  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
-  if (equalIgnoringCase(attributeValue, ""time""))
+  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   // An unknown value should return true.
   if (!attributeValue.isEmpty())
@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
 InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
-  if (equalIgnoringCase(attributeValue, ""false""))
+  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
-  if (equalIgnoringCase(attributeValue, ""spelling""))
+  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
-  if (equalIgnoringCase(attributeValue, ""grammar""))
+  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   // A yet unknown value.
   if (!attributeValue.isEmpty())
@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,
     // true if any ancestor is hidden, but we need to be able to compute the
     // accessible name of object inside hidden subtrees (for example, if
     // aria-labelledby points to an object that's hidden).
-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
     // If we're going between two layoutObjects that are in separate",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"AccessibilityExpanded AXNodeObject::isExpanded() const {
  if (getNode() && isHTMLSummaryElement(*getNode())) {
    if (getNode()->parentNode() &&
        isHTMLDetailsElement(getNode()->parentNode()))
      return toElement(getNode()->parentNode())->hasAttribute(openAttr)
                 ? ExpandedExpanded
                 : ExpandedCollapsed;
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
//flaw_line_below:
  if (equalIgnoringCase(expanded, ""true""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
//flaw_line_below:
  if (equalIgnoringCase(expanded, ""false""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
}
"
8058,185794,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,2,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",2,third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","bool AXNodeObject::isModal() const {
  if (roleValue() != DialogRole && roleValue() != AlertDialogRole)
    return false;
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
  if (getNode() && isHTMLDialogElement(*getNode()))
    return toElement(getNode())->isInTopLayer();

  return false;
}
","bool AXNodeObject::isModal() const {
  if (roleValue() != DialogRole && roleValue() != AlertDialogRole)
    return false;
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
    if (equalIgnoringCase(modal, ""true""))
       return true;
    if (equalIgnoringCase(modal, ""false""))
       return false;
   }
 
  if (getNode() && isHTMLDialogElement(*getNode()))
    return toElement(getNode())->isInTopLayer();

  return false;
}
",C,"    if (equalIgnoringASCIICase(modal, ""true""))
    if (equalIgnoringASCIICase(modal, ""false""))
","    if (equalIgnoringCase(modal, ""true""))
    if (equalIgnoringCase(modal, ""false""))
",,"@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {
            AXSparseAttributeClient& attributeMap,
            const AtomicString& value) override {
     attributeMap.addBoolAttribute(m_attribute,
-                                  equalIgnoringCase(value, ""true""));
+                                  equalIgnoringASCIICase(value, ""true""));
   }
 };
 
@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(
   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {
     return false;
   // Both ""true"" (case-insensitive) and the empty string count as true.
   return contentEditableValue.isEmpty() ||
-         equalIgnoringCase(contentEditableValue, ""true"");
+         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
 
 bool AXNodeObject::isTextControl() const {
@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
-    if (equalIgnoringCase(siblingAriaRole, role))
+    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {
 bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
-  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
-  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
-      if (equalIgnoringCase(
+      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
-  if (equalIgnoringCase(expanded, ""true""))
+  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
-  if (equalIgnoringCase(expanded, ""false""))
+  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
-    if (equalIgnoringCase(modal, ""true""))
+    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
-    if (equalIgnoringCase(modal, ""false""))
+    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {
   // ARIA button with aria-pressed not undefined, then check for aria-pressed
   // attribute rather than getNode()->active()
   if (ariaRoleAttribute() == ToggleButtonRole) {
-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
-        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }
@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {
 }
 
 bool AXNodeObject::canSetValueAttribute() const {
-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
-  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
+  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
-  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
+  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
-  if (!equalIgnoringCase(type, ""color""))
+  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
   // HTMLInputElement::value always returns a string parseable by Color.
@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
+  if (attributeValue.isEmpty() ||
+      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
-  if (equalIgnoringCase(attributeValue, ""page""))
+  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
-  if (equalIgnoringCase(attributeValue, ""step""))
+  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
-  if (equalIgnoringCase(attributeValue, ""location""))
+  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
-  if (equalIgnoringCase(attributeValue, ""date""))
+  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
-  if (equalIgnoringCase(attributeValue, ""time""))
+  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   // An unknown value should return true.
   if (!attributeValue.isEmpty())
@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
 InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
-  if (equalIgnoringCase(attributeValue, ""false""))
+  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
-  if (equalIgnoringCase(attributeValue, ""spelling""))
+  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
-  if (equalIgnoringCase(attributeValue, ""grammar""))
+  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   // A yet unknown value.
   if (!attributeValue.isEmpty())
@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,
     // true if any ancestor is hidden, but we need to be able to compute the
     // accessible name of object inside hidden subtrees (for example, if
     // aria-labelledby points to an object that's hidden).
-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
     // If we're going between two layoutObjects that are in separate",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"bool AXNodeObject::isModal() const {
  if (roleValue() != DialogRole && roleValue() != AlertDialogRole)
    return false;
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
//flaw_line_below:
    if (equalIgnoringCase(modal, ""true""))
//fix_flaw_line_below:
//    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
//flaw_line_below:
    if (equalIgnoringCase(modal, ""false""))
//fix_flaw_line_below:
//    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
  if (getNode() && isHTMLDialogElement(*getNode()))
    return toElement(getNode())->isInTopLayer();

  return false;
}
"
8059,185795,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,2,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",2,third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}"," bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
         toHTMLSelectElement(*getNode()).isMultiple();
}
"," bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
     return true;
  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
         toHTMLSelectElement(*getNode()).isMultiple();
}
",C,"  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
","  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
",,"@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {
            AXSparseAttributeClient& attributeMap,
            const AtomicString& value) override {
     attributeMap.addBoolAttribute(m_attribute,
-                                  equalIgnoringCase(value, ""true""));
+                                  equalIgnoringASCIICase(value, ""true""));
   }
 };
 
@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(
   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {
     return false;
   // Both ""true"" (case-insensitive) and the empty string count as true.
   return contentEditableValue.isEmpty() ||
-         equalIgnoringCase(contentEditableValue, ""true"");
+         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
 
 bool AXNodeObject::isTextControl() const {
@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
-    if (equalIgnoringCase(siblingAriaRole, role))
+    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {
 bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
-  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
-  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
-      if (equalIgnoringCase(
+      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
-  if (equalIgnoringCase(expanded, ""true""))
+  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
-  if (equalIgnoringCase(expanded, ""false""))
+  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
-    if (equalIgnoringCase(modal, ""true""))
+    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
-    if (equalIgnoringCase(modal, ""false""))
+    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {
   // ARIA button with aria-pressed not undefined, then check for aria-pressed
   // attribute rather than getNode()->active()
   if (ariaRoleAttribute() == ToggleButtonRole) {
-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
-        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }
@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {
 }
 
 bool AXNodeObject::canSetValueAttribute() const {
-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
-  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
+  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
-  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
+  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
-  if (!equalIgnoringCase(type, ""color""))
+  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
   // HTMLInputElement::value always returns a string parseable by Color.
@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
+  if (attributeValue.isEmpty() ||
+      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
-  if (equalIgnoringCase(attributeValue, ""page""))
+  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
-  if (equalIgnoringCase(attributeValue, ""step""))
+  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
-  if (equalIgnoringCase(attributeValue, ""location""))
+  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
-  if (equalIgnoringCase(attributeValue, ""date""))
+  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
-  if (equalIgnoringCase(attributeValue, ""time""))
+  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   // An unknown value should return true.
   if (!attributeValue.isEmpty())
@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
 InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
-  if (equalIgnoringCase(attributeValue, ""false""))
+  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
-  if (equalIgnoringCase(attributeValue, ""spelling""))
+  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
-  if (equalIgnoringCase(attributeValue, ""grammar""))
+  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   // A yet unknown value.
   if (!attributeValue.isEmpty())
@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,
     // true if any ancestor is hidden, but we need to be able to compute the
     // accessible name of object inside hidden subtrees (for example, if
     // aria-labelledby points to an object that's hidden).
-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
     // If we're going between two layoutObjects that are in separate",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1," bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
//flaw_line_below:
  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
//flaw_line_below:
  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
         toHTMLSelectElement(*getNode()).isMultiple();
}
"
8060,185796,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,2,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",2,third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","bool AXNodeObject::isPressed() const {
  if (!isButton())
    return false;

  Node* node = this->getNode();
  if (!node)
    return false;

   if (ariaRoleAttribute() == ToggleButtonRole) {
    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }

  return node->isActive();
}
","bool AXNodeObject::isPressed() const {
  if (!isButton())
    return false;

  Node* node = this->getNode();
  if (!node)
    return false;

   if (ariaRoleAttribute() == ToggleButtonRole) {
    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }

  return node->isActive();
}
",C,"    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
","    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
",,"@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {
            AXSparseAttributeClient& attributeMap,
            const AtomicString& value) override {
     attributeMap.addBoolAttribute(m_attribute,
-                                  equalIgnoringCase(value, ""true""));
+                                  equalIgnoringASCIICase(value, ""true""));
   }
 };
 
@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(
   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {
     return false;
   // Both ""true"" (case-insensitive) and the empty string count as true.
   return contentEditableValue.isEmpty() ||
-         equalIgnoringCase(contentEditableValue, ""true"");
+         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
 
 bool AXNodeObject::isTextControl() const {
@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
-    if (equalIgnoringCase(siblingAriaRole, role))
+    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {
 bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
-  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
-  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
-      if (equalIgnoringCase(
+      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
-  if (equalIgnoringCase(expanded, ""true""))
+  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
-  if (equalIgnoringCase(expanded, ""false""))
+  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
-    if (equalIgnoringCase(modal, ""true""))
+    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
-    if (equalIgnoringCase(modal, ""false""))
+    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {
   // ARIA button with aria-pressed not undefined, then check for aria-pressed
   // attribute rather than getNode()->active()
   if (ariaRoleAttribute() == ToggleButtonRole) {
-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
-        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }
@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {
 }
 
 bool AXNodeObject::canSetValueAttribute() const {
-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
-  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
+  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
-  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
+  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
-  if (!equalIgnoringCase(type, ""color""))
+  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
   // HTMLInputElement::value always returns a string parseable by Color.
@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
+  if (attributeValue.isEmpty() ||
+      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
-  if (equalIgnoringCase(attributeValue, ""page""))
+  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
-  if (equalIgnoringCase(attributeValue, ""step""))
+  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
-  if (equalIgnoringCase(attributeValue, ""location""))
+  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
-  if (equalIgnoringCase(attributeValue, ""date""))
+  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
-  if (equalIgnoringCase(attributeValue, ""time""))
+  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   // An unknown value should return true.
   if (!attributeValue.isEmpty())
@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
 InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
-  if (equalIgnoringCase(attributeValue, ""false""))
+  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
-  if (equalIgnoringCase(attributeValue, ""spelling""))
+  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
-  if (equalIgnoringCase(attributeValue, ""grammar""))
+  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   // A yet unknown value.
   if (!attributeValue.isEmpty())
@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,
     // true if any ancestor is hidden, but we need to be able to compute the
     // accessible name of object inside hidden subtrees (for example, if
     // aria-labelledby points to an object that's hidden).
-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
     // If we're going between two layoutObjects that are in separate",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"bool AXNodeObject::isPressed() const {
  if (!isButton())
    return false;

  Node* node = this->getNode();
  if (!node)
    return false;

   // ARIA button with aria-pressed not undefined, then check for aria-pressed
   // attribute rather than getNode()->active()
   if (ariaRoleAttribute() == ToggleButtonRole) {
//flaw_line_below:
    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
//flaw_line_below:
        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
//fix_flaw_line_below:
//    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
//fix_flaw_line_below:
//        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }

  return node->isActive();
}
"
8061,185797,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","bool AXNodeObject::isRequired() const {
  Node* n = this->getNode();
  if (n && (n->isElementNode() && toElement(n)->isFormControlElement()) &&
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
}
","bool AXNodeObject::isRequired() const {
  Node* n = this->getNode();
  if (n && (n->isElementNode() && toElement(n)->isFormControlElement()) &&
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
}
",C,"  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
","  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
",,"@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {
            AXSparseAttributeClient& attributeMap,
            const AtomicString& value) override {
     attributeMap.addBoolAttribute(m_attribute,
-                                  equalIgnoringCase(value, ""true""));
+                                  equalIgnoringASCIICase(value, ""true""));
   }
 };
 
@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(
   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {
     return false;
   // Both ""true"" (case-insensitive) and the empty string count as true.
   return contentEditableValue.isEmpty() ||
-         equalIgnoringCase(contentEditableValue, ""true"");
+         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
 
 bool AXNodeObject::isTextControl() const {
@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
-    if (equalIgnoringCase(siblingAriaRole, role))
+    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {
 bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
-  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
-  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
-      if (equalIgnoringCase(
+      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
-  if (equalIgnoringCase(expanded, ""true""))
+  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
-  if (equalIgnoringCase(expanded, ""false""))
+  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
-    if (equalIgnoringCase(modal, ""true""))
+    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
-    if (equalIgnoringCase(modal, ""false""))
+    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {
   // ARIA button with aria-pressed not undefined, then check for aria-pressed
   // attribute rather than getNode()->active()
   if (ariaRoleAttribute() == ToggleButtonRole) {
-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
-        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }
@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {
 }
 
 bool AXNodeObject::canSetValueAttribute() const {
-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
-  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
+  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
-  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
+  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
-  if (!equalIgnoringCase(type, ""color""))
+  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
   // HTMLInputElement::value always returns a string parseable by Color.
@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
+  if (attributeValue.isEmpty() ||
+      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
-  if (equalIgnoringCase(attributeValue, ""page""))
+  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
-  if (equalIgnoringCase(attributeValue, ""step""))
+  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
-  if (equalIgnoringCase(attributeValue, ""location""))
+  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
-  if (equalIgnoringCase(attributeValue, ""date""))
+  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
-  if (equalIgnoringCase(attributeValue, ""time""))
+  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   // An unknown value should return true.
   if (!attributeValue.isEmpty())
@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
 InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
-  if (equalIgnoringCase(attributeValue, ""false""))
+  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
-  if (equalIgnoringCase(attributeValue, ""spelling""))
+  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
-  if (equalIgnoringCase(attributeValue, ""grammar""))
+  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   // A yet unknown value.
   if (!attributeValue.isEmpty())
@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,
     // true if any ancestor is hidden, but we need to be able to compute the
     // accessible name of object inside hidden subtrees (for example, if
     // aria-labelledby points to an object that's hidden).
-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
     // If we're going between two layoutObjects that are in separate",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"bool AXNodeObject::isRequired() const {
  Node* n = this->getNode();
  if (n && (n->isElementNode() && toElement(n)->isFormControlElement()) &&
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
//flaw_line_below:
  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
}
"
8062,185798,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,2,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",2,third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
    case ComboBoxRole:
    case ListBoxRole:
    case MenuRole:
    case ScrollBarRole:
    case TreeRole:
      if (orientation == AccessibilityOrientationUndefined)
        orientation = AccessibilityOrientationVertical;

      return orientation;
    case MenuBarRole:
    case SliderRole:
    case SplitterRole:
    case TabListRole:
    case ToolbarRole:
      if (orientation == AccessibilityOrientationUndefined)
        orientation = AccessibilityOrientationHorizontal;

      return orientation;
    case RadioGroupRole:
    case TreeGridRole:
    case TableRole:
      return orientation;
    default:
      return AXObject::orientation();
  }
}
","AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
    case ComboBoxRole:
    case ListBoxRole:
    case MenuRole:
    case ScrollBarRole:
    case TreeRole:
      if (orientation == AccessibilityOrientationUndefined)
        orientation = AccessibilityOrientationVertical;

      return orientation;
    case MenuBarRole:
    case SliderRole:
    case SplitterRole:
    case TabListRole:
    case ToolbarRole:
      if (orientation == AccessibilityOrientationUndefined)
        orientation = AccessibilityOrientationHorizontal;

      return orientation;
    case RadioGroupRole:
    case TreeGridRole:
    case TableRole:
      return orientation;
    default:
      return AXObject::orientation();
  }
}
",C,"  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
","  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
",,"@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {
            AXSparseAttributeClient& attributeMap,
            const AtomicString& value) override {
     attributeMap.addBoolAttribute(m_attribute,
-                                  equalIgnoringCase(value, ""true""));
+                                  equalIgnoringASCIICase(value, ""true""));
   }
 };
 
@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(
   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {
     return false;
   // Both ""true"" (case-insensitive) and the empty string count as true.
   return contentEditableValue.isEmpty() ||
-         equalIgnoringCase(contentEditableValue, ""true"");
+         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
 
 bool AXNodeObject::isTextControl() const {
@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
-    if (equalIgnoringCase(siblingAriaRole, role))
+    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {
 bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
-  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
-  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
-      if (equalIgnoringCase(
+      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
-  if (equalIgnoringCase(expanded, ""true""))
+  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
-  if (equalIgnoringCase(expanded, ""false""))
+  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
-    if (equalIgnoringCase(modal, ""true""))
+    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
-    if (equalIgnoringCase(modal, ""false""))
+    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {
   // ARIA button with aria-pressed not undefined, then check for aria-pressed
   // attribute rather than getNode()->active()
   if (ariaRoleAttribute() == ToggleButtonRole) {
-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
-        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }
@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {
 }
 
 bool AXNodeObject::canSetValueAttribute() const {
-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
-  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
+  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
-  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
+  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
-  if (!equalIgnoringCase(type, ""color""))
+  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
   // HTMLInputElement::value always returns a string parseable by Color.
@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
+  if (attributeValue.isEmpty() ||
+      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
-  if (equalIgnoringCase(attributeValue, ""page""))
+  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
-  if (equalIgnoringCase(attributeValue, ""step""))
+  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
-  if (equalIgnoringCase(attributeValue, ""location""))
+  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
-  if (equalIgnoringCase(attributeValue, ""date""))
+  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
-  if (equalIgnoringCase(attributeValue, ""time""))
+  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   // An unknown value should return true.
   if (!attributeValue.isEmpty())
@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
 InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
-  if (equalIgnoringCase(attributeValue, ""false""))
+  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
-  if (equalIgnoringCase(attributeValue, ""spelling""))
+  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
-  if (equalIgnoringCase(attributeValue, ""grammar""))
+  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   // A yet unknown value.
   if (!attributeValue.isEmpty())
@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,
     // true if any ancestor is hidden, but we need to be able to compute the
     // accessible name of object inside hidden subtrees (for example, if
     // aria-labelledby points to an object that's hidden).
-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
     // If we're going between two layoutObjects that are in separate",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
//flaw_line_below:
  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
//flaw_line_below:
  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
//fix_flaw_line_below:
//  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
    case ComboBoxRole:
    case ListBoxRole:
    case MenuRole:
    case ScrollBarRole:
    case TreeRole:
      if (orientation == AccessibilityOrientationUndefined)
        orientation = AccessibilityOrientationVertical;

      return orientation;
    case MenuBarRole:
    case SliderRole:
    case SplitterRole:
    case TabListRole:
    case ToolbarRole:
      if (orientation == AccessibilityOrientationUndefined)
        orientation = AccessibilityOrientationHorizontal;

      return orientation;
    case RadioGroupRole:
    case TreeGridRole:
    // TODO(nektar): Fix bug 532670 and remove table role.
    case TableRole:
      return orientation;
    default:
      return AXObject::orientation();
  }
}
"
8063,185799,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","static Element* siblingWithAriaRole(String role, Node* node) {
  Node* parent = node->parentNode();
  if (!parent)
    return 0;

  for (Element* sibling = ElementTraversal::firstChild(*parent); sibling;
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
  return 0;
}
","static Element* siblingWithAriaRole(String role, Node* node) {
  Node* parent = node->parentNode();
  if (!parent)
    return 0;

  for (Element* sibling = ElementTraversal::firstChild(*parent); sibling;
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
    if (equalIgnoringCase(siblingAriaRole, role))
       return sibling;
   }
 
  return 0;
}
",C,"    if (equalIgnoringASCIICase(siblingAriaRole, role))
","    if (equalIgnoringCase(siblingAriaRole, role))
",,"@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {
            AXSparseAttributeClient& attributeMap,
            const AtomicString& value) override {
     attributeMap.addBoolAttribute(m_attribute,
-                                  equalIgnoringCase(value, ""true""));
+                                  equalIgnoringASCIICase(value, ""true""));
   }
 };
 
@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(
   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {
     return false;
   // Both ""true"" (case-insensitive) and the empty string count as true.
   return contentEditableValue.isEmpty() ||
-         equalIgnoringCase(contentEditableValue, ""true"");
+         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
 
 bool AXNodeObject::isTextControl() const {
@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
-    if (equalIgnoringCase(siblingAriaRole, role))
+    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {
 bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
-  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
-  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
-      if (equalIgnoringCase(
+      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
-  if (equalIgnoringCase(expanded, ""true""))
+  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
-  if (equalIgnoringCase(expanded, ""false""))
+  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
-    if (equalIgnoringCase(modal, ""true""))
+    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
-    if (equalIgnoringCase(modal, ""false""))
+    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {
   // ARIA button with aria-pressed not undefined, then check for aria-pressed
   // attribute rather than getNode()->active()
   if (ariaRoleAttribute() == ToggleButtonRole) {
-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
-        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }
@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {
 }
 
 bool AXNodeObject::canSetValueAttribute() const {
-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
-  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
+  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
-  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
+  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
-  if (!equalIgnoringCase(type, ""color""))
+  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
   // HTMLInputElement::value always returns a string parseable by Color.
@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
+  if (attributeValue.isEmpty() ||
+      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
-  if (equalIgnoringCase(attributeValue, ""page""))
+  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
-  if (equalIgnoringCase(attributeValue, ""step""))
+  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
-  if (equalIgnoringCase(attributeValue, ""location""))
+  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
-  if (equalIgnoringCase(attributeValue, ""date""))
+  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
-  if (equalIgnoringCase(attributeValue, ""time""))
+  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   // An unknown value should return true.
   if (!attributeValue.isEmpty())
@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
 InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
-  if (equalIgnoringCase(attributeValue, ""false""))
+  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
-  if (equalIgnoringCase(attributeValue, ""spelling""))
+  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
-  if (equalIgnoringCase(attributeValue, ""grammar""))
+  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   // A yet unknown value.
   if (!attributeValue.isEmpty())
@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,
     // true if any ancestor is hidden, but we need to be able to compute the
     // accessible name of object inside hidden subtrees (for example, if
     // aria-labelledby points to an object that's hidden).
-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
     // If we're going between two layoutObjects that are in separate",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"static Element* siblingWithAriaRole(String role, Node* node) {
  Node* parent = node->parentNode();
  if (!parent)
    return 0;

  for (Element* sibling = ElementTraversal::firstChild(*parent); sibling;
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
//flaw_line_below:
    if (equalIgnoringCase(siblingAriaRole, role))
//fix_flaw_line_below:
//    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
  return 0;
}
"
8064,185800,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","String AXNodeObject::textFromDescendants(AXObjectSet& visited,
                                         bool recursive) const {
  if (!canHaveChildren() && recursive)
    return String();

  StringBuilder accumulatedText;
  AXObject* previous = nullptr;

  AXObjectVector children;

  HeapVector<Member<AXObject>> ownedChildren;
  computeAriaOwnsChildren(ownedChildren);
  for (AXObject* obj = rawFirstChild(); obj; obj = obj->rawNextSibling()) {
    if (!axObjectCache().isAriaOwned(obj))
      children.push_back(obj);
  }
  for (const auto& ownedChild : ownedChildren)
    children.push_back(ownedChild);

  for (AXObject* child : children) {
    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
    if (previous && accumulatedText.length() &&
        !isHTMLSpace(accumulatedText[accumulatedText.length() - 1])) {
      if (!isInSameNonInlineBlockFlow(child->getLayoutObject(),
                                      previous->getLayoutObject()))
        accumulatedText.append(' ');
    }

    String result;
    if (child->isPresentational())
      result = child->textFromDescendants(visited, true);
    else
      result = recursiveTextAlternative(*child, false, visited);
    accumulatedText.append(result);
    previous = child;
  }

  return accumulatedText.toString();
}
","String AXNodeObject::textFromDescendants(AXObjectSet& visited,
                                         bool recursive) const {
  if (!canHaveChildren() && recursive)
    return String();

  StringBuilder accumulatedText;
  AXObject* previous = nullptr;

  AXObjectVector children;

  HeapVector<Member<AXObject>> ownedChildren;
  computeAriaOwnsChildren(ownedChildren);
  for (AXObject* obj = rawFirstChild(); obj; obj = obj->rawNextSibling()) {
    if (!axObjectCache().isAriaOwned(obj))
      children.push_back(obj);
  }
  for (const auto& ownedChild : ownedChildren)
    children.push_back(ownedChild);

  for (AXObject* child : children) {
    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
    if (previous && accumulatedText.length() &&
        !isHTMLSpace(accumulatedText[accumulatedText.length() - 1])) {
      if (!isInSameNonInlineBlockFlow(child->getLayoutObject(),
                                      previous->getLayoutObject()))
        accumulatedText.append(' ');
    }

    String result;
    if (child->isPresentational())
      result = child->textFromDescendants(visited, true);
    else
      result = recursiveTextAlternative(*child, false, visited);
    accumulatedText.append(result);
    previous = child;
  }

  return accumulatedText.toString();
}
",C,"    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
","    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
",,"@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {
            AXSparseAttributeClient& attributeMap,
            const AtomicString& value) override {
     attributeMap.addBoolAttribute(m_attribute,
-                                  equalIgnoringCase(value, ""true""));
+                                  equalIgnoringASCIICase(value, ""true""));
   }
 };
 
@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(
   Element* element = getNode()->isElementNode() ? toElement(getNode())
                                                 : getNode()->parentElement();
   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false"")) {
+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false"")) {
     if (ignoredReasons)
       ignoredReasons->push_back(IgnoredReason(AXNotRendered));
     return true;
@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {
     return false;
   // Both ""true"" (case-insensitive) and the empty string count as true.
   return contentEditableValue.isEmpty() ||
-         equalIgnoringCase(contentEditableValue, ""true"");
+         equalIgnoringASCIICase(contentEditableValue, ""true"");
 }
 
 bool AXNodeObject::isTextControl() const {
@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {
        sibling = ElementTraversal::nextSibling(*sibling)) {
     const AtomicString& siblingAriaRole =
         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
-    if (equalIgnoringCase(siblingAriaRole, role))
+    if (equalIgnoringASCIICase(siblingAriaRole, role))
       return sibling;
   }
 
@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {
 bool AXNodeObject::isMultiSelectable() const {
   const AtomicString& ariaMultiSelectable =
       getAttribute(aria_multiselectableAttr);
-  if (equalIgnoringCase(ariaMultiSelectable, ""true""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""true""))
     return true;
-  if (equalIgnoringCase(ariaMultiSelectable, ""false""))
+  if (equalIgnoringASCIICase(ariaMultiSelectable, ""false""))
     return false;
 
   return isHTMLSelectElement(getNode()) &&
@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {
     case MenuItemRadioRole:
     case RadioButtonRole:
     case SwitchRole:
-      if (equalIgnoringCase(
+      if (equalIgnoringASCIICase(
               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
               ""true""))
         return true;
@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {
   }
 
   const AtomicString& expanded = getAttribute(aria_expandedAttr);
-  if (equalIgnoringCase(expanded, ""true""))
+  if (equalIgnoringASCIICase(expanded, ""true""))
     return ExpandedExpanded;
-  if (equalIgnoringCase(expanded, ""false""))
+  if (equalIgnoringASCIICase(expanded, ""false""))
     return ExpandedCollapsed;
 
   return ExpandedUndefined;
@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
-    if (equalIgnoringCase(modal, ""true""))
+    if (equalIgnoringASCIICase(modal, ""true""))
       return true;
-    if (equalIgnoringCase(modal, ""false""))
+    if (equalIgnoringASCIICase(modal, ""false""))
       return false;
   }
 
@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {
   // ARIA button with aria-pressed not undefined, then check for aria-pressed
   // attribute rather than getNode()->active()
   if (ariaRoleAttribute() == ToggleButtonRole) {
-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), ""true"") ||
-        equalIgnoringCase(getAttribute(aria_pressedAttr), ""mixed""))
+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""true"") ||
+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), ""mixed""))
       return true;
     return false;
   }
@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {
       hasAttribute(requiredAttr))
     return toHTMLFormControlElement(n)->isRequired();
 
-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), ""true""))
     return true;
 
   return false;
@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {
 }
 
 bool AXNodeObject::canSetValueAttribute() const {
-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), ""true""))
+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), ""true""))
     return false;
 
   if (isProgressIndicator() || isSlider())
@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {
   const AtomicString& ariaOrientation =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
-  if (equalIgnoringCase(ariaOrientation, ""horizontal""))
+  if (equalIgnoringASCIICase(ariaOrientation, ""horizontal""))
     orientation = AccessibilityOrientationHorizontal;
-  else if (equalIgnoringCase(ariaOrientation, ""vertical""))
+  else if (equalIgnoringASCIICase(ariaOrientation, ""vertical""))
     orientation = AccessibilityOrientationVertical;
 
   switch (roleValue()) {
@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {
 
   HTMLInputElement* input = toHTMLInputElement(getNode());
   const AtomicString& type = input->getAttribute(typeAttr);
-  if (!equalIgnoringCase(type, ""color""))
+  if (!equalIgnoringASCIICase(type, ""color""))
     return AXObject::colorValue();
 
   // HTMLInputElement::value always returns a string parseable by Color.
@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
   if (attributeValue.isNull())
     return AriaCurrentStateUndefined;
-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, ""false""))
+  if (attributeValue.isEmpty() ||
+      equalIgnoringASCIICase(attributeValue, ""false""))
     return AriaCurrentStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return AriaCurrentStateTrue;
-  if (equalIgnoringCase(attributeValue, ""page""))
+  if (equalIgnoringASCIICase(attributeValue, ""page""))
     return AriaCurrentStatePage;
-  if (equalIgnoringCase(attributeValue, ""step""))
+  if (equalIgnoringASCIICase(attributeValue, ""step""))
     return AriaCurrentStateStep;
-  if (equalIgnoringCase(attributeValue, ""location""))
+  if (equalIgnoringASCIICase(attributeValue, ""location""))
     return AriaCurrentStateLocation;
-  if (equalIgnoringCase(attributeValue, ""date""))
+  if (equalIgnoringASCIICase(attributeValue, ""date""))
     return AriaCurrentStateDate;
-  if (equalIgnoringCase(attributeValue, ""time""))
+  if (equalIgnoringASCIICase(attributeValue, ""time""))
     return AriaCurrentStateTime;
   // An unknown value should return true.
   if (!attributeValue.isEmpty())
@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {
 InvalidState AXNodeObject::getInvalidState() const {
   const AtomicString& attributeValue =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
-  if (equalIgnoringCase(attributeValue, ""false""))
+  if (equalIgnoringASCIICase(attributeValue, ""false""))
     return InvalidStateFalse;
-  if (equalIgnoringCase(attributeValue, ""true""))
+  if (equalIgnoringASCIICase(attributeValue, ""true""))
     return InvalidStateTrue;
-  if (equalIgnoringCase(attributeValue, ""spelling""))
+  if (equalIgnoringASCIICase(attributeValue, ""spelling""))
     return InvalidStateSpelling;
-  if (equalIgnoringCase(attributeValue, ""grammar""))
+  if (equalIgnoringASCIICase(attributeValue, ""grammar""))
     return InvalidStateGrammar;
   // A yet unknown value.
   if (!attributeValue.isEmpty())
@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,
     // true if any ancestor is hidden, but we need to be able to compute the
     // accessible name of object inside hidden subtrees (for example, if
     // aria-labelledby points to an object that's hidden).
-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
     // If we're going between two layoutObjects that are in separate",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"String AXNodeObject::textFromDescendants(AXObjectSet& visited,
                                         bool recursive) const {
  if (!canHaveChildren() && recursive)
    return String();

  StringBuilder accumulatedText;
  AXObject* previous = nullptr;

  AXObjectVector children;

  HeapVector<Member<AXObject>> ownedChildren;
  computeAriaOwnsChildren(ownedChildren);
  for (AXObject* obj = rawFirstChild(); obj; obj = obj->rawNextSibling()) {
    if (!axObjectCache().isAriaOwned(obj))
      children.push_back(obj);
  }
  for (const auto& ownedChild : ownedChildren)
    children.push_back(ownedChild);

  for (AXObject* child : children) {
    // Don't recurse into children that are explicitly marked as aria-hidden.
    // Note that we don't call isInertOrAriaHidden because that would return
     // true if any ancestor is hidden, but we need to be able to compute the
     // accessible name of object inside hidden subtrees (for example, if
     // aria-labelledby points to an object that's hidden).
//flaw_line_below:
    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), ""true""))
//fix_flaw_line_below:
//    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), ""true""))
       continue;
 
     // If we're going between two layoutObjects that are in separate
    // LayoutBoxes, add whitespace if it wasn't there already. Intuitively if
    // you have <span>Hello</span><span>World</span>, those are part of the same
    // LayoutBox so we should return ""HelloWorld"", but given
    // <div>Hello</div><div>World</div> the strings are in separate boxes so we
    // should return ""Hello World"".
    if (previous && accumulatedText.length() &&
        !isHTMLSpace(accumulatedText[accumulatedText.length() - 1])) {
      if (!isInSameNonInlineBlockFlow(child->getLayoutObject(),
                                      previous->getLayoutObject()))
        accumulatedText.append(' ');
    }

    String result;
    if (child->isPresentational())
      result = child->textFromDescendants(visited, true);
    else
      result = recursiveTextAlternative(*child, false, visited);
    accumulatedText.append(result);
    previous = child;
  }

  return accumulatedText.toString();
}
"
8065,185801,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}"," const AXObject* AXObject::ariaHiddenRoot() const {
   for (const AXObject* object = this; object; object = object->parentObject()) {
    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), ""true""))
       return object;
   }
 
  return 0;
}
"," const AXObject* AXObject::ariaHiddenRoot() const {
   for (const AXObject* object = this; object; object = object->parentObject()) {
    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), ""true""))
       return object;
   }
 
  return 0;
}
",C,"    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), ""true""))
","    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), ""true""))
",,"@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {
 
 const AXObject* AXObject::ariaHiddenRoot() const {
   for (const AXObject* object = this; object; object = object->parentObject()) {
-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), ""true""))
       return object;
   }
 
@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {
 
 const AXObject* AXObject::disabledAncestor() const {
   const AtomicString& disabled = getAttribute(aria_disabledAttr);
-  if (equalIgnoringCase(disabled, ""true""))
+  if (equalIgnoringASCIICase(disabled, ""true""))
     return this;
-  if (equalIgnoringCase(disabled, ""false""))
+  if (equalIgnoringASCIICase(disabled, ""false""))
     return 0;
 
   if (AXObject* parent = parentObject())
@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,
 }
 
 bool AXObject::isHiddenForTextAlternativeCalculation() const {
-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
     return false;
 
   if (getLayoutObject())
@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {
 AccessibilityButtonState AXObject::checkboxOrRadioValue() const {
   const AtomicString& checkedAttribute =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);
-  if (equalIgnoringCase(checkedAttribute, ""true""))
+  if (equalIgnoringASCIICase(checkedAttribute, ""true""))
     return ButtonStateOn;
 
-  if (equalIgnoringCase(checkedAttribute, ""mixed"")) {
+  if (equalIgnoringASCIICase(checkedAttribute, ""mixed"")) {
     // Only checkboxes should support the mixed state.
     AccessibilityRole role = ariaRoleAttribute();
     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)
@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {
   if (!isNativeTextControl() && !isNonNativeTextControl())
     return false;
 
-  return equalIgnoringCase(getAttribute(aria_multilineAttr), ""true"");
+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), ""true"");
 }
 
 bool AXObject::ariaPressedIsPresent() const {
@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {
 
 bool AXObject::isLiveRegion() const {
   const AtomicString& liveRegion = liveRegionStatus();
-  return equalIgnoringCase(liveRegion, ""polite"") ||
-         equalIgnoringCase(liveRegion, ""assertive"");
+  return equalIgnoringASCIICase(liveRegion, ""polite"") ||
+         equalIgnoringASCIICase(liveRegion, ""assertive"");
 }
 
 AXObject* AXObject::liveRegionRoot() const {",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1," const AXObject* AXObject::ariaHiddenRoot() const {
   for (const AXObject* object = this; object; object = object->parentObject()) {
//flaw_line_below:
    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), ""true""))
//fix_flaw_line_below:
//    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), ""true""))
       return object;
   }
 
  return 0;
}
"
8066,185802,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,2,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",2,third_party/WebKit/Source/modules/accessibility/AXObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}"," AccessibilityButtonState AXObject::checkboxOrRadioValue() const {
   const AtomicString& checkedAttribute =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);
  if (equalIgnoringASCIICase(checkedAttribute, ""true""))
     return ButtonStateOn;
 
  if (equalIgnoringASCIICase(checkedAttribute, ""mixed"")) {
     AccessibilityRole role = ariaRoleAttribute();
     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)
      return ButtonStateMixed;
  }

  return ButtonStateOff;
}
"," AccessibilityButtonState AXObject::checkboxOrRadioValue() const {
   const AtomicString& checkedAttribute =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);
  if (equalIgnoringCase(checkedAttribute, ""true""))
     return ButtonStateOn;
 
  if (equalIgnoringCase(checkedAttribute, ""mixed"")) {
     AccessibilityRole role = ariaRoleAttribute();
     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)
      return ButtonStateMixed;
  }

  return ButtonStateOff;
}
",C,"  if (equalIgnoringASCIICase(checkedAttribute, ""true""))
  if (equalIgnoringASCIICase(checkedAttribute, ""mixed"")) {
","  if (equalIgnoringCase(checkedAttribute, ""true""))
  if (equalIgnoringCase(checkedAttribute, ""mixed"")) {
",,"@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {
 
 const AXObject* AXObject::ariaHiddenRoot() const {
   for (const AXObject* object = this; object; object = object->parentObject()) {
-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), ""true""))
       return object;
   }
 
@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {
 
 const AXObject* AXObject::disabledAncestor() const {
   const AtomicString& disabled = getAttribute(aria_disabledAttr);
-  if (equalIgnoringCase(disabled, ""true""))
+  if (equalIgnoringASCIICase(disabled, ""true""))
     return this;
-  if (equalIgnoringCase(disabled, ""false""))
+  if (equalIgnoringASCIICase(disabled, ""false""))
     return 0;
 
   if (AXObject* parent = parentObject())
@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,
 }
 
 bool AXObject::isHiddenForTextAlternativeCalculation() const {
-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
     return false;
 
   if (getLayoutObject())
@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {
 AccessibilityButtonState AXObject::checkboxOrRadioValue() const {
   const AtomicString& checkedAttribute =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);
-  if (equalIgnoringCase(checkedAttribute, ""true""))
+  if (equalIgnoringASCIICase(checkedAttribute, ""true""))
     return ButtonStateOn;
 
-  if (equalIgnoringCase(checkedAttribute, ""mixed"")) {
+  if (equalIgnoringASCIICase(checkedAttribute, ""mixed"")) {
     // Only checkboxes should support the mixed state.
     AccessibilityRole role = ariaRoleAttribute();
     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)
@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {
   if (!isNativeTextControl() && !isNonNativeTextControl())
     return false;
 
-  return equalIgnoringCase(getAttribute(aria_multilineAttr), ""true"");
+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), ""true"");
 }
 
 bool AXObject::ariaPressedIsPresent() const {
@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {
 
 bool AXObject::isLiveRegion() const {
   const AtomicString& liveRegion = liveRegionStatus();
-  return equalIgnoringCase(liveRegion, ""polite"") ||
-         equalIgnoringCase(liveRegion, ""assertive"");
+  return equalIgnoringASCIICase(liveRegion, ""polite"") ||
+         equalIgnoringASCIICase(liveRegion, ""assertive"");
 }
 
 AXObject* AXObject::liveRegionRoot() const {",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1," AccessibilityButtonState AXObject::checkboxOrRadioValue() const {
   const AtomicString& checkedAttribute =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);
//flaw_line_below:
  if (equalIgnoringCase(checkedAttribute, ""true""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(checkedAttribute, ""true""))
     return ButtonStateOn;
 
//flaw_line_below:
  if (equalIgnoringCase(checkedAttribute, ""mixed"")) {
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(checkedAttribute, ""mixed"")) {
     // Only checkboxes should support the mixed state.
     AccessibilityRole role = ariaRoleAttribute();
     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)
      return ButtonStateMixed;
  }

  return ButtonStateOff;
}
"
8067,185803,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,2,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",2,third_party/WebKit/Source/modules/accessibility/AXObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}"," const AXObject* AXObject::disabledAncestor() const {
   const AtomicString& disabled = getAttribute(aria_disabledAttr);
  if (equalIgnoringASCIICase(disabled, ""true""))
     return this;
  if (equalIgnoringASCIICase(disabled, ""false""))
     return 0;
 
   if (AXObject* parent = parentObject())
    return parent->disabledAncestor();

  return 0;
}
"," const AXObject* AXObject::disabledAncestor() const {
   const AtomicString& disabled = getAttribute(aria_disabledAttr);
  if (equalIgnoringCase(disabled, ""true""))
     return this;
  if (equalIgnoringCase(disabled, ""false""))
     return 0;
 
   if (AXObject* parent = parentObject())
    return parent->disabledAncestor();

  return 0;
}
",C,"  if (equalIgnoringASCIICase(disabled, ""true""))
  if (equalIgnoringASCIICase(disabled, ""false""))
","  if (equalIgnoringCase(disabled, ""true""))
  if (equalIgnoringCase(disabled, ""false""))
",,"@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {
 
 const AXObject* AXObject::ariaHiddenRoot() const {
   for (const AXObject* object = this; object; object = object->parentObject()) {
-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), ""true""))
       return object;
   }
 
@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {
 
 const AXObject* AXObject::disabledAncestor() const {
   const AtomicString& disabled = getAttribute(aria_disabledAttr);
-  if (equalIgnoringCase(disabled, ""true""))
+  if (equalIgnoringASCIICase(disabled, ""true""))
     return this;
-  if (equalIgnoringCase(disabled, ""false""))
+  if (equalIgnoringASCIICase(disabled, ""false""))
     return 0;
 
   if (AXObject* parent = parentObject())
@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,
 }
 
 bool AXObject::isHiddenForTextAlternativeCalculation() const {
-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
     return false;
 
   if (getLayoutObject())
@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {
 AccessibilityButtonState AXObject::checkboxOrRadioValue() const {
   const AtomicString& checkedAttribute =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);
-  if (equalIgnoringCase(checkedAttribute, ""true""))
+  if (equalIgnoringASCIICase(checkedAttribute, ""true""))
     return ButtonStateOn;
 
-  if (equalIgnoringCase(checkedAttribute, ""mixed"")) {
+  if (equalIgnoringASCIICase(checkedAttribute, ""mixed"")) {
     // Only checkboxes should support the mixed state.
     AccessibilityRole role = ariaRoleAttribute();
     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)
@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {
   if (!isNativeTextControl() && !isNonNativeTextControl())
     return false;
 
-  return equalIgnoringCase(getAttribute(aria_multilineAttr), ""true"");
+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), ""true"");
 }
 
 bool AXObject::ariaPressedIsPresent() const {
@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {
 
 bool AXObject::isLiveRegion() const {
   const AtomicString& liveRegion = liveRegionStatus();
-  return equalIgnoringCase(liveRegion, ""polite"") ||
-         equalIgnoringCase(liveRegion, ""assertive"");
+  return equalIgnoringASCIICase(liveRegion, ""polite"") ||
+         equalIgnoringASCIICase(liveRegion, ""assertive"");
 }
 
 AXObject* AXObject::liveRegionRoot() const {",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1," const AXObject* AXObject::disabledAncestor() const {
   const AtomicString& disabled = getAttribute(aria_disabledAttr);
//flaw_line_below:
  if (equalIgnoringCase(disabled, ""true""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(disabled, ""true""))
     return this;
//flaw_line_below:
  if (equalIgnoringCase(disabled, ""false""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(disabled, ""false""))
     return 0;
 
   if (AXObject* parent = parentObject())
    return parent->disabledAncestor();

  return 0;
}
"
8068,185804,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}"," bool AXObject::isHiddenForTextAlternativeCalculation() const {
  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
     return false;
 
   if (getLayoutObject())
    return getLayoutObject()->style()->visibility() != EVisibility::kVisible;

  Document* document = getDocument();
  if (!document || !document->frame())
    return false;
  if (Node* node = getNode()) {
    if (node->isConnected() && node->isElementNode()) {
      RefPtr<ComputedStyle> style =
          document->ensureStyleResolver().styleForElement(toElement(node));
      return style->display() == EDisplay::kNone ||
             style->visibility() != EVisibility::kVisible;
    }
  }
  return false;
}
"," bool AXObject::isHiddenForTextAlternativeCalculation() const {
  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
     return false;
 
   if (getLayoutObject())
    return getLayoutObject()->style()->visibility() != EVisibility::kVisible;

  Document* document = getDocument();
  if (!document || !document->frame())
    return false;
  if (Node* node = getNode()) {
    if (node->isConnected() && node->isElementNode()) {
      RefPtr<ComputedStyle> style =
          document->ensureStyleResolver().styleForElement(toElement(node));
      return style->display() == EDisplay::kNone ||
             style->visibility() != EVisibility::kVisible;
    }
  }
  return false;
}
",C,"  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
","  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
",,"@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {
 
 const AXObject* AXObject::ariaHiddenRoot() const {
   for (const AXObject* object = this; object; object = object->parentObject()) {
-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), ""true""))
       return object;
   }
 
@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {
 
 const AXObject* AXObject::disabledAncestor() const {
   const AtomicString& disabled = getAttribute(aria_disabledAttr);
-  if (equalIgnoringCase(disabled, ""true""))
+  if (equalIgnoringASCIICase(disabled, ""true""))
     return this;
-  if (equalIgnoringCase(disabled, ""false""))
+  if (equalIgnoringASCIICase(disabled, ""false""))
     return 0;
 
   if (AXObject* parent = parentObject())
@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,
 }
 
 bool AXObject::isHiddenForTextAlternativeCalculation() const {
-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
     return false;
 
   if (getLayoutObject())
@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {
 AccessibilityButtonState AXObject::checkboxOrRadioValue() const {
   const AtomicString& checkedAttribute =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);
-  if (equalIgnoringCase(checkedAttribute, ""true""))
+  if (equalIgnoringASCIICase(checkedAttribute, ""true""))
     return ButtonStateOn;
 
-  if (equalIgnoringCase(checkedAttribute, ""mixed"")) {
+  if (equalIgnoringASCIICase(checkedAttribute, ""mixed"")) {
     // Only checkboxes should support the mixed state.
     AccessibilityRole role = ariaRoleAttribute();
     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)
@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {
   if (!isNativeTextControl() && !isNonNativeTextControl())
     return false;
 
-  return equalIgnoringCase(getAttribute(aria_multilineAttr), ""true"");
+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), ""true"");
 }
 
 bool AXObject::ariaPressedIsPresent() const {
@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {
 
 bool AXObject::isLiveRegion() const {
   const AtomicString& liveRegion = liveRegionStatus();
-  return equalIgnoringCase(liveRegion, ""polite"") ||
-         equalIgnoringCase(liveRegion, ""assertive"");
+  return equalIgnoringASCIICase(liveRegion, ""polite"") ||
+         equalIgnoringASCIICase(liveRegion, ""assertive"");
 }
 
 AXObject* AXObject::liveRegionRoot() const {",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1," bool AXObject::isHiddenForTextAlternativeCalculation() const {
//flaw_line_below:
  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
     return false;
 
   if (getLayoutObject())
    return getLayoutObject()->style()->visibility() != EVisibility::kVisible;

  // This is an obscure corner case: if a node has no LayoutObject, that means
  // it's not rendered, but we still may be exploring it as part of a text
  // alternative calculation, for example if it was explicitly referenced by
  // aria-labelledby. So we need to explicitly call the style resolver to check
  // whether it's invisible or display:none, rather than relying on the style
  // cached in the LayoutObject.
  Document* document = getDocument();
  if (!document || !document->frame())
    return false;
  if (Node* node = getNode()) {
    if (node->isConnected() && node->isElementNode()) {
      RefPtr<ComputedStyle> style =
          document->ensureStyleResolver().styleForElement(toElement(node));
      return style->display() == EDisplay::kNone ||
             style->visibility() != EVisibility::kVisible;
    }
  }
  return false;
}
"
8069,185805,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,2,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",2,third_party/WebKit/Source/modules/accessibility/AXObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}"," bool AXObject::isLiveRegion() const {
   const AtomicString& liveRegion = liveRegionStatus();
  return equalIgnoringASCIICase(liveRegion, ""polite"") ||
         equalIgnoringASCIICase(liveRegion, ""assertive"");
 }
"," bool AXObject::isLiveRegion() const {
   const AtomicString& liveRegion = liveRegionStatus();
  return equalIgnoringCase(liveRegion, ""polite"") ||
         equalIgnoringCase(liveRegion, ""assertive"");
 }
",C,"  return equalIgnoringASCIICase(liveRegion, ""polite"") ||
         equalIgnoringASCIICase(liveRegion, ""assertive"");
","  return equalIgnoringCase(liveRegion, ""polite"") ||
         equalIgnoringCase(liveRegion, ""assertive"");
",,"@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {
 
 const AXObject* AXObject::ariaHiddenRoot() const {
   for (const AXObject* object = this; object; object = object->parentObject()) {
-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), ""true""))
       return object;
   }
 
@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {
 
 const AXObject* AXObject::disabledAncestor() const {
   const AtomicString& disabled = getAttribute(aria_disabledAttr);
-  if (equalIgnoringCase(disabled, ""true""))
+  if (equalIgnoringASCIICase(disabled, ""true""))
     return this;
-  if (equalIgnoringCase(disabled, ""false""))
+  if (equalIgnoringASCIICase(disabled, ""false""))
     return 0;
 
   if (AXObject* parent = parentObject())
@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,
 }
 
 bool AXObject::isHiddenForTextAlternativeCalculation() const {
-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
     return false;
 
   if (getLayoutObject())
@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {
 AccessibilityButtonState AXObject::checkboxOrRadioValue() const {
   const AtomicString& checkedAttribute =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);
-  if (equalIgnoringCase(checkedAttribute, ""true""))
+  if (equalIgnoringASCIICase(checkedAttribute, ""true""))
     return ButtonStateOn;
 
-  if (equalIgnoringCase(checkedAttribute, ""mixed"")) {
+  if (equalIgnoringASCIICase(checkedAttribute, ""mixed"")) {
     // Only checkboxes should support the mixed state.
     AccessibilityRole role = ariaRoleAttribute();
     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)
@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {
   if (!isNativeTextControl() && !isNonNativeTextControl())
     return false;
 
-  return equalIgnoringCase(getAttribute(aria_multilineAttr), ""true"");
+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), ""true"");
 }
 
 bool AXObject::ariaPressedIsPresent() const {
@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {
 
 bool AXObject::isLiveRegion() const {
   const AtomicString& liveRegion = liveRegionStatus();
-  return equalIgnoringCase(liveRegion, ""polite"") ||
-         equalIgnoringCase(liveRegion, ""assertive"");
+  return equalIgnoringASCIICase(liveRegion, ""polite"") ||
+         equalIgnoringASCIICase(liveRegion, ""assertive"");
 }
 
 AXObject* AXObject::liveRegionRoot() const {",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1," bool AXObject::isLiveRegion() const {
   const AtomicString& liveRegion = liveRegionStatus();
//flaw_line_below:
  return equalIgnoringCase(liveRegion, ""polite"") ||
//flaw_line_below:
         equalIgnoringCase(liveRegion, ""assertive"");
//fix_flaw_line_below:
//  return equalIgnoringASCIICase(liveRegion, ""polite"") ||
//fix_flaw_line_below:
//         equalIgnoringASCIICase(liveRegion, ""assertive"");
 }
"
8070,185806,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXObject.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","bool AXObject::isMultiline() const {
  Node* node = this->getNode();
  if (!node)
    return false;

  if (isHTMLTextAreaElement(*node))
    return true;

  if (hasEditableStyle(*node))
    return true;

   if (!isNativeTextControl() && !isNonNativeTextControl())
     return false;
 
  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), ""true"");
 }
","bool AXObject::isMultiline() const {
  Node* node = this->getNode();
  if (!node)
    return false;

  if (isHTMLTextAreaElement(*node))
    return true;

  if (hasEditableStyle(*node))
    return true;

   if (!isNativeTextControl() && !isNonNativeTextControl())
     return false;
 
  return equalIgnoringCase(getAttribute(aria_multilineAttr), ""true"");
 }
",C,"  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), ""true"");
","  return equalIgnoringCase(getAttribute(aria_multilineAttr), ""true"");
",,"@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {
 
 const AXObject* AXObject::ariaHiddenRoot() const {
   for (const AXObject* object = this; object; object = object->parentObject()) {
-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), ""true""))
+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), ""true""))
       return object;
   }
 
@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {
 
 const AXObject* AXObject::disabledAncestor() const {
   const AtomicString& disabled = getAttribute(aria_disabledAttr);
-  if (equalIgnoringCase(disabled, ""true""))
+  if (equalIgnoringASCIICase(disabled, ""true""))
     return this;
-  if (equalIgnoringCase(disabled, ""false""))
+  if (equalIgnoringASCIICase(disabled, ""false""))
     return 0;
 
   if (AXObject* parent = parentObject())
@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,
 }
 
 bool AXObject::isHiddenForTextAlternativeCalculation() const {
-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
     return false;
 
   if (getLayoutObject())
@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {
 AccessibilityButtonState AXObject::checkboxOrRadioValue() const {
   const AtomicString& checkedAttribute =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);
-  if (equalIgnoringCase(checkedAttribute, ""true""))
+  if (equalIgnoringASCIICase(checkedAttribute, ""true""))
     return ButtonStateOn;
 
-  if (equalIgnoringCase(checkedAttribute, ""mixed"")) {
+  if (equalIgnoringASCIICase(checkedAttribute, ""mixed"")) {
     // Only checkboxes should support the mixed state.
     AccessibilityRole role = ariaRoleAttribute();
     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)
@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {
   if (!isNativeTextControl() && !isNonNativeTextControl())
     return false;
 
-  return equalIgnoringCase(getAttribute(aria_multilineAttr), ""true"");
+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), ""true"");
 }
 
 bool AXObject::ariaPressedIsPresent() const {
@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {
 
 bool AXObject::isLiveRegion() const {
   const AtomicString& liveRegion = liveRegionStatus();
-  return equalIgnoringCase(liveRegion, ""polite"") ||
-         equalIgnoringCase(liveRegion, ""assertive"");
+  return equalIgnoringASCIICase(liveRegion, ""polite"") ||
+         equalIgnoringASCIICase(liveRegion, ""assertive"");
 }
 
 AXObject* AXObject::liveRegionRoot() const {",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"bool AXObject::isMultiline() const {
  Node* node = this->getNode();
  if (!node)
    return false;

  if (isHTMLTextAreaElement(*node))
    return true;

  if (hasEditableStyle(*node))
    return true;

   if (!isNativeTextControl() && !isNonNativeTextControl())
     return false;
 
//flaw_line_below:
  return equalIgnoringCase(getAttribute(aria_multilineAttr), ""true"");
//fix_flaw_line_below:
//  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), ""true"");
 }
"
8071,185807,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,2,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",2,third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","bool isNodeAriaVisible(Node* node) {
  if (!node)
    return false;

   if (!node->isElementNode())
     return false;
 
  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),
                                ""false"");
 }
","bool isNodeAriaVisible(Node* node) {
  if (!node)
    return false;

   if (!node->isElementNode())
     return false;
 
  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),
                           ""false"");
 }
",C,"  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),
                                ""false"");
","  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),
                           ""false"");
",,"@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {
   if (!node || !node->isElementNode())
     return false;
 
-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);
+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);
 }
 
 AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {
@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {
   if (!node->isElementNode())
     return false;
 
-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),
-                           ""false"");
+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),
+                                ""false"");
 }
 
 void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"bool isNodeAriaVisible(Node* node) {
  if (!node)
    return false;

   if (!node->isElementNode())
     return false;
 
//flaw_line_below:
  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),
//flaw_line_below:
                           ""false"");
//fix_flaw_line_below:
//  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),
//fix_flaw_line_below:
//                                ""false"");
 }
"
8072,185808,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","bool nodeHasRole(Node* node, const String& role) {
   if (!node || !node->isElementNode())
     return false;
 
  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);
 }
","bool nodeHasRole(Node* node, const String& role) {
   if (!node || !node->isElementNode())
     return false;
 
  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);
 }
",C,"  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);
","  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);
",,"@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {
   if (!node || !node->isElementNode())
     return false;
 
-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);
+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);
 }
 
 AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {
@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {
   if (!node->isElementNode())
     return false;
 
-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),
-                           ""false"");
+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),
+                                ""false"");
 }
 
 void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"bool nodeHasRole(Node* node, const String& role) {
   if (!node || !node->isElementNode())
     return false;
 
//flaw_line_below:
  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);
//fix_flaw_line_below:
//  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);
 }
"
8073,185809,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,4,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",4,third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","SortDirection AXTableCell::getSortDirection() const {
  if (roleValue() != RowHeaderRole && roleValue() != ColumnHeaderRole)
    return SortDirectionUndefined;

  const AtomicString& ariaSort =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);
   if (ariaSort.isEmpty())
     return SortDirectionUndefined;
  if (equalIgnoringASCIICase(ariaSort, ""none""))
     return SortDirectionNone;
  if (equalIgnoringASCIICase(ariaSort, ""ascending""))
     return SortDirectionAscending;
  if (equalIgnoringASCIICase(ariaSort, ""descending""))
     return SortDirectionDescending;
  if (equalIgnoringASCIICase(ariaSort, ""other""))
     return SortDirectionOther;
   return SortDirectionUndefined;
 }
","SortDirection AXTableCell::getSortDirection() const {
  if (roleValue() != RowHeaderRole && roleValue() != ColumnHeaderRole)
    return SortDirectionUndefined;

  const AtomicString& ariaSort =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);
   if (ariaSort.isEmpty())
     return SortDirectionUndefined;
  if (equalIgnoringCase(ariaSort, ""none""))
     return SortDirectionNone;
  if (equalIgnoringCase(ariaSort, ""ascending""))
     return SortDirectionAscending;
  if (equalIgnoringCase(ariaSort, ""descending""))
     return SortDirectionDescending;
  if (equalIgnoringCase(ariaSort, ""other""))
     return SortDirectionOther;
   return SortDirectionUndefined;
 }
",C,"  if (equalIgnoringASCIICase(ariaSort, ""none""))
  if (equalIgnoringASCIICase(ariaSort, ""ascending""))
  if (equalIgnoringASCIICase(ariaSort, ""descending""))
  if (equalIgnoringASCIICase(ariaSort, ""other""))
","  if (equalIgnoringCase(ariaSort, ""none""))
  if (equalIgnoringCase(ariaSort, ""ascending""))
  if (equalIgnoringCase(ariaSort, ""descending""))
  if (equalIgnoringCase(ariaSort, ""other""))
",,"@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {
 
 bool AXTableCell::isRowHeaderCell() const {
   const AtomicString& scope = getAttribute(scopeAttr);
-  return equalIgnoringCase(scope, ""row"") ||
-         equalIgnoringCase(scope, ""rowgroup"");
+  return equalIgnoringASCIICase(scope, ""row"") ||
+         equalIgnoringASCIICase(scope, ""rowgroup"");
 }
 
 bool AXTableCell::isColumnHeaderCell() const {
   const AtomicString& scope = getAttribute(scopeAttr);
-  return equalIgnoringCase(scope, ""col"") ||
-         equalIgnoringCase(scope, ""colgroup"");
+  return equalIgnoringASCIICase(scope, ""col"") ||
+         equalIgnoringASCIICase(scope, ""colgroup"");
 }
 
 bool AXTableCell::computeAccessibilityIsIgnored(
@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);
   if (ariaSort.isEmpty())
     return SortDirectionUndefined;
-  if (equalIgnoringCase(ariaSort, ""none""))
+  if (equalIgnoringASCIICase(ariaSort, ""none""))
     return SortDirectionNone;
-  if (equalIgnoringCase(ariaSort, ""ascending""))
+  if (equalIgnoringASCIICase(ariaSort, ""ascending""))
     return SortDirectionAscending;
-  if (equalIgnoringCase(ariaSort, ""descending""))
+  if (equalIgnoringASCIICase(ariaSort, ""descending""))
     return SortDirectionDescending;
-  if (equalIgnoringCase(ariaSort, ""other""))
+  if (equalIgnoringASCIICase(ariaSort, ""other""))
     return SortDirectionOther;
   return SortDirectionUndefined;
 }",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"SortDirection AXTableCell::getSortDirection() const {
  if (roleValue() != RowHeaderRole && roleValue() != ColumnHeaderRole)
    return SortDirectionUndefined;

  const AtomicString& ariaSort =
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);
   if (ariaSort.isEmpty())
     return SortDirectionUndefined;
//flaw_line_below:
  if (equalIgnoringCase(ariaSort, ""none""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(ariaSort, ""none""))
     return SortDirectionNone;
//flaw_line_below:
  if (equalIgnoringCase(ariaSort, ""ascending""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(ariaSort, ""ascending""))
     return SortDirectionAscending;
//flaw_line_below:
  if (equalIgnoringCase(ariaSort, ""descending""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(ariaSort, ""descending""))
     return SortDirectionDescending;
//flaw_line_below:
  if (equalIgnoringCase(ariaSort, ""other""))
//fix_flaw_line_below:
//  if (equalIgnoringASCIICase(ariaSort, ""other""))
     return SortDirectionOther;
   return SortDirectionUndefined;
 }
"
8074,185810,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,2,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",2,third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}"," bool AXTableCell::isColumnHeaderCell() const {
   const AtomicString& scope = getAttribute(scopeAttr);
  return equalIgnoringASCIICase(scope, ""col"") ||
         equalIgnoringASCIICase(scope, ""colgroup"");
 }
"," bool AXTableCell::isColumnHeaderCell() const {
   const AtomicString& scope = getAttribute(scopeAttr);
  return equalIgnoringCase(scope, ""col"") ||
         equalIgnoringCase(scope, ""colgroup"");
 }
",C,"  return equalIgnoringASCIICase(scope, ""col"") ||
         equalIgnoringASCIICase(scope, ""colgroup"");
","  return equalIgnoringCase(scope, ""col"") ||
         equalIgnoringCase(scope, ""colgroup"");
",,"@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {
 
 bool AXTableCell::isRowHeaderCell() const {
   const AtomicString& scope = getAttribute(scopeAttr);
-  return equalIgnoringCase(scope, ""row"") ||
-         equalIgnoringCase(scope, ""rowgroup"");
+  return equalIgnoringASCIICase(scope, ""row"") ||
+         equalIgnoringASCIICase(scope, ""rowgroup"");
 }
 
 bool AXTableCell::isColumnHeaderCell() const {
   const AtomicString& scope = getAttribute(scopeAttr);
-  return equalIgnoringCase(scope, ""col"") ||
-         equalIgnoringCase(scope, ""colgroup"");
+  return equalIgnoringASCIICase(scope, ""col"") ||
+         equalIgnoringASCIICase(scope, ""colgroup"");
 }
 
 bool AXTableCell::computeAccessibilityIsIgnored(
@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);
   if (ariaSort.isEmpty())
     return SortDirectionUndefined;
-  if (equalIgnoringCase(ariaSort, ""none""))
+  if (equalIgnoringASCIICase(ariaSort, ""none""))
     return SortDirectionNone;
-  if (equalIgnoringCase(ariaSort, ""ascending""))
+  if (equalIgnoringASCIICase(ariaSort, ""ascending""))
     return SortDirectionAscending;
-  if (equalIgnoringCase(ariaSort, ""descending""))
+  if (equalIgnoringASCIICase(ariaSort, ""descending""))
     return SortDirectionDescending;
-  if (equalIgnoringCase(ariaSort, ""other""))
+  if (equalIgnoringASCIICase(ariaSort, ""other""))
     return SortDirectionOther;
   return SortDirectionUndefined;
 }",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1," bool AXTableCell::isColumnHeaderCell() const {
   const AtomicString& scope = getAttribute(scopeAttr);
//flaw_line_below:
  return equalIgnoringCase(scope, ""col"") ||
//flaw_line_below:
         equalIgnoringCase(scope, ""colgroup"");
//fix_flaw_line_below:
//  return equalIgnoringASCIICase(scope, ""col"") ||
//fix_flaw_line_below:
//         equalIgnoringASCIICase(scope, ""colgroup"");
 }
"
8075,185811,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,2,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",2,third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}"," bool AXTableCell::isRowHeaderCell() const {
   const AtomicString& scope = getAttribute(scopeAttr);
  return equalIgnoringASCIICase(scope, ""row"") ||
         equalIgnoringASCIICase(scope, ""rowgroup"");
 }
"," bool AXTableCell::isRowHeaderCell() const {
   const AtomicString& scope = getAttribute(scopeAttr);
  return equalIgnoringCase(scope, ""row"") ||
         equalIgnoringCase(scope, ""rowgroup"");
 }
",C,"  return equalIgnoringASCIICase(scope, ""row"") ||
         equalIgnoringASCIICase(scope, ""rowgroup"");
","  return equalIgnoringCase(scope, ""row"") ||
         equalIgnoringCase(scope, ""rowgroup"");
",,"@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {
 
 bool AXTableCell::isRowHeaderCell() const {
   const AtomicString& scope = getAttribute(scopeAttr);
-  return equalIgnoringCase(scope, ""row"") ||
-         equalIgnoringCase(scope, ""rowgroup"");
+  return equalIgnoringASCIICase(scope, ""row"") ||
+         equalIgnoringASCIICase(scope, ""rowgroup"");
 }
 
 bool AXTableCell::isColumnHeaderCell() const {
   const AtomicString& scope = getAttribute(scopeAttr);
-  return equalIgnoringCase(scope, ""col"") ||
-         equalIgnoringCase(scope, ""colgroup"");
+  return equalIgnoringASCIICase(scope, ""col"") ||
+         equalIgnoringASCIICase(scope, ""colgroup"");
 }
 
 bool AXTableCell::computeAccessibilityIsIgnored(
@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {
       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);
   if (ariaSort.isEmpty())
     return SortDirectionUndefined;
-  if (equalIgnoringCase(ariaSort, ""none""))
+  if (equalIgnoringASCIICase(ariaSort, ""none""))
     return SortDirectionNone;
-  if (equalIgnoringCase(ariaSort, ""ascending""))
+  if (equalIgnoringASCIICase(ariaSort, ""ascending""))
     return SortDirectionAscending;
-  if (equalIgnoringCase(ariaSort, ""descending""))
+  if (equalIgnoringASCIICase(ariaSort, ""descending""))
     return SortDirectionDescending;
-  if (equalIgnoringCase(ariaSort, ""other""))
+  if (equalIgnoringASCIICase(ariaSort, ""other""))
     return SortDirectionOther;
   return SortDirectionUndefined;
 }",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1," bool AXTableCell::isRowHeaderCell() const {
   const AtomicString& scope = getAttribute(scopeAttr);
//flaw_line_below:
  return equalIgnoringCase(scope, ""row"") ||
//flaw_line_below:
         equalIgnoringCase(scope, ""rowgroup"");
//fix_flaw_line_below:
//  return equalIgnoringASCIICase(scope, ""row"") ||
//fix_flaw_line_below:
//         equalIgnoringASCIICase(scope, ""rowgroup"");
 }
"
8076,185812,,Remote,Not required,Partial,CVE-2015-1274,https://www.cvedetails.com/cve/CVE-2015-1274/,CWE-254,Medium,Partial,Partial,,2015-07-22,6.8,"Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc.",2018-10-30,Exec Code ,1,https://github.com/chromium/chromium/commit/d27468a832d5316884bd02f459cbf493697fd7e1,d27468a832d5316884bd02f459cbf493697fd7e1,"Switch to equalIgnoringASCIICase throughout modules/accessibility

BUG=627682

Review-Url: https://codereview.chromium.org/2793913007
Cr-Commit-Position: refs/heads/master@{#461858}",1,third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp,"{""sha"": ""b7b9d3ad4a5cdff0f72bf31370c16bddf7da6615"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXARIAGridCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -47,12 +47,12 @@ AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n \n bool AXARIAGridCell::isAriaColumnHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""columnheader\"");\n+  return equalIgnoringASCIICase(role, \""columnheader\"");\n }\n \n bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n-  return equalIgnoringCase(role, \""rowheader\"");\n+  return equalIgnoringASCIICase(role, \""rowheader\"");\n }\n \n AXObject* AXARIAGridCell::parentTable() const {""}<_**next**_>{""sha"": ""5b27c4762de74bb75c79991c9efd0c2889582e7a"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXLayoutObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -459,7 +459,7 @@ bool AXLayoutObject::isSelected() const {\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n-  if (equalIgnoringCase(ariaSelected, \""true\""))\n+  if (equalIgnoringASCIICase(ariaSelected, \""true\""))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n@@ -492,7 +492,7 @@ AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n     // aria-hidden is meant to override visibility as the determinant in AX\n     // hierarchy inclusion.\n-    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n@@ -1296,8 +1296,8 @@ AXObject* AXLayoutObject::ancestorForWhichThisIsAPresentationalChild() const {\n \n bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n-  return equalIgnoringCase(grabbed, \""true\"") ||\n-         equalIgnoringCase(grabbed, \""false\"");\n+  return equalIgnoringASCIICase(grabbed, \""true\"") ||\n+         equalIgnoringASCIICase(grabbed, \""false\"");\n }\n \n bool AXLayoutObject::supportsARIADropping() const {\n@@ -2500,7 +2500,7 @@ bool AXLayoutObject::elementAttributeValue(\n   if (!m_layoutObject)\n     return false;\n \n-  return equalIgnoringCase(getAttribute(attributeName), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(attributeName), \""true\"");\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""c4ba92f543cc10e21aa2d00a7da7f842fe57c457"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXListBoxOption.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -82,7 +82,7 @@ bool AXListBoxOption::isEnabled() const {\n   if (!getNode())\n     return false;\n \n-  if (equalIgnoringCase(getAttribute(aria_disabledAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_disabledAttr), \""true\""))\n     return false;\n \n   if (toElement(getNode())->hasAttribute(disabledAttr))""}<_**next**_>{""sha"": ""26298b2f98b7badcdcd664b7aff30e60428daf91"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 30, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXNodeObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -96,7 +96,7 @@ class BoolAttributeSetter : public SparseAttributeSetter {\n            AXSparseAttributeClient& attributeMap,\n            const AtomicString& value) override {\n     attributeMap.addBoolAttribute(m_attribute,\n-                                  equalIgnoringCase(value, \""true\""));\n+                                  equalIgnoringASCIICase(value, \""true\""));\n   }\n };\n \n@@ -300,7 +300,7 @@ bool AXNodeObject::computeAccessibilityIsIgnored(\n   Element* element = getNode()->isElementNode() ? toElement(getNode())\n                                                 : getNode()->parentElement();\n   if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&\n-      !equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\"")) {\n+      !equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\"")) {\n     if (ignoredReasons)\n       ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n     return true;\n@@ -750,7 +750,7 @@ bool AXNodeObject::hasContentEditableAttributeSet() const {\n     return false;\n   // Both \""true\"" (case-insensitive) and the empty string count as true.\n   return contentEditableValue.isEmpty() ||\n-         equalIgnoringCase(contentEditableValue, \""true\"");\n+         equalIgnoringASCIICase(contentEditableValue, \""true\"");\n }\n \n bool AXNodeObject::isTextControl() const {\n@@ -825,7 +825,7 @@ static Element* siblingWithAriaRole(String role, Node* node) {\n        sibling = ElementTraversal::nextSibling(*sibling)) {\n     const AtomicString& siblingAriaRole =\n         AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);\n-    if (equalIgnoringCase(siblingAriaRole, role))\n+    if (equalIgnoringASCIICase(siblingAriaRole, role))\n       return sibling;\n   }\n \n@@ -1044,9 +1044,9 @@ bool AXNodeObject::isMeter() const {\n bool AXNodeObject::isMultiSelectable() const {\n   const AtomicString& ariaMultiSelectable =\n       getAttribute(aria_multiselectableAttr);\n-  if (equalIgnoringCase(ariaMultiSelectable, \""true\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""true\""))\n     return true;\n-  if (equalIgnoringCase(ariaMultiSelectable, \""false\""))\n+  if (equalIgnoringASCIICase(ariaMultiSelectable, \""false\""))\n     return false;\n \n   return isHTMLSelectElement(getNode()) &&\n@@ -1159,7 +1159,7 @@ bool AXNodeObject::isChecked() const {\n     case MenuItemRadioRole:\n     case RadioButtonRole:\n     case SwitchRole:\n-      if (equalIgnoringCase(\n+      if (equalIgnoringASCIICase(\n               getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),\n               \""true\""))\n         return true;\n@@ -1211,9 +1211,9 @@ AccessibilityExpanded AXNodeObject::isExpanded() const {\n   }\n \n   const AtomicString& expanded = getAttribute(aria_expandedAttr);\n-  if (equalIgnoringCase(expanded, \""true\""))\n+  if (equalIgnoringASCIICase(expanded, \""true\""))\n     return ExpandedExpanded;\n-  if (equalIgnoringCase(expanded, \""false\""))\n+  if (equalIgnoringASCIICase(expanded, \""false\""))\n     return ExpandedCollapsed;\n \n   return ExpandedUndefined;\n@@ -1225,9 +1225,9 @@ bool AXNodeObject::isModal() const {\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n-    if (equalIgnoringCase(modal, \""true\""))\n+    if (equalIgnoringASCIICase(modal, \""true\""))\n       return true;\n-    if (equalIgnoringCase(modal, \""false\""))\n+    if (equalIgnoringASCIICase(modal, \""false\""))\n       return false;\n   }\n \n@@ -1248,8 +1248,8 @@ bool AXNodeObject::isPressed() const {\n   // ARIA button with aria-pressed not undefined, then check for aria-pressed\n   // attribute rather than getNode()->active()\n   if (ariaRoleAttribute() == ToggleButtonRole) {\n-    if (equalIgnoringCase(getAttribute(aria_pressedAttr), \""true\"") ||\n-        equalIgnoringCase(getAttribute(aria_pressedAttr), \""mixed\""))\n+    if (equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""true\"") ||\n+        equalIgnoringASCIICase(getAttribute(aria_pressedAttr), \""mixed\""))\n       return true;\n     return false;\n   }\n@@ -1280,7 +1280,7 @@ bool AXNodeObject::isRequired() const {\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n-  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_requiredAttr), \""true\""))\n     return true;\n \n   return false;\n@@ -1310,7 +1310,7 @@ bool AXNodeObject::canSetFocusAttribute() const {\n }\n \n bool AXNodeObject::canSetValueAttribute() const {\n-  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), \""true\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_readonlyAttr), \""true\""))\n     return false;\n \n   if (isProgressIndicator() || isSlider())\n@@ -1488,9 +1488,9 @@ AccessibilityOrientation AXNodeObject::orientation() const {\n   const AtomicString& ariaOrientation =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);\n   AccessibilityOrientation orientation = AccessibilityOrientationUndefined;\n-  if (equalIgnoringCase(ariaOrientation, \""horizontal\""))\n+  if (equalIgnoringASCIICase(ariaOrientation, \""horizontal\""))\n     orientation = AccessibilityOrientationHorizontal;\n-  else if (equalIgnoringCase(ariaOrientation, \""vertical\""))\n+  else if (equalIgnoringASCIICase(ariaOrientation, \""vertical\""))\n     orientation = AccessibilityOrientationVertical;\n \n   switch (roleValue()) {\n@@ -1621,7 +1621,7 @@ RGBA32 AXNodeObject::colorValue() const {\n \n   HTMLInputElement* input = toHTMLInputElement(getNode());\n   const AtomicString& type = input->getAttribute(typeAttr);\n-  if (!equalIgnoringCase(type, \""color\""))\n+  if (!equalIgnoringASCIICase(type, \""color\""))\n     return AXObject::colorValue();\n \n   // HTMLInputElement::value always returns a string parseable by Color.\n@@ -1636,19 +1636,20 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);\n   if (attributeValue.isNull())\n     return AriaCurrentStateUndefined;\n-  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, \""false\""))\n+  if (attributeValue.isEmpty() ||\n+      equalIgnoringASCIICase(attributeValue, \""false\""))\n     return AriaCurrentStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return AriaCurrentStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""page\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""page\""))\n     return AriaCurrentStatePage;\n-  if (equalIgnoringCase(attributeValue, \""step\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""step\""))\n     return AriaCurrentStateStep;\n-  if (equalIgnoringCase(attributeValue, \""location\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""location\""))\n     return AriaCurrentStateLocation;\n-  if (equalIgnoringCase(attributeValue, \""date\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""date\""))\n     return AriaCurrentStateDate;\n-  if (equalIgnoringCase(attributeValue, \""time\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""time\""))\n     return AriaCurrentStateTime;\n   // An unknown value should return true.\n   if (!attributeValue.isEmpty())\n@@ -1660,13 +1661,13 @@ AriaCurrentState AXNodeObject::ariaCurrentState() const {\n InvalidState AXNodeObject::getInvalidState() const {\n   const AtomicString& attributeValue =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);\n-  if (equalIgnoringCase(attributeValue, \""false\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""false\""))\n     return InvalidStateFalse;\n-  if (equalIgnoringCase(attributeValue, \""true\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""true\""))\n     return InvalidStateTrue;\n-  if (equalIgnoringCase(attributeValue, \""spelling\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""spelling\""))\n     return InvalidStateSpelling;\n-  if (equalIgnoringCase(attributeValue, \""grammar\""))\n+  if (equalIgnoringASCIICase(attributeValue, \""grammar\""))\n     return InvalidStateGrammar;\n   // A yet unknown value.\n   if (!attributeValue.isEmpty())\n@@ -1996,7 +1997,7 @@ String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n     // true if any ancestor is hidden, but we need to be able to compute the\n     // accessible name of object inside hidden subtrees (for example, if\n     // aria-labelledby points to an object that's hidden).\n-    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(child->getAttribute(aria_hiddenAttr), \""true\""))\n       continue;\n \n     // If we're going between two layoutObjects that are in separate""}<_**next**_>{""sha"": ""3e18e556d466beaf250314eaee1346ca0c2f1955"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObject.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -596,7 +596,7 @@ AXObject* AXObject::leafNodeAncestor() const {\n \n const AXObject* AXObject::ariaHiddenRoot() const {\n   for (const AXObject* object = this; object; object = object->parentObject()) {\n-    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), \""true\""))\n+    if (equalIgnoringASCIICase(object->getAttribute(aria_hiddenAttr), \""true\""))\n       return object;\n   }\n \n@@ -610,9 +610,9 @@ bool AXObject::isDescendantOfDisabledNode() const {\n \n const AXObject* AXObject::disabledAncestor() const {\n   const AtomicString& disabled = getAttribute(aria_disabledAttr);\n-  if (equalIgnoringCase(disabled, \""true\""))\n+  if (equalIgnoringASCIICase(disabled, \""true\""))\n     return this;\n-  if (equalIgnoringCase(disabled, \""false\""))\n+  if (equalIgnoringASCIICase(disabled, \""false\""))\n     return 0;\n \n   if (AXObject* parent = parentObject())\n@@ -723,7 +723,7 @@ String AXObject::recursiveTextAlternative(const AXObject& axObj,\n }\n \n bool AXObject::isHiddenForTextAlternativeCalculation() const {\n-  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \""false\""))\n+  if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \""false\""))\n     return false;\n \n   if (getLayoutObject())\n@@ -955,10 +955,10 @@ AXSupportedAction AXObject::action() const {\n AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n-  if (equalIgnoringCase(checkedAttribute, \""true\""))\n+  if (equalIgnoringASCIICase(checkedAttribute, \""true\""))\n     return ButtonStateOn;\n \n-  if (equalIgnoringCase(checkedAttribute, \""mixed\"")) {\n+  if (equalIgnoringASCIICase(checkedAttribute, \""mixed\"")) {\n     // Only checkboxes should support the mixed state.\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n@@ -982,7 +982,7 @@ bool AXObject::isMultiline() const {\n   if (!isNativeTextControl() && !isNonNativeTextControl())\n     return false;\n \n-  return equalIgnoringCase(getAttribute(aria_multilineAttr), \""true\"");\n+  return equalIgnoringASCIICase(getAttribute(aria_multilineAttr), \""true\"");\n }\n \n bool AXObject::ariaPressedIsPresent() const {\n@@ -1063,8 +1063,8 @@ int AXObject::indexInParent() const {\n \n bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n-  return equalIgnoringCase(liveRegion, \""polite\"") ||\n-         equalIgnoringCase(liveRegion, \""assertive\"");\n+  return equalIgnoringASCIICase(liveRegion, \""polite\"") ||\n+         equalIgnoringASCIICase(liveRegion, \""assertive\"");\n }\n \n AXObject* AXObject::liveRegionRoot() const {""}<_**next**_>{""sha"": ""0c17502098641388c189e5470a9e77f7a43e7779"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXObjectCacheImpl.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -262,7 +262,7 @@ bool nodeHasRole(Node* node, const String& role) {\n   if (!node || !node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(roleAttr), role);\n }\n \n AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n@@ -1090,8 +1090,8 @@ bool isNodeAriaVisible(Node* node) {\n   if (!node->isElementNode())\n     return false;\n \n-  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n-                           \""false\"");\n+  return equalIgnoringASCIICase(toElement(node)->getAttribute(aria_hiddenAttr),\n+                                \""false\"");\n }\n \n void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,""}<_**next**_>{""sha"": ""5b3ea88b5fa5cda94305bcbf0bb68c7faaff9528"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/AXTableCell.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -54,14 +54,14 @@ bool AXTableCell::isTableHeaderCell() const {\n \n bool AXTableCell::isRowHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""row\"") ||\n-         equalIgnoringCase(scope, \""rowgroup\"");\n+  return equalIgnoringASCIICase(scope, \""row\"") ||\n+         equalIgnoringASCIICase(scope, \""rowgroup\"");\n }\n \n bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n-  return equalIgnoringCase(scope, \""col\"") ||\n-         equalIgnoringCase(scope, \""colgroup\"");\n+  return equalIgnoringASCIICase(scope, \""col\"") ||\n+         equalIgnoringASCIICase(scope, \""colgroup\"");\n }\n \n bool AXTableCell::computeAccessibilityIsIgnored(\n@@ -225,13 +225,13 @@ SortDirection AXTableCell::getSortDirection() const {\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);\n   if (ariaSort.isEmpty())\n     return SortDirectionUndefined;\n-  if (equalIgnoringCase(ariaSort, \""none\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""none\""))\n     return SortDirectionNone;\n-  if (equalIgnoringCase(ariaSort, \""ascending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""ascending\""))\n     return SortDirectionAscending;\n-  if (equalIgnoringCase(ariaSort, \""descending\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""descending\""))\n     return SortDirectionDescending;\n-  if (equalIgnoringCase(ariaSort, \""other\""))\n+  if (equalIgnoringASCIICase(ariaSort, \""other\""))\n     return SortDirectionOther;\n   return SortDirectionUndefined;\n }""}<_**next**_>{""sha"": ""be670ecaaddaaeccafe8037219a26de0a5cf23d2"", ""filename"": ""third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d27468a832d5316884bd02f459cbf493697fd7e1/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/accessibility/InspectorAccessibilityAgent.cpp?ref=d27468a832d5316884bd02f459cbf493697fd7e1"", ""patch"": ""@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,\n     } else {\n       const AtomicString& pressedAttr =\n           axObject.getAttribute(HTMLNames::aria_pressedAttr);\n-      if (equalIgnoringCase(pressedAttr, \""mixed\""))\n+      if (equalIgnoringASCIICase(pressedAttr, \""mixed\""))\n         properties.addItem(\n             createProperty(AXWidgetStatesEnum::Pressed,\n                            createValue(\""mixed\"", AXValueTypeEnum::Tristate)));""}","void fillWidgetStates(AXObject& axObject,
                      protocol::Array<AXProperty>& properties) {
  AccessibilityRole role = axObject.roleValue();
  if (roleAllowsChecked(role)) {
    AccessibilityButtonState checked = axObject.checkboxOrRadioValue();
    switch (checked) {
      case ButtonStateOff:
        properties.addItem(
            createProperty(AXWidgetStatesEnum::Checked,
                           createValue(""false"", AXValueTypeEnum::Tristate)));
        break;
      case ButtonStateOn:
        properties.addItem(
            createProperty(AXWidgetStatesEnum::Checked,
                           createValue(""true"", AXValueTypeEnum::Tristate)));
        break;
      case ButtonStateMixed:
        properties.addItem(
            createProperty(AXWidgetStatesEnum::Checked,
                           createValue(""mixed"", AXValueTypeEnum::Tristate)));
        break;
    }
  }

  AccessibilityExpanded expanded = axObject.isExpanded();
  switch (expanded) {
    case ExpandedUndefined:
      break;
    case ExpandedCollapsed:
      properties.addItem(createProperty(
          AXWidgetStatesEnum::Expanded,
          createBooleanValue(false, AXValueTypeEnum::BooleanOrUndefined)));
      break;
    case ExpandedExpanded:
      properties.addItem(createProperty(
          AXWidgetStatesEnum::Expanded,
          createBooleanValue(true, AXValueTypeEnum::BooleanOrUndefined)));
      break;
  }

  if (role == ToggleButtonRole) {
    if (!axObject.isPressed()) {
      properties.addItem(
          createProperty(AXWidgetStatesEnum::Pressed,
                         createValue(""false"", AXValueTypeEnum::Tristate)));
     } else {
       const AtomicString& pressedAttr =
           axObject.getAttribute(HTMLNames::aria_pressedAttr);
      if (equalIgnoringASCIICase(pressedAttr, ""mixed""))
         properties.addItem(
             createProperty(AXWidgetStatesEnum::Pressed,
                            createValue(""mixed"", AXValueTypeEnum::Tristate)));
      else
        properties.addItem(
            createProperty(AXWidgetStatesEnum::Pressed,
                           createValue(""true"", AXValueTypeEnum::Tristate)));
    }
  }

  if (roleAllowsSelected(role)) {
    properties.addItem(
        createProperty(AXWidgetStatesEnum::Selected,
                       createBooleanValue(axObject.isSelected())));
  }

  if (roleAllowsModal(role)) {
    properties.addItem(createProperty(AXWidgetStatesEnum::Modal,
                                      createBooleanValue(axObject.isModal())));
  }
}
","void fillWidgetStates(AXObject& axObject,
                      protocol::Array<AXProperty>& properties) {
  AccessibilityRole role = axObject.roleValue();
  if (roleAllowsChecked(role)) {
    AccessibilityButtonState checked = axObject.checkboxOrRadioValue();
    switch (checked) {
      case ButtonStateOff:
        properties.addItem(
            createProperty(AXWidgetStatesEnum::Checked,
                           createValue(""false"", AXValueTypeEnum::Tristate)));
        break;
      case ButtonStateOn:
        properties.addItem(
            createProperty(AXWidgetStatesEnum::Checked,
                           createValue(""true"", AXValueTypeEnum::Tristate)));
        break;
      case ButtonStateMixed:
        properties.addItem(
            createProperty(AXWidgetStatesEnum::Checked,
                           createValue(""mixed"", AXValueTypeEnum::Tristate)));
        break;
    }
  }

  AccessibilityExpanded expanded = axObject.isExpanded();
  switch (expanded) {
    case ExpandedUndefined:
      break;
    case ExpandedCollapsed:
      properties.addItem(createProperty(
          AXWidgetStatesEnum::Expanded,
          createBooleanValue(false, AXValueTypeEnum::BooleanOrUndefined)));
      break;
    case ExpandedExpanded:
      properties.addItem(createProperty(
          AXWidgetStatesEnum::Expanded,
          createBooleanValue(true, AXValueTypeEnum::BooleanOrUndefined)));
      break;
  }

  if (role == ToggleButtonRole) {
    if (!axObject.isPressed()) {
      properties.addItem(
          createProperty(AXWidgetStatesEnum::Pressed,
                         createValue(""false"", AXValueTypeEnum::Tristate)));
     } else {
       const AtomicString& pressedAttr =
           axObject.getAttribute(HTMLNames::aria_pressedAttr);
      if (equalIgnoringCase(pressedAttr, ""mixed""))
         properties.addItem(
             createProperty(AXWidgetStatesEnum::Pressed,
                            createValue(""mixed"", AXValueTypeEnum::Tristate)));
      else
        properties.addItem(
            createProperty(AXWidgetStatesEnum::Pressed,
                           createValue(""true"", AXValueTypeEnum::Tristate)));
    }
  }

  if (roleAllowsSelected(role)) {
    properties.addItem(
        createProperty(AXWidgetStatesEnum::Selected,
                       createBooleanValue(axObject.isSelected())));
  }

  if (roleAllowsModal(role)) {
    properties.addItem(createProperty(AXWidgetStatesEnum::Modal,
                                      createBooleanValue(axObject.isModal())));
  }
}
",C,"      if (equalIgnoringASCIICase(pressedAttr, ""mixed""))
","      if (equalIgnoringCase(pressedAttr, ""mixed""))
",,"@@ -296,7 +296,7 @@ void fillWidgetStates(AXObject& axObject,
     } else {
       const AtomicString& pressedAttr =
           axObject.getAttribute(HTMLNames::aria_pressedAttr);
-      if (equalIgnoringCase(pressedAttr, ""mixed""))
+      if (equalIgnoringASCIICase(pressedAttr, ""mixed""))
         properties.addItem(
             createProperty(AXWidgetStatesEnum::Pressed,
                            createValue(""mixed"", AXValueTypeEnum::Tristate)));",Chrome,d27468a832d5316884bd02f459cbf493697fd7e1,62dc793dc640ae5fd16d571a0c9199fe0fb740d0,1,"void fillWidgetStates(AXObject& axObject,
                      protocol::Array<AXProperty>& properties) {
  AccessibilityRole role = axObject.roleValue();
  if (roleAllowsChecked(role)) {
    AccessibilityButtonState checked = axObject.checkboxOrRadioValue();
    switch (checked) {
      case ButtonStateOff:
        properties.addItem(
            createProperty(AXWidgetStatesEnum::Checked,
                           createValue(""false"", AXValueTypeEnum::Tristate)));
        break;
      case ButtonStateOn:
        properties.addItem(
            createProperty(AXWidgetStatesEnum::Checked,
                           createValue(""true"", AXValueTypeEnum::Tristate)));
        break;
      case ButtonStateMixed:
        properties.addItem(
            createProperty(AXWidgetStatesEnum::Checked,
                           createValue(""mixed"", AXValueTypeEnum::Tristate)));
        break;
    }
  }

  AccessibilityExpanded expanded = axObject.isExpanded();
  switch (expanded) {
    case ExpandedUndefined:
      break;
    case ExpandedCollapsed:
      properties.addItem(createProperty(
          AXWidgetStatesEnum::Expanded,
          createBooleanValue(false, AXValueTypeEnum::BooleanOrUndefined)));
      break;
    case ExpandedExpanded:
      properties.addItem(createProperty(
          AXWidgetStatesEnum::Expanded,
          createBooleanValue(true, AXValueTypeEnum::BooleanOrUndefined)));
      break;
  }

  if (role == ToggleButtonRole) {
    if (!axObject.isPressed()) {
      properties.addItem(
          createProperty(AXWidgetStatesEnum::Pressed,
                         createValue(""false"", AXValueTypeEnum::Tristate)));
     } else {
       const AtomicString& pressedAttr =
           axObject.getAttribute(HTMLNames::aria_pressedAttr);
//flaw_line_below:
      if (equalIgnoringCase(pressedAttr, ""mixed""))
//fix_flaw_line_below:
//      if (equalIgnoringASCIICase(pressedAttr, ""mixed""))
         properties.addItem(
             createProperty(AXWidgetStatesEnum::Pressed,
                            createValue(""mixed"", AXValueTypeEnum::Tristate)));
      else
        properties.addItem(
            createProperty(AXWidgetStatesEnum::Pressed,
                           createValue(""true"", AXValueTypeEnum::Tristate)));
    }
  }

  if (roleAllowsSelected(role)) {
    properties.addItem(
        createProperty(AXWidgetStatesEnum::Selected,
                       createBooleanValue(axObject.isSelected())));
  }

  if (roleAllowsModal(role)) {
    properties.addItem(createProperty(AXWidgetStatesEnum::Modal,
                                      createBooleanValue(axObject.isModal())));
  }
}
"
8085,185821,,Remote,Not required,,CVE-2015-1281,https://www.cvedetails.com/cve/CVE-2015-1281/,CWE-254,Medium,,Partial,,2015-07-22,4.3,"core/loader/ImageLoader.cpp in Blink, as used in Google Chrome before 44.0.2403.89, does not properly determine the V8 context of a microtask, which allows remote attackers to bypass Content Security Policy (CSP) restrictions by providing an image from an unintended source.",2018-10-30,Bypass ,1,https://github.com/chromium/chromium/commit/dff368031150a1033a1a3c913f8857679a0279be,dff368031150a1033a1a3c913f8857679a0279be,"Correctly keep track of isolates for microtask execution

BUG=487155
R=haraken@chromium.org

Review URL: https://codereview.chromium.org/1161823002

git-svn-id: svn://svn.chromium.org/blink/trunk@195985 bbb929c8-8fbe-4397-9dbb-9b2b20218538",1,third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp,"{""sha"": ""682fe9d2e06243e0b879e943e0138d344db742e6"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -37,7 +37,7 @@ namespace blink {\n \n void V8RecursionScope::didLeaveScriptContext()\n {\n-    Microtask::performCheckpoint();\n+    Microtask::performCheckpoint(m_isolate);\n     V8PerIsolateData::from(m_isolate)->runEndOfScopeTasks();\n }\n ""}<_**next**_>{""sha"": ""d85fa40c092391c457b3c51c2864d547ea6f4d7e"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Document.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Document.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -36,6 +36,7 @@\n #include \""bindings/core/v8/ScriptController.h\""\n #include \""bindings/core/v8/UnionTypesCore.h\""\n #include \""bindings/core/v8/V8DOMWrapper.h\""\n+#include \""bindings/core/v8/V8PerIsolateData.h\""\n #include \""bindings/core/v8/WindowProxy.h\""\n #include \""core/HTMLElementFactory.h\""\n #include \""core/HTMLNames.h\""\n@@ -4515,7 +4516,7 @@ void Document::finishedParsing()\n     // Ensure Custom Element callbacks are drained before DOMContentLoaded.\n     // FIXME: Remove this ad-hoc checkpoint when DOMContentLoaded is dispatched in a\n     // queued task, which will do a checkpoint anyway. https://crbug.com/425790\n-    Microtask::performCheckpoint();\n+    Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());\n \n     if (RefPtrWillBeRawPtr<LocalFrame> frame = this->frame()) {\n         // Don't update the layout tree if we haven't requested the main resource yet to avoid""}<_**next**_>{""sha"": ""833bccb8714d5c9146e7190a6b95396e89b5a0bf"", ""filename"": ""third_party/WebKit/Source/core/dom/Microtask.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Microtask.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -40,9 +40,8 @@\n \n namespace blink {\n \n-void Microtask::performCheckpoint()\n+void Microtask::performCheckpoint(v8::Isolate* isolate)\n {\n-    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n     V8PerIsolateData* isolateData = V8PerIsolateData::from(isolate);\n     ASSERT(isolateData);\n     if (isolateData->recursionLevel() || isolateData->performingMicrotaskCheckpoint() || isolateData->destructionPending() || ScriptForbiddenScope::isScriptForbidden())""}<_**next**_>{""sha"": ""e111c03da1dac1d1b06913a2c62c37b97c434e99"", ""filename"": ""third_party/WebKit/Source/core/dom/Microtask.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Microtask.h?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -31,6 +31,7 @@\n #ifndef Microtask_h\n #define Microtask_h\n \n+#include \""bindings/core/v8/ScriptState.h\""\n #include \""core/CoreExport.h\""\n #include \""public/platform/WebThread.h\""\n #include \""wtf/Functional.h\""\n@@ -41,7 +42,7 @@ namespace blink {\n \n class CORE_EXPORT Microtask {\n public:\n-    static void performCheckpoint();\n+    static void performCheckpoint(v8::Isolate*);\n     static bool performingCheckpoint(v8::Isolate*);\n \n     // TODO(jochen): Make all microtasks pass in the ScriptState they want to be""}<_**next**_>{""sha"": ""c0570e2e44c72829e06c338390b3dcf03c0309da"", ""filename"": ""third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -27,6 +27,7 @@\n #include \""core/html/parser/HTMLScriptRunner.h\""\n \n #include \""bindings/core/v8/ScriptSourceCode.h\""\n+#include \""bindings/core/v8/V8PerIsolateData.h\""\n #include \""core/dom/Element.h\""\n #include \""core/events/Event.h\""\n #include \""core/dom/IgnoreDestructiveWriteCountIncrementer.h\""\n@@ -133,7 +134,7 @@ void HTMLScriptRunner::executePendingScriptAndDispatchEvent(PendingScript& pendi\n     pendingScript.stopWatchingForLoad(this);\n \n     if (!isExecutingScript()) {\n-        Microtask::performCheckpoint();\n+        Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());\n         if (pendingScriptType == PendingScript::ParsingBlocking) {\n             m_hasScriptsWaitingForResources = !m_document->isScriptExecutionReady();\n             // The parser cannot be unblocked as a microtask requested another resource\n@@ -337,7 +338,7 @@ void HTMLScriptRunner::runScript(Element* script, const TextPosition& scriptStar\n         ASSERT(scriptLoader->isParserInserted());\n \n         if (!isExecutingScript())\n-            Microtask::performCheckpoint();\n+            Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());\n \n         InsertionPointRecord insertionPointRecord(m_host->inputStream());\n         NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);""}<_**next**_>{""sha"": ""883944ff2e4caeac2a8c5b0f951d687984b8da7e"", ""filename"": ""third_party/WebKit/Source/core/workers/WorkerThread.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/workers/WorkerThread.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/workers/WorkerThread.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/workers/WorkerThread.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -76,7 +76,7 @@ class WorkerMicrotaskRunner : public WebThread::TaskObserver {\n \n     virtual void didProcessTask() override\n     {\n-        Microtask::performCheckpoint();\n+        Microtask::performCheckpoint(m_workerThread->isolate());\n         if (WorkerGlobalScope* globalScope = m_workerThread->workerGlobalScope()) {\n             if (WorkerScriptController* scriptController = globalScope->script())\n                 scriptController->rejectedPromises()->processQueue();""}<_**next**_>{""sha"": ""6b1bc9394ebc90a076029c3235be48e270bc17f0"", ""filename"": ""third_party/WebKit/Source/web/WebKit.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/web/WebKit.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/web/WebKit.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/WebKit.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -76,7 +76,7 @@ class EndOfTaskRunner : public WebThread::TaskObserver {\n     }\n     virtual void didProcessTask() override\n     {\n-        Microtask::performCheckpoint();\n+        Microtask::performCheckpoint(mainThreadIsolate());\n         V8GCController::reportDOMMemoryUsageToV8(mainThreadIsolate());\n         V8Initializer::reportRejectedPromisesOnMainThread();\n     }""}"," void V8RecursionScope::didLeaveScriptContext()
 {
    Microtask::performCheckpoint(m_isolate);
     V8PerIsolateData::from(m_isolate)->runEndOfScopeTasks();
 }
"," void V8RecursionScope::didLeaveScriptContext()
 {
    Microtask::performCheckpoint();
     V8PerIsolateData::from(m_isolate)->runEndOfScopeTasks();
 }
",C,"    Microtask::performCheckpoint(m_isolate);
","    Microtask::performCheckpoint();
",,"@@ -37,7 +37,7 @@ namespace blink {
 
 void V8RecursionScope::didLeaveScriptContext()
 {
-    Microtask::performCheckpoint();
+    Microtask::performCheckpoint(m_isolate);
     V8PerIsolateData::from(m_isolate)->runEndOfScopeTasks();
 }
 ",Chrome,dff368031150a1033a1a3c913f8857679a0279be,e073acb8522a8f7fb8af7d2ee4c34f39a7d45a12,1," void V8RecursionScope::didLeaveScriptContext()
 {
//flaw_line_below:
    Microtask::performCheckpoint();
//fix_flaw_line_below:
//    Microtask::performCheckpoint(m_isolate);
     V8PerIsolateData::from(m_isolate)->runEndOfScopeTasks();
 }
"
8086,185822,,Remote,Not required,,CVE-2015-1281,https://www.cvedetails.com/cve/CVE-2015-1281/,CWE-254,Medium,,Partial,,2015-07-22,4.3,"core/loader/ImageLoader.cpp in Blink, as used in Google Chrome before 44.0.2403.89, does not properly determine the V8 context of a microtask, which allows remote attackers to bypass Content Security Policy (CSP) restrictions by providing an image from an unintended source.",2018-10-30,Bypass ,1,https://github.com/chromium/chromium/commit/dff368031150a1033a1a3c913f8857679a0279be,dff368031150a1033a1a3c913f8857679a0279be,"Correctly keep track of isolates for microtask execution

BUG=487155
R=haraken@chromium.org

Review URL: https://codereview.chromium.org/1161823002

git-svn-id: svn://svn.chromium.org/blink/trunk@195985 bbb929c8-8fbe-4397-9dbb-9b2b20218538",1,third_party/WebKit/Source/core/dom/Document.cpp,"{""sha"": ""682fe9d2e06243e0b879e943e0138d344db742e6"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -37,7 +37,7 @@ namespace blink {\n \n void V8RecursionScope::didLeaveScriptContext()\n {\n-    Microtask::performCheckpoint();\n+    Microtask::performCheckpoint(m_isolate);\n     V8PerIsolateData::from(m_isolate)->runEndOfScopeTasks();\n }\n ""}<_**next**_>{""sha"": ""d85fa40c092391c457b3c51c2864d547ea6f4d7e"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Document.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Document.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -36,6 +36,7 @@\n #include \""bindings/core/v8/ScriptController.h\""\n #include \""bindings/core/v8/UnionTypesCore.h\""\n #include \""bindings/core/v8/V8DOMWrapper.h\""\n+#include \""bindings/core/v8/V8PerIsolateData.h\""\n #include \""bindings/core/v8/WindowProxy.h\""\n #include \""core/HTMLElementFactory.h\""\n #include \""core/HTMLNames.h\""\n@@ -4515,7 +4516,7 @@ void Document::finishedParsing()\n     // Ensure Custom Element callbacks are drained before DOMContentLoaded.\n     // FIXME: Remove this ad-hoc checkpoint when DOMContentLoaded is dispatched in a\n     // queued task, which will do a checkpoint anyway. https://crbug.com/425790\n-    Microtask::performCheckpoint();\n+    Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());\n \n     if (RefPtrWillBeRawPtr<LocalFrame> frame = this->frame()) {\n         // Don't update the layout tree if we haven't requested the main resource yet to avoid""}<_**next**_>{""sha"": ""833bccb8714d5c9146e7190a6b95396e89b5a0bf"", ""filename"": ""third_party/WebKit/Source/core/dom/Microtask.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Microtask.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -40,9 +40,8 @@\n \n namespace blink {\n \n-void Microtask::performCheckpoint()\n+void Microtask::performCheckpoint(v8::Isolate* isolate)\n {\n-    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n     V8PerIsolateData* isolateData = V8PerIsolateData::from(isolate);\n     ASSERT(isolateData);\n     if (isolateData->recursionLevel() || isolateData->performingMicrotaskCheckpoint() || isolateData->destructionPending() || ScriptForbiddenScope::isScriptForbidden())""}<_**next**_>{""sha"": ""e111c03da1dac1d1b06913a2c62c37b97c434e99"", ""filename"": ""third_party/WebKit/Source/core/dom/Microtask.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Microtask.h?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -31,6 +31,7 @@\n #ifndef Microtask_h\n #define Microtask_h\n \n+#include \""bindings/core/v8/ScriptState.h\""\n #include \""core/CoreExport.h\""\n #include \""public/platform/WebThread.h\""\n #include \""wtf/Functional.h\""\n@@ -41,7 +42,7 @@ namespace blink {\n \n class CORE_EXPORT Microtask {\n public:\n-    static void performCheckpoint();\n+    static void performCheckpoint(v8::Isolate*);\n     static bool performingCheckpoint(v8::Isolate*);\n \n     // TODO(jochen): Make all microtasks pass in the ScriptState they want to be""}<_**next**_>{""sha"": ""c0570e2e44c72829e06c338390b3dcf03c0309da"", ""filename"": ""third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -27,6 +27,7 @@\n #include \""core/html/parser/HTMLScriptRunner.h\""\n \n #include \""bindings/core/v8/ScriptSourceCode.h\""\n+#include \""bindings/core/v8/V8PerIsolateData.h\""\n #include \""core/dom/Element.h\""\n #include \""core/events/Event.h\""\n #include \""core/dom/IgnoreDestructiveWriteCountIncrementer.h\""\n@@ -133,7 +134,7 @@ void HTMLScriptRunner::executePendingScriptAndDispatchEvent(PendingScript& pendi\n     pendingScript.stopWatchingForLoad(this);\n \n     if (!isExecutingScript()) {\n-        Microtask::performCheckpoint();\n+        Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());\n         if (pendingScriptType == PendingScript::ParsingBlocking) {\n             m_hasScriptsWaitingForResources = !m_document->isScriptExecutionReady();\n             // The parser cannot be unblocked as a microtask requested another resource\n@@ -337,7 +338,7 @@ void HTMLScriptRunner::runScript(Element* script, const TextPosition& scriptStar\n         ASSERT(scriptLoader->isParserInserted());\n \n         if (!isExecutingScript())\n-            Microtask::performCheckpoint();\n+            Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());\n \n         InsertionPointRecord insertionPointRecord(m_host->inputStream());\n         NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);""}<_**next**_>{""sha"": ""883944ff2e4caeac2a8c5b0f951d687984b8da7e"", ""filename"": ""third_party/WebKit/Source/core/workers/WorkerThread.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/workers/WorkerThread.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/workers/WorkerThread.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/workers/WorkerThread.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -76,7 +76,7 @@ class WorkerMicrotaskRunner : public WebThread::TaskObserver {\n \n     virtual void didProcessTask() override\n     {\n-        Microtask::performCheckpoint();\n+        Microtask::performCheckpoint(m_workerThread->isolate());\n         if (WorkerGlobalScope* globalScope = m_workerThread->workerGlobalScope()) {\n             if (WorkerScriptController* scriptController = globalScope->script())\n                 scriptController->rejectedPromises()->processQueue();""}<_**next**_>{""sha"": ""6b1bc9394ebc90a076029c3235be48e270bc17f0"", ""filename"": ""third_party/WebKit/Source/web/WebKit.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/web/WebKit.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/web/WebKit.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/WebKit.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -76,7 +76,7 @@ class EndOfTaskRunner : public WebThread::TaskObserver {\n     }\n     virtual void didProcessTask() override\n     {\n-        Microtask::performCheckpoint();\n+        Microtask::performCheckpoint(mainThreadIsolate());\n         V8GCController::reportDOMMemoryUsageToV8(mainThreadIsolate());\n         V8Initializer::reportRejectedPromisesOnMainThread();\n     }""}","void Document::finishedParsing()
{
    ASSERT(!scriptableDocumentParser() || !m_parser->isParsing());
    ASSERT(!scriptableDocumentParser() || m_readyState != Loading);
    setParsingState(InDOMContentLoaded);

    if (!m_documentTiming.domContentLoadedEventStart())
        m_documentTiming.setDomContentLoadedEventStart(monotonicallyIncreasingTime());
    dispatchEvent(Event::createBubble(EventTypeNames::DOMContentLoaded));
    if (!m_documentTiming.domContentLoadedEventEnd())
        m_documentTiming.setDomContentLoadedEventEnd(monotonicallyIncreasingTime());
    setParsingState(FinishedParsing);

    RefPtrWillBeRawPtr<Document> protect(this);

    Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());
 
     if (RefPtrWillBeRawPtr<LocalFrame> frame = this->frame()) {
        const bool mainResourceWasAlreadyRequested = frame->loader().stateMachine()->committedFirstRealDocumentLoad();

        if (mainResourceWasAlreadyRequested)
            updateLayoutTreeIfNeeded();

        frame->loader().finishedParsing();

        TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""MarkDOMContent"", TRACE_EVENT_SCOPE_THREAD, ""data"", InspectorMarkLoadEvent::data(frame.get()));
        InspectorInstrumentation::domContentLoadedEventFired(frame.get());
    }

    m_elementDataCacheClearTimer.startOneShot(10, FROM_HERE);

    m_fetcher->clearPreloads();
}
","void Document::finishedParsing()
{
    ASSERT(!scriptableDocumentParser() || !m_parser->isParsing());
    ASSERT(!scriptableDocumentParser() || m_readyState != Loading);
    setParsingState(InDOMContentLoaded);

    if (!m_documentTiming.domContentLoadedEventStart())
        m_documentTiming.setDomContentLoadedEventStart(monotonicallyIncreasingTime());
    dispatchEvent(Event::createBubble(EventTypeNames::DOMContentLoaded));
    if (!m_documentTiming.domContentLoadedEventEnd())
        m_documentTiming.setDomContentLoadedEventEnd(monotonicallyIncreasingTime());
    setParsingState(FinishedParsing);

    RefPtrWillBeRawPtr<Document> protect(this);

    Microtask::performCheckpoint();
 
     if (RefPtrWillBeRawPtr<LocalFrame> frame = this->frame()) {
        const bool mainResourceWasAlreadyRequested = frame->loader().stateMachine()->committedFirstRealDocumentLoad();

        if (mainResourceWasAlreadyRequested)
            updateLayoutTreeIfNeeded();

        frame->loader().finishedParsing();

        TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""MarkDOMContent"", TRACE_EVENT_SCOPE_THREAD, ""data"", InspectorMarkLoadEvent::data(frame.get()));
        InspectorInstrumentation::domContentLoadedEventFired(frame.get());
    }

    m_elementDataCacheClearTimer.startOneShot(10, FROM_HERE);

    m_fetcher->clearPreloads();
}
",C,"    Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());
","    Microtask::performCheckpoint();
",,"@@ -36,6 +36,7 @@
 #include ""bindings/core/v8/ScriptController.h""
 #include ""bindings/core/v8/UnionTypesCore.h""
 #include ""bindings/core/v8/V8DOMWrapper.h""
+#include ""bindings/core/v8/V8PerIsolateData.h""
 #include ""bindings/core/v8/WindowProxy.h""
 #include ""core/HTMLElementFactory.h""
 #include ""core/HTMLNames.h""
@@ -4515,7 +4516,7 @@ void Document::finishedParsing()
     // Ensure Custom Element callbacks are drained before DOMContentLoaded.
     // FIXME: Remove this ad-hoc checkpoint when DOMContentLoaded is dispatched in a
     // queued task, which will do a checkpoint anyway. https://crbug.com/425790
-    Microtask::performCheckpoint();
+    Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());
 
     if (RefPtrWillBeRawPtr<LocalFrame> frame = this->frame()) {
         // Don't update the layout tree if we haven't requested the main resource yet to avoid",Chrome,dff368031150a1033a1a3c913f8857679a0279be,e073acb8522a8f7fb8af7d2ee4c34f39a7d45a12,1,"void Document::finishedParsing()
{
    ASSERT(!scriptableDocumentParser() || !m_parser->isParsing());
    ASSERT(!scriptableDocumentParser() || m_readyState != Loading);
    setParsingState(InDOMContentLoaded);

    // FIXME: DOMContentLoaded is dispatched synchronously, but this should be dispatched in a queued task,
    // See https://crbug.com/425790
    if (!m_documentTiming.domContentLoadedEventStart())
        m_documentTiming.setDomContentLoadedEventStart(monotonicallyIncreasingTime());
    dispatchEvent(Event::createBubble(EventTypeNames::DOMContentLoaded));
    if (!m_documentTiming.domContentLoadedEventEnd())
        m_documentTiming.setDomContentLoadedEventEnd(monotonicallyIncreasingTime());
    setParsingState(FinishedParsing);

    // The microtask checkpoint or the loader's finishedParsing() method may invoke script that causes this object to
    // be dereferenced (when this document is in an iframe and the onload causes the iframe's src to change).
    // Keep it alive until we are done.
    RefPtrWillBeRawPtr<Document> protect(this);

     // Ensure Custom Element callbacks are drained before DOMContentLoaded.
     // FIXME: Remove this ad-hoc checkpoint when DOMContentLoaded is dispatched in a
     // queued task, which will do a checkpoint anyway. https://crbug.com/425790
//flaw_line_below:
    Microtask::performCheckpoint();
//fix_flaw_line_below:
//    Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());
 
     if (RefPtrWillBeRawPtr<LocalFrame> frame = this->frame()) {
         // Don't update the layout tree if we haven't requested the main resource yet to avoid
        // adding extra latency. Note that the first layout tree update can be expensive since it
        // triggers the parsing of the default stylesheets which are compiled-in.
        const bool mainResourceWasAlreadyRequested = frame->loader().stateMachine()->committedFirstRealDocumentLoad();

        // FrameLoader::finishedParsing() might end up calling Document::implicitClose() if all
        // resource loads are complete. HTMLObjectElements can start loading their resources from
        // post attach callbacks triggered by recalcStyle().  This means if we parse out an <object>
        // tag and then reach the end of the document without updating styles, we might not have yet
        // started the resource load and might fire the window load event too early.  To avoid this
        // we force the styles to be up to date before calling FrameLoader::finishedParsing().
        // See https://bugs.webkit.org/show_bug.cgi?id=36864 starting around comment 35.
        if (mainResourceWasAlreadyRequested)
            updateLayoutTreeIfNeeded();

        frame->loader().finishedParsing();

        TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""MarkDOMContent"", TRACE_EVENT_SCOPE_THREAD, ""data"", InspectorMarkLoadEvent::data(frame.get()));
        InspectorInstrumentation::domContentLoadedEventFired(frame.get());
    }

    // Schedule dropping of the ElementDataCache. We keep it alive for a while after parsing finishes
    // so that dynamically inserted content can also benefit from sharing optimizations.
    // Note that we don't refresh the timer on cache access since that could lead to huge caches being kept
    // alive indefinitely by something innocuous like JS setting .innerHTML repeatedly on a timer.
    m_elementDataCacheClearTimer.startOneShot(10, FROM_HERE);

    // Parser should have picked up all preloads by now
    m_fetcher->clearPreloads();
}
"
8087,185823,,Remote,Not required,,CVE-2015-1281,https://www.cvedetails.com/cve/CVE-2015-1281/,CWE-254,Medium,,Partial,,2015-07-22,4.3,"core/loader/ImageLoader.cpp in Blink, as used in Google Chrome before 44.0.2403.89, does not properly determine the V8 context of a microtask, which allows remote attackers to bypass Content Security Policy (CSP) restrictions by providing an image from an unintended source.",2018-10-30,Bypass ,1,https://github.com/chromium/chromium/commit/dff368031150a1033a1a3c913f8857679a0279be,dff368031150a1033a1a3c913f8857679a0279be,"Correctly keep track of isolates for microtask execution

BUG=487155
R=haraken@chromium.org

Review URL: https://codereview.chromium.org/1161823002

git-svn-id: svn://svn.chromium.org/blink/trunk@195985 bbb929c8-8fbe-4397-9dbb-9b2b20218538",1,third_party/WebKit/Source/core/dom/Microtask.cpp,"{""sha"": ""682fe9d2e06243e0b879e943e0138d344db742e6"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -37,7 +37,7 @@ namespace blink {\n \n void V8RecursionScope::didLeaveScriptContext()\n {\n-    Microtask::performCheckpoint();\n+    Microtask::performCheckpoint(m_isolate);\n     V8PerIsolateData::from(m_isolate)->runEndOfScopeTasks();\n }\n ""}<_**next**_>{""sha"": ""d85fa40c092391c457b3c51c2864d547ea6f4d7e"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Document.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Document.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -36,6 +36,7 @@\n #include \""bindings/core/v8/ScriptController.h\""\n #include \""bindings/core/v8/UnionTypesCore.h\""\n #include \""bindings/core/v8/V8DOMWrapper.h\""\n+#include \""bindings/core/v8/V8PerIsolateData.h\""\n #include \""bindings/core/v8/WindowProxy.h\""\n #include \""core/HTMLElementFactory.h\""\n #include \""core/HTMLNames.h\""\n@@ -4515,7 +4516,7 @@ void Document::finishedParsing()\n     // Ensure Custom Element callbacks are drained before DOMContentLoaded.\n     // FIXME: Remove this ad-hoc checkpoint when DOMContentLoaded is dispatched in a\n     // queued task, which will do a checkpoint anyway. https://crbug.com/425790\n-    Microtask::performCheckpoint();\n+    Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());\n \n     if (RefPtrWillBeRawPtr<LocalFrame> frame = this->frame()) {\n         // Don't update the layout tree if we haven't requested the main resource yet to avoid""}<_**next**_>{""sha"": ""833bccb8714d5c9146e7190a6b95396e89b5a0bf"", ""filename"": ""third_party/WebKit/Source/core/dom/Microtask.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Microtask.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -40,9 +40,8 @@\n \n namespace blink {\n \n-void Microtask::performCheckpoint()\n+void Microtask::performCheckpoint(v8::Isolate* isolate)\n {\n-    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n     V8PerIsolateData* isolateData = V8PerIsolateData::from(isolate);\n     ASSERT(isolateData);\n     if (isolateData->recursionLevel() || isolateData->performingMicrotaskCheckpoint() || isolateData->destructionPending() || ScriptForbiddenScope::isScriptForbidden())""}<_**next**_>{""sha"": ""e111c03da1dac1d1b06913a2c62c37b97c434e99"", ""filename"": ""third_party/WebKit/Source/core/dom/Microtask.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Microtask.h?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -31,6 +31,7 @@\n #ifndef Microtask_h\n #define Microtask_h\n \n+#include \""bindings/core/v8/ScriptState.h\""\n #include \""core/CoreExport.h\""\n #include \""public/platform/WebThread.h\""\n #include \""wtf/Functional.h\""\n@@ -41,7 +42,7 @@ namespace blink {\n \n class CORE_EXPORT Microtask {\n public:\n-    static void performCheckpoint();\n+    static void performCheckpoint(v8::Isolate*);\n     static bool performingCheckpoint(v8::Isolate*);\n \n     // TODO(jochen): Make all microtasks pass in the ScriptState they want to be""}<_**next**_>{""sha"": ""c0570e2e44c72829e06c338390b3dcf03c0309da"", ""filename"": ""third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -27,6 +27,7 @@\n #include \""core/html/parser/HTMLScriptRunner.h\""\n \n #include \""bindings/core/v8/ScriptSourceCode.h\""\n+#include \""bindings/core/v8/V8PerIsolateData.h\""\n #include \""core/dom/Element.h\""\n #include \""core/events/Event.h\""\n #include \""core/dom/IgnoreDestructiveWriteCountIncrementer.h\""\n@@ -133,7 +134,7 @@ void HTMLScriptRunner::executePendingScriptAndDispatchEvent(PendingScript& pendi\n     pendingScript.stopWatchingForLoad(this);\n \n     if (!isExecutingScript()) {\n-        Microtask::performCheckpoint();\n+        Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());\n         if (pendingScriptType == PendingScript::ParsingBlocking) {\n             m_hasScriptsWaitingForResources = !m_document->isScriptExecutionReady();\n             // The parser cannot be unblocked as a microtask requested another resource\n@@ -337,7 +338,7 @@ void HTMLScriptRunner::runScript(Element* script, const TextPosition& scriptStar\n         ASSERT(scriptLoader->isParserInserted());\n \n         if (!isExecutingScript())\n-            Microtask::performCheckpoint();\n+            Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());\n \n         InsertionPointRecord insertionPointRecord(m_host->inputStream());\n         NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);""}<_**next**_>{""sha"": ""883944ff2e4caeac2a8c5b0f951d687984b8da7e"", ""filename"": ""third_party/WebKit/Source/core/workers/WorkerThread.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/workers/WorkerThread.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/workers/WorkerThread.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/workers/WorkerThread.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -76,7 +76,7 @@ class WorkerMicrotaskRunner : public WebThread::TaskObserver {\n \n     virtual void didProcessTask() override\n     {\n-        Microtask::performCheckpoint();\n+        Microtask::performCheckpoint(m_workerThread->isolate());\n         if (WorkerGlobalScope* globalScope = m_workerThread->workerGlobalScope()) {\n             if (WorkerScriptController* scriptController = globalScope->script())\n                 scriptController->rejectedPromises()->processQueue();""}<_**next**_>{""sha"": ""6b1bc9394ebc90a076029c3235be48e270bc17f0"", ""filename"": ""third_party/WebKit/Source/web/WebKit.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/web/WebKit.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/web/WebKit.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/WebKit.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -76,7 +76,7 @@ class EndOfTaskRunner : public WebThread::TaskObserver {\n     }\n     virtual void didProcessTask() override\n     {\n-        Microtask::performCheckpoint();\n+        Microtask::performCheckpoint(mainThreadIsolate());\n         V8GCController::reportDOMMemoryUsageToV8(mainThreadIsolate());\n         V8Initializer::reportRejectedPromisesOnMainThread();\n     }""}","void Microtask::performCheckpoint()
void Microtask::performCheckpoint(v8::Isolate* isolate)
 {
     V8PerIsolateData* isolateData = V8PerIsolateData::from(isolate);
     ASSERT(isolateData);
     if (isolateData->recursionLevel() || isolateData->performingMicrotaskCheckpoint() || isolateData->destructionPending() || ScriptForbiddenScope::isScriptForbidden())
        return;
    isolateData->setPerformingMicrotaskCheckpoint(true);
    {
        V8RecursionScope recursionScope(isolate);
        isolate->RunMicrotasks();
    }
    isolateData->setPerformingMicrotaskCheckpoint(false);
}
","void Microtask::performCheckpoint()
 {
    v8::Isolate* isolate = v8::Isolate::GetCurrent();
     V8PerIsolateData* isolateData = V8PerIsolateData::from(isolate);
     ASSERT(isolateData);
     if (isolateData->recursionLevel() || isolateData->performingMicrotaskCheckpoint() || isolateData->destructionPending() || ScriptForbiddenScope::isScriptForbidden())
        return;
    isolateData->setPerformingMicrotaskCheckpoint(true);
    {
        V8RecursionScope recursionScope(isolate);
        isolate->RunMicrotasks();
    }
    isolateData->setPerformingMicrotaskCheckpoint(false);
}
",C,"void Microtask::performCheckpoint(v8::Isolate* isolate)
","    v8::Isolate* isolate = v8::Isolate::GetCurrent();
",,"@@ -40,9 +40,8 @@
 
 namespace blink {
 
-void Microtask::performCheckpoint()
+void Microtask::performCheckpoint(v8::Isolate* isolate)
 {
-    v8::Isolate* isolate = v8::Isolate::GetCurrent();
     V8PerIsolateData* isolateData = V8PerIsolateData::from(isolate);
     ASSERT(isolateData);
     if (isolateData->recursionLevel() || isolateData->performingMicrotaskCheckpoint() || isolateData->destructionPending() || ScriptForbiddenScope::isScriptForbidden())",Chrome,dff368031150a1033a1a3c913f8857679a0279be,e073acb8522a8f7fb8af7d2ee4c34f39a7d45a12,1,"void Microtask::performCheckpoint()
//fix_flaw_line_below:
//void Microtask::performCheckpoint(v8::Isolate* isolate)
 {
//flaw_line_below:
    v8::Isolate* isolate = v8::Isolate::GetCurrent();
     V8PerIsolateData* isolateData = V8PerIsolateData::from(isolate);
     ASSERT(isolateData);
     if (isolateData->recursionLevel() || isolateData->performingMicrotaskCheckpoint() || isolateData->destructionPending() || ScriptForbiddenScope::isScriptForbidden())
        return;
    isolateData->setPerformingMicrotaskCheckpoint(true);
    {
        // Ensure that end-of-task-or-microtask actions are performed.
        V8RecursionScope recursionScope(isolate);
        isolate->RunMicrotasks();
    }
    isolateData->setPerformingMicrotaskCheckpoint(false);
}
"
8088,185824,,Remote,Not required,,CVE-2015-1281,https://www.cvedetails.com/cve/CVE-2015-1281/,CWE-254,Medium,,Partial,,2015-07-22,4.3,"core/loader/ImageLoader.cpp in Blink, as used in Google Chrome before 44.0.2403.89, does not properly determine the V8 context of a microtask, which allows remote attackers to bypass Content Security Policy (CSP) restrictions by providing an image from an unintended source.",2018-10-30,Bypass ,1,https://github.com/chromium/chromium/commit/dff368031150a1033a1a3c913f8857679a0279be,dff368031150a1033a1a3c913f8857679a0279be,"Correctly keep track of isolates for microtask execution

BUG=487155
R=haraken@chromium.org

Review URL: https://codereview.chromium.org/1161823002

git-svn-id: svn://svn.chromium.org/blink/trunk@195985 bbb929c8-8fbe-4397-9dbb-9b2b20218538",1,third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp,"{""sha"": ""682fe9d2e06243e0b879e943e0138d344db742e6"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -37,7 +37,7 @@ namespace blink {\n \n void V8RecursionScope::didLeaveScriptContext()\n {\n-    Microtask::performCheckpoint();\n+    Microtask::performCheckpoint(m_isolate);\n     V8PerIsolateData::from(m_isolate)->runEndOfScopeTasks();\n }\n ""}<_**next**_>{""sha"": ""d85fa40c092391c457b3c51c2864d547ea6f4d7e"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Document.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Document.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -36,6 +36,7 @@\n #include \""bindings/core/v8/ScriptController.h\""\n #include \""bindings/core/v8/UnionTypesCore.h\""\n #include \""bindings/core/v8/V8DOMWrapper.h\""\n+#include \""bindings/core/v8/V8PerIsolateData.h\""\n #include \""bindings/core/v8/WindowProxy.h\""\n #include \""core/HTMLElementFactory.h\""\n #include \""core/HTMLNames.h\""\n@@ -4515,7 +4516,7 @@ void Document::finishedParsing()\n     // Ensure Custom Element callbacks are drained before DOMContentLoaded.\n     // FIXME: Remove this ad-hoc checkpoint when DOMContentLoaded is dispatched in a\n     // queued task, which will do a checkpoint anyway. https://crbug.com/425790\n-    Microtask::performCheckpoint();\n+    Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());\n \n     if (RefPtrWillBeRawPtr<LocalFrame> frame = this->frame()) {\n         // Don't update the layout tree if we haven't requested the main resource yet to avoid""}<_**next**_>{""sha"": ""833bccb8714d5c9146e7190a6b95396e89b5a0bf"", ""filename"": ""third_party/WebKit/Source/core/dom/Microtask.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Microtask.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -40,9 +40,8 @@\n \n namespace blink {\n \n-void Microtask::performCheckpoint()\n+void Microtask::performCheckpoint(v8::Isolate* isolate)\n {\n-    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n     V8PerIsolateData* isolateData = V8PerIsolateData::from(isolate);\n     ASSERT(isolateData);\n     if (isolateData->recursionLevel() || isolateData->performingMicrotaskCheckpoint() || isolateData->destructionPending() || ScriptForbiddenScope::isScriptForbidden())""}<_**next**_>{""sha"": ""e111c03da1dac1d1b06913a2c62c37b97c434e99"", ""filename"": ""third_party/WebKit/Source/core/dom/Microtask.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Microtask.h?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -31,6 +31,7 @@\n #ifndef Microtask_h\n #define Microtask_h\n \n+#include \""bindings/core/v8/ScriptState.h\""\n #include \""core/CoreExport.h\""\n #include \""public/platform/WebThread.h\""\n #include \""wtf/Functional.h\""\n@@ -41,7 +42,7 @@ namespace blink {\n \n class CORE_EXPORT Microtask {\n public:\n-    static void performCheckpoint();\n+    static void performCheckpoint(v8::Isolate*);\n     static bool performingCheckpoint(v8::Isolate*);\n \n     // TODO(jochen): Make all microtasks pass in the ScriptState they want to be""}<_**next**_>{""sha"": ""c0570e2e44c72829e06c338390b3dcf03c0309da"", ""filename"": ""third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -27,6 +27,7 @@\n #include \""core/html/parser/HTMLScriptRunner.h\""\n \n #include \""bindings/core/v8/ScriptSourceCode.h\""\n+#include \""bindings/core/v8/V8PerIsolateData.h\""\n #include \""core/dom/Element.h\""\n #include \""core/events/Event.h\""\n #include \""core/dom/IgnoreDestructiveWriteCountIncrementer.h\""\n@@ -133,7 +134,7 @@ void HTMLScriptRunner::executePendingScriptAndDispatchEvent(PendingScript& pendi\n     pendingScript.stopWatchingForLoad(this);\n \n     if (!isExecutingScript()) {\n-        Microtask::performCheckpoint();\n+        Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());\n         if (pendingScriptType == PendingScript::ParsingBlocking) {\n             m_hasScriptsWaitingForResources = !m_document->isScriptExecutionReady();\n             // The parser cannot be unblocked as a microtask requested another resource\n@@ -337,7 +338,7 @@ void HTMLScriptRunner::runScript(Element* script, const TextPosition& scriptStar\n         ASSERT(scriptLoader->isParserInserted());\n \n         if (!isExecutingScript())\n-            Microtask::performCheckpoint();\n+            Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());\n \n         InsertionPointRecord insertionPointRecord(m_host->inputStream());\n         NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);""}<_**next**_>{""sha"": ""883944ff2e4caeac2a8c5b0f951d687984b8da7e"", ""filename"": ""third_party/WebKit/Source/core/workers/WorkerThread.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/workers/WorkerThread.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/workers/WorkerThread.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/workers/WorkerThread.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -76,7 +76,7 @@ class WorkerMicrotaskRunner : public WebThread::TaskObserver {\n \n     virtual void didProcessTask() override\n     {\n-        Microtask::performCheckpoint();\n+        Microtask::performCheckpoint(m_workerThread->isolate());\n         if (WorkerGlobalScope* globalScope = m_workerThread->workerGlobalScope()) {\n             if (WorkerScriptController* scriptController = globalScope->script())\n                 scriptController->rejectedPromises()->processQueue();""}<_**next**_>{""sha"": ""6b1bc9394ebc90a076029c3235be48e270bc17f0"", ""filename"": ""third_party/WebKit/Source/web/WebKit.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/web/WebKit.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/web/WebKit.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/WebKit.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -76,7 +76,7 @@ class EndOfTaskRunner : public WebThread::TaskObserver {\n     }\n     virtual void didProcessTask() override\n     {\n-        Microtask::performCheckpoint();\n+        Microtask::performCheckpoint(mainThreadIsolate());\n         V8GCController::reportDOMMemoryUsageToV8(mainThreadIsolate());\n         V8Initializer::reportRejectedPromisesOnMainThread();\n     }""}","void HTMLScriptRunner::executePendingScriptAndDispatchEvent(PendingScript& pendingScript, PendingScript::Type pendingScriptType)
{
    bool errorOccurred = false;
    double loadFinishTime = pendingScript.resource() && pendingScript.resource()->url().protocolIsInHTTPFamily() ? pendingScript.resource()->loadFinishTime() : 0;
    ScriptSourceCode sourceCode = pendingScript.getSource(documentURLForScriptExecution(m_document), errorOccurred);

     pendingScript.stopWatchingForLoad(this);
 
     if (!isExecutingScript()) {
        Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());
         if (pendingScriptType == PendingScript::ParsingBlocking) {
             m_hasScriptsWaitingForResources = !m_document->isScriptExecutionReady();
            if (m_hasScriptsWaitingForResources)
                return;
        }
    }

    RefPtrWillBeRawPtr<Element> element = pendingScript.releaseElementAndClear();
    double compilationFinishTime = 0;
    if (ScriptLoader* scriptLoader = toScriptLoaderIfPossible(element.get())) {
        NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);
        IgnoreDestructiveWriteCountIncrementer ignoreDestructiveWriteCountIncrementer(m_document);
        if (errorOccurred)
            scriptLoader->dispatchErrorEvent();
        else {
            ASSERT(isExecutingScript());
            if (!scriptLoader->executeScript(sourceCode, &compilationFinishTime)) {
                scriptLoader->dispatchErrorEvent();
            } else {
                element->dispatchEvent(createScriptLoadEvent());
            }
        }
    }
    const double epsilon = 1;
    if (pendingScriptType == PendingScript::ParsingBlocking && !m_parserBlockingScriptAlreadyLoaded && compilationFinishTime > epsilon && loadFinishTime > epsilon) {
        Platform::current()->histogramCustomCounts(""WebCore.Scripts.ParsingBlocking.TimeBetweenLoadedAndCompiled"", (compilationFinishTime - loadFinishTime) * 1000, 0, 10000, 50);
    }

    ASSERT(!isExecutingScript());
}
","void HTMLScriptRunner::executePendingScriptAndDispatchEvent(PendingScript& pendingScript, PendingScript::Type pendingScriptType)
{
    bool errorOccurred = false;
    double loadFinishTime = pendingScript.resource() && pendingScript.resource()->url().protocolIsInHTTPFamily() ? pendingScript.resource()->loadFinishTime() : 0;
    ScriptSourceCode sourceCode = pendingScript.getSource(documentURLForScriptExecution(m_document), errorOccurred);

     pendingScript.stopWatchingForLoad(this);
 
     if (!isExecutingScript()) {
        Microtask::performCheckpoint();
         if (pendingScriptType == PendingScript::ParsingBlocking) {
             m_hasScriptsWaitingForResources = !m_document->isScriptExecutionReady();
            if (m_hasScriptsWaitingForResources)
                return;
        }
    }

    RefPtrWillBeRawPtr<Element> element = pendingScript.releaseElementAndClear();
    double compilationFinishTime = 0;
    if (ScriptLoader* scriptLoader = toScriptLoaderIfPossible(element.get())) {
        NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);
        IgnoreDestructiveWriteCountIncrementer ignoreDestructiveWriteCountIncrementer(m_document);
        if (errorOccurred)
            scriptLoader->dispatchErrorEvent();
        else {
            ASSERT(isExecutingScript());
            if (!scriptLoader->executeScript(sourceCode, &compilationFinishTime)) {
                scriptLoader->dispatchErrorEvent();
            } else {
                element->dispatchEvent(createScriptLoadEvent());
            }
        }
    }
    const double epsilon = 1;
    if (pendingScriptType == PendingScript::ParsingBlocking && !m_parserBlockingScriptAlreadyLoaded && compilationFinishTime > epsilon && loadFinishTime > epsilon) {
        Platform::current()->histogramCustomCounts(""WebCore.Scripts.ParsingBlocking.TimeBetweenLoadedAndCompiled"", (compilationFinishTime - loadFinishTime) * 1000, 0, 10000, 50);
    }

    ASSERT(!isExecutingScript());
}
",C,"        Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());
","        Microtask::performCheckpoint();
",,"@@ -27,6 +27,7 @@
 #include ""core/html/parser/HTMLScriptRunner.h""
 
 #include ""bindings/core/v8/ScriptSourceCode.h""
+#include ""bindings/core/v8/V8PerIsolateData.h""
 #include ""core/dom/Element.h""
 #include ""core/events/Event.h""
 #include ""core/dom/IgnoreDestructiveWriteCountIncrementer.h""
@@ -133,7 +134,7 @@ void HTMLScriptRunner::executePendingScriptAndDispatchEvent(PendingScript& pendi
     pendingScript.stopWatchingForLoad(this);
 
     if (!isExecutingScript()) {
-        Microtask::performCheckpoint();
+        Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());
         if (pendingScriptType == PendingScript::ParsingBlocking) {
             m_hasScriptsWaitingForResources = !m_document->isScriptExecutionReady();
             // The parser cannot be unblocked as a microtask requested another resource
@@ -337,7 +338,7 @@ void HTMLScriptRunner::runScript(Element* script, const TextPosition& scriptStar
         ASSERT(scriptLoader->isParserInserted());
 
         if (!isExecutingScript())
-            Microtask::performCheckpoint();
+            Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());
 
         InsertionPointRecord insertionPointRecord(m_host->inputStream());
         NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);",Chrome,dff368031150a1033a1a3c913f8857679a0279be,e073acb8522a8f7fb8af7d2ee4c34f39a7d45a12,1,"void HTMLScriptRunner::executePendingScriptAndDispatchEvent(PendingScript& pendingScript, PendingScript::Type pendingScriptType)
{
    bool errorOccurred = false;
    double loadFinishTime = pendingScript.resource() && pendingScript.resource()->url().protocolIsInHTTPFamily() ? pendingScript.resource()->loadFinishTime() : 0;
    ScriptSourceCode sourceCode = pendingScript.getSource(documentURLForScriptExecution(m_document), errorOccurred);

    // Stop watching loads before executeScript to prevent recursion if the script reloads itself.
     pendingScript.stopWatchingForLoad(this);
 
     if (!isExecutingScript()) {
//flaw_line_below:
        Microtask::performCheckpoint();
//fix_flaw_line_below:
//        Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());
         if (pendingScriptType == PendingScript::ParsingBlocking) {
             m_hasScriptsWaitingForResources = !m_document->isScriptExecutionReady();
             // The parser cannot be unblocked as a microtask requested another resource
            if (m_hasScriptsWaitingForResources)
                return;
        }
    }

    // Clear the pending script before possible rentrancy from executeScript()
    RefPtrWillBeRawPtr<Element> element = pendingScript.releaseElementAndClear();
    double compilationFinishTime = 0;
    if (ScriptLoader* scriptLoader = toScriptLoaderIfPossible(element.get())) {
        NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);
        IgnoreDestructiveWriteCountIncrementer ignoreDestructiveWriteCountIncrementer(m_document);
        if (errorOccurred)
            scriptLoader->dispatchErrorEvent();
        else {
            ASSERT(isExecutingScript());
            if (!scriptLoader->executeScript(sourceCode, &compilationFinishTime)) {
                scriptLoader->dispatchErrorEvent();
            } else {
                element->dispatchEvent(createScriptLoadEvent());
            }
        }
    }
    // The exact value doesn't matter; valid time stamps are much bigger than this value.
    const double epsilon = 1;
    if (pendingScriptType == PendingScript::ParsingBlocking && !m_parserBlockingScriptAlreadyLoaded && compilationFinishTime > epsilon && loadFinishTime > epsilon) {
        Platform::current()->histogramCustomCounts(""WebCore.Scripts.ParsingBlocking.TimeBetweenLoadedAndCompiled"", (compilationFinishTime - loadFinishTime) * 1000, 0, 10000, 50);
    }

    ASSERT(!isExecutingScript());
}
"
8089,185825,,Remote,Not required,,CVE-2015-1281,https://www.cvedetails.com/cve/CVE-2015-1281/,CWE-254,Medium,,Partial,,2015-07-22,4.3,"core/loader/ImageLoader.cpp in Blink, as used in Google Chrome before 44.0.2403.89, does not properly determine the V8 context of a microtask, which allows remote attackers to bypass Content Security Policy (CSP) restrictions by providing an image from an unintended source.",2018-10-30,Bypass ,1,https://github.com/chromium/chromium/commit/dff368031150a1033a1a3c913f8857679a0279be,dff368031150a1033a1a3c913f8857679a0279be,"Correctly keep track of isolates for microtask execution

BUG=487155
R=haraken@chromium.org

Review URL: https://codereview.chromium.org/1161823002

git-svn-id: svn://svn.chromium.org/blink/trunk@195985 bbb929c8-8fbe-4397-9dbb-9b2b20218538",1,third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp,"{""sha"": ""682fe9d2e06243e0b879e943e0138d344db742e6"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/V8RecursionScope.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -37,7 +37,7 @@ namespace blink {\n \n void V8RecursionScope::didLeaveScriptContext()\n {\n-    Microtask::performCheckpoint();\n+    Microtask::performCheckpoint(m_isolate);\n     V8PerIsolateData::from(m_isolate)->runEndOfScopeTasks();\n }\n ""}<_**next**_>{""sha"": ""d85fa40c092391c457b3c51c2864d547ea6f4d7e"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Document.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Document.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -36,6 +36,7 @@\n #include \""bindings/core/v8/ScriptController.h\""\n #include \""bindings/core/v8/UnionTypesCore.h\""\n #include \""bindings/core/v8/V8DOMWrapper.h\""\n+#include \""bindings/core/v8/V8PerIsolateData.h\""\n #include \""bindings/core/v8/WindowProxy.h\""\n #include \""core/HTMLElementFactory.h\""\n #include \""core/HTMLNames.h\""\n@@ -4515,7 +4516,7 @@ void Document::finishedParsing()\n     // Ensure Custom Element callbacks are drained before DOMContentLoaded.\n     // FIXME: Remove this ad-hoc checkpoint when DOMContentLoaded is dispatched in a\n     // queued task, which will do a checkpoint anyway. https://crbug.com/425790\n-    Microtask::performCheckpoint();\n+    Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());\n \n     if (RefPtrWillBeRawPtr<LocalFrame> frame = this->frame()) {\n         // Don't update the layout tree if we haven't requested the main resource yet to avoid""}<_**next**_>{""sha"": ""833bccb8714d5c9146e7190a6b95396e89b5a0bf"", ""filename"": ""third_party/WebKit/Source/core/dom/Microtask.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Microtask.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -40,9 +40,8 @@\n \n namespace blink {\n \n-void Microtask::performCheckpoint()\n+void Microtask::performCheckpoint(v8::Isolate* isolate)\n {\n-    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n     V8PerIsolateData* isolateData = V8PerIsolateData::from(isolate);\n     ASSERT(isolateData);\n     if (isolateData->recursionLevel() || isolateData->performingMicrotaskCheckpoint() || isolateData->destructionPending() || ScriptForbiddenScope::isScriptForbidden())""}<_**next**_>{""sha"": ""e111c03da1dac1d1b06913a2c62c37b97c434e99"", ""filename"": ""third_party/WebKit/Source/core/dom/Microtask.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/dom/Microtask.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Microtask.h?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -31,6 +31,7 @@\n #ifndef Microtask_h\n #define Microtask_h\n \n+#include \""bindings/core/v8/ScriptState.h\""\n #include \""core/CoreExport.h\""\n #include \""public/platform/WebThread.h\""\n #include \""wtf/Functional.h\""\n@@ -41,7 +42,7 @@ namespace blink {\n \n class CORE_EXPORT Microtask {\n public:\n-    static void performCheckpoint();\n+    static void performCheckpoint(v8::Isolate*);\n     static bool performingCheckpoint(v8::Isolate*);\n \n     // TODO(jochen): Make all microtasks pass in the ScriptState they want to be""}<_**next**_>{""sha"": ""c0570e2e44c72829e06c338390b3dcf03c0309da"", ""filename"": ""third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/parser/HTMLScriptRunner.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -27,6 +27,7 @@\n #include \""core/html/parser/HTMLScriptRunner.h\""\n \n #include \""bindings/core/v8/ScriptSourceCode.h\""\n+#include \""bindings/core/v8/V8PerIsolateData.h\""\n #include \""core/dom/Element.h\""\n #include \""core/events/Event.h\""\n #include \""core/dom/IgnoreDestructiveWriteCountIncrementer.h\""\n@@ -133,7 +134,7 @@ void HTMLScriptRunner::executePendingScriptAndDispatchEvent(PendingScript& pendi\n     pendingScript.stopWatchingForLoad(this);\n \n     if (!isExecutingScript()) {\n-        Microtask::performCheckpoint();\n+        Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());\n         if (pendingScriptType == PendingScript::ParsingBlocking) {\n             m_hasScriptsWaitingForResources = !m_document->isScriptExecutionReady();\n             // The parser cannot be unblocked as a microtask requested another resource\n@@ -337,7 +338,7 @@ void HTMLScriptRunner::runScript(Element* script, const TextPosition& scriptStar\n         ASSERT(scriptLoader->isParserInserted());\n \n         if (!isExecutingScript())\n-            Microtask::performCheckpoint();\n+            Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());\n \n         InsertionPointRecord insertionPointRecord(m_host->inputStream());\n         NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);""}<_**next**_>{""sha"": ""883944ff2e4caeac2a8c5b0f951d687984b8da7e"", ""filename"": ""third_party/WebKit/Source/core/workers/WorkerThread.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/workers/WorkerThread.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/core/workers/WorkerThread.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/workers/WorkerThread.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -76,7 +76,7 @@ class WorkerMicrotaskRunner : public WebThread::TaskObserver {\n \n     virtual void didProcessTask() override\n     {\n-        Microtask::performCheckpoint();\n+        Microtask::performCheckpoint(m_workerThread->isolate());\n         if (WorkerGlobalScope* globalScope = m_workerThread->workerGlobalScope()) {\n             if (WorkerScriptController* scriptController = globalScope->script())\n                 scriptController->rejectedPromises()->processQueue();""}<_**next**_>{""sha"": ""6b1bc9394ebc90a076029c3235be48e270bc17f0"", ""filename"": ""third_party/WebKit/Source/web/WebKit.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/web/WebKit.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dff368031150a1033a1a3c913f8857679a0279be/third_party/WebKit/Source/web/WebKit.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/WebKit.cpp?ref=dff368031150a1033a1a3c913f8857679a0279be"", ""patch"": ""@@ -76,7 +76,7 @@ class EndOfTaskRunner : public WebThread::TaskObserver {\n     }\n     virtual void didProcessTask() override\n     {\n-        Microtask::performCheckpoint();\n+        Microtask::performCheckpoint(mainThreadIsolate());\n         V8GCController::reportDOMMemoryUsageToV8(mainThreadIsolate());\n         V8Initializer::reportRejectedPromisesOnMainThread();\n     }""}","void HTMLScriptRunner::runScript(Element* script, const TextPosition& scriptStartPosition)
{
    ASSERT(m_document);
    ASSERT(!hasParserBlockingScript());
    {
        ScriptLoader* scriptLoader = toScriptLoaderIfPossible(script);

        ASSERT(scriptLoader);
        if (!scriptLoader)
            return;

         ASSERT(scriptLoader->isParserInserted());
 
         if (!isExecutingScript())
            Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());
 
         InsertionPointRecord insertionPointRecord(m_host->inputStream());
         NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);

        scriptLoader->prepareScript(scriptStartPosition);

        if (!scriptLoader->willBeParserExecuted())
            return;

        if (scriptLoader->willExecuteWhenDocumentFinishedParsing()) {
            requestDeferredScript(script);
        } else if (scriptLoader->readyToBeParserExecuted()) {
            if (m_scriptNestingLevel == 1) {
                m_parserBlockingScript.setElement(script);
                m_parserBlockingScript.setStartingPosition(scriptStartPosition);
            } else {
                ScriptSourceCode sourceCode(script->textContent(), documentURLForScriptExecution(m_document), scriptStartPosition);
                scriptLoader->executeScript(sourceCode);
            }
        } else {
            requestParsingBlockingScript(script);
        }
    }
}
","void HTMLScriptRunner::runScript(Element* script, const TextPosition& scriptStartPosition)
{
    ASSERT(m_document);
    ASSERT(!hasParserBlockingScript());
    {
        ScriptLoader* scriptLoader = toScriptLoaderIfPossible(script);

        ASSERT(scriptLoader);
        if (!scriptLoader)
            return;

         ASSERT(scriptLoader->isParserInserted());
 
         if (!isExecutingScript())
            Microtask::performCheckpoint();
 
         InsertionPointRecord insertionPointRecord(m_host->inputStream());
         NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);

        scriptLoader->prepareScript(scriptStartPosition);

        if (!scriptLoader->willBeParserExecuted())
            return;

        if (scriptLoader->willExecuteWhenDocumentFinishedParsing()) {
            requestDeferredScript(script);
        } else if (scriptLoader->readyToBeParserExecuted()) {
            if (m_scriptNestingLevel == 1) {
                m_parserBlockingScript.setElement(script);
                m_parserBlockingScript.setStartingPosition(scriptStartPosition);
            } else {
                ScriptSourceCode sourceCode(script->textContent(), documentURLForScriptExecution(m_document), scriptStartPosition);
                scriptLoader->executeScript(sourceCode);
            }
        } else {
            requestParsingBlockingScript(script);
        }
    }
}
",C,"            Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());
","            Microtask::performCheckpoint();
",,"@@ -27,6 +27,7 @@
 #include ""core/html/parser/HTMLScriptRunner.h""
 
 #include ""bindings/core/v8/ScriptSourceCode.h""
+#include ""bindings/core/v8/V8PerIsolateData.h""
 #include ""core/dom/Element.h""
 #include ""core/events/Event.h""
 #include ""core/dom/IgnoreDestructiveWriteCountIncrementer.h""
@@ -133,7 +134,7 @@ void HTMLScriptRunner::executePendingScriptAndDispatchEvent(PendingScript& pendi
     pendingScript.stopWatchingForLoad(this);
 
     if (!isExecutingScript()) {
-        Microtask::performCheckpoint();
+        Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());
         if (pendingScriptType == PendingScript::ParsingBlocking) {
             m_hasScriptsWaitingForResources = !m_document->isScriptExecutionReady();
             // The parser cannot be unblocked as a microtask requested another resource
@@ -337,7 +338,7 @@ void HTMLScriptRunner::runScript(Element* script, const TextPosition& scriptStar
         ASSERT(scriptLoader->isParserInserted());
 
         if (!isExecutingScript())
-            Microtask::performCheckpoint();
+            Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());
 
         InsertionPointRecord insertionPointRecord(m_host->inputStream());
         NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);",Chrome,dff368031150a1033a1a3c913f8857679a0279be,e073acb8522a8f7fb8af7d2ee4c34f39a7d45a12,1,"void HTMLScriptRunner::runScript(Element* script, const TextPosition& scriptStartPosition)
{
    ASSERT(m_document);
    ASSERT(!hasParserBlockingScript());
    {
        ScriptLoader* scriptLoader = toScriptLoaderIfPossible(script);

        // This contains both and ASSERTION and a null check since we should not
        // be getting into the case of a null script element, but seem to be from
        // time to time. The assertion is left in to help find those cases and
        // is being tracked by <https://bugs.webkit.org/show_bug.cgi?id=60559>.
        ASSERT(scriptLoader);
        if (!scriptLoader)
            return;

         ASSERT(scriptLoader->isParserInserted());
 
         if (!isExecutingScript())
//flaw_line_below:
            Microtask::performCheckpoint();
//fix_flaw_line_below:
//            Microtask::performCheckpoint(V8PerIsolateData::mainThreadIsolate());
 
         InsertionPointRecord insertionPointRecord(m_host->inputStream());
         NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);

        scriptLoader->prepareScript(scriptStartPosition);

        if (!scriptLoader->willBeParserExecuted())
            return;

        if (scriptLoader->willExecuteWhenDocumentFinishedParsing()) {
            requestDeferredScript(script);
        } else if (scriptLoader->readyToBeParserExecuted()) {
            if (m_scriptNestingLevel == 1) {
                m_parserBlockingScript.setElement(script);
                m_parserBlockingScript.setStartingPosition(scriptStartPosition);
            } else {
                ScriptSourceCode sourceCode(script->textContent(), documentURLForScriptExecution(m_document), scriptStartPosition);
                scriptLoader->executeScript(sourceCode);
            }
        } else {
            requestParsingBlockingScript(script);
        }
    }
}
"
8105,185841,,Remote,Not required,,CVE-2015-1278,https://www.cvedetails.com/cve/CVE-2015-1278/,CWE-254,Medium,,Partial,,2015-07-22,4.3,"content/browser/web_contents/web_contents_impl.cc in Google Chrome before 44.0.2403.89 does not ensure that a PDF document's modal dialog is closed upon navigation to an interstitial page, which allows remote attackers to spoof URLs via a crafted document, as demonstrated by the alert_dialog.pdf document.",2018-10-30,,1,https://github.com/chromium/chromium/commit/784f56a9c97a838448dd23f9bdc7c05fe8e639b3,784f56a9c97a838448dd23f9bdc7c05fe8e639b3,"Correctly reset FP in RFHI whenever origin changes

Bug: 713364
Change-Id: Id8bb923750e20f3db6fc9358b1d44120513ac95f

CQ_INCLUDE_TRYBOTS=master.tryserver.chromium.linux:linux_site_isolation

Change-Id: Id8bb923750e20f3db6fc9358b1d44120513ac95f
Reviewed-on: https://chromium-review.googlesource.com/482380
Commit-Queue: Ian Clelland <iclelland@chromium.org>
Reviewed-by: Charles Reis <creis@chromium.org>
Cr-Commit-Position: refs/heads/master@{#466778}",1,content/browser/frame_host/navigator_impl.cc,"{""sha"": ""c677f372f5767093b64cb134621ef84a3f4c3e10"", ""filename"": ""content/browser/frame_host/navigator_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/navigator_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/navigator_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/navigator_impl.cc?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -673,7 +673,7 @@ void NavigatorImpl::DidNavigate(\n \n   // After setting the last committed origin, reset the feature policy in the\n   // RenderFrameHost to a blank policy based on the parent frame.\n-  if (did_navigate && !is_navigation_within_page)\n+  if (!is_navigation_within_page)\n     render_frame_host->ResetFeaturePolicy();\n \n   // Send notification about committed provisional loads. This notification is""}<_**next**_>{""sha"": ""c0b0d8df6f61cbc0c575a175cabfe66137c4f2e4"", ""filename"": ""content/browser/frame_host/navigator_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 6, ""changes"": 31, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/navigator_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/navigator_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/navigator_impl_unittest.cc?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -1251,15 +1251,14 @@ TEST_F(NavigatorTestWithBrowserSideNavigation,\n   contents()->NavigateAndCommit(kUrl1);\n \n   // Check the feature policy before navigation.\n-  FeaturePolicy* original_feature_policy =\n-      main_test_rfh()->get_feature_policy();\n+  FeaturePolicy* original_feature_policy = main_test_rfh()->feature_policy();\n   ASSERT_TRUE(original_feature_policy);\n \n   // Navigate to the new URL.\n   contents()->NavigateAndCommit(kUrl2);\n \n   // Check the feature policy after navigation.\n-  FeaturePolicy* final_feature_policy = main_test_rfh()->get_feature_policy();\n+  FeaturePolicy* final_feature_policy = main_test_rfh()->feature_policy();\n   ASSERT_TRUE(final_feature_policy);\n   ASSERT_NE(original_feature_policy, final_feature_policy);\n }\n@@ -1274,16 +1273,36 @@ TEST_F(NavigatorTestWithBrowserSideNavigation,\n   contents()->NavigateAndCommit(kUrl1);\n \n   // Check the feature policy before navigation.\n-  FeaturePolicy* original_feature_policy =\n-      main_test_rfh()->get_feature_policy();\n+  FeaturePolicy* original_feature_policy = main_test_rfh()->feature_policy();\n   ASSERT_TRUE(original_feature_policy);\n \n   // Navigate to the new URL.\n   contents()->NavigateAndCommit(kUrl2);\n \n   // Check the feature policy after navigation.\n-  FeaturePolicy* final_feature_policy = main_test_rfh()->get_feature_policy();\n+  FeaturePolicy* final_feature_policy = main_test_rfh()->feature_policy();\n   ASSERT_EQ(original_feature_policy, final_feature_policy);\n }\n \n+// Feature Policy: Test that the feature policy is set correctly when inserting\n+// a new child frame.\n+TEST_F(NavigatorTestWithBrowserSideNavigation, FeaturePolicyNewChild) {\n+  const GURL kUrl1(\""http://www.chromium.org/\"");\n+  const GURL kUrl2(\""http://www.chromium.org/Home\"");\n+\n+  contents()->NavigateAndCommit(kUrl1);\n+\n+  TestRenderFrameHost* subframe_rfh =\n+      contents()->GetMainFrame()->AppendChild(\""child\"");\n+  // Simulate the navigation triggered by inserting a child frame into a page.\n+  FrameHostMsg_DidCommitProvisionalLoad_Params params;\n+  InitNavigateParams(&params, 1, false, kUrl2,\n+                     ui::PAGE_TRANSITION_AUTO_SUBFRAME);\n+  subframe_rfh->SendNavigateWithParams(&params);\n+\n+  FeaturePolicy* subframe_feature_policy = subframe_rfh->feature_policy();\n+  ASSERT_TRUE(subframe_feature_policy);\n+  ASSERT_FALSE(subframe_feature_policy->origin_.unique());\n+}\n+\n }  // namespace content""}<_**next**_>{""sha"": ""ad8c146eec85b3d4bdbc4b141e8b6d27589b4af3"", ""filename"": ""content/browser/frame_host/render_frame_host_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/render_frame_host_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/render_frame_host_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_impl.cc?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -3626,7 +3626,7 @@ void RenderFrameHostImpl::DeleteWebBluetoothService(\n void RenderFrameHostImpl::ResetFeaturePolicy() {\n   RenderFrameHostImpl* parent_frame_host = GetParent();\n   const FeaturePolicy* parent_policy =\n-      parent_frame_host ? parent_frame_host->get_feature_policy() : nullptr;\n+      parent_frame_host ? parent_frame_host->feature_policy() : nullptr;\n   ParsedFeaturePolicyHeader container_policy =\n       frame_tree_node()->effective_container_policy();\n   feature_policy_ = FeaturePolicy::CreateFromParentPolicy(""}<_**next**_>{""sha"": ""183c3e5d95b54a5f1bb6f45555fd12cad0da4ee2"", ""filename"": ""content/browser/frame_host/render_frame_host_impl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/render_frame_host_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/render_frame_host_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_impl.h?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -585,7 +585,7 @@ class CONTENT_EXPORT RenderFrameHostImpl\n   void ResetLoadingState();\n \n   // Returns the feature policy which should be enforced on this RenderFrame.\n-  FeaturePolicy* get_feature_policy() { return feature_policy_.get(); }\n+  FeaturePolicy* feature_policy() { return feature_policy_.get(); }\n \n   // Clears any existing policy and constructs a new policy for this frame,\n   // based on its parent frame.""}<_**next**_>{""sha"": ""4f9be78420786fcaeb7d75048c86c5e012108bb6"", ""filename"": ""content/common/feature_policy/feature_policy.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/common/feature_policy/feature_policy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/common/feature_policy/feature_policy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/feature_policy/feature_policy.h?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -10,6 +10,7 @@\n #include <string>\n #include <vector>\n \n+#include \""base/gtest_prod_util.h\""\n #include \""base/macros.h\""\n #include \""content/common/content_export.h\""\n #include \""third_party/WebKit/public/platform/WebFeaturePolicy.h\""\n@@ -177,6 +178,8 @@ class CONTENT_EXPORT FeaturePolicy : public blink::WebFeaturePolicy {\n \n  private:\n   friend class FeaturePolicyTest;\n+  FRIEND_TEST_ALL_PREFIXES(NavigatorTestWithBrowserSideNavigation,\n+                           FeaturePolicyNewChild);\n \n   explicit FeaturePolicy(url::Origin origin);\n   FeaturePolicy(url::Origin origin, const FeatureList& feature_list);""}<_**next**_>{""sha"": ""ece1a637fb4177cc712b0a947f755e58d90785ca"", ""filename"": ""content/test/test_render_view_host.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/test/test_render_view_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/test/test_render_view_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/test/test_render_view_host.cc?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -41,6 +41,7 @@ void InitNavigateParams(FrameHostMsg_DidCommitProvisionalLoad_Params* params,\n                         ui::PageTransition transition) {\n   params->nav_entry_id = nav_entry_id;\n   params->url = url;\n+  params->origin = url::Origin(url);\n   params->referrer = Referrer();\n   params->transition = transition;\n   params->redirects = std::vector<GURL>();""}","void NavigatorImpl::DidNavigate(
    RenderFrameHostImpl* render_frame_host,
    const FrameHostMsg_DidCommitProvisionalLoad_Params& params,
    std::unique_ptr<NavigationHandleImpl> navigation_handle) {
  FrameTree* frame_tree = render_frame_host->frame_tree_node()->frame_tree();
  bool oopifs_possible = SiteIsolationPolicy::AreCrossProcessFramesPossible();

  bool is_navigation_within_page = controller_->IsURLInPageNavigation(
      params.url, params.origin, params.was_within_same_document,
      render_frame_host);

  if (is_navigation_within_page &&
      render_frame_host !=
          render_frame_host->frame_tree_node()
              ->render_manager()
              ->current_frame_host()) {
    bad_message::ReceivedBadMessage(render_frame_host->GetProcess(),
                                    bad_message::NI_IN_PAGE_NAVIGATION);
    is_navigation_within_page = false;
  }

  if (ui::PageTransitionIsMainFrame(params.transition)) {
    if (delegate_) {
      if (delegate_->CanOverscrollContent()) {
        if (!params.was_within_same_document)
          controller_->TakeScreenshot();
      }

      delegate_->DidNavigateMainFramePreCommit(is_navigation_within_page);
    }

    if (!oopifs_possible)
      frame_tree->root()->render_manager()->DidNavigateFrame(
          render_frame_host, params.gesture == NavigationGestureUser);
  }

  render_frame_host->frame_tree_node()->SetCurrentOrigin(
      params.origin, params.has_potentially_trustworthy_unique_origin);

  render_frame_host->frame_tree_node()->SetInsecureRequestPolicy(
      params.insecure_request_policy);

  if (!is_navigation_within_page) {
    render_frame_host->ResetContentSecurityPolicies();
    render_frame_host->frame_tree_node()->ResetCspHeaders();
    render_frame_host->frame_tree_node()->ResetFeaturePolicyHeader();
  }

  if (oopifs_possible) {
    FrameTreeNode* frame = render_frame_host->frame_tree_node();
    frame->render_manager()->DidNavigateFrame(
        render_frame_host, params.gesture == NavigationGestureUser);
  }

  SiteInstanceImpl* site_instance = render_frame_host->GetSiteInstance();
  if (!site_instance->HasSite() && ShouldAssignSiteForURL(params.url) &&
      !params.url_is_unreachable) {
    site_instance->SetSite(params.url);
  }

  if (ui::PageTransitionIsMainFrame(params.transition) && delegate_)
    delegate_->SetMainFrameMimeType(params.contents_mime_type);

  int old_entry_count = controller_->GetEntryCount();
  LoadCommittedDetails details;
  bool did_navigate = controller_->RendererDidNavigate(
      render_frame_host, params, &details, is_navigation_within_page,
      navigation_handle.get());

  if (old_entry_count != controller_->GetEntryCount() ||
      details.previous_entry_index !=
          controller_->GetLastCommittedEntryIndex()) {
    frame_tree->root()->render_manager()->SendPageMessage(
        new PageMsg_SetHistoryOffsetAndLength(
            MSG_ROUTING_NONE, controller_->GetLastCommittedEntryIndex(),
            controller_->GetEntryCount()),
        site_instance);
  }

  render_frame_host->frame_tree_node()->SetCurrentURL(params.url);
  render_frame_host->SetLastCommittedOrigin(params.origin);

  if (!params.url_is_unreachable)
    render_frame_host->set_last_successful_url(params.url);
 
  if (!is_navigation_within_page)
     render_frame_host->ResetFeaturePolicy();
 
  if (details.type != NAVIGATION_TYPE_NAV_IGNORE && delegate_) {
    DCHECK_EQ(!render_frame_host->GetParent(),
              did_navigate ? details.is_main_frame : false);
    navigation_handle->DidCommitNavigation(params, did_navigate,
                                           details.did_replace_entry,
                                           details.previous_url, details.type,
                                           render_frame_host);
    navigation_handle.reset();
  }

  if (!did_navigate)
    return;  // No navigation happened.


  RecordNavigationMetrics(details, params, site_instance);

  if (delegate_) {
    if (details.is_main_frame) {
      delegate_->DidNavigateMainFramePostCommit(render_frame_host,
                                                details, params);
    }

    delegate_->DidNavigateAnyFramePostCommit(
        render_frame_host, details, params);
  }
}
","void NavigatorImpl::DidNavigate(
    RenderFrameHostImpl* render_frame_host,
    const FrameHostMsg_DidCommitProvisionalLoad_Params& params,
    std::unique_ptr<NavigationHandleImpl> navigation_handle) {
  FrameTree* frame_tree = render_frame_host->frame_tree_node()->frame_tree();
  bool oopifs_possible = SiteIsolationPolicy::AreCrossProcessFramesPossible();

  bool is_navigation_within_page = controller_->IsURLInPageNavigation(
      params.url, params.origin, params.was_within_same_document,
      render_frame_host);

  if (is_navigation_within_page &&
      render_frame_host !=
          render_frame_host->frame_tree_node()
              ->render_manager()
              ->current_frame_host()) {
    bad_message::ReceivedBadMessage(render_frame_host->GetProcess(),
                                    bad_message::NI_IN_PAGE_NAVIGATION);
    is_navigation_within_page = false;
  }

  if (ui::PageTransitionIsMainFrame(params.transition)) {
    if (delegate_) {
      if (delegate_->CanOverscrollContent()) {
        if (!params.was_within_same_document)
          controller_->TakeScreenshot();
      }

      delegate_->DidNavigateMainFramePreCommit(is_navigation_within_page);
    }

    if (!oopifs_possible)
      frame_tree->root()->render_manager()->DidNavigateFrame(
          render_frame_host, params.gesture == NavigationGestureUser);
  }

  render_frame_host->frame_tree_node()->SetCurrentOrigin(
      params.origin, params.has_potentially_trustworthy_unique_origin);

  render_frame_host->frame_tree_node()->SetInsecureRequestPolicy(
      params.insecure_request_policy);

  if (!is_navigation_within_page) {
    render_frame_host->ResetContentSecurityPolicies();
    render_frame_host->frame_tree_node()->ResetCspHeaders();
    render_frame_host->frame_tree_node()->ResetFeaturePolicyHeader();
  }

  if (oopifs_possible) {
    FrameTreeNode* frame = render_frame_host->frame_tree_node();
    frame->render_manager()->DidNavigateFrame(
        render_frame_host, params.gesture == NavigationGestureUser);
  }

  SiteInstanceImpl* site_instance = render_frame_host->GetSiteInstance();
  if (!site_instance->HasSite() && ShouldAssignSiteForURL(params.url) &&
      !params.url_is_unreachable) {
    site_instance->SetSite(params.url);
  }

  if (ui::PageTransitionIsMainFrame(params.transition) && delegate_)
    delegate_->SetMainFrameMimeType(params.contents_mime_type);

  int old_entry_count = controller_->GetEntryCount();
  LoadCommittedDetails details;
  bool did_navigate = controller_->RendererDidNavigate(
      render_frame_host, params, &details, is_navigation_within_page,
      navigation_handle.get());

  if (old_entry_count != controller_->GetEntryCount() ||
      details.previous_entry_index !=
          controller_->GetLastCommittedEntryIndex()) {
    frame_tree->root()->render_manager()->SendPageMessage(
        new PageMsg_SetHistoryOffsetAndLength(
            MSG_ROUTING_NONE, controller_->GetLastCommittedEntryIndex(),
            controller_->GetEntryCount()),
        site_instance);
  }

  render_frame_host->frame_tree_node()->SetCurrentURL(params.url);
  render_frame_host->SetLastCommittedOrigin(params.origin);

  if (!params.url_is_unreachable)
    render_frame_host->set_last_successful_url(params.url);
 
  if (did_navigate && !is_navigation_within_page)
     render_frame_host->ResetFeaturePolicy();
 
  if (details.type != NAVIGATION_TYPE_NAV_IGNORE && delegate_) {
    DCHECK_EQ(!render_frame_host->GetParent(),
              did_navigate ? details.is_main_frame : false);
    navigation_handle->DidCommitNavigation(params, did_navigate,
                                           details.did_replace_entry,
                                           details.previous_url, details.type,
                                           render_frame_host);
    navigation_handle.reset();
  }

  if (!did_navigate)
    return;  // No navigation happened.


  RecordNavigationMetrics(details, params, site_instance);

  if (delegate_) {
    if (details.is_main_frame) {
      delegate_->DidNavigateMainFramePostCommit(render_frame_host,
                                                details, params);
    }

    delegate_->DidNavigateAnyFramePostCommit(
        render_frame_host, details, params);
  }
}
",C,"  if (!is_navigation_within_page)
","  if (did_navigate && !is_navigation_within_page)
",,"@@ -673,7 +673,7 @@ void NavigatorImpl::DidNavigate(
 
   // After setting the last committed origin, reset the feature policy in the
   // RenderFrameHost to a blank policy based on the parent frame.
-  if (did_navigate && !is_navigation_within_page)
+  if (!is_navigation_within_page)
     render_frame_host->ResetFeaturePolicy();
 
   // Send notification about committed provisional loads. This notification is",Chrome,784f56a9c97a838448dd23f9bdc7c05fe8e639b3,858c1cc4ded16a2365425fa416bb90d3c2d3bf85,1,"void NavigatorImpl::DidNavigate(
    RenderFrameHostImpl* render_frame_host,
    const FrameHostMsg_DidCommitProvisionalLoad_Params& params,
    std::unique_ptr<NavigationHandleImpl> navigation_handle) {
  FrameTree* frame_tree = render_frame_host->frame_tree_node()->frame_tree();
  bool oopifs_possible = SiteIsolationPolicy::AreCrossProcessFramesPossible();

  bool is_navigation_within_page = controller_->IsURLInPageNavigation(
      params.url, params.origin, params.was_within_same_document,
      render_frame_host);

  // If a frame claims it navigated within page, it must be the current frame,
  // not a pending one.
  if (is_navigation_within_page &&
      render_frame_host !=
          render_frame_host->frame_tree_node()
              ->render_manager()
              ->current_frame_host()) {
    bad_message::ReceivedBadMessage(render_frame_host->GetProcess(),
                                    bad_message::NI_IN_PAGE_NAVIGATION);
    is_navigation_within_page = false;
  }

  if (ui::PageTransitionIsMainFrame(params.transition)) {
    if (delegate_) {
      // When overscroll navigation gesture is enabled, a screenshot of the page
      // in its current state is taken so that it can be used during the
      // nav-gesture. It is necessary to take the screenshot here, before
      // calling RenderFrameHostManager::DidNavigateMainFrame, because that can
      // change WebContents::GetRenderViewHost to return the new host, instead
      // of the one that may have just been swapped out.
      if (delegate_->CanOverscrollContent()) {
        // Don't take screenshots if we are staying on the same document. We
        // want same-document navigations to be super fast, and taking a
        // screenshot currently blocks GPU for a longer time than we are willing
        // to tolerate in this use case.
        if (!params.was_within_same_document)
          controller_->TakeScreenshot();
      }

      // Run tasks that must execute just before the commit.
      delegate_->DidNavigateMainFramePreCommit(is_navigation_within_page);
    }

    if (!oopifs_possible)
      frame_tree->root()->render_manager()->DidNavigateFrame(
          render_frame_host, params.gesture == NavigationGestureUser);
  }

  // Save the origin of the new page.  Do this before calling
  // DidNavigateFrame(), because the origin needs to be included in the SwapOut
  // message, which is sent inside DidNavigateFrame().  SwapOut needs the
  // origin because it creates a RenderFrameProxy that needs this to initialize
  // its security context. This origin will also be sent to RenderFrameProxies
  // created via mojom::Renderer::CreateView and
  // mojom::Renderer::CreateFrameProxy.
  render_frame_host->frame_tree_node()->SetCurrentOrigin(
      params.origin, params.has_potentially_trustworthy_unique_origin);

  render_frame_host->frame_tree_node()->SetInsecureRequestPolicy(
      params.insecure_request_policy);

  // Navigating to a new location means a new, fresh set of http headers and/or
  // <meta> elements - we need to reset CSP and Feature Policy.
  if (!is_navigation_within_page) {
    render_frame_host->ResetContentSecurityPolicies();
    render_frame_host->frame_tree_node()->ResetCspHeaders();
    render_frame_host->frame_tree_node()->ResetFeaturePolicyHeader();
  }

  // When using --site-per-process, we notify the RFHM for all navigations,
  // not just main frame navigations.
  if (oopifs_possible) {
    FrameTreeNode* frame = render_frame_host->frame_tree_node();
    frame->render_manager()->DidNavigateFrame(
        render_frame_host, params.gesture == NavigationGestureUser);
  }

  // Update the site of the SiteInstance if it doesn't have one yet, unless
  // assigning a site is not necessary for this URL or the commit was for an
  // error page.  In that case, the SiteInstance can still be considered unused
  // until a navigation to a real page.
  SiteInstanceImpl* site_instance = render_frame_host->GetSiteInstance();
  if (!site_instance->HasSite() && ShouldAssignSiteForURL(params.url) &&
      !params.url_is_unreachable) {
    site_instance->SetSite(params.url);
  }

  // Need to update MIME type here because it's referred to in
  // UpdateNavigationCommands() called by RendererDidNavigate() to
  // determine whether or not to enable the encoding menu.
  // It's updated only for the main frame. For a subframe,
  // RenderView::UpdateURL does not set params.contents_mime_type.
  // (see http://code.google.com/p/chromium/issues/detail?id=2929 )
  // TODO(jungshik): Add a test for the encoding menu to avoid
  // regressing it again.
  // TODO(nasko): Verify the correctness of the above comment, since some of the
  // code doesn't exist anymore. Also, move this code in the
  // PageTransitionIsMainFrame code block above.
  if (ui::PageTransitionIsMainFrame(params.transition) && delegate_)
    delegate_->SetMainFrameMimeType(params.contents_mime_type);

  int old_entry_count = controller_->GetEntryCount();
  LoadCommittedDetails details;
  bool did_navigate = controller_->RendererDidNavigate(
      render_frame_host, params, &details, is_navigation_within_page,
      navigation_handle.get());

  // If the history length and/or offset changed, update other renderers in the
  // FrameTree.
  if (old_entry_count != controller_->GetEntryCount() ||
      details.previous_entry_index !=
          controller_->GetLastCommittedEntryIndex()) {
    frame_tree->root()->render_manager()->SendPageMessage(
        new PageMsg_SetHistoryOffsetAndLength(
            MSG_ROUTING_NONE, controller_->GetLastCommittedEntryIndex(),
            controller_->GetEntryCount()),
        site_instance);
  }

  // Keep track of the last committed URL and origin in the RenderFrameHost
  // itself.  These allow GetLastCommittedURL and GetLastCommittedOrigin to
  // stay correct even if the render_frame_host later becomes pending deletion.
  // The URL is set regardless of whether it's for a net error or not.
  render_frame_host->frame_tree_node()->SetCurrentURL(params.url);
  render_frame_host->SetLastCommittedOrigin(params.origin);

  // Separately, update the frame's last successful URL except for net error
  // pages, since those do not end up in the correct process after transfers
  // (see https://crbug.com/560511).  Instead, the next cross-process navigation
  // or transfer should decide whether to swap as if the net error had not
  // occurred.
  // TODO(creis): Remove this block and always set the URL once transfers handle
  // network errors or PlzNavigate is enabled.  See https://crbug.com/588314.
  if (!params.url_is_unreachable)
    render_frame_host->set_last_successful_url(params.url);
 
   // After setting the last committed origin, reset the feature policy in the
   // RenderFrameHost to a blank policy based on the parent frame.
//flaw_line_below:
  if (did_navigate && !is_navigation_within_page)
//fix_flaw_line_below:
//  if (!is_navigation_within_page)
     render_frame_host->ResetFeaturePolicy();
 
   // Send notification about committed provisional loads. This notification is
  // different from the NAV_ENTRY_COMMITTED notification which doesn't include
  // the actual URL navigated to and isn't sent for AUTO_SUBFRAME navigations.
  if (details.type != NAVIGATION_TYPE_NAV_IGNORE && delegate_) {
    DCHECK_EQ(!render_frame_host->GetParent(),
              did_navigate ? details.is_main_frame : false);
    navigation_handle->DidCommitNavigation(params, did_navigate,
                                           details.did_replace_entry,
                                           details.previous_url, details.type,
                                           render_frame_host);
    navigation_handle.reset();
  }

  if (!did_navigate)
    return;  // No navigation happened.

  // DO NOT ADD MORE STUFF TO THIS FUNCTION! Your component should either listen
  // for the appropriate notification (best) or you can add it to
  // DidNavigateMainFramePostCommit / DidNavigateAnyFramePostCommit (only if
  // necessary, please).

  // TODO(carlosk): Move this out when PlzNavigate implementation properly calls
  // the observer methods.
  RecordNavigationMetrics(details, params, site_instance);

  // Run post-commit tasks.
  if (delegate_) {
    if (details.is_main_frame) {
      delegate_->DidNavigateMainFramePostCommit(render_frame_host,
                                                details, params);
    }

    delegate_->DidNavigateAnyFramePostCommit(
        render_frame_host, details, params);
  }
}
"
8106,185842,,Remote,Not required,,CVE-2015-1278,https://www.cvedetails.com/cve/CVE-2015-1278/,CWE-254,Medium,,Partial,,2015-07-22,4.3,"content/browser/web_contents/web_contents_impl.cc in Google Chrome before 44.0.2403.89 does not ensure that a PDF document's modal dialog is closed upon navigation to an interstitial page, which allows remote attackers to spoof URLs via a crafted document, as demonstrated by the alert_dialog.pdf document.",2018-10-30,,1,https://github.com/chromium/chromium/commit/784f56a9c97a838448dd23f9bdc7c05fe8e639b3,784f56a9c97a838448dd23f9bdc7c05fe8e639b3,"Correctly reset FP in RFHI whenever origin changes

Bug: 713364
Change-Id: Id8bb923750e20f3db6fc9358b1d44120513ac95f

CQ_INCLUDE_TRYBOTS=master.tryserver.chromium.linux:linux_site_isolation

Change-Id: Id8bb923750e20f3db6fc9358b1d44120513ac95f
Reviewed-on: https://chromium-review.googlesource.com/482380
Commit-Queue: Ian Clelland <iclelland@chromium.org>
Reviewed-by: Charles Reis <creis@chromium.org>
Cr-Commit-Position: refs/heads/master@{#466778}",1,content/browser/frame_host/render_frame_host_impl.cc,"{""sha"": ""c677f372f5767093b64cb134621ef84a3f4c3e10"", ""filename"": ""content/browser/frame_host/navigator_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/navigator_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/navigator_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/navigator_impl.cc?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -673,7 +673,7 @@ void NavigatorImpl::DidNavigate(\n \n   // After setting the last committed origin, reset the feature policy in the\n   // RenderFrameHost to a blank policy based on the parent frame.\n-  if (did_navigate && !is_navigation_within_page)\n+  if (!is_navigation_within_page)\n     render_frame_host->ResetFeaturePolicy();\n \n   // Send notification about committed provisional loads. This notification is""}<_**next**_>{""sha"": ""c0b0d8df6f61cbc0c575a175cabfe66137c4f2e4"", ""filename"": ""content/browser/frame_host/navigator_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 6, ""changes"": 31, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/navigator_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/navigator_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/navigator_impl_unittest.cc?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -1251,15 +1251,14 @@ TEST_F(NavigatorTestWithBrowserSideNavigation,\n   contents()->NavigateAndCommit(kUrl1);\n \n   // Check the feature policy before navigation.\n-  FeaturePolicy* original_feature_policy =\n-      main_test_rfh()->get_feature_policy();\n+  FeaturePolicy* original_feature_policy = main_test_rfh()->feature_policy();\n   ASSERT_TRUE(original_feature_policy);\n \n   // Navigate to the new URL.\n   contents()->NavigateAndCommit(kUrl2);\n \n   // Check the feature policy after navigation.\n-  FeaturePolicy* final_feature_policy = main_test_rfh()->get_feature_policy();\n+  FeaturePolicy* final_feature_policy = main_test_rfh()->feature_policy();\n   ASSERT_TRUE(final_feature_policy);\n   ASSERT_NE(original_feature_policy, final_feature_policy);\n }\n@@ -1274,16 +1273,36 @@ TEST_F(NavigatorTestWithBrowserSideNavigation,\n   contents()->NavigateAndCommit(kUrl1);\n \n   // Check the feature policy before navigation.\n-  FeaturePolicy* original_feature_policy =\n-      main_test_rfh()->get_feature_policy();\n+  FeaturePolicy* original_feature_policy = main_test_rfh()->feature_policy();\n   ASSERT_TRUE(original_feature_policy);\n \n   // Navigate to the new URL.\n   contents()->NavigateAndCommit(kUrl2);\n \n   // Check the feature policy after navigation.\n-  FeaturePolicy* final_feature_policy = main_test_rfh()->get_feature_policy();\n+  FeaturePolicy* final_feature_policy = main_test_rfh()->feature_policy();\n   ASSERT_EQ(original_feature_policy, final_feature_policy);\n }\n \n+// Feature Policy: Test that the feature policy is set correctly when inserting\n+// a new child frame.\n+TEST_F(NavigatorTestWithBrowserSideNavigation, FeaturePolicyNewChild) {\n+  const GURL kUrl1(\""http://www.chromium.org/\"");\n+  const GURL kUrl2(\""http://www.chromium.org/Home\"");\n+\n+  contents()->NavigateAndCommit(kUrl1);\n+\n+  TestRenderFrameHost* subframe_rfh =\n+      contents()->GetMainFrame()->AppendChild(\""child\"");\n+  // Simulate the navigation triggered by inserting a child frame into a page.\n+  FrameHostMsg_DidCommitProvisionalLoad_Params params;\n+  InitNavigateParams(&params, 1, false, kUrl2,\n+                     ui::PAGE_TRANSITION_AUTO_SUBFRAME);\n+  subframe_rfh->SendNavigateWithParams(&params);\n+\n+  FeaturePolicy* subframe_feature_policy = subframe_rfh->feature_policy();\n+  ASSERT_TRUE(subframe_feature_policy);\n+  ASSERT_FALSE(subframe_feature_policy->origin_.unique());\n+}\n+\n }  // namespace content""}<_**next**_>{""sha"": ""ad8c146eec85b3d4bdbc4b141e8b6d27589b4af3"", ""filename"": ""content/browser/frame_host/render_frame_host_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/render_frame_host_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/render_frame_host_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_impl.cc?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -3626,7 +3626,7 @@ void RenderFrameHostImpl::DeleteWebBluetoothService(\n void RenderFrameHostImpl::ResetFeaturePolicy() {\n   RenderFrameHostImpl* parent_frame_host = GetParent();\n   const FeaturePolicy* parent_policy =\n-      parent_frame_host ? parent_frame_host->get_feature_policy() : nullptr;\n+      parent_frame_host ? parent_frame_host->feature_policy() : nullptr;\n   ParsedFeaturePolicyHeader container_policy =\n       frame_tree_node()->effective_container_policy();\n   feature_policy_ = FeaturePolicy::CreateFromParentPolicy(""}<_**next**_>{""sha"": ""183c3e5d95b54a5f1bb6f45555fd12cad0da4ee2"", ""filename"": ""content/browser/frame_host/render_frame_host_impl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/render_frame_host_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/render_frame_host_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_impl.h?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -585,7 +585,7 @@ class CONTENT_EXPORT RenderFrameHostImpl\n   void ResetLoadingState();\n \n   // Returns the feature policy which should be enforced on this RenderFrame.\n-  FeaturePolicy* get_feature_policy() { return feature_policy_.get(); }\n+  FeaturePolicy* feature_policy() { return feature_policy_.get(); }\n \n   // Clears any existing policy and constructs a new policy for this frame,\n   // based on its parent frame.""}<_**next**_>{""sha"": ""4f9be78420786fcaeb7d75048c86c5e012108bb6"", ""filename"": ""content/common/feature_policy/feature_policy.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/common/feature_policy/feature_policy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/common/feature_policy/feature_policy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/feature_policy/feature_policy.h?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -10,6 +10,7 @@\n #include <string>\n #include <vector>\n \n+#include \""base/gtest_prod_util.h\""\n #include \""base/macros.h\""\n #include \""content/common/content_export.h\""\n #include \""third_party/WebKit/public/platform/WebFeaturePolicy.h\""\n@@ -177,6 +178,8 @@ class CONTENT_EXPORT FeaturePolicy : public blink::WebFeaturePolicy {\n \n  private:\n   friend class FeaturePolicyTest;\n+  FRIEND_TEST_ALL_PREFIXES(NavigatorTestWithBrowserSideNavigation,\n+                           FeaturePolicyNewChild);\n \n   explicit FeaturePolicy(url::Origin origin);\n   FeaturePolicy(url::Origin origin, const FeatureList& feature_list);""}<_**next**_>{""sha"": ""ece1a637fb4177cc712b0a947f755e58d90785ca"", ""filename"": ""content/test/test_render_view_host.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/test/test_render_view_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/test/test_render_view_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/test/test_render_view_host.cc?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -41,6 +41,7 @@ void InitNavigateParams(FrameHostMsg_DidCommitProvisionalLoad_Params* params,\n                         ui::PageTransition transition) {\n   params->nav_entry_id = nav_entry_id;\n   params->url = url;\n+  params->origin = url::Origin(url);\n   params->referrer = Referrer();\n   params->transition = transition;\n   params->redirects = std::vector<GURL>();""}"," void RenderFrameHostImpl::ResetFeaturePolicy() {
   RenderFrameHostImpl* parent_frame_host = GetParent();
   const FeaturePolicy* parent_policy =
      parent_frame_host ? parent_frame_host->feature_policy() : nullptr;
   ParsedFeaturePolicyHeader container_policy =
       frame_tree_node()->effective_container_policy();
   feature_policy_ = FeaturePolicy::CreateFromParentPolicy(
      parent_policy, container_policy, last_committed_origin_);
}
"," void RenderFrameHostImpl::ResetFeaturePolicy() {
   RenderFrameHostImpl* parent_frame_host = GetParent();
   const FeaturePolicy* parent_policy =
      parent_frame_host ? parent_frame_host->get_feature_policy() : nullptr;
   ParsedFeaturePolicyHeader container_policy =
       frame_tree_node()->effective_container_policy();
   feature_policy_ = FeaturePolicy::CreateFromParentPolicy(
      parent_policy, container_policy, last_committed_origin_);
}
",C,"      parent_frame_host ? parent_frame_host->feature_policy() : nullptr;
","      parent_frame_host ? parent_frame_host->get_feature_policy() : nullptr;
",,"@@ -3626,7 +3626,7 @@ void RenderFrameHostImpl::DeleteWebBluetoothService(
 void RenderFrameHostImpl::ResetFeaturePolicy() {
   RenderFrameHostImpl* parent_frame_host = GetParent();
   const FeaturePolicy* parent_policy =
-      parent_frame_host ? parent_frame_host->get_feature_policy() : nullptr;
+      parent_frame_host ? parent_frame_host->feature_policy() : nullptr;
   ParsedFeaturePolicyHeader container_policy =
       frame_tree_node()->effective_container_policy();
   feature_policy_ = FeaturePolicy::CreateFromParentPolicy(",Chrome,784f56a9c97a838448dd23f9bdc7c05fe8e639b3,858c1cc4ded16a2365425fa416bb90d3c2d3bf85,1," void RenderFrameHostImpl::ResetFeaturePolicy() {
   RenderFrameHostImpl* parent_frame_host = GetParent();
   const FeaturePolicy* parent_policy =
//flaw_line_below:
      parent_frame_host ? parent_frame_host->get_feature_policy() : nullptr;
//fix_flaw_line_below:
//      parent_frame_host ? parent_frame_host->feature_policy() : nullptr;
   ParsedFeaturePolicyHeader container_policy =
       frame_tree_node()->effective_container_policy();
   feature_policy_ = FeaturePolicy::CreateFromParentPolicy(
      parent_policy, container_policy, last_committed_origin_);
}
"
8107,185843,,Remote,Not required,,CVE-2015-1278,https://www.cvedetails.com/cve/CVE-2015-1278/,CWE-254,Medium,,Partial,,2015-07-22,4.3,"content/browser/web_contents/web_contents_impl.cc in Google Chrome before 44.0.2403.89 does not ensure that a PDF document's modal dialog is closed upon navigation to an interstitial page, which allows remote attackers to spoof URLs via a crafted document, as demonstrated by the alert_dialog.pdf document.",2018-10-30,,1,https://github.com/chromium/chromium/commit/784f56a9c97a838448dd23f9bdc7c05fe8e639b3,784f56a9c97a838448dd23f9bdc7c05fe8e639b3,"Correctly reset FP in RFHI whenever origin changes

Bug: 713364
Change-Id: Id8bb923750e20f3db6fc9358b1d44120513ac95f

CQ_INCLUDE_TRYBOTS=master.tryserver.chromium.linux:linux_site_isolation

Change-Id: Id8bb923750e20f3db6fc9358b1d44120513ac95f
Reviewed-on: https://chromium-review.googlesource.com/482380
Commit-Queue: Ian Clelland <iclelland@chromium.org>
Reviewed-by: Charles Reis <creis@chromium.org>
Cr-Commit-Position: refs/heads/master@{#466778}",0,content/test/test_render_view_host.cc,"{""sha"": ""c677f372f5767093b64cb134621ef84a3f4c3e10"", ""filename"": ""content/browser/frame_host/navigator_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/navigator_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/navigator_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/navigator_impl.cc?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -673,7 +673,7 @@ void NavigatorImpl::DidNavigate(\n \n   // After setting the last committed origin, reset the feature policy in the\n   // RenderFrameHost to a blank policy based on the parent frame.\n-  if (did_navigate && !is_navigation_within_page)\n+  if (!is_navigation_within_page)\n     render_frame_host->ResetFeaturePolicy();\n \n   // Send notification about committed provisional loads. This notification is""}<_**next**_>{""sha"": ""c0b0d8df6f61cbc0c575a175cabfe66137c4f2e4"", ""filename"": ""content/browser/frame_host/navigator_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 6, ""changes"": 31, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/navigator_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/navigator_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/navigator_impl_unittest.cc?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -1251,15 +1251,14 @@ TEST_F(NavigatorTestWithBrowserSideNavigation,\n   contents()->NavigateAndCommit(kUrl1);\n \n   // Check the feature policy before navigation.\n-  FeaturePolicy* original_feature_policy =\n-      main_test_rfh()->get_feature_policy();\n+  FeaturePolicy* original_feature_policy = main_test_rfh()->feature_policy();\n   ASSERT_TRUE(original_feature_policy);\n \n   // Navigate to the new URL.\n   contents()->NavigateAndCommit(kUrl2);\n \n   // Check the feature policy after navigation.\n-  FeaturePolicy* final_feature_policy = main_test_rfh()->get_feature_policy();\n+  FeaturePolicy* final_feature_policy = main_test_rfh()->feature_policy();\n   ASSERT_TRUE(final_feature_policy);\n   ASSERT_NE(original_feature_policy, final_feature_policy);\n }\n@@ -1274,16 +1273,36 @@ TEST_F(NavigatorTestWithBrowserSideNavigation,\n   contents()->NavigateAndCommit(kUrl1);\n \n   // Check the feature policy before navigation.\n-  FeaturePolicy* original_feature_policy =\n-      main_test_rfh()->get_feature_policy();\n+  FeaturePolicy* original_feature_policy = main_test_rfh()->feature_policy();\n   ASSERT_TRUE(original_feature_policy);\n \n   // Navigate to the new URL.\n   contents()->NavigateAndCommit(kUrl2);\n \n   // Check the feature policy after navigation.\n-  FeaturePolicy* final_feature_policy = main_test_rfh()->get_feature_policy();\n+  FeaturePolicy* final_feature_policy = main_test_rfh()->feature_policy();\n   ASSERT_EQ(original_feature_policy, final_feature_policy);\n }\n \n+// Feature Policy: Test that the feature policy is set correctly when inserting\n+// a new child frame.\n+TEST_F(NavigatorTestWithBrowserSideNavigation, FeaturePolicyNewChild) {\n+  const GURL kUrl1(\""http://www.chromium.org/\"");\n+  const GURL kUrl2(\""http://www.chromium.org/Home\"");\n+\n+  contents()->NavigateAndCommit(kUrl1);\n+\n+  TestRenderFrameHost* subframe_rfh =\n+      contents()->GetMainFrame()->AppendChild(\""child\"");\n+  // Simulate the navigation triggered by inserting a child frame into a page.\n+  FrameHostMsg_DidCommitProvisionalLoad_Params params;\n+  InitNavigateParams(&params, 1, false, kUrl2,\n+                     ui::PAGE_TRANSITION_AUTO_SUBFRAME);\n+  subframe_rfh->SendNavigateWithParams(&params);\n+\n+  FeaturePolicy* subframe_feature_policy = subframe_rfh->feature_policy();\n+  ASSERT_TRUE(subframe_feature_policy);\n+  ASSERT_FALSE(subframe_feature_policy->origin_.unique());\n+}\n+\n }  // namespace content""}<_**next**_>{""sha"": ""ad8c146eec85b3d4bdbc4b141e8b6d27589b4af3"", ""filename"": ""content/browser/frame_host/render_frame_host_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/render_frame_host_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/render_frame_host_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_impl.cc?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -3626,7 +3626,7 @@ void RenderFrameHostImpl::DeleteWebBluetoothService(\n void RenderFrameHostImpl::ResetFeaturePolicy() {\n   RenderFrameHostImpl* parent_frame_host = GetParent();\n   const FeaturePolicy* parent_policy =\n-      parent_frame_host ? parent_frame_host->get_feature_policy() : nullptr;\n+      parent_frame_host ? parent_frame_host->feature_policy() : nullptr;\n   ParsedFeaturePolicyHeader container_policy =\n       frame_tree_node()->effective_container_policy();\n   feature_policy_ = FeaturePolicy::CreateFromParentPolicy(""}<_**next**_>{""sha"": ""183c3e5d95b54a5f1bb6f45555fd12cad0da4ee2"", ""filename"": ""content/browser/frame_host/render_frame_host_impl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/render_frame_host_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/browser/frame_host/render_frame_host_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_impl.h?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -585,7 +585,7 @@ class CONTENT_EXPORT RenderFrameHostImpl\n   void ResetLoadingState();\n \n   // Returns the feature policy which should be enforced on this RenderFrame.\n-  FeaturePolicy* get_feature_policy() { return feature_policy_.get(); }\n+  FeaturePolicy* feature_policy() { return feature_policy_.get(); }\n \n   // Clears any existing policy and constructs a new policy for this frame,\n   // based on its parent frame.""}<_**next**_>{""sha"": ""4f9be78420786fcaeb7d75048c86c5e012108bb6"", ""filename"": ""content/common/feature_policy/feature_policy.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/common/feature_policy/feature_policy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/common/feature_policy/feature_policy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/feature_policy/feature_policy.h?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -10,6 +10,7 @@\n #include <string>\n #include <vector>\n \n+#include \""base/gtest_prod_util.h\""\n #include \""base/macros.h\""\n #include \""content/common/content_export.h\""\n #include \""third_party/WebKit/public/platform/WebFeaturePolicy.h\""\n@@ -177,6 +178,8 @@ class CONTENT_EXPORT FeaturePolicy : public blink::WebFeaturePolicy {\n \n  private:\n   friend class FeaturePolicyTest;\n+  FRIEND_TEST_ALL_PREFIXES(NavigatorTestWithBrowserSideNavigation,\n+                           FeaturePolicyNewChild);\n \n   explicit FeaturePolicy(url::Origin origin);\n   FeaturePolicy(url::Origin origin, const FeatureList& feature_list);""}<_**next**_>{""sha"": ""ece1a637fb4177cc712b0a947f755e58d90785ca"", ""filename"": ""content/test/test_render_view_host.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/test/test_render_view_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/784f56a9c97a838448dd23f9bdc7c05fe8e639b3/content/test/test_render_view_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/test/test_render_view_host.cc?ref=784f56a9c97a838448dd23f9bdc7c05fe8e639b3"", ""patch"": ""@@ -41,6 +41,7 @@ void InitNavigateParams(FrameHostMsg_DidCommitProvisionalLoad_Params* params,\n                         ui::PageTransition transition) {\n   params->nav_entry_id = nav_entry_id;\n   params->url = url;\n+  params->origin = url::Origin(url);\n   params->referrer = Referrer();\n   params->transition = transition;\n   params->redirects = std::vector<GURL>();""}","void InitNavigateParams(FrameHostMsg_DidCommitProvisionalLoad_Params* params,
                        int nav_entry_id,
                        bool did_create_new_entry,
                        const GURL& url,
                         ui::PageTransition transition) {
   params->nav_entry_id = nav_entry_id;
   params->url = url;
  params->origin = url::Origin(url);
   params->referrer = Referrer();
   params->transition = transition;
   params->redirects = std::vector<GURL>();
  params->should_update_history = false;
  params->searchable_form_url = GURL();
  params->searchable_form_encoding = std::string();
  params->did_create_new_entry = did_create_new_entry;
  params->gesture = NavigationGestureUser;
  params->was_within_same_document = false;
  params->method = ""GET"";
  params->page_state = PageState::CreateFromURL(url);
}
","void InitNavigateParams(FrameHostMsg_DidCommitProvisionalLoad_Params* params,
                        int nav_entry_id,
                        bool did_create_new_entry,
                        const GURL& url,
                         ui::PageTransition transition) {
   params->nav_entry_id = nav_entry_id;
   params->url = url;
   params->referrer = Referrer();
   params->transition = transition;
   params->redirects = std::vector<GURL>();
  params->should_update_history = false;
  params->searchable_form_url = GURL();
  params->searchable_form_encoding = std::string();
  params->did_create_new_entry = did_create_new_entry;
  params->gesture = NavigationGestureUser;
  params->was_within_same_document = false;
  params->method = ""GET"";
  params->page_state = PageState::CreateFromURL(url);
}
",C,"  params->origin = url::Origin(url);
",,,"@@ -41,6 +41,7 @@ void InitNavigateParams(FrameHostMsg_DidCommitProvisionalLoad_Params* params,
                         ui::PageTransition transition) {
   params->nav_entry_id = nav_entry_id;
   params->url = url;
+  params->origin = url::Origin(url);
   params->referrer = Referrer();
   params->transition = transition;
   params->redirects = std::vector<GURL>();",Chrome,784f56a9c97a838448dd23f9bdc7c05fe8e639b3,858c1cc4ded16a2365425fa416bb90d3c2d3bf85,1,"void InitNavigateParams(FrameHostMsg_DidCommitProvisionalLoad_Params* params,
                        int nav_entry_id,
                        bool did_create_new_entry,
                        const GURL& url,
                         ui::PageTransition transition) {
   params->nav_entry_id = nav_entry_id;
   params->url = url;
//fix_flaw_line_below:
//  params->origin = url::Origin(url);
   params->referrer = Referrer();
   params->transition = transition;
   params->redirects = std::vector<GURL>();
  params->should_update_history = false;
  params->searchable_form_url = GURL();
  params->searchable_form_encoding = std::string();
  params->did_create_new_entry = did_create_new_entry;
  params->gesture = NavigationGestureUser;
  params->was_within_same_document = false;
  params->method = ""GET"";
  params->page_state = PageState::CreateFromURL(url);
}
"
8235,185971,,Remote,Not required,,CVE-2016-5155,https://www.cvedetails.com/cve/CVE-2016-5155/,CWE-254,Medium,,Partial,,2016-09-11,4.3,"Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",2018-10-30,,2,https://github.com/chromium/chromium/commit/32a9879fc01c24f9216bb2975200ab8a4afac80c,32a9879fc01c24f9216bb2975200ab8a4afac80c,"Prefer SyncService over ProfileSyncService in foreign_session_helper

SyncService is the interface, ProfileSyncService is the concrete
implementation. Generally no clients should need to use the conrete
implementation - for one, testing will be much easier once everyone
uses the interface only.

Bug: 924508
Change-Id: Ia210665f8f02512053d1a60d627dea0f22758387
Reviewed-on: https://chromium-review.googlesource.com/c/1461119
Auto-Submit: Marc Treib <treib@chromium.org>
Commit-Queue: Yaron Friedman <yfriedman@chromium.org>
Reviewed-by: Yaron Friedman <yfriedman@chromium.org>
Cr-Commit-Position: refs/heads/master@{#630662}",2,chrome/browser/android/foreign_session_helper.cc,"{""sha"": ""140e2d09130ad870a82a7b4594bfc6549b2c6c0d"", ""filename"": ""chrome/browser/android/foreign_session_helper.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/32a9879fc01c24f9216bb2975200ab8a4afac80c/chrome/browser/android/foreign_session_helper.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/32a9879fc01c24f9216bb2975200ab8a4afac80c/chrome/browser/android/foreign_session_helper.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/foreign_session_helper.cc?ref=32a9879fc01c24f9216bb2975200ab8a4afac80c"", ""patch"": ""@@ -19,9 +19,9 @@\n #include \""chrome/browser/ui/android/tab_model/tab_model_list.h\""\n #include \""chrome/common/pref_names.h\""\n #include \""chrome/common/url_constants.h\""\n-#include \""components/browser_sync/profile_sync_service.h\""\n #include \""components/prefs/pref_service.h\""\n #include \""components/prefs/scoped_user_pref_update.h\""\n+#include \""components/sync/driver/sync_service.h\""\n #include \""components/sync_sessions/open_tabs_ui_delegate.h\""\n #include \""components/sync_sessions/session_sync_service.h\""\n #include \""content/public/browser/notification_details.h\""\n@@ -181,13 +181,12 @@ jboolean ForeignSessionHelper::IsTabSyncEnabled(\n void ForeignSessionHelper::TriggerSessionSync(\n     JNIEnv* env,\n     const JavaParamRef<jobject>& obj) {\n-  browser_sync::ProfileSyncService* service =\n-      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile_);\n+  syncer::SyncService* service =\n+      ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);\n   if (!service)\n     return;\n \n-  const syncer::ModelTypeSet types(syncer::SESSIONS);\n-  service->TriggerRefresh(types);\n+  service->TriggerRefresh({syncer::SESSIONS});\n }\n \n void ForeignSessionHelper::SetOnForeignSessionCallback(\n@@ -309,8 +308,8 @@ void ForeignSessionHelper::SetInvalidationsForSessionsEnabled(\n     JNIEnv* env,\n     const JavaParamRef<jobject>& obj,\n     jboolean enabled) {\n-  browser_sync::ProfileSyncService* service =\n-      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile_);\n+  syncer::SyncService* service =\n+      ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);\n   if (!service)\n     return;\n ""}","void ForeignSessionHelper::SetInvalidationsForSessionsEnabled(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj,
     jboolean enabled) {
  syncer::SyncService* service =
      ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);
   if (!service)
     return;
 
  service->SetInvalidationsForSessionsEnabled(enabled);
}
","void ForeignSessionHelper::SetInvalidationsForSessionsEnabled(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj,
     jboolean enabled) {
  browser_sync::ProfileSyncService* service =
      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile_);
   if (!service)
     return;
 
  service->SetInvalidationsForSessionsEnabled(enabled);
}
",C,"  syncer::SyncService* service =
      ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);
","  browser_sync::ProfileSyncService* service =
      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile_);
",,"@@ -19,9 +19,9 @@
 #include ""chrome/browser/ui/android/tab_model/tab_model_list.h""
 #include ""chrome/common/pref_names.h""
 #include ""chrome/common/url_constants.h""
-#include ""components/browser_sync/profile_sync_service.h""
 #include ""components/prefs/pref_service.h""
 #include ""components/prefs/scoped_user_pref_update.h""
+#include ""components/sync/driver/sync_service.h""
 #include ""components/sync_sessions/open_tabs_ui_delegate.h""
 #include ""components/sync_sessions/session_sync_service.h""
 #include ""content/public/browser/notification_details.h""
@@ -181,13 +181,12 @@ jboolean ForeignSessionHelper::IsTabSyncEnabled(
 void ForeignSessionHelper::TriggerSessionSync(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj) {
-  browser_sync::ProfileSyncService* service =
-      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile_);
+  syncer::SyncService* service =
+      ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);
   if (!service)
     return;
 
-  const syncer::ModelTypeSet types(syncer::SESSIONS);
-  service->TriggerRefresh(types);
+  service->TriggerRefresh({syncer::SESSIONS});
 }
 
 void ForeignSessionHelper::SetOnForeignSessionCallback(
@@ -309,8 +308,8 @@ void ForeignSessionHelper::SetInvalidationsForSessionsEnabled(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj,
     jboolean enabled) {
-  browser_sync::ProfileSyncService* service =
-      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile_);
+  syncer::SyncService* service =
+      ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);
   if (!service)
     return;
 ",Chrome,32a9879fc01c24f9216bb2975200ab8a4afac80c,8b4b4f6251c73978007eb3946cf9e9ddd73aa803,1,"void ForeignSessionHelper::SetInvalidationsForSessionsEnabled(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj,
     jboolean enabled) {
//flaw_line_below:
  browser_sync::ProfileSyncService* service =
//flaw_line_below:
      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile_);
//fix_flaw_line_below:
//  syncer::SyncService* service =
//fix_flaw_line_below:
//      ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);
   if (!service)
     return;
 
  service->SetInvalidationsForSessionsEnabled(enabled);
}
"
8236,185972,,Remote,Not required,,CVE-2016-5155,https://www.cvedetails.com/cve/CVE-2016-5155/,CWE-254,Medium,,Partial,,2016-09-11,4.3,"Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",2018-10-30,,3,https://github.com/chromium/chromium/commit/32a9879fc01c24f9216bb2975200ab8a4afac80c,32a9879fc01c24f9216bb2975200ab8a4afac80c,"Prefer SyncService over ProfileSyncService in foreign_session_helper

SyncService is the interface, ProfileSyncService is the concrete
implementation. Generally no clients should need to use the conrete
implementation - for one, testing will be much easier once everyone
uses the interface only.

Bug: 924508
Change-Id: Ia210665f8f02512053d1a60d627dea0f22758387
Reviewed-on: https://chromium-review.googlesource.com/c/1461119
Auto-Submit: Marc Treib <treib@chromium.org>
Commit-Queue: Yaron Friedman <yfriedman@chromium.org>
Reviewed-by: Yaron Friedman <yfriedman@chromium.org>
Cr-Commit-Position: refs/heads/master@{#630662}",4,chrome/browser/android/foreign_session_helper.cc,"{""sha"": ""140e2d09130ad870a82a7b4594bfc6549b2c6c0d"", ""filename"": ""chrome/browser/android/foreign_session_helper.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/32a9879fc01c24f9216bb2975200ab8a4afac80c/chrome/browser/android/foreign_session_helper.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/32a9879fc01c24f9216bb2975200ab8a4afac80c/chrome/browser/android/foreign_session_helper.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/foreign_session_helper.cc?ref=32a9879fc01c24f9216bb2975200ab8a4afac80c"", ""patch"": ""@@ -19,9 +19,9 @@\n #include \""chrome/browser/ui/android/tab_model/tab_model_list.h\""\n #include \""chrome/common/pref_names.h\""\n #include \""chrome/common/url_constants.h\""\n-#include \""components/browser_sync/profile_sync_service.h\""\n #include \""components/prefs/pref_service.h\""\n #include \""components/prefs/scoped_user_pref_update.h\""\n+#include \""components/sync/driver/sync_service.h\""\n #include \""components/sync_sessions/open_tabs_ui_delegate.h\""\n #include \""components/sync_sessions/session_sync_service.h\""\n #include \""content/public/browser/notification_details.h\""\n@@ -181,13 +181,12 @@ jboolean ForeignSessionHelper::IsTabSyncEnabled(\n void ForeignSessionHelper::TriggerSessionSync(\n     JNIEnv* env,\n     const JavaParamRef<jobject>& obj) {\n-  browser_sync::ProfileSyncService* service =\n-      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile_);\n+  syncer::SyncService* service =\n+      ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);\n   if (!service)\n     return;\n \n-  const syncer::ModelTypeSet types(syncer::SESSIONS);\n-  service->TriggerRefresh(types);\n+  service->TriggerRefresh({syncer::SESSIONS});\n }\n \n void ForeignSessionHelper::SetOnForeignSessionCallback(\n@@ -309,8 +308,8 @@ void ForeignSessionHelper::SetInvalidationsForSessionsEnabled(\n     JNIEnv* env,\n     const JavaParamRef<jobject>& obj,\n     jboolean enabled) {\n-  browser_sync::ProfileSyncService* service =\n-      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile_);\n+  syncer::SyncService* service =\n+      ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);\n   if (!service)\n     return;\n ""}"," void ForeignSessionHelper::TriggerSessionSync(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj) {
  syncer::SyncService* service =
      ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);
   if (!service)
     return;
 
  service->TriggerRefresh({syncer::SESSIONS});
 }
"," void ForeignSessionHelper::TriggerSessionSync(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj) {
  browser_sync::ProfileSyncService* service =
      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile_);
   if (!service)
     return;
 
  const syncer::ModelTypeSet types(syncer::SESSIONS);
  service->TriggerRefresh(types);
 }
",C,"  syncer::SyncService* service =
      ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);
  service->TriggerRefresh({syncer::SESSIONS});
","  browser_sync::ProfileSyncService* service =
      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile_);
  const syncer::ModelTypeSet types(syncer::SESSIONS);
  service->TriggerRefresh(types);
",,"@@ -19,9 +19,9 @@
 #include ""chrome/browser/ui/android/tab_model/tab_model_list.h""
 #include ""chrome/common/pref_names.h""
 #include ""chrome/common/url_constants.h""
-#include ""components/browser_sync/profile_sync_service.h""
 #include ""components/prefs/pref_service.h""
 #include ""components/prefs/scoped_user_pref_update.h""
+#include ""components/sync/driver/sync_service.h""
 #include ""components/sync_sessions/open_tabs_ui_delegate.h""
 #include ""components/sync_sessions/session_sync_service.h""
 #include ""content/public/browser/notification_details.h""
@@ -181,13 +181,12 @@ jboolean ForeignSessionHelper::IsTabSyncEnabled(
 void ForeignSessionHelper::TriggerSessionSync(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj) {
-  browser_sync::ProfileSyncService* service =
-      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile_);
+  syncer::SyncService* service =
+      ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);
   if (!service)
     return;
 
-  const syncer::ModelTypeSet types(syncer::SESSIONS);
-  service->TriggerRefresh(types);
+  service->TriggerRefresh({syncer::SESSIONS});
 }
 
 void ForeignSessionHelper::SetOnForeignSessionCallback(
@@ -309,8 +308,8 @@ void ForeignSessionHelper::SetInvalidationsForSessionsEnabled(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj,
     jboolean enabled) {
-  browser_sync::ProfileSyncService* service =
-      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile_);
+  syncer::SyncService* service =
+      ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);
   if (!service)
     return;
 ",Chrome,32a9879fc01c24f9216bb2975200ab8a4afac80c,8b4b4f6251c73978007eb3946cf9e9ddd73aa803,1," void ForeignSessionHelper::TriggerSessionSync(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj) {
//flaw_line_below:
  browser_sync::ProfileSyncService* service =
//flaw_line_below:
      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile_);
//fix_flaw_line_below:
//  syncer::SyncService* service =
//fix_flaw_line_below:
//      ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);
   if (!service)
     return;
 
//flaw_line_below:
  const syncer::ModelTypeSet types(syncer::SESSIONS);
//flaw_line_below:
  service->TriggerRefresh(types);
//fix_flaw_line_below:
//  service->TriggerRefresh({syncer::SESSIONS});
 }
"
8465,186201,,Remote,Not required,,CVE-2016-1615,https://www.cvedetails.com/cve/CVE-2016-1615/,CWE-254,Medium,,Partial,,2016-01-25,4.3,The Omnibox implementation in Google Chrome before 48.0.2564.82 allows remote attackers to spoof a document's origin via unspecified vectors.,2016-12-07,,1,https://github.com/chromium/chromium/commit/b399a05453d7b3e2dfdec67865fefe6953bcc59e,b399a05453d7b3e2dfdec67865fefe6953bcc59e,"Allocate a FrameSinkId for RenderWidgetHostViewAura in mus+ash

RenderWidgetHostViewChildFrame expects its parent to have a valid
FrameSinkId. Make sure RenderWidgetHostViewAura has a FrameSinkId even
if DelegatedFrameHost is not used (in mus+ash).

BUG=706553
TBR=jam@chromium.org

Review-Url: https://codereview.chromium.org/2847253003
Cr-Commit-Position: refs/heads/master@{#468179}",3,content/browser/renderer_host/render_widget_host_view_aura.cc,"{""sha"": ""64e3883071e13069017e7f3f006552e7392335d9"", ""filename"": ""content/browser/renderer_host/render_widget_host_view_aura.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/b399a05453d7b3e2dfdec67865fefe6953bcc59e/content/browser/renderer_host/render_widget_host_view_aura.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b399a05453d7b3e2dfdec67865fefe6953bcc59e/content/browser/renderer_host/render_widget_host_view_aura.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/render_widget_host_view_aura.cc?ref=b399a05453d7b3e2dfdec67865fefe6953bcc59e"", ""patch"": ""@@ -396,6 +396,7 @@ RenderWidgetHostViewAura::RenderWidgetHostViewAura(RenderWidgetHost* host,\n       is_guest_view_hack_(is_guest_view_hack),\n       device_scale_factor_(0.0f),\n       event_handler_(new RenderWidgetHostViewEventHandler(host_, this, this)),\n+      frame_sink_id_(host_->AllocateFrameSinkId(is_guest_view_hack_)),\n       weak_ptr_factory_(this) {\n   if (!is_guest_view_hack_)\n     host_->SetView(this);\n@@ -1932,16 +1933,13 @@ void RenderWidgetHostViewAura::CreateDelegatedFrameHostClient() {\n   if (IsMus())\n     return;\n \n-  cc::FrameSinkId frame_sink_id =\n-      host_->AllocateFrameSinkId(is_guest_view_hack_);\n-\n   // Tests may set |delegated_frame_host_client_|.\n   if (!delegated_frame_host_client_) {\n     delegated_frame_host_client_ =\n         base::MakeUnique<DelegatedFrameHostClientAura>(this);\n   }\n   delegated_frame_host_ = base::MakeUnique<DelegatedFrameHost>(\n-      frame_sink_id, delegated_frame_host_client_.get());\n+      frame_sink_id_, delegated_frame_host_client_.get());\n   if (renderer_compositor_frame_sink_) {\n     delegated_frame_host_->DidCreateNewRendererCompositorFrameSink(\n         renderer_compositor_frame_sink_);\n@@ -2282,8 +2280,7 @@ void RenderWidgetHostViewAura::OnDidNavigateMainFrameToNewPage() {\n }\n \n cc::FrameSinkId RenderWidgetHostViewAura::GetFrameSinkId() {\n-  return delegated_frame_host_ ? delegated_frame_host_->GetFrameSinkId()\n-                               : cc::FrameSinkId();\n+  return frame_sink_id_;\n }\n \n cc::SurfaceId RenderWidgetHostViewAura::SurfaceIdForTesting() const {""}<_**next**_>{""sha"": ""489ebc43422d6b0766dd5d33e22ec172edaa4c76"", ""filename"": ""content/browser/renderer_host/render_widget_host_view_aura.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/b399a05453d7b3e2dfdec67865fefe6953bcc59e/content/browser/renderer_host/render_widget_host_view_aura.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b399a05453d7b3e2dfdec67865fefe6953bcc59e/content/browser/renderer_host/render_widget_host_view_aura.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/render_widget_host_view_aura.h?ref=b399a05453d7b3e2dfdec67865fefe6953bcc59e"", ""patch"": ""@@ -590,6 +590,8 @@ class CONTENT_EXPORT RenderWidgetHostViewAura\n   // provides an implementation, and directs events to |host_|.\n   std::unique_ptr<RenderWidgetHostViewEventHandler> event_handler_;\n \n+  cc::FrameSinkId frame_sink_id_;\n+\n   base::WeakPtrFactory<RenderWidgetHostViewAura> weak_ptr_factory_;\n \n   DISALLOW_COPY_AND_ASSIGN(RenderWidgetHostViewAura);""}","void RenderWidgetHostViewAura::CreateDelegatedFrameHostClient() {
   if (IsMus())
     return;
 
   if (!delegated_frame_host_client_) {
     delegated_frame_host_client_ =
         base::MakeUnique<DelegatedFrameHostClientAura>(this);
   }
   delegated_frame_host_ = base::MakeUnique<DelegatedFrameHost>(
      frame_sink_id_, delegated_frame_host_client_.get());
   if (renderer_compositor_frame_sink_) {
     delegated_frame_host_->DidCreateNewRendererCompositorFrameSink(
         renderer_compositor_frame_sink_);
  }
  UpdateNeedsBeginFramesInternal();

  if (host_->delegate() && host_->delegate()->GetInputEventRouter()) {
    host_->delegate()->GetInputEventRouter()->AddFrameSinkIdOwner(
        GetFrameSinkId(), this);
  }
}
","void RenderWidgetHostViewAura::CreateDelegatedFrameHostClient() {
   if (IsMus())
     return;
 
  cc::FrameSinkId frame_sink_id =
      host_->AllocateFrameSinkId(is_guest_view_hack_);
   if (!delegated_frame_host_client_) {
     delegated_frame_host_client_ =
         base::MakeUnique<DelegatedFrameHostClientAura>(this);
   }
   delegated_frame_host_ = base::MakeUnique<DelegatedFrameHost>(
      frame_sink_id, delegated_frame_host_client_.get());
   if (renderer_compositor_frame_sink_) {
     delegated_frame_host_->DidCreateNewRendererCompositorFrameSink(
         renderer_compositor_frame_sink_);
  }
  UpdateNeedsBeginFramesInternal();

  if (host_->delegate() && host_->delegate()->GetInputEventRouter()) {
    host_->delegate()->GetInputEventRouter()->AddFrameSinkIdOwner(
        GetFrameSinkId(), this);
  }
}
",C,"      frame_sink_id_, delegated_frame_host_client_.get());
","  cc::FrameSinkId frame_sink_id =
      host_->AllocateFrameSinkId(is_guest_view_hack_);
      frame_sink_id, delegated_frame_host_client_.get());
",,"@@ -396,6 +396,7 @@ RenderWidgetHostViewAura::RenderWidgetHostViewAura(RenderWidgetHost* host,
       is_guest_view_hack_(is_guest_view_hack),
       device_scale_factor_(0.0f),
       event_handler_(new RenderWidgetHostViewEventHandler(host_, this, this)),
+      frame_sink_id_(host_->AllocateFrameSinkId(is_guest_view_hack_)),
       weak_ptr_factory_(this) {
   if (!is_guest_view_hack_)
     host_->SetView(this);
@@ -1932,16 +1933,13 @@ void RenderWidgetHostViewAura::CreateDelegatedFrameHostClient() {
   if (IsMus())
     return;
 
-  cc::FrameSinkId frame_sink_id =
-      host_->AllocateFrameSinkId(is_guest_view_hack_);
-
   // Tests may set |delegated_frame_host_client_|.
   if (!delegated_frame_host_client_) {
     delegated_frame_host_client_ =
         base::MakeUnique<DelegatedFrameHostClientAura>(this);
   }
   delegated_frame_host_ = base::MakeUnique<DelegatedFrameHost>(
-      frame_sink_id, delegated_frame_host_client_.get());
+      frame_sink_id_, delegated_frame_host_client_.get());
   if (renderer_compositor_frame_sink_) {
     delegated_frame_host_->DidCreateNewRendererCompositorFrameSink(
         renderer_compositor_frame_sink_);
@@ -2282,8 +2280,7 @@ void RenderWidgetHostViewAura::OnDidNavigateMainFrameToNewPage() {
 }
 
 cc::FrameSinkId RenderWidgetHostViewAura::GetFrameSinkId() {
-  return delegated_frame_host_ ? delegated_frame_host_->GetFrameSinkId()
-                               : cc::FrameSinkId();
+  return frame_sink_id_;
 }
 
 cc::SurfaceId RenderWidgetHostViewAura::SurfaceIdForTesting() const {",Chrome,b399a05453d7b3e2dfdec67865fefe6953bcc59e,d4fcf211213e19d716f822cc514da06155879926,1,"void RenderWidgetHostViewAura::CreateDelegatedFrameHostClient() {
   if (IsMus())
     return;
 
//flaw_line_below:
  cc::FrameSinkId frame_sink_id =
//flaw_line_below:
      host_->AllocateFrameSinkId(is_guest_view_hack_);
//flaw_line_below:

   // Tests may set |delegated_frame_host_client_|.
   if (!delegated_frame_host_client_) {
     delegated_frame_host_client_ =
         base::MakeUnique<DelegatedFrameHostClientAura>(this);
   }
   delegated_frame_host_ = base::MakeUnique<DelegatedFrameHost>(
//flaw_line_below:
      frame_sink_id, delegated_frame_host_client_.get());
//fix_flaw_line_below:
//      frame_sink_id_, delegated_frame_host_client_.get());
   if (renderer_compositor_frame_sink_) {
     delegated_frame_host_->DidCreateNewRendererCompositorFrameSink(
         renderer_compositor_frame_sink_);
  }
  UpdateNeedsBeginFramesInternal();

  // Let the page-level input event router know about our surface ID
  // namespace for surface-based hit testing.
  if (host_->delegate() && host_->delegate()->GetInputEventRouter()) {
    host_->delegate()->GetInputEventRouter()->AddFrameSinkIdOwner(
        GetFrameSinkId(), this);
  }
}
"
8466,186202,,Remote,Not required,,CVE-2016-1615,https://www.cvedetails.com/cve/CVE-2016-1615/,CWE-254,Medium,,Partial,,2016-01-25,4.3,The Omnibox implementation in Google Chrome before 48.0.2564.82 allows remote attackers to spoof a document's origin via unspecified vectors.,2016-12-07,,1,https://github.com/chromium/chromium/commit/b399a05453d7b3e2dfdec67865fefe6953bcc59e,b399a05453d7b3e2dfdec67865fefe6953bcc59e,"Allocate a FrameSinkId for RenderWidgetHostViewAura in mus+ash

RenderWidgetHostViewChildFrame expects its parent to have a valid
FrameSinkId. Make sure RenderWidgetHostViewAura has a FrameSinkId even
if DelegatedFrameHost is not used (in mus+ash).

BUG=706553
TBR=jam@chromium.org

Review-Url: https://codereview.chromium.org/2847253003
Cr-Commit-Position: refs/heads/master@{#468179}",2,content/browser/renderer_host/render_widget_host_view_aura.cc,"{""sha"": ""64e3883071e13069017e7f3f006552e7392335d9"", ""filename"": ""content/browser/renderer_host/render_widget_host_view_aura.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/b399a05453d7b3e2dfdec67865fefe6953bcc59e/content/browser/renderer_host/render_widget_host_view_aura.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b399a05453d7b3e2dfdec67865fefe6953bcc59e/content/browser/renderer_host/render_widget_host_view_aura.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/render_widget_host_view_aura.cc?ref=b399a05453d7b3e2dfdec67865fefe6953bcc59e"", ""patch"": ""@@ -396,6 +396,7 @@ RenderWidgetHostViewAura::RenderWidgetHostViewAura(RenderWidgetHost* host,\n       is_guest_view_hack_(is_guest_view_hack),\n       device_scale_factor_(0.0f),\n       event_handler_(new RenderWidgetHostViewEventHandler(host_, this, this)),\n+      frame_sink_id_(host_->AllocateFrameSinkId(is_guest_view_hack_)),\n       weak_ptr_factory_(this) {\n   if (!is_guest_view_hack_)\n     host_->SetView(this);\n@@ -1932,16 +1933,13 @@ void RenderWidgetHostViewAura::CreateDelegatedFrameHostClient() {\n   if (IsMus())\n     return;\n \n-  cc::FrameSinkId frame_sink_id =\n-      host_->AllocateFrameSinkId(is_guest_view_hack_);\n-\n   // Tests may set |delegated_frame_host_client_|.\n   if (!delegated_frame_host_client_) {\n     delegated_frame_host_client_ =\n         base::MakeUnique<DelegatedFrameHostClientAura>(this);\n   }\n   delegated_frame_host_ = base::MakeUnique<DelegatedFrameHost>(\n-      frame_sink_id, delegated_frame_host_client_.get());\n+      frame_sink_id_, delegated_frame_host_client_.get());\n   if (renderer_compositor_frame_sink_) {\n     delegated_frame_host_->DidCreateNewRendererCompositorFrameSink(\n         renderer_compositor_frame_sink_);\n@@ -2282,8 +2280,7 @@ void RenderWidgetHostViewAura::OnDidNavigateMainFrameToNewPage() {\n }\n \n cc::FrameSinkId RenderWidgetHostViewAura::GetFrameSinkId() {\n-  return delegated_frame_host_ ? delegated_frame_host_->GetFrameSinkId()\n-                               : cc::FrameSinkId();\n+  return frame_sink_id_;\n }\n \n cc::SurfaceId RenderWidgetHostViewAura::SurfaceIdForTesting() const {""}<_**next**_>{""sha"": ""489ebc43422d6b0766dd5d33e22ec172edaa4c76"", ""filename"": ""content/browser/renderer_host/render_widget_host_view_aura.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/b399a05453d7b3e2dfdec67865fefe6953bcc59e/content/browser/renderer_host/render_widget_host_view_aura.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b399a05453d7b3e2dfdec67865fefe6953bcc59e/content/browser/renderer_host/render_widget_host_view_aura.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/render_widget_host_view_aura.h?ref=b399a05453d7b3e2dfdec67865fefe6953bcc59e"", ""patch"": ""@@ -590,6 +590,8 @@ class CONTENT_EXPORT RenderWidgetHostViewAura\n   // provides an implementation, and directs events to |host_|.\n   std::unique_ptr<RenderWidgetHostViewEventHandler> event_handler_;\n \n+  cc::FrameSinkId frame_sink_id_;\n+\n   base::WeakPtrFactory<RenderWidgetHostViewAura> weak_ptr_factory_;\n \n   DISALLOW_COPY_AND_ASSIGN(RenderWidgetHostViewAura);""}"," cc::FrameSinkId RenderWidgetHostViewAura::GetFrameSinkId() {
  return frame_sink_id_;
 }
"," cc::FrameSinkId RenderWidgetHostViewAura::GetFrameSinkId() {
  return delegated_frame_host_ ? delegated_frame_host_->GetFrameSinkId()
                               : cc::FrameSinkId();
 }
",C,"  return frame_sink_id_;
","  return delegated_frame_host_ ? delegated_frame_host_->GetFrameSinkId()
                               : cc::FrameSinkId();
",,"@@ -396,6 +396,7 @@ RenderWidgetHostViewAura::RenderWidgetHostViewAura(RenderWidgetHost* host,
       is_guest_view_hack_(is_guest_view_hack),
       device_scale_factor_(0.0f),
       event_handler_(new RenderWidgetHostViewEventHandler(host_, this, this)),
+      frame_sink_id_(host_->AllocateFrameSinkId(is_guest_view_hack_)),
       weak_ptr_factory_(this) {
   if (!is_guest_view_hack_)
     host_->SetView(this);
@@ -1932,16 +1933,13 @@ void RenderWidgetHostViewAura::CreateDelegatedFrameHostClient() {
   if (IsMus())
     return;
 
-  cc::FrameSinkId frame_sink_id =
-      host_->AllocateFrameSinkId(is_guest_view_hack_);
-
   // Tests may set |delegated_frame_host_client_|.
   if (!delegated_frame_host_client_) {
     delegated_frame_host_client_ =
         base::MakeUnique<DelegatedFrameHostClientAura>(this);
   }
   delegated_frame_host_ = base::MakeUnique<DelegatedFrameHost>(
-      frame_sink_id, delegated_frame_host_client_.get());
+      frame_sink_id_, delegated_frame_host_client_.get());
   if (renderer_compositor_frame_sink_) {
     delegated_frame_host_->DidCreateNewRendererCompositorFrameSink(
         renderer_compositor_frame_sink_);
@@ -2282,8 +2280,7 @@ void RenderWidgetHostViewAura::OnDidNavigateMainFrameToNewPage() {
 }
 
 cc::FrameSinkId RenderWidgetHostViewAura::GetFrameSinkId() {
-  return delegated_frame_host_ ? delegated_frame_host_->GetFrameSinkId()
-                               : cc::FrameSinkId();
+  return frame_sink_id_;
 }
 
 cc::SurfaceId RenderWidgetHostViewAura::SurfaceIdForTesting() const {",Chrome,b399a05453d7b3e2dfdec67865fefe6953bcc59e,d4fcf211213e19d716f822cc514da06155879926,1," cc::FrameSinkId RenderWidgetHostViewAura::GetFrameSinkId() {
//flaw_line_below:
  return delegated_frame_host_ ? delegated_frame_host_->GetFrameSinkId()
//flaw_line_below:
                               : cc::FrameSinkId();
//fix_flaw_line_below:
//  return frame_sink_id_;
 }
"
8467,186203,,Remote,Not required,,CVE-2016-1615,https://www.cvedetails.com/cve/CVE-2016-1615/,CWE-254,Medium,,Partial,,2016-01-25,4.3,The Omnibox implementation in Google Chrome before 48.0.2564.82 allows remote attackers to spoof a document's origin via unspecified vectors.,2016-12-07,,1,https://github.com/chromium/chromium/commit/b399a05453d7b3e2dfdec67865fefe6953bcc59e,b399a05453d7b3e2dfdec67865fefe6953bcc59e,"Allocate a FrameSinkId for RenderWidgetHostViewAura in mus+ash

RenderWidgetHostViewChildFrame expects its parent to have a valid
FrameSinkId. Make sure RenderWidgetHostViewAura has a FrameSinkId even
if DelegatedFrameHost is not used (in mus+ash).

BUG=706553
TBR=jam@chromium.org

Review-Url: https://codereview.chromium.org/2847253003
Cr-Commit-Position: refs/heads/master@{#468179}",0,content/browser/renderer_host/render_widget_host_view_aura.cc,"{""sha"": ""64e3883071e13069017e7f3f006552e7392335d9"", ""filename"": ""content/browser/renderer_host/render_widget_host_view_aura.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/b399a05453d7b3e2dfdec67865fefe6953bcc59e/content/browser/renderer_host/render_widget_host_view_aura.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b399a05453d7b3e2dfdec67865fefe6953bcc59e/content/browser/renderer_host/render_widget_host_view_aura.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/render_widget_host_view_aura.cc?ref=b399a05453d7b3e2dfdec67865fefe6953bcc59e"", ""patch"": ""@@ -396,6 +396,7 @@ RenderWidgetHostViewAura::RenderWidgetHostViewAura(RenderWidgetHost* host,\n       is_guest_view_hack_(is_guest_view_hack),\n       device_scale_factor_(0.0f),\n       event_handler_(new RenderWidgetHostViewEventHandler(host_, this, this)),\n+      frame_sink_id_(host_->AllocateFrameSinkId(is_guest_view_hack_)),\n       weak_ptr_factory_(this) {\n   if (!is_guest_view_hack_)\n     host_->SetView(this);\n@@ -1932,16 +1933,13 @@ void RenderWidgetHostViewAura::CreateDelegatedFrameHostClient() {\n   if (IsMus())\n     return;\n \n-  cc::FrameSinkId frame_sink_id =\n-      host_->AllocateFrameSinkId(is_guest_view_hack_);\n-\n   // Tests may set |delegated_frame_host_client_|.\n   if (!delegated_frame_host_client_) {\n     delegated_frame_host_client_ =\n         base::MakeUnique<DelegatedFrameHostClientAura>(this);\n   }\n   delegated_frame_host_ = base::MakeUnique<DelegatedFrameHost>(\n-      frame_sink_id, delegated_frame_host_client_.get());\n+      frame_sink_id_, delegated_frame_host_client_.get());\n   if (renderer_compositor_frame_sink_) {\n     delegated_frame_host_->DidCreateNewRendererCompositorFrameSink(\n         renderer_compositor_frame_sink_);\n@@ -2282,8 +2280,7 @@ void RenderWidgetHostViewAura::OnDidNavigateMainFrameToNewPage() {\n }\n \n cc::FrameSinkId RenderWidgetHostViewAura::GetFrameSinkId() {\n-  return delegated_frame_host_ ? delegated_frame_host_->GetFrameSinkId()\n-                               : cc::FrameSinkId();\n+  return frame_sink_id_;\n }\n \n cc::SurfaceId RenderWidgetHostViewAura::SurfaceIdForTesting() const {""}<_**next**_>{""sha"": ""489ebc43422d6b0766dd5d33e22ec172edaa4c76"", ""filename"": ""content/browser/renderer_host/render_widget_host_view_aura.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/b399a05453d7b3e2dfdec67865fefe6953bcc59e/content/browser/renderer_host/render_widget_host_view_aura.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b399a05453d7b3e2dfdec67865fefe6953bcc59e/content/browser/renderer_host/render_widget_host_view_aura.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/render_widget_host_view_aura.h?ref=b399a05453d7b3e2dfdec67865fefe6953bcc59e"", ""patch"": ""@@ -590,6 +590,8 @@ class CONTENT_EXPORT RenderWidgetHostViewAura\n   // provides an implementation, and directs events to |host_|.\n   std::unique_ptr<RenderWidgetHostViewEventHandler> event_handler_;\n \n+  cc::FrameSinkId frame_sink_id_;\n+\n   base::WeakPtrFactory<RenderWidgetHostViewAura> weak_ptr_factory_;\n \n   DISALLOW_COPY_AND_ASSIGN(RenderWidgetHostViewAura);""}","RenderWidgetHostViewAura::RenderWidgetHostViewAura(RenderWidgetHost* host,
                                                   bool is_guest_view_hack)
    : host_(RenderWidgetHostImpl::From(host)),
      window_(nullptr),
      in_shutdown_(false),
      in_bounds_changed_(false),
      popup_parent_host_view_(nullptr),
      popup_child_host_view_(nullptr),
      is_loading_(false),
      has_composition_text_(false),
      background_color_(SK_ColorWHITE),
      needs_begin_frames_(false),
      needs_flush_input_(false),
      added_frame_observer_(false),
      cursor_visibility_state_in_renderer_(UNKNOWN),
#if defined(OS_WIN)
      legacy_render_widget_host_HWND_(nullptr),
      legacy_window_destroyed_(false),
      virtual_keyboard_requested_(false),
#endif
      has_snapped_to_boundary_(false),
       is_guest_view_hack_(is_guest_view_hack),
       device_scale_factor_(0.0f),
       event_handler_(new RenderWidgetHostViewEventHandler(host_, this, this)),
      frame_sink_id_(host_->AllocateFrameSinkId(is_guest_view_hack_)),
       weak_ptr_factory_(this) {
   if (!is_guest_view_hack_)
     host_->SetView(this);

  if (GetTextInputManager())
    GetTextInputManager()->AddObserver(this);

  bool overscroll_enabled = base::CommandLine::ForCurrentProcess()->
      GetSwitchValueASCII(switches::kOverscrollHistoryNavigation) != ""0"";
  SetOverscrollControllerEnabled(overscroll_enabled);

  selection_controller_client_.reset(
      new TouchSelectionControllerClientAura(this));
  CreateSelectionController();

  RenderViewHost* rvh = RenderViewHost::From(host_);
  if (rvh) {
    ignore_result(rvh->GetWebkitPreferences());
  }
}
","RenderWidgetHostViewAura::RenderWidgetHostViewAura(RenderWidgetHost* host,
                                                   bool is_guest_view_hack)
    : host_(RenderWidgetHostImpl::From(host)),
      window_(nullptr),
      in_shutdown_(false),
      in_bounds_changed_(false),
      popup_parent_host_view_(nullptr),
      popup_child_host_view_(nullptr),
      is_loading_(false),
      has_composition_text_(false),
      background_color_(SK_ColorWHITE),
      needs_begin_frames_(false),
      needs_flush_input_(false),
      added_frame_observer_(false),
      cursor_visibility_state_in_renderer_(UNKNOWN),
#if defined(OS_WIN)
      legacy_render_widget_host_HWND_(nullptr),
      legacy_window_destroyed_(false),
      virtual_keyboard_requested_(false),
#endif
      has_snapped_to_boundary_(false),
       is_guest_view_hack_(is_guest_view_hack),
       device_scale_factor_(0.0f),
       event_handler_(new RenderWidgetHostViewEventHandler(host_, this, this)),
       weak_ptr_factory_(this) {
   if (!is_guest_view_hack_)
     host_->SetView(this);

  if (GetTextInputManager())
    GetTextInputManager()->AddObserver(this);

  bool overscroll_enabled = base::CommandLine::ForCurrentProcess()->
      GetSwitchValueASCII(switches::kOverscrollHistoryNavigation) != ""0"";
  SetOverscrollControllerEnabled(overscroll_enabled);

  selection_controller_client_.reset(
      new TouchSelectionControllerClientAura(this));
  CreateSelectionController();

  RenderViewHost* rvh = RenderViewHost::From(host_);
  if (rvh) {
    ignore_result(rvh->GetWebkitPreferences());
  }
}
",C,"      frame_sink_id_(host_->AllocateFrameSinkId(is_guest_view_hack_)),
",,,"@@ -396,6 +396,7 @@ RenderWidgetHostViewAura::RenderWidgetHostViewAura(RenderWidgetHost* host,
       is_guest_view_hack_(is_guest_view_hack),
       device_scale_factor_(0.0f),
       event_handler_(new RenderWidgetHostViewEventHandler(host_, this, this)),
+      frame_sink_id_(host_->AllocateFrameSinkId(is_guest_view_hack_)),
       weak_ptr_factory_(this) {
   if (!is_guest_view_hack_)
     host_->SetView(this);
@@ -1932,16 +1933,13 @@ void RenderWidgetHostViewAura::CreateDelegatedFrameHostClient() {
   if (IsMus())
     return;
 
-  cc::FrameSinkId frame_sink_id =
-      host_->AllocateFrameSinkId(is_guest_view_hack_);
-
   // Tests may set |delegated_frame_host_client_|.
   if (!delegated_frame_host_client_) {
     delegated_frame_host_client_ =
         base::MakeUnique<DelegatedFrameHostClientAura>(this);
   }
   delegated_frame_host_ = base::MakeUnique<DelegatedFrameHost>(
-      frame_sink_id, delegated_frame_host_client_.get());
+      frame_sink_id_, delegated_frame_host_client_.get());
   if (renderer_compositor_frame_sink_) {
     delegated_frame_host_->DidCreateNewRendererCompositorFrameSink(
         renderer_compositor_frame_sink_);
@@ -2282,8 +2280,7 @@ void RenderWidgetHostViewAura::OnDidNavigateMainFrameToNewPage() {
 }
 
 cc::FrameSinkId RenderWidgetHostViewAura::GetFrameSinkId() {
-  return delegated_frame_host_ ? delegated_frame_host_->GetFrameSinkId()
-                               : cc::FrameSinkId();
+  return frame_sink_id_;
 }
 
 cc::SurfaceId RenderWidgetHostViewAura::SurfaceIdForTesting() const {",Chrome,b399a05453d7b3e2dfdec67865fefe6953bcc59e,d4fcf211213e19d716f822cc514da06155879926,1,"RenderWidgetHostViewAura::RenderWidgetHostViewAura(RenderWidgetHost* host,
                                                   bool is_guest_view_hack)
    : host_(RenderWidgetHostImpl::From(host)),
      window_(nullptr),
      in_shutdown_(false),
      in_bounds_changed_(false),
      popup_parent_host_view_(nullptr),
      popup_child_host_view_(nullptr),
      is_loading_(false),
      has_composition_text_(false),
      background_color_(SK_ColorWHITE),
      needs_begin_frames_(false),
      needs_flush_input_(false),
      added_frame_observer_(false),
      cursor_visibility_state_in_renderer_(UNKNOWN),
#if defined(OS_WIN)
      legacy_render_widget_host_HWND_(nullptr),
      legacy_window_destroyed_(false),
      virtual_keyboard_requested_(false),
#endif
      has_snapped_to_boundary_(false),
       is_guest_view_hack_(is_guest_view_hack),
       device_scale_factor_(0.0f),
       event_handler_(new RenderWidgetHostViewEventHandler(host_, this, this)),
//fix_flaw_line_below:
//      frame_sink_id_(host_->AllocateFrameSinkId(is_guest_view_hack_)),
       weak_ptr_factory_(this) {
   if (!is_guest_view_hack_)
     host_->SetView(this);

  // We should start observing the TextInputManager for IME-related events as
  // well as monitoring its lifetime.
  if (GetTextInputManager())
    GetTextInputManager()->AddObserver(this);

  bool overscroll_enabled = base::CommandLine::ForCurrentProcess()->
      GetSwitchValueASCII(switches::kOverscrollHistoryNavigation) != ""0"";
  SetOverscrollControllerEnabled(overscroll_enabled);

  selection_controller_client_.reset(
      new TouchSelectionControllerClientAura(this));
  CreateSelectionController();

  RenderViewHost* rvh = RenderViewHost::From(host_);
  if (rvh) {
    // TODO(mostynb): actually use prefs.  Landing this as a separate CL
    // first to rebaseline some unreliable layout tests.
    ignore_result(rvh->GetWebkitPreferences());
  }
}
"
8468,186204,,Remote,Not required,,CVE-2016-1616,https://www.cvedetails.com/cve/CVE-2016-1616/,CWE-254,Medium,,Partial,,2016-01-25,4.3,The CustomButton::AcceleratorPressed function in ui/views/controls/button/custom_button.cc in Google Chrome before 48.0.2564.82 allows remote attackers to spoof URLs via vectors involving an unfocused custom button.,2016-12-07,,7,https://github.com/chromium/chromium/commit/297ae873b471a46929ea39697b121c0b411434ee,297ae873b471a46929ea39697b121c0b411434ee,"Custom buttons should only handle accelerators when focused.

BUG=541415

Review URL: https://codereview.chromium.org/1437523005

Cr-Commit-Position: refs/heads/master@{#360130}",0,ui/views/controls/button/custom_button.cc,"{""sha"": ""aafbf2d65a63aa32810d6da8d352f9bf1663f8af"", ""filename"": ""ui/views/controls/button/custom_button.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 0, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/297ae873b471a46929ea39697b121c0b411434ee/ui/views/controls/button/custom_button.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/297ae873b471a46929ea39697b121c0b411434ee/ui/views/controls/button/custom_button.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/views/controls/button/custom_button.cc?ref=297ae873b471a46929ea39697b121c0b411434ee"", ""patch"": ""@@ -251,6 +251,13 @@ void CustomButton::OnGestureEvent(ui::GestureEvent* event) {\n }\n \n bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {\n+  // Should only handle accelerators when active. However, only top level\n+  // widgets can be active, so for child widgets check if they are focused\n+  // instead.\n+  if ((IsChildWidget() && !FocusInChildWidget()) ||\n+      (!IsChildWidget() && !GetWidget()->IsActive())) {\n+    return false;\n+  }\n   SetState(STATE_NORMAL);\n   // TODO(beng): remove once NotifyClick takes ui::Event.\n   ui::MouseEvent synthetic_event(\n@@ -378,4 +385,14 @@ void CustomButton::OnBlur() {\n     SetState(STATE_NORMAL);\n }\n \n+bool CustomButton::IsChildWidget() const {\n+  return GetWidget() && GetWidget()->GetTopLevelWidget() != GetWidget();\n+}\n+\n+bool CustomButton::FocusInChildWidget() const {\n+  return GetWidget() &&\n+         GetWidget()->GetRootView()->Contains(\n+             GetFocusManager()->GetFocusedView());\n+}\n+\n }  // namespace views""}<_**next**_>{""sha"": ""869bcd77af5dac05115312e726c984cf58aac1cf"", ""filename"": ""ui/views/controls/button/custom_button.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/297ae873b471a46929ea39697b121c0b411434ee/ui/views/controls/button/custom_button.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/297ae873b471a46929ea39697b121c0b411434ee/ui/views/controls/button/custom_button.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/views/controls/button/custom_button.h?ref=297ae873b471a46929ea39697b121c0b411434ee"", ""patch"": ""@@ -135,6 +135,11 @@ class VIEWS_EXPORT CustomButton : public Button,\n   scoped_ptr<gfx::ThrobAnimation> hover_animation_;\n \n  private:\n+  // Returns true if this is not a top level widget. Virtual for tests.\n+  virtual bool IsChildWidget() const;\n+  // Returns true if the focus is not in a top level widget. Virtual for tests.\n+  virtual bool FocusInChildWidget() const;\n+\n   // Should we animate when the state changes? Defaults to true.\n   bool animate_on_state_change_;\n ""}<_**next**_>{""sha"": ""7a079fe7bba05f22de2c3e0b5209d16579e94b1b"", ""filename"": ""ui/views/controls/button/custom_button_unittest.cc"", ""status"": ""modified"", ""additions"": 54, ""deletions"": 3, ""changes"": 57, ""blob_url"": ""https://github.com/chromium/chromium/blob/297ae873b471a46929ea39697b121c0b411434ee/ui/views/controls/button/custom_button_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/297ae873b471a46929ea39697b121c0b411434ee/ui/views/controls/button/custom_button_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/views/controls/button/custom_button_unittest.cc?ref=297ae873b471a46929ea39697b121c0b411434ee"", ""patch"": ""@@ -43,12 +43,36 @@ class TestCustomButton : public CustomButton, public ButtonListener {\n \n   void Reset() { notified_ = false; }\n \n+  // CustomButton methods:\n+  bool IsChildWidget() const override { return is_child_widget_; }\n+  bool FocusInChildWidget() const override { return focus_in_child_widget_; }\n+\n+  void set_child_widget(bool b) { is_child_widget_ = b; }\n+  void set_focus_in_child_widget(bool b) { focus_in_child_widget_ = b; }\n+\n  private:\n   bool notified_ = false;\n+  bool is_child_widget_ = false;\n+  bool focus_in_child_widget_ = false;\n \n   DISALLOW_COPY_AND_ASSIGN(TestCustomButton);\n };\n \n+class TestWidget : public Widget {\n+ public:\n+  TestWidget() : Widget() {}\n+\n+  // Widget method:\n+  bool IsActive() const override { return active_; }\n+\n+  void set_active(bool active) { active_ = active; }\n+\n+ private:\n+  bool active_ = false;\n+\n+  DISALLOW_COPY_AND_ASSIGN(TestWidget);\n+};\n+\n class CustomButtonTest : public ViewsTestBase {\n  public:\n   CustomButtonTest() {}\n@@ -59,7 +83,7 @@ class CustomButtonTest : public ViewsTestBase {\n \n     // Create a widget so that the CustomButton can query the hover state\n     // correctly.\n-    widget_.reset(new Widget);\n+    widget_.reset(new TestWidget);\n     Widget::InitParams params = CreateParams(Widget::InitParams::TYPE_POPUP);\n     params.ownership = views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET;\n     params.bounds = gfx::Rect(0, 0, 650, 650);\n@@ -82,11 +106,11 @@ class CustomButtonTest : public ViewsTestBase {\n     ViewsTestBase::TearDown();\n   }\n \n-  Widget* widget() { return widget_.get(); }\n+  TestWidget* widget() { return widget_.get(); }\n   TestCustomButton* button() { return button_; }\n \n  private:\n-  scoped_ptr<Widget> widget_;\n+  scoped_ptr<TestWidget> widget_;\n   TestCustomButton* button_;\n \n   DISALLOW_COPY_AND_ASSIGN(CustomButtonTest);\n@@ -204,6 +228,33 @@ TEST_F(CustomButtonTest, NotifyAction) {\n   EXPECT_FALSE(button()->notified());\n }\n \n+TEST_F(CustomButtonTest, HandleAccelerator) {\n+  // Child widgets shouldn't handle accelerators when they are not focused.\n+  EXPECT_FALSE(button()->IsChildWidget());\n+  EXPECT_FALSE(button()->FocusInChildWidget());\n+  EXPECT_FALSE(widget()->IsActive());\n+  button()->AcceleratorPressed(ui::Accelerator(ui::VKEY_RETURN, ui::EF_NONE));\n+  EXPECT_FALSE(button()->notified());\n+  // Child without focus.\n+  button()->set_child_widget(true);\n+  button()->set_focus_in_child_widget(false);\n+  button()->AcceleratorPressed(ui::Accelerator(ui::VKEY_RETURN, ui::EF_NONE));\n+  EXPECT_FALSE(button()->notified());\n+  button()->Reset();\n+  // Child with focus.\n+  button()->set_child_widget(true);\n+  button()->set_focus_in_child_widget(true);\n+  button()->AcceleratorPressed(ui::Accelerator(ui::VKEY_RETURN, ui::EF_NONE));\n+  EXPECT_TRUE(button()->notified());\n+  button()->Reset();\n+  // Not a child, but active.\n+  button()->set_child_widget(false);\n+  button()->set_focus_in_child_widget(true);\n+  widget()->set_active(true);\n+  button()->AcceleratorPressed(ui::Accelerator(ui::VKEY_RETURN, ui::EF_NONE));\n+  EXPECT_TRUE(button()->notified());\n+}\n+\n // No touch on desktop Mac. Tracked in http://crbug.com/445520.\n #if !defined(OS_MACOSX) || defined(USE_AURA)\n ""}"," bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {
  // Should only handle accelerators when active. However, only top level
  // widgets can be active, so for child widgets check if they are focused
  // instead.
  if ((IsChildWidget() && !FocusInChildWidget()) ||
      (!IsChildWidget() && !GetWidget()->IsActive())) {
    return false;
  }
   SetState(STATE_NORMAL);
   ui::MouseEvent synthetic_event(
      ui::ET_MOUSE_RELEASED, gfx::Point(), gfx::Point(), ui::EventTimeForNow(),
      ui::EF_LEFT_MOUSE_BUTTON, ui::EF_LEFT_MOUSE_BUTTON);
  NotifyClick(synthetic_event);
  return true;
}
"," bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {
   SetState(STATE_NORMAL);
   ui::MouseEvent synthetic_event(
      ui::ET_MOUSE_RELEASED, gfx::Point(), gfx::Point(), ui::EventTimeForNow(),
      ui::EF_LEFT_MOUSE_BUTTON, ui::EF_LEFT_MOUSE_BUTTON);
  NotifyClick(synthetic_event);
  return true;
}
",C,"  // Should only handle accelerators when active. However, only top level
  // widgets can be active, so for child widgets check if they are focused
  // instead.
  if ((IsChildWidget() && !FocusInChildWidget()) ||
      (!IsChildWidget() && !GetWidget()->IsActive())) {
    return false;
  }
",,,"@@ -251,6 +251,13 @@ void CustomButton::OnGestureEvent(ui::GestureEvent* event) {
 }
 
 bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {
+  // Should only handle accelerators when active. However, only top level
+  // widgets can be active, so for child widgets check if they are focused
+  // instead.
+  if ((IsChildWidget() && !FocusInChildWidget()) ||
+      (!IsChildWidget() && !GetWidget()->IsActive())) {
+    return false;
+  }
   SetState(STATE_NORMAL);
   // TODO(beng): remove once NotifyClick takes ui::Event.
   ui::MouseEvent synthetic_event(
@@ -378,4 +385,14 @@ void CustomButton::OnBlur() {
     SetState(STATE_NORMAL);
 }
 
+bool CustomButton::IsChildWidget() const {
+  return GetWidget() && GetWidget()->GetTopLevelWidget() != GetWidget();
+}
+
+bool CustomButton::FocusInChildWidget() const {
+  return GetWidget() &&
+         GetWidget()->GetRootView()->Contains(
+             GetFocusManager()->GetFocusedView());
+}
+
 }  // namespace views",Chrome,297ae873b471a46929ea39697b121c0b411434ee,597404d651817e8ab1886cba0a888361df320123,1," bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {
//fix_flaw_line_below:
//  // Should only handle accelerators when active. However, only top level
//fix_flaw_line_below:
//  // widgets can be active, so for child widgets check if they are focused
//fix_flaw_line_below:
//  // instead.
//fix_flaw_line_below:
//  if ((IsChildWidget() && !FocusInChildWidget()) ||
//fix_flaw_line_below:
//      (!IsChildWidget() && !GetWidget()->IsActive())) {
//fix_flaw_line_below:
//    return false;
//fix_flaw_line_below:
//  }
   SetState(STATE_NORMAL);
   // TODO(beng): remove once NotifyClick takes ui::Event.
   ui::MouseEvent synthetic_event(
      ui::ET_MOUSE_RELEASED, gfx::Point(), gfx::Point(), ui::EventTimeForNow(),
      ui::EF_LEFT_MOUSE_BUTTON, ui::EF_LEFT_MOUSE_BUTTON);
  NotifyClick(synthetic_event);
  return true;
}
"
8512,186248,,Remote,Not required,,CVE-2016-1657,https://www.cvedetails.com/cve/CVE-2016-1657/,CWE-254,Medium,,Partial,,2016-04-18,4.3,"The WebContentsImpl::FocusLocationBarByDefault function in content/browser/web_contents/web_contents_impl.cc in Google Chrome before 50.0.2661.75 mishandles focus for certain about:blank pages, which allows remote attackers to spoof the address bar via a crafted URL.",2018-10-30,,25,https://github.com/chromium/chromium/commit/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e,f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e,"Revert ""Update fontconfig to 6cc99d6a""

This reverts commit e6db40d91d0bd2afeb39f78f6d22404c3525b63c.

Reason for revert:

Findit (https://goo.gl/kROfz5) identified CL at revision 567445 as the
culprit for failures in the build cycles as shown on:
https://findit-for-me.appspot.com/waterfall/culprit?key=ag9zfmZpbmRpdC1mb3ItbWVyRAsSDVdmU3VzcGVjdGVkQ0wiMWNocm9taXVtL2U2ZGI0MGQ5MWQwYmQyYWZlYjM5Zjc4ZjZkMjI0MDRjMzUyNWI2M2MM

Sample Failed Build: https://ci.chromium.org/buildbot/chromium.linux/Linux%20Builder%20%28dbg%29%2832%29/83483

Sample Failed Step: compile

Original change's description:
> Update fontconfig to 6cc99d6a
> 
> Changelog [1].  This is necessary to pick up [2] for fixing undefined-shift
> UBSAN errors detected by clusterfuzz, [3] to allow removing a build workaround,
> [4] to fix a bug and clean up some log spam, [5] to fix CFI builds, and [6] to
> fix a use-after-free.
> 
> Fontconfig also now requires libuuid as a dependency, so whitelist it as a
> dependency since we statically link fontconfig.
> 
> [1] https://chromium.googlesource.com/external/fontconfig/+log/b546940435ebfb0df575bc7a2350d1e913919c34..6cc99d6a82ad67d2f5eac887b28bca13c0dfddde
> [2] https://chromium.googlesource.com/external/fontconfig/+/c60ed9ef66e59584f8b54323018e9e6c69925c7e
> [3] https://chromium.googlesource.com/external/fontconfig/+/b8a225b3c3495942480377b7b3404710c70be914
> [4] https://chromium.googlesource.com/external/fontconfig/+/7ad010e80bdf8e41303e322882ece908f5e04c74
> [5] https://chromium.googlesource.com/external/fontconfig/+/096e8019be595c2224aaabf98da630ee917ee51c
> [6] https://chromium.googlesource.com/external/fontconfig/+/6cc99d6a82ad67d2f5eac887b28bca13c0dfddde
> 
> BUG=831146,822737,787020,829890,847323
> TBR=thestig,dnicoara
> 
> Change-Id: Ic2d1bd19af8ca131c960a30d09246827c115ccec
> Reviewed-on: https://chromium-review.googlesource.com/1095538
> Commit-Queue: Thomas Anderson <thomasanderson@chromium.org>
> Reviewed-by: Thomas Anderson <thomasanderson@chromium.org>
> Reviewed-by: Lei Zhang <thestig@chromium.org>
> Reviewed-by: Daniel Nicoara <dnicoara@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#567445}

No-Presubmit: true
No-Tree-Checks: true
No-Try: true
BUG=831146,822737,787020,829890,847323

Change-Id: I47d475941350efc76370fa5eb5043c80c5063495
Reviewed-on: https://chromium-review.googlesource.com/1101759
Cr-Commit-Position: refs/heads/master@{#567472}",17,base/test/fontconfig_util_linux.cc,"{""sha"": ""d99ebd2a596662303e935d9513c382c92211cb77"", ""filename"": ""DEPS"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/DEPS?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -588,7 +588,7 @@ deps = {\n \n   # Used for embedded builds. CrOS & Linux use the system version.\n   'src/third_party/fontconfig/src': {\n-      'url': Var('chromium_git') + '/external/fontconfig.git' + '@' + '6cc99d6a82ad67d2f5eac887b28bca13c0dfddde',\n+      'url': Var('chromium_git') + '/external/fontconfig.git' + '@' + 'b546940435ebfb0df575bc7a2350d1e913919c34',\n       'condition': 'checkout_linux',\n   },\n ""}<_**next**_>{""sha"": ""5c9bf5cee9589a1cb17c311acc0f72a012253979"", ""filename"": ""base/test/fontconfig_util_linux.cc"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 30, ""changes"": 55, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/base/test/fontconfig_util_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/base/test/fontconfig_util_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/test/fontconfig_util_linux.cc?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -7,7 +7,6 @@\n #include <fontconfig/fontconfig.h>\n \n #include \""base/base_paths.h\""\n-#include \""base/environment.h\""\n #include \""base/files/file_path.h\""\n #include \""base/files/file_util.h\""\n #include \""base/logging.h\""\n@@ -382,35 +381,31 @@ const char kFontsConfTemplate[] = R\""(<?xml version=\""1.0\""?>\n }  // namespace\n \n void SetUpFontconfig() {\n-  // TODO(thomasanderson): Use FONTCONFIG_SYSROOT to avoid having to write\n-  // a new fonts.conf with updated paths.\n-  std::unique_ptr<Environment> env = Environment::Create();\n-  if (!env->HasVar(\""FONTCONFIG_FILE\"")) {\n-    // fonts.conf must be generated on-the-fly since it contains absolute paths\n-    // which may be different if\n-    //   1. The user moves/renames their build directory (or any parent dirs).\n-    //   2. The build directory is mapped on a swarming bot at a location\n-    //      different from the one the buildbot used.\n-    FilePath dir_module;\n-    PathService::Get(DIR_MODULE, &dir_module);\n-    FilePath font_cache = dir_module.Append(\""fontconfig_caches\"");\n-    FilePath test_fonts = dir_module.Append(\""test_fonts\"");\n-    std::string fonts_conf = ReplaceStringPlaceholders(\n-        kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);\n-\n-    // Write the data to a different file and then atomically rename it to\n-    // fonts.conf.  This avoids the file being in a bad state when different\n-    // parallel tests call this function at the same time.\n-    FilePath fonts_conf_file_temp;\n-    CHECK(CreateTemporaryFileInDir(dir_module, &fonts_conf_file_temp));\n-    CHECK(\n-        WriteFile(fonts_conf_file_temp, fonts_conf.c_str(), fonts_conf.size()));\n-    FilePath fonts_conf_file = dir_module.Append(\""fonts.conf\"");\n-    CHECK(ReplaceFile(fonts_conf_file_temp, fonts_conf_file, nullptr));\n-    env->SetVar(\""FONTCONFIG_FILE\"", fonts_conf_file.value());\n-  }\n-\n-  CHECK(FcInit());\n+  FilePath dir_module;\n+  PathService::Get(DIR_MODULE, &dir_module);\n+  FilePath font_cache = dir_module.Append(\""fontconfig_caches\"");\n+  FilePath test_fonts = dir_module.Append(\""test_fonts\"");\n+  std::string fonts_conf = ReplaceStringPlaceholders(\n+      kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);\n+\n+  FcConfig* config = FcConfigCreate();\n+  CHECK(config);\n+#if FC_VERSION >= 21205\n+  CHECK(FcConfigParseAndLoadFromMemory(\n+      config, reinterpret_cast<const FcChar8*>(fonts_conf.c_str()), FcTrue));\n+#else\n+  FilePath temp;\n+  CHECK(CreateTemporaryFile(&temp));\n+  CHECK(WriteFile(temp, fonts_conf.c_str(), fonts_conf.size()));\n+  CHECK(FcConfigParseAndLoad(\n+      config, reinterpret_cast<const FcChar8*>(temp.value().c_str()), FcTrue));\n+  CHECK(DeleteFile(temp, false));\n+#endif\n+  CHECK(FcConfigBuildFonts(config));\n+  CHECK(FcConfigSetCurrent(config));\n+\n+  // Decrement the reference count for |config|.  It's now owned by fontconfig.\n+  FcConfigDestroy(config);\n }\n \n void TearDownFontconfig() {""}<_**next**_>{""sha"": ""9487fb2d3b944253b0eca5c2b48f0d5a4cf319d7"", ""filename"": ""chrome/installer/linux/debian/dist_package_versions.json"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 36, ""changes"": 66, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/chrome/installer/linux/debian/dist_package_versions.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/chrome/installer/linux/debian/dist_package_versions.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/installer/linux/debian/dist_package_versions.json?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -2,26 +2,25 @@\n     \""Debian 10 (Buster)\"": {\n         \""libappindicator3-1\"": \""0.4.92-5\"",\n         \""libasound2\"": \""1.1.3-5\"",\n-        \""libatk-bridge2.0-0\"": \""2.26.2-1\"",\n-        \""libatk1.0-0\"": \""2.28.1-1\"",\n-        \""libc6\"": \""2.27-3\"",\n-        \""libcairo2\"": \""1.15.10-1\"",\n-        \""libcups2\"": \""2.2.7-2\"",\n-        \""libdbus-1-3\"": \""1.12.6-2\"",\n+        \""libatk-bridge2.0-0\"": \""2.26.1-1\"",\n+        \""libatk1.0-0\"": \""2.26.1-3\"",\n+        \""libc6\"": \""2.26-4\"",\n+        \""libcairo2\"": \""1.15.8-3\"",\n+        \""libcups2\"": \""2.2.6-4\"",\n+        \""libdbus-1-3\"": \""1.12.2-1\"",\n         \""libexpat1\"": \""2.2.5-3\"",\n-        \""libgcc1\"": \""1:8-20180402-1\"",\n-        \""libgdk-pixbuf2.0-0\"": \""2.36.11-2\"",\n-        \""libglib2.0-0\"": \""2.56.0-4\"",\n-        \""libgtk-3-0\"": \""3.22.29-3\"",\n-        \""libnspr4\"": \""2:4.18-1\"",\n-        \""libnss3\"": \""2:3.35-2\"",\n-        \""libpango-1.0-0\"": \""1.42.0-1\"",\n-        \""libpangocairo-1.0-0\"": \""1.42.0-1\"",\n-        \""libstdc++6\"": \""8-20180402-1\"",\n-        \""libuuid1\"": \""2.31.1-0.5\"",\n-        \""libx11-6\"": \""2:1.6.5-1\"",\n-        \""libx11-xcb1\"": \""2:1.6.5-1\"",\n-        \""libxcb1\"": \""1.13-1\"",\n+        \""libgcc1\"": \""1:7.2.0-19\"",\n+        \""libgdk-pixbuf2.0-0\"": \""2.36.11-1\"",\n+        \""libglib2.0-0\"": \""2.54.3-2\"",\n+        \""libgtk-3-0\"": \""3.22.26-2\"",\n+        \""libnspr4\"": \""2:4.16-1+b1\"",\n+        \""libnss3\"": \""2:3.34.1-1\"",\n+        \""libpango-1.0-0\"": \""1.40.14-1\"",\n+        \""libpangocairo-1.0-0\"": \""1.40.14-1\"",\n+        \""libstdc++6\"": \""7.2.0-19\"",\n+        \""libx11-6\"": \""2:1.6.4-3\"",\n+        \""libx11-xcb1\"": \""2:1.6.4-3\"",\n+        \""libxcb1\"": \""1.12-1\"",\n         \""libxcomposite1\"": \""1:0.4.4-2\"",\n         \""libxcursor1\"": \""1:1.1.15-1\"",\n         \""libxdamage1\"": \""1:1.1.4-3\"",\n@@ -43,16 +42,15 @@\n         \""libcups2\"": \""1.7.5-11+deb8u1\"",\n         \""libdbus-1-3\"": \""1.8.22-0+deb8u1\"",\n         \""libexpat1\"": \""2.1.0-6+deb8u4\"",\n-        \""libgcc1\"": \""1:4.9.2-10+deb8u1\"",\n+        \""libgcc1\"": \""1:4.9.2-10\"",\n         \""libgdk-pixbuf2.0-0\"": \""2.31.1-2+deb8u7\"",\n         \""libglib2.0-0\"": \""2.42.1-1+b1\"",\n         \""libgtk-3-0\"": \""3.14.5-1+deb8u1\"",\n         \""libnspr4\"": \""2:4.12-1+debu8u1\"",\n         \""libnss3\"": \""2:3.26-1+debu8u3\"",\n         \""libpango-1.0-0\"": \""1.36.8-3\"",\n         \""libpangocairo-1.0-0\"": \""1.36.8-3\"",\n-        \""libstdc++6\"": \""4.9.2-10+deb8u1\"",\n-        \""libuuid1\"": \""2.25.2-6\"",\n+        \""libstdc++6\"": \""4.9.2-10\"",\n         \""libx11-6\"": \""2:1.6.2-3+deb8u1\"",\n         \""libx11-xcb1\"": \""2:1.6.2-3+deb8u1\"",\n         \""libxcb1\"": \""1.10-3+b1\"",\n@@ -74,19 +72,18 @@\n         \""libatk1.0-0\"": \""2.22.0-1\"",\n         \""libc6\"": \""2.24-11+deb9u1\"",\n         \""libcairo2\"": \""1.14.8-1\"",\n-        \""libcups2\"": \""2.2.1-8+deb9u1\"",\n-        \""libdbus-1-3\"": \""1.10.26-0+deb9u1\"",\n+        \""libcups2\"": \""2.2.1-8\"",\n+        \""libdbus-1-3\"": \""1.10.24-0+deb9u1\"",\n         \""libexpat1\"": \""2.2.0-2+deb9u1\"",\n-        \""libgcc1\"": \""1:6.3.0-18+deb9u1\"",\n+        \""libgcc1\"": \""1:6.3.0-18\"",\n         \""libgdk-pixbuf2.0-0\"": \""2.36.5-2+deb9u2\"",\n         \""libglib2.0-0\"": \""2.50.3-2\"",\n         \""libgtk-3-0\"": \""3.22.11-1\"",\n         \""libnspr4\"": \""2:4.12-6\"",\n         \""libnss3\"": \""2:3.26.2-1.1+deb9u1\"",\n         \""libpango-1.0-0\"": \""1.40.5-1\"",\n         \""libpangocairo-1.0-0\"": \""1.40.5-1\"",\n-        \""libstdc++6\"": \""6.3.0-18+deb9u1\"",\n-        \""libuuid1\"": \""2.29.2-1+deb9u1\"",\n+        \""libstdc++6\"": \""6.3.0-18\"",\n         \""libx11-6\"": \""2:1.6.4-3\"",\n         \""libx11-xcb1\"": \""2:1.6.4-3\"",\n         \""libxcb1\"": \""1.12-1\"",\n@@ -108,7 +105,7 @@\n         \""libatk1.0-0\"": \""2.10.0-2ubuntu2\"",\n         \""libc6\"": \""2.19-0ubuntu6.14\"",\n         \""libcairo2\"": \""1.13.0~20140204-0ubuntu1.1\"",\n-        \""libcups2\"": \""1.7.2-0ubuntu1.9\"",\n+        \""libcups2\"": \""1.7.2-0ubuntu1.7\"",\n         \""libdbus-1-3\"": \""1.6.18-0ubuntu4.4\"",\n         \""libexpat1\"": \""2.1.0-4ubuntu1.4\"",\n         \""libgcc1\"": \""1:4.9.3-0ubuntu4\"",\n@@ -119,8 +116,7 @@\n         \""libnss3\"": \""2:3.28.4-0ubuntu0.14.04.3\"",\n         \""libpango-1.0-0\"": \""1.36.3-1ubuntu1.1\"",\n         \""libpangocairo-1.0-0\"": \""1.36.3-1ubuntu1.1\"",\n-        \""libstdc++6\"": \""4.8.4-2ubuntu1~14.04.4\"",\n-        \""libuuid1\"": \""2.20.1-5.1ubuntu20.9\"",\n+        \""libstdc++6\"": \""4.8.4-2ubuntu1~14.04.3\"",\n         \""libx11-6\"": \""2:1.6.2-1ubuntu2\"",\n         \""libx11-xcb1\"": \""2:1.6.2-1ubuntu2\"",\n         \""libxcb1\"": \""1.10-2ubuntu1\"",\n@@ -142,7 +138,7 @@\n         \""libatk1.0-0\"": \""2.18.0-1\"",\n         \""libc6\"": \""2.23-0ubuntu10\"",\n         \""libcairo2\"": \""1.14.6-1\"",\n-        \""libcups2\"": \""2.1.3-4ubuntu0.4\"",\n+        \""libcups2\"": \""2.1.3-4ubuntu0.3\"",\n         \""libdbus-1-3\"": \""1.10.6-1ubuntu3.1\"",\n         \""libexpat1\"": \""2.1.0-7ubuntu0.16.04.3\"",\n         \""libgcc1\"": \""1:6.0.1-0ubuntu1\"",\n@@ -153,8 +149,7 @@\n         \""libnss3\"": \""2:3.28.4-0ubuntu0.16.04.3\"",\n         \""libpango-1.0-0\"": \""1.38.1-1\"",\n         \""libpangocairo-1.0-0\"": \""1.38.1-1\"",\n-        \""libstdc++6\"": \""5.4.0-6ubuntu1~16.04.9\"",\n-        \""libuuid1\"": \""2.27.1-6ubuntu3.4\"",\n+        \""libstdc++6\"": \""5.4.0-6ubuntu1~16.04.4\"",\n         \""libx11-6\"": \""2:1.6.3-1ubuntu2\"",\n         \""libx11-xcb1\"": \""2:1.6.3-1ubuntu2\"",\n         \""libxcb1\"": \""1.11.1-1ubuntu1\"",\n@@ -179,16 +174,15 @@\n         \""libcups2\"": \""2.2.4-7ubuntu3\"",\n         \""libdbus-1-3\"": \""1.10.22-1ubuntu1\"",\n         \""libexpat1\"": \""2.2.3-1\"",\n-        \""libgcc1\"": \""1:7.2.0-8ubuntu3.2\"",\n+        \""libgcc1\"": \""1:7.2.0-8ubuntu3\"",\n         \""libgdk-pixbuf2.0-0\"": \""2.36.11-1ubuntu0.1\"",\n         \""libglib2.0-0\"": \""2.54.1-1ubuntu1\"",\n         \""libgtk-3-0\"": \""3.22.25-0ubuntu0.1\"",\n         \""libnspr4\"": \""2:4.16-1ubuntu2\"",\n         \""libnss3\"": \""2:3.32-1ubuntu3\"",\n         \""libpango-1.0-0\"": \""1.40.12-1\"",\n         \""libpangocairo-1.0-0\"": \""1.40.12-1\"",\n-        \""libstdc++6\"": \""7.2.0-8ubuntu3.2\"",\n-        \""libuuid1\"": \""2.30.1-0ubuntu4.1\"",\n+        \""libstdc++6\"": \""7.2.0-8ubuntu3\"",\n         \""libx11-6\"": \""2:1.6.4-3\"",\n         \""libx11-xcb1\"": \""2:1.6.4-3\"",\n         \""libxcb1\"": \""1.12-1ubuntu1\"",""}<_**next**_>{""sha"": ""481dfd7b1930385ff44862dc9cd0ba112b422417"", ""filename"": ""chrome/installer/linux/debian/update_dist_package_versions.py"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/chrome/installer/linux/debian/update_dist_package_versions.py"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/chrome/installer/linux/debian/update_dist_package_versions.py"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/installer/linux/debian/update_dist_package_versions.py?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -52,7 +52,6 @@\n     \""libpango-1.0-0\"",\n     \""libpangocairo-1.0-0\"",\n     \""libstdc++6\"",\n-    \""libuuid1\"",\n     \""libx11-6\"",\n     \""libx11-xcb1\"",\n     \""libxcb1\"",""}<_**next**_>{""sha"": ""9edf127d28b20e6286e8c9ee12c8462aa270a487"", ""filename"": ""chrome/installer/linux/rpm/dist_package_provides.json"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 28, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/chrome/installer/linux/rpm/dist_package_provides.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/chrome/installer/linux/rpm/dist_package_provides.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/installer/linux/rpm/dist_package_provides.json?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -236,10 +236,6 @@\n         \""libstdc++.so.6(GLIBCXX_3.4.7)(64bit)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.8)(64bit)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.9)(64bit)\"",\n-        \""libuuid.so.1()(64bit)\"",\n-        \""libuuid.so.1(UUIDD_PRIVATE)(64bit)\"",\n-        \""libuuid.so.1(UUID_1.0)(64bit)\"",\n-        \""libuuid.so.1(UUID_2.20)(64bit)\"",\n         \""libxcb.so.1()(64bit)\"",\n         \""rtld(GNU_HASH)\""\n     ],\n@@ -486,10 +482,6 @@\n         \""libstdc++.so.6(GLIBCXX_3.4.7)(64bit)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.8)(64bit)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.9)(64bit)\"",\n-        \""libuuid.so.1()(64bit)\"",\n-        \""libuuid.so.1(UUIDD_PRIVATE)(64bit)\"",\n-        \""libuuid.so.1(UUID_1.0)(64bit)\"",\n-        \""libuuid.so.1(UUID_2.20)(64bit)\"",\n         \""libxcb.so.1()(64bit)\"",\n         \""rtld(GNU_HASH)\""\n     ],\n@@ -737,10 +729,6 @@\n         \""libstdc++.so.6(GLIBCXX_3.4.7)(64bit)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.8)(64bit)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.9)(64bit)\"",\n-        \""libuuid.so.1()(64bit)\"",\n-        \""libuuid.so.1(UUIDD_PRIVATE)(64bit)\"",\n-        \""libuuid.so.1(UUID_1.0)(64bit)\"",\n-        \""libuuid.so.1(UUID_2.20)(64bit)\"",\n         \""libxcb.so.1()(64bit)\"",\n         \""rtld(GNU_HASH)\""\n     ],\n@@ -1191,14 +1179,6 @@\n         \""libstdc++.so.6(GLIBCXX_3.4.8)(64bit)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.9)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.9)(64bit)\"",\n-        \""libuuid.so.1\"",\n-        \""libuuid.so.1()(64bit)\"",\n-        \""libuuid.so.1(UUIDD_PRIVATE)\"",\n-        \""libuuid.so.1(UUIDD_PRIVATE)(64bit)\"",\n-        \""libuuid.so.1(UUID_1.0)\"",\n-        \""libuuid.so.1(UUID_1.0)(64bit)\"",\n-        \""libuuid.so.1(UUID_2.20)\"",\n-        \""libuuid.so.1(UUID_2.20)(64bit)\"",\n         \""libxcb.so.1\"",\n         \""libxcb.so.1()(64bit)\"",\n         \""rtld(GNU_HASH)\""\n@@ -1658,14 +1638,6 @@\n         \""libstdc++.so.6(GLIBCXX_3.4.8)(64bit)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.9)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.9)(64bit)\"",\n-        \""libuuid.so.1\"",\n-        \""libuuid.so.1()(64bit)\"",\n-        \""libuuid.so.1(UUIDD_PRIVATE)\"",\n-        \""libuuid.so.1(UUIDD_PRIVATE)(64bit)\"",\n-        \""libuuid.so.1(UUID_1.0)\"",\n-        \""libuuid.so.1(UUID_1.0)(64bit)\"",\n-        \""libuuid.so.1(UUID_2.20)\"",\n-        \""libuuid.so.1(UUID_2.20)(64bit)\"",\n         \""libxcb.so.1\"",\n         \""libxcb.so.1()(64bit)\"",\n         \""rtld(GNU_HASH)\""""}<_**next**_>{""sha"": ""4ce30012357a32e1316dbb3930ce55ddf9acacfa"", ""filename"": ""chrome/installer/linux/rpm/update_package_provides.py"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/chrome/installer/linux/rpm/update_package_provides.py"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/chrome/installer/linux/rpm/update_package_provides.py"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/installer/linux/rpm/update_package_provides.py?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -54,7 +54,6 @@\n     \""librt.so\"",\n     \""libsmime3.so\"",\n     \""libstdc++.so\"",\n-    \""libuuid.so\"",\n     \""libxcb.so\"",\n     \""rtld(GNU_HASH)\"",\n ]""}<_**next**_>{""sha"": ""19c41003de611bd0727cfd4f3385c5041fac07bf"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/text/unicode-fallback-font-expected.png"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/WebKit/LayoutTests/platform/linux/fast/text/unicode-fallback-font-expected.png"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/WebKit/LayoutTests/platform/linux/fast/text/unicode-fallback-font-expected.png"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/text/unicode-fallback-font-expected.png?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e""}<_**next**_>{""sha"": ""8ff1984a7df58ca5df821c1076a13c3483c40b20"", ""filename"": ""third_party/fontconfig/BUILD.gn"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 13, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/BUILD.gn?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -15,6 +15,7 @@ if (use_bundled_fontconfig) {\n     sources = [\n       \""src/src/fcarch.h\"",\n       \""src/src/fcatomic.c\"",\n+      \""src/src/fcblanks.c\"",\n       \""src/src/fccache.c\"",\n       \""src/src/fccfg.c\"",\n       \""src/src/fccharset.c\"",\n@@ -25,7 +26,6 @@ if (use_bundled_fontconfig) {\n       \""src/src/fcformat.c\"",\n       \""src/src/fcfreetype.c\"",\n       \""src/src/fcfs.c\"",\n-      \""src/src/fchash.c\"",\n       \""src/src/fcinit.c\"",\n       \""src/src/fclang.c\"",\n       \""src/src/fclist.c\"",\n@@ -34,7 +34,6 @@ if (use_bundled_fontconfig) {\n       \""src/src/fcname.c\"",\n       \""src/src/fcobjs.c\"",\n       \""src/src/fcpat.c\"",\n-      \""src/src/fcptrlist.c\"",\n       \""src/src/fcrange.c\"",\n       \""src/src/fcserialize.c\"",\n       \""src/src/fcstat.c\"",\n@@ -53,17 +52,14 @@ if (use_bundled_fontconfig) {\n     defines = [\n       \""HAVE_CONFIG_H\"",\n       \""FC_CACHEDIR=\\\""/var/cache/fontconfig\\\""\"",\n-      \""FC_TEMPLATEDIR=\\\""/usr/share/fontconfig/conf.avail\\\""\"",\n       \""FONTCONFIG_PATH=\\\""/etc/fonts\\\""\"",\n     ]\n \n-    # Fontconfig symbols should not be exported from chrome, nacl_helper, or\n-    # anything else.\n+    # This is a hack to remove visibility(\""default\"") annotations.  Fontconfig\n+    # symbols should not be exported from chrome, nacl_helper, or anything\n+    # else.\n     if (!is_component_build) {\n-      defines += [\n-        \""FC_ATTRIBUTE_VISIBILITY_HIDDEN=__attribute((visibility(\\\""hidden\\\"")))\"",\n-        \""FC_ATTRIBUTE_VISIBILITY_EXPORT=__attribute((visibility(\\\""hidden\\\"")))\"",\n-      ]\n+      defines += [ \""visibility(x)=\"" ]\n     }\n \n     deps = [\n@@ -86,10 +82,6 @@ if (use_bundled_fontconfig) {\n         \""-Wno-pointer-bool-conversion\"",\n       ]\n     }\n-\n-    if (!is_win) {\n-      libs = [ \""uuid\"" ]\n-    }\n   }\n } else {\n   config(\""fontconfig_config\"") {""}<_**next**_>{""sha"": ""82160d5ef526a87226c3551c2c4b41edb82ab1b9"", ""filename"": ""third_party/fontconfig/OWNERS"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/OWNERS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/OWNERS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/OWNERS?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -1,3 +1,2 @@\n spang@chromium.org\n dnicoara@chromium.org\n-thomasanderson@chromium.org""}<_**next**_>{""sha"": ""5a7a10c36e3fd1f50b10ff81cd3074f249ae74e5"", ""filename"": ""third_party/fontconfig/README.chromium"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 5, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/README.chromium"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/README.chromium"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/README.chromium?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -1,6 +1,6 @@\n Name: fontconfig\n URL: http://www.freedesktop.org/wiki/Software/fontconfig/\n-Version: 6cc99d6a82ad67d2f5eac887b28bca13c0dfddde\n+Version: 2.12.6\n License: MIT\n License File: src/COPYING\n Security Critical: yes\n@@ -12,11 +12,9 @@ Modifications:\n - None\n \n To import a new snapshot of fontconfig:\n-- Checkout the latest revision:\n-    git fetch origin master\n-    git checkout origin/master\n+- Checkout the latest release tag: git checkout 2.12.6\n - Change the DEPS entry to the newly checked out commit.\n - Update generated files:\n-    ./autogen.sh --enable-libxml2 --disable-docs && make\n+    ./autogen.sh --enable-libxml2 && make\n     rsync -R $(git ls-files --others '*.h' '*/*.h') ../include\n - Update this README to reflect the new version number.""}<_**next**_>{""sha"": ""82b0e6581bb118db13b04e4944dbadfd4424c544"", ""filename"": ""third_party/fontconfig/include/config.h"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 37, ""changes"": 55, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/config.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/config.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/include/config.h?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -13,10 +13,6 @@\n /* Use libxml2 instead of Expat */\n #define ENABLE_LIBXML2 1\n \n-/* Define to 1 if translation of program messages to the user's native\n-   language is requested. */\n-#define ENABLE_NLS 1\n-\n /* Additional font directories */\n #define FC_ADD_FONTS \""yes\""\n \n@@ -27,7 +23,7 @@\n #define FC_DEFAULT_FONTS \""/usr/share/fonts\""\n \n /* The type of len parameter of the gperf hash/lookup function */\n-#define FC_GPERF_SIZE_T size_t\n+#define FC_GPERF_SIZE_T unsigned int\n \n /* Define to nothing if C supports flexible array members, and to 1 if it does\n    not. That way, with a declaration like `struct s { int n; double\n@@ -38,21 +34,6 @@\n    MSVC and with C++ compilers. */\n #define FLEXIBLE_ARRAY_MEMBER /**/\n \n-/* Gettext package */\n-#define GETTEXT_PACKAGE \""fontconfig\""\n-\n-/* Define to 1 if you have the Mac OS X function CFLocaleCopyCurrent in the\n-   CoreFoundation framework. */\n-/* #undef HAVE_CFLOCALECOPYCURRENT */\n-\n-/* Define to 1 if you have the Mac OS X function CFPreferencesCopyAppValue in\n-   the CoreFoundation framework. */\n-/* #undef HAVE_CFPREFERENCESCOPYAPPVALUE */\n-\n-/* Define if the GNU dcgettext() function is already present or preinstalled.\n-   */\n-#define HAVE_DCGETTEXT 1\n-\n /* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.\n    */\n #define HAVE_DIRENT_H 1\n@@ -72,12 +53,15 @@\n /* Define to 1 if you have the `fstatvfs' function. */\n #define HAVE_FSTATVFS 1\n \n-/* Define to 1 if you have the `FT_Done_MM_Var' function. */\n-/* #undef HAVE_FT_DONE_MM_VAR */\n+/* FT_Bitmap_Size structure includes y_ppem field */\n+#define HAVE_FT_BITMAP_SIZE_Y_PPEM 1\n \n /* Define to 1 if you have the `FT_Get_BDF_Property' function. */\n #define HAVE_FT_GET_BDF_PROPERTY 1\n \n+/* Define to 1 if you have the `FT_Get_Next_Char' function. */\n+#define HAVE_FT_GET_NEXT_CHAR 1\n+\n /* Define to 1 if you have the `FT_Get_PS_Font_Info' function. */\n #define HAVE_FT_GET_PS_FONT_INFO 1\n \n@@ -87,6 +71,9 @@\n /* Define to 1 if you have the `FT_Has_PS_Glyph_Names' function. */\n #define HAVE_FT_HAS_PS_GLYPH_NAMES 1\n \n+/* Define to 1 if you have the `FT_Select_Size' function. */\n+#define HAVE_FT_SELECT_SIZE 1\n+\n /* Define to 1 if you have the `getexecname' function. */\n /* #undef HAVE_GETEXECNAME */\n \n@@ -102,12 +89,6 @@\n /* Define to 1 if you have the `getprogname' function. */\n /* #undef HAVE_GETPROGNAME */\n \n-/* Define if the GNU gettext() function is already present or preinstalled. */\n-#define HAVE_GETTEXT 1\n-\n-/* Define if you have the iconv() function and it works. */\n-/* #undef HAVE_ICONV */\n-\n /* Have Intel __sync_* atomic primitives */\n #define HAVE_INTEL_ATOMIC_PRIMITIVES 1\n \n@@ -180,12 +161,6 @@\n /* Define to 1 if you have the <stdlib.h> header file. */\n #define HAVE_STDLIB_H 1\n \n-/* Define to 1 if you have the `strerror' function. */\n-#define HAVE_STRERROR 1\n-\n-/* Define to 1 if you have the `strerror_r' function. */\n-#define HAVE_STRERROR_R 1\n-\n /* Define to 1 if you have the <strings.h> header file. */\n #define HAVE_STRINGS_H 1\n \n@@ -239,6 +214,12 @@\n /* Define to 1 if you have the <sys/vfs.h> header file. */\n #define HAVE_SYS_VFS_H 1\n \n+/* Define to 1 if `usLowerOpticalPointSize' is a member of `TT_OS2'. */\n+#define HAVE_TT_OS2_USLOWEROPTICALPOINTSIZE 1\n+\n+/* Define to 1 if `usUpperOpticalPointSize' is a member of `TT_OS2'. */\n+#define HAVE_TT_OS2_USUPPEROPTICALPOINTSIZE 1\n+\n /* Define to 1 if you have the <unistd.h> header file. */\n #define HAVE_UNISTD_H 1\n \n@@ -270,7 +251,7 @@\n #define PACKAGE_NAME \""fontconfig\""\n \n /* Define to the full name and version of this package. */\n-#define PACKAGE_STRING \""fontconfig 2.13.0\""\n+#define PACKAGE_STRING \""fontconfig 2.12.6\""\n \n /* Define to the one symbol short name of this package. */\n #define PACKAGE_TARNAME \""fontconfig\""\n@@ -279,7 +260,7 @@\n #define PACKAGE_URL \""\""\n \n /* Define to the version of this package. */\n-#define PACKAGE_VERSION \""2.13.0\""\n+#define PACKAGE_VERSION \""2.12.6\""\n \n /* Define to necessary symbol if this constant uses a non-standard name on\n    your system. */\n@@ -332,7 +313,7 @@\n \n \n /* Version number of package */\n-#define VERSION \""2.13.0\""\n+#define VERSION \""2.12.6\""\n \n /* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n    significant byte first (like Motorola and SPARC, unlike Intel). */""}<_**next**_>{""sha"": ""5be716d0c8468917ad5a755714757272f9d4aeba"", ""filename"": ""third_party/fontconfig/include/fc-case/fccase.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 5, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/fc-case/fccase.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/fc-case/fccase.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/include/fc-case/fccase.h?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -22,7 +22,7 @@\n  * PERFORMANCE OF THIS SOFTWARE.\n  */\n \n-#define FC_NUM_CASE_FOLD\t291\n+#define FC_NUM_CASE_FOLD\t288\n #define FC_NUM_CASE_FOLD_CHARS\t471\n #define FC_MAX_CASE_FOLD_CHARS\t6\n #define FC_MAX_CASE_FOLD_EXPAND\t4\n@@ -146,8 +146,6 @@ static const FcCaseFold    fcCaseFold[FC_NUM_CASE_FOLD] = {\n     { 0x00001c86, FC_CASE_FOLD_RANGE,    0x0001,  -6204 },\n     { 0x00001c87, FC_CASE_FOLD_RANGE,    0x0001,  -6180 },\n     { 0x00001c88, FC_CASE_FOLD_RANGE,    0x0001, -30269 },\n-    { 0x00001c90, FC_CASE_FOLD_RANGE,    0x002b,  -3008 },\n-    { 0x00001cbd, FC_CASE_FOLD_RANGE,    0x0003,  -3008 },\n     { 0x00001e00, FC_CASE_FOLD_EVEN_ODD, 0x0095,      1 },\n     { 0x00001e96, FC_CASE_FOLD_FULL,     0x0003,     27 },\n     { 0x00001e97, FC_CASE_FOLD_FULL,     0x0003,     30 },\n@@ -300,7 +298,7 @@ static const FcCaseFold    fcCaseFold[FC_NUM_CASE_FOLD] = {\n     { 0x0000a7b1, FC_CASE_FOLD_RANGE,    0x0001,  23254 },\n     { 0x0000a7b2, FC_CASE_FOLD_RANGE,    0x0001,  23275 },\n     { 0x0000a7b3, FC_CASE_FOLD_RANGE,    0x0001,    928 },\n-    { 0x0000a7b4, FC_CASE_FOLD_EVEN_ODD, 0x0005,      1 },\n+    { 0x0000a7b4, FC_CASE_FOLD_EVEN_ODD, 0x0003,      1 },\n     { 0x0000ab70, FC_CASE_FOLD_RANGE,    0x0050,  26672 },\n     { 0x0000fb00, FC_CASE_FOLD_FULL,     0x0002,    435 },\n     { 0x0000fb01, FC_CASE_FOLD_FULL,     0x0002,    437 },\n@@ -319,7 +317,6 @@ static const FcCaseFold    fcCaseFold[FC_NUM_CASE_FOLD] = {\n     { 0x000104b0, FC_CASE_FOLD_RANGE,    0x0024,     40 },\n     { 0x00010c80, FC_CASE_FOLD_RANGE,    0x0033,     64 },\n     { 0x000118a0, FC_CASE_FOLD_RANGE,    0x0020,     32 },\n-    { 0x00016e40, FC_CASE_FOLD_RANGE,    0x0020,     32 },\n     { 0x0001e900, FC_CASE_FOLD_RANGE,    0x0022,     34 },\n };\n ""}<_**next**_>{""sha"": ""153915847283ee51ce4105578bc1cef92dd32ecf"", ""filename"": ""third_party/fontconfig/include/src/fcalias.h"", ""status"": ""modified"", ""additions"": 207, ""deletions"": 241, ""changes"": 448, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcalias.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcalias.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/include/src/fcalias.h?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -1,448 +1,414 @@\n-extern __typeof (FcBlanksCreate) IA__FcBlanksCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcBlanksCreate) IA__FcBlanksCreate __attribute((visibility(\""hidden\"")));\n #define FcBlanksCreate IA__FcBlanksCreate\n-extern __typeof (FcBlanksDestroy) IA__FcBlanksDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcBlanksDestroy) IA__FcBlanksDestroy __attribute((visibility(\""hidden\"")));\n #define FcBlanksDestroy IA__FcBlanksDestroy\n-extern __typeof (FcBlanksAdd) IA__FcBlanksAdd FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcBlanksAdd) IA__FcBlanksAdd __attribute((visibility(\""hidden\"")));\n #define FcBlanksAdd IA__FcBlanksAdd\n-extern __typeof (FcBlanksIsMember) IA__FcBlanksIsMember FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcBlanksIsMember) IA__FcBlanksIsMember __attribute((visibility(\""hidden\"")));\n #define FcBlanksIsMember IA__FcBlanksIsMember\n-extern __typeof (FcCacheCopySet) IA__FcCacheCopySet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCacheCopySet) IA__FcCacheCopySet __attribute((visibility(\""hidden\"")));\n #define FcCacheCopySet IA__FcCacheCopySet\n-extern __typeof (FcCacheNumSubdir) IA__FcCacheNumSubdir FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCacheNumSubdir) IA__FcCacheNumSubdir __attribute((visibility(\""hidden\"")));\n #define FcCacheNumSubdir IA__FcCacheNumSubdir\n-extern __typeof (FcCacheNumFont) IA__FcCacheNumFont FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCacheNumFont) IA__FcCacheNumFont __attribute((visibility(\""hidden\"")));\n #define FcCacheNumFont IA__FcCacheNumFont\n-extern __typeof (FcDirCacheUnlink) IA__FcDirCacheUnlink FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirCacheUnlink) IA__FcDirCacheUnlink __attribute((visibility(\""hidden\"")));\n #define FcDirCacheUnlink IA__FcDirCacheUnlink\n-extern __typeof (FcDirCacheValid) IA__FcDirCacheValid FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirCacheValid) IA__FcDirCacheValid __attribute((visibility(\""hidden\"")));\n #define FcDirCacheValid IA__FcDirCacheValid\n-extern __typeof (FcDirCacheClean) IA__FcDirCacheClean FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirCacheClean) IA__FcDirCacheClean __attribute((visibility(\""hidden\"")));\n #define FcDirCacheClean IA__FcDirCacheClean\n-extern __typeof (FcCacheCreateTagFile) IA__FcCacheCreateTagFile FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCacheCreateTagFile) IA__FcCacheCreateTagFile __attribute((visibility(\""hidden\"")));\n #define FcCacheCreateTagFile IA__FcCacheCreateTagFile\n-extern __typeof (FcDirCacheCreateUUID) IA__FcDirCacheCreateUUID FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcDirCacheCreateUUID IA__FcDirCacheCreateUUID\n-extern __typeof (FcDirCacheDeleteUUID) IA__FcDirCacheDeleteUUID FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcDirCacheDeleteUUID IA__FcDirCacheDeleteUUID\n-extern __typeof (FcConfigHome) IA__FcConfigHome FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigHome) IA__FcConfigHome __attribute((visibility(\""hidden\"")));\n #define FcConfigHome IA__FcConfigHome\n-extern __typeof (FcConfigEnableHome) IA__FcConfigEnableHome FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigEnableHome) IA__FcConfigEnableHome __attribute((visibility(\""hidden\"")));\n #define FcConfigEnableHome IA__FcConfigEnableHome\n-extern __typeof (FcConfigFilename) IA__FcConfigFilename FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigFilename) IA__FcConfigFilename __attribute((visibility(\""hidden\"")));\n #define FcConfigFilename IA__FcConfigFilename\n-extern __typeof (FcConfigCreate) IA__FcConfigCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigCreate) IA__FcConfigCreate __attribute((visibility(\""hidden\"")));\n #define FcConfigCreate IA__FcConfigCreate\n-extern __typeof (FcConfigReference) IA__FcConfigReference FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigReference) IA__FcConfigReference __attribute((visibility(\""hidden\"")));\n #define FcConfigReference IA__FcConfigReference\n-extern __typeof (FcConfigDestroy) IA__FcConfigDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigDestroy) IA__FcConfigDestroy __attribute((visibility(\""hidden\"")));\n #define FcConfigDestroy IA__FcConfigDestroy\n-extern __typeof (FcConfigSetCurrent) IA__FcConfigSetCurrent FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigSetCurrent) IA__FcConfigSetCurrent __attribute((visibility(\""hidden\"")));\n #define FcConfigSetCurrent IA__FcConfigSetCurrent\n-extern __typeof (FcConfigGetCurrent) IA__FcConfigGetCurrent FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetCurrent) IA__FcConfigGetCurrent __attribute((visibility(\""hidden\"")));\n #define FcConfigGetCurrent IA__FcConfigGetCurrent\n-extern __typeof (FcConfigUptoDate) IA__FcConfigUptoDate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigUptoDate) IA__FcConfigUptoDate __attribute((visibility(\""hidden\"")));\n #define FcConfigUptoDate IA__FcConfigUptoDate\n-extern __typeof (FcConfigBuildFonts) IA__FcConfigBuildFonts FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigBuildFonts) IA__FcConfigBuildFonts __attribute((visibility(\""hidden\"")));\n #define FcConfigBuildFonts IA__FcConfigBuildFonts\n-extern __typeof (FcConfigGetFontDirs) IA__FcConfigGetFontDirs FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetFontDirs) IA__FcConfigGetFontDirs __attribute((visibility(\""hidden\"")));\n #define FcConfigGetFontDirs IA__FcConfigGetFontDirs\n-extern __typeof (FcConfigGetConfigDirs) IA__FcConfigGetConfigDirs FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetConfigDirs) IA__FcConfigGetConfigDirs __attribute((visibility(\""hidden\"")));\n #define FcConfigGetConfigDirs IA__FcConfigGetConfigDirs\n-extern __typeof (FcConfigGetConfigFiles) IA__FcConfigGetConfigFiles FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetConfigFiles) IA__FcConfigGetConfigFiles __attribute((visibility(\""hidden\"")));\n #define FcConfigGetConfigFiles IA__FcConfigGetConfigFiles\n-extern __typeof (FcConfigGetCache) IA__FcConfigGetCache FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetCache) IA__FcConfigGetCache __attribute((visibility(\""hidden\"")));\n #define FcConfigGetCache IA__FcConfigGetCache\n-extern __typeof (FcConfigGetBlanks) IA__FcConfigGetBlanks FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetBlanks) IA__FcConfigGetBlanks __attribute((visibility(\""hidden\"")));\n #define FcConfigGetBlanks IA__FcConfigGetBlanks\n-extern __typeof (FcConfigGetCacheDirs) IA__FcConfigGetCacheDirs FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetCacheDirs) IA__FcConfigGetCacheDirs __attribute((visibility(\""hidden\"")));\n #define FcConfigGetCacheDirs IA__FcConfigGetCacheDirs\n-extern __typeof (FcConfigGetRescanInterval) IA__FcConfigGetRescanInterval FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetRescanInterval) IA__FcConfigGetRescanInterval __attribute((visibility(\""hidden\"")));\n #define FcConfigGetRescanInterval IA__FcConfigGetRescanInterval\n-extern __typeof (FcConfigSetRescanInterval) IA__FcConfigSetRescanInterval FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigSetRescanInterval) IA__FcConfigSetRescanInterval __attribute((visibility(\""hidden\"")));\n #define FcConfigSetRescanInterval IA__FcConfigSetRescanInterval\n-extern __typeof (FcConfigGetFonts) IA__FcConfigGetFonts FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetFonts) IA__FcConfigGetFonts __attribute((visibility(\""hidden\"")));\n #define FcConfigGetFonts IA__FcConfigGetFonts\n-extern __typeof (FcConfigAppFontAddFile) IA__FcConfigAppFontAddFile FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigAppFontAddFile) IA__FcConfigAppFontAddFile __attribute((visibility(\""hidden\"")));\n #define FcConfigAppFontAddFile IA__FcConfigAppFontAddFile\n-extern __typeof (FcConfigAppFontAddDir) IA__FcConfigAppFontAddDir FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigAppFontAddDir) IA__FcConfigAppFontAddDir __attribute((visibility(\""hidden\"")));\n #define FcConfigAppFontAddDir IA__FcConfigAppFontAddDir\n-extern __typeof (FcConfigAppFontClear) IA__FcConfigAppFontClear FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigAppFontClear) IA__FcConfigAppFontClear __attribute((visibility(\""hidden\"")));\n #define FcConfigAppFontClear IA__FcConfigAppFontClear\n-extern __typeof (FcConfigSubstituteWithPat) IA__FcConfigSubstituteWithPat FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigSubstituteWithPat) IA__FcConfigSubstituteWithPat __attribute((visibility(\""hidden\"")));\n #define FcConfigSubstituteWithPat IA__FcConfigSubstituteWithPat\n-extern __typeof (FcConfigSubstitute) IA__FcConfigSubstitute FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigSubstitute) IA__FcConfigSubstitute __attribute((visibility(\""hidden\"")));\n #define FcConfigSubstitute IA__FcConfigSubstitute\n-extern __typeof (FcConfigGetSysRoot) IA__FcConfigGetSysRoot FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetSysRoot) IA__FcConfigGetSysRoot __attribute((visibility(\""hidden\"")));\n #define FcConfigGetSysRoot IA__FcConfigGetSysRoot\n-extern __typeof (FcConfigSetSysRoot) IA__FcConfigSetSysRoot FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigSetSysRoot) IA__FcConfigSetSysRoot __attribute((visibility(\""hidden\"")));\n #define FcConfigSetSysRoot IA__FcConfigSetSysRoot\n-extern __typeof (FcConfigFileInfoIterInit) IA__FcConfigFileInfoIterInit FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcConfigFileInfoIterInit IA__FcConfigFileInfoIterInit\n-extern __typeof (FcConfigFileInfoIterNext) IA__FcConfigFileInfoIterNext FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcConfigFileInfoIterNext IA__FcConfigFileInfoIterNext\n-extern __typeof (FcConfigFileInfoIterGet) IA__FcConfigFileInfoIterGet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcConfigFileInfoIterGet IA__FcConfigFileInfoIterGet\n-extern __typeof (FcCharSetCreate) IA__FcCharSetCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetCreate) IA__FcCharSetCreate __attribute((visibility(\""hidden\"")));\n #define FcCharSetCreate IA__FcCharSetCreate\n-extern __typeof (FcCharSetNew) IA__FcCharSetNew FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetNew) IA__FcCharSetNew __attribute((visibility(\""hidden\"")));\n #define FcCharSetNew IA__FcCharSetNew\n-extern __typeof (FcCharSetDestroy) IA__FcCharSetDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetDestroy) IA__FcCharSetDestroy __attribute((visibility(\""hidden\"")));\n #define FcCharSetDestroy IA__FcCharSetDestroy\n-extern __typeof (FcCharSetAddChar) IA__FcCharSetAddChar FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetAddChar) IA__FcCharSetAddChar __attribute((visibility(\""hidden\"")));\n #define FcCharSetAddChar IA__FcCharSetAddChar\n-extern __typeof (FcCharSetDelChar) IA__FcCharSetDelChar FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetDelChar) IA__FcCharSetDelChar __attribute((visibility(\""hidden\"")));\n #define FcCharSetDelChar IA__FcCharSetDelChar\n-extern __typeof (FcCharSetCopy) IA__FcCharSetCopy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetCopy) IA__FcCharSetCopy __attribute((visibility(\""hidden\"")));\n #define FcCharSetCopy IA__FcCharSetCopy\n-extern __typeof (FcCharSetEqual) IA__FcCharSetEqual FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetEqual) IA__FcCharSetEqual __attribute((visibility(\""hidden\"")));\n #define FcCharSetEqual IA__FcCharSetEqual\n-extern __typeof (FcCharSetIntersect) IA__FcCharSetIntersect FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetIntersect) IA__FcCharSetIntersect __attribute((visibility(\""hidden\"")));\n #define FcCharSetIntersect IA__FcCharSetIntersect\n-extern __typeof (FcCharSetUnion) IA__FcCharSetUnion FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetUnion) IA__FcCharSetUnion __attribute((visibility(\""hidden\"")));\n #define FcCharSetUnion IA__FcCharSetUnion\n-extern __typeof (FcCharSetSubtract) IA__FcCharSetSubtract FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetSubtract) IA__FcCharSetSubtract __attribute((visibility(\""hidden\"")));\n #define FcCharSetSubtract IA__FcCharSetSubtract\n-extern __typeof (FcCharSetMerge) IA__FcCharSetMerge FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetMerge) IA__FcCharSetMerge __attribute((visibility(\""hidden\"")));\n #define FcCharSetMerge IA__FcCharSetMerge\n-extern __typeof (FcCharSetHasChar) IA__FcCharSetHasChar FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetHasChar) IA__FcCharSetHasChar __attribute((visibility(\""hidden\"")));\n #define FcCharSetHasChar IA__FcCharSetHasChar\n-extern __typeof (FcCharSetCount) IA__FcCharSetCount FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetCount) IA__FcCharSetCount __attribute((visibility(\""hidden\"")));\n #define FcCharSetCount IA__FcCharSetCount\n-extern __typeof (FcCharSetIntersectCount) IA__FcCharSetIntersectCount FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetIntersectCount) IA__FcCharSetIntersectCount __attribute((visibility(\""hidden\"")));\n #define FcCharSetIntersectCount IA__FcCharSetIntersectCount\n-extern __typeof (FcCharSetSubtractCount) IA__FcCharSetSubtractCount FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetSubtractCount) IA__FcCharSetSubtractCount __attribute((visibility(\""hidden\"")));\n #define FcCharSetSubtractCount IA__FcCharSetSubtractCount\n-extern __typeof (FcCharSetIsSubset) IA__FcCharSetIsSubset FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetIsSubset) IA__FcCharSetIsSubset __attribute((visibility(\""hidden\"")));\n #define FcCharSetIsSubset IA__FcCharSetIsSubset\n-extern __typeof (FcCharSetFirstPage) IA__FcCharSetFirstPage FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetFirstPage) IA__FcCharSetFirstPage __attribute((visibility(\""hidden\"")));\n #define FcCharSetFirstPage IA__FcCharSetFirstPage\n-extern __typeof (FcCharSetNextPage) IA__FcCharSetNextPage FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetNextPage) IA__FcCharSetNextPage __attribute((visibility(\""hidden\"")));\n #define FcCharSetNextPage IA__FcCharSetNextPage\n-extern __typeof (FcCharSetCoverage) IA__FcCharSetCoverage FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetCoverage) IA__FcCharSetCoverage __attribute((visibility(\""hidden\"")));\n #define FcCharSetCoverage IA__FcCharSetCoverage\n-extern __typeof (FcValuePrint) IA__FcValuePrint FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcValuePrint) IA__FcValuePrint __attribute((visibility(\""hidden\"")));\n #define FcValuePrint IA__FcValuePrint\n-extern __typeof (FcPatternPrint) IA__FcPatternPrint FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternPrint) IA__FcPatternPrint __attribute((visibility(\""hidden\"")));\n #define FcPatternPrint IA__FcPatternPrint\n-extern __typeof (FcFontSetPrint) IA__FcFontSetPrint FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSetPrint) IA__FcFontSetPrint __attribute((visibility(\""hidden\"")));\n #define FcFontSetPrint IA__FcFontSetPrint\n-extern __typeof (FcGetDefaultLangs) IA__FcGetDefaultLangs FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcGetDefaultLangs) IA__FcGetDefaultLangs __attribute((visibility(\""hidden\"")));\n #define FcGetDefaultLangs IA__FcGetDefaultLangs\n-extern __typeof (FcDefaultSubstitute) IA__FcDefaultSubstitute FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDefaultSubstitute) IA__FcDefaultSubstitute __attribute((visibility(\""hidden\"")));\n #define FcDefaultSubstitute IA__FcDefaultSubstitute\n-extern __typeof (FcFileIsDir) IA__FcFileIsDir FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFileIsDir) IA__FcFileIsDir __attribute((visibility(\""hidden\"")));\n #define FcFileIsDir IA__FcFileIsDir\n-extern __typeof (FcFileScan) IA__FcFileScan FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFileScan) IA__FcFileScan __attribute((visibility(\""hidden\"")));\n #define FcFileScan IA__FcFileScan\n-extern __typeof (FcDirScan) IA__FcDirScan FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirScan) IA__FcDirScan __attribute((visibility(\""hidden\"")));\n #define FcDirScan IA__FcDirScan\n-extern __typeof (FcDirSave) IA__FcDirSave FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirSave) IA__FcDirSave __attribute((visibility(\""hidden\"")));\n #define FcDirSave IA__FcDirSave\n-extern __typeof (FcDirCacheLoad) IA__FcDirCacheLoad FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirCacheLoad) IA__FcDirCacheLoad __attribute((visibility(\""hidden\"")));\n #define FcDirCacheLoad IA__FcDirCacheLoad\n-extern __typeof (FcDirCacheRescan) IA__FcDirCacheRescan FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirCacheRescan) IA__FcDirCacheRescan __attribute((visibility(\""hidden\"")));\n #define FcDirCacheRescan IA__FcDirCacheRescan\n-extern __typeof (FcDirCacheRead) IA__FcDirCacheRead FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirCacheRead) IA__FcDirCacheRead __attribute((visibility(\""hidden\"")));\n #define FcDirCacheRead IA__FcDirCacheRead\n-extern __typeof (FcDirCacheLoadFile) IA__FcDirCacheLoadFile FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirCacheLoadFile) IA__FcDirCacheLoadFile __attribute((visibility(\""hidden\"")));\n #define FcDirCacheLoadFile IA__FcDirCacheLoadFile\n-extern __typeof (FcDirCacheUnload) IA__FcDirCacheUnload FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirCacheUnload) IA__FcDirCacheUnload __attribute((visibility(\""hidden\"")));\n #define FcDirCacheUnload IA__FcDirCacheUnload\n-extern __typeof (FcFreeTypeQuery) IA__FcFreeTypeQuery FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFreeTypeQuery) IA__FcFreeTypeQuery __attribute((visibility(\""hidden\"")));\n #define FcFreeTypeQuery IA__FcFreeTypeQuery\n-extern __typeof (FcFreeTypeQueryAll) IA__FcFreeTypeQueryAll FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcFreeTypeQueryAll IA__FcFreeTypeQueryAll\n-extern __typeof (FcFontSetCreate) IA__FcFontSetCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSetCreate) IA__FcFontSetCreate __attribute((visibility(\""hidden\"")));\n #define FcFontSetCreate IA__FcFontSetCreate\n-extern __typeof (FcFontSetDestroy) IA__FcFontSetDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSetDestroy) IA__FcFontSetDestroy __attribute((visibility(\""hidden\"")));\n #define FcFontSetDestroy IA__FcFontSetDestroy\n-extern __typeof (FcFontSetAdd) IA__FcFontSetAdd FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSetAdd) IA__FcFontSetAdd __attribute((visibility(\""hidden\"")));\n #define FcFontSetAdd IA__FcFontSetAdd\n-extern __typeof (FcInitLoadConfig) IA__FcInitLoadConfig FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcInitLoadConfig) IA__FcInitLoadConfig __attribute((visibility(\""hidden\"")));\n #define FcInitLoadConfig IA__FcInitLoadConfig\n-extern __typeof (FcInitLoadConfigAndFonts) IA__FcInitLoadConfigAndFonts FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcInitLoadConfigAndFonts) IA__FcInitLoadConfigAndFonts __attribute((visibility(\""hidden\"")));\n #define FcInitLoadConfigAndFonts IA__FcInitLoadConfigAndFonts\n-extern __typeof (FcInit) IA__FcInit FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcInit) IA__FcInit __attribute((visibility(\""hidden\"")));\n #define FcInit IA__FcInit\n-extern __typeof (FcFini) IA__FcFini FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFini) IA__FcFini __attribute((visibility(\""hidden\"")));\n #define FcFini IA__FcFini\n-extern __typeof (FcGetVersion) IA__FcGetVersion FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcGetVersion) IA__FcGetVersion __attribute((visibility(\""hidden\"")));\n #define FcGetVersion IA__FcGetVersion\n-extern __typeof (FcInitReinitialize) IA__FcInitReinitialize FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcInitReinitialize) IA__FcInitReinitialize __attribute((visibility(\""hidden\"")));\n #define FcInitReinitialize IA__FcInitReinitialize\n-extern __typeof (FcInitBringUptoDate) IA__FcInitBringUptoDate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcInitBringUptoDate) IA__FcInitBringUptoDate __attribute((visibility(\""hidden\"")));\n #define FcInitBringUptoDate IA__FcInitBringUptoDate\n-extern __typeof (FcGetLangs) IA__FcGetLangs FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcGetLangs) IA__FcGetLangs __attribute((visibility(\""hidden\"")));\n #define FcGetLangs IA__FcGetLangs\n-extern __typeof (FcLangNormalize) IA__FcLangNormalize FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangNormalize) IA__FcLangNormalize __attribute((visibility(\""hidden\"")));\n #define FcLangNormalize IA__FcLangNormalize\n-extern __typeof (FcLangGetCharSet) IA__FcLangGetCharSet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangGetCharSet) IA__FcLangGetCharSet __attribute((visibility(\""hidden\"")));\n #define FcLangGetCharSet IA__FcLangGetCharSet\n-extern __typeof (FcLangSetCreate) IA__FcLangSetCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetCreate) IA__FcLangSetCreate __attribute((visibility(\""hidden\"")));\n #define FcLangSetCreate IA__FcLangSetCreate\n-extern __typeof (FcLangSetDestroy) IA__FcLangSetDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetDestroy) IA__FcLangSetDestroy __attribute((visibility(\""hidden\"")));\n #define FcLangSetDestroy IA__FcLangSetDestroy\n-extern __typeof (FcLangSetCopy) IA__FcLangSetCopy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetCopy) IA__FcLangSetCopy __attribute((visibility(\""hidden\"")));\n #define FcLangSetCopy IA__FcLangSetCopy\n-extern __typeof (FcLangSetAdd) IA__FcLangSetAdd FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetAdd) IA__FcLangSetAdd __attribute((visibility(\""hidden\"")));\n #define FcLangSetAdd IA__FcLangSetAdd\n-extern __typeof (FcLangSetDel) IA__FcLangSetDel FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetDel) IA__FcLangSetDel __attribute((visibility(\""hidden\"")));\n #define FcLangSetDel IA__FcLangSetDel\n-extern __typeof (FcLangSetHasLang) IA__FcLangSetHasLang FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetHasLang) IA__FcLangSetHasLang __attribute((visibility(\""hidden\"")));\n #define FcLangSetHasLang IA__FcLangSetHasLang\n-extern __typeof (FcLangSetCompare) IA__FcLangSetCompare FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetCompare) IA__FcLangSetCompare __attribute((visibility(\""hidden\"")));\n #define FcLangSetCompare IA__FcLangSetCompare\n-extern __typeof (FcLangSetContains) IA__FcLangSetContains FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetContains) IA__FcLangSetContains __attribute((visibility(\""hidden\"")));\n #define FcLangSetContains IA__FcLangSetContains\n-extern __typeof (FcLangSetEqual) IA__FcLangSetEqual FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetEqual) IA__FcLangSetEqual __attribute((visibility(\""hidden\"")));\n #define FcLangSetEqual IA__FcLangSetEqual\n-extern __typeof (FcLangSetHash) IA__FcLangSetHash FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetHash) IA__FcLangSetHash __attribute((visibility(\""hidden\"")));\n #define FcLangSetHash IA__FcLangSetHash\n-extern __typeof (FcLangSetGetLangs) IA__FcLangSetGetLangs FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetGetLangs) IA__FcLangSetGetLangs __attribute((visibility(\""hidden\"")));\n #define FcLangSetGetLangs IA__FcLangSetGetLangs\n-extern __typeof (FcLangSetUnion) IA__FcLangSetUnion FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetUnion) IA__FcLangSetUnion __attribute((visibility(\""hidden\"")));\n #define FcLangSetUnion IA__FcLangSetUnion\n-extern __typeof (FcLangSetSubtract) IA__FcLangSetSubtract FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetSubtract) IA__FcLangSetSubtract __attribute((visibility(\""hidden\"")));\n #define FcLangSetSubtract IA__FcLangSetSubtract\n-extern __typeof (FcObjectSetCreate) IA__FcObjectSetCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcObjectSetCreate) IA__FcObjectSetCreate __attribute((visibility(\""hidden\"")));\n #define FcObjectSetCreate IA__FcObjectSetCreate\n-extern __typeof (FcObjectSetAdd) IA__FcObjectSetAdd FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcObjectSetAdd) IA__FcObjectSetAdd __attribute((visibility(\""hidden\"")));\n #define FcObjectSetAdd IA__FcObjectSetAdd\n-extern __typeof (FcObjectSetDestroy) IA__FcObjectSetDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcObjectSetDestroy) IA__FcObjectSetDestroy __attribute((visibility(\""hidden\"")));\n #define FcObjectSetDestroy IA__FcObjectSetDestroy\n-extern __typeof (FcObjectSetVaBuild) IA__FcObjectSetVaBuild FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcObjectSetVaBuild) IA__FcObjectSetVaBuild __attribute((visibility(\""hidden\"")));\n #define FcObjectSetVaBuild IA__FcObjectSetVaBuild\n-extern __typeof (FcObjectSetBuild) IA__FcObjectSetBuild FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcObjectSetBuild) IA__FcObjectSetBuild __attribute((visibility(\""hidden\"")));\n #define FcObjectSetBuild IA__FcObjectSetBuild\n-extern __typeof (FcFontSetList) IA__FcFontSetList FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSetList) IA__FcFontSetList __attribute((visibility(\""hidden\"")));\n #define FcFontSetList IA__FcFontSetList\n-extern __typeof (FcFontList) IA__FcFontList FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontList) IA__FcFontList __attribute((visibility(\""hidden\"")));\n #define FcFontList IA__FcFontList\n-extern __typeof (FcAtomicCreate) IA__FcAtomicCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcAtomicCreate) IA__FcAtomicCreate __attribute((visibility(\""hidden\"")));\n #define FcAtomicCreate IA__FcAtomicCreate\n-extern __typeof (FcAtomicLock) IA__FcAtomicLock FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcAtomicLock) IA__FcAtomicLock __attribute((visibility(\""hidden\"")));\n #define FcAtomicLock IA__FcAtomicLock\n-extern __typeof (FcAtomicNewFile) IA__FcAtomicNewFile FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcAtomicNewFile) IA__FcAtomicNewFile __attribute((visibility(\""hidden\"")));\n #define FcAtomicNewFile IA__FcAtomicNewFile\n-extern __typeof (FcAtomicOrigFile) IA__FcAtomicOrigFile FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcAtomicOrigFile) IA__FcAtomicOrigFile __attribute((visibility(\""hidden\"")));\n #define FcAtomicOrigFile IA__FcAtomicOrigFile\n-extern __typeof (FcAtomicReplaceOrig) IA__FcAtomicReplaceOrig FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcAtomicReplaceOrig) IA__FcAtomicReplaceOrig __attribute((visibility(\""hidden\"")));\n #define FcAtomicReplaceOrig IA__FcAtomicReplaceOrig\n-extern __typeof (FcAtomicDeleteNew) IA__FcAtomicDeleteNew FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcAtomicDeleteNew) IA__FcAtomicDeleteNew __attribute((visibility(\""hidden\"")));\n #define FcAtomicDeleteNew IA__FcAtomicDeleteNew\n-extern __typeof (FcAtomicUnlock) IA__FcAtomicUnlock FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcAtomicUnlock) IA__FcAtomicUnlock __attribute((visibility(\""hidden\"")));\n #define FcAtomicUnlock IA__FcAtomicUnlock\n-extern __typeof (FcAtomicDestroy) IA__FcAtomicDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcAtomicDestroy) IA__FcAtomicDestroy __attribute((visibility(\""hidden\"")));\n #define FcAtomicDestroy IA__FcAtomicDestroy\n-extern __typeof (FcFontSetMatch) IA__FcFontSetMatch FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSetMatch) IA__FcFontSetMatch __attribute((visibility(\""hidden\"")));\n #define FcFontSetMatch IA__FcFontSetMatch\n-extern __typeof (FcFontMatch) IA__FcFontMatch FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontMatch) IA__FcFontMatch __attribute((visibility(\""hidden\"")));\n #define FcFontMatch IA__FcFontMatch\n-extern __typeof (FcFontRenderPrepare) IA__FcFontRenderPrepare FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontRenderPrepare) IA__FcFontRenderPrepare __attribute((visibility(\""hidden\"")));\n #define FcFontRenderPrepare IA__FcFontRenderPrepare\n-extern __typeof (FcFontSetSort) IA__FcFontSetSort FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSetSort) IA__FcFontSetSort __attribute((visibility(\""hidden\"")));\n #define FcFontSetSort IA__FcFontSetSort\n-extern __typeof (FcFontSort) IA__FcFontSort FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSort) IA__FcFontSort __attribute((visibility(\""hidden\"")));\n #define FcFontSort IA__FcFontSort\n-extern __typeof (FcFontSetSortDestroy) IA__FcFontSetSortDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSetSortDestroy) IA__FcFontSetSortDestroy __attribute((visibility(\""hidden\"")));\n #define FcFontSetSortDestroy IA__FcFontSetSortDestroy\n-extern __typeof (FcMatrixCopy) IA__FcMatrixCopy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcMatrixCopy) IA__FcMatrixCopy __attribute((visibility(\""hidden\"")));\n #define FcMatrixCopy IA__FcMatrixCopy\n-extern __typeof (FcMatrixEqual) IA__FcMatrixEqual FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcMatrixEqual) IA__FcMatrixEqual __attribute((visibility(\""hidden\"")));\n #define FcMatrixEqual IA__FcMatrixEqual\n-extern __typeof (FcMatrixMultiply) IA__FcMatrixMultiply FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcMatrixMultiply) IA__FcMatrixMultiply __attribute((visibility(\""hidden\"")));\n #define FcMatrixMultiply IA__FcMatrixMultiply\n-extern __typeof (FcMatrixRotate) IA__FcMatrixRotate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcMatrixRotate) IA__FcMatrixRotate __attribute((visibility(\""hidden\"")));\n #define FcMatrixRotate IA__FcMatrixRotate\n-extern __typeof (FcMatrixScale) IA__FcMatrixScale FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcMatrixScale) IA__FcMatrixScale __attribute((visibility(\""hidden\"")));\n #define FcMatrixScale IA__FcMatrixScale\n-extern __typeof (FcMatrixShear) IA__FcMatrixShear FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcMatrixShear) IA__FcMatrixShear __attribute((visibility(\""hidden\"")));\n #define FcMatrixShear IA__FcMatrixShear\n-extern __typeof (FcNameRegisterObjectTypes) IA__FcNameRegisterObjectTypes FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameRegisterObjectTypes) IA__FcNameRegisterObjectTypes __attribute((visibility(\""hidden\"")));\n #define FcNameRegisterObjectTypes IA__FcNameRegisterObjectTypes\n-extern __typeof (FcNameUnregisterObjectTypes) IA__FcNameUnregisterObjectTypes FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameUnregisterObjectTypes) IA__FcNameUnregisterObjectTypes __attribute((visibility(\""hidden\"")));\n #define FcNameUnregisterObjectTypes IA__FcNameUnregisterObjectTypes\n-extern __typeof (FcNameGetObjectType) IA__FcNameGetObjectType FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameGetObjectType) IA__FcNameGetObjectType __attribute((visibility(\""hidden\"")));\n #define FcNameGetObjectType IA__FcNameGetObjectType\n-extern __typeof (FcNameRegisterConstants) IA__FcNameRegisterConstants FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameRegisterConstants) IA__FcNameRegisterConstants __attribute((visibility(\""hidden\"")));\n #define FcNameRegisterConstants IA__FcNameRegisterConstants\n-extern __typeof (FcNameUnregisterConstants) IA__FcNameUnregisterConstants FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameUnregisterConstants) IA__FcNameUnregisterConstants __attribute((visibility(\""hidden\"")));\n #define FcNameUnregisterConstants IA__FcNameUnregisterConstants\n-extern __typeof (FcNameGetConstant) IA__FcNameGetConstant FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameGetConstant) IA__FcNameGetConstant __attribute((visibility(\""hidden\"")));\n #define FcNameGetConstant IA__FcNameGetConstant\n-extern __typeof (FcNameConstant) IA__FcNameConstant FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameConstant) IA__FcNameConstant __attribute((visibility(\""hidden\"")));\n #define FcNameConstant IA__FcNameConstant\n-extern __typeof (FcNameParse) IA__FcNameParse FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameParse) IA__FcNameParse __attribute((visibility(\""hidden\"")));\n #define FcNameParse IA__FcNameParse\n-extern __typeof (FcNameUnparse) IA__FcNameUnparse FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameUnparse) IA__FcNameUnparse __attribute((visibility(\""hidden\"")));\n #define FcNameUnparse IA__FcNameUnparse\n-extern __typeof (FcPatternCreate) IA__FcPatternCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternCreate) IA__FcPatternCreate __attribute((visibility(\""hidden\"")));\n #define FcPatternCreate IA__FcPatternCreate\n-extern __typeof (FcPatternDuplicate) IA__FcPatternDuplicate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternDuplicate) IA__FcPatternDuplicate __attribute((visibility(\""hidden\"")));\n #define FcPatternDuplicate IA__FcPatternDuplicate\n-extern __typeof (FcPatternReference) IA__FcPatternReference FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternReference) IA__FcPatternReference __attribute((visibility(\""hidden\"")));\n #define FcPatternReference IA__FcPatternReference\n-extern __typeof (FcPatternFilter) IA__FcPatternFilter FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternFilter) IA__FcPatternFilter __attribute((visibility(\""hidden\"")));\n #define FcPatternFilter IA__FcPatternFilter\n-extern __typeof (FcValueDestroy) IA__FcValueDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcValueDestroy) IA__FcValueDestroy __attribute((visibility(\""hidden\"")));\n #define FcValueDestroy IA__FcValueDestroy\n-extern __typeof (FcValueEqual) IA__FcValueEqual FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcValueEqual) IA__FcValueEqual __attribute((visibility(\""hidden\"")));\n #define FcValueEqual IA__FcValueEqual\n-extern __typeof (FcValueSave) IA__FcValueSave FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcValueSave) IA__FcValueSave __attribute((visibility(\""hidden\"")));\n #define FcValueSave IA__FcValueSave\n-extern __typeof (FcPatternDestroy) IA__FcPatternDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternDestroy) IA__FcPatternDestroy __attribute((visibility(\""hidden\"")));\n #define FcPatternDestroy IA__FcPatternDestroy\n-extern __typeof (FcPatternObjectCount) IA__FcPatternObjectCount FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternObjectCount IA__FcPatternObjectCount\n-extern __typeof (FcPatternEqual) IA__FcPatternEqual FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternEqual) IA__FcPatternEqual __attribute((visibility(\""hidden\"")));\n #define FcPatternEqual IA__FcPatternEqual\n-extern __typeof (FcPatternEqualSubset) IA__FcPatternEqualSubset FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternEqualSubset) IA__FcPatternEqualSubset __attribute((visibility(\""hidden\"")));\n #define FcPatternEqualSubset IA__FcPatternEqualSubset\n-extern __typeof (FcPatternHash) IA__FcPatternHash FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternHash) IA__FcPatternHash __attribute((visibility(\""hidden\"")));\n #define FcPatternHash IA__FcPatternHash\n-extern __typeof (FcPatternAdd) IA__FcPatternAdd FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAdd) IA__FcPatternAdd __attribute((visibility(\""hidden\"")));\n #define FcPatternAdd IA__FcPatternAdd\n-extern __typeof (FcPatternAddWeak) IA__FcPatternAddWeak FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddWeak) IA__FcPatternAddWeak __attribute((visibility(\""hidden\"")));\n #define FcPatternAddWeak IA__FcPatternAddWeak\n-extern __typeof (FcPatternGet) IA__FcPatternGet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGet) IA__FcPatternGet __attribute((visibility(\""hidden\"")));\n #define FcPatternGet IA__FcPatternGet\n-extern __typeof (FcPatternGetWithBinding) IA__FcPatternGetWithBinding FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetWithBinding) IA__FcPatternGetWithBinding __attribute((visibility(\""hidden\"")));\n #define FcPatternGetWithBinding IA__FcPatternGetWithBinding\n-extern __typeof (FcPatternDel) IA__FcPatternDel FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternDel) IA__FcPatternDel __attribute((visibility(\""hidden\"")));\n #define FcPatternDel IA__FcPatternDel\n-extern __typeof (FcPatternRemove) IA__FcPatternRemove FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternRemove) IA__FcPatternRemove __attribute((visibility(\""hidden\"")));\n #define FcPatternRemove IA__FcPatternRemove\n-extern __typeof (FcPatternAddInteger) IA__FcPatternAddInteger FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddInteger) IA__FcPatternAddInteger __attribute((visibility(\""hidden\"")));\n #define FcPatternAddInteger IA__FcPatternAddInteger\n-extern __typeof (FcPatternAddDouble) IA__FcPatternAddDouble FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddDouble) IA__FcPatternAddDouble __attribute((visibility(\""hidden\"")));\n #define FcPatternAddDouble IA__FcPatternAddDouble\n-extern __typeof (FcPatternAddString) IA__FcPatternAddString FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddString) IA__FcPatternAddString __attribute((visibility(\""hidden\"")));\n #define FcPatternAddString IA__FcPatternAddString\n-extern __typeof (FcPatternAddMatrix) IA__FcPatternAddMatrix FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddMatrix) IA__FcPatternAddMatrix __attribute((visibility(\""hidden\"")));\n #define FcPatternAddMatrix IA__FcPatternAddMatrix\n-extern __typeof (FcPatternAddCharSet) IA__FcPatternAddCharSet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddCharSet) IA__FcPatternAddCharSet __attribute((visibility(\""hidden\"")));\n #define FcPatternAddCharSet IA__FcPatternAddCharSet\n-extern __typeof (FcPatternAddBool) IA__FcPatternAddBool FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddBool) IA__FcPatternAddBool __attribute((visibility(\""hidden\"")));\n #define FcPatternAddBool IA__FcPatternAddBool\n-extern __typeof (FcPatternAddLangSet) IA__FcPatternAddLangSet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddLangSet) IA__FcPatternAddLangSet __attribute((visibility(\""hidden\"")));\n #define FcPatternAddLangSet IA__FcPatternAddLangSet\n-extern __typeof (FcPatternAddRange) IA__FcPatternAddRange FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddRange) IA__FcPatternAddRange __attribute((visibility(\""hidden\"")));\n #define FcPatternAddRange IA__FcPatternAddRange\n-extern __typeof (FcPatternGetInteger) IA__FcPatternGetInteger FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetInteger) IA__FcPatternGetInteger __attribute((visibility(\""hidden\"")));\n #define FcPatternGetInteger IA__FcPatternGetInteger\n-extern __typeof (FcPatternGetDouble) IA__FcPatternGetDouble FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetDouble) IA__FcPatternGetDouble __attribute((visibility(\""hidden\"")));\n #define FcPatternGetDouble IA__FcPatternGetDouble\n-extern __typeof (FcPatternGetString) IA__FcPatternGetString FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetString) IA__FcPatternGetString __attribute((visibility(\""hidden\"")));\n #define FcPatternGetString IA__FcPatternGetString\n-extern __typeof (FcPatternGetMatrix) IA__FcPatternGetMatrix FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetMatrix) IA__FcPatternGetMatrix __attribute((visibility(\""hidden\"")));\n #define FcPatternGetMatrix IA__FcPatternGetMatrix\n-extern __typeof (FcPatternGetCharSet) IA__FcPatternGetCharSet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetCharSet) IA__FcPatternGetCharSet __attribute((visibility(\""hidden\"")));\n #define FcPatternGetCharSet IA__FcPatternGetCharSet\n-extern __typeof (FcPatternGetBool) IA__FcPatternGetBool FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetBool) IA__FcPatternGetBool __attribute((visibility(\""hidden\"")));\n #define FcPatternGetBool IA__FcPatternGetBool\n-extern __typeof (FcPatternGetLangSet) IA__FcPatternGetLangSet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetLangSet) IA__FcPatternGetLangSet __attribute((visibility(\""hidden\"")));\n #define FcPatternGetLangSet IA__FcPatternGetLangSet\n-extern __typeof (FcPatternGetRange) IA__FcPatternGetRange FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetRange) IA__FcPatternGetRange __attribute((visibility(\""hidden\"")));\n #define FcPatternGetRange IA__FcPatternGetRange\n-extern __typeof (FcPatternVaBuild) IA__FcPatternVaBuild FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternVaBuild) IA__FcPatternVaBuild __attribute((visibility(\""hidden\"")));\n #define FcPatternVaBuild IA__FcPatternVaBuild\n-extern __typeof (FcPatternBuild) IA__FcPatternBuild FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternBuild) IA__FcPatternBuild __attribute((visibility(\""hidden\"")));\n #define FcPatternBuild IA__FcPatternBuild\n-extern __typeof (FcPatternFormat) IA__FcPatternFormat FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternFormat) IA__FcPatternFormat __attribute((visibility(\""hidden\"")));\n #define FcPatternFormat IA__FcPatternFormat\n-extern __typeof (FcRangeCreateDouble) IA__FcRangeCreateDouble FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcRangeCreateDouble) IA__FcRangeCreateDouble __attribute((visibility(\""hidden\"")));\n #define FcRangeCreateDouble IA__FcRangeCreateDouble\n-extern __typeof (FcRangeCreateInteger) IA__FcRangeCreateInteger FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcRangeCreateInteger) IA__FcRangeCreateInteger __attribute((visibility(\""hidden\"")));\n #define FcRangeCreateInteger IA__FcRangeCreateInteger\n-extern __typeof (FcRangeDestroy) IA__FcRangeDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcRangeDestroy) IA__FcRangeDestroy __attribute((visibility(\""hidden\"")));\n #define FcRangeDestroy IA__FcRangeDestroy\n-extern __typeof (FcRangeCopy) IA__FcRangeCopy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcRangeCopy) IA__FcRangeCopy __attribute((visibility(\""hidden\"")));\n #define FcRangeCopy IA__FcRangeCopy\n-extern __typeof (FcRangeGetDouble) IA__FcRangeGetDouble FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcRangeGetDouble) IA__FcRangeGetDouble __attribute((visibility(\""hidden\"")));\n #define FcRangeGetDouble IA__FcRangeGetDouble\n-extern __typeof (FcPatternIterStart) IA__FcPatternIterStart FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternIterStart IA__FcPatternIterStart\n-extern __typeof (FcPatternIterNext) IA__FcPatternIterNext FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternIterNext IA__FcPatternIterNext\n-extern __typeof (FcPatternIterEqual) IA__FcPatternIterEqual FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternIterEqual IA__FcPatternIterEqual\n-extern __typeof (FcPatternFindIter) IA__FcPatternFindIter FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternFindIter IA__FcPatternFindIter\n-extern __typeof (FcPatternIterIsValid) IA__FcPatternIterIsValid FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternIterIsValid IA__FcPatternIterIsValid\n-extern __typeof (FcPatternIterGetObject) IA__FcPatternIterGetObject FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternIterGetObject IA__FcPatternIterGetObject\n-extern __typeof (FcPatternIterValueCount) IA__FcPatternIterValueCount FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternIterValueCount IA__FcPatternIterValueCount\n-extern __typeof (FcPatternIterGetValue) IA__FcPatternIterGetValue FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternIterGetValue IA__FcPatternIterGetValue\n-extern __typeof (FcWeightFromOpenType) IA__FcWeightFromOpenType FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcWeightFromOpenType) IA__FcWeightFromOpenType __attribute((visibility(\""hidden\"")));\n #define FcWeightFromOpenType IA__FcWeightFromOpenType\n-extern __typeof (FcWeightFromOpenTypeDouble) IA__FcWeightFromOpenTypeDouble FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcWeightFromOpenTypeDouble IA__FcWeightFromOpenTypeDouble\n-extern __typeof (FcWeightToOpenType) IA__FcWeightToOpenType FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcWeightToOpenType) IA__FcWeightToOpenType __attribute((visibility(\""hidden\"")));\n #define FcWeightToOpenType IA__FcWeightToOpenType\n-extern __typeof (FcWeightToOpenTypeDouble) IA__FcWeightToOpenTypeDouble FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcWeightToOpenTypeDouble IA__FcWeightToOpenTypeDouble\n-extern __typeof (FcStrCopy) IA__FcStrCopy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrCopy) IA__FcStrCopy __attribute((visibility(\""hidden\"")));\n #define FcStrCopy IA__FcStrCopy\n-extern __typeof (FcStrCopyFilename) IA__FcStrCopyFilename FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrCopyFilename) IA__FcStrCopyFilename __attribute((visibility(\""hidden\"")));\n #define FcStrCopyFilename IA__FcStrCopyFilename\n-extern __typeof (FcStrPlus) IA__FcStrPlus FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrPlus) IA__FcStrPlus __attribute((visibility(\""hidden\"")));\n #define FcStrPlus IA__FcStrPlus\n-extern __typeof (FcStrFree) IA__FcStrFree FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrFree) IA__FcStrFree __attribute((visibility(\""hidden\"")));\n #define FcStrFree IA__FcStrFree\n-extern __typeof (FcStrDowncase) IA__FcStrDowncase FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrDowncase) IA__FcStrDowncase __attribute((visibility(\""hidden\"")));\n #define FcStrDowncase IA__FcStrDowncase\n-extern __typeof (FcStrCmpIgnoreCase) IA__FcStrCmpIgnoreCase FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrCmpIgnoreCase) IA__FcStrCmpIgnoreCase __attribute((visibility(\""hidden\"")));\n #define FcStrCmpIgnoreCase IA__FcStrCmpIgnoreCase\n-extern __typeof (FcStrCmp) IA__FcStrCmp FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrCmp) IA__FcStrCmp __attribute((visibility(\""hidden\"")));\n #define FcStrCmp IA__FcStrCmp\n-extern __typeof (FcStrStrIgnoreCase) IA__FcStrStrIgnoreCase FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrStrIgnoreCase) IA__FcStrStrIgnoreCase __attribute((visibility(\""hidden\"")));\n #define FcStrStrIgnoreCase IA__FcStrStrIgnoreCase\n-extern __typeof (FcStrStr) IA__FcStrStr FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrStr) IA__FcStrStr __attribute((visibility(\""hidden\"")));\n #define FcStrStr IA__FcStrStr\n-extern __typeof (FcUtf8ToUcs4) IA__FcUtf8ToUcs4 FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcUtf8ToUcs4) IA__FcUtf8ToUcs4 __attribute((visibility(\""hidden\"")));\n #define FcUtf8ToUcs4 IA__FcUtf8ToUcs4\n-extern __typeof (FcUtf8Len) IA__FcUtf8Len FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcUtf8Len) IA__FcUtf8Len __attribute((visibility(\""hidden\"")));\n #define FcUtf8Len IA__FcUtf8Len\n-extern __typeof (FcUcs4ToUtf8) IA__FcUcs4ToUtf8 FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcUcs4ToUtf8) IA__FcUcs4ToUtf8 __attribute((visibility(\""hidden\"")));\n #define FcUcs4ToUtf8 IA__FcUcs4ToUtf8\n-extern __typeof (FcUtf16ToUcs4) IA__FcUtf16ToUcs4 FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcUtf16ToUcs4) IA__FcUtf16ToUcs4 __attribute((visibility(\""hidden\"")));\n #define FcUtf16ToUcs4 IA__FcUtf16ToUcs4\n-extern __typeof (FcUtf16Len) IA__FcUtf16Len FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcUtf16Len) IA__FcUtf16Len __attribute((visibility(\""hidden\"")));\n #define FcUtf16Len IA__FcUtf16Len\n-extern __typeof (FcStrDirname) IA__FcStrDirname FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrDirname) IA__FcStrDirname __attribute((visibility(\""hidden\"")));\n #define FcStrDirname IA__FcStrDirname\n-extern __typeof (FcStrBasename) IA__FcStrBasename FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrBasename) IA__FcStrBasename __attribute((visibility(\""hidden\"")));\n #define FcStrBasename IA__FcStrBasename\n-extern __typeof (FcStrSetCreate) IA__FcStrSetCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrSetCreate) IA__FcStrSetCreate __attribute((visibility(\""hidden\"")));\n #define FcStrSetCreate IA__FcStrSetCreate\n-extern __typeof (FcStrSetMember) IA__FcStrSetMember FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrSetMember) IA__FcStrSetMember __attribute((visibility(\""hidden\"")));\n #define FcStrSetMember IA__FcStrSetMember\n-extern __typeof (FcStrSetEqual) IA__FcStrSetEqual FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrSetEqual) IA__FcStrSetEqual __attribute((visibility(\""hidden\"")));\n #define FcStrSetEqual IA__FcStrSetEqual\n-extern __typeof (FcStrSetAdd) IA__FcStrSetAdd FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrSetAdd) IA__FcStrSetAdd __attribute((visibility(\""hidden\"")));\n #define FcStrSetAdd IA__FcStrSetAdd\n-extern __typeof (FcStrSetAddFilename) IA__FcStrSetAddFilename FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrSetAddFilename) IA__FcStrSetAddFilename __attribute((visibility(\""hidden\"")));\n #define FcStrSetAddFilename IA__FcStrSetAddFilename\n-extern __typeof (FcStrSetDel) IA__FcStrSetDel FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrSetDel) IA__FcStrSetDel __attribute((visibility(\""hidden\"")));\n #define FcStrSetDel IA__FcStrSetDel\n-extern __typeof (FcStrSetDestroy) IA__FcStrSetDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrSetDestroy) IA__FcStrSetDestroy __attribute((visibility(\""hidden\"")));\n #define FcStrSetDestroy IA__FcStrSetDestroy\n-extern __typeof (FcStrListCreate) IA__FcStrListCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrListCreate) IA__FcStrListCreate __attribute((visibility(\""hidden\"")));\n #define FcStrListCreate IA__FcStrListCreate\n-extern __typeof (FcStrListFirst) IA__FcStrListFirst FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrListFirst) IA__FcStrListFirst __attribute((visibility(\""hidden\"")));\n #define FcStrListFirst IA__FcStrListFirst\n-extern __typeof (FcStrListNext) IA__FcStrListNext FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrListNext) IA__FcStrListNext __attribute((visibility(\""hidden\"")));\n #define FcStrListNext IA__FcStrListNext\n-extern __typeof (FcStrListDone) IA__FcStrListDone FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrListDone) IA__FcStrListDone __attribute((visibility(\""hidden\"")));\n #define FcStrListDone IA__FcStrListDone\n-extern __typeof (FcConfigParseAndLoad) IA__FcConfigParseAndLoad FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigParseAndLoad) IA__FcConfigParseAndLoad __attribute((visibility(\""hidden\"")));\n #define FcConfigParseAndLoad IA__FcConfigParseAndLoad\n-extern __typeof (FcConfigParseAndLoadFromMemory) IA__FcConfigParseAndLoadFromMemory FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigParseAndLoadFromMemory) IA__FcConfigParseAndLoadFromMemory __attribute((visibility(\""hidden\"")));\n #define FcConfigParseAndLoadFromMemory IA__FcConfigParseAndLoadFromMemory\n-extern __typeof (FcConfigGetRescanInverval) IA__FcConfigGetRescanInverval FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetRescanInverval) IA__FcConfigGetRescanInverval __attribute((visibility(\""hidden\"")));\n #define FcConfigGetRescanInverval IA__FcConfigGetRescanInverval\n-extern __typeof (FcConfigSetRescanInverval) IA__FcConfigSetRescanInverval FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigSetRescanInverval) IA__FcConfigSetRescanInverval __attribute((visibility(\""hidden\"")));\n #define FcConfigSetRescanInverval IA__FcConfigSetRescanInverval""}<_**next**_>{""sha"": ""a46c8d0116475878b5638061b8bde001611a1e62"", ""filename"": ""third_party/fontconfig/include/src/fcaliastail.h"", ""status"": ""modified"", ""additions"": 209, ""deletions"": 245, ""changes"": 454, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcaliastail.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcaliastail.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/include/src/fcaliastail.h?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -1,504 +1,468 @@\n #if HAVE_GNUC_ATTRIBUTE\n-#ifdef __fccfg__\n+#ifdef __fcblanks__\n # undef FcBlanksCreate\n-extern __typeof (FcBlanksCreate) FcBlanksCreate __attribute((alias(\""IA__FcBlanksCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcBlanksCreate) FcBlanksCreate __attribute((alias(\""IA__FcBlanksCreate\""), visibility(\""default\"")));\n # undef FcBlanksDestroy\n-extern __typeof (FcBlanksDestroy) FcBlanksDestroy __attribute((alias(\""IA__FcBlanksDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcBlanksDestroy) FcBlanksDestroy __attribute((alias(\""IA__FcBlanksDestroy\""), visibility(\""default\"")));\n # undef FcBlanksAdd\n-extern __typeof (FcBlanksAdd) FcBlanksAdd __attribute((alias(\""IA__FcBlanksAdd\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcBlanksAdd) FcBlanksAdd __attribute((alias(\""IA__FcBlanksAdd\""), visibility(\""default\"")));\n # undef FcBlanksIsMember\n-extern __typeof (FcBlanksIsMember) FcBlanksIsMember __attribute((alias(\""IA__FcBlanksIsMember\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-#endif /* __fccfg__ */\n+extern __typeof (FcBlanksIsMember) FcBlanksIsMember __attribute((alias(\""IA__FcBlanksIsMember\""), visibility(\""default\"")));\n+#endif /* __fcblanks__ */\n #ifdef __fccache__\n # undef FcCacheCopySet\n-extern __typeof (FcCacheCopySet) FcCacheCopySet __attribute((alias(\""IA__FcCacheCopySet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCacheCopySet) FcCacheCopySet __attribute((alias(\""IA__FcCacheCopySet\""), visibility(\""default\"")));\n # undef FcCacheNumSubdir\n-extern __typeof (FcCacheNumSubdir) FcCacheNumSubdir __attribute((alias(\""IA__FcCacheNumSubdir\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCacheNumSubdir) FcCacheNumSubdir __attribute((alias(\""IA__FcCacheNumSubdir\""), visibility(\""default\"")));\n # undef FcCacheNumFont\n-extern __typeof (FcCacheNumFont) FcCacheNumFont __attribute((alias(\""IA__FcCacheNumFont\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCacheNumFont) FcCacheNumFont __attribute((alias(\""IA__FcCacheNumFont\""), visibility(\""default\"")));\n # undef FcDirCacheUnlink\n-extern __typeof (FcDirCacheUnlink) FcDirCacheUnlink __attribute((alias(\""IA__FcDirCacheUnlink\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirCacheUnlink) FcDirCacheUnlink __attribute((alias(\""IA__FcDirCacheUnlink\""), visibility(\""default\"")));\n # undef FcDirCacheValid\n-extern __typeof (FcDirCacheValid) FcDirCacheValid __attribute((alias(\""IA__FcDirCacheValid\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirCacheValid) FcDirCacheValid __attribute((alias(\""IA__FcDirCacheValid\""), visibility(\""default\"")));\n # undef FcDirCacheClean\n-extern __typeof (FcDirCacheClean) FcDirCacheClean __attribute((alias(\""IA__FcDirCacheClean\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirCacheClean) FcDirCacheClean __attribute((alias(\""IA__FcDirCacheClean\""), visibility(\""default\"")));\n # undef FcCacheCreateTagFile\n-extern __typeof (FcCacheCreateTagFile) FcCacheCreateTagFile __attribute((alias(\""IA__FcCacheCreateTagFile\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcDirCacheCreateUUID\n-extern __typeof (FcDirCacheCreateUUID) FcDirCacheCreateUUID __attribute((alias(\""IA__FcDirCacheCreateUUID\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcDirCacheDeleteUUID\n-extern __typeof (FcDirCacheDeleteUUID) FcDirCacheDeleteUUID __attribute((alias(\""IA__FcDirCacheDeleteUUID\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCacheCreateTagFile) FcCacheCreateTagFile __attribute((alias(\""IA__FcCacheCreateTagFile\""), visibility(\""default\"")));\n #endif /* __fccache__ */\n #ifdef __fccfg__\n # undef FcConfigHome\n-extern __typeof (FcConfigHome) FcConfigHome __attribute((alias(\""IA__FcConfigHome\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigHome) FcConfigHome __attribute((alias(\""IA__FcConfigHome\""), visibility(\""default\"")));\n # undef FcConfigEnableHome\n-extern __typeof (FcConfigEnableHome) FcConfigEnableHome __attribute((alias(\""IA__FcConfigEnableHome\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigEnableHome) FcConfigEnableHome __attribute((alias(\""IA__FcConfigEnableHome\""), visibility(\""default\"")));\n # undef FcConfigFilename\n-extern __typeof (FcConfigFilename) FcConfigFilename __attribute((alias(\""IA__FcConfigFilename\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigFilename) FcConfigFilename __attribute((alias(\""IA__FcConfigFilename\""), visibility(\""default\"")));\n # undef FcConfigCreate\n-extern __typeof (FcConfigCreate) FcConfigCreate __attribute((alias(\""IA__FcConfigCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigCreate) FcConfigCreate __attribute((alias(\""IA__FcConfigCreate\""), visibility(\""default\"")));\n # undef FcConfigReference\n-extern __typeof (FcConfigReference) FcConfigReference __attribute((alias(\""IA__FcConfigReference\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigReference) FcConfigReference __attribute((alias(\""IA__FcConfigReference\""), visibility(\""default\"")));\n # undef FcConfigDestroy\n-extern __typeof (FcConfigDestroy) FcConfigDestroy __attribute((alias(\""IA__FcConfigDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigDestroy) FcConfigDestroy __attribute((alias(\""IA__FcConfigDestroy\""), visibility(\""default\"")));\n # undef FcConfigSetCurrent\n-extern __typeof (FcConfigSetCurrent) FcConfigSetCurrent __attribute((alias(\""IA__FcConfigSetCurrent\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigSetCurrent) FcConfigSetCurrent __attribute((alias(\""IA__FcConfigSetCurrent\""), visibility(\""default\"")));\n # undef FcConfigGetCurrent\n-extern __typeof (FcConfigGetCurrent) FcConfigGetCurrent __attribute((alias(\""IA__FcConfigGetCurrent\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetCurrent) FcConfigGetCurrent __attribute((alias(\""IA__FcConfigGetCurrent\""), visibility(\""default\"")));\n # undef FcConfigUptoDate\n-extern __typeof (FcConfigUptoDate) FcConfigUptoDate __attribute((alias(\""IA__FcConfigUptoDate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigUptoDate) FcConfigUptoDate __attribute((alias(\""IA__FcConfigUptoDate\""), visibility(\""default\"")));\n # undef FcConfigBuildFonts\n-extern __typeof (FcConfigBuildFonts) FcConfigBuildFonts __attribute((alias(\""IA__FcConfigBuildFonts\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigBuildFonts) FcConfigBuildFonts __attribute((alias(\""IA__FcConfigBuildFonts\""), visibility(\""default\"")));\n # undef FcConfigGetFontDirs\n-extern __typeof (FcConfigGetFontDirs) FcConfigGetFontDirs __attribute((alias(\""IA__FcConfigGetFontDirs\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetFontDirs) FcConfigGetFontDirs __attribute((alias(\""IA__FcConfigGetFontDirs\""), visibility(\""default\"")));\n # undef FcConfigGetConfigDirs\n-extern __typeof (FcConfigGetConfigDirs) FcConfigGetConfigDirs __attribute((alias(\""IA__FcConfigGetConfigDirs\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetConfigDirs) FcConfigGetConfigDirs __attribute((alias(\""IA__FcConfigGetConfigDirs\""), visibility(\""default\"")));\n # undef FcConfigGetConfigFiles\n-extern __typeof (FcConfigGetConfigFiles) FcConfigGetConfigFiles __attribute((alias(\""IA__FcConfigGetConfigFiles\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetConfigFiles) FcConfigGetConfigFiles __attribute((alias(\""IA__FcConfigGetConfigFiles\""), visibility(\""default\"")));\n # undef FcConfigGetCache\n-extern __typeof (FcConfigGetCache) FcConfigGetCache __attribute((alias(\""IA__FcConfigGetCache\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetCache) FcConfigGetCache __attribute((alias(\""IA__FcConfigGetCache\""), visibility(\""default\"")));\n # undef FcConfigGetBlanks\n-extern __typeof (FcConfigGetBlanks) FcConfigGetBlanks __attribute((alias(\""IA__FcConfigGetBlanks\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetBlanks) FcConfigGetBlanks __attribute((alias(\""IA__FcConfigGetBlanks\""), visibility(\""default\"")));\n # undef FcConfigGetCacheDirs\n-extern __typeof (FcConfigGetCacheDirs) FcConfigGetCacheDirs __attribute((alias(\""IA__FcConfigGetCacheDirs\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetCacheDirs) FcConfigGetCacheDirs __attribute((alias(\""IA__FcConfigGetCacheDirs\""), visibility(\""default\"")));\n # undef FcConfigGetRescanInterval\n-extern __typeof (FcConfigGetRescanInterval) FcConfigGetRescanInterval __attribute((alias(\""IA__FcConfigGetRescanInterval\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetRescanInterval) FcConfigGetRescanInterval __attribute((alias(\""IA__FcConfigGetRescanInterval\""), visibility(\""default\"")));\n # undef FcConfigSetRescanInterval\n-extern __typeof (FcConfigSetRescanInterval) FcConfigSetRescanInterval __attribute((alias(\""IA__FcConfigSetRescanInterval\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigSetRescanInterval) FcConfigSetRescanInterval __attribute((alias(\""IA__FcConfigSetRescanInterval\""), visibility(\""default\"")));\n # undef FcConfigGetFonts\n-extern __typeof (FcConfigGetFonts) FcConfigGetFonts __attribute((alias(\""IA__FcConfigGetFonts\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetFonts) FcConfigGetFonts __attribute((alias(\""IA__FcConfigGetFonts\""), visibility(\""default\"")));\n # undef FcConfigAppFontAddFile\n-extern __typeof (FcConfigAppFontAddFile) FcConfigAppFontAddFile __attribute((alias(\""IA__FcConfigAppFontAddFile\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigAppFontAddFile) FcConfigAppFontAddFile __attribute((alias(\""IA__FcConfigAppFontAddFile\""), visibility(\""default\"")));\n # undef FcConfigAppFontAddDir\n-extern __typeof (FcConfigAppFontAddDir) FcConfigAppFontAddDir __attribute((alias(\""IA__FcConfigAppFontAddDir\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigAppFontAddDir) FcConfigAppFontAddDir __attribute((alias(\""IA__FcConfigAppFontAddDir\""), visibility(\""default\"")));\n # undef FcConfigAppFontClear\n-extern __typeof (FcConfigAppFontClear) FcConfigAppFontClear __attribute((alias(\""IA__FcConfigAppFontClear\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigAppFontClear) FcConfigAppFontClear __attribute((alias(\""IA__FcConfigAppFontClear\""), visibility(\""default\"")));\n # undef FcConfigSubstituteWithPat\n-extern __typeof (FcConfigSubstituteWithPat) FcConfigSubstituteWithPat __attribute((alias(\""IA__FcConfigSubstituteWithPat\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigSubstituteWithPat) FcConfigSubstituteWithPat __attribute((alias(\""IA__FcConfigSubstituteWithPat\""), visibility(\""default\"")));\n # undef FcConfigSubstitute\n-extern __typeof (FcConfigSubstitute) FcConfigSubstitute __attribute((alias(\""IA__FcConfigSubstitute\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigSubstitute) FcConfigSubstitute __attribute((alias(\""IA__FcConfigSubstitute\""), visibility(\""default\"")));\n # undef FcConfigGetSysRoot\n-extern __typeof (FcConfigGetSysRoot) FcConfigGetSysRoot __attribute((alias(\""IA__FcConfigGetSysRoot\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetSysRoot) FcConfigGetSysRoot __attribute((alias(\""IA__FcConfigGetSysRoot\""), visibility(\""default\"")));\n # undef FcConfigSetSysRoot\n-extern __typeof (FcConfigSetSysRoot) FcConfigSetSysRoot __attribute((alias(\""IA__FcConfigSetSysRoot\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcConfigFileInfoIterInit\n-extern __typeof (FcConfigFileInfoIterInit) FcConfigFileInfoIterInit __attribute((alias(\""IA__FcConfigFileInfoIterInit\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcConfigFileInfoIterNext\n-extern __typeof (FcConfigFileInfoIterNext) FcConfigFileInfoIterNext __attribute((alias(\""IA__FcConfigFileInfoIterNext\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcConfigFileInfoIterGet\n-extern __typeof (FcConfigFileInfoIterGet) FcConfigFileInfoIterGet __attribute((alias(\""IA__FcConfigFileInfoIterGet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigSetSysRoot) FcConfigSetSysRoot __attribute((alias(\""IA__FcConfigSetSysRoot\""), visibility(\""default\"")));\n #endif /* __fccfg__ */\n #ifdef __fccharset__\n # undef FcCharSetCreate\n-extern __typeof (FcCharSetCreate) FcCharSetCreate __attribute((alias(\""IA__FcCharSetCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetCreate) FcCharSetCreate __attribute((alias(\""IA__FcCharSetCreate\""), visibility(\""default\"")));\n # undef FcCharSetNew\n-extern __typeof (FcCharSetNew) FcCharSetNew __attribute((alias(\""IA__FcCharSetNew\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetNew) FcCharSetNew __attribute((alias(\""IA__FcCharSetNew\""), visibility(\""default\"")));\n # undef FcCharSetDestroy\n-extern __typeof (FcCharSetDestroy) FcCharSetDestroy __attribute((alias(\""IA__FcCharSetDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetDestroy) FcCharSetDestroy __attribute((alias(\""IA__FcCharSetDestroy\""), visibility(\""default\"")));\n # undef FcCharSetAddChar\n-extern __typeof (FcCharSetAddChar) FcCharSetAddChar __attribute((alias(\""IA__FcCharSetAddChar\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetAddChar) FcCharSetAddChar __attribute((alias(\""IA__FcCharSetAddChar\""), visibility(\""default\"")));\n # undef FcCharSetDelChar\n-extern __typeof (FcCharSetDelChar) FcCharSetDelChar __attribute((alias(\""IA__FcCharSetDelChar\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetDelChar) FcCharSetDelChar __attribute((alias(\""IA__FcCharSetDelChar\""), visibility(\""default\"")));\n # undef FcCharSetCopy\n-extern __typeof (FcCharSetCopy) FcCharSetCopy __attribute((alias(\""IA__FcCharSetCopy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetCopy) FcCharSetCopy __attribute((alias(\""IA__FcCharSetCopy\""), visibility(\""default\"")));\n # undef FcCharSetEqual\n-extern __typeof (FcCharSetEqual) FcCharSetEqual __attribute((alias(\""IA__FcCharSetEqual\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetEqual) FcCharSetEqual __attribute((alias(\""IA__FcCharSetEqual\""), visibility(\""default\"")));\n # undef FcCharSetIntersect\n-extern __typeof (FcCharSetIntersect) FcCharSetIntersect __attribute((alias(\""IA__FcCharSetIntersect\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetIntersect) FcCharSetIntersect __attribute((alias(\""IA__FcCharSetIntersect\""), visibility(\""default\"")));\n # undef FcCharSetUnion\n-extern __typeof (FcCharSetUnion) FcCharSetUnion __attribute((alias(\""IA__FcCharSetUnion\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetUnion) FcCharSetUnion __attribute((alias(\""IA__FcCharSetUnion\""), visibility(\""default\"")));\n # undef FcCharSetSubtract\n-extern __typeof (FcCharSetSubtract) FcCharSetSubtract __attribute((alias(\""IA__FcCharSetSubtract\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetSubtract) FcCharSetSubtract __attribute((alias(\""IA__FcCharSetSubtract\""), visibility(\""default\"")));\n # undef FcCharSetMerge\n-extern __typeof (FcCharSetMerge) FcCharSetMerge __attribute((alias(\""IA__FcCharSetMerge\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetMerge) FcCharSetMerge __attribute((alias(\""IA__FcCharSetMerge\""), visibility(\""default\"")));\n # undef FcCharSetHasChar\n-extern __typeof (FcCharSetHasChar) FcCharSetHasChar __attribute((alias(\""IA__FcCharSetHasChar\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetHasChar) FcCharSetHasChar __attribute((alias(\""IA__FcCharSetHasChar\""), visibility(\""default\"")));\n # undef FcCharSetCount\n-extern __typeof (FcCharSetCount) FcCharSetCount __attribute((alias(\""IA__FcCharSetCount\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetCount) FcCharSetCount __attribute((alias(\""IA__FcCharSetCount\""), visibility(\""default\"")));\n # undef FcCharSetIntersectCount\n-extern __typeof (FcCharSetIntersectCount) FcCharSetIntersectCount __attribute((alias(\""IA__FcCharSetIntersectCount\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetIntersectCount) FcCharSetIntersectCount __attribute((alias(\""IA__FcCharSetIntersectCount\""), visibility(\""default\"")));\n # undef FcCharSetSubtractCount\n-extern __typeof (FcCharSetSubtractCount) FcCharSetSubtractCount __attribute((alias(\""IA__FcCharSetSubtractCount\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetSubtractCount) FcCharSetSubtractCount __attribute((alias(\""IA__FcCharSetSubtractCount\""), visibility(\""default\"")));\n # undef FcCharSetIsSubset\n-extern __typeof (FcCharSetIsSubset) FcCharSetIsSubset __attribute((alias(\""IA__FcCharSetIsSubset\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetIsSubset) FcCharSetIsSubset __attribute((alias(\""IA__FcCharSetIsSubset\""), visibility(\""default\"")));\n # undef FcCharSetFirstPage\n-extern __typeof (FcCharSetFirstPage) FcCharSetFirstPage __attribute((alias(\""IA__FcCharSetFirstPage\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetFirstPage) FcCharSetFirstPage __attribute((alias(\""IA__FcCharSetFirstPage\""), visibility(\""default\"")));\n # undef FcCharSetNextPage\n-extern __typeof (FcCharSetNextPage) FcCharSetNextPage __attribute((alias(\""IA__FcCharSetNextPage\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetNextPage) FcCharSetNextPage __attribute((alias(\""IA__FcCharSetNextPage\""), visibility(\""default\"")));\n # undef FcCharSetCoverage\n-extern __typeof (FcCharSetCoverage) FcCharSetCoverage __attribute((alias(\""IA__FcCharSetCoverage\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetCoverage) FcCharSetCoverage __attribute((alias(\""IA__FcCharSetCoverage\""), visibility(\""default\"")));\n #endif /* __fccharset__ */\n #ifdef __fcdbg__\n # undef FcValuePrint\n-extern __typeof (FcValuePrint) FcValuePrint __attribute((alias(\""IA__FcValuePrint\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcValuePrint) FcValuePrint __attribute((alias(\""IA__FcValuePrint\""), visibility(\""default\"")));\n # undef FcPatternPrint\n-extern __typeof (FcPatternPrint) FcPatternPrint __attribute((alias(\""IA__FcPatternPrint\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternPrint) FcPatternPrint __attribute((alias(\""IA__FcPatternPrint\""), visibility(\""default\"")));\n # undef FcFontSetPrint\n-extern __typeof (FcFontSetPrint) FcFontSetPrint __attribute((alias(\""IA__FcFontSetPrint\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSetPrint) FcFontSetPrint __attribute((alias(\""IA__FcFontSetPrint\""), visibility(\""default\"")));\n #endif /* __fcdbg__ */\n #ifdef __fcdefault__\n # undef FcGetDefaultLangs\n-extern __typeof (FcGetDefaultLangs) FcGetDefaultLangs __attribute((alias(\""IA__FcGetDefaultLangs\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcGetDefaultLangs) FcGetDefaultLangs __attribute((alias(\""IA__FcGetDefaultLangs\""), visibility(\""default\"")));\n # undef FcDefaultSubstitute\n-extern __typeof (FcDefaultSubstitute) FcDefaultSubstitute __attribute((alias(\""IA__FcDefaultSubstitute\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDefaultSubstitute) FcDefaultSubstitute __attribute((alias(\""IA__FcDefaultSubstitute\""), visibility(\""default\"")));\n #endif /* __fcdefault__ */\n #ifdef __fcdir__\n # undef FcFileIsDir\n-extern __typeof (FcFileIsDir) FcFileIsDir __attribute((alias(\""IA__FcFileIsDir\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFileIsDir) FcFileIsDir __attribute((alias(\""IA__FcFileIsDir\""), visibility(\""default\"")));\n # undef FcFileScan\n-extern __typeof (FcFileScan) FcFileScan __attribute((alias(\""IA__FcFileScan\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFileScan) FcFileScan __attribute((alias(\""IA__FcFileScan\""), visibility(\""default\"")));\n # undef FcDirScan\n-extern __typeof (FcDirScan) FcDirScan __attribute((alias(\""IA__FcDirScan\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirScan) FcDirScan __attribute((alias(\""IA__FcDirScan\""), visibility(\""default\"")));\n # undef FcDirSave\n-extern __typeof (FcDirSave) FcDirSave __attribute((alias(\""IA__FcDirSave\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirSave) FcDirSave __attribute((alias(\""IA__FcDirSave\""), visibility(\""default\"")));\n #endif /* __fcdir__ */\n #ifdef __fccache__\n # undef FcDirCacheLoad\n-extern __typeof (FcDirCacheLoad) FcDirCacheLoad __attribute((alias(\""IA__FcDirCacheLoad\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirCacheLoad) FcDirCacheLoad __attribute((alias(\""IA__FcDirCacheLoad\""), visibility(\""default\"")));\n #endif /* __fccache__ */\n #ifdef __fcdir__\n # undef FcDirCacheRescan\n-extern __typeof (FcDirCacheRescan) FcDirCacheRescan __attribute((alias(\""IA__FcDirCacheRescan\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirCacheRescan) FcDirCacheRescan __attribute((alias(\""IA__FcDirCacheRescan\""), visibility(\""default\"")));\n # undef FcDirCacheRead\n-extern __typeof (FcDirCacheRead) FcDirCacheRead __attribute((alias(\""IA__FcDirCacheRead\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirCacheRead) FcDirCacheRead __attribute((alias(\""IA__FcDirCacheRead\""), visibility(\""default\"")));\n #endif /* __fcdir__ */\n #ifdef __fccache__\n # undef FcDirCacheLoadFile\n-extern __typeof (FcDirCacheLoadFile) FcDirCacheLoadFile __attribute((alias(\""IA__FcDirCacheLoadFile\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirCacheLoadFile) FcDirCacheLoadFile __attribute((alias(\""IA__FcDirCacheLoadFile\""), visibility(\""default\"")));\n # undef FcDirCacheUnload\n-extern __typeof (FcDirCacheUnload) FcDirCacheUnload __attribute((alias(\""IA__FcDirCacheUnload\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirCacheUnload) FcDirCacheUnload __attribute((alias(\""IA__FcDirCacheUnload\""), visibility(\""default\"")));\n #endif /* __fccache__ */\n #ifdef __fcfreetype__\n # undef FcFreeTypeQuery\n-extern __typeof (FcFreeTypeQuery) FcFreeTypeQuery __attribute((alias(\""IA__FcFreeTypeQuery\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcFreeTypeQueryAll\n-extern __typeof (FcFreeTypeQueryAll) FcFreeTypeQueryAll __attribute((alias(\""IA__FcFreeTypeQueryAll\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFreeTypeQuery) FcFreeTypeQuery __attribute((alias(\""IA__FcFreeTypeQuery\""), visibility(\""default\"")));\n #endif /* __fcfreetype__ */\n #ifdef __fcfs__\n # undef FcFontSetCreate\n-extern __typeof (FcFontSetCreate) FcFontSetCreate __attribute((alias(\""IA__FcFontSetCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSetCreate) FcFontSetCreate __attribute((alias(\""IA__FcFontSetCreate\""), visibility(\""default\"")));\n # undef FcFontSetDestroy\n-extern __typeof (FcFontSetDestroy) FcFontSetDestroy __attribute((alias(\""IA__FcFontSetDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSetDestroy) FcFontSetDestroy __attribute((alias(\""IA__FcFontSetDestroy\""), visibility(\""default\"")));\n # undef FcFontSetAdd\n-extern __typeof (FcFontSetAdd) FcFontSetAdd __attribute((alias(\""IA__FcFontSetAdd\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSetAdd) FcFontSetAdd __attribute((alias(\""IA__FcFontSetAdd\""), visibility(\""default\"")));\n #endif /* __fcfs__ */\n #ifdef __fcinit__\n # undef FcInitLoadConfig\n-extern __typeof (FcInitLoadConfig) FcInitLoadConfig __attribute((alias(\""IA__FcInitLoadConfig\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcInitLoadConfig) FcInitLoadConfig __attribute((alias(\""IA__FcInitLoadConfig\""), visibility(\""default\"")));\n # undef FcInitLoadConfigAndFonts\n-extern __typeof (FcInitLoadConfigAndFonts) FcInitLoadConfigAndFonts __attribute((alias(\""IA__FcInitLoadConfigAndFonts\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcInitLoadConfigAndFonts) FcInitLoadConfigAndFonts __attribute((alias(\""IA__FcInitLoadConfigAndFonts\""), visibility(\""default\"")));\n # undef FcInit\n-extern __typeof (FcInit) FcInit __attribute((alias(\""IA__FcInit\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcInit) FcInit __attribute((alias(\""IA__FcInit\""), visibility(\""default\"")));\n # undef FcFini\n-extern __typeof (FcFini) FcFini __attribute((alias(\""IA__FcFini\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFini) FcFini __attribute((alias(\""IA__FcFini\""), visibility(\""default\"")));\n # undef FcGetVersion\n-extern __typeof (FcGetVersion) FcGetVersion __attribute((alias(\""IA__FcGetVersion\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcGetVersion) FcGetVersion __attribute((alias(\""IA__FcGetVersion\""), visibility(\""default\"")));\n # undef FcInitReinitialize\n-extern __typeof (FcInitReinitialize) FcInitReinitialize __attribute((alias(\""IA__FcInitReinitialize\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcInitReinitialize) FcInitReinitialize __attribute((alias(\""IA__FcInitReinitialize\""), visibility(\""default\"")));\n # undef FcInitBringUptoDate\n-extern __typeof (FcInitBringUptoDate) FcInitBringUptoDate __attribute((alias(\""IA__FcInitBringUptoDate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcInitBringUptoDate) FcInitBringUptoDate __attribute((alias(\""IA__FcInitBringUptoDate\""), visibility(\""default\"")));\n #endif /* __fcinit__ */\n #ifdef __fclang__\n # undef FcGetLangs\n-extern __typeof (FcGetLangs) FcGetLangs __attribute((alias(\""IA__FcGetLangs\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcGetLangs) FcGetLangs __attribute((alias(\""IA__FcGetLangs\""), visibility(\""default\"")));\n # undef FcLangNormalize\n-extern __typeof (FcLangNormalize) FcLangNormalize __attribute((alias(\""IA__FcLangNormalize\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangNormalize) FcLangNormalize __attribute((alias(\""IA__FcLangNormalize\""), visibility(\""default\"")));\n # undef FcLangGetCharSet\n-extern __typeof (FcLangGetCharSet) FcLangGetCharSet __attribute((alias(\""IA__FcLangGetCharSet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangGetCharSet) FcLangGetCharSet __attribute((alias(\""IA__FcLangGetCharSet\""), visibility(\""default\"")));\n # undef FcLangSetCreate\n-extern __typeof (FcLangSetCreate) FcLangSetCreate __attribute((alias(\""IA__FcLangSetCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetCreate) FcLangSetCreate __attribute((alias(\""IA__FcLangSetCreate\""), visibility(\""default\"")));\n # undef FcLangSetDestroy\n-extern __typeof (FcLangSetDestroy) FcLangSetDestroy __attribute((alias(\""IA__FcLangSetDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetDestroy) FcLangSetDestroy __attribute((alias(\""IA__FcLangSetDestroy\""), visibility(\""default\"")));\n # undef FcLangSetCopy\n-extern __typeof (FcLangSetCopy) FcLangSetCopy __attribute((alias(\""IA__FcLangSetCopy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetCopy) FcLangSetCopy __attribute((alias(\""IA__FcLangSetCopy\""), visibility(\""default\"")));\n # undef FcLangSetAdd\n-extern __typeof (FcLangSetAdd) FcLangSetAdd __attribute((alias(\""IA__FcLangSetAdd\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetAdd) FcLangSetAdd __attribute((alias(\""IA__FcLangSetAdd\""), visibility(\""default\"")));\n # undef FcLangSetDel\n-extern __typeof (FcLangSetDel) FcLangSetDel __attribute((alias(\""IA__FcLangSetDel\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetDel) FcLangSetDel __attribute((alias(\""IA__FcLangSetDel\""), visibility(\""default\"")));\n # undef FcLangSetHasLang\n-extern __typeof (FcLangSetHasLang) FcLangSetHasLang __attribute((alias(\""IA__FcLangSetHasLang\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetHasLang) FcLangSetHasLang __attribute((alias(\""IA__FcLangSetHasLang\""), visibility(\""default\"")));\n # undef FcLangSetCompare\n-extern __typeof (FcLangSetCompare) FcLangSetCompare __attribute((alias(\""IA__FcLangSetCompare\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetCompare) FcLangSetCompare __attribute((alias(\""IA__FcLangSetCompare\""), visibility(\""default\"")));\n # undef FcLangSetContains\n-extern __typeof (FcLangSetContains) FcLangSetContains __attribute((alias(\""IA__FcLangSetContains\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetContains) FcLangSetContains __attribute((alias(\""IA__FcLangSetContains\""), visibility(\""default\"")));\n # undef FcLangSetEqual\n-extern __typeof (FcLangSetEqual) FcLangSetEqual __attribute((alias(\""IA__FcLangSetEqual\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetEqual) FcLangSetEqual __attribute((alias(\""IA__FcLangSetEqual\""), visibility(\""default\"")));\n # undef FcLangSetHash\n-extern __typeof (FcLangSetHash) FcLangSetHash __attribute((alias(\""IA__FcLangSetHash\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetHash) FcLangSetHash __attribute((alias(\""IA__FcLangSetHash\""), visibility(\""default\"")));\n # undef FcLangSetGetLangs\n-extern __typeof (FcLangSetGetLangs) FcLangSetGetLangs __attribute((alias(\""IA__FcLangSetGetLangs\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetGetLangs) FcLangSetGetLangs __attribute((alias(\""IA__FcLangSetGetLangs\""), visibility(\""default\"")));\n # undef FcLangSetUnion\n-extern __typeof (FcLangSetUnion) FcLangSetUnion __attribute((alias(\""IA__FcLangSetUnion\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetUnion) FcLangSetUnion __attribute((alias(\""IA__FcLangSetUnion\""), visibility(\""default\"")));\n # undef FcLangSetSubtract\n-extern __typeof (FcLangSetSubtract) FcLangSetSubtract __attribute((alias(\""IA__FcLangSetSubtract\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetSubtract) FcLangSetSubtract __attribute((alias(\""IA__FcLangSetSubtract\""), visibility(\""default\"")));\n #endif /* __fclang__ */\n #ifdef __fclist__\n # undef FcObjectSetCreate\n-extern __typeof (FcObjectSetCreate) FcObjectSetCreate __attribute((alias(\""IA__FcObjectSetCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcObjectSetCreate) FcObjectSetCreate __attribute((alias(\""IA__FcObjectSetCreate\""), visibility(\""default\"")));\n # undef FcObjectSetAdd\n-extern __typeof (FcObjectSetAdd) FcObjectSetAdd __attribute((alias(\""IA__FcObjectSetAdd\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcObjectSetAdd) FcObjectSetAdd __attribute((alias(\""IA__FcObjectSetAdd\""), visibility(\""default\"")));\n # undef FcObjectSetDestroy\n-extern __typeof (FcObjectSetDestroy) FcObjectSetDestroy __attribute((alias(\""IA__FcObjectSetDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcObjectSetDestroy) FcObjectSetDestroy __attribute((alias(\""IA__FcObjectSetDestroy\""), visibility(\""default\"")));\n # undef FcObjectSetVaBuild\n-extern __typeof (FcObjectSetVaBuild) FcObjectSetVaBuild __attribute((alias(\""IA__FcObjectSetVaBuild\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcObjectSetVaBuild) FcObjectSetVaBuild __attribute((alias(\""IA__FcObjectSetVaBuild\""), visibility(\""default\"")));\n # undef FcObjectSetBuild\n-extern __typeof (FcObjectSetBuild) FcObjectSetBuild __attribute((alias(\""IA__FcObjectSetBuild\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcObjectSetBuild) FcObjectSetBuild __attribute((alias(\""IA__FcObjectSetBuild\""), visibility(\""default\"")));\n # undef FcFontSetList\n-extern __typeof (FcFontSetList) FcFontSetList __attribute((alias(\""IA__FcFontSetList\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSetList) FcFontSetList __attribute((alias(\""IA__FcFontSetList\""), visibility(\""default\"")));\n # undef FcFontList\n-extern __typeof (FcFontList) FcFontList __attribute((alias(\""IA__FcFontList\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontList) FcFontList __attribute((alias(\""IA__FcFontList\""), visibility(\""default\"")));\n #endif /* __fclist__ */\n #ifdef __fcatomic__\n # undef FcAtomicCreate\n-extern __typeof (FcAtomicCreate) FcAtomicCreate __attribute((alias(\""IA__FcAtomicCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcAtomicCreate) FcAtomicCreate __attribute((alias(\""IA__FcAtomicCreate\""), visibility(\""default\"")));\n # undef FcAtomicLock\n-extern __typeof (FcAtomicLock) FcAtomicLock __attribute((alias(\""IA__FcAtomicLock\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcAtomicLock) FcAtomicLock __attribute((alias(\""IA__FcAtomicLock\""), visibility(\""default\"")));\n # undef FcAtomicNewFile\n-extern __typeof (FcAtomicNewFile) FcAtomicNewFile __attribute((alias(\""IA__FcAtomicNewFile\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcAtomicNewFile) FcAtomicNewFile __attribute((alias(\""IA__FcAtomicNewFile\""), visibility(\""default\"")));\n # undef FcAtomicOrigFile\n-extern __typeof (FcAtomicOrigFile) FcAtomicOrigFile __attribute((alias(\""IA__FcAtomicOrigFile\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcAtomicOrigFile) FcAtomicOrigFile __attribute((alias(\""IA__FcAtomicOrigFile\""), visibility(\""default\"")));\n # undef FcAtomicReplaceOrig\n-extern __typeof (FcAtomicReplaceOrig) FcAtomicReplaceOrig __attribute((alias(\""IA__FcAtomicReplaceOrig\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcAtomicReplaceOrig) FcAtomicReplaceOrig __attribute((alias(\""IA__FcAtomicReplaceOrig\""), visibility(\""default\"")));\n # undef FcAtomicDeleteNew\n-extern __typeof (FcAtomicDeleteNew) FcAtomicDeleteNew __attribute((alias(\""IA__FcAtomicDeleteNew\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcAtomicDeleteNew) FcAtomicDeleteNew __attribute((alias(\""IA__FcAtomicDeleteNew\""), visibility(\""default\"")));\n # undef FcAtomicUnlock\n-extern __typeof (FcAtomicUnlock) FcAtomicUnlock __attribute((alias(\""IA__FcAtomicUnlock\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcAtomicUnlock) FcAtomicUnlock __attribute((alias(\""IA__FcAtomicUnlock\""), visibility(\""default\"")));\n # undef FcAtomicDestroy\n-extern __typeof (FcAtomicDestroy) FcAtomicDestroy __attribute((alias(\""IA__FcAtomicDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcAtomicDestroy) FcAtomicDestroy __attribute((alias(\""IA__FcAtomicDestroy\""), visibility(\""default\"")));\n #endif /* __fcatomic__ */\n #ifdef __fcmatch__\n # undef FcFontSetMatch\n-extern __typeof (FcFontSetMatch) FcFontSetMatch __attribute((alias(\""IA__FcFontSetMatch\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSetMatch) FcFontSetMatch __attribute((alias(\""IA__FcFontSetMatch\""), visibility(\""default\"")));\n # undef FcFontMatch\n-extern __typeof (FcFontMatch) FcFontMatch __attribute((alias(\""IA__FcFontMatch\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontMatch) FcFontMatch __attribute((alias(\""IA__FcFontMatch\""), visibility(\""default\"")));\n # undef FcFontRenderPrepare\n-extern __typeof (FcFontRenderPrepare) FcFontRenderPrepare __attribute((alias(\""IA__FcFontRenderPrepare\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontRenderPrepare) FcFontRenderPrepare __attribute((alias(\""IA__FcFontRenderPrepare\""), visibility(\""default\"")));\n # undef FcFontSetSort\n-extern __typeof (FcFontSetSort) FcFontSetSort __attribute((alias(\""IA__FcFontSetSort\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSetSort) FcFontSetSort __attribute((alias(\""IA__FcFontSetSort\""), visibility(\""default\"")));\n # undef FcFontSort\n-extern __typeof (FcFontSort) FcFontSort __attribute((alias(\""IA__FcFontSort\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSort) FcFontSort __attribute((alias(\""IA__FcFontSort\""), visibility(\""default\"")));\n # undef FcFontSetSortDestroy\n-extern __typeof (FcFontSetSortDestroy) FcFontSetSortDestroy __attribute((alias(\""IA__FcFontSetSortDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSetSortDestroy) FcFontSetSortDestroy __attribute((alias(\""IA__FcFontSetSortDestroy\""), visibility(\""default\"")));\n #endif /* __fcmatch__ */\n #ifdef __fcmatrix__\n # undef FcMatrixCopy\n-extern __typeof (FcMatrixCopy) FcMatrixCopy __attribute((alias(\""IA__FcMatrixCopy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcMatrixCopy) FcMatrixCopy __attribute((alias(\""IA__FcMatrixCopy\""), visibility(\""default\"")));\n # undef FcMatrixEqual\n-extern __typeof (FcMatrixEqual) FcMatrixEqual __attribute((alias(\""IA__FcMatrixEqual\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcMatrixEqual) FcMatrixEqual __attribute((alias(\""IA__FcMatrixEqual\""), visibility(\""default\"")));\n # undef FcMatrixMultiply\n-extern __typeof (FcMatrixMultiply) FcMatrixMultiply __attribute((alias(\""IA__FcMatrixMultiply\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcMatrixMultiply) FcMatrixMultiply __attribute((alias(\""IA__FcMatrixMultiply\""), visibility(\""default\"")));\n # undef FcMatrixRotate\n-extern __typeof (FcMatrixRotate) FcMatrixRotate __attribute((alias(\""IA__FcMatrixRotate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcMatrixRotate) FcMatrixRotate __attribute((alias(\""IA__FcMatrixRotate\""), visibility(\""default\"")));\n # undef FcMatrixScale\n-extern __typeof (FcMatrixScale) FcMatrixScale __attribute((alias(\""IA__FcMatrixScale\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcMatrixScale) FcMatrixScale __attribute((alias(\""IA__FcMatrixScale\""), visibility(\""default\"")));\n # undef FcMatrixShear\n-extern __typeof (FcMatrixShear) FcMatrixShear __attribute((alias(\""IA__FcMatrixShear\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcMatrixShear) FcMatrixShear __attribute((alias(\""IA__FcMatrixShear\""), visibility(\""default\"")));\n #endif /* __fcmatrix__ */\n #ifdef __fcname__\n # undef FcNameRegisterObjectTypes\n-extern __typeof (FcNameRegisterObjectTypes) FcNameRegisterObjectTypes __attribute((alias(\""IA__FcNameRegisterObjectTypes\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameRegisterObjectTypes) FcNameRegisterObjectTypes __attribute((alias(\""IA__FcNameRegisterObjectTypes\""), visibility(\""default\"")));\n # undef FcNameUnregisterObjectTypes\n-extern __typeof (FcNameUnregisterObjectTypes) FcNameUnregisterObjectTypes __attribute((alias(\""IA__FcNameUnregisterObjectTypes\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameUnregisterObjectTypes) FcNameUnregisterObjectTypes __attribute((alias(\""IA__FcNameUnregisterObjectTypes\""), visibility(\""default\"")));\n # undef FcNameGetObjectType\n-extern __typeof (FcNameGetObjectType) FcNameGetObjectType __attribute((alias(\""IA__FcNameGetObjectType\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameGetObjectType) FcNameGetObjectType __attribute((alias(\""IA__FcNameGetObjectType\""), visibility(\""default\"")));\n # undef FcNameRegisterConstants\n-extern __typeof (FcNameRegisterConstants) FcNameRegisterConstants __attribute((alias(\""IA__FcNameRegisterConstants\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameRegisterConstants) FcNameRegisterConstants __attribute((alias(\""IA__FcNameRegisterConstants\""), visibility(\""default\"")));\n # undef FcNameUnregisterConstants\n-extern __typeof (FcNameUnregisterConstants) FcNameUnregisterConstants __attribute((alias(\""IA__FcNameUnregisterConstants\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameUnregisterConstants) FcNameUnregisterConstants __attribute((alias(\""IA__FcNameUnregisterConstants\""), visibility(\""default\"")));\n # undef FcNameGetConstant\n-extern __typeof (FcNameGetConstant) FcNameGetConstant __attribute((alias(\""IA__FcNameGetConstant\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameGetConstant) FcNameGetConstant __attribute((alias(\""IA__FcNameGetConstant\""), visibility(\""default\"")));\n # undef FcNameConstant\n-extern __typeof (FcNameConstant) FcNameConstant __attribute((alias(\""IA__FcNameConstant\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameConstant) FcNameConstant __attribute((alias(\""IA__FcNameConstant\""), visibility(\""default\"")));\n # undef FcNameParse\n-extern __typeof (FcNameParse) FcNameParse __attribute((alias(\""IA__FcNameParse\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameParse) FcNameParse __attribute((alias(\""IA__FcNameParse\""), visibility(\""default\"")));\n # undef FcNameUnparse\n-extern __typeof (FcNameUnparse) FcNameUnparse __attribute((alias(\""IA__FcNameUnparse\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameUnparse) FcNameUnparse __attribute((alias(\""IA__FcNameUnparse\""), visibility(\""default\"")));\n #endif /* __fcname__ */\n #ifdef __fcpat__\n # undef FcPatternCreate\n-extern __typeof (FcPatternCreate) FcPatternCreate __attribute((alias(\""IA__FcPatternCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternCreate) FcPatternCreate __attribute((alias(\""IA__FcPatternCreate\""), visibility(\""default\"")));\n # undef FcPatternDuplicate\n-extern __typeof (FcPatternDuplicate) FcPatternDuplicate __attribute((alias(\""IA__FcPatternDuplicate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternDuplicate) FcPatternDuplicate __attribute((alias(\""IA__FcPatternDuplicate\""), visibility(\""default\"")));\n # undef FcPatternReference\n-extern __typeof (FcPatternReference) FcPatternReference __attribute((alias(\""IA__FcPatternReference\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternReference) FcPatternReference __attribute((alias(\""IA__FcPatternReference\""), visibility(\""default\"")));\n # undef FcPatternFilter\n-extern __typeof (FcPatternFilter) FcPatternFilter __attribute((alias(\""IA__FcPatternFilter\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternFilter) FcPatternFilter __attribute((alias(\""IA__FcPatternFilter\""), visibility(\""default\"")));\n # undef FcValueDestroy\n-extern __typeof (FcValueDestroy) FcValueDestroy __attribute((alias(\""IA__FcValueDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcValueDestroy) FcValueDestroy __attribute((alias(\""IA__FcValueDestroy\""), visibility(\""default\"")));\n # undef FcValueEqual\n-extern __typeof (FcValueEqual) FcValueEqual __attribute((alias(\""IA__FcValueEqual\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcValueEqual) FcValueEqual __attribute((alias(\""IA__FcValueEqual\""), visibility(\""default\"")));\n # undef FcValueSave\n-extern __typeof (FcValueSave) FcValueSave __attribute((alias(\""IA__FcValueSave\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcValueSave) FcValueSave __attribute((alias(\""IA__FcValueSave\""), visibility(\""default\"")));\n # undef FcPatternDestroy\n-extern __typeof (FcPatternDestroy) FcPatternDestroy __attribute((alias(\""IA__FcPatternDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcPatternObjectCount\n-extern __typeof (FcPatternObjectCount) FcPatternObjectCount __attribute((alias(\""IA__FcPatternObjectCount\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternDestroy) FcPatternDestroy __attribute((alias(\""IA__FcPatternDestroy\""), visibility(\""default\"")));\n # undef FcPatternEqual\n-extern __typeof (FcPatternEqual) FcPatternEqual __attribute((alias(\""IA__FcPatternEqual\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternEqual) FcPatternEqual __attribute((alias(\""IA__FcPatternEqual\""), visibility(\""default\"")));\n # undef FcPatternEqualSubset\n-extern __typeof (FcPatternEqualSubset) FcPatternEqualSubset __attribute((alias(\""IA__FcPatternEqualSubset\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternEqualSubset) FcPatternEqualSubset __attribute((alias(\""IA__FcPatternEqualSubset\""), visibility(\""default\"")));\n # undef FcPatternHash\n-extern __typeof (FcPatternHash) FcPatternHash __attribute((alias(\""IA__FcPatternHash\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternHash) FcPatternHash __attribute((alias(\""IA__FcPatternHash\""), visibility(\""default\"")));\n # undef FcPatternAdd\n-extern __typeof (FcPatternAdd) FcPatternAdd __attribute((alias(\""IA__FcPatternAdd\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAdd) FcPatternAdd __attribute((alias(\""IA__FcPatternAdd\""), visibility(\""default\"")));\n # undef FcPatternAddWeak\n-extern __typeof (FcPatternAddWeak) FcPatternAddWeak __attribute((alias(\""IA__FcPatternAddWeak\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddWeak) FcPatternAddWeak __attribute((alias(\""IA__FcPatternAddWeak\""), visibility(\""default\"")));\n # undef FcPatternGet\n-extern __typeof (FcPatternGet) FcPatternGet __attribute((alias(\""IA__FcPatternGet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGet) FcPatternGet __attribute((alias(\""IA__FcPatternGet\""), visibility(\""default\"")));\n # undef FcPatternGetWithBinding\n-extern __typeof (FcPatternGetWithBinding) FcPatternGetWithBinding __attribute((alias(\""IA__FcPatternGetWithBinding\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetWithBinding) FcPatternGetWithBinding __attribute((alias(\""IA__FcPatternGetWithBinding\""), visibility(\""default\"")));\n # undef FcPatternDel\n-extern __typeof (FcPatternDel) FcPatternDel __attribute((alias(\""IA__FcPatternDel\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternDel) FcPatternDel __attribute((alias(\""IA__FcPatternDel\""), visibility(\""default\"")));\n # undef FcPatternRemove\n-extern __typeof (FcPatternRemove) FcPatternRemove __attribute((alias(\""IA__FcPatternRemove\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternRemove) FcPatternRemove __attribute((alias(\""IA__FcPatternRemove\""), visibility(\""default\"")));\n # undef FcPatternAddInteger\n-extern __typeof (FcPatternAddInteger) FcPatternAddInteger __attribute((alias(\""IA__FcPatternAddInteger\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddInteger) FcPatternAddInteger __attribute((alias(\""IA__FcPatternAddInteger\""), visibility(\""default\"")));\n # undef FcPatternAddDouble\n-extern __typeof (FcPatternAddDouble) FcPatternAddDouble __attribute((alias(\""IA__FcPatternAddDouble\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddDouble) FcPatternAddDouble __attribute((alias(\""IA__FcPatternAddDouble\""), visibility(\""default\"")));\n # undef FcPatternAddString\n-extern __typeof (FcPatternAddString) FcPatternAddString __attribute((alias(\""IA__FcPatternAddString\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddString) FcPatternAddString __attribute((alias(\""IA__FcPatternAddString\""), visibility(\""default\"")));\n # undef FcPatternAddMatrix\n-extern __typeof (FcPatternAddMatrix) FcPatternAddMatrix __attribute((alias(\""IA__FcPatternAddMatrix\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddMatrix) FcPatternAddMatrix __attribute((alias(\""IA__FcPatternAddMatrix\""), visibility(\""default\"")));\n # undef FcPatternAddCharSet\n-extern __typeof (FcPatternAddCharSet) FcPatternAddCharSet __attribute((alias(\""IA__FcPatternAddCharSet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddCharSet) FcPatternAddCharSet __attribute((alias(\""IA__FcPatternAddCharSet\""), visibility(\""default\"")));\n # undef FcPatternAddBool\n-extern __typeof (FcPatternAddBool) FcPatternAddBool __attribute((alias(\""IA__FcPatternAddBool\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddBool) FcPatternAddBool __attribute((alias(\""IA__FcPatternAddBool\""), visibility(\""default\"")));\n # undef FcPatternAddLangSet\n-extern __typeof (FcPatternAddLangSet) FcPatternAddLangSet __attribute((alias(\""IA__FcPatternAddLangSet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddLangSet) FcPatternAddLangSet __attribute((alias(\""IA__FcPatternAddLangSet\""), visibility(\""default\"")));\n # undef FcPatternAddRange\n-extern __typeof (FcPatternAddRange) FcPatternAddRange __attribute((alias(\""IA__FcPatternAddRange\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddRange) FcPatternAddRange __attribute((alias(\""IA__FcPatternAddRange\""), visibility(\""default\"")));\n # undef FcPatternGetInteger\n-extern __typeof (FcPatternGetInteger) FcPatternGetInteger __attribute((alias(\""IA__FcPatternGetInteger\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetInteger) FcPatternGetInteger __attribute((alias(\""IA__FcPatternGetInteger\""), visibility(\""default\"")));\n # undef FcPatternGetDouble\n-extern __typeof (FcPatternGetDouble) FcPatternGetDouble __attribute((alias(\""IA__FcPatternGetDouble\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetDouble) FcPatternGetDouble __attribute((alias(\""IA__FcPatternGetDouble\""), visibility(\""default\"")));\n # undef FcPatternGetString\n-extern __typeof (FcPatternGetString) FcPatternGetString __attribute((alias(\""IA__FcPatternGetString\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetString) FcPatternGetString __attribute((alias(\""IA__FcPatternGetString\""), visibility(\""default\"")));\n # undef FcPatternGetMatrix\n-extern __typeof (FcPatternGetMatrix) FcPatternGetMatrix __attribute((alias(\""IA__FcPatternGetMatrix\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetMatrix) FcPatternGetMatrix __attribute((alias(\""IA__FcPatternGetMatrix\""), visibility(\""default\"")));\n # undef FcPatternGetCharSet\n-extern __typeof (FcPatternGetCharSet) FcPatternGetCharSet __attribute((alias(\""IA__FcPatternGetCharSet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetCharSet) FcPatternGetCharSet __attribute((alias(\""IA__FcPatternGetCharSet\""), visibility(\""default\"")));\n # undef FcPatternGetBool\n-extern __typeof (FcPatternGetBool) FcPatternGetBool __attribute((alias(\""IA__FcPatternGetBool\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetBool) FcPatternGetBool __attribute((alias(\""IA__FcPatternGetBool\""), visibility(\""default\"")));\n # undef FcPatternGetLangSet\n-extern __typeof (FcPatternGetLangSet) FcPatternGetLangSet __attribute((alias(\""IA__FcPatternGetLangSet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetLangSet) FcPatternGetLangSet __attribute((alias(\""IA__FcPatternGetLangSet\""), visibility(\""default\"")));\n # undef FcPatternGetRange\n-extern __typeof (FcPatternGetRange) FcPatternGetRange __attribute((alias(\""IA__FcPatternGetRange\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetRange) FcPatternGetRange __attribute((alias(\""IA__FcPatternGetRange\""), visibility(\""default\"")));\n # undef FcPatternVaBuild\n-extern __typeof (FcPatternVaBuild) FcPatternVaBuild __attribute((alias(\""IA__FcPatternVaBuild\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternVaBuild) FcPatternVaBuild __attribute((alias(\""IA__FcPatternVaBuild\""), visibility(\""default\"")));\n # undef FcPatternBuild\n-extern __typeof (FcPatternBuild) FcPatternBuild __attribute((alias(\""IA__FcPatternBuild\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternBuild) FcPatternBuild __attribute((alias(\""IA__FcPatternBuild\""), visibility(\""default\"")));\n #endif /* __fcpat__ */\n #ifdef __fcformat__\n # undef FcPatternFormat\n-extern __typeof (FcPatternFormat) FcPatternFormat __attribute((alias(\""IA__FcPatternFormat\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternFormat) FcPatternFormat __attribute((alias(\""IA__FcPatternFormat\""), visibility(\""default\"")));\n #endif /* __fcformat__ */\n #ifdef __fcrange__\n # undef FcRangeCreateDouble\n-extern __typeof (FcRangeCreateDouble) FcRangeCreateDouble __attribute((alias(\""IA__FcRangeCreateDouble\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcRangeCreateDouble) FcRangeCreateDouble __attribute((alias(\""IA__FcRangeCreateDouble\""), visibility(\""default\"")));\n # undef FcRangeCreateInteger\n-extern __typeof (FcRangeCreateInteger) FcRangeCreateInteger __attribute((alias(\""IA__FcRangeCreateInteger\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcRangeCreateInteger) FcRangeCreateInteger __attribute((alias(\""IA__FcRangeCreateInteger\""), visibility(\""default\"")));\n # undef FcRangeDestroy\n-extern __typeof (FcRangeDestroy) FcRangeDestroy __attribute((alias(\""IA__FcRangeDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcRangeDestroy) FcRangeDestroy __attribute((alias(\""IA__FcRangeDestroy\""), visibility(\""default\"")));\n # undef FcRangeCopy\n-extern __typeof (FcRangeCopy) FcRangeCopy __attribute((alias(\""IA__FcRangeCopy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcRangeCopy) FcRangeCopy __attribute((alias(\""IA__FcRangeCopy\""), visibility(\""default\"")));\n # undef FcRangeGetDouble\n-extern __typeof (FcRangeGetDouble) FcRangeGetDouble __attribute((alias(\""IA__FcRangeGetDouble\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcRangeGetDouble) FcRangeGetDouble __attribute((alias(\""IA__FcRangeGetDouble\""), visibility(\""default\"")));\n #endif /* __fcrange__ */\n-#ifdef __fcpat__\n-# undef FcPatternIterStart\n-extern __typeof (FcPatternIterStart) FcPatternIterStart __attribute((alias(\""IA__FcPatternIterStart\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcPatternIterNext\n-extern __typeof (FcPatternIterNext) FcPatternIterNext __attribute((alias(\""IA__FcPatternIterNext\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcPatternIterEqual\n-extern __typeof (FcPatternIterEqual) FcPatternIterEqual __attribute((alias(\""IA__FcPatternIterEqual\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcPatternFindIter\n-extern __typeof (FcPatternFindIter) FcPatternFindIter __attribute((alias(\""IA__FcPatternFindIter\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcPatternIterIsValid\n-extern __typeof (FcPatternIterIsValid) FcPatternIterIsValid __attribute((alias(\""IA__FcPatternIterIsValid\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcPatternIterGetObject\n-extern __typeof (FcPatternIterGetObject) FcPatternIterGetObject __attribute((alias(\""IA__FcPatternIterGetObject\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcPatternIterValueCount\n-extern __typeof (FcPatternIterValueCount) FcPatternIterValueCount __attribute((alias(\""IA__FcPatternIterValueCount\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcPatternIterGetValue\n-extern __typeof (FcPatternIterGetValue) FcPatternIterGetValue __attribute((alias(\""IA__FcPatternIterGetValue\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-#endif /* __fcpat__ */\n #ifdef __fcweight__\n # undef FcWeightFromOpenType\n-extern __typeof (FcWeightFromOpenType) FcWeightFromOpenType __attribute((alias(\""IA__FcWeightFromOpenType\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcWeightFromOpenTypeDouble\n-extern __typeof (FcWeightFromOpenTypeDouble) FcWeightFromOpenTypeDouble __attribute((alias(\""IA__FcWeightFromOpenTypeDouble\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcWeightFromOpenType) FcWeightFromOpenType __attribute((alias(\""IA__FcWeightFromOpenType\""), visibility(\""default\"")));\n # undef FcWeightToOpenType\n-extern __typeof (FcWeightToOpenType) FcWeightToOpenType __attribute((alias(\""IA__FcWeightToOpenType\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcWeightToOpenTypeDouble\n-extern __typeof (FcWeightToOpenTypeDouble) FcWeightToOpenTypeDouble __attribute((alias(\""IA__FcWeightToOpenTypeDouble\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcWeightToOpenType) FcWeightToOpenType __attribute((alias(\""IA__FcWeightToOpenType\""), visibility(\""default\"")));\n #endif /* __fcweight__ */\n #ifdef __fcstr__\n # undef FcStrCopy\n-extern __typeof (FcStrCopy) FcStrCopy __attribute((alias(\""IA__FcStrCopy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrCopy) FcStrCopy __attribute((alias(\""IA__FcStrCopy\""), visibility(\""default\"")));\n # undef FcStrCopyFilename\n-extern __typeof (FcStrCopyFilename) FcStrCopyFilename __attribute((alias(\""IA__FcStrCopyFilename\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrCopyFilename) FcStrCopyFilename __attribute((alias(\""IA__FcStrCopyFilename\""), visibility(\""default\"")));\n # undef FcStrPlus\n-extern __typeof (FcStrPlus) FcStrPlus __attribute((alias(\""IA__FcStrPlus\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrPlus) FcStrPlus __attribute((alias(\""IA__FcStrPlus\""), visibility(\""default\"")));\n # undef FcStrFree\n-extern __typeof (FcStrFree) FcStrFree __attribute((alias(\""IA__FcStrFree\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrFree) FcStrFree __attribute((alias(\""IA__FcStrFree\""), visibility(\""default\"")));\n # undef FcStrDowncase\n-extern __typeof (FcStrDowncase) FcStrDowncase __attribute((alias(\""IA__FcStrDowncase\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrDowncase) FcStrDowncase __attribute((alias(\""IA__FcStrDowncase\""), visibility(\""default\"")));\n # undef FcStrCmpIgnoreCase\n-extern __typeof (FcStrCmpIgnoreCase) FcStrCmpIgnoreCase __attribute((alias(\""IA__FcStrCmpIgnoreCase\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrCmpIgnoreCase) FcStrCmpIgnoreCase __attribute((alias(\""IA__FcStrCmpIgnoreCase\""), visibility(\""default\"")));\n # undef FcStrCmp\n-extern __typeof (FcStrCmp) FcStrCmp __attribute((alias(\""IA__FcStrCmp\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrCmp) FcStrCmp __attribute((alias(\""IA__FcStrCmp\""), visibility(\""default\"")));\n # undef FcStrStrIgnoreCase\n-extern __typeof (FcStrStrIgnoreCase) FcStrStrIgnoreCase __attribute((alias(\""IA__FcStrStrIgnoreCase\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrStrIgnoreCase) FcStrStrIgnoreCase __attribute((alias(\""IA__FcStrStrIgnoreCase\""), visibility(\""default\"")));\n # undef FcStrStr\n-extern __typeof (FcStrStr) FcStrStr __attribute((alias(\""IA__FcStrStr\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrStr) FcStrStr __attribute((alias(\""IA__FcStrStr\""), visibility(\""default\"")));\n # undef FcUtf8ToUcs4\n-extern __typeof (FcUtf8ToUcs4) FcUtf8ToUcs4 __attribute((alias(\""IA__FcUtf8ToUcs4\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcUtf8ToUcs4) FcUtf8ToUcs4 __attribute((alias(\""IA__FcUtf8ToUcs4\""), visibility(\""default\"")));\n # undef FcUtf8Len\n-extern __typeof (FcUtf8Len) FcUtf8Len __attribute((alias(\""IA__FcUtf8Len\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcUtf8Len) FcUtf8Len __attribute((alias(\""IA__FcUtf8Len\""), visibility(\""default\"")));\n # undef FcUcs4ToUtf8\n-extern __typeof (FcUcs4ToUtf8) FcUcs4ToUtf8 __attribute((alias(\""IA__FcUcs4ToUtf8\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcUcs4ToUtf8) FcUcs4ToUtf8 __attribute((alias(\""IA__FcUcs4ToUtf8\""), visibility(\""default\"")));\n # undef FcUtf16ToUcs4\n-extern __typeof (FcUtf16ToUcs4) FcUtf16ToUcs4 __attribute((alias(\""IA__FcUtf16ToUcs4\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcUtf16ToUcs4) FcUtf16ToUcs4 __attribute((alias(\""IA__FcUtf16ToUcs4\""), visibility(\""default\"")));\n # undef FcUtf16Len\n-extern __typeof (FcUtf16Len) FcUtf16Len __attribute((alias(\""IA__FcUtf16Len\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcUtf16Len) FcUtf16Len __attribute((alias(\""IA__FcUtf16Len\""), visibility(\""default\"")));\n # undef FcStrDirname\n-extern __typeof (FcStrDirname) FcStrDirname __attribute((alias(\""IA__FcStrDirname\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrDirname) FcStrDirname __attribute((alias(\""IA__FcStrDirname\""), visibility(\""default\"")));\n # undef FcStrBasename\n-extern __typeof (FcStrBasename) FcStrBasename __attribute((alias(\""IA__FcStrBasename\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrBasename) FcStrBasename __attribute((alias(\""IA__FcStrBasename\""), visibility(\""default\"")));\n # undef FcStrSetCreate\n-extern __typeof (FcStrSetCreate) FcStrSetCreate __attribute((alias(\""IA__FcStrSetCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrSetCreate) FcStrSetCreate __attribute((alias(\""IA__FcStrSetCreate\""), visibility(\""default\"")));\n # undef FcStrSetMember\n-extern __typeof (FcStrSetMember) FcStrSetMember __attribute((alias(\""IA__FcStrSetMember\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrSetMember) FcStrSetMember __attribute((alias(\""IA__FcStrSetMember\""), visibility(\""default\"")));\n # undef FcStrSetEqual\n-extern __typeof (FcStrSetEqual) FcStrSetEqual __attribute((alias(\""IA__FcStrSetEqual\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrSetEqual) FcStrSetEqual __attribute((alias(\""IA__FcStrSetEqual\""), visibility(\""default\"")));\n # undef FcStrSetAdd\n-extern __typeof (FcStrSetAdd) FcStrSetAdd __attribute((alias(\""IA__FcStrSetAdd\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrSetAdd) FcStrSetAdd __attribute((alias(\""IA__FcStrSetAdd\""), visibility(\""default\"")));\n # undef FcStrSetAddFilename\n-extern __typeof (FcStrSetAddFilename) FcStrSetAddFilename __attribute((alias(\""IA__FcStrSetAddFilename\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrSetAddFilename) FcStrSetAddFilename __attribute((alias(\""IA__FcStrSetAddFilename\""), visibility(\""default\"")));\n # undef FcStrSetDel\n-extern __typeof (FcStrSetDel) FcStrSetDel __attribute((alias(\""IA__FcStrSetDel\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrSetDel) FcStrSetDel __attribute((alias(\""IA__FcStrSetDel\""), visibility(\""default\"")));\n # undef FcStrSetDestroy\n-extern __typeof (FcStrSetDestroy) FcStrSetDestroy __attribute((alias(\""IA__FcStrSetDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrSetDestroy) FcStrSetDestroy __attribute((alias(\""IA__FcStrSetDestroy\""), visibility(\""default\"")));\n # undef FcStrListCreate\n-extern __typeof (FcStrListCreate) FcStrListCreate __attribute((alias(\""IA__FcStrListCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrListCreate) FcStrListCreate __attribute((alias(\""IA__FcStrListCreate\""), visibility(\""default\"")));\n # undef FcStrListFirst\n-extern __typeof (FcStrListFirst) FcStrListFirst __attribute((alias(\""IA__FcStrListFirst\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrListFirst) FcStrListFirst __attribute((alias(\""IA__FcStrListFirst\""), visibility(\""default\"")));\n # undef FcStrListNext\n-extern __typeof (FcStrListNext) FcStrListNext __attribute((alias(\""IA__FcStrListNext\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrListNext) FcStrListNext __attribute((alias(\""IA__FcStrListNext\""), visibility(\""default\"")));\n # undef FcStrListDone\n-extern __typeof (FcStrListDone) FcStrListDone __attribute((alias(\""IA__FcStrListDone\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrListDone) FcStrListDone __attribute((alias(\""IA__FcStrListDone\""), visibility(\""default\"")));\n #endif /* __fcstr__ */\n #ifdef __fcxml__\n # undef FcConfigParseAndLoad\n-extern __typeof (FcConfigParseAndLoad) FcConfigParseAndLoad __attribute((alias(\""IA__FcConfigParseAndLoad\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigParseAndLoad) FcConfigParseAndLoad __attribute((alias(\""IA__FcConfigParseAndLoad\""), visibility(\""default\"")));\n # undef FcConfigParseAndLoadFromMemory\n-extern __typeof (FcConfigParseAndLoadFromMemory) FcConfigParseAndLoadFromMemory __attribute((alias(\""IA__FcConfigParseAndLoadFromMemory\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigParseAndLoadFromMemory) FcConfigParseAndLoadFromMemory __attribute((alias(\""IA__FcConfigParseAndLoadFromMemory\""), visibility(\""default\"")));\n #endif /* __fcxml__ */\n #ifdef __fccfg__\n # undef FcConfigGetRescanInverval\n-extern __typeof (FcConfigGetRescanInverval) FcConfigGetRescanInverval __attribute((alias(\""IA__FcConfigGetRescanInverval\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetRescanInverval) FcConfigGetRescanInverval __attribute((alias(\""IA__FcConfigGetRescanInverval\""), visibility(\""default\"")));\n # undef FcConfigSetRescanInverval\n-extern __typeof (FcConfigSetRescanInverval) FcConfigSetRescanInverval __attribute((alias(\""IA__FcConfigSetRescanInverval\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigSetRescanInverval) FcConfigSetRescanInverval __attribute((alias(\""IA__FcConfigSetRescanInverval\""), visibility(\""default\"")));\n #endif /*  */\n #endif /* HAVE_GNUC_ATTRIBUTE */""}<_**next**_>{""sha"": ""884eb4b2e4b59127dce6f91435d1f43e80fa3bdb"", ""filename"": ""third_party/fontconfig/include/src/fcftalias.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcftalias.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcftalias.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/include/src/fcftalias.h?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -1,12 +1,12 @@\n-extern __typeof (FcFreeTypeCharIndex) IA__FcFreeTypeCharIndex FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFreeTypeCharIndex) IA__FcFreeTypeCharIndex __attribute((visibility(\""hidden\"")));\n #define FcFreeTypeCharIndex IA__FcFreeTypeCharIndex\n-extern __typeof (FcFreeTypeCharSetAndSpacing) IA__FcFreeTypeCharSetAndSpacing FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFreeTypeCharSetAndSpacing) IA__FcFreeTypeCharSetAndSpacing __attribute((visibility(\""hidden\"")));\n #define FcFreeTypeCharSetAndSpacing IA__FcFreeTypeCharSetAndSpacing\n-extern __typeof (FcFreeTypeCharSet) IA__FcFreeTypeCharSet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFreeTypeCharSet) IA__FcFreeTypeCharSet __attribute((visibility(\""hidden\"")));\n #define FcFreeTypeCharSet IA__FcFreeTypeCharSet\n-extern __typeof (FcPatternGetFTFace) IA__FcPatternGetFTFace FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetFTFace) IA__FcPatternGetFTFace __attribute((visibility(\""hidden\"")));\n #define FcPatternGetFTFace IA__FcPatternGetFTFace\n-extern __typeof (FcPatternAddFTFace) IA__FcPatternAddFTFace FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddFTFace) IA__FcPatternAddFTFace __attribute((visibility(\""hidden\"")));\n #define FcPatternAddFTFace IA__FcPatternAddFTFace\n-extern __typeof (FcFreeTypeQueryFace) IA__FcFreeTypeQueryFace FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFreeTypeQueryFace) IA__FcFreeTypeQueryFace __attribute((visibility(\""hidden\"")));\n #define FcFreeTypeQueryFace IA__FcFreeTypeQueryFace""}<_**next**_>{""sha"": ""f5a537d9ce9a10d96baa093560761a8c3e4f5a0c"", ""filename"": ""third_party/fontconfig/include/src/fcftaliastail.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcftaliastail.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcftaliastail.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/include/src/fcftaliastail.h?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -1,20 +1,20 @@\n #if HAVE_GNUC_ATTRIBUTE\n #ifdef __fcfreetype__\n # undef FcFreeTypeCharIndex\n-extern __typeof (FcFreeTypeCharIndex) FcFreeTypeCharIndex __attribute((alias(\""IA__FcFreeTypeCharIndex\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFreeTypeCharIndex) FcFreeTypeCharIndex __attribute((alias(\""IA__FcFreeTypeCharIndex\""), visibility(\""default\"")));\n # undef FcFreeTypeCharSetAndSpacing\n-extern __typeof (FcFreeTypeCharSetAndSpacing) FcFreeTypeCharSetAndSpacing __attribute((alias(\""IA__FcFreeTypeCharSetAndSpacing\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFreeTypeCharSetAndSpacing) FcFreeTypeCharSetAndSpacing __attribute((alias(\""IA__FcFreeTypeCharSetAndSpacing\""), visibility(\""default\"")));\n # undef FcFreeTypeCharSet\n-extern __typeof (FcFreeTypeCharSet) FcFreeTypeCharSet __attribute((alias(\""IA__FcFreeTypeCharSet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFreeTypeCharSet) FcFreeTypeCharSet __attribute((alias(\""IA__FcFreeTypeCharSet\""), visibility(\""default\"")));\n #endif /* __fcfreetype__ */\n #ifdef __fcpat__\n # undef FcPatternGetFTFace\n-extern __typeof (FcPatternGetFTFace) FcPatternGetFTFace __attribute((alias(\""IA__FcPatternGetFTFace\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetFTFace) FcPatternGetFTFace __attribute((alias(\""IA__FcPatternGetFTFace\""), visibility(\""default\"")));\n # undef FcPatternAddFTFace\n-extern __typeof (FcPatternAddFTFace) FcPatternAddFTFace __attribute((alias(\""IA__FcPatternAddFTFace\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddFTFace) FcPatternAddFTFace __attribute((alias(\""IA__FcPatternAddFTFace\""), visibility(\""default\"")));\n #endif /* __fcpat__ */\n #ifdef __fcfreetype__\n # undef FcFreeTypeQueryFace\n-extern __typeof (FcFreeTypeQueryFace) FcFreeTypeQueryFace __attribute((alias(\""IA__FcFreeTypeQueryFace\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFreeTypeQueryFace) FcFreeTypeQueryFace __attribute((alias(\""IA__FcFreeTypeQueryFace\""), visibility(\""default\"")));\n #endif /*  */\n #endif /* HAVE_GNUC_ATTRIBUTE */""}<_**next**_>{""sha"": ""7ca40966e2bc8679ada22e4ddf2f5b1ded4d8ebc"", ""filename"": ""third_party/fontconfig/include/src/fcobjshash.h"", ""status"": ""modified"", ""additions"": 165, ""deletions"": 169, ""changes"": 334, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcobjshash.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcobjshash.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/include/src/fcobjshash.h?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* ANSI-C code produced by gperf version 3.1 */\n+/* ANSI-C code produced by gperf version 3.0.4 */\n /* Command-line: gperf --pic -m 100 fcobjshash.gperf  */\n /* Computed positions: -k'2-3' */\n \n@@ -26,7 +26,7 @@\n       && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \\\n       && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))\n /* The character set is not based on ISO-646.  */\n-#error \""gperf generated tables don't work with this execution character set. Please report a bug to <bug-gperf@gnu.org>.\""\n+#error \""gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>.\""\n #endif\n \n #line 1 \""fcobjshash.gperf\""\n@@ -37,7 +37,7 @@ int name;\n int id;\n };\n #include <string.h>\n-/* maximum key range = 65, duplicates = 0 */\n+/* maximum key range = 56, duplicates = 0 */\n \n #ifdef __GNUC__\n __inline\n@@ -47,36 +47,36 @@ inline\n #endif\n #endif\n static unsigned int\n-FcObjectTypeHash (register const char *str, register size_t len)\n+FcObjectTypeHash (register const char *str, register unsigned int len)\n {\n   static const unsigned char asso_values[] =\n     {\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69,  9, 21, 18,\n-      33, 21, 69,  6, 36,  0, 69, 69,  0, 24,\n-       9,  0, 21, 69, 33, 15, 18,  0, 69, 69,\n-       0, 21,  6, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 21, 30,  3,\n+      36, 45, 60,  3, 15,  0, 60, 60,  0,  9,\n+       9,  0, 21, 60,  0,  0, 15,  0, 60, 60,\n+       0, 15, 24, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60\n     };\n   return len + asso_values[(unsigned char)str[2]] + asso_values[(unsigned char)str[1]];\n }\n@@ -88,51 +88,49 @@ struct FcObjectTypeNamePool_t\n     char FcObjectTypeNamePool_str7[sizeof(\""foundry\"")];\n     char FcObjectTypeNamePool_str8[sizeof(\""fullname\"")];\n     char FcObjectTypeNamePool_str9[sizeof(\""pixelsize\"")];\n-    char FcObjectTypeNamePool_str10[sizeof(\""size\"")];\n+    char FcObjectTypeNamePool_str10[sizeof(\""prgname\"")];\n     char FcObjectTypeNamePool_str12[sizeof(\""fullnamelang\"")];\n     char FcObjectTypeNamePool_str13[sizeof(\""globaladvance\"")];\n-    char FcObjectTypeNamePool_str14[sizeof(\""slant\"")];\n+    char FcObjectTypeNamePool_str14[sizeof(\""postscriptname\"")];\n     char FcObjectTypeNamePool_str16[sizeof(\""hinting\"")];\n     char FcObjectTypeNamePool_str17[sizeof(\""minspace\"")];\n     char FcObjectTypeNamePool_str18[sizeof(\""hintstyle\"")];\n     char FcObjectTypeNamePool_str19[sizeof(\""fontformat\"")];\n     char FcObjectTypeNamePool_str20[sizeof(\""fontversion\"")];\n     char FcObjectTypeNamePool_str21[sizeof(\""fontfeatures\"")];\n-    char FcObjectTypeNamePool_str22[sizeof(\""lang\"")];\n-    char FcObjectTypeNamePool_str23[sizeof(\""fontvariations\"")];\n+    char FcObjectTypeNamePool_str22[sizeof(\""outline\"")];\n+    char FcObjectTypeNamePool_str23[sizeof(\""autohint\"")];\n     char FcObjectTypeNamePool_str24[sizeof(\""dpi\"")];\n-    char FcObjectTypeNamePool_str25[sizeof(\""outline\"")];\n-    char FcObjectTypeNamePool_str26[sizeof(\""autohint\"")];\n-    char FcObjectTypeNamePool_str27[sizeof(\""weight\"")];\n-    char FcObjectTypeNamePool_str28[sizeof(\""hash\"")];\n-    char FcObjectTypeNamePool_str29[sizeof(\""postscriptname\"")];\n-    char FcObjectTypeNamePool_str31[sizeof(\""rgba\"")];\n-    char FcObjectTypeNamePool_str32[sizeof(\""scale\"")];\n-    char FcObjectTypeNamePool_str33[sizeof(\""matrix\"")];\n-    char FcObjectTypeNamePool_str34[sizeof(\""rasterizer\"")];\n-    char FcObjectTypeNamePool_str35[sizeof(\""scalable\"")];\n-    char FcObjectTypeNamePool_str36[sizeof(\""antialias\"")];\n-    char FcObjectTypeNamePool_str37[sizeof(\""spacing\"")];\n-    char FcObjectTypeNamePool_str38[sizeof(\""width\"")];\n-    char FcObjectTypeNamePool_str39[sizeof(\""family\"")];\n-    char FcObjectTypeNamePool_str40[sizeof(\""capability\"")];\n-    char FcObjectTypeNamePool_str41[sizeof(\""namelang\"")];\n-    char FcObjectTypeNamePool_str42[sizeof(\""aspect\"")];\n-    char FcObjectTypeNamePool_str43[sizeof(\""familylang\"")];\n-    char FcObjectTypeNamePool_str44[sizeof(\""style\"")];\n-    char FcObjectTypeNamePool_str46[sizeof(\""prgname\"")];\n-    char FcObjectTypeNamePool_str47[sizeof(\""index\"")];\n-    char FcObjectTypeNamePool_str48[sizeof(\""stylelang\"")];\n-    char FcObjectTypeNamePool_str49[sizeof(\""decorative\"")];\n-    char FcObjectTypeNamePool_str50[sizeof(\""variable\"")];\n-    char FcObjectTypeNamePool_str51[sizeof(\""symbol\"")];\n-    char FcObjectTypeNamePool_str52[sizeof(\""charset\"")];\n-    char FcObjectTypeNamePool_str53[sizeof(\""embolden\"")];\n-    char FcObjectTypeNamePool_str54[sizeof(\""charwidth\"")];\n-    char FcObjectTypeNamePool_str55[sizeof(\""charheight\"")];\n-    char FcObjectTypeNamePool_str59[sizeof(\""embeddedbitmap\"")];\n-    char FcObjectTypeNamePool_str60[sizeof(\""lcdfilter\"")];\n-    char FcObjectTypeNamePool_str68[sizeof(\""verticallayout\"")];\n+    char FcObjectTypeNamePool_str25[sizeof(\""hash\"")];\n+    char FcObjectTypeNamePool_str26[sizeof(\""slant\"")];\n+    char FcObjectTypeNamePool_str27[sizeof(\""aspect\"")];\n+    char FcObjectTypeNamePool_str28[sizeof(\""size\"")];\n+    char FcObjectTypeNamePool_str29[sizeof(\""scale\"")];\n+    char FcObjectTypeNamePool_str30[sizeof(\""symbol\"")];\n+    char FcObjectTypeNamePool_str31[sizeof(\""rasterizer\"")];\n+    char FcObjectTypeNamePool_str32[sizeof(\""scalable\"")];\n+    char FcObjectTypeNamePool_str33[sizeof(\""antialias\"")];\n+    char FcObjectTypeNamePool_str34[sizeof(\""lang\"")];\n+    char FcObjectTypeNamePool_str35[sizeof(\""style\"")];\n+    char FcObjectTypeNamePool_str36[sizeof(\""family\"")];\n+    char FcObjectTypeNamePool_str37[sizeof(\""rgba\"")];\n+    char FcObjectTypeNamePool_str38[sizeof(\""namelang\"")];\n+    char FcObjectTypeNamePool_str39[sizeof(\""stylelang\"")];\n+    char FcObjectTypeNamePool_str40[sizeof(\""familylang\"")];\n+    char FcObjectTypeNamePool_str41[sizeof(\""width\"")];\n+    char FcObjectTypeNamePool_str42[sizeof(\""matrix\"")];\n+    char FcObjectTypeNamePool_str43[sizeof(\""charset\"")];\n+    char FcObjectTypeNamePool_str45[sizeof(\""charwidth\"")];\n+    char FcObjectTypeNamePool_str46[sizeof(\""charheight\"")];\n+    char FcObjectTypeNamePool_str47[sizeof(\""embolden\"")];\n+    char FcObjectTypeNamePool_str48[sizeof(\""lcdfilter\"")];\n+    char FcObjectTypeNamePool_str49[sizeof(\""spacing\"")];\n+    char FcObjectTypeNamePool_str50[sizeof(\""index\"")];\n+    char FcObjectTypeNamePool_str51[sizeof(\""weight\"")];\n+    char FcObjectTypeNamePool_str52[sizeof(\""capability\"")];\n+    char FcObjectTypeNamePool_str53[sizeof(\""embeddedbitmap\"")];\n+    char FcObjectTypeNamePool_str58[sizeof(\""decorative\"")];\n+    char FcObjectTypeNamePool_str59[sizeof(\""verticallayout\"")];\n   };\n static const struct FcObjectTypeNamePool_t FcObjectTypeNamePool_contents =\n   {\n@@ -141,182 +139,180 @@ static const struct FcObjectTypeNamePool_t FcObjectTypeNamePool_contents =\n     \""foundry\"",\n     \""fullname\"",\n     \""pixelsize\"",\n-    \""size\"",\n+    \""prgname\"",\n     \""fullnamelang\"",\n     \""globaladvance\"",\n-    \""slant\"",\n+    \""postscriptname\"",\n     \""hinting\"",\n     \""minspace\"",\n     \""hintstyle\"",\n     \""fontformat\"",\n     \""fontversion\"",\n     \""fontfeatures\"",\n-    \""lang\"",\n-    \""fontvariations\"",\n-    \""dpi\"",\n     \""outline\"",\n     \""autohint\"",\n-    \""weight\"",\n+    \""dpi\"",\n     \""hash\"",\n-    \""postscriptname\"",\n-    \""rgba\"",\n+    \""slant\"",\n+    \""aspect\"",\n+    \""size\"",\n     \""scale\"",\n-    \""matrix\"",\n+    \""symbol\"",\n     \""rasterizer\"",\n     \""scalable\"",\n     \""antialias\"",\n-    \""spacing\"",\n-    \""width\"",\n+    \""lang\"",\n+    \""style\"",\n     \""family\"",\n-    \""capability\"",\n+    \""rgba\"",\n     \""namelang\"",\n-    \""aspect\"",\n-    \""familylang\"",\n-    \""style\"",\n-    \""prgname\"",\n-    \""index\"",\n     \""stylelang\"",\n-    \""decorative\"",\n-    \""variable\"",\n-    \""symbol\"",\n+    \""familylang\"",\n+    \""width\"",\n+    \""matrix\"",\n     \""charset\"",\n-    \""embolden\"",\n     \""charwidth\"",\n     \""charheight\"",\n-    \""embeddedbitmap\"",\n+    \""embolden\"",\n     \""lcdfilter\"",\n+    \""spacing\"",\n+    \""index\"",\n+    \""weight\"",\n+    \""capability\"",\n+    \""embeddedbitmap\"",\n+    \""decorative\"",\n     \""verticallayout\""\n   };\n #define FcObjectTypeNamePool ((const char *) &FcObjectTypeNamePool_contents)\n+#ifdef __GNUC__\n+__inline\n+#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__\n+__attribute__ ((__gnu_inline__))\n+#endif\n+#endif\n const struct FcObjectTypeInfo *\n-FcObjectTypeLookup (register const char *str, register size_t len)\n+FcObjectTypeLookup (register const char *str, register unsigned int len)\n {\n   enum\n     {\n-      TOTAL_KEYWORDS = 50,\n+      TOTAL_KEYWORDS = 48,\n       MIN_WORD_LENGTH = 3,\n       MAX_WORD_LENGTH = 14,\n       MIN_HASH_VALUE = 4,\n-      MAX_HASH_VALUE = 68\n+      MAX_HASH_VALUE = 59\n     };\n \n   static const struct FcObjectTypeInfo wordlist[] =\n     {\n       {-1}, {-1}, {-1}, {-1},\n #line 38 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str4,FC_FILE_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str4,FC_FILE_OBJECT},\n #line 64 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str5,FC_COLOR_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str5,FC_COLOR_OBJECT},\n       {-1},\n #line 31 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str7,FC_FOUNDRY_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str7,FC_FOUNDRY_OBJECT},\n #line 22 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str8,FC_FULLNAME_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str8,FC_FULLNAME_OBJECT},\n #line 29 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str9,FC_PIXEL_SIZE_OBJECT},\n-#line 27 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str10,FC_SIZE_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str9,FC_PIXEL_SIZE_OBJECT},\n+#line 61 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str10,FC_PRGNAME_OBJECT},\n       {-1},\n #line 23 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str12,FC_FULLNAMELANG_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str12,FC_FULLNAMELANG_OBJECT},\n #line 37 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str13,FC_GLOBAL_ADVANCE_OBJECT},\n-#line 24 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str14,FC_SLANT_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str13,FC_GLOBAL_ADVANCE_OBJECT},\n+#line 63 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str14,FC_POSTSCRIPT_NAME_OBJECT},\n       {-1},\n #line 34 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str16,FC_HINTING_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str16,FC_HINTING_OBJECT},\n #line 46 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str17,FC_MINSPACE_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str17,FC_MINSPACE_OBJECT},\n #line 33 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str18,FC_HINT_STYLE_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str18,FC_HINT_STYLE_OBJECT},\n #line 54 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str19,FC_FONTFORMAT_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str19,FC_FONTFORMAT_OBJECT},\n #line 52 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str20,FC_FONTVERSION_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str20,FC_FONTVERSION_OBJECT},\n #line 60 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str21,FC_FONT_FEATURES_OBJECT},\n-#line 51 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str22,FC_LANG_OBJECT},\n-#line 66 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str23,FC_FONT_VARIATIONS_OBJECT},\n-#line 43 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str24,FC_DPI_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str21,FC_FONT_FEATURES_OBJECT},\n #line 41 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str25,FC_OUTLINE_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str22,FC_OUTLINE_OBJECT},\n #line 36 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str26,FC_AUTOHINT_OBJECT},\n-#line 25 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str27,FC_WEIGHT_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str23,FC_AUTOHINT_OBJECT},\n+#line 43 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str24,FC_DPI_OBJECT},\n #line 62 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str28,FC_HASH_OBJECT},\n-#line 63 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str29,FC_POSTSCRIPT_NAME_OBJECT},\n-      {-1},\n-#line 44 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str31,FC_RGBA_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str25,FC_HASH_OBJECT},\n+#line 24 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str26,FC_SLANT_OBJECT},\n+#line 28 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str27,FC_ASPECT_OBJECT},\n+#line 27 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str28,FC_SIZE_OBJECT},\n #line 45 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str32,FC_SCALE_OBJECT},\n-#line 49 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str33,FC_MATRIX_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str29,FC_SCALE_OBJECT},\n+#line 65 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str30,FC_SYMBOL_OBJECT},\n #line 40 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str34,FC_RASTERIZER_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str31,FC_RASTERIZER_OBJECT},\n #line 42 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str35,FC_SCALABLE_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str32,FC_SCALABLE_OBJECT},\n #line 32 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str36,FC_ANTIALIAS_OBJECT},\n-#line 30 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str37,FC_SPACING_OBJECT},\n-#line 26 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str38,FC_WIDTH_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str33,FC_ANTIALIAS_OBJECT},\n+#line 51 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str34,FC_LANG_OBJECT},\n+#line 20 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str35,FC_STYLE_OBJECT},\n #line 18 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str39,FC_FAMILY_OBJECT},\n-#line 53 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str40,FC_CAPABILITY_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str36,FC_FAMILY_OBJECT},\n+#line 44 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str37,FC_RGBA_OBJECT},\n #line 59 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str41,FC_NAMELANG_OBJECT},\n-#line 28 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str42,FC_ASPECT_OBJECT},\n-#line 19 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str43,FC_FAMILYLANG_OBJECT},\n-#line 20 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str44,FC_STYLE_OBJECT},\n-      {-1},\n-#line 61 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str46,FC_PRGNAME_OBJECT},\n-#line 39 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str47,FC_INDEX_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str38,FC_NAMELANG_OBJECT},\n #line 21 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str48,FC_STYLELANG_OBJECT},\n-#line 57 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str49,FC_DECORATIVE_OBJECT},\n-#line 67 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str50,FC_VARIABLE_OBJECT},\n-#line 65 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str51,FC_SYMBOL_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str39,FC_STYLELANG_OBJECT},\n+#line 19 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str40,FC_FAMILYLANG_OBJECT},\n+#line 26 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str41,FC_WIDTH_OBJECT},\n+#line 49 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str42,FC_MATRIX_OBJECT},\n #line 50 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str52,FC_CHARSET_OBJECT},\n-#line 55 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str53,FC_EMBOLDEN_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str43,FC_CHARSET_OBJECT},\n+      {-1},\n #line 47 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str54,FC_CHARWIDTH_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str45,FC_CHARWIDTH_OBJECT},\n #line 48 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str55,FC_CHAR_HEIGHT_OBJECT},\n-      {-1}, {-1}, {-1},\n-#line 56 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str59,FC_EMBEDDED_BITMAP_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str46,FC_CHAR_HEIGHT_OBJECT},\n+#line 55 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str47,FC_EMBOLDEN_OBJECT},\n #line 58 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str60,FC_LCD_FILTER_OBJECT},\n-      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str48,FC_LCD_FILTER_OBJECT},\n+#line 30 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str49,FC_SPACING_OBJECT},\n+#line 39 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str50,FC_INDEX_OBJECT},\n+#line 25 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str51,FC_WEIGHT_OBJECT},\n+#line 53 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str52,FC_CAPABILITY_OBJECT},\n+#line 56 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str53,FC_EMBEDDED_BITMAP_OBJECT},\n+      {-1}, {-1}, {-1}, {-1},\n+#line 57 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str58,FC_DECORATIVE_OBJECT},\n #line 35 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str68,FC_VERTICAL_LAYOUT_OBJECT}\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str59,FC_VERTICAL_LAYOUT_OBJECT}\n     };\n \n   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n     {\n-      register unsigned int key = FcObjectTypeHash (str, len);\n+      register int key = FcObjectTypeHash (str, len);\n \n-      if (key <= MAX_HASH_VALUE)\n+      if (key <= MAX_HASH_VALUE && key >= 0)\n         {\n           register int o = wordlist[key].name;\n           if (o >= 0)""}<_**next**_>{""sha"": ""e2ded13c465a0f2730679b6e3eae5c4064e5557e"", ""filename"": ""third_party/fontconfig/include/src/fcstdint.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcstdint.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcstdint.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/include/src/fcstdint.h?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -1,8 +1,8 @@\n #ifndef _FONTCONFIG_SRC_FCSTDINT_H\n #define _FONTCONFIG_SRC_FCSTDINT_H 1\n #ifndef _GENERATED_STDINT_H\n-#define _GENERATED_STDINT_H \""fontconfig 2.13.0\""\n-/* generated using gnu compiler gcc (Debian 7.3.0-21) 7.3.0 */\n+#define _GENERATED_STDINT_H \""fontconfig 2.12.6\""\n+/* generated using gnu compiler gcc (Debian 6.3.0-18) 6.3.0 20170516 */\n #define _STDINT_HAVE_STDINT_H 1\n #include <stdint.h>\n #endif""}"," void SetUpFontconfig() {
  FilePath dir_module;
  PathService::Get(DIR_MODULE, &dir_module);
  FilePath font_cache = dir_module.Append(""fontconfig_caches"");
  FilePath test_fonts = dir_module.Append(""test_fonts"");
  std::string fonts_conf = ReplaceStringPlaceholders(
      kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);

  FcConfig* config = FcConfigCreate();
  CHECK(config);
#if FC_VERSION >= 21205
  CHECK(FcConfigParseAndLoadFromMemory(
      config, reinterpret_cast<const FcChar8*>(fonts_conf.c_str()), FcTrue));
#else
  FilePath temp;
  CHECK(CreateTemporaryFile(&temp));
  CHECK(WriteFile(temp, fonts_conf.c_str(), fonts_conf.size()));
  CHECK(FcConfigParseAndLoad(
      config, reinterpret_cast<const FcChar8*>(temp.value().c_str()), FcTrue));
  CHECK(DeleteFile(temp, false));
#endif
  CHECK(FcConfigBuildFonts(config));
  CHECK(FcConfigSetCurrent(config));

  // Decrement the reference count for |config|.  It's now owned by fontconfig.
  FcConfigDestroy(config);
 }
"," void SetUpFontconfig() {
  std::unique_ptr<Environment> env = Environment::Create();
  if (!env->HasVar(""FONTCONFIG_FILE"")) {
    FilePath dir_module;
    PathService::Get(DIR_MODULE, &dir_module);
    FilePath font_cache = dir_module.Append(""fontconfig_caches"");
    FilePath test_fonts = dir_module.Append(""test_fonts"");
    std::string fonts_conf = ReplaceStringPlaceholders(
        kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);
    FilePath fonts_conf_file_temp;
    CHECK(CreateTemporaryFileInDir(dir_module, &fonts_conf_file_temp));
    CHECK(
        WriteFile(fonts_conf_file_temp, fonts_conf.c_str(), fonts_conf.size()));
    FilePath fonts_conf_file = dir_module.Append(""fonts.conf"");
    CHECK(ReplaceFile(fonts_conf_file_temp, fonts_conf_file, nullptr));
    env->SetVar(""FONTCONFIG_FILE"", fonts_conf_file.value());
  }
  CHECK(FcInit());
 }
",C,"  FilePath dir_module;
  PathService::Get(DIR_MODULE, &dir_module);
  FilePath font_cache = dir_module.Append(""fontconfig_caches"");
  FilePath test_fonts = dir_module.Append(""test_fonts"");
  std::string fonts_conf = ReplaceStringPlaceholders(
      kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);

  FcConfig* config = FcConfigCreate();
  CHECK(config);
#if FC_VERSION >= 21205
  CHECK(FcConfigParseAndLoadFromMemory(
      config, reinterpret_cast<const FcChar8*>(fonts_conf.c_str()), FcTrue));
#else
  FilePath temp;
  CHECK(CreateTemporaryFile(&temp));
  CHECK(WriteFile(temp, fonts_conf.c_str(), fonts_conf.size()));
  CHECK(FcConfigParseAndLoad(
      config, reinterpret_cast<const FcChar8*>(temp.value().c_str()), FcTrue));
  CHECK(DeleteFile(temp, false));
#endif
  CHECK(FcConfigBuildFonts(config));
  CHECK(FcConfigSetCurrent(config));

  // Decrement the reference count for |config|.  It's now owned by fontconfig.
  FcConfigDestroy(config);
","  std::unique_ptr<Environment> env = Environment::Create();
  if (!env->HasVar(""FONTCONFIG_FILE"")) {
    FilePath dir_module;
    PathService::Get(DIR_MODULE, &dir_module);
    FilePath font_cache = dir_module.Append(""fontconfig_caches"");
    FilePath test_fonts = dir_module.Append(""test_fonts"");
    std::string fonts_conf = ReplaceStringPlaceholders(
        kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);
    FilePath fonts_conf_file_temp;
    CHECK(CreateTemporaryFileInDir(dir_module, &fonts_conf_file_temp));
    CHECK(
        WriteFile(fonts_conf_file_temp, fonts_conf.c_str(), fonts_conf.size()));
    FilePath fonts_conf_file = dir_module.Append(""fonts.conf"");
    CHECK(ReplaceFile(fonts_conf_file_temp, fonts_conf_file, nullptr));
    env->SetVar(""FONTCONFIG_FILE"", fonts_conf_file.value());
  }
  CHECK(FcInit());
",,"@@ -7,7 +7,6 @@
 #include <fontconfig/fontconfig.h>
 
 #include ""base/base_paths.h""
-#include ""base/environment.h""
 #include ""base/files/file_path.h""
 #include ""base/files/file_util.h""
 #include ""base/logging.h""
@@ -382,35 +381,31 @@ const char kFontsConfTemplate[] = R""(<?xml version=""1.0""?>
 }  // namespace
 
 void SetUpFontconfig() {
-  // TODO(thomasanderson): Use FONTCONFIG_SYSROOT to avoid having to write
-  // a new fonts.conf with updated paths.
-  std::unique_ptr<Environment> env = Environment::Create();
-  if (!env->HasVar(""FONTCONFIG_FILE"")) {
-    // fonts.conf must be generated on-the-fly since it contains absolute paths
-    // which may be different if
-    //   1. The user moves/renames their build directory (or any parent dirs).
-    //   2. The build directory is mapped on a swarming bot at a location
-    //      different from the one the buildbot used.
-    FilePath dir_module;
-    PathService::Get(DIR_MODULE, &dir_module);
-    FilePath font_cache = dir_module.Append(""fontconfig_caches"");
-    FilePath test_fonts = dir_module.Append(""test_fonts"");
-    std::string fonts_conf = ReplaceStringPlaceholders(
-        kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);
-
-    // Write the data to a different file and then atomically rename it to
-    // fonts.conf.  This avoids the file being in a bad state when different
-    // parallel tests call this function at the same time.
-    FilePath fonts_conf_file_temp;
-    CHECK(CreateTemporaryFileInDir(dir_module, &fonts_conf_file_temp));
-    CHECK(
-        WriteFile(fonts_conf_file_temp, fonts_conf.c_str(), fonts_conf.size()));
-    FilePath fonts_conf_file = dir_module.Append(""fonts.conf"");
-    CHECK(ReplaceFile(fonts_conf_file_temp, fonts_conf_file, nullptr));
-    env->SetVar(""FONTCONFIG_FILE"", fonts_conf_file.value());
-  }
-
-  CHECK(FcInit());
+  FilePath dir_module;
+  PathService::Get(DIR_MODULE, &dir_module);
+  FilePath font_cache = dir_module.Append(""fontconfig_caches"");
+  FilePath test_fonts = dir_module.Append(""test_fonts"");
+  std::string fonts_conf = ReplaceStringPlaceholders(
+      kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);
+
+  FcConfig* config = FcConfigCreate();
+  CHECK(config);
+#if FC_VERSION >= 21205
+  CHECK(FcConfigParseAndLoadFromMemory(
+      config, reinterpret_cast<const FcChar8*>(fonts_conf.c_str()), FcTrue));
+#else
+  FilePath temp;
+  CHECK(CreateTemporaryFile(&temp));
+  CHECK(WriteFile(temp, fonts_conf.c_str(), fonts_conf.size()));
+  CHECK(FcConfigParseAndLoad(
+      config, reinterpret_cast<const FcChar8*>(temp.value().c_str()), FcTrue));
+  CHECK(DeleteFile(temp, false));
+#endif
+  CHECK(FcConfigBuildFonts(config));
+  CHECK(FcConfigSetCurrent(config));
+
+  // Decrement the reference count for |config|.  It's now owned by fontconfig.
+  FcConfigDestroy(config);
 }
 
 void TearDownFontconfig() {",Chrome,f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e,123d0536410a20de923a3c8931238979b838b90a,1," void SetUpFontconfig() {
//flaw_line_below:
  // TODO(thomasanderson): Use FONTCONFIG_SYSROOT to avoid having to write
//flaw_line_below:
  // a new fonts.conf with updated paths.
//flaw_line_below:
  std::unique_ptr<Environment> env = Environment::Create();
//flaw_line_below:
  if (!env->HasVar(""FONTCONFIG_FILE"")) {
//flaw_line_below:
    // fonts.conf must be generated on-the-fly since it contains absolute paths
//flaw_line_below:
    // which may be different if
//flaw_line_below:
    //   1. The user moves/renames their build directory (or any parent dirs).
//flaw_line_below:
    //   2. The build directory is mapped on a swarming bot at a location
//flaw_line_below:
    //      different from the one the buildbot used.
//flaw_line_below:
    FilePath dir_module;
//flaw_line_below:
    PathService::Get(DIR_MODULE, &dir_module);
//flaw_line_below:
    FilePath font_cache = dir_module.Append(""fontconfig_caches"");
//flaw_line_below:
    FilePath test_fonts = dir_module.Append(""test_fonts"");
//flaw_line_below:
    std::string fonts_conf = ReplaceStringPlaceholders(
//flaw_line_below:
        kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);
//flaw_line_below:

//flaw_line_below:
    // Write the data to a different file and then atomically rename it to
//flaw_line_below:
    // fonts.conf.  This avoids the file being in a bad state when different
//flaw_line_below:
    // parallel tests call this function at the same time.
//flaw_line_below:
    FilePath fonts_conf_file_temp;
//flaw_line_below:
    CHECK(CreateTemporaryFileInDir(dir_module, &fonts_conf_file_temp));
//flaw_line_below:
    CHECK(
//flaw_line_below:
        WriteFile(fonts_conf_file_temp, fonts_conf.c_str(), fonts_conf.size()));
//flaw_line_below:
    FilePath fonts_conf_file = dir_module.Append(""fonts.conf"");
//flaw_line_below:
    CHECK(ReplaceFile(fonts_conf_file_temp, fonts_conf_file, nullptr));
//flaw_line_below:
    env->SetVar(""FONTCONFIG_FILE"", fonts_conf_file.value());
//flaw_line_below:
  }
//flaw_line_below:

//flaw_line_below:
  CHECK(FcInit());
//fix_flaw_line_below:
//  FilePath dir_module;
//fix_flaw_line_below:
//  PathService::Get(DIR_MODULE, &dir_module);
//fix_flaw_line_below:
//  FilePath font_cache = dir_module.Append(""fontconfig_caches"");
//fix_flaw_line_below:
//  FilePath test_fonts = dir_module.Append(""test_fonts"");
//fix_flaw_line_below:
//  std::string fonts_conf = ReplaceStringPlaceholders(
//fix_flaw_line_below:
//      kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  FcConfig* config = FcConfigCreate();
//fix_flaw_line_below:
//  CHECK(config);
//fix_flaw_line_below:
//#if FC_VERSION >= 21205
//fix_flaw_line_below:
//  CHECK(FcConfigParseAndLoadFromMemory(
//fix_flaw_line_below:
//      config, reinterpret_cast<const FcChar8*>(fonts_conf.c_str()), FcTrue));
//fix_flaw_line_below:
//#else
//fix_flaw_line_below:
//  FilePath temp;
//fix_flaw_line_below:
//  CHECK(CreateTemporaryFile(&temp));
//fix_flaw_line_below:
//  CHECK(WriteFile(temp, fonts_conf.c_str(), fonts_conf.size()));
//fix_flaw_line_below:
//  CHECK(FcConfigParseAndLoad(
//fix_flaw_line_below:
//      config, reinterpret_cast<const FcChar8*>(temp.value().c_str()), FcTrue));
//fix_flaw_line_below:
//  CHECK(DeleteFile(temp, false));
//fix_flaw_line_below:
//#endif
//fix_flaw_line_below:
//  CHECK(FcConfigBuildFonts(config));
//fix_flaw_line_below:
//  CHECK(FcConfigSetCurrent(config));
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  // Decrement the reference count for |config|.  It's now owned by fontconfig.
//fix_flaw_line_below:
//  FcConfigDestroy(config);
 }
"
8804,186540,,Remote,Not required,,CVE-2016-1664,https://www.cvedetails.com/cve/CVE-2016-1664/,CWE-254,Medium,,Partial,,2016-05-14,4.3,"The HistoryController::UpdateForCommit function in content/renderer/history_controller.cc in Google Chrome before 50.0.2661.94 mishandles the interaction between subframe forward navigations and other forward navigations, which allows remote attackers to spoof the address bar via a crafted web site.",2018-10-30,,8,https://github.com/chromium/chromium/commit/bb3548ef2fcdb58f9bc638bb5a3c379320fdd0e0,bb3548ef2fcdb58f9bc638bb5a3c379320fdd0e0,"Fix HistoryEntry corruption when commit isn't for provisional entry.

BUG=597322
TEST=See bug for repro steps.

Review URL: https://codereview.chromium.org/1848103004

Cr-Commit-Position: refs/heads/master@{#384659}",1,content/renderer/history_controller.cc,"{""sha"": ""0a6cd634f3546944f4ee4dc7a8bdad8bc6a80168"", ""filename"": ""content/renderer/history_controller.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/bb3548ef2fcdb58f9bc638bb5a3c379320fdd0e0/content/renderer/history_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bb3548ef2fcdb58f9bc638bb5a3c379320fdd0e0/content/renderer/history_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/history_controller.cc?ref=bb3548ef2fcdb58f9bc638bb5a3c379320fdd0e0"", ""patch"": ""@@ -187,7 +187,14 @@ void HistoryController::UpdateForCommit(RenderFrameImpl* frame,\n     case blink::WebBackForwardCommit:\n       if (!provisional_entry_)\n         return;\n-      current_entry_.reset(provisional_entry_.release());\n+      // Commit the provisional entry, but only if this back/forward item\n+      // matches it.  Otherwise it could be a commit from an earlier attempt to\n+      // go back/forward, and we should leave the provisional entry in place.\n+      if (HistoryEntry::HistoryNode* node =\n+              provisional_entry_->GetHistoryNodeForFrame(frame)) {\n+        if (node->item().itemSequenceNumber() == item.itemSequenceNumber())\n+          current_entry_.reset(provisional_entry_.release());\n+      }\n       if (HistoryEntry::HistoryNode* node =\n               current_entry_->GetHistoryNodeForFrame(frame)) {\n         node->set_item(item);""}","void HistoryController::UpdateForCommit(RenderFrameImpl* frame,
                                        const WebHistoryItem& item,
                                        WebHistoryCommitType commit_type,
                                        bool navigation_within_page) {
  switch (commit_type) {
     case blink::WebBackForwardCommit:
       if (!provisional_entry_)
         return;
      // Commit the provisional entry, but only if this back/forward item
      // matches it.  Otherwise it could be a commit from an earlier attempt to
      // go back/forward, and we should leave the provisional entry in place.
      if (HistoryEntry::HistoryNode* node =
              provisional_entry_->GetHistoryNodeForFrame(frame)) {
        if (node->item().itemSequenceNumber() == item.itemSequenceNumber())
          current_entry_.reset(provisional_entry_.release());
      }
       if (HistoryEntry::HistoryNode* node =
               current_entry_->GetHistoryNodeForFrame(frame)) {
         node->set_item(item);
      }
      break;
    case blink::WebStandardCommit:
      CreateNewBackForwardItem(frame, item, navigation_within_page);
      break;
    case blink::WebInitialCommitInChildFrame:
      UpdateForInitialLoadInChildFrame(frame, item);
      break;
    case blink::WebHistoryInertCommit:
      if (current_entry_) {
        if (HistoryEntry::HistoryNode* node =
                current_entry_->GetHistoryNodeForFrame(frame)) {
          if (!navigation_within_page)
            node->RemoveChildren();
          node->set_item(item);
        }
      }
      break;
    default:
      NOTREACHED() << ""Invalid commit type: "" << commit_type;
  }
}
","void HistoryController::UpdateForCommit(RenderFrameImpl* frame,
                                        const WebHistoryItem& item,
                                        WebHistoryCommitType commit_type,
                                        bool navigation_within_page) {
  switch (commit_type) {
     case blink::WebBackForwardCommit:
       if (!provisional_entry_)
         return;
      current_entry_.reset(provisional_entry_.release());
       if (HistoryEntry::HistoryNode* node =
               current_entry_->GetHistoryNodeForFrame(frame)) {
         node->set_item(item);
      }
      break;
    case blink::WebStandardCommit:
      CreateNewBackForwardItem(frame, item, navigation_within_page);
      break;
    case blink::WebInitialCommitInChildFrame:
      UpdateForInitialLoadInChildFrame(frame, item);
      break;
    case blink::WebHistoryInertCommit:
      if (current_entry_) {
        if (HistoryEntry::HistoryNode* node =
                current_entry_->GetHistoryNodeForFrame(frame)) {
          if (!navigation_within_page)
            node->RemoveChildren();
          node->set_item(item);
        }
      }
      break;
    default:
      NOTREACHED() << ""Invalid commit type: "" << commit_type;
  }
}
",C,"      // Commit the provisional entry, but only if this back/forward item
      // matches it.  Otherwise it could be a commit from an earlier attempt to
      // go back/forward, and we should leave the provisional entry in place.
      if (HistoryEntry::HistoryNode* node =
              provisional_entry_->GetHistoryNodeForFrame(frame)) {
        if (node->item().itemSequenceNumber() == item.itemSequenceNumber())
          current_entry_.reset(provisional_entry_.release());
      }
","      current_entry_.reset(provisional_entry_.release());
",,"@@ -187,7 +187,14 @@ void HistoryController::UpdateForCommit(RenderFrameImpl* frame,
     case blink::WebBackForwardCommit:
       if (!provisional_entry_)
         return;
-      current_entry_.reset(provisional_entry_.release());
+      // Commit the provisional entry, but only if this back/forward item
+      // matches it.  Otherwise it could be a commit from an earlier attempt to
+      // go back/forward, and we should leave the provisional entry in place.
+      if (HistoryEntry::HistoryNode* node =
+              provisional_entry_->GetHistoryNodeForFrame(frame)) {
+        if (node->item().itemSequenceNumber() == item.itemSequenceNumber())
+          current_entry_.reset(provisional_entry_.release());
+      }
       if (HistoryEntry::HistoryNode* node =
               current_entry_->GetHistoryNodeForFrame(frame)) {
         node->set_item(item);",Chrome,bb3548ef2fcdb58f9bc638bb5a3c379320fdd0e0,66605a610bce190e818ebfc73913a126c025ffb3,1,"void HistoryController::UpdateForCommit(RenderFrameImpl* frame,
                                        const WebHistoryItem& item,
                                        WebHistoryCommitType commit_type,
                                        bool navigation_within_page) {
  switch (commit_type) {
     case blink::WebBackForwardCommit:
       if (!provisional_entry_)
         return;
//flaw_line_below:
      current_entry_.reset(provisional_entry_.release());
//fix_flaw_line_below:
//      // Commit the provisional entry, but only if this back/forward item
//fix_flaw_line_below:
//      // matches it.  Otherwise it could be a commit from an earlier attempt to
//fix_flaw_line_below:
//      // go back/forward, and we should leave the provisional entry in place.
//fix_flaw_line_below:
//      if (HistoryEntry::HistoryNode* node =
//fix_flaw_line_below:
//              provisional_entry_->GetHistoryNodeForFrame(frame)) {
//fix_flaw_line_below:
//        if (node->item().itemSequenceNumber() == item.itemSequenceNumber())
//fix_flaw_line_below:
//          current_entry_.reset(provisional_entry_.release());
//fix_flaw_line_below:
//      }
       if (HistoryEntry::HistoryNode* node =
               current_entry_->GetHistoryNodeForFrame(frame)) {
         node->set_item(item);
      }
      break;
    case blink::WebStandardCommit:
      CreateNewBackForwardItem(frame, item, navigation_within_page);
      break;
    case blink::WebInitialCommitInChildFrame:
      UpdateForInitialLoadInChildFrame(frame, item);
      break;
    case blink::WebHistoryInertCommit:
      // Even for inert commits (e.g., location.replace, client redirects), make
      // sure the current entry gets updated, if there is one.
      if (current_entry_) {
        if (HistoryEntry::HistoryNode* node =
                current_entry_->GetHistoryNodeForFrame(frame)) {
          // Inert commits that reset the page without changing the item (e.g.,
          // reloads, location.replace) shouldn't keep the old subtree.
          if (!navigation_within_page)
            node->RemoveChildren();
          node->set_item(item);
        }
      }
      break;
    default:
      NOTREACHED() << ""Invalid commit type: "" << commit_type;
  }
}
"
8889,186625,,Remote,Not required,,CVE-2018-20067,https://www.cvedetails.com/cve/CVE-2018-20067/,CWE-254,Medium,,Partial,,2019-01-09,4.3,A renderer initiated back navigation was incorrectly allowed to cancel a browser initiated one in Navigation in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to confuse the user about the origin of the current page via a crafted HTML page.,2019-01-16,,4,https://github.com/chromium/chromium/commit/a7d715ae5b654d1f98669fd979a00282a7229044,a7d715ae5b654d1f98669fd979a00282a7229044,"Prevent renderer initiated back navigation to cancel a browser one.

Renderer initiated back/forward navigations must not be able to cancel ongoing
browser initiated navigation if they are not user initiated.

Note: 'normal' renderer initiated navigation uses the
FrameHost::BeginNavigation() path. A code similar to this patch is done
in NavigatorImpl::OnBeginNavigation().

Test:
-----

Added: NavigationBrowserTest.
 * HistoryBackInBeforeUnload
 * HistoryBackInBeforeUnloadAfterSetTimeout
 * HistoryBackCancelPendingNavigationNoUserGesture
 * HistoryBackCancelPendingNavigationUserGesture

Fixed:
 * (WPT) .../the-history-interface/traverse_the_history_2.html
 * (WPT) .../the-history-interface/traverse_the_history_3.html
 * (WPT) .../the-history-interface/traverse_the_history_4.html
 * (WPT) .../the-history-interface/traverse_the_history_5.html

Bug: 879965
Change-Id: I1a9bfaaea1ffc219e6c32f6e676b660e746c578c
Reviewed-on: https://chromium-review.googlesource.com/1209744
Commit-Queue: Arthur Sonzogni <arthursonzogni@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Mustaq Ahmed <mustaq@chromium.org>
Reviewed-by: Camille Lamy <clamy@chromium.org>
Reviewed-by: Charlie Reis <creis@chromium.org>
Cr-Commit-Position: refs/heads/master@{#592823}",1,content/renderer/render_view_impl.cc,"{""sha"": ""f1b34e92fe85da386228991fb2edb0fec9ce2561"", ""filename"": ""content/browser/frame_host/navigation_controller_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/content/browser/frame_host/navigation_controller_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/content/browser/frame_host/navigation_controller_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/navigation_controller_impl_unittest.cc?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -4498,7 +4498,7 @@ TEST_F(NavigationControllerTest, HistoryNavigate) {\n   process()->sink().ClearMessages();\n \n   // Simulate the page calling history.back(). It should create a pending entry.\n-  contents()->OnGoToEntryAtOffset(test_rvh(), -1);\n+  contents()->OnGoToEntryAtOffset(test_rvh(), -1, false);\n   EXPECT_EQ(0, controller.GetPendingEntryIndex());\n \n   // Also make sure we told the page to navigate.\n@@ -4508,7 +4508,7 @@ TEST_F(NavigationControllerTest, HistoryNavigate) {\n   process()->sink().ClearMessages();\n \n   // Now test history.forward()\n-  contents()->OnGoToEntryAtOffset(test_rvh(), 2);\n+  contents()->OnGoToEntryAtOffset(test_rvh(), 2, false);\n   EXPECT_EQ(2, controller.GetPendingEntryIndex());\n \n   nav_url = GetLastNavigationURL();\n@@ -4519,7 +4519,7 @@ TEST_F(NavigationControllerTest, HistoryNavigate) {\n   controller.DiscardNonCommittedEntries();\n \n   // Make sure an extravagant history.go() doesn't break.\n-  contents()->OnGoToEntryAtOffset(test_rvh(), 120);  // Out of bounds.\n+  contents()->OnGoToEntryAtOffset(test_rvh(), 120, false);  // Out of bounds.\n   EXPECT_EQ(-1, controller.GetPendingEntryIndex());\n   EXPECT_FALSE(HasNavigationRequest());\n }""}<_**next**_>{""sha"": ""c101d5f2e049534e55614411f716c3f514aa81f8"", ""filename"": ""content/browser/navigation_browsertest.cc"", ""status"": ""modified"", ""additions"": 116, ""deletions"": 0, ""changes"": 116, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/content/browser/navigation_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/content/browser/navigation_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/navigation_browsertest.cc?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -17,7 +17,9 @@\n #include \""content/browser/loader/resource_dispatcher_host_impl.h\""\n #include \""content/browser/web_contents/web_contents_impl.h\""\n #include \""content/common/frame_messages.h\""\n+#include \""content/common/view_messages.h\""\n #include \""content/public/browser/browser_context.h\""\n+#include \""content/public/browser/browser_message_filter.h\""\n #include \""content/public/browser/browser_task_traits.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/download_manager_delegate.h\""\n@@ -138,6 +140,29 @@ class NavigationRecorder : public WebContentsObserver {\n   std::vector<std::string> records_;\n };\n \n+// Used to wait for an observed IPC to be received.\n+class BrowserMessageObserver : public content::BrowserMessageFilter {\n+ public:\n+  BrowserMessageObserver(uint32_t observed_message_class,\n+                         uint32_t observed_message_type)\n+      : content::BrowserMessageFilter(observed_message_class),\n+        observed_message_type_(observed_message_type) {}\n+\n+  bool OnMessageReceived(const IPC::Message& message) override {\n+    if (message.type() == observed_message_type_)\n+      loop.Quit();\n+    return false;\n+  }\n+\n+  void Wait() { loop.Run(); }\n+\n+ private:\n+  ~BrowserMessageObserver() override {}\n+  uint32_t observed_message_type_;\n+  base::RunLoop loop;\n+  DISALLOW_COPY_AND_ASSIGN(BrowserMessageObserver);\n+};\n+\n }  // namespace\n \n // Test about navigation.\n@@ -1102,4 +1127,95 @@ IN_PROC_BROWSER_TEST_F(NavigationBrowserTest,\n                recorder.records()[5].c_str());\n }\n \n+// Renderer initiated back/forward navigation in beforeunload should not prevent\n+// the user to navigate away from a website.\n+IN_PROC_BROWSER_TEST_F(NavigationBrowserTest, HistoryBackInBeforeUnload) {\n+  GURL url_1(embedded_test_server()->GetURL(\""/title1.html\""));\n+  GURL url_2(embedded_test_server()->GetURL(\""/title2.html\""));\n+\n+  EXPECT_TRUE(NavigateToURL(shell(), url_1));\n+  EXPECT_TRUE(ExecuteScript(shell()->web_contents(),\n+                            \""onbeforeunload = function() {\""\n+                            \""  history.pushState({}, null, '/');\""\n+                            \""  history.back();\""\n+                            \""};\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), url_2));\n+}\n+\n+// Same as 'HistoryBackInBeforeUnload', but wraps history.back() inside\n+// window.setTimeout(). Thus it is executed \""outside\"" of its beforeunload\n+// handler and thus avoid basic navigation circumventions.\n+// Regression test for: https://crbug.com/879965.\n+IN_PROC_BROWSER_TEST_F(NavigationBrowserTest,\n+                       HistoryBackInBeforeUnloadAfterSetTimeout) {\n+  GURL url_1(embedded_test_server()->GetURL(\""/title1.html\""));\n+  GURL url_2(embedded_test_server()->GetURL(\""/title2.html\""));\n+\n+  EXPECT_TRUE(NavigateToURL(shell(), url_1));\n+  EXPECT_TRUE(ExecuteScript(shell()->web_contents(),\n+                            \""onbeforeunload = function() {\""\n+                            \""  history.pushState({}, null, '/');\""\n+                            \""  setTimeout(()=>history.back());\""\n+                            \""};\""));\n+  TestNavigationManager navigation(shell()->web_contents(), url_2);\n+  auto ipc_observer = base::MakeRefCounted<BrowserMessageObserver>(\n+      ViewMsgStart, ViewHostMsg_GoToEntryAtOffset::ID);\n+  static_cast<RenderFrameHostImpl*>(shell()->web_contents()->GetMainFrame())\n+      ->GetProcess()\n+      ->AddFilter(ipc_observer.get());\n+\n+  shell()->LoadURL(url_2);\n+  ipc_observer->Wait();\n+  navigation.WaitForNavigationFinished();\n+\n+  EXPECT_TRUE(navigation.was_successful());\n+}\n+\n+// Renderer initiated back/forward navigation can't cancel an ongoing browser\n+// initiated navigation if it is not user initiated.\n+IN_PROC_BROWSER_TEST_F(NavigationBrowserTest,\n+                       HistoryBackCancelPendingNavigationNoUserGesture) {\n+  GURL url_1(embedded_test_server()->GetURL(\""/title1.html\""));\n+  GURL url_2(embedded_test_server()->GetURL(\""/title2.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), url_1));\n+\n+  // 1) A pending browser initiated navigation (omnibox, ...) starts.\n+  TestNavigationManager navigation(shell()->web_contents(), url_2);\n+  shell()->LoadURL(url_2);\n+  EXPECT_TRUE(navigation.WaitForRequestStart());\n+\n+  // 2) history.back() is sent but is not user initiated.\n+  EXPECT_TRUE(\n+      ExecuteScriptWithoutUserGesture(shell()->web_contents(),\n+                                      \""history.pushState({}, null, '/');\""\n+                                      \""history.back();\""));\n+\n+  // 3) The first pending navigation is not canceled and can continue.\n+  navigation.WaitForNavigationFinished();  // Resume navigation.\n+  EXPECT_TRUE(navigation.was_successful());\n+}\n+\n+// Renderer initiated back/forward navigation can cancel an ongoing browser\n+// initiated navigation if it is user initiated.\n+IN_PROC_BROWSER_TEST_F(NavigationBrowserTest,\n+                       HistoryBackCancelPendingNavigationUserGesture) {\n+  GURL url_1(embedded_test_server()->GetURL(\""/title1.html\""));\n+  GURL url_2(embedded_test_server()->GetURL(\""/title2.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), url_1));\n+\n+  // 1) A pending browser initiated navigation (omnibox, ...) starts.\n+  TestNavigationManager navigation(shell()->web_contents(), url_2);\n+  shell()->LoadURL(url_2);\n+  EXPECT_TRUE(navigation.WaitForRequestStart());\n+\n+  // 2) history.back() is sent and is user initiated.\n+  EXPECT_TRUE(ExecuteScript(shell()->web_contents(),\n+                            \""history.pushState({}, null, '/');\""\n+                            \""history.back();\""));\n+\n+  // 3) Check the first pending navigation has been canceled.\n+  navigation.WaitForNavigationFinished();  // Resume navigation.\n+  EXPECT_FALSE(navigation.was_successful());\n+}\n+\n }  // namespace content""}<_**next**_>{""sha"": ""f8de134d26963c366a16a289601ced893d1e1c5b"", ""filename"": ""content/browser/web_contents/web_contents_impl.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 1, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/content/browser/web_contents/web_contents_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/content/browser/web_contents/web_contents_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/web_contents/web_contents_impl.cc?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -4518,7 +4518,23 @@ void WebContentsImpl::OnDidFinishLoad(RenderFrameHostImpl* source,\n }\n \n void WebContentsImpl::OnGoToEntryAtOffset(RenderViewHostImpl* source,\n-                                          int offset) {\n+                                          int offset,\n+                                          bool has_user_gesture) {\n+  // Non-user initiated navigations coming from the renderer should be ignored\n+  // if there is an ongoing browser-initiated navigation.\n+  // See https://crbug.com/879965.\n+  // TODO(arthursonzogni): See if this should check for ongoing navigations in\n+  // the frame(s) affected by the session history navigation, rather than just\n+  // the main frame.\n+  if (!has_user_gesture) {\n+    NavigationRequest* ongoing_navigation_request =\n+        frame_tree_.root()->navigation_request();\n+    if (ongoing_navigation_request &&\n+        ongoing_navigation_request->browser_initiated()) {\n+      return;\n+    }\n+  }\n+\n   // All frames are allowed to navigate the global history.\n   if (!delegate_ || delegate_->OnGoToEntryOffset(offset))\n     controller_.GoToOffset(offset);""}<_**next**_>{""sha"": ""f0cec7f1377efa43a5c31ed5d6dbaa2cbbac10b1"", ""filename"": ""content/browser/web_contents/web_contents_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/content/browser/web_contents/web_contents_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/content/browser/web_contents/web_contents_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/web_contents/web_contents_impl.h?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -1191,7 +1191,9 @@ class CONTENT_EXPORT WebContentsImpl : public WebContents,\n   void OnDidRunContentWithCertificateErrors(RenderFrameHostImpl* source);\n   void OnDocumentLoadedInFrame(RenderFrameHostImpl* source);\n   void OnDidFinishLoad(RenderFrameHostImpl* source, const GURL& url);\n-  void OnGoToEntryAtOffset(RenderViewHostImpl* source, int offset);\n+  void OnGoToEntryAtOffset(RenderViewHostImpl* source,\n+                           int offset,\n+                           bool has_user_gesture);\n   void OnUpdateZoomLimits(RenderViewHostImpl* source,\n                           int minimum_percent,\n                           int maximum_percent);""}<_**next**_>{""sha"": ""2de8e708fea291449754b68384f70a834a5dc2e8"", ""filename"": ""content/common/view_messages.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/content/common/view_messages.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/content/common/view_messages.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/view_messages.h?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -498,8 +498,9 @@ IPC_MESSAGE_ROUTED2(ViewHostMsg_AppCacheAccessed,\n \n // Used to go to the session history entry at the given offset (ie, -1 will\n // return the \""back\"" item).\n-IPC_MESSAGE_ROUTED1(ViewHostMsg_GoToEntryAtOffset,\n-                    int /* offset (from current) of history item to get */)\n+IPC_MESSAGE_ROUTED2(ViewHostMsg_GoToEntryAtOffset,\n+                    int /* offset (from current) of history item to get */,\n+                    bool /* has_user_gesture */)\n \n // Sent from an inactive renderer for the browser to route to the active\n // renderer, instructing it to close.""}<_**next**_>{""sha"": ""6dcebb87823fa8cc1d53078e97b0c1e0b393daeb"", ""filename"": ""content/renderer/render_view_impl.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/content/renderer/render_view_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/content/renderer/render_view_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_view_impl.cc?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -1722,15 +1722,17 @@ void RenderViewImpl::DidUpdateMainFrameLayout() {\n   needs_preferred_size_update_ = true;\n }\n \n-void RenderViewImpl::NavigateBackForwardSoon(int offset) {\n+void RenderViewImpl::NavigateBackForwardSoon(int offset,\n+                                             bool has_user_gesture) {\n   history_navigation_virtual_time_pauser_ =\n       RenderThreadImpl::current()\n           ->GetWebMainThreadScheduler()\n           ->CreateWebScopedVirtualTimePauser(\n               \""NavigateBackForwardSoon\"",\n               blink::WebScopedVirtualTimePauser::VirtualTaskDuration::kInstant);\n   history_navigation_virtual_time_pauser_.PauseVirtualTime();\n-  Send(new ViewHostMsg_GoToEntryAtOffset(GetRoutingID(), offset));\n+  Send(new ViewHostMsg_GoToEntryAtOffset(GetRoutingID(), offset,\n+                                         has_user_gesture));\n }\n \n void RenderViewImpl::DidCommitProvisionalHistoryLoad() {""}<_**next**_>{""sha"": ""cd13b43995c43c40c91333ebeb3a59da387c63be"", ""filename"": ""content/renderer/render_view_impl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/content/renderer/render_view_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/content/renderer/render_view_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_view_impl.h?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -234,7 +234,7 @@ class CONTENT_EXPORT RenderViewImpl : private RenderWidget,\n   bool CanUpdateLayout() override;\n   void DidUpdateMainFrameLayout() override;\n   blink::WebString AcceptLanguages() override;\n-  void NavigateBackForwardSoon(int offset) override;\n+  void NavigateBackForwardSoon(int offset, bool has_user_gesture) override;\n   int HistoryBackListCount() override;\n   int HistoryForwardListCount() override;\n   void ZoomLimitsChanged(double minimum_level, double maximum_level) override;""}<_**next**_>{""sha"": ""4cc1bc9d0779b0dc2a502bfa4fe6c79a6f0e0d8e"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_2-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/96a4668d39b28f933b44801b594aa91cdd32f87b/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_2-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/96a4668d39b28f933b44801b594aa91cdd32f87b/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_2-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_2-expected.txt?ref=96a4668d39b28f933b44801b594aa91cdd32f87b"", ""patch"": ""@@ -1,4 +0,0 @@\n-This is a testharness.js-based test.\n-FAIL Multiple history traversals, last would be aborted assert_array_equals: Pages opened during history navigation property 1, expected 3 but got 1\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""4cc1bc9d0779b0dc2a502bfa4fe6c79a6f0e0d8e"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_3-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/96a4668d39b28f933b44801b594aa91cdd32f87b/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_3-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/96a4668d39b28f933b44801b594aa91cdd32f87b/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_3-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_3-expected.txt?ref=96a4668d39b28f933b44801b594aa91cdd32f87b"", ""patch"": ""@@ -1,4 +0,0 @@\n-This is a testharness.js-based test.\n-FAIL Multiple history traversals, last would be aborted assert_array_equals: Pages opened during history navigation property 1, expected 3 but got 1\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""d8e3e002d4ad0ad41dca696d9656a1b326fe30a4"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_4-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/96a4668d39b28f933b44801b594aa91cdd32f87b/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_4-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/96a4668d39b28f933b44801b594aa91cdd32f87b/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_4-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_4-expected.txt?ref=96a4668d39b28f933b44801b594aa91cdd32f87b"", ""patch"": ""@@ -1,4 +0,0 @@\n-This is a testharness.js-based test.\n-FAIL Multiple history traversals, last would be aborted assert_array_equals: Pages opened during history navigation property 1, expected 5 but got 3\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""d8e3e002d4ad0ad41dca696d9656a1b326fe30a4"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_5-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/96a4668d39b28f933b44801b594aa91cdd32f87b/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_5-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/96a4668d39b28f933b44801b594aa91cdd32f87b/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_5-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_5-expected.txt?ref=96a4668d39b28f933b44801b594aa91cdd32f87b"", ""patch"": ""@@ -1,4 +0,0 @@\n-This is a testharness.js-based test.\n-FAIL Multiple history traversals, last would be aborted assert_array_equals: Pages opened during history navigation property 1, expected 5 but got 3\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""27d49895a54819f0b21b322b3261666a70eba7d7"", ""filename"": ""third_party/blink/public/web/web_view_client.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/third_party/blink/public/web/web_view_client.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/third_party/blink/public/web/web_view_client.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/web/web_view_client.h?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -173,8 +173,9 @@ class WebViewClient {\n \n   // Tells the embedder to navigate back or forward in session history by\n   // the given offset (relative to the current position in session\n-  // history).\n-  virtual void NavigateBackForwardSoon(int offset) {}\n+  // history). |has_user_gesture| tells whether or not this is the consequence\n+  // of a user action.\n+  virtual void NavigateBackForwardSoon(int offset, bool has_user_gesture) {}\n \n   // Returns the number of history items before/after the current\n   // history item.""}<_**next**_>{""sha"": ""c89e0280a085c4bf4bc53d15a5f2d60e919c3ed5"", ""filename"": ""third_party/blink/renderer/core/exported/local_frame_client_impl.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/third_party/blink/renderer/core/exported/local_frame_client_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/third_party/blink/renderer/core/exported/local_frame_client_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/exported/local_frame_client_impl.cc?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -71,6 +71,7 @@\n #include \""third_party/blink/renderer/core/exported/web_plugin_container_impl.h\""\n #include \""third_party/blink/renderer/core/exported/web_view_impl.h\""\n #include \""third_party/blink/renderer/core/fileapi/public_url_manager.h\""\n+#include \""third_party/blink/renderer/core/frame/frame.h\""\n #include \""third_party/blink/renderer/core/frame/local_frame_view.h\""\n #include \""third_party/blink/renderer/core/frame/settings.h\""\n #include \""third_party/blink/renderer/core/frame/web_local_frame_impl.h\""\n@@ -667,7 +668,10 @@ bool LocalFrameClientImpl::NavigateBackForward(int offset) const {\n     return false;\n   if (offset < -webview->Client()->HistoryBackListCount())\n     return false;\n-  webview->Client()->NavigateBackForwardSoon(offset);\n+\n+  bool has_user_gesture =\n+      Frame::HasTransientUserActivation(web_frame_->GetFrame());\n+  webview->Client()->NavigateBackForwardSoon(offset, has_user_gesture);\n   return true;\n }\n ""}","void RenderViewImpl::NavigateBackForwardSoon(int offset) {
void RenderViewImpl::NavigateBackForwardSoon(int offset,
                                             bool has_user_gesture) {
   history_navigation_virtual_time_pauser_ =
       RenderThreadImpl::current()
           ->GetWebMainThreadScheduler()
           ->CreateWebScopedVirtualTimePauser(
               ""NavigateBackForwardSoon"",
               blink::WebScopedVirtualTimePauser::VirtualTaskDuration::kInstant);
   history_navigation_virtual_time_pauser_.PauseVirtualTime();
  Send(new ViewHostMsg_GoToEntryAtOffset(GetRoutingID(), offset,
                                         has_user_gesture));
 }
","void RenderViewImpl::NavigateBackForwardSoon(int offset) {
   history_navigation_virtual_time_pauser_ =
       RenderThreadImpl::current()
           ->GetWebMainThreadScheduler()
           ->CreateWebScopedVirtualTimePauser(
               ""NavigateBackForwardSoon"",
               blink::WebScopedVirtualTimePauser::VirtualTaskDuration::kInstant);
   history_navigation_virtual_time_pauser_.PauseVirtualTime();
  Send(new ViewHostMsg_GoToEntryAtOffset(GetRoutingID(), offset));
 }
",C,"void RenderViewImpl::NavigateBackForwardSoon(int offset,
                                             bool has_user_gesture) {
  Send(new ViewHostMsg_GoToEntryAtOffset(GetRoutingID(), offset,
                                         has_user_gesture));
","  Send(new ViewHostMsg_GoToEntryAtOffset(GetRoutingID(), offset));
",,"@@ -1722,15 +1722,17 @@ void RenderViewImpl::DidUpdateMainFrameLayout() {
   needs_preferred_size_update_ = true;
 }
 
-void RenderViewImpl::NavigateBackForwardSoon(int offset) {
+void RenderViewImpl::NavigateBackForwardSoon(int offset,
+                                             bool has_user_gesture) {
   history_navigation_virtual_time_pauser_ =
       RenderThreadImpl::current()
           ->GetWebMainThreadScheduler()
           ->CreateWebScopedVirtualTimePauser(
               ""NavigateBackForwardSoon"",
               blink::WebScopedVirtualTimePauser::VirtualTaskDuration::kInstant);
   history_navigation_virtual_time_pauser_.PauseVirtualTime();
-  Send(new ViewHostMsg_GoToEntryAtOffset(GetRoutingID(), offset));
+  Send(new ViewHostMsg_GoToEntryAtOffset(GetRoutingID(), offset,
+                                         has_user_gesture));
 }
 
 void RenderViewImpl::DidCommitProvisionalHistoryLoad() {",Chrome,a7d715ae5b654d1f98669fd979a00282a7229044,96a4668d39b28f933b44801b594aa91cdd32f87b,1,"void RenderViewImpl::NavigateBackForwardSoon(int offset) {
//fix_flaw_line_below:
//void RenderViewImpl::NavigateBackForwardSoon(int offset,
//fix_flaw_line_below:
//                                             bool has_user_gesture) {
   history_navigation_virtual_time_pauser_ =
       RenderThreadImpl::current()
           ->GetWebMainThreadScheduler()
           ->CreateWebScopedVirtualTimePauser(
               ""NavigateBackForwardSoon"",
               blink::WebScopedVirtualTimePauser::VirtualTaskDuration::kInstant);
   history_navigation_virtual_time_pauser_.PauseVirtualTime();
//flaw_line_below:
  Send(new ViewHostMsg_GoToEntryAtOffset(GetRoutingID(), offset));
//fix_flaw_line_below:
//  Send(new ViewHostMsg_GoToEntryAtOffset(GetRoutingID(), offset,
//fix_flaw_line_below:
//                                         has_user_gesture));
 }
"
8890,186626,,Remote,Not required,,CVE-2018-20067,https://www.cvedetails.com/cve/CVE-2018-20067/,CWE-254,Medium,,Partial,,2019-01-09,4.3,A renderer initiated back navigation was incorrectly allowed to cancel a browser initiated one in Navigation in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to confuse the user about the origin of the current page via a crafted HTML page.,2019-01-16,,4,https://github.com/chromium/chromium/commit/a7d715ae5b654d1f98669fd979a00282a7229044,a7d715ae5b654d1f98669fd979a00282a7229044,"Prevent renderer initiated back navigation to cancel a browser one.

Renderer initiated back/forward navigations must not be able to cancel ongoing
browser initiated navigation if they are not user initiated.

Note: 'normal' renderer initiated navigation uses the
FrameHost::BeginNavigation() path. A code similar to this patch is done
in NavigatorImpl::OnBeginNavigation().

Test:
-----

Added: NavigationBrowserTest.
 * HistoryBackInBeforeUnload
 * HistoryBackInBeforeUnloadAfterSetTimeout
 * HistoryBackCancelPendingNavigationNoUserGesture
 * HistoryBackCancelPendingNavigationUserGesture

Fixed:
 * (WPT) .../the-history-interface/traverse_the_history_2.html
 * (WPT) .../the-history-interface/traverse_the_history_3.html
 * (WPT) .../the-history-interface/traverse_the_history_4.html
 * (WPT) .../the-history-interface/traverse_the_history_5.html

Bug: 879965
Change-Id: I1a9bfaaea1ffc219e6c32f6e676b660e746c578c
Reviewed-on: https://chromium-review.googlesource.com/1209744
Commit-Queue: Arthur Sonzogni <arthursonzogni@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Mustaq Ahmed <mustaq@chromium.org>
Reviewed-by: Camille Lamy <clamy@chromium.org>
Reviewed-by: Charlie Reis <creis@chromium.org>
Cr-Commit-Position: refs/heads/master@{#592823}",1,third_party/blink/renderer/core/exported/local_frame_client_impl.cc,"{""sha"": ""f1b34e92fe85da386228991fb2edb0fec9ce2561"", ""filename"": ""content/browser/frame_host/navigation_controller_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/content/browser/frame_host/navigation_controller_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/content/browser/frame_host/navigation_controller_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/navigation_controller_impl_unittest.cc?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -4498,7 +4498,7 @@ TEST_F(NavigationControllerTest, HistoryNavigate) {\n   process()->sink().ClearMessages();\n \n   // Simulate the page calling history.back(). It should create a pending entry.\n-  contents()->OnGoToEntryAtOffset(test_rvh(), -1);\n+  contents()->OnGoToEntryAtOffset(test_rvh(), -1, false);\n   EXPECT_EQ(0, controller.GetPendingEntryIndex());\n \n   // Also make sure we told the page to navigate.\n@@ -4508,7 +4508,7 @@ TEST_F(NavigationControllerTest, HistoryNavigate) {\n   process()->sink().ClearMessages();\n \n   // Now test history.forward()\n-  contents()->OnGoToEntryAtOffset(test_rvh(), 2);\n+  contents()->OnGoToEntryAtOffset(test_rvh(), 2, false);\n   EXPECT_EQ(2, controller.GetPendingEntryIndex());\n \n   nav_url = GetLastNavigationURL();\n@@ -4519,7 +4519,7 @@ TEST_F(NavigationControllerTest, HistoryNavigate) {\n   controller.DiscardNonCommittedEntries();\n \n   // Make sure an extravagant history.go() doesn't break.\n-  contents()->OnGoToEntryAtOffset(test_rvh(), 120);  // Out of bounds.\n+  contents()->OnGoToEntryAtOffset(test_rvh(), 120, false);  // Out of bounds.\n   EXPECT_EQ(-1, controller.GetPendingEntryIndex());\n   EXPECT_FALSE(HasNavigationRequest());\n }""}<_**next**_>{""sha"": ""c101d5f2e049534e55614411f716c3f514aa81f8"", ""filename"": ""content/browser/navigation_browsertest.cc"", ""status"": ""modified"", ""additions"": 116, ""deletions"": 0, ""changes"": 116, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/content/browser/navigation_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/content/browser/navigation_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/navigation_browsertest.cc?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -17,7 +17,9 @@\n #include \""content/browser/loader/resource_dispatcher_host_impl.h\""\n #include \""content/browser/web_contents/web_contents_impl.h\""\n #include \""content/common/frame_messages.h\""\n+#include \""content/common/view_messages.h\""\n #include \""content/public/browser/browser_context.h\""\n+#include \""content/public/browser/browser_message_filter.h\""\n #include \""content/public/browser/browser_task_traits.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/download_manager_delegate.h\""\n@@ -138,6 +140,29 @@ class NavigationRecorder : public WebContentsObserver {\n   std::vector<std::string> records_;\n };\n \n+// Used to wait for an observed IPC to be received.\n+class BrowserMessageObserver : public content::BrowserMessageFilter {\n+ public:\n+  BrowserMessageObserver(uint32_t observed_message_class,\n+                         uint32_t observed_message_type)\n+      : content::BrowserMessageFilter(observed_message_class),\n+        observed_message_type_(observed_message_type) {}\n+\n+  bool OnMessageReceived(const IPC::Message& message) override {\n+    if (message.type() == observed_message_type_)\n+      loop.Quit();\n+    return false;\n+  }\n+\n+  void Wait() { loop.Run(); }\n+\n+ private:\n+  ~BrowserMessageObserver() override {}\n+  uint32_t observed_message_type_;\n+  base::RunLoop loop;\n+  DISALLOW_COPY_AND_ASSIGN(BrowserMessageObserver);\n+};\n+\n }  // namespace\n \n // Test about navigation.\n@@ -1102,4 +1127,95 @@ IN_PROC_BROWSER_TEST_F(NavigationBrowserTest,\n                recorder.records()[5].c_str());\n }\n \n+// Renderer initiated back/forward navigation in beforeunload should not prevent\n+// the user to navigate away from a website.\n+IN_PROC_BROWSER_TEST_F(NavigationBrowserTest, HistoryBackInBeforeUnload) {\n+  GURL url_1(embedded_test_server()->GetURL(\""/title1.html\""));\n+  GURL url_2(embedded_test_server()->GetURL(\""/title2.html\""));\n+\n+  EXPECT_TRUE(NavigateToURL(shell(), url_1));\n+  EXPECT_TRUE(ExecuteScript(shell()->web_contents(),\n+                            \""onbeforeunload = function() {\""\n+                            \""  history.pushState({}, null, '/');\""\n+                            \""  history.back();\""\n+                            \""};\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), url_2));\n+}\n+\n+// Same as 'HistoryBackInBeforeUnload', but wraps history.back() inside\n+// window.setTimeout(). Thus it is executed \""outside\"" of its beforeunload\n+// handler and thus avoid basic navigation circumventions.\n+// Regression test for: https://crbug.com/879965.\n+IN_PROC_BROWSER_TEST_F(NavigationBrowserTest,\n+                       HistoryBackInBeforeUnloadAfterSetTimeout) {\n+  GURL url_1(embedded_test_server()->GetURL(\""/title1.html\""));\n+  GURL url_2(embedded_test_server()->GetURL(\""/title2.html\""));\n+\n+  EXPECT_TRUE(NavigateToURL(shell(), url_1));\n+  EXPECT_TRUE(ExecuteScript(shell()->web_contents(),\n+                            \""onbeforeunload = function() {\""\n+                            \""  history.pushState({}, null, '/');\""\n+                            \""  setTimeout(()=>history.back());\""\n+                            \""};\""));\n+  TestNavigationManager navigation(shell()->web_contents(), url_2);\n+  auto ipc_observer = base::MakeRefCounted<BrowserMessageObserver>(\n+      ViewMsgStart, ViewHostMsg_GoToEntryAtOffset::ID);\n+  static_cast<RenderFrameHostImpl*>(shell()->web_contents()->GetMainFrame())\n+      ->GetProcess()\n+      ->AddFilter(ipc_observer.get());\n+\n+  shell()->LoadURL(url_2);\n+  ipc_observer->Wait();\n+  navigation.WaitForNavigationFinished();\n+\n+  EXPECT_TRUE(navigation.was_successful());\n+}\n+\n+// Renderer initiated back/forward navigation can't cancel an ongoing browser\n+// initiated navigation if it is not user initiated.\n+IN_PROC_BROWSER_TEST_F(NavigationBrowserTest,\n+                       HistoryBackCancelPendingNavigationNoUserGesture) {\n+  GURL url_1(embedded_test_server()->GetURL(\""/title1.html\""));\n+  GURL url_2(embedded_test_server()->GetURL(\""/title2.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), url_1));\n+\n+  // 1) A pending browser initiated navigation (omnibox, ...) starts.\n+  TestNavigationManager navigation(shell()->web_contents(), url_2);\n+  shell()->LoadURL(url_2);\n+  EXPECT_TRUE(navigation.WaitForRequestStart());\n+\n+  // 2) history.back() is sent but is not user initiated.\n+  EXPECT_TRUE(\n+      ExecuteScriptWithoutUserGesture(shell()->web_contents(),\n+                                      \""history.pushState({}, null, '/');\""\n+                                      \""history.back();\""));\n+\n+  // 3) The first pending navigation is not canceled and can continue.\n+  navigation.WaitForNavigationFinished();  // Resume navigation.\n+  EXPECT_TRUE(navigation.was_successful());\n+}\n+\n+// Renderer initiated back/forward navigation can cancel an ongoing browser\n+// initiated navigation if it is user initiated.\n+IN_PROC_BROWSER_TEST_F(NavigationBrowserTest,\n+                       HistoryBackCancelPendingNavigationUserGesture) {\n+  GURL url_1(embedded_test_server()->GetURL(\""/title1.html\""));\n+  GURL url_2(embedded_test_server()->GetURL(\""/title2.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), url_1));\n+\n+  // 1) A pending browser initiated navigation (omnibox, ...) starts.\n+  TestNavigationManager navigation(shell()->web_contents(), url_2);\n+  shell()->LoadURL(url_2);\n+  EXPECT_TRUE(navigation.WaitForRequestStart());\n+\n+  // 2) history.back() is sent and is user initiated.\n+  EXPECT_TRUE(ExecuteScript(shell()->web_contents(),\n+                            \""history.pushState({}, null, '/');\""\n+                            \""history.back();\""));\n+\n+  // 3) Check the first pending navigation has been canceled.\n+  navigation.WaitForNavigationFinished();  // Resume navigation.\n+  EXPECT_FALSE(navigation.was_successful());\n+}\n+\n }  // namespace content""}<_**next**_>{""sha"": ""f8de134d26963c366a16a289601ced893d1e1c5b"", ""filename"": ""content/browser/web_contents/web_contents_impl.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 1, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/content/browser/web_contents/web_contents_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/content/browser/web_contents/web_contents_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/web_contents/web_contents_impl.cc?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -4518,7 +4518,23 @@ void WebContentsImpl::OnDidFinishLoad(RenderFrameHostImpl* source,\n }\n \n void WebContentsImpl::OnGoToEntryAtOffset(RenderViewHostImpl* source,\n-                                          int offset) {\n+                                          int offset,\n+                                          bool has_user_gesture) {\n+  // Non-user initiated navigations coming from the renderer should be ignored\n+  // if there is an ongoing browser-initiated navigation.\n+  // See https://crbug.com/879965.\n+  // TODO(arthursonzogni): See if this should check for ongoing navigations in\n+  // the frame(s) affected by the session history navigation, rather than just\n+  // the main frame.\n+  if (!has_user_gesture) {\n+    NavigationRequest* ongoing_navigation_request =\n+        frame_tree_.root()->navigation_request();\n+    if (ongoing_navigation_request &&\n+        ongoing_navigation_request->browser_initiated()) {\n+      return;\n+    }\n+  }\n+\n   // All frames are allowed to navigate the global history.\n   if (!delegate_ || delegate_->OnGoToEntryOffset(offset))\n     controller_.GoToOffset(offset);""}<_**next**_>{""sha"": ""f0cec7f1377efa43a5c31ed5d6dbaa2cbbac10b1"", ""filename"": ""content/browser/web_contents/web_contents_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/content/browser/web_contents/web_contents_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/content/browser/web_contents/web_contents_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/web_contents/web_contents_impl.h?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -1191,7 +1191,9 @@ class CONTENT_EXPORT WebContentsImpl : public WebContents,\n   void OnDidRunContentWithCertificateErrors(RenderFrameHostImpl* source);\n   void OnDocumentLoadedInFrame(RenderFrameHostImpl* source);\n   void OnDidFinishLoad(RenderFrameHostImpl* source, const GURL& url);\n-  void OnGoToEntryAtOffset(RenderViewHostImpl* source, int offset);\n+  void OnGoToEntryAtOffset(RenderViewHostImpl* source,\n+                           int offset,\n+                           bool has_user_gesture);\n   void OnUpdateZoomLimits(RenderViewHostImpl* source,\n                           int minimum_percent,\n                           int maximum_percent);""}<_**next**_>{""sha"": ""2de8e708fea291449754b68384f70a834a5dc2e8"", ""filename"": ""content/common/view_messages.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/content/common/view_messages.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/content/common/view_messages.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/view_messages.h?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -498,8 +498,9 @@ IPC_MESSAGE_ROUTED2(ViewHostMsg_AppCacheAccessed,\n \n // Used to go to the session history entry at the given offset (ie, -1 will\n // return the \""back\"" item).\n-IPC_MESSAGE_ROUTED1(ViewHostMsg_GoToEntryAtOffset,\n-                    int /* offset (from current) of history item to get */)\n+IPC_MESSAGE_ROUTED2(ViewHostMsg_GoToEntryAtOffset,\n+                    int /* offset (from current) of history item to get */,\n+                    bool /* has_user_gesture */)\n \n // Sent from an inactive renderer for the browser to route to the active\n // renderer, instructing it to close.""}<_**next**_>{""sha"": ""6dcebb87823fa8cc1d53078e97b0c1e0b393daeb"", ""filename"": ""content/renderer/render_view_impl.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/content/renderer/render_view_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/content/renderer/render_view_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_view_impl.cc?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -1722,15 +1722,17 @@ void RenderViewImpl::DidUpdateMainFrameLayout() {\n   needs_preferred_size_update_ = true;\n }\n \n-void RenderViewImpl::NavigateBackForwardSoon(int offset) {\n+void RenderViewImpl::NavigateBackForwardSoon(int offset,\n+                                             bool has_user_gesture) {\n   history_navigation_virtual_time_pauser_ =\n       RenderThreadImpl::current()\n           ->GetWebMainThreadScheduler()\n           ->CreateWebScopedVirtualTimePauser(\n               \""NavigateBackForwardSoon\"",\n               blink::WebScopedVirtualTimePauser::VirtualTaskDuration::kInstant);\n   history_navigation_virtual_time_pauser_.PauseVirtualTime();\n-  Send(new ViewHostMsg_GoToEntryAtOffset(GetRoutingID(), offset));\n+  Send(new ViewHostMsg_GoToEntryAtOffset(GetRoutingID(), offset,\n+                                         has_user_gesture));\n }\n \n void RenderViewImpl::DidCommitProvisionalHistoryLoad() {""}<_**next**_>{""sha"": ""cd13b43995c43c40c91333ebeb3a59da387c63be"", ""filename"": ""content/renderer/render_view_impl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/content/renderer/render_view_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/content/renderer/render_view_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_view_impl.h?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -234,7 +234,7 @@ class CONTENT_EXPORT RenderViewImpl : private RenderWidget,\n   bool CanUpdateLayout() override;\n   void DidUpdateMainFrameLayout() override;\n   blink::WebString AcceptLanguages() override;\n-  void NavigateBackForwardSoon(int offset) override;\n+  void NavigateBackForwardSoon(int offset, bool has_user_gesture) override;\n   int HistoryBackListCount() override;\n   int HistoryForwardListCount() override;\n   void ZoomLimitsChanged(double minimum_level, double maximum_level) override;""}<_**next**_>{""sha"": ""4cc1bc9d0779b0dc2a502bfa4fe6c79a6f0e0d8e"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_2-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/96a4668d39b28f933b44801b594aa91cdd32f87b/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_2-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/96a4668d39b28f933b44801b594aa91cdd32f87b/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_2-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_2-expected.txt?ref=96a4668d39b28f933b44801b594aa91cdd32f87b"", ""patch"": ""@@ -1,4 +0,0 @@\n-This is a testharness.js-based test.\n-FAIL Multiple history traversals, last would be aborted assert_array_equals: Pages opened during history navigation property 1, expected 3 but got 1\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""4cc1bc9d0779b0dc2a502bfa4fe6c79a6f0e0d8e"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_3-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/96a4668d39b28f933b44801b594aa91cdd32f87b/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_3-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/96a4668d39b28f933b44801b594aa91cdd32f87b/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_3-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_3-expected.txt?ref=96a4668d39b28f933b44801b594aa91cdd32f87b"", ""patch"": ""@@ -1,4 +0,0 @@\n-This is a testharness.js-based test.\n-FAIL Multiple history traversals, last would be aborted assert_array_equals: Pages opened during history navigation property 1, expected 3 but got 1\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""d8e3e002d4ad0ad41dca696d9656a1b326fe30a4"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_4-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/96a4668d39b28f933b44801b594aa91cdd32f87b/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_4-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/96a4668d39b28f933b44801b594aa91cdd32f87b/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_4-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_4-expected.txt?ref=96a4668d39b28f933b44801b594aa91cdd32f87b"", ""patch"": ""@@ -1,4 +0,0 @@\n-This is a testharness.js-based test.\n-FAIL Multiple history traversals, last would be aborted assert_array_equals: Pages opened during history navigation property 1, expected 5 but got 3\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""d8e3e002d4ad0ad41dca696d9656a1b326fe30a4"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_5-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/96a4668d39b28f933b44801b594aa91cdd32f87b/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_5-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/96a4668d39b28f933b44801b594aa91cdd32f87b/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_5-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/html/browsers/history/the-history-interface/traverse_the_history_5-expected.txt?ref=96a4668d39b28f933b44801b594aa91cdd32f87b"", ""patch"": ""@@ -1,4 +0,0 @@\n-This is a testharness.js-based test.\n-FAIL Multiple history traversals, last would be aborted assert_array_equals: Pages opened during history navigation property 1, expected 5 but got 3\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""27d49895a54819f0b21b322b3261666a70eba7d7"", ""filename"": ""third_party/blink/public/web/web_view_client.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/third_party/blink/public/web/web_view_client.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/third_party/blink/public/web/web_view_client.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/web/web_view_client.h?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -173,8 +173,9 @@ class WebViewClient {\n \n   // Tells the embedder to navigate back or forward in session history by\n   // the given offset (relative to the current position in session\n-  // history).\n-  virtual void NavigateBackForwardSoon(int offset) {}\n+  // history). |has_user_gesture| tells whether or not this is the consequence\n+  // of a user action.\n+  virtual void NavigateBackForwardSoon(int offset, bool has_user_gesture) {}\n \n   // Returns the number of history items before/after the current\n   // history item.""}<_**next**_>{""sha"": ""c89e0280a085c4bf4bc53d15a5f2d60e919c3ed5"", ""filename"": ""third_party/blink/renderer/core/exported/local_frame_client_impl.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/a7d715ae5b654d1f98669fd979a00282a7229044/third_party/blink/renderer/core/exported/local_frame_client_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a7d715ae5b654d1f98669fd979a00282a7229044/third_party/blink/renderer/core/exported/local_frame_client_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/exported/local_frame_client_impl.cc?ref=a7d715ae5b654d1f98669fd979a00282a7229044"", ""patch"": ""@@ -71,6 +71,7 @@\n #include \""third_party/blink/renderer/core/exported/web_plugin_container_impl.h\""\n #include \""third_party/blink/renderer/core/exported/web_view_impl.h\""\n #include \""third_party/blink/renderer/core/fileapi/public_url_manager.h\""\n+#include \""third_party/blink/renderer/core/frame/frame.h\""\n #include \""third_party/blink/renderer/core/frame/local_frame_view.h\""\n #include \""third_party/blink/renderer/core/frame/settings.h\""\n #include \""third_party/blink/renderer/core/frame/web_local_frame_impl.h\""\n@@ -667,7 +668,10 @@ bool LocalFrameClientImpl::NavigateBackForward(int offset) const {\n     return false;\n   if (offset < -webview->Client()->HistoryBackListCount())\n     return false;\n-  webview->Client()->NavigateBackForwardSoon(offset);\n+\n+  bool has_user_gesture =\n+      Frame::HasTransientUserActivation(web_frame_->GetFrame());\n+  webview->Client()->NavigateBackForwardSoon(offset, has_user_gesture);\n   return true;\n }\n ""}","bool LocalFrameClientImpl::NavigateBackForward(int offset) const {
  WebViewImpl* webview = web_frame_->ViewImpl();
  if (!webview->Client())
    return false;

  DCHECK(offset);
  if (offset > webview->Client()->HistoryForwardListCount())
     return false;
   if (offset < -webview->Client()->HistoryBackListCount())
     return false;

  bool has_user_gesture =
      Frame::HasTransientUserActivation(web_frame_->GetFrame());
  webview->Client()->NavigateBackForwardSoon(offset, has_user_gesture);
   return true;
 }
","bool LocalFrameClientImpl::NavigateBackForward(int offset) const {
  WebViewImpl* webview = web_frame_->ViewImpl();
  if (!webview->Client())
    return false;

  DCHECK(offset);
  if (offset > webview->Client()->HistoryForwardListCount())
     return false;
   if (offset < -webview->Client()->HistoryBackListCount())
     return false;
  webview->Client()->NavigateBackForwardSoon(offset);
   return true;
 }
",C,"
  bool has_user_gesture =
      Frame::HasTransientUserActivation(web_frame_->GetFrame());
  webview->Client()->NavigateBackForwardSoon(offset, has_user_gesture);
","  webview->Client()->NavigateBackForwardSoon(offset);
",,"@@ -71,6 +71,7 @@
 #include ""third_party/blink/renderer/core/exported/web_plugin_container_impl.h""
 #include ""third_party/blink/renderer/core/exported/web_view_impl.h""
 #include ""third_party/blink/renderer/core/fileapi/public_url_manager.h""
+#include ""third_party/blink/renderer/core/frame/frame.h""
 #include ""third_party/blink/renderer/core/frame/local_frame_view.h""
 #include ""third_party/blink/renderer/core/frame/settings.h""
 #include ""third_party/blink/renderer/core/frame/web_local_frame_impl.h""
@@ -667,7 +668,10 @@ bool LocalFrameClientImpl::NavigateBackForward(int offset) const {
     return false;
   if (offset < -webview->Client()->HistoryBackListCount())
     return false;
-  webview->Client()->NavigateBackForwardSoon(offset);
+
+  bool has_user_gesture =
+      Frame::HasTransientUserActivation(web_frame_->GetFrame());
+  webview->Client()->NavigateBackForwardSoon(offset, has_user_gesture);
   return true;
 }
 ",Chrome,a7d715ae5b654d1f98669fd979a00282a7229044,96a4668d39b28f933b44801b594aa91cdd32f87b,1,"bool LocalFrameClientImpl::NavigateBackForward(int offset) const {
  WebViewImpl* webview = web_frame_->ViewImpl();
  if (!webview->Client())
    return false;

  DCHECK(offset);
  if (offset > webview->Client()->HistoryForwardListCount())
     return false;
   if (offset < -webview->Client()->HistoryBackListCount())
     return false;
//flaw_line_below:
  webview->Client()->NavigateBackForwardSoon(offset);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  bool has_user_gesture =
//fix_flaw_line_below:
//      Frame::HasTransientUserActivation(web_frame_->GetFrame());
//fix_flaw_line_below:
//  webview->Client()->NavigateBackForwardSoon(offset, has_user_gesture);
   return true;
 }
"
9360,187096,,Remote,Not required,,CVE-2019-5768,https://www.cvedetails.com/cve/CVE-2019-5768/,CWE-254,Medium,Partial,,,2019-02-19,4.3,DevTools API not correctly gating on extension capability in DevTools in Google Chrome prior to 72.0.3626.81 allowed an attacker who convinced a user to install a malicious extension to read local files via a crafted Chrome Extension.,2019-04-18,,1,https://github.com/chromium/chromium/commit/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b,7aaf7e9031ee16b9d4212fa0bc03d94713b3261b,"[DevTools] Guard DOM.setFileInputFiles under MayAffectLocalFiles

Bug: 805557
Change-Id: Ib6f37ec6e1d091ee54621cc0c5c44f1a6beab10f
Reviewed-on: https://chromium-review.googlesource.com/c/1334847
Reviewed-by: Pavel Feldman <pfeldman@chromium.org>
Commit-Queue: Dmitry Gozman <dgozman@chromium.org>
Cr-Commit-Position: refs/heads/master@{#607902}",2,content/browser/devtools/protocol/dom_handler.cc,"{""sha"": ""bd8f29519c955328d055f3e6b7bdca5a6ab01222"", ""filename"": ""content/browser/devtools/protocol/dom_handler.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/protocol/dom_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/protocol/dom_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/devtools/protocol/dom_handler.cc?ref=7aaf7e9031ee16b9d4212fa0bc03d94713b3261b"", ""patch"": ""@@ -12,10 +12,10 @@\n namespace content {\n namespace protocol {\n \n-DOMHandler::DOMHandler()\n+DOMHandler::DOMHandler(bool allow_file_access)\n     : DevToolsDomainHandler(DOM::Metainfo::domainName),\n-      host_(nullptr) {\n-}\n+      host_(nullptr),\n+      allow_file_access_(allow_file_access) {}\n \n DOMHandler::~DOMHandler() {\n }\n@@ -38,6 +38,8 @@ Response DOMHandler::SetFileInputFiles(\n     Maybe<DOM::NodeId> node_id,\n     Maybe<DOM::BackendNodeId> backend_node_id,\n     Maybe<String> in_object_id) {\n+  if (!allow_file_access_)\n+    return Response::Error(\""Not allowed\"");\n   if (host_) {\n     for (size_t i = 0; i < files->length(); i++) {\n #if defined(OS_WIN)""}<_**next**_>{""sha"": ""fde9851225086a03e7399e104e6c392718d15790"", ""filename"": ""content/browser/devtools/protocol/dom_handler.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/protocol/dom_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/protocol/dom_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/devtools/protocol/dom_handler.h?ref=7aaf7e9031ee16b9d4212fa0bc03d94713b3261b"", ""patch"": ""@@ -18,7 +18,7 @@ namespace protocol {\n class DOMHandler : public DevToolsDomainHandler,\n                    public DOM::Backend {\n  public:\n-  DOMHandler();\n+  explicit DOMHandler(bool allow_file_access);\n   ~DOMHandler() override;\n \n   void Wire(UberDispatcher* dispatcher) override;\n@@ -34,6 +34,7 @@ class DOMHandler : public DevToolsDomainHandler,\n \n  private:\n   RenderFrameHostImpl* host_;\n+  bool allow_file_access_;\n   DISALLOW_COPY_AND_ASSIGN(DOMHandler);\n };\n ""}<_**next**_>{""sha"": ""18b0397a618a91e903de37d73277b5d24348227c"", ""filename"": ""content/browser/devtools/render_frame_devtools_agent_host.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/render_frame_devtools_agent_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/render_frame_devtools_agent_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/devtools/render_frame_devtools_agent_host.cc?ref=7aaf7e9031ee16b9d4212fa0bc03d94713b3261b"", ""patch"": ""@@ -226,7 +226,8 @@ bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n   protocol::EmulationHandler* emulation_handler =\n       new protocol::EmulationHandler();\n   session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));\n-  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));\n+  session->AddHandler(base::WrapUnique(\n+      new protocol::DOMHandler(session->client()->MayAffectLocalFiles())));\n   session->AddHandler(base::WrapUnique(emulation_handler));\n   session->AddHandler(base::WrapUnique(new protocol::InputHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));""}","DOMHandler::DOMHandler()
DOMHandler::DOMHandler(bool allow_file_access)
     : DevToolsDomainHandler(DOM::Metainfo::domainName),
","DOMHandler::DOMHandler()
     : DevToolsDomainHandler(DOM::Metainfo::domainName),
      host_(nullptr) {
}
",C,"DOMHandler::DOMHandler(bool allow_file_access)
","      host_(nullptr) {
}
",,"@@ -12,10 +12,10 @@
 namespace content {
 namespace protocol {
 
-DOMHandler::DOMHandler()
+DOMHandler::DOMHandler(bool allow_file_access)
     : DevToolsDomainHandler(DOM::Metainfo::domainName),
-      host_(nullptr) {
-}
+      host_(nullptr),
+      allow_file_access_(allow_file_access) {}
 
 DOMHandler::~DOMHandler() {
 }
@@ -38,6 +38,8 @@ Response DOMHandler::SetFileInputFiles(
     Maybe<DOM::NodeId> node_id,
     Maybe<DOM::BackendNodeId> backend_node_id,
     Maybe<String> in_object_id) {
+  if (!allow_file_access_)
+    return Response::Error(""Not allowed"");
   if (host_) {
     for (size_t i = 0; i < files->length(); i++) {
 #if defined(OS_WIN)",Chrome,7aaf7e9031ee16b9d4212fa0bc03d94713b3261b,0eaa27d31b4d727a10363cc2ef000b84438d9696,1,"DOMHandler::DOMHandler()
//fix_flaw_line_below:
//DOMHandler::DOMHandler(bool allow_file_access)
     : DevToolsDomainHandler(DOM::Metainfo::domainName),
//flaw_line_below:
      host_(nullptr) {
//flaw_line_below:
}
"
9361,187097,,Remote,Not required,,CVE-2019-5768,https://www.cvedetails.com/cve/CVE-2019-5768/,CWE-254,Medium,Partial,,,2019-02-19,4.3,DevTools API not correctly gating on extension capability in DevTools in Google Chrome prior to 72.0.3626.81 allowed an attacker who convinced a user to install a malicious extension to read local files via a crafted Chrome Extension.,2019-04-18,,2,https://github.com/chromium/chromium/commit/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b,7aaf7e9031ee16b9d4212fa0bc03d94713b3261b,"[DevTools] Guard DOM.setFileInputFiles under MayAffectLocalFiles

Bug: 805557
Change-Id: Ib6f37ec6e1d091ee54621cc0c5c44f1a6beab10f
Reviewed-on: https://chromium-review.googlesource.com/c/1334847
Reviewed-by: Pavel Feldman <pfeldman@chromium.org>
Commit-Queue: Dmitry Gozman <dgozman@chromium.org>
Cr-Commit-Position: refs/heads/master@{#607902}",0,content/browser/devtools/protocol/dom_handler.cc,"{""sha"": ""bd8f29519c955328d055f3e6b7bdca5a6ab01222"", ""filename"": ""content/browser/devtools/protocol/dom_handler.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/protocol/dom_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/protocol/dom_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/devtools/protocol/dom_handler.cc?ref=7aaf7e9031ee16b9d4212fa0bc03d94713b3261b"", ""patch"": ""@@ -12,10 +12,10 @@\n namespace content {\n namespace protocol {\n \n-DOMHandler::DOMHandler()\n+DOMHandler::DOMHandler(bool allow_file_access)\n     : DevToolsDomainHandler(DOM::Metainfo::domainName),\n-      host_(nullptr) {\n-}\n+      host_(nullptr),\n+      allow_file_access_(allow_file_access) {}\n \n DOMHandler::~DOMHandler() {\n }\n@@ -38,6 +38,8 @@ Response DOMHandler::SetFileInputFiles(\n     Maybe<DOM::NodeId> node_id,\n     Maybe<DOM::BackendNodeId> backend_node_id,\n     Maybe<String> in_object_id) {\n+  if (!allow_file_access_)\n+    return Response::Error(\""Not allowed\"");\n   if (host_) {\n     for (size_t i = 0; i < files->length(); i++) {\n #if defined(OS_WIN)""}<_**next**_>{""sha"": ""fde9851225086a03e7399e104e6c392718d15790"", ""filename"": ""content/browser/devtools/protocol/dom_handler.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/protocol/dom_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/protocol/dom_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/devtools/protocol/dom_handler.h?ref=7aaf7e9031ee16b9d4212fa0bc03d94713b3261b"", ""patch"": ""@@ -18,7 +18,7 @@ namespace protocol {\n class DOMHandler : public DevToolsDomainHandler,\n                    public DOM::Backend {\n  public:\n-  DOMHandler();\n+  explicit DOMHandler(bool allow_file_access);\n   ~DOMHandler() override;\n \n   void Wire(UberDispatcher* dispatcher) override;\n@@ -34,6 +34,7 @@ class DOMHandler : public DevToolsDomainHandler,\n \n  private:\n   RenderFrameHostImpl* host_;\n+  bool allow_file_access_;\n   DISALLOW_COPY_AND_ASSIGN(DOMHandler);\n };\n ""}<_**next**_>{""sha"": ""18b0397a618a91e903de37d73277b5d24348227c"", ""filename"": ""content/browser/devtools/render_frame_devtools_agent_host.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/render_frame_devtools_agent_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/render_frame_devtools_agent_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/devtools/render_frame_devtools_agent_host.cc?ref=7aaf7e9031ee16b9d4212fa0bc03d94713b3261b"", ""patch"": ""@@ -226,7 +226,8 @@ bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n   protocol::EmulationHandler* emulation_handler =\n       new protocol::EmulationHandler();\n   session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));\n-  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));\n+  session->AddHandler(base::WrapUnique(\n+      new protocol::DOMHandler(session->client()->MayAffectLocalFiles())));\n   session->AddHandler(base::WrapUnique(emulation_handler));\n   session->AddHandler(base::WrapUnique(new protocol::InputHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));""}","Response DOMHandler::SetFileInputFiles(
    std::unique_ptr<protocol::Array<std::string>> files,
     Maybe<DOM::NodeId> node_id,
     Maybe<DOM::BackendNodeId> backend_node_id,
     Maybe<String> in_object_id) {
  if (!allow_file_access_)
    return Response::Error(""Not allowed"");
   if (host_) {
     for (size_t i = 0; i < files->length(); i++) {
 #if defined(OS_WIN)
      ChildProcessSecurityPolicyImpl::GetInstance()->GrantReadFile(
          host_->GetProcess()->GetID(),
          base::FilePath(base::UTF8ToUTF16(files->get(i))));
#else
      ChildProcessSecurityPolicyImpl::GetInstance()->GrantReadFile(
          host_->GetProcess()->GetID(),
          base::FilePath(files->get(i)));
#endif  // OS_WIN
    }
  }
  return Response::FallThrough();
}
","Response DOMHandler::SetFileInputFiles(
    std::unique_ptr<protocol::Array<std::string>> files,
     Maybe<DOM::NodeId> node_id,
     Maybe<DOM::BackendNodeId> backend_node_id,
     Maybe<String> in_object_id) {
   if (host_) {
     for (size_t i = 0; i < files->length(); i++) {
 #if defined(OS_WIN)
      ChildProcessSecurityPolicyImpl::GetInstance()->GrantReadFile(
          host_->GetProcess()->GetID(),
          base::FilePath(base::UTF8ToUTF16(files->get(i))));
#else
      ChildProcessSecurityPolicyImpl::GetInstance()->GrantReadFile(
          host_->GetProcess()->GetID(),
          base::FilePath(files->get(i)));
#endif  // OS_WIN
    }
  }
  return Response::FallThrough();
}
",C,"  if (!allow_file_access_)
    return Response::Error(""Not allowed"");
",,,"@@ -12,10 +12,10 @@
 namespace content {
 namespace protocol {
 
-DOMHandler::DOMHandler()
+DOMHandler::DOMHandler(bool allow_file_access)
     : DevToolsDomainHandler(DOM::Metainfo::domainName),
-      host_(nullptr) {
-}
+      host_(nullptr),
+      allow_file_access_(allow_file_access) {}
 
 DOMHandler::~DOMHandler() {
 }
@@ -38,6 +38,8 @@ Response DOMHandler::SetFileInputFiles(
     Maybe<DOM::NodeId> node_id,
     Maybe<DOM::BackendNodeId> backend_node_id,
     Maybe<String> in_object_id) {
+  if (!allow_file_access_)
+    return Response::Error(""Not allowed"");
   if (host_) {
     for (size_t i = 0; i < files->length(); i++) {
 #if defined(OS_WIN)",Chrome,7aaf7e9031ee16b9d4212fa0bc03d94713b3261b,0eaa27d31b4d727a10363cc2ef000b84438d9696,1,"Response DOMHandler::SetFileInputFiles(
    std::unique_ptr<protocol::Array<std::string>> files,
     Maybe<DOM::NodeId> node_id,
     Maybe<DOM::BackendNodeId> backend_node_id,
     Maybe<String> in_object_id) {
//fix_flaw_line_below:
//  if (!allow_file_access_)
//fix_flaw_line_below:
//    return Response::Error(""Not allowed"");
   if (host_) {
     for (size_t i = 0; i < files->length(); i++) {
 #if defined(OS_WIN)
      ChildProcessSecurityPolicyImpl::GetInstance()->GrantReadFile(
          host_->GetProcess()->GetID(),
          base::FilePath(base::UTF8ToUTF16(files->get(i))));
#else
      ChildProcessSecurityPolicyImpl::GetInstance()->GrantReadFile(
          host_->GetProcess()->GetID(),
          base::FilePath(files->get(i)));
#endif  // OS_WIN
    }
  }
  return Response::FallThrough();
}
"
9362,187098,,Remote,Not required,,CVE-2019-5768,https://www.cvedetails.com/cve/CVE-2019-5768/,CWE-254,Medium,Partial,,,2019-02-19,4.3,DevTools API not correctly gating on extension capability in DevTools in Google Chrome prior to 72.0.3626.81 allowed an attacker who convinced a user to install a malicious extension to read local files via a crafted Chrome Extension.,2019-04-18,,2,https://github.com/chromium/chromium/commit/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b,7aaf7e9031ee16b9d4212fa0bc03d94713b3261b,"[DevTools] Guard DOM.setFileInputFiles under MayAffectLocalFiles

Bug: 805557
Change-Id: Ib6f37ec6e1d091ee54621cc0c5c44f1a6beab10f
Reviewed-on: https://chromium-review.googlesource.com/c/1334847
Reviewed-by: Pavel Feldman <pfeldman@chromium.org>
Commit-Queue: Dmitry Gozman <dgozman@chromium.org>
Cr-Commit-Position: refs/heads/master@{#607902}",1,content/browser/devtools/render_frame_devtools_agent_host.cc,"{""sha"": ""bd8f29519c955328d055f3e6b7bdca5a6ab01222"", ""filename"": ""content/browser/devtools/protocol/dom_handler.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/protocol/dom_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/protocol/dom_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/devtools/protocol/dom_handler.cc?ref=7aaf7e9031ee16b9d4212fa0bc03d94713b3261b"", ""patch"": ""@@ -12,10 +12,10 @@\n namespace content {\n namespace protocol {\n \n-DOMHandler::DOMHandler()\n+DOMHandler::DOMHandler(bool allow_file_access)\n     : DevToolsDomainHandler(DOM::Metainfo::domainName),\n-      host_(nullptr) {\n-}\n+      host_(nullptr),\n+      allow_file_access_(allow_file_access) {}\n \n DOMHandler::~DOMHandler() {\n }\n@@ -38,6 +38,8 @@ Response DOMHandler::SetFileInputFiles(\n     Maybe<DOM::NodeId> node_id,\n     Maybe<DOM::BackendNodeId> backend_node_id,\n     Maybe<String> in_object_id) {\n+  if (!allow_file_access_)\n+    return Response::Error(\""Not allowed\"");\n   if (host_) {\n     for (size_t i = 0; i < files->length(); i++) {\n #if defined(OS_WIN)""}<_**next**_>{""sha"": ""fde9851225086a03e7399e104e6c392718d15790"", ""filename"": ""content/browser/devtools/protocol/dom_handler.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/protocol/dom_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/protocol/dom_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/devtools/protocol/dom_handler.h?ref=7aaf7e9031ee16b9d4212fa0bc03d94713b3261b"", ""patch"": ""@@ -18,7 +18,7 @@ namespace protocol {\n class DOMHandler : public DevToolsDomainHandler,\n                    public DOM::Backend {\n  public:\n-  DOMHandler();\n+  explicit DOMHandler(bool allow_file_access);\n   ~DOMHandler() override;\n \n   void Wire(UberDispatcher* dispatcher) override;\n@@ -34,6 +34,7 @@ class DOMHandler : public DevToolsDomainHandler,\n \n  private:\n   RenderFrameHostImpl* host_;\n+  bool allow_file_access_;\n   DISALLOW_COPY_AND_ASSIGN(DOMHandler);\n };\n ""}<_**next**_>{""sha"": ""18b0397a618a91e903de37d73277b5d24348227c"", ""filename"": ""content/browser/devtools/render_frame_devtools_agent_host.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/render_frame_devtools_agent_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7aaf7e9031ee16b9d4212fa0bc03d94713b3261b/content/browser/devtools/render_frame_devtools_agent_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/devtools/render_frame_devtools_agent_host.cc?ref=7aaf7e9031ee16b9d4212fa0bc03d94713b3261b"", ""patch"": ""@@ -226,7 +226,8 @@ bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n   protocol::EmulationHandler* emulation_handler =\n       new protocol::EmulationHandler();\n   session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));\n-  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));\n+  session->AddHandler(base::WrapUnique(\n+      new protocol::DOMHandler(session->client()->MayAffectLocalFiles())));\n   session->AddHandler(base::WrapUnique(emulation_handler));\n   session->AddHandler(base::WrapUnique(new protocol::InputHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));""}","bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {
  if (!ShouldAllowSession(session))
    return false;

   protocol::EmulationHandler* emulation_handler =
       new protocol::EmulationHandler();
   session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));
  session->AddHandler(base::WrapUnique(
      new protocol::DOMHandler(session->client()->MayAffectLocalFiles())));
   session->AddHandler(base::WrapUnique(emulation_handler));
   session->AddHandler(base::WrapUnique(new protocol::InputHandler()));
   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));
  session->AddHandler(base::WrapUnique(new protocol::IOHandler(
      GetIOContext())));
  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));
  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(
      GetId(),
      frame_tree_node_ ? frame_tree_node_->devtools_frame_token()
                       : base::UnguessableToken(),
      GetIOContext())));
  session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));
  session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));
  session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));
  session->AddHandler(base::WrapUnique(new protocol::TargetHandler(
      session->client()->MayAttachToBrowser()
          ? protocol::TargetHandler::AccessMode::kRegular
          : protocol::TargetHandler::AccessMode::kAutoAttachOnly,
      GetId(), GetRendererChannel(), session->GetRootSession())));
  session->AddHandler(base::WrapUnique(new protocol::PageHandler(
      emulation_handler, session->client()->MayAffectLocalFiles())));
  session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));
  if (!frame_tree_node_ || !frame_tree_node_->parent()) {
    session->AddHandler(base::WrapUnique(
        new protocol::TracingHandler(frame_tree_node_, GetIOContext())));
  }

  if (sessions().empty()) {
    bool use_video_capture_api = true;
#ifdef OS_ANDROID
    if (!CompositorImpl::IsInitialized())
      use_video_capture_api = false;
#endif
    if (!use_video_capture_api)
      frame_trace_recorder_.reset(new DevToolsFrameTraceRecorder());
    GrantPolicy();
#if defined(OS_ANDROID)
    GetWakeLock()->RequestWakeLock();
#endif
  }
  return true;
}
","bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {
  if (!ShouldAllowSession(session))
    return false;

   protocol::EmulationHandler* emulation_handler =
       new protocol::EmulationHandler();
   session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));
  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));
   session->AddHandler(base::WrapUnique(emulation_handler));
   session->AddHandler(base::WrapUnique(new protocol::InputHandler()));
   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));
  session->AddHandler(base::WrapUnique(new protocol::IOHandler(
      GetIOContext())));
  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));
  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(
      GetId(),
      frame_tree_node_ ? frame_tree_node_->devtools_frame_token()
                       : base::UnguessableToken(),
      GetIOContext())));
  session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));
  session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));
  session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));
  session->AddHandler(base::WrapUnique(new protocol::TargetHandler(
      session->client()->MayAttachToBrowser()
          ? protocol::TargetHandler::AccessMode::kRegular
          : protocol::TargetHandler::AccessMode::kAutoAttachOnly,
      GetId(), GetRendererChannel(), session->GetRootSession())));
  session->AddHandler(base::WrapUnique(new protocol::PageHandler(
      emulation_handler, session->client()->MayAffectLocalFiles())));
  session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));
  if (!frame_tree_node_ || !frame_tree_node_->parent()) {
    session->AddHandler(base::WrapUnique(
        new protocol::TracingHandler(frame_tree_node_, GetIOContext())));
  }

  if (sessions().empty()) {
    bool use_video_capture_api = true;
#ifdef OS_ANDROID
    if (!CompositorImpl::IsInitialized())
      use_video_capture_api = false;
#endif
    if (!use_video_capture_api)
      frame_trace_recorder_.reset(new DevToolsFrameTraceRecorder());
    GrantPolicy();
#if defined(OS_ANDROID)
    GetWakeLock()->RequestWakeLock();
#endif
  }
  return true;
}
",C,"  session->AddHandler(base::WrapUnique(
      new protocol::DOMHandler(session->client()->MayAffectLocalFiles())));
","  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));
",,"@@ -226,7 +226,8 @@ bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {
   protocol::EmulationHandler* emulation_handler =
       new protocol::EmulationHandler();
   session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));
-  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));
+  session->AddHandler(base::WrapUnique(
+      new protocol::DOMHandler(session->client()->MayAffectLocalFiles())));
   session->AddHandler(base::WrapUnique(emulation_handler));
   session->AddHandler(base::WrapUnique(new protocol::InputHandler()));
   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));",Chrome,7aaf7e9031ee16b9d4212fa0bc03d94713b3261b,0eaa27d31b4d727a10363cc2ef000b84438d9696,1,"bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {
  if (!ShouldAllowSession(session))
    return false;

   protocol::EmulationHandler* emulation_handler =
       new protocol::EmulationHandler();
   session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));
//flaw_line_below:
  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));
//fix_flaw_line_below:
//  session->AddHandler(base::WrapUnique(
//fix_flaw_line_below:
//      new protocol::DOMHandler(session->client()->MayAffectLocalFiles())));
   session->AddHandler(base::WrapUnique(emulation_handler));
   session->AddHandler(base::WrapUnique(new protocol::InputHandler()));
   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));
  session->AddHandler(base::WrapUnique(new protocol::IOHandler(
      GetIOContext())));
  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));
  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(
      GetId(),
      frame_tree_node_ ? frame_tree_node_->devtools_frame_token()
                       : base::UnguessableToken(),
      GetIOContext())));
  session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));
  session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));
  session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));
  session->AddHandler(base::WrapUnique(new protocol::TargetHandler(
      session->client()->MayAttachToBrowser()
          ? protocol::TargetHandler::AccessMode::kRegular
          : protocol::TargetHandler::AccessMode::kAutoAttachOnly,
      GetId(), GetRendererChannel(), session->GetRootSession())));
  session->AddHandler(base::WrapUnique(new protocol::PageHandler(
      emulation_handler, session->client()->MayAffectLocalFiles())));
  session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));
  if (!frame_tree_node_ || !frame_tree_node_->parent()) {
    session->AddHandler(base::WrapUnique(
        new protocol::TracingHandler(frame_tree_node_, GetIOContext())));
  }

  if (sessions().empty()) {
    bool use_video_capture_api = true;
#ifdef OS_ANDROID
    // Video capture API cannot be used on Android WebView.
    if (!CompositorImpl::IsInitialized())
      use_video_capture_api = false;
#endif
    // When video capture API is used, don't instantiate
    // DevToolsFrameTraceRecorder. Taking snapshots happens in TracingHandler.
    if (!use_video_capture_api)
      frame_trace_recorder_.reset(new DevToolsFrameTraceRecorder());
    GrantPolicy();
#if defined(OS_ANDROID)
    GetWakeLock()->RequestWakeLock();
#endif
  }
  return true;
}
"
9413,187149,,Remote,Not required,,CVE-2018-6178,https://www.cvedetails.com/cve/CVE-2018-6178/,CWE-254,Medium,,Partial,,2019-01-09,4.3,Eliding from the wrong side in an infobar in DevTools in Google Chrome prior to 68.0.3440.75 allowed an attacker who convinced a user to install a malicious extension to Hide Chrome Security UI via a crafted Chrome Extension.,2019-01-16,,1,https://github.com/chromium/chromium/commit/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311,fbeba958bb83c05ec8cc54e285a4a9ca10d1b311,"Allow to specify elide behavior for confrim infobar message

Used in ""<extension name> is debugging this browser"" infobar.

Bug: 823194
Change-Id: Iff6627097c020cccca8f7cc3e21a803a41fd8f2c
Reviewed-on: https://chromium-review.googlesource.com/1048064
Commit-Queue: Dmitry Gozman <dgozman@chromium.org>
Reviewed-by: Devlin <rdevlin.cronin@chromium.org>
Reviewed-by: Peter Kasting <pkasting@chromium.org>
Cr-Commit-Position: refs/heads/master@{#557245}",0,chrome/browser/ui/views/infobars/confirm_infobar.cc,"{""sha"": ""d283a99766a4dcf93c3011b9baec4644c81e5590"", ""filename"": ""chrome/browser/devtools/global_confirm_info_bar.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/chrome/browser/devtools/global_confirm_info_bar.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/chrome/browser/devtools/global_confirm_info_bar.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/devtools/global_confirm_info_bar.cc?ref=fbeba958bb83c05ec8cc54e285a4a9ca10d1b311"", ""patch"": ""@@ -28,6 +28,7 @@ class GlobalConfirmInfoBar::DelegateProxy : public ConfirmInfoBarDelegate {\n   // ConfirmInfoBarDelegate overrides\n   infobars::InfoBarDelegate::InfoBarIdentifier GetIdentifier() const override;\n   base::string16 GetMessageText() const override;\n+  gfx::ElideBehavior GetMessageElideBehavior() const override;\n   int GetButtons() const override;\n   base::string16 GetButtonLabel(InfoBarButton button) const override;\n   bool Accept() override;\n@@ -63,6 +64,13 @@ base::string16 GlobalConfirmInfoBar::DelegateProxy::GetMessageText() const {\n                           : base::string16();\n }\n \n+gfx::ElideBehavior\n+GlobalConfirmInfoBar::DelegateProxy::GetMessageElideBehavior() const {\n+  return global_info_bar_\n+             ? global_info_bar_->delegate_->GetMessageElideBehavior()\n+             : ConfirmInfoBarDelegate::GetMessageElideBehavior();\n+}\n+\n int GlobalConfirmInfoBar::DelegateProxy::GetButtons() const {\n   return global_info_bar_ ? global_info_bar_->delegate_->GetButtons()\n                           : 0;""}<_**next**_>{""sha"": ""fdc19ab8c5535dc9c29fe36a73dcf15d5a22830f"", ""filename"": ""chrome/browser/extensions/api/debugger/extension_dev_tools_infobar.cc"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 0, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/chrome/browser/extensions/api/debugger/extension_dev_tools_infobar.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/chrome/browser/extensions/api/debugger/extension_dev_tools_infobar.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/api/debugger/extension_dev_tools_infobar.cc?ref=fbeba958bb83c05ec8cc54e285a4a9ca10d1b311"", ""patch"": ""@@ -30,6 +30,8 @@ class ExtensionDevToolsInfoBarDelegate : public ConfirmInfoBarDelegate {\n   bool ShouldExpire(const NavigationDetails& details) const override;\n   void InfoBarDismissed() override;\n   base::string16 GetMessageText() const override;\n+  gfx::ElideBehavior GetMessageElideBehavior() const override;\n+\n   int GetButtons() const override;\n   bool Cancel() override;\n \n@@ -69,6 +71,14 @@ base::string16 ExtensionDevToolsInfoBarDelegate::GetMessageText() const {\n   return l10n_util::GetStringFUTF16(IDS_DEV_TOOLS_INFOBAR_LABEL, client_name_);\n }\n \n+gfx::ElideBehavior ExtensionDevToolsInfoBarDelegate::GetMessageElideBehavior()\n+    const {\n+  // The important part of the message text above is at the end:\n+  // \""... is debugging the browser\"". If the extension name is very long,\n+  // we'd rather truncate it instead. See https://crbug.com/823194.\n+  return gfx::ELIDE_HEAD;\n+}\n+\n int ExtensionDevToolsInfoBarDelegate::GetButtons() const {\n   return BUTTON_CANCEL;\n }""}<_**next**_>{""sha"": ""883e78dadc6c9e66219f817ffdae97b5324dd6f4"", ""filename"": ""chrome/browser/ui/views/infobars/confirm_infobar.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/chrome/browser/ui/views/infobars/confirm_infobar.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/chrome/browser/ui/views/infobars/confirm_infobar.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/infobars/confirm_infobar.cc?ref=fbeba958bb83c05ec8cc54e285a4a9ca10d1b311"", ""patch"": ""@@ -39,6 +39,7 @@ ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)\n     : InfoBarView(std::move(delegate)) {\n   auto* delegate_ptr = GetDelegate();\n   label_ = CreateLabel(delegate_ptr->GetMessageText());\n+  label_->SetElideBehavior(delegate_ptr->GetMessageElideBehavior());\n   AddChildView(label_);\n \n   const auto buttons = delegate_ptr->GetButtons();""}<_**next**_>{""sha"": ""d33f23e6367f84af95d1419704198996177d009d"", ""filename"": ""components/infobars/core/confirm_infobar_delegate.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/components/infobars/core/confirm_infobar_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/components/infobars/core/confirm_infobar_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/infobars/core/confirm_infobar_delegate.cc?ref=fbeba958bb83c05ec8cc54e285a4a9ca10d1b311"", ""patch"": ""@@ -19,6 +19,10 @@ InfoBarDelegate::InfoBarAutomationType\n   return CONFIRM_INFOBAR;\n }\n \n+gfx::ElideBehavior ConfirmInfoBarDelegate::GetMessageElideBehavior() const {\n+  return gfx::ELIDE_TAIL;\n+}\n+\n int ConfirmInfoBarDelegate::GetButtons() const {\n   return BUTTON_OK | BUTTON_CANCEL;\n }""}<_**next**_>{""sha"": ""8d0a89a2968a41f1999a77f623a7676ecaeb80c6"", ""filename"": ""components/infobars/core/confirm_infobar_delegate.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/components/infobars/core/confirm_infobar_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/components/infobars/core/confirm_infobar_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/infobars/core/confirm_infobar_delegate.h?ref=fbeba958bb83c05ec8cc54e285a4a9ca10d1b311"", ""patch"": ""@@ -9,6 +9,7 @@\n #include \""base/strings/string16.h\""\n #include \""components/infobars/core/infobar_delegate.h\""\n #include \""components/infobars/core/infobar_manager.h\""\n+#include \""ui/gfx/text_constants.h\""\n #include \""url/gurl.h\""\n \n namespace infobars {\n@@ -33,6 +34,10 @@ class ConfirmInfoBarDelegate : public infobars::InfoBarDelegate {\n   // Returns the message string to be displayed for the InfoBar.\n   virtual base::string16 GetMessageText() const = 0;\n \n+  // Returns the elide behavior for the message string.\n+  // Not supported on Android.\n+  virtual gfx::ElideBehavior GetMessageElideBehavior() const;\n+\n   // Returns the buttons to be shown for this InfoBar.\n   virtual int GetButtons() const;\n ""}","ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)
     : InfoBarView(std::move(delegate)) {
   auto* delegate_ptr = GetDelegate();
   label_ = CreateLabel(delegate_ptr->GetMessageText());
  label_->SetElideBehavior(delegate_ptr->GetMessageElideBehavior());
   AddChildView(label_);
 
   const auto buttons = delegate_ptr->GetButtons();
  if (buttons & ConfirmInfoBarDelegate::BUTTON_OK) {
    ok_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_OK);
    ok_button_->SetProminent(true);
    if (delegate_ptr->OKButtonTriggersUACPrompt()) {
      elevation_icon_setter_.reset(new ElevationIconSetter(
          ok_button_,
          base::BindOnce(&ConfirmInfoBar::Layout, base::Unretained(this))));
    }
  }

  if (buttons & ConfirmInfoBarDelegate::BUTTON_CANCEL) {
    cancel_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_CANCEL);
    if (buttons == ConfirmInfoBarDelegate::BUTTON_CANCEL)
      cancel_button_->SetProminent(true);
  }

  link_ = CreateLink(delegate_ptr->GetLinkText(), this);
  AddChildView(link_);
}
","ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)
     : InfoBarView(std::move(delegate)) {
   auto* delegate_ptr = GetDelegate();
   label_ = CreateLabel(delegate_ptr->GetMessageText());
   AddChildView(label_);
 
   const auto buttons = delegate_ptr->GetButtons();
  if (buttons & ConfirmInfoBarDelegate::BUTTON_OK) {
    ok_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_OK);
    ok_button_->SetProminent(true);
    if (delegate_ptr->OKButtonTriggersUACPrompt()) {
      elevation_icon_setter_.reset(new ElevationIconSetter(
          ok_button_,
          base::BindOnce(&ConfirmInfoBar::Layout, base::Unretained(this))));
    }
  }

  if (buttons & ConfirmInfoBarDelegate::BUTTON_CANCEL) {
    cancel_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_CANCEL);
    if (buttons == ConfirmInfoBarDelegate::BUTTON_CANCEL)
      cancel_button_->SetProminent(true);
  }

  link_ = CreateLink(delegate_ptr->GetLinkText(), this);
  AddChildView(link_);
}
",C,"  label_->SetElideBehavior(delegate_ptr->GetMessageElideBehavior());
",,,"@@ -39,6 +39,7 @@ ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)
     : InfoBarView(std::move(delegate)) {
   auto* delegate_ptr = GetDelegate();
   label_ = CreateLabel(delegate_ptr->GetMessageText());
+  label_->SetElideBehavior(delegate_ptr->GetMessageElideBehavior());
   AddChildView(label_);
 
   const auto buttons = delegate_ptr->GetButtons();",Chrome,fbeba958bb83c05ec8cc54e285a4a9ca10d1b311,6ed800438a7d678b14ed09b983d7f439031b8896,1,"ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)
     : InfoBarView(std::move(delegate)) {
   auto* delegate_ptr = GetDelegate();
   label_ = CreateLabel(delegate_ptr->GetMessageText());
//fix_flaw_line_below:
//  label_->SetElideBehavior(delegate_ptr->GetMessageElideBehavior());
   AddChildView(label_);
 
   const auto buttons = delegate_ptr->GetButtons();
  if (buttons & ConfirmInfoBarDelegate::BUTTON_OK) {
    ok_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_OK);
    ok_button_->SetProminent(true);
    if (delegate_ptr->OKButtonTriggersUACPrompt()) {
      elevation_icon_setter_.reset(new ElevationIconSetter(
          ok_button_,
          base::BindOnce(&ConfirmInfoBar::Layout, base::Unretained(this))));
    }
  }

  if (buttons & ConfirmInfoBarDelegate::BUTTON_CANCEL) {
    cancel_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_CANCEL);
    if (buttons == ConfirmInfoBarDelegate::BUTTON_CANCEL)
      cancel_button_->SetProminent(true);
  }

  link_ = CreateLink(delegate_ptr->GetLinkText(), this);
  AddChildView(link_);
}
"
9440,187176,,Remote,Not required,,CVE-2018-16075,https://www.cvedetails.com/cve/CVE-2018-16075/,CWE-254,High,Partial,,,2019-06-27,2.6,Insufficient file type enforcement in Blink in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to obtain local file data via a crafted HTML page.,2019-07-01,,0,https://github.com/chromium/chromium/commit/d913f72b4875cf0814fc3f03ad7c00642097c4a4,d913f72b4875cf0814fc3f03ad7c00642097c4a4,"Remove RequireCSSExtensionForFile runtime enabled flag.

The feature has long since been stable (since M64) and doesn't seem
to be a need for this flag.

BUG=788936

Change-Id: I666390b869289c328acb4a2daa5bf4154e1702c0
Reviewed-on: https://chromium-review.googlesource.com/c/1324143
Reviewed-by: Mike West <mkwst@chromium.org>
Reviewed-by: Camille Lamy <clamy@chromium.org>
Commit-Queue: Dave Tapuska <dtapuska@chromium.org>
Cr-Commit-Position: refs/heads/master@{#607329}",2,content/child/runtime_features.cc,"{""sha"": ""a55db99e7b7c27fa4dbf950862d23452a1777360"", ""filename"": ""content/child/runtime_features.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/child/runtime_features.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/child/runtime_features.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/child/runtime_features.cc?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -422,9 +422,6 @@ void SetRuntimeFeaturesDefaultsAndUpdateFromArgs(\n   WebRuntimeFeatures::EnableV8ContextSnapshot(\n       base::FeatureList::IsEnabled(features::kV8ContextSnapshot));\n \n-  WebRuntimeFeatures::EnableRequireCSSExtensionForFile(\n-      base::FeatureList::IsEnabled(features::kRequireCSSExtensionForFile));\n-\n   WebRuntimeFeatures::EnablePictureInPicture(\n       base::FeatureList::IsEnabled(media::kPictureInPicture));\n ""}<_**next**_>{""sha"": ""0d7975c9b2bf75277a90f0437b8f1b2330b3e812"", ""filename"": ""content/public/common/content_features.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/public/common/content_features.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/public/common/content_features.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/common/content_features.cc?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -351,10 +351,6 @@ const base::Feature kRasterInducingScroll{\""RasterInducingScroll\"",\n const base::Feature kRenderingPipelineThrottling{\n     \""RenderingPipelineThrottling\"", base::FEATURE_ENABLED_BY_DEFAULT};\n \n-// When loading CSS from a 'file:' URL, require a CSS-like file extension.\n-const base::Feature kRequireCSSExtensionForFile{\n-    \""RequireCSSExtensionForFile\"", base::FEATURE_ENABLED_BY_DEFAULT};\n-\n // Enables resampling input events on main thread.\n const base::Feature kResamplingInputEvents{\""ResamplingInputEvents\"",\n                                            base::FEATURE_DISABLED_BY_DEFAULT};""}<_**next**_>{""sha"": ""9c7e5359864aa8e4e933a05f5d87797b1bfa3b0c"", ""filename"": ""content/public/common/content_features.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/public/common/content_features.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/public/common/content_features.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/common/content_features.h?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -83,7 +83,6 @@ CONTENT_EXPORT extern const base::Feature kPepper3DImageChromium;\n CONTENT_EXPORT extern const base::Feature kPurgeAndSuspend;\n CONTENT_EXPORT extern const base::Feature kRasterInducingScroll;\n CONTENT_EXPORT extern const base::Feature kRenderingPipelineThrottling;\n-CONTENT_EXPORT extern const base::Feature kRequireCSSExtensionForFile;\n CONTENT_EXPORT extern const base::Feature kResamplingInputEvents;\n CONTENT_EXPORT extern const base::Feature kResourceLoadScheduler;\n CONTENT_EXPORT extern const base::Feature""}<_**next**_>{""sha"": ""e09d2a228d9eea3d0af4afd1718db9bf97020915"", ""filename"": ""third_party/blink/public/platform/web_runtime_features.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/public/platform/web_runtime_features.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/public/platform/web_runtime_features.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_runtime_features.h?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -150,7 +150,6 @@ class WebRuntimeFeatures {\n   BLINK_PLATFORM_EXPORT static void EnableReducedReferrerGranularity(bool);\n   BLINK_PLATFORM_EXPORT static void EnableRemotePlaybackAPI(bool);\n   BLINK_PLATFORM_EXPORT static void EnableRenderingPipelineThrottling(bool);\n-  BLINK_PLATFORM_EXPORT static void EnableRequireCSSExtensionForFile(bool);\n   BLINK_PLATFORM_EXPORT static void EnableResourceLoadScheduler(bool);\n   BLINK_PLATFORM_EXPORT static void EnableScriptedSpeech(bool);\n   BLINK_PLATFORM_EXPORT static void EnableScrollAnchorSerialization(bool);""}<_**next**_>{""sha"": ""ca623be21e14ea7326fc72b36fed0ca86d6bed66"", ""filename"": ""third_party/blink/renderer/core/loader/resource/css_style_sheet_resource.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/core/loader/resource/css_style_sheet_resource.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/core/loader/resource/css_style_sheet_resource.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/loader/resource/css_style_sheet_resource.cc?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -178,9 +178,7 @@ bool CSSStyleSheetResource::CanUseSheet(const CSSParserContext* parser_context,\n         parser_context->CountDeprecation(\n             WebFeature::kLocalCSSFileExtensionRejected);\n       }\n-      if (RuntimeEnabledFeatures::RequireCSSExtensionForFileEnabled()) {\n-        return false;\n-      }\n+      return false;\n     }\n   }\n ""}<_**next**_>{""sha"": ""395670e974edd446c7fb6926f66a30b4dc2ac910"", ""filename"": ""third_party/blink/renderer/platform/exported/web_runtime_features.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/platform/exported/web_runtime_features.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/platform/exported/web_runtime_features.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/exported/web_runtime_features.cc?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -440,10 +440,6 @@ void WebRuntimeFeatures::EnableRenderingPipelineThrottling(bool enable) {\n   RuntimeEnabledFeatures::SetRenderingPipelineThrottlingEnabled(enable);\n }\n \n-void WebRuntimeFeatures::EnableRequireCSSExtensionForFile(bool enable) {\n-  RuntimeEnabledFeatures::SetRequireCSSExtensionForFileEnabled(enable);\n-}\n-\n void WebRuntimeFeatures::EnableResourceLoadScheduler(bool enable) {\n   RuntimeEnabledFeatures::SetResourceLoadSchedulerEnabled(enable);\n }""}<_**next**_>{""sha"": ""99edfef487c48d78a59f39b209b7867aea19d02b"", ""filename"": ""third_party/blink/renderer/platform/runtime_enabled_features.json5"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/platform/runtime_enabled_features.json5"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/platform/runtime_enabled_features.json5"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/runtime_enabled_features.json5?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -1025,10 +1025,6 @@\n       name: \""RenderingPipelineThrottling\"",\n       status: \""stable\"",\n     },\n-    {\n-      name: \""RequireCSSExtensionForFile\"",\n-      status: \""stable\"",\n-    },\n     {\n       name: \""ResourceLoadScheduler\"",\n       status: \""experimental\"",""}","void SetRuntimeFeaturesDefaultsAndUpdateFromArgs(
    const base::CommandLine& command_line) {
  bool enableExperimentalWebPlatformFeatures = command_line.HasSwitch(
      switches::kEnableExperimentalWebPlatformFeatures);
  if (enableExperimentalWebPlatformFeatures)
    WebRuntimeFeatures::EnableExperimentalFeatures(true);

  SetRuntimeFeatureDefaultsForPlatform();


  WebRuntimeFeatures::EnableOriginTrials(
      base::FeatureList::IsEnabled(features::kOriginTrials));

  if (!base::FeatureList::IsEnabled(features::kWebUsb))
    WebRuntimeFeatures::EnableWebUsb(false);

  WebRuntimeFeatures::EnableBlinkHeapIncrementalMarking(
      base::FeatureList::IsEnabled(features::kBlinkHeapIncrementalMarking));

  WebRuntimeFeatures::EnableBlinkHeapUnifiedGarbageCollection(
      base::FeatureList::IsEnabled(
          features::kBlinkHeapUnifiedGarbageCollection));

  if (base::FeatureList::IsEnabled(features::kBloatedRendererDetection))
    WebRuntimeFeatures::EnableBloatedRendererDetection(true);

  if (command_line.HasSwitch(switches::kDisableDatabases))
    WebRuntimeFeatures::EnableDatabase(false);

  if (command_line.HasSwitch(switches::kDisableNotifications)) {
    WebRuntimeFeatures::EnableNotifications(false);

    WebRuntimeFeatures::EnablePushMessaging(false);
  }

  if (!base::FeatureList::IsEnabled(features::kNotificationContentImage))
    WebRuntimeFeatures::EnableNotificationContentImage(false);

  WebRuntimeFeatures::EnableSharedArrayBuffer(
      base::FeatureList::IsEnabled(features::kSharedArrayBuffer) ||
      base::FeatureList::IsEnabled(features::kWebAssemblyThreads));

  if (command_line.HasSwitch(switches::kDisableSharedWorkers))
    WebRuntimeFeatures::EnableSharedWorker(false);

  if (command_line.HasSwitch(switches::kDisableSpeechAPI))
    WebRuntimeFeatures::EnableScriptedSpeech(false);

  if (command_line.HasSwitch(switches::kDisableFileSystem))
    WebRuntimeFeatures::EnableFileSystem(false);

  if (!command_line.HasSwitch(switches::kDisableAcceleratedJpegDecoding))
    WebRuntimeFeatures::EnableDecodeToYUV(true);

#if defined(SUPPORT_WEBGL2_COMPUTE_CONTEXT)
  if (command_line.HasSwitch(switches::kEnableWebGL2ComputeContext)) {
    WebRuntimeFeatures::EnableWebGL2ComputeContext(true);
  }
#endif

  if (command_line.HasSwitch(switches::kEnableWebGLDraftExtensions))
    WebRuntimeFeatures::EnableWebGLDraftExtensions(true);

  if (command_line.HasSwitch(switches::kEnableAutomation) ||
      command_line.HasSwitch(switches::kHeadless)) {
    WebRuntimeFeatures::EnableAutomationControlled(true);
  }

#if defined(OS_MACOSX)
  const bool enable_canvas_2d_image_chromium =
      command_line.HasSwitch(
          switches::kEnableGpuMemoryBufferCompositorResources) &&
      !command_line.HasSwitch(switches::kDisable2dCanvasImageChromium) &&
      !command_line.HasSwitch(switches::kDisableGpu) &&
      base::FeatureList::IsEnabled(features::kCanvas2DImageChromium);
#else
  constexpr bool enable_canvas_2d_image_chromium = false;
#endif
  WebRuntimeFeatures::EnableCanvas2dImageChromium(
      enable_canvas_2d_image_chromium);

#if defined(OS_MACOSX)
  const bool enable_web_gl_image_chromium =
      command_line.HasSwitch(
          switches::kEnableGpuMemoryBufferCompositorResources) &&
      !command_line.HasSwitch(switches::kDisableWebGLImageChromium) &&
      !command_line.HasSwitch(switches::kDisableGpu) &&
      base::FeatureList::IsEnabled(features::kWebGLImageChromium);
#else
  const bool enable_web_gl_image_chromium =
      command_line.HasSwitch(switches::kEnableWebGLImageChromium);
#endif
  WebRuntimeFeatures::EnableWebGLImageChromium(enable_web_gl_image_chromium);

  if (command_line.HasSwitch(switches::kForceOverlayFullscreenVideo))
    WebRuntimeFeatures::ForceOverlayFullscreenVideo(true);

  if (ui::IsOverlayScrollbarEnabled())
    WebRuntimeFeatures::EnableOverlayScrollbars(true);

  if (command_line.HasSwitch(switches::kEnablePreciseMemoryInfo))
    WebRuntimeFeatures::EnablePreciseMemoryInfo(true);

  if (command_line.HasSwitch(switches::kEnablePrintBrowser))
    WebRuntimeFeatures::EnablePrintBrowser(true);

  if (command_line.HasSwitch(switches::kEnableNetworkInformationDownlinkMax) ||
      enableExperimentalWebPlatformFeatures) {
    WebRuntimeFeatures::EnableNetInfoDownlinkMax(true);
  }

  if (command_line.HasSwitch(switches::kReducedReferrerGranularity))
    WebRuntimeFeatures::EnableReducedReferrerGranularity(true);

  if (command_line.HasSwitch(switches::kDisablePermissionsAPI))
    WebRuntimeFeatures::EnablePermissionsAPI(false);

  if (command_line.HasSwitch(switches::kDisableV8IdleTasks))
    WebRuntimeFeatures::EnableV8IdleTasks(false);
  else
    WebRuntimeFeatures::EnableV8IdleTasks(true);

  if (command_line.HasSwitch(switches::kEnableUnsafeWebGPU))
    WebRuntimeFeatures::EnableWebGPU(true);

  if (command_line.HasSwitch(switches::kEnableWebVR))
    WebRuntimeFeatures::EnableWebVR(true);

  if (base::FeatureList::IsEnabled(features::kWebXr))
    WebRuntimeFeatures::EnableWebXR(true);

  if (base::FeatureList::IsEnabled(features::kWebXrGamepadSupport))
    WebRuntimeFeatures::EnableWebXRGamepadSupport(true);

  if (base::FeatureList::IsEnabled(features::kWebXrHitTest))
    WebRuntimeFeatures::EnableWebXRHitTest(true);

  if (command_line.HasSwitch(switches::kDisablePresentationAPI))
    WebRuntimeFeatures::EnablePresentationAPI(false);

  if (command_line.HasSwitch(switches::kDisableRemotePlaybackAPI))
    WebRuntimeFeatures::EnableRemotePlaybackAPI(false);

  WebRuntimeFeatures::EnableSecMetadata(
      base::FeatureList::IsEnabled(features::kSecMetadata) ||
      enableExperimentalWebPlatformFeatures);

  WebRuntimeFeatures::EnableUserActivationV2(
      base::FeatureList::IsEnabled(features::kUserActivationV2));

  if (base::FeatureList::IsEnabled(features::kScrollAnchorSerialization))
    WebRuntimeFeatures::EnableScrollAnchorSerialization(true);

  if (command_line.HasSwitch(switches::kEnableBlinkGenPropertyTrees))
    WebRuntimeFeatures::EnableFeatureFromString(""BlinkGenPropertyTrees"", true);

  if (command_line.HasSwitch(switches::kEnableSlimmingPaintV2))
    WebRuntimeFeatures::EnableFeatureFromString(""SlimmingPaintV2"", true);

  WebRuntimeFeatures::EnablePassiveDocumentEventListeners(
      base::FeatureList::IsEnabled(features::kPassiveDocumentEventListeners));

  WebRuntimeFeatures::EnablePassiveDocumentWheelEventListeners(
      base::FeatureList::IsEnabled(
          features::kPassiveDocumentWheelEventListeners));

  WebRuntimeFeatures::EnableFeatureFromString(
      ""FontCacheScaling"",
      base::FeatureList::IsEnabled(features::kFontCacheScaling));

  WebRuntimeFeatures::EnableFeatureFromString(
      ""FontSrcLocalMatching"",
      base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));

  WebRuntimeFeatures::EnableFeatureFromString(
      ""FramebustingNeedsSameOriginOrUserGesture"",
      base::FeatureList::IsEnabled(
          features::kFramebustingNeedsSameOriginOrUserGesture));

  if (command_line.HasSwitch(switches::kDisableBackgroundTimerThrottling))
    WebRuntimeFeatures::EnableTimerThrottlingForBackgroundTabs(false);

  WebRuntimeFeatures::EnableExpensiveBackgroundTimerThrottling(
      base::FeatureList::IsEnabled(
          features::kExpensiveBackgroundTimerThrottling));

  if (base::FeatureList::IsEnabled(features::kHeapCompaction))
    WebRuntimeFeatures::EnableHeapCompaction(true);

  WebRuntimeFeatures::EnableRenderingPipelineThrottling(
      base::FeatureList::IsEnabled(features::kRenderingPipelineThrottling));

  WebRuntimeFeatures::EnableTimerThrottlingForHiddenFrames(
      base::FeatureList::IsEnabled(features::kTimerThrottlingForHiddenFrames));

  if (base::FeatureList::IsEnabled(
          features::kSendBeaconThrowForBlobWithNonSimpleType))
    WebRuntimeFeatures::EnableSendBeaconThrowForBlobWithNonSimpleType(true);

#if defined(OS_ANDROID)
  if (command_line.HasSwitch(switches::kDisableMediaSessionAPI))
    WebRuntimeFeatures::EnableMediaSession(false);
#endif

  WebRuntimeFeatures::EnablePaymentRequest(
      base::FeatureList::IsEnabled(features::kWebPayments));

  if (base::FeatureList::IsEnabled(features::kServiceWorkerPaymentApps))
    WebRuntimeFeatures::EnablePaymentApp(true);

  WebRuntimeFeatures::EnableNetworkService(
      base::FeatureList::IsEnabled(network::features::kNetworkService));

  if (base::FeatureList::IsEnabled(features::kGamepadExtensions))
    WebRuntimeFeatures::EnableGamepadExtensions(true);

  if (base::FeatureList::IsEnabled(features::kGamepadVibration))
    WebRuntimeFeatures::EnableGamepadVibration(true);

  if (base::FeatureList::IsEnabled(features::kCompositeOpaqueFixedPosition))
    WebRuntimeFeatures::EnableFeatureFromString(""CompositeOpaqueFixedPosition"",
                                                true);

  if (!base::FeatureList::IsEnabled(features::kCompositeOpaqueScrollers))
    WebRuntimeFeatures::EnableFeatureFromString(""CompositeOpaqueScrollers"",
                                                false);
  if (base::FeatureList::IsEnabled(features::kCompositorTouchAction))
    WebRuntimeFeatures::EnableCompositorTouchAction(true);

  if (base::FeatureList::IsEnabled(features::kCSSFragmentIdentifiers))
    WebRuntimeFeatures::EnableCSSFragmentIdentifiers(true);

  if (!base::FeatureList::IsEnabled(features::kGenericSensor))
    WebRuntimeFeatures::EnableGenericSensor(false);

  if (base::FeatureList::IsEnabled(features::kGenericSensorExtraClasses))
    WebRuntimeFeatures::EnableGenericSensorExtraClasses(true);

  if (base::FeatureList::IsEnabled(network::features::kOutOfBlinkCORS))
    WebRuntimeFeatures::EnableOutOfBlinkCORS(true);

  WebRuntimeFeatures::EnableMediaCastOverlayButton(
      base::FeatureList::IsEnabled(media::kMediaCastOverlayButton));

  if (!base::FeatureList::IsEnabled(features::kBlockCredentialedSubresources)) {
    WebRuntimeFeatures::EnableFeatureFromString(""BlockCredentialedSubresources"",
                                                false);
  }

  if (base::FeatureList::IsEnabled(features::kRasterInducingScroll))
    WebRuntimeFeatures::EnableRasterInducingScroll(true);

  WebRuntimeFeatures::EnableFeatureFromString(
      ""AllowContentInitiatedDataUrlNavigations"",
      base::FeatureList::IsEnabled(
          features::kAllowContentInitiatedDataUrlNavigations));

#if defined(OS_ANDROID)
  if (base::FeatureList::IsEnabled(features::kWebNfc))
    WebRuntimeFeatures::EnableWebNfc(true);
#endif

  WebRuntimeFeatures::EnableWebAuth(
      base::FeatureList::IsEnabled(features::kWebAuth));

  WebRuntimeFeatures::EnableWebAuthGetTransports(
      base::FeatureList::IsEnabled(features::kWebAuthGetTransports) ||
      enableExperimentalWebPlatformFeatures);

  WebRuntimeFeatures::EnableClientPlaceholdersForServerLoFi(
      base::GetFieldTrialParamValue(""PreviewsClientLoFi"",
                                    ""replace_server_placeholders"") != ""false"");

  WebRuntimeFeatures::EnableResourceLoadScheduler(
      base::FeatureList::IsEnabled(features::kResourceLoadScheduler));

  if (base::FeatureList::IsEnabled(features::kLayeredAPI))
    WebRuntimeFeatures::EnableLayeredAPI(true);

  if (base::FeatureList::IsEnabled(blink::features::kLayoutNG))
    WebRuntimeFeatures::EnableLayoutNG(true);

  WebRuntimeFeatures::EnableLazyInitializeMediaControls(
      base::FeatureList::IsEnabled(features::kLazyInitializeMediaControls));

  WebRuntimeFeatures::EnableMediaEngagementBypassAutoplayPolicies(
      base::FeatureList::IsEnabled(
          media::kMediaEngagementBypassAutoplayPolicies));

  WebRuntimeFeatures::EnableOverflowIconsForMediaControls(
      base::FeatureList::IsEnabled(media::kOverflowIconsForMediaControls));

  WebRuntimeFeatures::EnableAllowActivationDelegationAttr(
      base::FeatureList::IsEnabled(features::kAllowActivationDelegationAttr));

  WebRuntimeFeatures::EnableModernMediaControls(
      base::FeatureList::IsEnabled(media::kUseModernMediaControls));

  WebRuntimeFeatures::EnableWorkStealingInScriptRunner(
      base::FeatureList::IsEnabled(features::kWorkStealingInScriptRunner));

  WebRuntimeFeatures::EnableScheduledScriptStreaming(
      base::FeatureList::IsEnabled(features::kScheduledScriptStreaming));

  WebRuntimeFeatures::EnableMergeBlockingNonBlockingPools(
      base::FeatureList::IsEnabled(base::kMergeBlockingNonBlockingPools));

  if (base::FeatureList::IsEnabled(features::kLazyFrameLoading))
    WebRuntimeFeatures::EnableLazyFrameLoading(true);
  if (base::FeatureList::IsEnabled(features::kLazyFrameVisibleLoadTimeMetrics))
    WebRuntimeFeatures::EnableLazyFrameVisibleLoadTimeMetrics(true);
  if (base::FeatureList::IsEnabled(features::kLazyImageLoading))
    WebRuntimeFeatures::EnableLazyImageLoading(true);
  if (base::FeatureList::IsEnabled(features::kLazyImageVisibleLoadTimeMetrics))
    WebRuntimeFeatures::EnableLazyImageVisibleLoadTimeMetrics(true);

   WebRuntimeFeatures::EnableV8ContextSnapshot(
       base::FeatureList::IsEnabled(features::kV8ContextSnapshot));
 
   WebRuntimeFeatures::EnablePictureInPicture(
       base::FeatureList::IsEnabled(media::kPictureInPicture));
 
  WebRuntimeFeatures::EnableCacheInlineScriptCode(
      base::FeatureList::IsEnabled(features::kCacheInlineScriptCode));

  WebRuntimeFeatures::EnableIsolatedCodeCache(
      base::FeatureList::IsEnabled(net::features::kIsolatedCodeCache));

  if (base::FeatureList::IsEnabled(features::kSignedHTTPExchange)) {
    WebRuntimeFeatures::EnableSignedHTTPExchange(true);
    WebRuntimeFeatures::EnablePreloadImageSrcSetEnabled(true);
  }

  WebRuntimeFeatures::EnableNestedWorkers(
      base::FeatureList::IsEnabled(blink::features::kNestedWorkers));

  if (base::FeatureList::IsEnabled(
          features::kExperimentalProductivityFeatures)) {
    WebRuntimeFeatures::EnableExperimentalProductivityFeatures(true);
  }

  if (base::FeatureList::IsEnabled(features::kPageLifecycle))
    WebRuntimeFeatures::EnablePageLifecycle(true);

#if defined(OS_ANDROID)
  if (base::FeatureList::IsEnabled(features::kDisplayCutoutAPI) &&
      base::android::BuildInfo::GetInstance()->sdk_int() >=
          base::android::SDK_VERSION_P) {
    WebRuntimeFeatures::EnableDisplayCutoutAPI(true);
  }
#endif

  if (command_line.HasSwitch(switches::kEnableAccessibilityObjectModel))
    WebRuntimeFeatures::EnableAccessibilityObjectModel(true);

  if (base::FeatureList::IsEnabled(blink::features::kWritableFilesAPI))
    WebRuntimeFeatures::EnableFeatureFromString(""WritableFiles"", true);


  if (command_line.HasSwitch(
          switches::kDisableOriginTrialControlledBlinkFeatures)) {
    WebRuntimeFeatures::EnableOriginTrialControlledFeatures(false);
  }

  WebRuntimeFeatures::EnableAutoplayIgnoresWebAudio(
      base::FeatureList::IsEnabled(media::kAutoplayIgnoreWebAudio));

#if defined(OS_ANDROID)
  WebRuntimeFeatures::EnableMediaControlsExpandGesture(
      base::FeatureList::IsEnabled(media::kMediaControlsExpandGesture));
#endif

  for (const std::string& feature :
       FeaturesFromSwitch(command_line, switches::kEnableBlinkFeatures)) {
    WebRuntimeFeatures::EnableFeatureFromString(feature, true);
  }
  for (const std::string& feature :
       FeaturesFromSwitch(command_line, switches::kDisableBlinkFeatures)) {
    WebRuntimeFeatures::EnableFeatureFromString(feature, false);
  }

  WebRuntimeFeatures::EnablePortals(
      base::FeatureList::IsEnabled(blink::features::kPortals));

  if (!base::FeatureList::IsEnabled(features::kBackgroundFetch))
    WebRuntimeFeatures::EnableBackgroundFetch(false);

  WebRuntimeFeatures::EnableBackgroundFetchUploads(
      base::FeatureList::IsEnabled(features::kBackgroundFetchUploads));

  WebRuntimeFeatures::EnableNoHoverAfterLayoutChange(
      base::FeatureList::IsEnabled(features::kNoHoverAfterLayoutChange));

  WebRuntimeFeatures::EnableJankTracking(
      base::FeatureList::IsEnabled(blink::features::kJankTracking) ||
      enableExperimentalWebPlatformFeatures);

  WebRuntimeFeatures::EnableNoHoverDuringScroll(
      base::FeatureList::IsEnabled(features::kNoHoverDuringScroll));
}
","void SetRuntimeFeaturesDefaultsAndUpdateFromArgs(
    const base::CommandLine& command_line) {
  bool enableExperimentalWebPlatformFeatures = command_line.HasSwitch(
      switches::kEnableExperimentalWebPlatformFeatures);
  if (enableExperimentalWebPlatformFeatures)
    WebRuntimeFeatures::EnableExperimentalFeatures(true);

  SetRuntimeFeatureDefaultsForPlatform();


  WebRuntimeFeatures::EnableOriginTrials(
      base::FeatureList::IsEnabled(features::kOriginTrials));

  if (!base::FeatureList::IsEnabled(features::kWebUsb))
    WebRuntimeFeatures::EnableWebUsb(false);

  WebRuntimeFeatures::EnableBlinkHeapIncrementalMarking(
      base::FeatureList::IsEnabled(features::kBlinkHeapIncrementalMarking));

  WebRuntimeFeatures::EnableBlinkHeapUnifiedGarbageCollection(
      base::FeatureList::IsEnabled(
          features::kBlinkHeapUnifiedGarbageCollection));

  if (base::FeatureList::IsEnabled(features::kBloatedRendererDetection))
    WebRuntimeFeatures::EnableBloatedRendererDetection(true);

  if (command_line.HasSwitch(switches::kDisableDatabases))
    WebRuntimeFeatures::EnableDatabase(false);

  if (command_line.HasSwitch(switches::kDisableNotifications)) {
    WebRuntimeFeatures::EnableNotifications(false);

    WebRuntimeFeatures::EnablePushMessaging(false);
  }

  if (!base::FeatureList::IsEnabled(features::kNotificationContentImage))
    WebRuntimeFeatures::EnableNotificationContentImage(false);

  WebRuntimeFeatures::EnableSharedArrayBuffer(
      base::FeatureList::IsEnabled(features::kSharedArrayBuffer) ||
      base::FeatureList::IsEnabled(features::kWebAssemblyThreads));

  if (command_line.HasSwitch(switches::kDisableSharedWorkers))
    WebRuntimeFeatures::EnableSharedWorker(false);

  if (command_line.HasSwitch(switches::kDisableSpeechAPI))
    WebRuntimeFeatures::EnableScriptedSpeech(false);

  if (command_line.HasSwitch(switches::kDisableFileSystem))
    WebRuntimeFeatures::EnableFileSystem(false);

  if (!command_line.HasSwitch(switches::kDisableAcceleratedJpegDecoding))
    WebRuntimeFeatures::EnableDecodeToYUV(true);

#if defined(SUPPORT_WEBGL2_COMPUTE_CONTEXT)
  if (command_line.HasSwitch(switches::kEnableWebGL2ComputeContext)) {
    WebRuntimeFeatures::EnableWebGL2ComputeContext(true);
  }
#endif

  if (command_line.HasSwitch(switches::kEnableWebGLDraftExtensions))
    WebRuntimeFeatures::EnableWebGLDraftExtensions(true);

  if (command_line.HasSwitch(switches::kEnableAutomation) ||
      command_line.HasSwitch(switches::kHeadless)) {
    WebRuntimeFeatures::EnableAutomationControlled(true);
  }

#if defined(OS_MACOSX)
  const bool enable_canvas_2d_image_chromium =
      command_line.HasSwitch(
          switches::kEnableGpuMemoryBufferCompositorResources) &&
      !command_line.HasSwitch(switches::kDisable2dCanvasImageChromium) &&
      !command_line.HasSwitch(switches::kDisableGpu) &&
      base::FeatureList::IsEnabled(features::kCanvas2DImageChromium);
#else
  constexpr bool enable_canvas_2d_image_chromium = false;
#endif
  WebRuntimeFeatures::EnableCanvas2dImageChromium(
      enable_canvas_2d_image_chromium);

#if defined(OS_MACOSX)
  const bool enable_web_gl_image_chromium =
      command_line.HasSwitch(
          switches::kEnableGpuMemoryBufferCompositorResources) &&
      !command_line.HasSwitch(switches::kDisableWebGLImageChromium) &&
      !command_line.HasSwitch(switches::kDisableGpu) &&
      base::FeatureList::IsEnabled(features::kWebGLImageChromium);
#else
  const bool enable_web_gl_image_chromium =
      command_line.HasSwitch(switches::kEnableWebGLImageChromium);
#endif
  WebRuntimeFeatures::EnableWebGLImageChromium(enable_web_gl_image_chromium);

  if (command_line.HasSwitch(switches::kForceOverlayFullscreenVideo))
    WebRuntimeFeatures::ForceOverlayFullscreenVideo(true);

  if (ui::IsOverlayScrollbarEnabled())
    WebRuntimeFeatures::EnableOverlayScrollbars(true);

  if (command_line.HasSwitch(switches::kEnablePreciseMemoryInfo))
    WebRuntimeFeatures::EnablePreciseMemoryInfo(true);

  if (command_line.HasSwitch(switches::kEnablePrintBrowser))
    WebRuntimeFeatures::EnablePrintBrowser(true);

  if (command_line.HasSwitch(switches::kEnableNetworkInformationDownlinkMax) ||
      enableExperimentalWebPlatformFeatures) {
    WebRuntimeFeatures::EnableNetInfoDownlinkMax(true);
  }

  if (command_line.HasSwitch(switches::kReducedReferrerGranularity))
    WebRuntimeFeatures::EnableReducedReferrerGranularity(true);

  if (command_line.HasSwitch(switches::kDisablePermissionsAPI))
    WebRuntimeFeatures::EnablePermissionsAPI(false);

  if (command_line.HasSwitch(switches::kDisableV8IdleTasks))
    WebRuntimeFeatures::EnableV8IdleTasks(false);
  else
    WebRuntimeFeatures::EnableV8IdleTasks(true);

  if (command_line.HasSwitch(switches::kEnableUnsafeWebGPU))
    WebRuntimeFeatures::EnableWebGPU(true);

  if (command_line.HasSwitch(switches::kEnableWebVR))
    WebRuntimeFeatures::EnableWebVR(true);

  if (base::FeatureList::IsEnabled(features::kWebXr))
    WebRuntimeFeatures::EnableWebXR(true);

  if (base::FeatureList::IsEnabled(features::kWebXrGamepadSupport))
    WebRuntimeFeatures::EnableWebXRGamepadSupport(true);

  if (base::FeatureList::IsEnabled(features::kWebXrHitTest))
    WebRuntimeFeatures::EnableWebXRHitTest(true);

  if (command_line.HasSwitch(switches::kDisablePresentationAPI))
    WebRuntimeFeatures::EnablePresentationAPI(false);

  if (command_line.HasSwitch(switches::kDisableRemotePlaybackAPI))
    WebRuntimeFeatures::EnableRemotePlaybackAPI(false);

  WebRuntimeFeatures::EnableSecMetadata(
      base::FeatureList::IsEnabled(features::kSecMetadata) ||
      enableExperimentalWebPlatformFeatures);

  WebRuntimeFeatures::EnableUserActivationV2(
      base::FeatureList::IsEnabled(features::kUserActivationV2));

  if (base::FeatureList::IsEnabled(features::kScrollAnchorSerialization))
    WebRuntimeFeatures::EnableScrollAnchorSerialization(true);

  if (command_line.HasSwitch(switches::kEnableBlinkGenPropertyTrees))
    WebRuntimeFeatures::EnableFeatureFromString(""BlinkGenPropertyTrees"", true);

  if (command_line.HasSwitch(switches::kEnableSlimmingPaintV2))
    WebRuntimeFeatures::EnableFeatureFromString(""SlimmingPaintV2"", true);

  WebRuntimeFeatures::EnablePassiveDocumentEventListeners(
      base::FeatureList::IsEnabled(features::kPassiveDocumentEventListeners));

  WebRuntimeFeatures::EnablePassiveDocumentWheelEventListeners(
      base::FeatureList::IsEnabled(
          features::kPassiveDocumentWheelEventListeners));

  WebRuntimeFeatures::EnableFeatureFromString(
      ""FontCacheScaling"",
      base::FeatureList::IsEnabled(features::kFontCacheScaling));

  WebRuntimeFeatures::EnableFeatureFromString(
      ""FontSrcLocalMatching"",
      base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));

  WebRuntimeFeatures::EnableFeatureFromString(
      ""FramebustingNeedsSameOriginOrUserGesture"",
      base::FeatureList::IsEnabled(
          features::kFramebustingNeedsSameOriginOrUserGesture));

  if (command_line.HasSwitch(switches::kDisableBackgroundTimerThrottling))
    WebRuntimeFeatures::EnableTimerThrottlingForBackgroundTabs(false);

  WebRuntimeFeatures::EnableExpensiveBackgroundTimerThrottling(
      base::FeatureList::IsEnabled(
          features::kExpensiveBackgroundTimerThrottling));

  if (base::FeatureList::IsEnabled(features::kHeapCompaction))
    WebRuntimeFeatures::EnableHeapCompaction(true);

  WebRuntimeFeatures::EnableRenderingPipelineThrottling(
      base::FeatureList::IsEnabled(features::kRenderingPipelineThrottling));

  WebRuntimeFeatures::EnableTimerThrottlingForHiddenFrames(
      base::FeatureList::IsEnabled(features::kTimerThrottlingForHiddenFrames));

  if (base::FeatureList::IsEnabled(
          features::kSendBeaconThrowForBlobWithNonSimpleType))
    WebRuntimeFeatures::EnableSendBeaconThrowForBlobWithNonSimpleType(true);

#if defined(OS_ANDROID)
  if (command_line.HasSwitch(switches::kDisableMediaSessionAPI))
    WebRuntimeFeatures::EnableMediaSession(false);
#endif

  WebRuntimeFeatures::EnablePaymentRequest(
      base::FeatureList::IsEnabled(features::kWebPayments));

  if (base::FeatureList::IsEnabled(features::kServiceWorkerPaymentApps))
    WebRuntimeFeatures::EnablePaymentApp(true);

  WebRuntimeFeatures::EnableNetworkService(
      base::FeatureList::IsEnabled(network::features::kNetworkService));

  if (base::FeatureList::IsEnabled(features::kGamepadExtensions))
    WebRuntimeFeatures::EnableGamepadExtensions(true);

  if (base::FeatureList::IsEnabled(features::kGamepadVibration))
    WebRuntimeFeatures::EnableGamepadVibration(true);

  if (base::FeatureList::IsEnabled(features::kCompositeOpaqueFixedPosition))
    WebRuntimeFeatures::EnableFeatureFromString(""CompositeOpaqueFixedPosition"",
                                                true);

  if (!base::FeatureList::IsEnabled(features::kCompositeOpaqueScrollers))
    WebRuntimeFeatures::EnableFeatureFromString(""CompositeOpaqueScrollers"",
                                                false);
  if (base::FeatureList::IsEnabled(features::kCompositorTouchAction))
    WebRuntimeFeatures::EnableCompositorTouchAction(true);

  if (base::FeatureList::IsEnabled(features::kCSSFragmentIdentifiers))
    WebRuntimeFeatures::EnableCSSFragmentIdentifiers(true);

  if (!base::FeatureList::IsEnabled(features::kGenericSensor))
    WebRuntimeFeatures::EnableGenericSensor(false);

  if (base::FeatureList::IsEnabled(features::kGenericSensorExtraClasses))
    WebRuntimeFeatures::EnableGenericSensorExtraClasses(true);

  if (base::FeatureList::IsEnabled(network::features::kOutOfBlinkCORS))
    WebRuntimeFeatures::EnableOutOfBlinkCORS(true);

  WebRuntimeFeatures::EnableMediaCastOverlayButton(
      base::FeatureList::IsEnabled(media::kMediaCastOverlayButton));

  if (!base::FeatureList::IsEnabled(features::kBlockCredentialedSubresources)) {
    WebRuntimeFeatures::EnableFeatureFromString(""BlockCredentialedSubresources"",
                                                false);
  }

  if (base::FeatureList::IsEnabled(features::kRasterInducingScroll))
    WebRuntimeFeatures::EnableRasterInducingScroll(true);

  WebRuntimeFeatures::EnableFeatureFromString(
      ""AllowContentInitiatedDataUrlNavigations"",
      base::FeatureList::IsEnabled(
          features::kAllowContentInitiatedDataUrlNavigations));

#if defined(OS_ANDROID)
  if (base::FeatureList::IsEnabled(features::kWebNfc))
    WebRuntimeFeatures::EnableWebNfc(true);
#endif

  WebRuntimeFeatures::EnableWebAuth(
      base::FeatureList::IsEnabled(features::kWebAuth));

  WebRuntimeFeatures::EnableWebAuthGetTransports(
      base::FeatureList::IsEnabled(features::kWebAuthGetTransports) ||
      enableExperimentalWebPlatformFeatures);

  WebRuntimeFeatures::EnableClientPlaceholdersForServerLoFi(
      base::GetFieldTrialParamValue(""PreviewsClientLoFi"",
                                    ""replace_server_placeholders"") != ""false"");

  WebRuntimeFeatures::EnableResourceLoadScheduler(
      base::FeatureList::IsEnabled(features::kResourceLoadScheduler));

  if (base::FeatureList::IsEnabled(features::kLayeredAPI))
    WebRuntimeFeatures::EnableLayeredAPI(true);

  if (base::FeatureList::IsEnabled(blink::features::kLayoutNG))
    WebRuntimeFeatures::EnableLayoutNG(true);

  WebRuntimeFeatures::EnableLazyInitializeMediaControls(
      base::FeatureList::IsEnabled(features::kLazyInitializeMediaControls));

  WebRuntimeFeatures::EnableMediaEngagementBypassAutoplayPolicies(
      base::FeatureList::IsEnabled(
          media::kMediaEngagementBypassAutoplayPolicies));

  WebRuntimeFeatures::EnableOverflowIconsForMediaControls(
      base::FeatureList::IsEnabled(media::kOverflowIconsForMediaControls));

  WebRuntimeFeatures::EnableAllowActivationDelegationAttr(
      base::FeatureList::IsEnabled(features::kAllowActivationDelegationAttr));

  WebRuntimeFeatures::EnableModernMediaControls(
      base::FeatureList::IsEnabled(media::kUseModernMediaControls));

  WebRuntimeFeatures::EnableWorkStealingInScriptRunner(
      base::FeatureList::IsEnabled(features::kWorkStealingInScriptRunner));

  WebRuntimeFeatures::EnableScheduledScriptStreaming(
      base::FeatureList::IsEnabled(features::kScheduledScriptStreaming));

  WebRuntimeFeatures::EnableMergeBlockingNonBlockingPools(
      base::FeatureList::IsEnabled(base::kMergeBlockingNonBlockingPools));

  if (base::FeatureList::IsEnabled(features::kLazyFrameLoading))
    WebRuntimeFeatures::EnableLazyFrameLoading(true);
  if (base::FeatureList::IsEnabled(features::kLazyFrameVisibleLoadTimeMetrics))
    WebRuntimeFeatures::EnableLazyFrameVisibleLoadTimeMetrics(true);
  if (base::FeatureList::IsEnabled(features::kLazyImageLoading))
    WebRuntimeFeatures::EnableLazyImageLoading(true);
  if (base::FeatureList::IsEnabled(features::kLazyImageVisibleLoadTimeMetrics))
    WebRuntimeFeatures::EnableLazyImageVisibleLoadTimeMetrics(true);

   WebRuntimeFeatures::EnableV8ContextSnapshot(
       base::FeatureList::IsEnabled(features::kV8ContextSnapshot));
 
  WebRuntimeFeatures::EnableRequireCSSExtensionForFile(
      base::FeatureList::IsEnabled(features::kRequireCSSExtensionForFile));
   WebRuntimeFeatures::EnablePictureInPicture(
       base::FeatureList::IsEnabled(media::kPictureInPicture));
 
  WebRuntimeFeatures::EnableCacheInlineScriptCode(
      base::FeatureList::IsEnabled(features::kCacheInlineScriptCode));

  WebRuntimeFeatures::EnableIsolatedCodeCache(
      base::FeatureList::IsEnabled(net::features::kIsolatedCodeCache));

  if (base::FeatureList::IsEnabled(features::kSignedHTTPExchange)) {
    WebRuntimeFeatures::EnableSignedHTTPExchange(true);
    WebRuntimeFeatures::EnablePreloadImageSrcSetEnabled(true);
  }

  WebRuntimeFeatures::EnableNestedWorkers(
      base::FeatureList::IsEnabled(blink::features::kNestedWorkers));

  if (base::FeatureList::IsEnabled(
          features::kExperimentalProductivityFeatures)) {
    WebRuntimeFeatures::EnableExperimentalProductivityFeatures(true);
  }

  if (base::FeatureList::IsEnabled(features::kPageLifecycle))
    WebRuntimeFeatures::EnablePageLifecycle(true);

#if defined(OS_ANDROID)
  if (base::FeatureList::IsEnabled(features::kDisplayCutoutAPI) &&
      base::android::BuildInfo::GetInstance()->sdk_int() >=
          base::android::SDK_VERSION_P) {
    WebRuntimeFeatures::EnableDisplayCutoutAPI(true);
  }
#endif

  if (command_line.HasSwitch(switches::kEnableAccessibilityObjectModel))
    WebRuntimeFeatures::EnableAccessibilityObjectModel(true);

  if (base::FeatureList::IsEnabled(blink::features::kWritableFilesAPI))
    WebRuntimeFeatures::EnableFeatureFromString(""WritableFiles"", true);


  if (command_line.HasSwitch(
          switches::kDisableOriginTrialControlledBlinkFeatures)) {
    WebRuntimeFeatures::EnableOriginTrialControlledFeatures(false);
  }

  WebRuntimeFeatures::EnableAutoplayIgnoresWebAudio(
      base::FeatureList::IsEnabled(media::kAutoplayIgnoreWebAudio));

#if defined(OS_ANDROID)
  WebRuntimeFeatures::EnableMediaControlsExpandGesture(
      base::FeatureList::IsEnabled(media::kMediaControlsExpandGesture));
#endif

  for (const std::string& feature :
       FeaturesFromSwitch(command_line, switches::kEnableBlinkFeatures)) {
    WebRuntimeFeatures::EnableFeatureFromString(feature, true);
  }
  for (const std::string& feature :
       FeaturesFromSwitch(command_line, switches::kDisableBlinkFeatures)) {
    WebRuntimeFeatures::EnableFeatureFromString(feature, false);
  }

  WebRuntimeFeatures::EnablePortals(
      base::FeatureList::IsEnabled(blink::features::kPortals));

  if (!base::FeatureList::IsEnabled(features::kBackgroundFetch))
    WebRuntimeFeatures::EnableBackgroundFetch(false);

  WebRuntimeFeatures::EnableBackgroundFetchUploads(
      base::FeatureList::IsEnabled(features::kBackgroundFetchUploads));

  WebRuntimeFeatures::EnableNoHoverAfterLayoutChange(
      base::FeatureList::IsEnabled(features::kNoHoverAfterLayoutChange));

  WebRuntimeFeatures::EnableJankTracking(
      base::FeatureList::IsEnabled(blink::features::kJankTracking) ||
      enableExperimentalWebPlatformFeatures);

  WebRuntimeFeatures::EnableNoHoverDuringScroll(
      base::FeatureList::IsEnabled(features::kNoHoverDuringScroll));
}
",C,,"  WebRuntimeFeatures::EnableRequireCSSExtensionForFile(
      base::FeatureList::IsEnabled(features::kRequireCSSExtensionForFile));
",,"@@ -422,9 +422,6 @@ void SetRuntimeFeaturesDefaultsAndUpdateFromArgs(
   WebRuntimeFeatures::EnableV8ContextSnapshot(
       base::FeatureList::IsEnabled(features::kV8ContextSnapshot));
 
-  WebRuntimeFeatures::EnableRequireCSSExtensionForFile(
-      base::FeatureList::IsEnabled(features::kRequireCSSExtensionForFile));
-
   WebRuntimeFeatures::EnablePictureInPicture(
       base::FeatureList::IsEnabled(media::kPictureInPicture));
 ",Chrome,d913f72b4875cf0814fc3f03ad7c00642097c4a4,290d578e4aa4458206ceb564744ef3d7c43c7c9a,1,"void SetRuntimeFeaturesDefaultsAndUpdateFromArgs(
    const base::CommandLine& command_line) {
  bool enableExperimentalWebPlatformFeatures = command_line.HasSwitch(
      switches::kEnableExperimentalWebPlatformFeatures);
  if (enableExperimentalWebPlatformFeatures)
    WebRuntimeFeatures::EnableExperimentalFeatures(true);

  SetRuntimeFeatureDefaultsForPlatform();

  // Begin individual features.
  // Do not add individual features above this line.

  WebRuntimeFeatures::EnableOriginTrials(
      base::FeatureList::IsEnabled(features::kOriginTrials));

  if (!base::FeatureList::IsEnabled(features::kWebUsb))
    WebRuntimeFeatures::EnableWebUsb(false);

  WebRuntimeFeatures::EnableBlinkHeapIncrementalMarking(
      base::FeatureList::IsEnabled(features::kBlinkHeapIncrementalMarking));

  WebRuntimeFeatures::EnableBlinkHeapUnifiedGarbageCollection(
      base::FeatureList::IsEnabled(
          features::kBlinkHeapUnifiedGarbageCollection));

  if (base::FeatureList::IsEnabled(features::kBloatedRendererDetection))
    WebRuntimeFeatures::EnableBloatedRendererDetection(true);

  if (command_line.HasSwitch(switches::kDisableDatabases))
    WebRuntimeFeatures::EnableDatabase(false);

  if (command_line.HasSwitch(switches::kDisableNotifications)) {
    WebRuntimeFeatures::EnableNotifications(false);

    // Chrome's Push Messaging implementation relies on Web Notifications.
    WebRuntimeFeatures::EnablePushMessaging(false);
  }

  if (!base::FeatureList::IsEnabled(features::kNotificationContentImage))
    WebRuntimeFeatures::EnableNotificationContentImage(false);

  WebRuntimeFeatures::EnableSharedArrayBuffer(
      base::FeatureList::IsEnabled(features::kSharedArrayBuffer) ||
      base::FeatureList::IsEnabled(features::kWebAssemblyThreads));

  if (command_line.HasSwitch(switches::kDisableSharedWorkers))
    WebRuntimeFeatures::EnableSharedWorker(false);

  if (command_line.HasSwitch(switches::kDisableSpeechAPI))
    WebRuntimeFeatures::EnableScriptedSpeech(false);

  if (command_line.HasSwitch(switches::kDisableFileSystem))
    WebRuntimeFeatures::EnableFileSystem(false);

  if (!command_line.HasSwitch(switches::kDisableAcceleratedJpegDecoding))
    WebRuntimeFeatures::EnableDecodeToYUV(true);

#if defined(SUPPORT_WEBGL2_COMPUTE_CONTEXT)
  if (command_line.HasSwitch(switches::kEnableWebGL2ComputeContext)) {
    WebRuntimeFeatures::EnableWebGL2ComputeContext(true);
  }
#endif

  if (command_line.HasSwitch(switches::kEnableWebGLDraftExtensions))
    WebRuntimeFeatures::EnableWebGLDraftExtensions(true);

  if (command_line.HasSwitch(switches::kEnableAutomation) ||
      command_line.HasSwitch(switches::kHeadless)) {
    WebRuntimeFeatures::EnableAutomationControlled(true);
  }

#if defined(OS_MACOSX)
  const bool enable_canvas_2d_image_chromium =
      command_line.HasSwitch(
          switches::kEnableGpuMemoryBufferCompositorResources) &&
      !command_line.HasSwitch(switches::kDisable2dCanvasImageChromium) &&
      !command_line.HasSwitch(switches::kDisableGpu) &&
      base::FeatureList::IsEnabled(features::kCanvas2DImageChromium);
#else
  constexpr bool enable_canvas_2d_image_chromium = false;
#endif
  WebRuntimeFeatures::EnableCanvas2dImageChromium(
      enable_canvas_2d_image_chromium);

#if defined(OS_MACOSX)
  const bool enable_web_gl_image_chromium =
      command_line.HasSwitch(
          switches::kEnableGpuMemoryBufferCompositorResources) &&
      !command_line.HasSwitch(switches::kDisableWebGLImageChromium) &&
      !command_line.HasSwitch(switches::kDisableGpu) &&
      base::FeatureList::IsEnabled(features::kWebGLImageChromium);
#else
  const bool enable_web_gl_image_chromium =
      command_line.HasSwitch(switches::kEnableWebGLImageChromium);
#endif
  WebRuntimeFeatures::EnableWebGLImageChromium(enable_web_gl_image_chromium);

  if (command_line.HasSwitch(switches::kForceOverlayFullscreenVideo))
    WebRuntimeFeatures::ForceOverlayFullscreenVideo(true);

  if (ui::IsOverlayScrollbarEnabled())
    WebRuntimeFeatures::EnableOverlayScrollbars(true);

  if (command_line.HasSwitch(switches::kEnablePreciseMemoryInfo))
    WebRuntimeFeatures::EnablePreciseMemoryInfo(true);

  if (command_line.HasSwitch(switches::kEnablePrintBrowser))
    WebRuntimeFeatures::EnablePrintBrowser(true);

  if (command_line.HasSwitch(switches::kEnableNetworkInformationDownlinkMax) ||
      enableExperimentalWebPlatformFeatures) {
    WebRuntimeFeatures::EnableNetInfoDownlinkMax(true);
  }

  if (command_line.HasSwitch(switches::kReducedReferrerGranularity))
    WebRuntimeFeatures::EnableReducedReferrerGranularity(true);

  if (command_line.HasSwitch(switches::kDisablePermissionsAPI))
    WebRuntimeFeatures::EnablePermissionsAPI(false);

  if (command_line.HasSwitch(switches::kDisableV8IdleTasks))
    WebRuntimeFeatures::EnableV8IdleTasks(false);
  else
    WebRuntimeFeatures::EnableV8IdleTasks(true);

  if (command_line.HasSwitch(switches::kEnableUnsafeWebGPU))
    WebRuntimeFeatures::EnableWebGPU(true);

  if (command_line.HasSwitch(switches::kEnableWebVR))
    WebRuntimeFeatures::EnableWebVR(true);

  if (base::FeatureList::IsEnabled(features::kWebXr))
    WebRuntimeFeatures::EnableWebXR(true);

  if (base::FeatureList::IsEnabled(features::kWebXrGamepadSupport))
    WebRuntimeFeatures::EnableWebXRGamepadSupport(true);

  if (base::FeatureList::IsEnabled(features::kWebXrHitTest))
    WebRuntimeFeatures::EnableWebXRHitTest(true);

  if (command_line.HasSwitch(switches::kDisablePresentationAPI))
    WebRuntimeFeatures::EnablePresentationAPI(false);

  if (command_line.HasSwitch(switches::kDisableRemotePlaybackAPI))
    WebRuntimeFeatures::EnableRemotePlaybackAPI(false);

  WebRuntimeFeatures::EnableSecMetadata(
      base::FeatureList::IsEnabled(features::kSecMetadata) ||
      enableExperimentalWebPlatformFeatures);

  WebRuntimeFeatures::EnableUserActivationV2(
      base::FeatureList::IsEnabled(features::kUserActivationV2));

  if (base::FeatureList::IsEnabled(features::kScrollAnchorSerialization))
    WebRuntimeFeatures::EnableScrollAnchorSerialization(true);

  if (command_line.HasSwitch(switches::kEnableBlinkGenPropertyTrees))
    WebRuntimeFeatures::EnableFeatureFromString(""BlinkGenPropertyTrees"", true);

  if (command_line.HasSwitch(switches::kEnableSlimmingPaintV2))
    WebRuntimeFeatures::EnableFeatureFromString(""SlimmingPaintV2"", true);

  WebRuntimeFeatures::EnablePassiveDocumentEventListeners(
      base::FeatureList::IsEnabled(features::kPassiveDocumentEventListeners));

  WebRuntimeFeatures::EnablePassiveDocumentWheelEventListeners(
      base::FeatureList::IsEnabled(
          features::kPassiveDocumentWheelEventListeners));

  WebRuntimeFeatures::EnableFeatureFromString(
      ""FontCacheScaling"",
      base::FeatureList::IsEnabled(features::kFontCacheScaling));

  WebRuntimeFeatures::EnableFeatureFromString(
      ""FontSrcLocalMatching"",
      base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));

  WebRuntimeFeatures::EnableFeatureFromString(
      ""FramebustingNeedsSameOriginOrUserGesture"",
      base::FeatureList::IsEnabled(
          features::kFramebustingNeedsSameOriginOrUserGesture));

  if (command_line.HasSwitch(switches::kDisableBackgroundTimerThrottling))
    WebRuntimeFeatures::EnableTimerThrottlingForBackgroundTabs(false);

  WebRuntimeFeatures::EnableExpensiveBackgroundTimerThrottling(
      base::FeatureList::IsEnabled(
          features::kExpensiveBackgroundTimerThrottling));

  if (base::FeatureList::IsEnabled(features::kHeapCompaction))
    WebRuntimeFeatures::EnableHeapCompaction(true);

  WebRuntimeFeatures::EnableRenderingPipelineThrottling(
      base::FeatureList::IsEnabled(features::kRenderingPipelineThrottling));

  WebRuntimeFeatures::EnableTimerThrottlingForHiddenFrames(
      base::FeatureList::IsEnabled(features::kTimerThrottlingForHiddenFrames));

  if (base::FeatureList::IsEnabled(
          features::kSendBeaconThrowForBlobWithNonSimpleType))
    WebRuntimeFeatures::EnableSendBeaconThrowForBlobWithNonSimpleType(true);

#if defined(OS_ANDROID)
  if (command_line.HasSwitch(switches::kDisableMediaSessionAPI))
    WebRuntimeFeatures::EnableMediaSession(false);
#endif

  WebRuntimeFeatures::EnablePaymentRequest(
      base::FeatureList::IsEnabled(features::kWebPayments));

  if (base::FeatureList::IsEnabled(features::kServiceWorkerPaymentApps))
    WebRuntimeFeatures::EnablePaymentApp(true);

  WebRuntimeFeatures::EnableNetworkService(
      base::FeatureList::IsEnabled(network::features::kNetworkService));

  if (base::FeatureList::IsEnabled(features::kGamepadExtensions))
    WebRuntimeFeatures::EnableGamepadExtensions(true);

  if (base::FeatureList::IsEnabled(features::kGamepadVibration))
    WebRuntimeFeatures::EnableGamepadVibration(true);

  if (base::FeatureList::IsEnabled(features::kCompositeOpaqueFixedPosition))
    WebRuntimeFeatures::EnableFeatureFromString(""CompositeOpaqueFixedPosition"",
                                                true);

  if (!base::FeatureList::IsEnabled(features::kCompositeOpaqueScrollers))
    WebRuntimeFeatures::EnableFeatureFromString(""CompositeOpaqueScrollers"",
                                                false);
  if (base::FeatureList::IsEnabled(features::kCompositorTouchAction))
    WebRuntimeFeatures::EnableCompositorTouchAction(true);

  if (base::FeatureList::IsEnabled(features::kCSSFragmentIdentifiers))
    WebRuntimeFeatures::EnableCSSFragmentIdentifiers(true);

  if (!base::FeatureList::IsEnabled(features::kGenericSensor))
    WebRuntimeFeatures::EnableGenericSensor(false);

  if (base::FeatureList::IsEnabled(features::kGenericSensorExtraClasses))
    WebRuntimeFeatures::EnableGenericSensorExtraClasses(true);

  if (base::FeatureList::IsEnabled(network::features::kOutOfBlinkCORS))
    WebRuntimeFeatures::EnableOutOfBlinkCORS(true);

  WebRuntimeFeatures::EnableMediaCastOverlayButton(
      base::FeatureList::IsEnabled(media::kMediaCastOverlayButton));

  if (!base::FeatureList::IsEnabled(features::kBlockCredentialedSubresources)) {
    WebRuntimeFeatures::EnableFeatureFromString(""BlockCredentialedSubresources"",
                                                false);
  }

  if (base::FeatureList::IsEnabled(features::kRasterInducingScroll))
    WebRuntimeFeatures::EnableRasterInducingScroll(true);

  WebRuntimeFeatures::EnableFeatureFromString(
      ""AllowContentInitiatedDataUrlNavigations"",
      base::FeatureList::IsEnabled(
          features::kAllowContentInitiatedDataUrlNavigations));

#if defined(OS_ANDROID)
  if (base::FeatureList::IsEnabled(features::kWebNfc))
    WebRuntimeFeatures::EnableWebNfc(true);
#endif

  WebRuntimeFeatures::EnableWebAuth(
      base::FeatureList::IsEnabled(features::kWebAuth));

  WebRuntimeFeatures::EnableWebAuthGetTransports(
      base::FeatureList::IsEnabled(features::kWebAuthGetTransports) ||
      enableExperimentalWebPlatformFeatures);

  WebRuntimeFeatures::EnableClientPlaceholdersForServerLoFi(
      base::GetFieldTrialParamValue(""PreviewsClientLoFi"",
                                    ""replace_server_placeholders"") != ""false"");

  WebRuntimeFeatures::EnableResourceLoadScheduler(
      base::FeatureList::IsEnabled(features::kResourceLoadScheduler));

  if (base::FeatureList::IsEnabled(features::kLayeredAPI))
    WebRuntimeFeatures::EnableLayeredAPI(true);

  if (base::FeatureList::IsEnabled(blink::features::kLayoutNG))
    WebRuntimeFeatures::EnableLayoutNG(true);

  WebRuntimeFeatures::EnableLazyInitializeMediaControls(
      base::FeatureList::IsEnabled(features::kLazyInitializeMediaControls));

  WebRuntimeFeatures::EnableMediaEngagementBypassAutoplayPolicies(
      base::FeatureList::IsEnabled(
          media::kMediaEngagementBypassAutoplayPolicies));

  WebRuntimeFeatures::EnableOverflowIconsForMediaControls(
      base::FeatureList::IsEnabled(media::kOverflowIconsForMediaControls));

  WebRuntimeFeatures::EnableAllowActivationDelegationAttr(
      base::FeatureList::IsEnabled(features::kAllowActivationDelegationAttr));

  WebRuntimeFeatures::EnableModernMediaControls(
      base::FeatureList::IsEnabled(media::kUseModernMediaControls));

  WebRuntimeFeatures::EnableWorkStealingInScriptRunner(
      base::FeatureList::IsEnabled(features::kWorkStealingInScriptRunner));

  WebRuntimeFeatures::EnableScheduledScriptStreaming(
      base::FeatureList::IsEnabled(features::kScheduledScriptStreaming));

  WebRuntimeFeatures::EnableMergeBlockingNonBlockingPools(
      base::FeatureList::IsEnabled(base::kMergeBlockingNonBlockingPools));

  if (base::FeatureList::IsEnabled(features::kLazyFrameLoading))
    WebRuntimeFeatures::EnableLazyFrameLoading(true);
  if (base::FeatureList::IsEnabled(features::kLazyFrameVisibleLoadTimeMetrics))
    WebRuntimeFeatures::EnableLazyFrameVisibleLoadTimeMetrics(true);
  if (base::FeatureList::IsEnabled(features::kLazyImageLoading))
    WebRuntimeFeatures::EnableLazyImageLoading(true);
  if (base::FeatureList::IsEnabled(features::kLazyImageVisibleLoadTimeMetrics))
    WebRuntimeFeatures::EnableLazyImageVisibleLoadTimeMetrics(true);

   WebRuntimeFeatures::EnableV8ContextSnapshot(
       base::FeatureList::IsEnabled(features::kV8ContextSnapshot));
 
//flaw_line_below:
  WebRuntimeFeatures::EnableRequireCSSExtensionForFile(
//flaw_line_below:
      base::FeatureList::IsEnabled(features::kRequireCSSExtensionForFile));
//flaw_line_below:

   WebRuntimeFeatures::EnablePictureInPicture(
       base::FeatureList::IsEnabled(media::kPictureInPicture));
 
  WebRuntimeFeatures::EnableCacheInlineScriptCode(
      base::FeatureList::IsEnabled(features::kCacheInlineScriptCode));

  WebRuntimeFeatures::EnableIsolatedCodeCache(
      base::FeatureList::IsEnabled(net::features::kIsolatedCodeCache));

  if (base::FeatureList::IsEnabled(features::kSignedHTTPExchange)) {
    WebRuntimeFeatures::EnableSignedHTTPExchange(true);
    // Make srcset on link rel=preload work with SignedHTTPExchange flag too.
    WebRuntimeFeatures::EnablePreloadImageSrcSetEnabled(true);
  }

  WebRuntimeFeatures::EnableNestedWorkers(
      base::FeatureList::IsEnabled(blink::features::kNestedWorkers));

  if (base::FeatureList::IsEnabled(
          features::kExperimentalProductivityFeatures)) {
    WebRuntimeFeatures::EnableExperimentalProductivityFeatures(true);
  }

  if (base::FeatureList::IsEnabled(features::kPageLifecycle))
    WebRuntimeFeatures::EnablePageLifecycle(true);

#if defined(OS_ANDROID)
  if (base::FeatureList::IsEnabled(features::kDisplayCutoutAPI) &&
      base::android::BuildInfo::GetInstance()->sdk_int() >=
          base::android::SDK_VERSION_P) {
    // Display Cutout is limited to Android P+.
    WebRuntimeFeatures::EnableDisplayCutoutAPI(true);
  }
#endif

  if (command_line.HasSwitch(switches::kEnableAccessibilityObjectModel))
    WebRuntimeFeatures::EnableAccessibilityObjectModel(true);

  if (base::FeatureList::IsEnabled(blink::features::kWritableFilesAPI))
    WebRuntimeFeatures::EnableFeatureFromString(""WritableFiles"", true);

  // End individual features.
  // Do not add individual features below this line.

  if (command_line.HasSwitch(
          switches::kDisableOriginTrialControlledBlinkFeatures)) {
    WebRuntimeFeatures::EnableOriginTrialControlledFeatures(false);
  }

  WebRuntimeFeatures::EnableAutoplayIgnoresWebAudio(
      base::FeatureList::IsEnabled(media::kAutoplayIgnoreWebAudio));

#if defined(OS_ANDROID)
  WebRuntimeFeatures::EnableMediaControlsExpandGesture(
      base::FeatureList::IsEnabled(media::kMediaControlsExpandGesture));
#endif

  // Enable explicitly enabled features, and then disable explicitly disabled
  // ones.
  for (const std::string& feature :
       FeaturesFromSwitch(command_line, switches::kEnableBlinkFeatures)) {
    WebRuntimeFeatures::EnableFeatureFromString(feature, true);
  }
  for (const std::string& feature :
       FeaturesFromSwitch(command_line, switches::kDisableBlinkFeatures)) {
    WebRuntimeFeatures::EnableFeatureFromString(feature, false);
  }

  WebRuntimeFeatures::EnablePortals(
      base::FeatureList::IsEnabled(blink::features::kPortals));

  if (!base::FeatureList::IsEnabled(features::kBackgroundFetch))
    WebRuntimeFeatures::EnableBackgroundFetch(false);

  WebRuntimeFeatures::EnableBackgroundFetchUploads(
      base::FeatureList::IsEnabled(features::kBackgroundFetchUploads));

  WebRuntimeFeatures::EnableNoHoverAfterLayoutChange(
      base::FeatureList::IsEnabled(features::kNoHoverAfterLayoutChange));

  WebRuntimeFeatures::EnableJankTracking(
      base::FeatureList::IsEnabled(blink::features::kJankTracking) ||
      enableExperimentalWebPlatformFeatures);

  WebRuntimeFeatures::EnableNoHoverDuringScroll(
      base::FeatureList::IsEnabled(features::kNoHoverDuringScroll));
}
"
9441,187177,,Remote,Not required,,CVE-2018-16075,https://www.cvedetails.com/cve/CVE-2018-16075/,CWE-254,High,Partial,,,2019-06-27,2.6,Insufficient file type enforcement in Blink in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to obtain local file data via a crafted HTML page.,2019-07-01,,1,https://github.com/chromium/chromium/commit/d913f72b4875cf0814fc3f03ad7c00642097c4a4,d913f72b4875cf0814fc3f03ad7c00642097c4a4,"Remove RequireCSSExtensionForFile runtime enabled flag.

The feature has long since been stable (since M64) and doesn't seem
to be a need for this flag.

BUG=788936

Change-Id: I666390b869289c328acb4a2daa5bf4154e1702c0
Reviewed-on: https://chromium-review.googlesource.com/c/1324143
Reviewed-by: Mike West <mkwst@chromium.org>
Reviewed-by: Camille Lamy <clamy@chromium.org>
Commit-Queue: Dave Tapuska <dtapuska@chromium.org>
Cr-Commit-Position: refs/heads/master@{#607329}",3,third_party/blink/renderer/core/loader/resource/css_style_sheet_resource.cc,"{""sha"": ""a55db99e7b7c27fa4dbf950862d23452a1777360"", ""filename"": ""content/child/runtime_features.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/child/runtime_features.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/child/runtime_features.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/child/runtime_features.cc?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -422,9 +422,6 @@ void SetRuntimeFeaturesDefaultsAndUpdateFromArgs(\n   WebRuntimeFeatures::EnableV8ContextSnapshot(\n       base::FeatureList::IsEnabled(features::kV8ContextSnapshot));\n \n-  WebRuntimeFeatures::EnableRequireCSSExtensionForFile(\n-      base::FeatureList::IsEnabled(features::kRequireCSSExtensionForFile));\n-\n   WebRuntimeFeatures::EnablePictureInPicture(\n       base::FeatureList::IsEnabled(media::kPictureInPicture));\n ""}<_**next**_>{""sha"": ""0d7975c9b2bf75277a90f0437b8f1b2330b3e812"", ""filename"": ""content/public/common/content_features.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/public/common/content_features.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/public/common/content_features.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/common/content_features.cc?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -351,10 +351,6 @@ const base::Feature kRasterInducingScroll{\""RasterInducingScroll\"",\n const base::Feature kRenderingPipelineThrottling{\n     \""RenderingPipelineThrottling\"", base::FEATURE_ENABLED_BY_DEFAULT};\n \n-// When loading CSS from a 'file:' URL, require a CSS-like file extension.\n-const base::Feature kRequireCSSExtensionForFile{\n-    \""RequireCSSExtensionForFile\"", base::FEATURE_ENABLED_BY_DEFAULT};\n-\n // Enables resampling input events on main thread.\n const base::Feature kResamplingInputEvents{\""ResamplingInputEvents\"",\n                                            base::FEATURE_DISABLED_BY_DEFAULT};""}<_**next**_>{""sha"": ""9c7e5359864aa8e4e933a05f5d87797b1bfa3b0c"", ""filename"": ""content/public/common/content_features.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/public/common/content_features.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/public/common/content_features.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/common/content_features.h?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -83,7 +83,6 @@ CONTENT_EXPORT extern const base::Feature kPepper3DImageChromium;\n CONTENT_EXPORT extern const base::Feature kPurgeAndSuspend;\n CONTENT_EXPORT extern const base::Feature kRasterInducingScroll;\n CONTENT_EXPORT extern const base::Feature kRenderingPipelineThrottling;\n-CONTENT_EXPORT extern const base::Feature kRequireCSSExtensionForFile;\n CONTENT_EXPORT extern const base::Feature kResamplingInputEvents;\n CONTENT_EXPORT extern const base::Feature kResourceLoadScheduler;\n CONTENT_EXPORT extern const base::Feature""}<_**next**_>{""sha"": ""e09d2a228d9eea3d0af4afd1718db9bf97020915"", ""filename"": ""third_party/blink/public/platform/web_runtime_features.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/public/platform/web_runtime_features.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/public/platform/web_runtime_features.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_runtime_features.h?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -150,7 +150,6 @@ class WebRuntimeFeatures {\n   BLINK_PLATFORM_EXPORT static void EnableReducedReferrerGranularity(bool);\n   BLINK_PLATFORM_EXPORT static void EnableRemotePlaybackAPI(bool);\n   BLINK_PLATFORM_EXPORT static void EnableRenderingPipelineThrottling(bool);\n-  BLINK_PLATFORM_EXPORT static void EnableRequireCSSExtensionForFile(bool);\n   BLINK_PLATFORM_EXPORT static void EnableResourceLoadScheduler(bool);\n   BLINK_PLATFORM_EXPORT static void EnableScriptedSpeech(bool);\n   BLINK_PLATFORM_EXPORT static void EnableScrollAnchorSerialization(bool);""}<_**next**_>{""sha"": ""ca623be21e14ea7326fc72b36fed0ca86d6bed66"", ""filename"": ""third_party/blink/renderer/core/loader/resource/css_style_sheet_resource.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/core/loader/resource/css_style_sheet_resource.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/core/loader/resource/css_style_sheet_resource.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/loader/resource/css_style_sheet_resource.cc?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -178,9 +178,7 @@ bool CSSStyleSheetResource::CanUseSheet(const CSSParserContext* parser_context,\n         parser_context->CountDeprecation(\n             WebFeature::kLocalCSSFileExtensionRejected);\n       }\n-      if (RuntimeEnabledFeatures::RequireCSSExtensionForFileEnabled()) {\n-        return false;\n-      }\n+      return false;\n     }\n   }\n ""}<_**next**_>{""sha"": ""395670e974edd446c7fb6926f66a30b4dc2ac910"", ""filename"": ""third_party/blink/renderer/platform/exported/web_runtime_features.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/platform/exported/web_runtime_features.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/platform/exported/web_runtime_features.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/exported/web_runtime_features.cc?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -440,10 +440,6 @@ void WebRuntimeFeatures::EnableRenderingPipelineThrottling(bool enable) {\n   RuntimeEnabledFeatures::SetRenderingPipelineThrottlingEnabled(enable);\n }\n \n-void WebRuntimeFeatures::EnableRequireCSSExtensionForFile(bool enable) {\n-  RuntimeEnabledFeatures::SetRequireCSSExtensionForFileEnabled(enable);\n-}\n-\n void WebRuntimeFeatures::EnableResourceLoadScheduler(bool enable) {\n   RuntimeEnabledFeatures::SetResourceLoadSchedulerEnabled(enable);\n }""}<_**next**_>{""sha"": ""99edfef487c48d78a59f39b209b7867aea19d02b"", ""filename"": ""third_party/blink/renderer/platform/runtime_enabled_features.json5"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/platform/runtime_enabled_features.json5"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/platform/runtime_enabled_features.json5"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/runtime_enabled_features.json5?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -1025,10 +1025,6 @@\n       name: \""RenderingPipelineThrottling\"",\n       status: \""stable\"",\n     },\n-    {\n-      name: \""RequireCSSExtensionForFile\"",\n-      status: \""stable\"",\n-    },\n     {\n       name: \""ResourceLoadScheduler\"",\n       status: \""experimental\"",""}","bool CSSStyleSheetResource::CanUseSheet(const CSSParserContext* parser_context,
                                        MIMETypeCheck mime_type_check) const {
  if (ErrorOccurred())
    return false;

  KURL sheet_url = GetResponse().Url();
  if (sheet_url.IsLocalFile()) {
    if (parser_context) {
      parser_context->Count(WebFeature::kLocalCSSFile);
    }
    String extension;
    int last_dot = sheet_url.LastPathComponent().ReverseFind('.');
    if (last_dot != -1)
      extension = sheet_url.LastPathComponent().Substring(last_dot + 1);
    if (!EqualIgnoringASCIICase(
            MIMETypeRegistry::GetMIMETypeForExtension(extension), ""text/css"")) {
      if (parser_context) {
         parser_context->CountDeprecation(
             WebFeature::kLocalCSSFileExtensionRejected);
       }
      return false;
     }
   }
 
  if (mime_type_check == MIMETypeCheck::kLax)
    return true;
  AtomicString content_type = HttpContentType();
  return content_type.IsEmpty() ||
         DeprecatedEqualIgnoringCase(content_type, ""text/css"") ||
         DeprecatedEqualIgnoringCase(content_type,
                                     ""application/x-unknown-content-type"");
}
","bool CSSStyleSheetResource::CanUseSheet(const CSSParserContext* parser_context,
                                        MIMETypeCheck mime_type_check) const {
  if (ErrorOccurred())
    return false;

  KURL sheet_url = GetResponse().Url();
  if (sheet_url.IsLocalFile()) {
    if (parser_context) {
      parser_context->Count(WebFeature::kLocalCSSFile);
    }
    String extension;
    int last_dot = sheet_url.LastPathComponent().ReverseFind('.');
    if (last_dot != -1)
      extension = sheet_url.LastPathComponent().Substring(last_dot + 1);
    if (!EqualIgnoringASCIICase(
            MIMETypeRegistry::GetMIMETypeForExtension(extension), ""text/css"")) {
      if (parser_context) {
         parser_context->CountDeprecation(
             WebFeature::kLocalCSSFileExtensionRejected);
       }
      if (RuntimeEnabledFeatures::RequireCSSExtensionForFileEnabled()) {
        return false;
      }
     }
   }
 
  if (mime_type_check == MIMETypeCheck::kLax)
    return true;
  AtomicString content_type = HttpContentType();
  return content_type.IsEmpty() ||
         DeprecatedEqualIgnoringCase(content_type, ""text/css"") ||
         DeprecatedEqualIgnoringCase(content_type,
                                     ""application/x-unknown-content-type"");
}
",C,"      return false;
","      if (RuntimeEnabledFeatures::RequireCSSExtensionForFileEnabled()) {
        return false;
      }
",,"@@ -178,9 +178,7 @@ bool CSSStyleSheetResource::CanUseSheet(const CSSParserContext* parser_context,
         parser_context->CountDeprecation(
             WebFeature::kLocalCSSFileExtensionRejected);
       }
-      if (RuntimeEnabledFeatures::RequireCSSExtensionForFileEnabled()) {
-        return false;
-      }
+      return false;
     }
   }
 ",Chrome,d913f72b4875cf0814fc3f03ad7c00642097c4a4,290d578e4aa4458206ceb564744ef3d7c43c7c9a,1,"bool CSSStyleSheetResource::CanUseSheet(const CSSParserContext* parser_context,
                                        MIMETypeCheck mime_type_check) const {
  if (ErrorOccurred())
    return false;

  // For `file:` URLs, we may need to be a little more strict than the below.
  // Though we'll likely change this in the future, for the moment we're going
  // to enforce a file-extension requirement on stylesheets loaded from `file:`
  // URLs and see how far it gets us.
  KURL sheet_url = GetResponse().Url();
  if (sheet_url.IsLocalFile()) {
    if (parser_context) {
      parser_context->Count(WebFeature::kLocalCSSFile);
    }
    // Grab |sheet_url|'s filename's extension (if present), and check whether
    // or not it maps to a `text/css` MIME type:
    String extension;
    int last_dot = sheet_url.LastPathComponent().ReverseFind('.');
    if (last_dot != -1)
      extension = sheet_url.LastPathComponent().Substring(last_dot + 1);
    if (!EqualIgnoringASCIICase(
            MIMETypeRegistry::GetMIMETypeForExtension(extension), ""text/css"")) {
      if (parser_context) {
         parser_context->CountDeprecation(
             WebFeature::kLocalCSSFileExtensionRejected);
       }
//flaw_line_below:
      if (RuntimeEnabledFeatures::RequireCSSExtensionForFileEnabled()) {
//flaw_line_below:
        return false;
//flaw_line_below:
      }
//fix_flaw_line_below:
//      return false;
     }
   }
 
  // This check exactly matches Firefox. Note that we grab the Content-Type
  // header directly because we want to see what the value is BEFORE content
  // sniffing. Firefox does this by setting a ""type hint"" on the channel. This
  // implementation should be observationally equivalent.
  //
  // This code defaults to allowing the stylesheet for non-HTTP protocols so
  // folks can use standards mode for local HTML documents.
  if (mime_type_check == MIMETypeCheck::kLax)
    return true;
  AtomicString content_type = HttpContentType();
  return content_type.IsEmpty() ||
         DeprecatedEqualIgnoringCase(content_type, ""text/css"") ||
         DeprecatedEqualIgnoringCase(content_type,
                                     ""application/x-unknown-content-type"");
}
"
9442,187178,,Remote,Not required,,CVE-2018-16075,https://www.cvedetails.com/cve/CVE-2018-16075/,CWE-254,High,Partial,,,2019-06-27,2.6,Insufficient file type enforcement in Blink in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to obtain local file data via a crafted HTML page.,2019-07-01,,0,https://github.com/chromium/chromium/commit/d913f72b4875cf0814fc3f03ad7c00642097c4a4,d913f72b4875cf0814fc3f03ad7c00642097c4a4,"Remove RequireCSSExtensionForFile runtime enabled flag.

The feature has long since been stable (since M64) and doesn't seem
to be a need for this flag.

BUG=788936

Change-Id: I666390b869289c328acb4a2daa5bf4154e1702c0
Reviewed-on: https://chromium-review.googlesource.com/c/1324143
Reviewed-by: Mike West <mkwst@chromium.org>
Reviewed-by: Camille Lamy <clamy@chromium.org>
Commit-Queue: Dave Tapuska <dtapuska@chromium.org>
Cr-Commit-Position: refs/heads/master@{#607329}",2,third_party/blink/renderer/platform/exported/web_runtime_features.cc,"{""sha"": ""a55db99e7b7c27fa4dbf950862d23452a1777360"", ""filename"": ""content/child/runtime_features.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/child/runtime_features.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/child/runtime_features.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/child/runtime_features.cc?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -422,9 +422,6 @@ void SetRuntimeFeaturesDefaultsAndUpdateFromArgs(\n   WebRuntimeFeatures::EnableV8ContextSnapshot(\n       base::FeatureList::IsEnabled(features::kV8ContextSnapshot));\n \n-  WebRuntimeFeatures::EnableRequireCSSExtensionForFile(\n-      base::FeatureList::IsEnabled(features::kRequireCSSExtensionForFile));\n-\n   WebRuntimeFeatures::EnablePictureInPicture(\n       base::FeatureList::IsEnabled(media::kPictureInPicture));\n ""}<_**next**_>{""sha"": ""0d7975c9b2bf75277a90f0437b8f1b2330b3e812"", ""filename"": ""content/public/common/content_features.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/public/common/content_features.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/public/common/content_features.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/common/content_features.cc?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -351,10 +351,6 @@ const base::Feature kRasterInducingScroll{\""RasterInducingScroll\"",\n const base::Feature kRenderingPipelineThrottling{\n     \""RenderingPipelineThrottling\"", base::FEATURE_ENABLED_BY_DEFAULT};\n \n-// When loading CSS from a 'file:' URL, require a CSS-like file extension.\n-const base::Feature kRequireCSSExtensionForFile{\n-    \""RequireCSSExtensionForFile\"", base::FEATURE_ENABLED_BY_DEFAULT};\n-\n // Enables resampling input events on main thread.\n const base::Feature kResamplingInputEvents{\""ResamplingInputEvents\"",\n                                            base::FEATURE_DISABLED_BY_DEFAULT};""}<_**next**_>{""sha"": ""9c7e5359864aa8e4e933a05f5d87797b1bfa3b0c"", ""filename"": ""content/public/common/content_features.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/public/common/content_features.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/content/public/common/content_features.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/common/content_features.h?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -83,7 +83,6 @@ CONTENT_EXPORT extern const base::Feature kPepper3DImageChromium;\n CONTENT_EXPORT extern const base::Feature kPurgeAndSuspend;\n CONTENT_EXPORT extern const base::Feature kRasterInducingScroll;\n CONTENT_EXPORT extern const base::Feature kRenderingPipelineThrottling;\n-CONTENT_EXPORT extern const base::Feature kRequireCSSExtensionForFile;\n CONTENT_EXPORT extern const base::Feature kResamplingInputEvents;\n CONTENT_EXPORT extern const base::Feature kResourceLoadScheduler;\n CONTENT_EXPORT extern const base::Feature""}<_**next**_>{""sha"": ""e09d2a228d9eea3d0af4afd1718db9bf97020915"", ""filename"": ""third_party/blink/public/platform/web_runtime_features.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/public/platform/web_runtime_features.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/public/platform/web_runtime_features.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_runtime_features.h?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -150,7 +150,6 @@ class WebRuntimeFeatures {\n   BLINK_PLATFORM_EXPORT static void EnableReducedReferrerGranularity(bool);\n   BLINK_PLATFORM_EXPORT static void EnableRemotePlaybackAPI(bool);\n   BLINK_PLATFORM_EXPORT static void EnableRenderingPipelineThrottling(bool);\n-  BLINK_PLATFORM_EXPORT static void EnableRequireCSSExtensionForFile(bool);\n   BLINK_PLATFORM_EXPORT static void EnableResourceLoadScheduler(bool);\n   BLINK_PLATFORM_EXPORT static void EnableScriptedSpeech(bool);\n   BLINK_PLATFORM_EXPORT static void EnableScrollAnchorSerialization(bool);""}<_**next**_>{""sha"": ""ca623be21e14ea7326fc72b36fed0ca86d6bed66"", ""filename"": ""third_party/blink/renderer/core/loader/resource/css_style_sheet_resource.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/core/loader/resource/css_style_sheet_resource.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/core/loader/resource/css_style_sheet_resource.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/loader/resource/css_style_sheet_resource.cc?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -178,9 +178,7 @@ bool CSSStyleSheetResource::CanUseSheet(const CSSParserContext* parser_context,\n         parser_context->CountDeprecation(\n             WebFeature::kLocalCSSFileExtensionRejected);\n       }\n-      if (RuntimeEnabledFeatures::RequireCSSExtensionForFileEnabled()) {\n-        return false;\n-      }\n+      return false;\n     }\n   }\n ""}<_**next**_>{""sha"": ""395670e974edd446c7fb6926f66a30b4dc2ac910"", ""filename"": ""third_party/blink/renderer/platform/exported/web_runtime_features.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/platform/exported/web_runtime_features.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/platform/exported/web_runtime_features.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/exported/web_runtime_features.cc?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -440,10 +440,6 @@ void WebRuntimeFeatures::EnableRenderingPipelineThrottling(bool enable) {\n   RuntimeEnabledFeatures::SetRenderingPipelineThrottlingEnabled(enable);\n }\n \n-void WebRuntimeFeatures::EnableRequireCSSExtensionForFile(bool enable) {\n-  RuntimeEnabledFeatures::SetRequireCSSExtensionForFileEnabled(enable);\n-}\n-\n void WebRuntimeFeatures::EnableResourceLoadScheduler(bool enable) {\n   RuntimeEnabledFeatures::SetResourceLoadSchedulerEnabled(enable);\n }""}<_**next**_>{""sha"": ""99edfef487c48d78a59f39b209b7867aea19d02b"", ""filename"": ""third_party/blink/renderer/platform/runtime_enabled_features.json5"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/platform/runtime_enabled_features.json5"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d913f72b4875cf0814fc3f03ad7c00642097c4a4/third_party/blink/renderer/platform/runtime_enabled_features.json5"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/runtime_enabled_features.json5?ref=d913f72b4875cf0814fc3f03ad7c00642097c4a4"", ""patch"": ""@@ -1025,10 +1025,6 @@\n       name: \""RenderingPipelineThrottling\"",\n       status: \""stable\"",\n     },\n-    {\n-      name: \""RequireCSSExtensionForFile\"",\n-      status: \""stable\"",\n-    },\n     {\n       name: \""ResourceLoadScheduler\"",\n       status: \""experimental\"",""}","void WebRuntimeFeatures::EnableRequireCSSExtensionForFile(bool enable) {
","void WebRuntimeFeatures::EnableRequireCSSExtensionForFile(bool enable) {
  RuntimeEnabledFeatures::SetRequireCSSExtensionForFileEnabled(enable);
}
",C,,"  RuntimeEnabledFeatures::SetRequireCSSExtensionForFileEnabled(enable);
}
",,"@@ -440,10 +440,6 @@ void WebRuntimeFeatures::EnableRenderingPipelineThrottling(bool enable) {
   RuntimeEnabledFeatures::SetRenderingPipelineThrottlingEnabled(enable);
 }
 
-void WebRuntimeFeatures::EnableRequireCSSExtensionForFile(bool enable) {
-  RuntimeEnabledFeatures::SetRequireCSSExtensionForFileEnabled(enable);
-}
-
 void WebRuntimeFeatures::EnableResourceLoadScheduler(bool enable) {
   RuntimeEnabledFeatures::SetResourceLoadSchedulerEnabled(enable);
 }",Chrome,d913f72b4875cf0814fc3f03ad7c00642097c4a4,290d578e4aa4458206ceb564744ef3d7c43c7c9a,1,"void WebRuntimeFeatures::EnableRequireCSSExtensionForFile(bool enable) {
//flaw_line_below:
  RuntimeEnabledFeatures::SetRequireCSSExtensionForFileEnabled(enable);
//flaw_line_below:
}
"
10218,187954,,Remote,Not required,,CVE-2016-0829,https://www.cvedetails.com/cve/CVE-2016-0829/,CWE-254,Low,Partial,,,2016-03-12,5.0,"The BnGraphicBufferProducer::onTransact function in libs/gui/IGraphicBufferConsumer.cpp in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not initialize a certain output data structure, which allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, by triggering a QUEUE_BUFFER action, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26338109.",2016-11-28,Bypass +Info ,1,https://android.googlesource.com/platform/frameworks/native/+/d06421fd37fbb7fd07002e6738fac3a223cb1a62,d06421fd37fbb7fd07002e6738fac3a223cb1a62,"IGraphicBufferProducer: fix QUEUE_BUFFER info leak

Bug: 26338109
Change-Id: I8a979469bfe1e317ebdefa43685e19f9302baea8
",0,libs/gui/IGraphicBufferProducer.cpp,"{""filename"": ""libs/gui/IGraphicBufferProducer.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/d06421fd37fbb7fd07002e6738fac3a223cb1a62/libs/gui/IGraphicBufferProducer.cpp"", ""patch"": ""@@ -219,6 +219,7 @@\n\n             QueueBufferOutput* const output =\n                     reinterpret_cast<QueueBufferOutput *>(\n                             reply->writeInplace(sizeof(QueueBufferOutput)));\n+            memset(output, 0, sizeof(QueueBufferOutput));\n             status_t result = queueBuffer(buf, input, output);\n             reply->writeInt32(result);\n             return NO_ERROR;\n""}","status_t BnGraphicBufferProducer::onTransact(
 uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
 switch(code) {
 case REQUEST_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int bufferIdx   = data.readInt32();
            sp<GraphicBuffer> buffer;
 int result = requestBuffer(bufferIdx, &buffer);
            reply->writeInt32(buffer != 0);
 if (buffer != 0) {
                reply->write(*buffer);
 }
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int bufferCount = data.readInt32();
 int result = setBufferCount(bufferCount);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DEQUEUE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 bool async      = data.readInt32();
 uint32_t w      = data.readInt32();
 uint32_t h      = data.readInt32();
 uint32_t format = data.readInt32();
 uint32_t usage  = data.readInt32();
 int buf = 0;
            sp<Fence> fence;
 int result = dequeueBuffer(&buf, &fence, async, w, h, format, usage);
            reply->writeInt32(buf);
            reply->writeInt32(fence != NULL);
 if (fence != NULL) {
                reply->write(*fence);
 }
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case QUEUE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int buf = data.readInt32();
 QueueBufferInput input(data);

             QueueBufferOutput* const output =
                     reinterpret_cast<QueueBufferOutput *>(
                             reply->writeInplace(sizeof(QueueBufferOutput)));
            memset(output, 0, sizeof(QueueBufferOutput));
             status_t result = queueBuffer(buf, input, output);
             reply->writeInt32(result);
             return NO_ERROR;
 } break;
 case CANCEL_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int buf = data.readInt32();
            sp<Fence> fence = new Fence();
            data.read(*fence.get());
            cancelBuffer(buf, fence);
 return NO_ERROR;
 } break;
 case QUERY: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int value = 0;
 int what = data.readInt32();
 int res = query(what, &value);
            reply->writeInt32(value);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 case CONNECT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
            sp<IBinder> token = data.readStrongBinder();
 int api = data.readInt32();
 bool producerControlledByApp = data.readInt32();
 QueueBufferOutput* const output =
 reinterpret_cast<QueueBufferOutput *>(
                            reply->writeInplace(sizeof(QueueBufferOutput)));
 status_t res = connect(token, api, producerControlledByApp, output);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 case DISCONNECT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int api = data.readInt32();
 status_t res = disconnect(api);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 }
 return BBinder::onTransact(code, data, reply, flags);
}
","status_t BnGraphicBufferProducer::onTransact(
 uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
 switch(code) {
 case REQUEST_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int bufferIdx   = data.readInt32();
            sp<GraphicBuffer> buffer;
 int result = requestBuffer(bufferIdx, &buffer);
            reply->writeInt32(buffer != 0);
 if (buffer != 0) {
                reply->write(*buffer);
 }
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int bufferCount = data.readInt32();
 int result = setBufferCount(bufferCount);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DEQUEUE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 bool async      = data.readInt32();
 uint32_t w      = data.readInt32();
 uint32_t h      = data.readInt32();
 uint32_t format = data.readInt32();
 uint32_t usage  = data.readInt32();
 int buf = 0;
            sp<Fence> fence;
 int result = dequeueBuffer(&buf, &fence, async, w, h, format, usage);
            reply->writeInt32(buf);
            reply->writeInt32(fence != NULL);
 if (fence != NULL) {
                reply->write(*fence);
 }
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case QUEUE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int buf = data.readInt32();
 QueueBufferInput input(data);

             QueueBufferOutput* const output =
                     reinterpret_cast<QueueBufferOutput *>(
                             reply->writeInplace(sizeof(QueueBufferOutput)));
             status_t result = queueBuffer(buf, input, output);
             reply->writeInt32(result);
             return NO_ERROR;
 } break;
 case CANCEL_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int buf = data.readInt32();
            sp<Fence> fence = new Fence();
            data.read(*fence.get());
            cancelBuffer(buf, fence);
 return NO_ERROR;
 } break;
 case QUERY: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int value = 0;
 int what = data.readInt32();
 int res = query(what, &value);
            reply->writeInt32(value);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 case CONNECT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
            sp<IBinder> token = data.readStrongBinder();
 int api = data.readInt32();
 bool producerControlledByApp = data.readInt32();
 QueueBufferOutput* const output =
 reinterpret_cast<QueueBufferOutput *>(
                            reply->writeInplace(sizeof(QueueBufferOutput)));
 status_t res = connect(token, api, producerControlledByApp, output);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 case DISCONNECT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int api = data.readInt32();
 status_t res = disconnect(api);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 }
 return BBinder::onTransact(code, data, reply, flags);
}
",C,"            memset(output, 0, sizeof(QueueBufferOutput));
",,,"@@ -219,6 +219,7 @@

             QueueBufferOutput* const output =
                     reinterpret_cast<QueueBufferOutput *>(
                             reply->writeInplace(sizeof(QueueBufferOutput)));
+            memset(output, 0, sizeof(QueueBufferOutput));
             status_t result = queueBuffer(buf, input, output);
             reply->writeInt32(result);
             return NO_ERROR;
",Android,https://android.googlesource.com/platform/frameworks/native/+/d06421fd37fbb7fd07002e6738fac3a223cb1a62/,https://android.googlesource.com/platform/frameworks/native/+/d06421fd37fbb7fd07002e6738fac3a223cb1a62%5E/,1,"status_t BnGraphicBufferProducer::onTransact(
 uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
 switch(code) {
 case REQUEST_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int bufferIdx   = data.readInt32();
            sp<GraphicBuffer> buffer;
 int result = requestBuffer(bufferIdx, &buffer);
            reply->writeInt32(buffer != 0);
 if (buffer != 0) {
                reply->write(*buffer);
 }
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int bufferCount = data.readInt32();
 int result = setBufferCount(bufferCount);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DEQUEUE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 bool async      = data.readInt32();
 uint32_t w      = data.readInt32();
 uint32_t h      = data.readInt32();
 uint32_t format = data.readInt32();
 uint32_t usage  = data.readInt32();
 int buf = 0;
            sp<Fence> fence;
 int result = dequeueBuffer(&buf, &fence, async, w, h, format, usage);
            reply->writeInt32(buf);
            reply->writeInt32(fence != NULL);
 if (fence != NULL) {
                reply->write(*fence);
 }
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case QUEUE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int buf = data.readInt32();
 QueueBufferInput input(data);

             QueueBufferOutput* const output =
                     reinterpret_cast<QueueBufferOutput *>(
                             reply->writeInplace(sizeof(QueueBufferOutput)));
//fix_flaw_line_below:
//            memset(output, 0, sizeof(QueueBufferOutput));
             status_t result = queueBuffer(buf, input, output);
             reply->writeInt32(result);
             return NO_ERROR;
 } break;
 case CANCEL_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int buf = data.readInt32();
            sp<Fence> fence = new Fence();
            data.read(*fence.get());
            cancelBuffer(buf, fence);
 return NO_ERROR;
 } break;
 case QUERY: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int value = 0;
 int what = data.readInt32();
 int res = query(what, &value);
            reply->writeInt32(value);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 case CONNECT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
            sp<IBinder> token = data.readStrongBinder();
 int api = data.readInt32();
 bool producerControlledByApp = data.readInt32();
 QueueBufferOutput* const output =
 reinterpret_cast<QueueBufferOutput *>(
                            reply->writeInplace(sizeof(QueueBufferOutput)));
 status_t res = connect(token, api, producerControlledByApp, output);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 case DISCONNECT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int api = data.readInt32();
 status_t res = disconnect(api);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 }
 return BBinder::onTransact(code, data, reply, flags);
}
"
10219,187955,,Remote,Not required,,CVE-2016-0828,https://www.cvedetails.com/cve/CVE-2016-0828/,CWE-254,Low,Partial,,,2016-03-12,5.0,"The BnGraphicBufferConsumer::onTransact function in libs/gui/IGraphicBufferConsumer.cpp in mediaserver in Android 5.x before 5.1.1 LMY49H and 6.x before 2016-03-01 does not initialize a certain slot variable, which allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, by triggering an ATTACH_BUFFER action, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26338113.",2016-11-28,Bypass +Info ,1,https://android.googlesource.com/platform/frameworks/native/+/dded8fdbb700d6cc498debc69a780915bc34d755,dded8fdbb700d6cc498debc69a780915bc34d755,"IGraphicBufferConsumer: fix ATTACH_BUFFER info leak

Bug: 26338113
Change-Id: I019c4df2c6adbc944122df96968ddd11a02ebe33
",1,libs/gui/IGraphicBufferConsumer.cpp,"{""filename"": ""libs/gui/IGraphicBufferConsumer.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/dded8fdbb700d6cc498debc69a780915bc34d755/libs/gui/IGraphicBufferConsumer.cpp"", ""patch"": ""@@ -444,7 +444,7 @@\n\n             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n             sp<GraphicBuffer> buffer = new GraphicBuffer();\n             data.read(*buffer.get());\n-            int slot;\n+            int slot = -1;\n             int result = attachBuffer(&slot, buffer);\n             reply->writeInt32(slot);\n             reply->writeInt32(result);\n""}","status_t BnGraphicBufferConsumer::onTransact(
 uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
 switch(code) {
 case ACQUIRE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 BufferItem item;
 int64_t presentWhen = data.readInt64();
 status_t result = acquireBuffer(&item, presentWhen);
 status_t err = reply->write(item);
 if (err) return err;
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DETACH_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 int slot = data.readInt32();
 int result = detachBuffer(slot);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case ATTACH_BUFFER: {

             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             sp<GraphicBuffer> buffer = new GraphicBuffer();
             data.read(*buffer.get());
            int slot = -1;
             int result = attachBuffer(&slot, buffer);
             reply->writeInt32(slot);
             reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case RELEASE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 int buf = data.readInt32();
 uint64_t frameNumber = data.readInt64();
            sp<Fence> releaseFence = new Fence();
 status_t err = data.read(*releaseFence);
 if (err) return err;
 status_t result = releaseBuffer(buf, frameNumber,
                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, releaseFence);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case CONSUMER_CONNECT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            sp<IConsumerListener> consumer = IConsumerListener::asInterface( data.readStrongBinder() );
 bool controlledByApp = data.readInt32();
 status_t result = consumerConnect(consumer, controlledByApp);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case CONSUMER_DISCONNECT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 status_t result = consumerDisconnect();
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case GET_RELEASED_BUFFERS: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint64_t slotMask;
 status_t result = getReleasedBuffers(&slotMask);
            reply->writeInt64(slotMask);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_DEFAULT_BUFFER_SIZE: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t w = data.readInt32();
 uint32_t h = data.readInt32();
 status_t result = setDefaultBufferSize(w, h);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_DEFAULT_MAX_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t bufferCount = data.readInt32();
 status_t result = setDefaultMaxBufferCount(bufferCount);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DISABLE_ASYNC_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 status_t result = disableAsyncBuffer();
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_MAX_ACQUIRED_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t maxAcquiredBuffers = data.readInt32();
 status_t result = setMaxAcquiredBufferCount(maxAcquiredBuffers);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_CONSUMER_NAME: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            setConsumerName( data.readString8() );
 return NO_ERROR;
 } break;
 case SET_DEFAULT_BUFFER_FORMAT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t defaultFormat = data.readInt32();
 status_t result = setDefaultBufferFormat(defaultFormat);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_CONSUMER_USAGE_BITS: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t usage = data.readInt32();
 status_t result = setConsumerUsageBits(usage);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_TRANSFORM_HINT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t hint = data.readInt32();
 status_t result = setTransformHint(hint);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DUMP: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 String8 result = data.readString8();
 String8 prefix = data.readString8();
 static_cast<IGraphicBufferConsumer*>(this)->dump(result, prefix);
            reply->writeString8(result);
 return NO_ERROR;
 }
 }
 return BBinder::onTransact(code, data, reply, flags);
}
","status_t BnGraphicBufferConsumer::onTransact(
 uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
 switch(code) {
 case ACQUIRE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 BufferItem item;
 int64_t presentWhen = data.readInt64();
 status_t result = acquireBuffer(&item, presentWhen);
 status_t err = reply->write(item);
 if (err) return err;
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DETACH_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 int slot = data.readInt32();
 int result = detachBuffer(slot);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case ATTACH_BUFFER: {

             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             sp<GraphicBuffer> buffer = new GraphicBuffer();
             data.read(*buffer.get());
            int slot;
             int result = attachBuffer(&slot, buffer);
             reply->writeInt32(slot);
             reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case RELEASE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 int buf = data.readInt32();
 uint64_t frameNumber = data.readInt64();
            sp<Fence> releaseFence = new Fence();
 status_t err = data.read(*releaseFence);
 if (err) return err;
 status_t result = releaseBuffer(buf, frameNumber,
                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, releaseFence);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case CONSUMER_CONNECT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            sp<IConsumerListener> consumer = IConsumerListener::asInterface( data.readStrongBinder() );
 bool controlledByApp = data.readInt32();
 status_t result = consumerConnect(consumer, controlledByApp);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case CONSUMER_DISCONNECT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 status_t result = consumerDisconnect();
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case GET_RELEASED_BUFFERS: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint64_t slotMask;
 status_t result = getReleasedBuffers(&slotMask);
            reply->writeInt64(slotMask);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_DEFAULT_BUFFER_SIZE: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t w = data.readInt32();
 uint32_t h = data.readInt32();
 status_t result = setDefaultBufferSize(w, h);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_DEFAULT_MAX_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t bufferCount = data.readInt32();
 status_t result = setDefaultMaxBufferCount(bufferCount);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DISABLE_ASYNC_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 status_t result = disableAsyncBuffer();
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_MAX_ACQUIRED_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t maxAcquiredBuffers = data.readInt32();
 status_t result = setMaxAcquiredBufferCount(maxAcquiredBuffers);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_CONSUMER_NAME: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            setConsumerName( data.readString8() );
 return NO_ERROR;
 } break;
 case SET_DEFAULT_BUFFER_FORMAT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t defaultFormat = data.readInt32();
 status_t result = setDefaultBufferFormat(defaultFormat);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_CONSUMER_USAGE_BITS: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t usage = data.readInt32();
 status_t result = setConsumerUsageBits(usage);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_TRANSFORM_HINT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t hint = data.readInt32();
 status_t result = setTransformHint(hint);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DUMP: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 String8 result = data.readString8();
 String8 prefix = data.readString8();
 static_cast<IGraphicBufferConsumer*>(this)->dump(result, prefix);
            reply->writeString8(result);
 return NO_ERROR;
 }
 }
 return BBinder::onTransact(code, data, reply, flags);
}
",C,"            int slot = -1;
","            int slot;
",,"@@ -444,7 +444,7 @@

             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             sp<GraphicBuffer> buffer = new GraphicBuffer();
             data.read(*buffer.get());
-            int slot;
+            int slot = -1;
             int result = attachBuffer(&slot, buffer);
             reply->writeInt32(slot);
             reply->writeInt32(result);
",Android,https://android.googlesource.com/platform/frameworks/native/+/dded8fdbb700d6cc498debc69a780915bc34d755/,https://android.googlesource.com/platform/frameworks/native/+/dded8fdbb700d6cc498debc69a780915bc34d755%5E/,1,"status_t BnGraphicBufferConsumer::onTransact(
 uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
 switch(code) {
 case ACQUIRE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 BufferItem item;
 int64_t presentWhen = data.readInt64();
 status_t result = acquireBuffer(&item, presentWhen);
 status_t err = reply->write(item);
 if (err) return err;
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DETACH_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 int slot = data.readInt32();
 int result = detachBuffer(slot);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case ATTACH_BUFFER: {

             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             sp<GraphicBuffer> buffer = new GraphicBuffer();
             data.read(*buffer.get());
//flaw_line_below:
            int slot;
//fix_flaw_line_below:
//            int slot = -1;
             int result = attachBuffer(&slot, buffer);
             reply->writeInt32(slot);
             reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case RELEASE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 int buf = data.readInt32();
 uint64_t frameNumber = data.readInt64();
            sp<Fence> releaseFence = new Fence();
 status_t err = data.read(*releaseFence);
 if (err) return err;
 status_t result = releaseBuffer(buf, frameNumber,
                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, releaseFence);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case CONSUMER_CONNECT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            sp<IConsumerListener> consumer = IConsumerListener::asInterface( data.readStrongBinder() );
 bool controlledByApp = data.readInt32();
 status_t result = consumerConnect(consumer, controlledByApp);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case CONSUMER_DISCONNECT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 status_t result = consumerDisconnect();
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case GET_RELEASED_BUFFERS: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint64_t slotMask;
 status_t result = getReleasedBuffers(&slotMask);
            reply->writeInt64(slotMask);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_DEFAULT_BUFFER_SIZE: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t w = data.readInt32();
 uint32_t h = data.readInt32();
 status_t result = setDefaultBufferSize(w, h);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_DEFAULT_MAX_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t bufferCount = data.readInt32();
 status_t result = setDefaultMaxBufferCount(bufferCount);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DISABLE_ASYNC_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 status_t result = disableAsyncBuffer();
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_MAX_ACQUIRED_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t maxAcquiredBuffers = data.readInt32();
 status_t result = setMaxAcquiredBufferCount(maxAcquiredBuffers);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_CONSUMER_NAME: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            setConsumerName( data.readString8() );
 return NO_ERROR;
 } break;
 case SET_DEFAULT_BUFFER_FORMAT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t defaultFormat = data.readInt32();
 status_t result = setDefaultBufferFormat(defaultFormat);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_CONSUMER_USAGE_BITS: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t usage = data.readInt32();
 status_t result = setConsumerUsageBits(usage);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_TRANSFORM_HINT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t hint = data.readInt32();
 status_t result = setTransformHint(hint);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DUMP: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 String8 result = data.readString8();
 String8 prefix = data.readString8();
 static_cast<IGraphicBufferConsumer*>(this)->dump(result, prefix);
            reply->writeString8(result);
 return NO_ERROR;
 }
 }
 return BBinder::onTransact(code, data, reply, flags);
}
"
10227,187963,,Remote,Not required,,CVE-2016-0824,https://www.cvedetails.com/cve/CVE-2016-0824/,CWE-254,Low,Partial,,,2016-03-12,5.0,"libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",2016-11-28,Bypass +Info ,5,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,ffab15eb80630dc799eb410855c93525b75233c3,"Fixed bit stream access to make sure that it is not read beyond the allocated size.

Bug: 25765591

Change-Id: I98c23a3c3f84f6710f29bffe5ed73adcf51d47f6
",1,decoder/impeg2d_bitstream.c,"{""filename"": ""decoder/impeg2d_bitstream.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_bitstream.c"", ""patch"": ""@@ -164,9 +164,12 @@\n\n     if (u4_curr_bit == 31)\n     {\n         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;\n-        u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n \n-        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+        {\n+            u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n+            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        }\n     }\n     ps_stream->u4_offset          = u4_offset;\n \n@@ -189,7 +192,11 @@\n\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n \n-    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+\n+    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+    {\n+        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+    }\n     return;\n }\n /******************************************************************************\n""}<_**next**_>{""filename"": ""decoder/impeg2d_d_pic.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_d_pic.c"", ""patch"": ""@@ -172,7 +172,8 @@\n\n         /*------------------------------------------------------------------*/\n         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n         /*------------------------------------------------------------------*/\n-        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n+        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n+                ps_stream->u4_offset < ps_stream->u4_max_offset)\n             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n \n         /*------------------------------------------------------------------*/\n""}<_**next**_>{""filename"": ""decoder/impeg2d_dec_hdr.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_dec_hdr.c"", ""patch"": ""@@ -82,8 +82,8 @@\n\n     ps_stream = &ps_dec->s_bit_stream;\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&\n+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n \n         if (impeg2d_bit_stream_get(ps_stream,8) != 0)\n@@ -111,7 +111,7 @@\n\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n         impeg2d_bit_stream_get(ps_stream,8);\n     }\n@@ -669,7 +669,8 @@\n\n     /*  }                                                                    */\n     /*  extra_bit_picture             1                                      */\n     /*-----------------------------------------------------------------------*/\n-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+           ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_get(ps_stream,9);\n     }\n@@ -800,7 +801,8 @@\n\n     {\n         impeg2d_bit_stream_flush(ps_stream,9);\n         /* Flush extra bit information */\n-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+               ps_stream->u4_offset < ps_stream->u4_max_offset)\n         {\n             impeg2d_bit_stream_flush(ps_stream,9);\n         }\n@@ -1322,10 +1324,12 @@\n\n     ps_stream    = &ps_dec->s_bit_stream;\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n \n-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)\n+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1354,7 +1358,8 @@\n\n     while(u4_start_code == USER_DATA_START_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1384,7 +1389,8 @@\n\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n@@ -1436,7 +1442,8 @@\n\n     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while ( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n""}<_**next**_>{""filename"": ""decoder/impeg2d_pic_proc.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_pic_proc.c"", ""patch"": ""@@ -219,7 +219,8 @@\n\n UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)\n {\n     UWORD16 u2_mb_addr_incr = 0;\n-    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)\n+    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&\n+            ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);\n         u2_mb_addr_incr += 33;\n""}","INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)

 {
     stream_t *ps_stream = (stream_t *)pv_ctxt;
 

    if (ps_stream->u4_offset < ps_stream->u4_max_offset)
    {
        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
    }
     return;
 }
","INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)

 {
     stream_t *ps_stream = (stream_t *)pv_ctxt;
 
    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
     return;
 }
",C,"
    if (ps_stream->u4_offset < ps_stream->u4_max_offset)
    {
        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
    }
","    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
",,"@@ -164,9 +164,12 @@

     if (u4_curr_bit == 31)
     {
         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;
-        u4_temp             = *(ps_stream->pu4_buf_aligned)++;
 
-        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)
+        if (ps_stream->u4_offset < ps_stream->u4_max_offset)
+        {
+            u4_temp             = *(ps_stream->pu4_buf_aligned)++;
+            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)
+        }
     }
     ps_stream->u4_offset          = u4_offset;
 
@@ -189,7 +192,11 @@

 {
     stream_t *ps_stream = (stream_t *)pv_ctxt;
 
-    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
+
+    if (ps_stream->u4_offset < ps_stream->u4_max_offset)
+    {
+        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
+    }
     return;
 }
 /******************************************************************************
",Android,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3%5E/,1,"INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)

 {
     stream_t *ps_stream = (stream_t *)pv_ctxt;
 
//flaw_line_below:
    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (ps_stream->u4_offset < ps_stream->u4_max_offset)
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
//fix_flaw_line_below:
//    }
     return;
 }
"
10228,187964,,Remote,Not required,,CVE-2016-0824,https://www.cvedetails.com/cve/CVE-2016-0824/,CWE-254,Low,Partial,,,2016-03-12,5.0,"libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",2016-11-28,Bypass +Info ,5,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,ffab15eb80630dc799eb410855c93525b75233c3,"Fixed bit stream access to make sure that it is not read beyond the allocated size.

Bug: 25765591

Change-Id: I98c23a3c3f84f6710f29bffe5ed73adcf51d47f6
",2,decoder/impeg2d_bitstream.c,"{""filename"": ""decoder/impeg2d_bitstream.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_bitstream.c"", ""patch"": ""@@ -164,9 +164,12 @@\n\n     if (u4_curr_bit == 31)\n     {\n         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;\n-        u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n \n-        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+        {\n+            u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n+            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        }\n     }\n     ps_stream->u4_offset          = u4_offset;\n \n@@ -189,7 +192,11 @@\n\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n \n-    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+\n+    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+    {\n+        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+    }\n     return;\n }\n /******************************************************************************\n""}<_**next**_>{""filename"": ""decoder/impeg2d_d_pic.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_d_pic.c"", ""patch"": ""@@ -172,7 +172,8 @@\n\n         /*------------------------------------------------------------------*/\n         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n         /*------------------------------------------------------------------*/\n-        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n+        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n+                ps_stream->u4_offset < ps_stream->u4_max_offset)\n             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n \n         /*------------------------------------------------------------------*/\n""}<_**next**_>{""filename"": ""decoder/impeg2d_dec_hdr.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_dec_hdr.c"", ""patch"": ""@@ -82,8 +82,8 @@\n\n     ps_stream = &ps_dec->s_bit_stream;\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&\n+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n \n         if (impeg2d_bit_stream_get(ps_stream,8) != 0)\n@@ -111,7 +111,7 @@\n\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n         impeg2d_bit_stream_get(ps_stream,8);\n     }\n@@ -669,7 +669,8 @@\n\n     /*  }                                                                    */\n     /*  extra_bit_picture             1                                      */\n     /*-----------------------------------------------------------------------*/\n-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+           ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_get(ps_stream,9);\n     }\n@@ -800,7 +801,8 @@\n\n     {\n         impeg2d_bit_stream_flush(ps_stream,9);\n         /* Flush extra bit information */\n-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+               ps_stream->u4_offset < ps_stream->u4_max_offset)\n         {\n             impeg2d_bit_stream_flush(ps_stream,9);\n         }\n@@ -1322,10 +1324,12 @@\n\n     ps_stream    = &ps_dec->s_bit_stream;\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n \n-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)\n+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1354,7 +1358,8 @@\n\n     while(u4_start_code == USER_DATA_START_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1384,7 +1389,8 @@\n\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n@@ -1436,7 +1442,8 @@\n\n     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while ( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n""}<_**next**_>{""filename"": ""decoder/impeg2d_pic_proc.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_pic_proc.c"", ""patch"": ""@@ -219,7 +219,8 @@\n\n UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)\n {\n     UWORD16 u2_mb_addr_incr = 0;\n-    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)\n+    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&\n+            ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);\n         u2_mb_addr_incr += 33;\n""}","INLINE UWORD8 impeg2d_bit_stream_get_bit(stream_t *ps_stream)
{
    UWORD32     u4_bit,u4_offset,u4_temp;
    UWORD32     u4_curr_bit;

    u4_offset               = ps_stream->u4_offset;
    u4_curr_bit             = u4_offset & 0x1F;
    u4_bit                  = ps_stream->u4_buf;

 /* Move the current bit read from the current word to the
       least significant bit positions of 'c'.*/
    u4_bit                  >>= BITS_IN_INT - u4_curr_bit - 1;

    u4_offset++;

 /* If the last bit of the last word of the buffer has been read update
       the currrent buf with next, and read next buf from bit stream buffer */

     if (u4_curr_bit == 31)
     {
         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;
 
        if (ps_stream->u4_offset < ps_stream->u4_max_offset)
        {
            u4_temp             = *(ps_stream->pu4_buf_aligned)++;
            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)
        }
     }
     ps_stream->u4_offset          = u4_offset;
 
 return (u4_bit & 0x1);
}
","INLINE UWORD8 impeg2d_bit_stream_get_bit(stream_t *ps_stream)
{
    UWORD32     u4_bit,u4_offset,u4_temp;
    UWORD32     u4_curr_bit;

    u4_offset               = ps_stream->u4_offset;
    u4_curr_bit             = u4_offset & 0x1F;
    u4_bit                  = ps_stream->u4_buf;

 /* Move the current bit read from the current word to the
       least significant bit positions of 'c'.*/
    u4_bit                  >>= BITS_IN_INT - u4_curr_bit - 1;

    u4_offset++;

 /* If the last bit of the last word of the buffer has been read update
       the currrent buf with next, and read next buf from bit stream buffer */

     if (u4_curr_bit == 31)
     {
         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;
        u4_temp             = *(ps_stream->pu4_buf_aligned)++;
 
        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)
     }
     ps_stream->u4_offset          = u4_offset;
 
 return (u4_bit & 0x1);
}
",C,"        if (ps_stream->u4_offset < ps_stream->u4_max_offset)
        {
            u4_temp             = *(ps_stream->pu4_buf_aligned)++;
            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)
        }
","        u4_temp             = *(ps_stream->pu4_buf_aligned)++;
        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)
",,"@@ -164,9 +164,12 @@

     if (u4_curr_bit == 31)
     {
         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;
-        u4_temp             = *(ps_stream->pu4_buf_aligned)++;
 
-        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)
+        if (ps_stream->u4_offset < ps_stream->u4_max_offset)
+        {
+            u4_temp             = *(ps_stream->pu4_buf_aligned)++;
+            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)
+        }
     }
     ps_stream->u4_offset          = u4_offset;
 
@@ -189,7 +192,11 @@

 {
     stream_t *ps_stream = (stream_t *)pv_ctxt;
 
-    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
+
+    if (ps_stream->u4_offset < ps_stream->u4_max_offset)
+    {
+        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
+    }
     return;
 }
 /******************************************************************************
",Android,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3%5E/,1,"INLINE UWORD8 impeg2d_bit_stream_get_bit(stream_t *ps_stream)
{
    UWORD32     u4_bit,u4_offset,u4_temp;
    UWORD32     u4_curr_bit;

    u4_offset               = ps_stream->u4_offset;
    u4_curr_bit             = u4_offset & 0x1F;
    u4_bit                  = ps_stream->u4_buf;

 /* Move the current bit read from the current word to the
       least significant bit positions of 'c'.*/
    u4_bit                  >>= BITS_IN_INT - u4_curr_bit - 1;

    u4_offset++;

 /* If the last bit of the last word of the buffer has been read update
       the currrent buf with next, and read next buf from bit stream buffer */

     if (u4_curr_bit == 31)
     {
         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;
//flaw_line_below:
        u4_temp             = *(ps_stream->pu4_buf_aligned)++;
 
//flaw_line_below:
        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)
//fix_flaw_line_below:
//        if (ps_stream->u4_offset < ps_stream->u4_max_offset)
//fix_flaw_line_below:
//        {
//fix_flaw_line_below:
//            u4_temp             = *(ps_stream->pu4_buf_aligned)++;
//fix_flaw_line_below:
//            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)
//fix_flaw_line_below:
//        }
     }
     ps_stream->u4_offset          = u4_offset;
 
 return (u4_bit & 0x1);
}
"
10229,187965,,Remote,Not required,,CVE-2016-0824,https://www.cvedetails.com/cve/CVE-2016-0824/,CWE-254,Low,Partial,,,2016-03-12,5.0,"libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",2016-11-28,Bypass +Info ,2,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,ffab15eb80630dc799eb410855c93525b75233c3,"Fixed bit stream access to make sure that it is not read beyond the allocated size.

Bug: 25765591

Change-Id: I98c23a3c3f84f6710f29bffe5ed73adcf51d47f6
",1,decoder/impeg2d_d_pic.c,"{""filename"": ""decoder/impeg2d_bitstream.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_bitstream.c"", ""patch"": ""@@ -164,9 +164,12 @@\n\n     if (u4_curr_bit == 31)\n     {\n         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;\n-        u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n \n-        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+        {\n+            u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n+            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        }\n     }\n     ps_stream->u4_offset          = u4_offset;\n \n@@ -189,7 +192,11 @@\n\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n \n-    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+\n+    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+    {\n+        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+    }\n     return;\n }\n /******************************************************************************\n""}<_**next**_>{""filename"": ""decoder/impeg2d_d_pic.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_d_pic.c"", ""patch"": ""@@ -172,7 +172,8 @@\n\n         /*------------------------------------------------------------------*/\n         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n         /*------------------------------------------------------------------*/\n-        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n+        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n+                ps_stream->u4_offset < ps_stream->u4_max_offset)\n             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n \n         /*------------------------------------------------------------------*/\n""}<_**next**_>{""filename"": ""decoder/impeg2d_dec_hdr.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_dec_hdr.c"", ""patch"": ""@@ -82,8 +82,8 @@\n\n     ps_stream = &ps_dec->s_bit_stream;\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&\n+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n \n         if (impeg2d_bit_stream_get(ps_stream,8) != 0)\n@@ -111,7 +111,7 @@\n\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n         impeg2d_bit_stream_get(ps_stream,8);\n     }\n@@ -669,7 +669,8 @@\n\n     /*  }                                                                    */\n     /*  extra_bit_picture             1                                      */\n     /*-----------------------------------------------------------------------*/\n-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+           ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_get(ps_stream,9);\n     }\n@@ -800,7 +801,8 @@\n\n     {\n         impeg2d_bit_stream_flush(ps_stream,9);\n         /* Flush extra bit information */\n-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+               ps_stream->u4_offset < ps_stream->u4_max_offset)\n         {\n             impeg2d_bit_stream_flush(ps_stream,9);\n         }\n@@ -1322,10 +1324,12 @@\n\n     ps_stream    = &ps_dec->s_bit_stream;\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n \n-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)\n+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1354,7 +1358,8 @@\n\n     while(u4_start_code == USER_DATA_START_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1384,7 +1389,8 @@\n\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n@@ -1436,7 +1442,8 @@\n\n     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while ( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n""}<_**next**_>{""filename"": ""decoder/impeg2d_pic_proc.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_pic_proc.c"", ""patch"": ""@@ -219,7 +219,8 @@\n\n UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)\n {\n     UWORD16 u2_mb_addr_incr = 0;\n-    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)\n+    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&\n+            ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);\n         u2_mb_addr_incr += 33;\n""}","IMPEG2D_ERROR_CODES_T impeg2d_dec_d_slice(dec_state_t *ps_dec)
{
    UWORD32 i;
 yuv_buf_t *ps_cur_frm_buf  = &ps_dec->s_cur_frm_buf;

 stream_t *ps_stream       = &ps_dec->s_bit_stream;
    UWORD8   *pu1_vld_buf;

    WORD16 i2_dc_diff;
    UWORD32 u4_frame_width = ps_dec->u2_frame_width;
    UWORD32 u4_frm_offset = 0;
 if(ps_dec->u2_picture_structure != FRAME_PICTURE)
 {
        u4_frame_width <<= 1;
 if(ps_dec->u2_picture_structure == BOTTOM_FIELD)
 {
            u4_frm_offset = ps_dec->u2_frame_width;
 }
 }

 do
 {

        UWORD32 u4_x_offset, u4_y_offset;
        UWORD32 u4_blk_pos;
        WORD16 i2_dc_val;

        UWORD32 u4_dst_x_offset     = u4_frm_offset + (ps_dec->u2_mb_x << 4);
        UWORD32 u4_dst_y_offset     = (ps_dec->u2_mb_y << 4) * u4_frame_width;
        UWORD8 *pu1_vld_buf8        = ps_cur_frm_buf->pu1_y + u4_dst_x_offset + u4_dst_y_offset;
        UWORD32 u4_dst_wd           = u4_frame_width;

         /*------------------------------------------------------------------*/
         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */
         /*------------------------------------------------------------------*/
        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&
                ps_stream->u4_offset < ps_stream->u4_max_offset)
             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);
 
         /*------------------------------------------------------------------*/
 /* Flush 2 bits from bitstream [MB_Type and MacroBlockAddrIncrement]*/
 /*------------------------------------------------------------------*/
        impeg2d_bit_stream_flush(ps_stream,1);

 if(impeg2d_bit_stream_get(ps_stream, 1) != 0x01)
 {
 /* Ignore and continue decoding. */
 }

 /* Process LUMA blocks of the MB */
 for(i = 0; i < NUM_LUMA_BLKS; ++i)
 {

            u4_x_offset    = gai2_impeg2_blk_x_off[i];
            u4_y_offset    = gai2_impeg2_blk_y_off_frm[i] ;
            u4_blk_pos     = (u4_y_offset * u4_dst_wd) + u4_x_offset;
            pu1_vld_buf     = pu1_vld_buf8 + u4_blk_pos;

            i2_dc_diff = impeg2d_get_luma_dc_diff(ps_stream);
            i2_dc_val = ps_dec->u2_def_dc_pred[Y_LUMA] + i2_dc_diff;
            ps_dec->u2_def_dc_pred[Y_LUMA] = i2_dc_val;
            i2_dc_val = CLIP_U8(i2_dc_val);

            ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);
 }



 /* Process U block of the MB */

        u4_dst_x_offset                >>= 1;
        u4_dst_y_offset                >>= 2;
        u4_dst_wd                      >>= 1;
        pu1_vld_buf                     = ps_cur_frm_buf->pu1_u + u4_dst_x_offset + u4_dst_y_offset;
        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);
        i2_dc_val                      = ps_dec->u2_def_dc_pred[U_CHROMA] + i2_dc_diff;
        ps_dec->u2_def_dc_pred[U_CHROMA] = i2_dc_val;
        i2_dc_val = CLIP_U8(i2_dc_val);
        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);


 /* Process V block of the MB */

        pu1_vld_buf                     = ps_cur_frm_buf->pu1_v + u4_dst_x_offset + u4_dst_y_offset;
        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);
        i2_dc_val                      = ps_dec->u2_def_dc_pred[V_CHROMA] + i2_dc_diff;
        ps_dec->u2_def_dc_pred[V_CHROMA] = i2_dc_val;
        i2_dc_val = CLIP_U8(i2_dc_val);
        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);

 /* Common MB processing Steps */


        ps_dec->u2_num_mbs_left--;
        ps_dec->u2_mb_x++;

 if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)
 {
 return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;
 }
 else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)
 {
            ps_dec->u2_mb_x = 0;
            ps_dec->u2_mb_y++;

 }

 /* Flush end of macro block */
        impeg2d_bit_stream_flush(ps_stream,1);
 }
 while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);
 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}/* End of impeg2d_dec_d_slice() */
","IMPEG2D_ERROR_CODES_T impeg2d_dec_d_slice(dec_state_t *ps_dec)
{
    UWORD32 i;
 yuv_buf_t *ps_cur_frm_buf  = &ps_dec->s_cur_frm_buf;

 stream_t *ps_stream       = &ps_dec->s_bit_stream;
    UWORD8   *pu1_vld_buf;

    WORD16 i2_dc_diff;
    UWORD32 u4_frame_width = ps_dec->u2_frame_width;
    UWORD32 u4_frm_offset = 0;
 if(ps_dec->u2_picture_structure != FRAME_PICTURE)
 {
        u4_frame_width <<= 1;
 if(ps_dec->u2_picture_structure == BOTTOM_FIELD)
 {
            u4_frm_offset = ps_dec->u2_frame_width;
 }
 }

 do
 {

        UWORD32 u4_x_offset, u4_y_offset;
        UWORD32 u4_blk_pos;
        WORD16 i2_dc_val;

        UWORD32 u4_dst_x_offset     = u4_frm_offset + (ps_dec->u2_mb_x << 4);
        UWORD32 u4_dst_y_offset     = (ps_dec->u2_mb_y << 4) * u4_frame_width;
        UWORD8 *pu1_vld_buf8        = ps_cur_frm_buf->pu1_y + u4_dst_x_offset + u4_dst_y_offset;
        UWORD32 u4_dst_wd           = u4_frame_width;

         /*------------------------------------------------------------------*/
         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */
         /*------------------------------------------------------------------*/
        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)
             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);
 
         /*------------------------------------------------------------------*/
 /* Flush 2 bits from bitstream [MB_Type and MacroBlockAddrIncrement]*/
 /*------------------------------------------------------------------*/
        impeg2d_bit_stream_flush(ps_stream,1);

 if(impeg2d_bit_stream_get(ps_stream, 1) != 0x01)
 {
 /* Ignore and continue decoding. */
 }

 /* Process LUMA blocks of the MB */
 for(i = 0; i < NUM_LUMA_BLKS; ++i)
 {

            u4_x_offset    = gai2_impeg2_blk_x_off[i];
            u4_y_offset    = gai2_impeg2_blk_y_off_frm[i] ;
            u4_blk_pos     = (u4_y_offset * u4_dst_wd) + u4_x_offset;
            pu1_vld_buf     = pu1_vld_buf8 + u4_blk_pos;

            i2_dc_diff = impeg2d_get_luma_dc_diff(ps_stream);
            i2_dc_val = ps_dec->u2_def_dc_pred[Y_LUMA] + i2_dc_diff;
            ps_dec->u2_def_dc_pred[Y_LUMA] = i2_dc_val;
            i2_dc_val = CLIP_U8(i2_dc_val);

            ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);
 }



 /* Process U block of the MB */

        u4_dst_x_offset                >>= 1;
        u4_dst_y_offset                >>= 2;
        u4_dst_wd                      >>= 1;
        pu1_vld_buf                     = ps_cur_frm_buf->pu1_u + u4_dst_x_offset + u4_dst_y_offset;
        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);
        i2_dc_val                      = ps_dec->u2_def_dc_pred[U_CHROMA] + i2_dc_diff;
        ps_dec->u2_def_dc_pred[U_CHROMA] = i2_dc_val;
        i2_dc_val = CLIP_U8(i2_dc_val);
        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);


 /* Process V block of the MB */

        pu1_vld_buf                     = ps_cur_frm_buf->pu1_v + u4_dst_x_offset + u4_dst_y_offset;
        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);
        i2_dc_val                      = ps_dec->u2_def_dc_pred[V_CHROMA] + i2_dc_diff;
        ps_dec->u2_def_dc_pred[V_CHROMA] = i2_dc_val;
        i2_dc_val = CLIP_U8(i2_dc_val);
        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);

 /* Common MB processing Steps */


        ps_dec->u2_num_mbs_left--;
        ps_dec->u2_mb_x++;

 if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)
 {
 return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;
 }
 else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)
 {
            ps_dec->u2_mb_x = 0;
            ps_dec->u2_mb_y++;

 }

 /* Flush end of macro block */
        impeg2d_bit_stream_flush(ps_stream,1);
 }
 while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);
 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}/* End of impeg2d_dec_d_slice() */
",C,"        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&
                ps_stream->u4_offset < ps_stream->u4_max_offset)
","        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)
",,"@@ -172,7 +172,8 @@

         /*------------------------------------------------------------------*/
         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */
         /*------------------------------------------------------------------*/
-        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)
+        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&
+                ps_stream->u4_offset < ps_stream->u4_max_offset)
             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);
 
         /*------------------------------------------------------------------*/
",Android,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3%5E/,1,"IMPEG2D_ERROR_CODES_T impeg2d_dec_d_slice(dec_state_t *ps_dec)
{
    UWORD32 i;
 yuv_buf_t *ps_cur_frm_buf  = &ps_dec->s_cur_frm_buf;

 stream_t *ps_stream       = &ps_dec->s_bit_stream;
    UWORD8   *pu1_vld_buf;

    WORD16 i2_dc_diff;
    UWORD32 u4_frame_width = ps_dec->u2_frame_width;
    UWORD32 u4_frm_offset = 0;
 if(ps_dec->u2_picture_structure != FRAME_PICTURE)
 {
        u4_frame_width <<= 1;
 if(ps_dec->u2_picture_structure == BOTTOM_FIELD)
 {
            u4_frm_offset = ps_dec->u2_frame_width;
 }
 }

 do
 {

        UWORD32 u4_x_offset, u4_y_offset;
        UWORD32 u4_blk_pos;
        WORD16 i2_dc_val;

        UWORD32 u4_dst_x_offset     = u4_frm_offset + (ps_dec->u2_mb_x << 4);
        UWORD32 u4_dst_y_offset     = (ps_dec->u2_mb_y << 4) * u4_frame_width;
        UWORD8 *pu1_vld_buf8        = ps_cur_frm_buf->pu1_y + u4_dst_x_offset + u4_dst_y_offset;
        UWORD32 u4_dst_wd           = u4_frame_width;

         /*------------------------------------------------------------------*/
         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */
         /*------------------------------------------------------------------*/
//flaw_line_below:
        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)
//fix_flaw_line_below:
//        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&
//fix_flaw_line_below:
//                ps_stream->u4_offset < ps_stream->u4_max_offset)
             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);
 
         /*------------------------------------------------------------------*/
 /* Flush 2 bits from bitstream [MB_Type and MacroBlockAddrIncrement]*/
 /*------------------------------------------------------------------*/
        impeg2d_bit_stream_flush(ps_stream,1);

 if(impeg2d_bit_stream_get(ps_stream, 1) != 0x01)
 {
 /* Ignore and continue decoding. */
 }

 /* Process LUMA blocks of the MB */
 for(i = 0; i < NUM_LUMA_BLKS; ++i)
 {

            u4_x_offset    = gai2_impeg2_blk_x_off[i];
            u4_y_offset    = gai2_impeg2_blk_y_off_frm[i] ;
            u4_blk_pos     = (u4_y_offset * u4_dst_wd) + u4_x_offset;
            pu1_vld_buf     = pu1_vld_buf8 + u4_blk_pos;

            i2_dc_diff = impeg2d_get_luma_dc_diff(ps_stream);
            i2_dc_val = ps_dec->u2_def_dc_pred[Y_LUMA] + i2_dc_diff;
            ps_dec->u2_def_dc_pred[Y_LUMA] = i2_dc_val;
            i2_dc_val = CLIP_U8(i2_dc_val);

            ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);
 }



 /* Process U block of the MB */

        u4_dst_x_offset                >>= 1;
        u4_dst_y_offset                >>= 2;
        u4_dst_wd                      >>= 1;
        pu1_vld_buf                     = ps_cur_frm_buf->pu1_u + u4_dst_x_offset + u4_dst_y_offset;
        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);
        i2_dc_val                      = ps_dec->u2_def_dc_pred[U_CHROMA] + i2_dc_diff;
        ps_dec->u2_def_dc_pred[U_CHROMA] = i2_dc_val;
        i2_dc_val = CLIP_U8(i2_dc_val);
        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);


 /* Process V block of the MB */

        pu1_vld_buf                     = ps_cur_frm_buf->pu1_v + u4_dst_x_offset + u4_dst_y_offset;
        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);
        i2_dc_val                      = ps_dec->u2_def_dc_pred[V_CHROMA] + i2_dc_diff;
        ps_dec->u2_def_dc_pred[V_CHROMA] = i2_dc_val;
        i2_dc_val = CLIP_U8(i2_dc_val);
        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);

 /* Common MB processing Steps */


        ps_dec->u2_num_mbs_left--;
        ps_dec->u2_mb_x++;

 if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)
 {
 return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;
 }
 else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)
 {
            ps_dec->u2_mb_x = 0;
            ps_dec->u2_mb_y++;

 }

 /* Flush end of macro block */
        impeg2d_bit_stream_flush(ps_stream,1);
 }
 while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);
 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}/* End of impeg2d_dec_d_slice() */
"
10230,187966,,Remote,Not required,,CVE-2016-0824,https://www.cvedetails.com/cve/CVE-2016-0824/,CWE-254,Low,Partial,,,2016-03-12,5.0,"libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",2016-11-28,Bypass +Info ,2,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,ffab15eb80630dc799eb410855c93525b75233c3,"Fixed bit stream access to make sure that it is not read beyond the allocated size.

Bug: 25765591

Change-Id: I98c23a3c3f84f6710f29bffe5ed73adcf51d47f6
",1,decoder/impeg2d_dec_hdr.c,"{""filename"": ""decoder/impeg2d_bitstream.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_bitstream.c"", ""patch"": ""@@ -164,9 +164,12 @@\n\n     if (u4_curr_bit == 31)\n     {\n         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;\n-        u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n \n-        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+        {\n+            u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n+            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        }\n     }\n     ps_stream->u4_offset          = u4_offset;\n \n@@ -189,7 +192,11 @@\n\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n \n-    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+\n+    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+    {\n+        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+    }\n     return;\n }\n /******************************************************************************\n""}<_**next**_>{""filename"": ""decoder/impeg2d_d_pic.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_d_pic.c"", ""patch"": ""@@ -172,7 +172,8 @@\n\n         /*------------------------------------------------------------------*/\n         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n         /*------------------------------------------------------------------*/\n-        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n+        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n+                ps_stream->u4_offset < ps_stream->u4_max_offset)\n             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n \n         /*------------------------------------------------------------------*/\n""}<_**next**_>{""filename"": ""decoder/impeg2d_dec_hdr.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_dec_hdr.c"", ""patch"": ""@@ -82,8 +82,8 @@\n\n     ps_stream = &ps_dec->s_bit_stream;\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&\n+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n \n         if (impeg2d_bit_stream_get(ps_stream,8) != 0)\n@@ -111,7 +111,7 @@\n\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n         impeg2d_bit_stream_get(ps_stream,8);\n     }\n@@ -669,7 +669,8 @@\n\n     /*  }                                                                    */\n     /*  extra_bit_picture             1                                      */\n     /*-----------------------------------------------------------------------*/\n-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+           ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_get(ps_stream,9);\n     }\n@@ -800,7 +801,8 @@\n\n     {\n         impeg2d_bit_stream_flush(ps_stream,9);\n         /* Flush extra bit information */\n-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+               ps_stream->u4_offset < ps_stream->u4_max_offset)\n         {\n             impeg2d_bit_stream_flush(ps_stream,9);\n         }\n@@ -1322,10 +1324,12 @@\n\n     ps_stream    = &ps_dec->s_bit_stream;\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n \n-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)\n+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1354,7 +1358,8 @@\n\n     while(u4_start_code == USER_DATA_START_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1384,7 +1389,8 @@\n\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n@@ -1436,7 +1442,8 @@\n\n     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while ( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n""}<_**next**_>{""filename"": ""decoder/impeg2d_pic_proc.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_pic_proc.c"", ""patch"": ""@@ -219,7 +219,8 @@\n\n UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)\n {\n     UWORD16 u2_mb_addr_incr = 0;\n-    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)\n+    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&\n+            ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);\n         u2_mb_addr_incr += 33;\n""}","IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_ext_data(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32     u4_start_code;
    IMPEG2D_ERROR_CODES_T e_error;

    e_error = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;

    ps_stream      = &ps_dec->s_bit_stream;

     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while ( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
            impeg2d_dec_user_data(ps_dec);
 }
 else
 {
            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);
 switch(u4_start_code)
 {
 case QUANT_MATRIX_EXT_ID:
                impeg2d_dec_quant_matrix_ext(ps_dec);
 break;
 case COPYRIGHT_EXT_ID:
                impeg2d_dec_copyright_ext(ps_dec);
 break;
 case PIC_DISPLAY_EXT_ID:
                impeg2d_dec_pic_disp_ext(ps_dec);
 break;
 case CAMERA_PARAM_EXT_ID:
                impeg2d_dec_cam_param_ext(ps_dec);
 break;
 case ITU_T_EXT_ID:
                impeg2d_dec_itu_t_ext(ps_dec);
 break;
 case PIC_SPATIAL_SCALABLE_EXT_ID:
 case PIC_TEMPORAL_SCALABLE_EXT_ID:
                e_error = IMPEG2D_SCALABLITY_NOT_SUP;
 break;
 default:
 /* In case its a reserved extension code */
                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);
                impeg2d_next_start_code(ps_dec);
 break;
 }
 }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
 return e_error;
}
","IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_ext_data(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32     u4_start_code;
    IMPEG2D_ERROR_CODES_T e_error;

    e_error = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;

    ps_stream      = &ps_dec->s_bit_stream;

     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while ( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
            impeg2d_dec_user_data(ps_dec);
 }
 else
 {
            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);
 switch(u4_start_code)
 {
 case QUANT_MATRIX_EXT_ID:
                impeg2d_dec_quant_matrix_ext(ps_dec);
 break;
 case COPYRIGHT_EXT_ID:
                impeg2d_dec_copyright_ext(ps_dec);
 break;
 case PIC_DISPLAY_EXT_ID:
                impeg2d_dec_pic_disp_ext(ps_dec);
 break;
 case CAMERA_PARAM_EXT_ID:
                impeg2d_dec_cam_param_ext(ps_dec);
 break;
 case ITU_T_EXT_ID:
                impeg2d_dec_itu_t_ext(ps_dec);
 break;
 case PIC_SPATIAL_SCALABLE_EXT_ID:
 case PIC_TEMPORAL_SCALABLE_EXT_ID:
                e_error = IMPEG2D_SCALABLITY_NOT_SUP;
 break;
 default:
 /* In case its a reserved extension code */
                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);
                impeg2d_next_start_code(ps_dec);
 break;
 }
 }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
 return e_error;
}
",C,"            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
            (ps_stream->u4_offset < ps_stream->u4_max_offset))
","            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
",,"@@ -82,8 +82,8 @@

     ps_stream = &ps_dec->s_bit_stream;
     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)
-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&
+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
 
         if (impeg2d_bit_stream_get(ps_stream,8) != 0)
@@ -111,7 +111,7 @@

     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
         impeg2d_bit_stream_get(ps_stream,8);
     }
@@ -669,7 +669,8 @@

     /*  }                                                                    */
     /*  extra_bit_picture             1                                      */
     /*-----------------------------------------------------------------------*/
-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
+           ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         impeg2d_bit_stream_get(ps_stream,9);
     }
@@ -800,7 +801,8 @@

     {
         impeg2d_bit_stream_flush(ps_stream,9);
         /* Flush extra bit information */
-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
+               ps_stream->u4_offset < ps_stream->u4_max_offset)
         {
             impeg2d_bit_stream_flush(ps_stream,9);
         }
@@ -1322,10 +1324,12 @@

     ps_stream    = &ps_dec->s_bit_stream;
     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 
-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)
+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&
+                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
@@ -1354,7 +1358,8 @@

     while(u4_start_code == USER_DATA_START_CODE)
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&
+                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
@@ -1384,7 +1389,8 @@

     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
@@ -1436,7 +1442,8 @@

     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while ( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
",Android,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3%5E/,1,"IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_ext_data(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32     u4_start_code;
    IMPEG2D_ERROR_CODES_T e_error;

    e_error = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;

    ps_stream      = &ps_dec->s_bit_stream;

     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while ( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
//flaw_line_below:
            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
//fix_flaw_line_below:
//            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
//fix_flaw_line_below:
//            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
            impeg2d_dec_user_data(ps_dec);
 }
 else
 {
            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);
 switch(u4_start_code)
 {
 case QUANT_MATRIX_EXT_ID:
                impeg2d_dec_quant_matrix_ext(ps_dec);
 break;
 case COPYRIGHT_EXT_ID:
                impeg2d_dec_copyright_ext(ps_dec);
 break;
 case PIC_DISPLAY_EXT_ID:
                impeg2d_dec_pic_disp_ext(ps_dec);
 break;
 case CAMERA_PARAM_EXT_ID:
                impeg2d_dec_cam_param_ext(ps_dec);
 break;
 case ITU_T_EXT_ID:
                impeg2d_dec_itu_t_ext(ps_dec);
 break;
 case PIC_SPATIAL_SCALABLE_EXT_ID:
 case PIC_TEMPORAL_SCALABLE_EXT_ID:
                e_error = IMPEG2D_SCALABLITY_NOT_SUP;
 break;
 default:
 /* In case its a reserved extension code */
                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);
                impeg2d_next_start_code(ps_dec);
 break;
 }
 }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
 return e_error;
}
"
10231,187967,,Remote,Not required,,CVE-2016-0824,https://www.cvedetails.com/cve/CVE-2016-0824/,CWE-254,Low,Partial,,,2016-03-12,5.0,"libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",2016-11-28,Bypass +Info ,2,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,ffab15eb80630dc799eb410855c93525b75233c3,"Fixed bit stream access to make sure that it is not read beyond the allocated size.

Bug: 25765591

Change-Id: I98c23a3c3f84f6710f29bffe5ed73adcf51d47f6
",1,decoder/impeg2d_dec_hdr.c,"{""filename"": ""decoder/impeg2d_bitstream.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_bitstream.c"", ""patch"": ""@@ -164,9 +164,12 @@\n\n     if (u4_curr_bit == 31)\n     {\n         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;\n-        u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n \n-        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+        {\n+            u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n+            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        }\n     }\n     ps_stream->u4_offset          = u4_offset;\n \n@@ -189,7 +192,11 @@\n\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n \n-    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+\n+    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+    {\n+        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+    }\n     return;\n }\n /******************************************************************************\n""}<_**next**_>{""filename"": ""decoder/impeg2d_d_pic.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_d_pic.c"", ""patch"": ""@@ -172,7 +172,8 @@\n\n         /*------------------------------------------------------------------*/\n         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n         /*------------------------------------------------------------------*/\n-        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n+        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n+                ps_stream->u4_offset < ps_stream->u4_max_offset)\n             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n \n         /*------------------------------------------------------------------*/\n""}<_**next**_>{""filename"": ""decoder/impeg2d_dec_hdr.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_dec_hdr.c"", ""patch"": ""@@ -82,8 +82,8 @@\n\n     ps_stream = &ps_dec->s_bit_stream;\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&\n+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n \n         if (impeg2d_bit_stream_get(ps_stream,8) != 0)\n@@ -111,7 +111,7 @@\n\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n         impeg2d_bit_stream_get(ps_stream,8);\n     }\n@@ -669,7 +669,8 @@\n\n     /*  }                                                                    */\n     /*  extra_bit_picture             1                                      */\n     /*-----------------------------------------------------------------------*/\n-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+           ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_get(ps_stream,9);\n     }\n@@ -800,7 +801,8 @@\n\n     {\n         impeg2d_bit_stream_flush(ps_stream,9);\n         /* Flush extra bit information */\n-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+               ps_stream->u4_offset < ps_stream->u4_max_offset)\n         {\n             impeg2d_bit_stream_flush(ps_stream,9);\n         }\n@@ -1322,10 +1324,12 @@\n\n     ps_stream    = &ps_dec->s_bit_stream;\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n \n-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)\n+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1354,7 +1358,8 @@\n\n     while(u4_start_code == USER_DATA_START_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1384,7 +1389,8 @@\n\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n@@ -1436,7 +1442,8 @@\n\n     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while ( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n""}<_**next**_>{""filename"": ""decoder/impeg2d_pic_proc.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_pic_proc.c"", ""patch"": ""@@ -219,7 +219,8 @@\n\n UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)\n {\n     UWORD16 u2_mb_addr_incr = 0;\n-    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)\n+    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&\n+            ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);\n         u2_mb_addr_incr += 33;\n""}","IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;

    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
 /* Flush temporal reference */
    impeg2d_bit_stream_get(ps_stream,10);

 /* Picture type */
    ps_dec->e_pic_type = (e_pic_type_t)impeg2d_bit_stream_get(ps_stream,3);
 if((ps_dec->e_pic_type < I_PIC) || (ps_dec->e_pic_type > D_PIC))
 {
        impeg2d_next_code(ps_dec, PICTURE_START_CODE);
 return IMPEG2D_INVALID_PIC_TYPE;
 }

 /* Flush vbv_delay */
    impeg2d_bit_stream_get(ps_stream,16);

 if(ps_dec->e_pic_type == P_PIC || ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_forw_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }
 if(ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_back_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_back_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }

 if(ps_dec->u2_is_mpeg2 == 0)
 {
        ps_dec->au2_f_code[0][0] = ps_dec->au2_f_code[0][1] = ps_dec->u2_forw_f_code;
        ps_dec->au2_f_code[1][0] = ps_dec->au2_f_code[1][1] = ps_dec->u2_back_f_code;
 }

 /*-----------------------------------------------------------------------*/
 /*  Flush the extra bit value                                            */
 /*                                                                       */
 /*  while(impeg2d_bit_stream_nxt() == '1')                                  */
 /*  {                                                                    */
 /*      extra_bit_picture         1                                      */
 /*      extra_information_picture 8                                      */

     /*  }                                                                    */
     /*  extra_bit_picture             1                                      */
     /*-----------------------------------------------------------------------*/
    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
           ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         impeg2d_bit_stream_get(ps_stream,9);
     }
    impeg2d_bit_stream_get_bit(ps_stream);
    impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
","IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;

    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
 /* Flush temporal reference */
    impeg2d_bit_stream_get(ps_stream,10);

 /* Picture type */
    ps_dec->e_pic_type = (e_pic_type_t)impeg2d_bit_stream_get(ps_stream,3);
 if((ps_dec->e_pic_type < I_PIC) || (ps_dec->e_pic_type > D_PIC))
 {
        impeg2d_next_code(ps_dec, PICTURE_START_CODE);
 return IMPEG2D_INVALID_PIC_TYPE;
 }

 /* Flush vbv_delay */
    impeg2d_bit_stream_get(ps_stream,16);

 if(ps_dec->e_pic_type == P_PIC || ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_forw_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }
 if(ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_back_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_back_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }

 if(ps_dec->u2_is_mpeg2 == 0)
 {
        ps_dec->au2_f_code[0][0] = ps_dec->au2_f_code[0][1] = ps_dec->u2_forw_f_code;
        ps_dec->au2_f_code[1][0] = ps_dec->au2_f_code[1][1] = ps_dec->u2_back_f_code;
 }

 /*-----------------------------------------------------------------------*/
 /*  Flush the extra bit value                                            */
 /*                                                                       */
 /*  while(impeg2d_bit_stream_nxt() == '1')                                  */
 /*  {                                                                    */
 /*      extra_bit_picture         1                                      */
 /*      extra_information_picture 8                                      */

     /*  }                                                                    */
     /*  extra_bit_picture             1                                      */
     /*-----------------------------------------------------------------------*/
    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
     {
         impeg2d_bit_stream_get(ps_stream,9);
     }
    impeg2d_bit_stream_get_bit(ps_stream);
    impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
",C,"    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
           ps_stream->u4_offset < ps_stream->u4_max_offset)
","    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
",,"@@ -82,8 +82,8 @@

     ps_stream = &ps_dec->s_bit_stream;
     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)
-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&
+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
 
         if (impeg2d_bit_stream_get(ps_stream,8) != 0)
@@ -111,7 +111,7 @@

     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
         impeg2d_bit_stream_get(ps_stream,8);
     }
@@ -669,7 +669,8 @@

     /*  }                                                                    */
     /*  extra_bit_picture             1                                      */
     /*-----------------------------------------------------------------------*/
-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
+           ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         impeg2d_bit_stream_get(ps_stream,9);
     }
@@ -800,7 +801,8 @@

     {
         impeg2d_bit_stream_flush(ps_stream,9);
         /* Flush extra bit information */
-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
+               ps_stream->u4_offset < ps_stream->u4_max_offset)
         {
             impeg2d_bit_stream_flush(ps_stream,9);
         }
@@ -1322,10 +1324,12 @@

     ps_stream    = &ps_dec->s_bit_stream;
     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 
-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)
+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&
+                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
@@ -1354,7 +1358,8 @@

     while(u4_start_code == USER_DATA_START_CODE)
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&
+                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
@@ -1384,7 +1389,8 @@

     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
@@ -1436,7 +1442,8 @@

     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while ( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
",Android,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3%5E/,1,"IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;

    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
 /* Flush temporal reference */
    impeg2d_bit_stream_get(ps_stream,10);

 /* Picture type */
    ps_dec->e_pic_type = (e_pic_type_t)impeg2d_bit_stream_get(ps_stream,3);
 if((ps_dec->e_pic_type < I_PIC) || (ps_dec->e_pic_type > D_PIC))
 {
        impeg2d_next_code(ps_dec, PICTURE_START_CODE);
 return IMPEG2D_INVALID_PIC_TYPE;
 }

 /* Flush vbv_delay */
    impeg2d_bit_stream_get(ps_stream,16);

 if(ps_dec->e_pic_type == P_PIC || ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_forw_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }
 if(ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_back_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_back_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }

 if(ps_dec->u2_is_mpeg2 == 0)
 {
        ps_dec->au2_f_code[0][0] = ps_dec->au2_f_code[0][1] = ps_dec->u2_forw_f_code;
        ps_dec->au2_f_code[1][0] = ps_dec->au2_f_code[1][1] = ps_dec->u2_back_f_code;
 }

 /*-----------------------------------------------------------------------*/
 /*  Flush the extra bit value                                            */
 /*                                                                       */
 /*  while(impeg2d_bit_stream_nxt() == '1')                                  */
 /*  {                                                                    */
 /*      extra_bit_picture         1                                      */
 /*      extra_information_picture 8                                      */

     /*  }                                                                    */
     /*  extra_bit_picture             1                                      */
     /*-----------------------------------------------------------------------*/
//flaw_line_below:
    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
//fix_flaw_line_below:
//    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
//fix_flaw_line_below:
//           ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         impeg2d_bit_stream_get(ps_stream,9);
     }
    impeg2d_bit_stream_get_bit(ps_stream);
    impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
"
10232,187968,,Remote,Not required,,CVE-2016-0824,https://www.cvedetails.com/cve/CVE-2016-0824/,CWE-254,Low,Partial,,,2016-03-12,5.0,"libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",2016-11-28,Bypass +Info ,2,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,ffab15eb80630dc799eb410855c93525b75233c3,"Fixed bit stream access to make sure that it is not read beyond the allocated size.

Bug: 25765591

Change-Id: I98c23a3c3f84f6710f29bffe5ed73adcf51d47f6
",1,decoder/impeg2d_dec_hdr.c,"{""filename"": ""decoder/impeg2d_bitstream.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_bitstream.c"", ""patch"": ""@@ -164,9 +164,12 @@\n\n     if (u4_curr_bit == 31)\n     {\n         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;\n-        u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n \n-        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+        {\n+            u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n+            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        }\n     }\n     ps_stream->u4_offset          = u4_offset;\n \n@@ -189,7 +192,11 @@\n\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n \n-    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+\n+    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+    {\n+        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+    }\n     return;\n }\n /******************************************************************************\n""}<_**next**_>{""filename"": ""decoder/impeg2d_d_pic.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_d_pic.c"", ""patch"": ""@@ -172,7 +172,8 @@\n\n         /*------------------------------------------------------------------*/\n         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n         /*------------------------------------------------------------------*/\n-        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n+        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n+                ps_stream->u4_offset < ps_stream->u4_max_offset)\n             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n \n         /*------------------------------------------------------------------*/\n""}<_**next**_>{""filename"": ""decoder/impeg2d_dec_hdr.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_dec_hdr.c"", ""patch"": ""@@ -82,8 +82,8 @@\n\n     ps_stream = &ps_dec->s_bit_stream;\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&\n+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n \n         if (impeg2d_bit_stream_get(ps_stream,8) != 0)\n@@ -111,7 +111,7 @@\n\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n         impeg2d_bit_stream_get(ps_stream,8);\n     }\n@@ -669,7 +669,8 @@\n\n     /*  }                                                                    */\n     /*  extra_bit_picture             1                                      */\n     /*-----------------------------------------------------------------------*/\n-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+           ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_get(ps_stream,9);\n     }\n@@ -800,7 +801,8 @@\n\n     {\n         impeg2d_bit_stream_flush(ps_stream,9);\n         /* Flush extra bit information */\n-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+               ps_stream->u4_offset < ps_stream->u4_max_offset)\n         {\n             impeg2d_bit_stream_flush(ps_stream,9);\n         }\n@@ -1322,10 +1324,12 @@\n\n     ps_stream    = &ps_dec->s_bit_stream;\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n \n-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)\n+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1354,7 +1358,8 @@\n\n     while(u4_start_code == USER_DATA_START_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1384,7 +1389,8 @@\n\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n@@ -1436,7 +1442,8 @@\n\n     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while ( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n""}<_**next**_>{""filename"": ""decoder/impeg2d_pic_proc.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_pic_proc.c"", ""patch"": ""@@ -219,7 +219,8 @@\n\n UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)\n {\n     UWORD16 u2_mb_addr_incr = 0;\n-    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)\n+    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&\n+            ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);\n         u2_mb_addr_incr += 33;\n""}","IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_ext_data(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32     u4_start_code;
    IMPEG2D_ERROR_CODES_T e_error;

    e_error = (IMPEG2D_ERROR_CODES_T) IVD_ERROR_NONE;

    ps_stream      = &ps_dec->s_bit_stream;

     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
            impeg2d_dec_user_data(ps_dec);
 }
 else
 {
            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);
 switch(u4_start_code)
 {
 case SEQ_DISPLAY_EXT_ID:
                impeg2d_dec_seq_disp_ext(ps_dec);
 break;
 case SEQ_SCALABLE_EXT_ID:
                e_error = IMPEG2D_SCALABILITIY_NOT_SUPPORTED;
 break;
 default:
 /* In case its a reserved extension code */
                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);
                impeg2d_peek_next_start_code(ps_dec);
 break;
 }
 }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
 return e_error;
}
","IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_ext_data(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32     u4_start_code;
    IMPEG2D_ERROR_CODES_T e_error;

    e_error = (IMPEG2D_ERROR_CODES_T) IVD_ERROR_NONE;

    ps_stream      = &ps_dec->s_bit_stream;

     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
            impeg2d_dec_user_data(ps_dec);
 }
 else
 {
            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);
 switch(u4_start_code)
 {
 case SEQ_DISPLAY_EXT_ID:
                impeg2d_dec_seq_disp_ext(ps_dec);
 break;
 case SEQ_SCALABLE_EXT_ID:
                e_error = IMPEG2D_SCALABILITIY_NOT_SUPPORTED;
 break;
 default:
 /* In case its a reserved extension code */
                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);
                impeg2d_peek_next_start_code(ps_dec);
 break;
 }
 }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
 return e_error;
}
",C,"            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
            (ps_stream->u4_offset < ps_stream->u4_max_offset))
","            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
",,"@@ -82,8 +82,8 @@

     ps_stream = &ps_dec->s_bit_stream;
     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)
-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&
+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
 
         if (impeg2d_bit_stream_get(ps_stream,8) != 0)
@@ -111,7 +111,7 @@

     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
         impeg2d_bit_stream_get(ps_stream,8);
     }
@@ -669,7 +669,8 @@

     /*  }                                                                    */
     /*  extra_bit_picture             1                                      */
     /*-----------------------------------------------------------------------*/
-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
+           ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         impeg2d_bit_stream_get(ps_stream,9);
     }
@@ -800,7 +801,8 @@

     {
         impeg2d_bit_stream_flush(ps_stream,9);
         /* Flush extra bit information */
-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
+               ps_stream->u4_offset < ps_stream->u4_max_offset)
         {
             impeg2d_bit_stream_flush(ps_stream,9);
         }
@@ -1322,10 +1324,12 @@

     ps_stream    = &ps_dec->s_bit_stream;
     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 
-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)
+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&
+                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
@@ -1354,7 +1358,8 @@

     while(u4_start_code == USER_DATA_START_CODE)
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&
+                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
@@ -1384,7 +1389,8 @@

     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
@@ -1436,7 +1442,8 @@

     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while ( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
",Android,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3%5E/,1,"IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_ext_data(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32     u4_start_code;
    IMPEG2D_ERROR_CODES_T e_error;

    e_error = (IMPEG2D_ERROR_CODES_T) IVD_ERROR_NONE;

    ps_stream      = &ps_dec->s_bit_stream;

     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
//flaw_line_below:
            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
//fix_flaw_line_below:
//            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
//fix_flaw_line_below:
//            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
            impeg2d_dec_user_data(ps_dec);
 }
 else
 {
            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);
 switch(u4_start_code)
 {
 case SEQ_DISPLAY_EXT_ID:
                impeg2d_dec_seq_disp_ext(ps_dec);
 break;
 case SEQ_SCALABLE_EXT_ID:
                e_error = IMPEG2D_SCALABILITIY_NOT_SUPPORTED;
 break;
 default:
 /* In case its a reserved extension code */
                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);
                impeg2d_peek_next_start_code(ps_dec);
 break;
 }
 }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
 return e_error;
}
"
10233,187969,,Remote,Not required,,CVE-2016-0824,https://www.cvedetails.com/cve/CVE-2016-0824/,CWE-254,Low,Partial,,,2016-03-12,5.0,"libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",2016-11-28,Bypass +Info ,2,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,ffab15eb80630dc799eb410855c93525b75233c3,"Fixed bit stream access to make sure that it is not read beyond the allocated size.

Bug: 25765591

Change-Id: I98c23a3c3f84f6710f29bffe5ed73adcf51d47f6
",1,decoder/impeg2d_dec_hdr.c,"{""filename"": ""decoder/impeg2d_bitstream.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_bitstream.c"", ""patch"": ""@@ -164,9 +164,12 @@\n\n     if (u4_curr_bit == 31)\n     {\n         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;\n-        u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n \n-        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+        {\n+            u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n+            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        }\n     }\n     ps_stream->u4_offset          = u4_offset;\n \n@@ -189,7 +192,11 @@\n\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n \n-    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+\n+    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+    {\n+        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+    }\n     return;\n }\n /******************************************************************************\n""}<_**next**_>{""filename"": ""decoder/impeg2d_d_pic.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_d_pic.c"", ""patch"": ""@@ -172,7 +172,8 @@\n\n         /*------------------------------------------------------------------*/\n         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n         /*------------------------------------------------------------------*/\n-        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n+        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n+                ps_stream->u4_offset < ps_stream->u4_max_offset)\n             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n \n         /*------------------------------------------------------------------*/\n""}<_**next**_>{""filename"": ""decoder/impeg2d_dec_hdr.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_dec_hdr.c"", ""patch"": ""@@ -82,8 +82,8 @@\n\n     ps_stream = &ps_dec->s_bit_stream;\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&\n+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n \n         if (impeg2d_bit_stream_get(ps_stream,8) != 0)\n@@ -111,7 +111,7 @@\n\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n         impeg2d_bit_stream_get(ps_stream,8);\n     }\n@@ -669,7 +669,8 @@\n\n     /*  }                                                                    */\n     /*  extra_bit_picture             1                                      */\n     /*-----------------------------------------------------------------------*/\n-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+           ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_get(ps_stream,9);\n     }\n@@ -800,7 +801,8 @@\n\n     {\n         impeg2d_bit_stream_flush(ps_stream,9);\n         /* Flush extra bit information */\n-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+               ps_stream->u4_offset < ps_stream->u4_max_offset)\n         {\n             impeg2d_bit_stream_flush(ps_stream,9);\n         }\n@@ -1322,10 +1324,12 @@\n\n     ps_stream    = &ps_dec->s_bit_stream;\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n \n-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)\n+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1354,7 +1358,8 @@\n\n     while(u4_start_code == USER_DATA_START_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1384,7 +1389,8 @@\n\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n@@ -1436,7 +1442,8 @@\n\n     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while ( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n""}<_**next**_>{""filename"": ""decoder/impeg2d_pic_proc.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_pic_proc.c"", ""patch"": ""@@ -219,7 +219,8 @@\n\n UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)\n {\n     UWORD16 u2_mb_addr_incr = 0;\n-    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)\n+    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&\n+            ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);\n         u2_mb_addr_incr += 33;\n""}","IMPEG2D_ERROR_CODES_T impeg2d_dec_slice(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32 u4_slice_vertical_position;
    UWORD32 u4_slice_vertical_position_extension;
    IMPEG2D_ERROR_CODES_T e_error;

    ps_stream = &ps_dec->s_bit_stream;

 /*------------------------------------------------------------------------*/
 /* All the profiles supported require restricted slice structure. Hence   */
 /* there is no need to store slice_vertical_position. Note that max       */
 /* height supported does not exceed 2800 and scalablity is not supported  */
 /*------------------------------------------------------------------------*/

 /* Remove the slice start code */
    impeg2d_bit_stream_flush(ps_stream,START_CODE_PREFIX_LEN);
    u4_slice_vertical_position = impeg2d_bit_stream_get(ps_stream, 8);
 if(u4_slice_vertical_position > 2800)
 {
        u4_slice_vertical_position_extension = impeg2d_bit_stream_get(ps_stream, 3);
        u4_slice_vertical_position += (u4_slice_vertical_position_extension << 7);
 }

 if((u4_slice_vertical_position > ps_dec->u2_num_vert_mb) ||
 (u4_slice_vertical_position == 0))
 {
 return IMPEG2D_INVALID_VERT_SIZE;
 }

    u4_slice_vertical_position--;
 if (ps_dec->u2_mb_y != u4_slice_vertical_position)
 {
        ps_dec->u2_mb_y    = u4_slice_vertical_position;
        ps_dec->u2_mb_x    = 0;
 }
    ps_dec->u2_first_mb = 1;

 /*------------------------------------------------------------------------*/
 /* Quant scale code decoding                                              */
 /*------------------------------------------------------------------------*/
 {
        UWORD16 u2_quant_scale_code;
        u2_quant_scale_code = impeg2d_bit_stream_get(ps_stream,5);
        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?
            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);
 }

 if (impeg2d_bit_stream_nxt(ps_stream,1) == 1)

     {
         impeg2d_bit_stream_flush(ps_stream,9);
         /* Flush extra bit information */
        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
               ps_stream->u4_offset < ps_stream->u4_max_offset)
         {
             impeg2d_bit_stream_flush(ps_stream,9);
         }
 }
    impeg2d_bit_stream_get_bit(ps_stream);

 /* Reset the DC predictors to reset values given in Table 7.2 at the start*/
 /* of slice data */
    ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;
    ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
    ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
 /*------------------------------------------------------------------------*/
 /* dec->DecMBsinSlice() implements the following psuedo code from standard*/
 /* do                                                                     */
 /* {                                                                      */
 /*      macroblock()                                                      */
 /* } while (impeg2d_bit_stream_nxt() != '000 0000 0000 0000 0000 0000')      */
 /*------------------------------------------------------------------------*/

    e_error = ps_dec->pf_decode_slice(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }

 /* Check for the MBy index instead of number of MBs left, because the
     * number of MBs left in case of multi-thread decode is the number of MBs
     * in that row only
     */
 if(ps_dec->u2_mb_y < ps_dec->u2_num_vert_mb)
        impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
","IMPEG2D_ERROR_CODES_T impeg2d_dec_slice(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32 u4_slice_vertical_position;
    UWORD32 u4_slice_vertical_position_extension;
    IMPEG2D_ERROR_CODES_T e_error;

    ps_stream = &ps_dec->s_bit_stream;

 /*------------------------------------------------------------------------*/
 /* All the profiles supported require restricted slice structure. Hence   */
 /* there is no need to store slice_vertical_position. Note that max       */
 /* height supported does not exceed 2800 and scalablity is not supported  */
 /*------------------------------------------------------------------------*/

 /* Remove the slice start code */
    impeg2d_bit_stream_flush(ps_stream,START_CODE_PREFIX_LEN);
    u4_slice_vertical_position = impeg2d_bit_stream_get(ps_stream, 8);
 if(u4_slice_vertical_position > 2800)
 {
        u4_slice_vertical_position_extension = impeg2d_bit_stream_get(ps_stream, 3);
        u4_slice_vertical_position += (u4_slice_vertical_position_extension << 7);
 }

 if((u4_slice_vertical_position > ps_dec->u2_num_vert_mb) ||
 (u4_slice_vertical_position == 0))
 {
 return IMPEG2D_INVALID_VERT_SIZE;
 }

    u4_slice_vertical_position--;
 if (ps_dec->u2_mb_y != u4_slice_vertical_position)
 {
        ps_dec->u2_mb_y    = u4_slice_vertical_position;
        ps_dec->u2_mb_x    = 0;
 }
    ps_dec->u2_first_mb = 1;

 /*------------------------------------------------------------------------*/
 /* Quant scale code decoding                                              */
 /*------------------------------------------------------------------------*/
 {
        UWORD16 u2_quant_scale_code;
        u2_quant_scale_code = impeg2d_bit_stream_get(ps_stream,5);
        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?
            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);
 }

 if (impeg2d_bit_stream_nxt(ps_stream,1) == 1)

     {
         impeg2d_bit_stream_flush(ps_stream,9);
         /* Flush extra bit information */
        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
         {
             impeg2d_bit_stream_flush(ps_stream,9);
         }
 }
    impeg2d_bit_stream_get_bit(ps_stream);

 /* Reset the DC predictors to reset values given in Table 7.2 at the start*/
 /* of slice data */
    ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;
    ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
    ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
 /*------------------------------------------------------------------------*/
 /* dec->DecMBsinSlice() implements the following psuedo code from standard*/
 /* do                                                                     */
 /* {                                                                      */
 /*      macroblock()                                                      */
 /* } while (impeg2d_bit_stream_nxt() != '000 0000 0000 0000 0000 0000')      */
 /*------------------------------------------------------------------------*/

    e_error = ps_dec->pf_decode_slice(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }

 /* Check for the MBy index instead of number of MBs left, because the
     * number of MBs left in case of multi-thread decode is the number of MBs
     * in that row only
     */
 if(ps_dec->u2_mb_y < ps_dec->u2_num_vert_mb)
        impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
",C,"        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
               ps_stream->u4_offset < ps_stream->u4_max_offset)
","        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
",,"@@ -82,8 +82,8 @@

     ps_stream = &ps_dec->s_bit_stream;
     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)
-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&
+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
 
         if (impeg2d_bit_stream_get(ps_stream,8) != 0)
@@ -111,7 +111,7 @@

     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
         impeg2d_bit_stream_get(ps_stream,8);
     }
@@ -669,7 +669,8 @@

     /*  }                                                                    */
     /*  extra_bit_picture             1                                      */
     /*-----------------------------------------------------------------------*/
-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
+           ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         impeg2d_bit_stream_get(ps_stream,9);
     }
@@ -800,7 +801,8 @@

     {
         impeg2d_bit_stream_flush(ps_stream,9);
         /* Flush extra bit information */
-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
+               ps_stream->u4_offset < ps_stream->u4_max_offset)
         {
             impeg2d_bit_stream_flush(ps_stream,9);
         }
@@ -1322,10 +1324,12 @@

     ps_stream    = &ps_dec->s_bit_stream;
     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 
-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)
+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&
+                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
@@ -1354,7 +1358,8 @@

     while(u4_start_code == USER_DATA_START_CODE)
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&
+                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
@@ -1384,7 +1389,8 @@

     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
@@ -1436,7 +1442,8 @@

     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while ( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
",Android,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3%5E/,1,"IMPEG2D_ERROR_CODES_T impeg2d_dec_slice(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32 u4_slice_vertical_position;
    UWORD32 u4_slice_vertical_position_extension;
    IMPEG2D_ERROR_CODES_T e_error;

    ps_stream = &ps_dec->s_bit_stream;

 /*------------------------------------------------------------------------*/
 /* All the profiles supported require restricted slice structure. Hence   */
 /* there is no need to store slice_vertical_position. Note that max       */
 /* height supported does not exceed 2800 and scalablity is not supported  */
 /*------------------------------------------------------------------------*/

 /* Remove the slice start code */
    impeg2d_bit_stream_flush(ps_stream,START_CODE_PREFIX_LEN);
    u4_slice_vertical_position = impeg2d_bit_stream_get(ps_stream, 8);
 if(u4_slice_vertical_position > 2800)
 {
        u4_slice_vertical_position_extension = impeg2d_bit_stream_get(ps_stream, 3);
        u4_slice_vertical_position += (u4_slice_vertical_position_extension << 7);
 }

 if((u4_slice_vertical_position > ps_dec->u2_num_vert_mb) ||
 (u4_slice_vertical_position == 0))
 {
 return IMPEG2D_INVALID_VERT_SIZE;
 }

 // change the mb_y to point to slice_vertical_position
    u4_slice_vertical_position--;
 if (ps_dec->u2_mb_y != u4_slice_vertical_position)
 {
        ps_dec->u2_mb_y    = u4_slice_vertical_position;
        ps_dec->u2_mb_x    = 0;
 }
    ps_dec->u2_first_mb = 1;

 /*------------------------------------------------------------------------*/
 /* Quant scale code decoding                                              */
 /*------------------------------------------------------------------------*/
 {
        UWORD16 u2_quant_scale_code;
        u2_quant_scale_code = impeg2d_bit_stream_get(ps_stream,5);
        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?
            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);
 }

 if (impeg2d_bit_stream_nxt(ps_stream,1) == 1)

     {
         impeg2d_bit_stream_flush(ps_stream,9);
         /* Flush extra bit information */
//flaw_line_below:
        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
//fix_flaw_line_below:
//        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
//fix_flaw_line_below:
//               ps_stream->u4_offset < ps_stream->u4_max_offset)
         {
             impeg2d_bit_stream_flush(ps_stream,9);
         }
 }
    impeg2d_bit_stream_get_bit(ps_stream);

 /* Reset the DC predictors to reset values given in Table 7.2 at the start*/
 /* of slice data */
    ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;
    ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
    ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
 /*------------------------------------------------------------------------*/
 /* dec->DecMBsinSlice() implements the following psuedo code from standard*/
 /* do                                                                     */
 /* {                                                                      */
 /*      macroblock()                                                      */
 /* } while (impeg2d_bit_stream_nxt() != '000 0000 0000 0000 0000 0000')      */
 /*------------------------------------------------------------------------*/

    e_error = ps_dec->pf_decode_slice(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }

 /* Check for the MBy index instead of number of MBs left, because the
     * number of MBs left in case of multi-thread decode is the number of MBs
     * in that row only
     */
 if(ps_dec->u2_mb_y < ps_dec->u2_num_vert_mb)
        impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
"
10234,187970,,Remote,Not required,,CVE-2016-0824,https://www.cvedetails.com/cve/CVE-2016-0824/,CWE-254,Low,Partial,,,2016-03-12,5.0,"libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",2016-11-28,Bypass +Info ,2,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,ffab15eb80630dc799eb410855c93525b75233c3,"Fixed bit stream access to make sure that it is not read beyond the allocated size.

Bug: 25765591

Change-Id: I98c23a3c3f84f6710f29bffe5ed73adcf51d47f6
",1,decoder/impeg2d_dec_hdr.c,"{""filename"": ""decoder/impeg2d_bitstream.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_bitstream.c"", ""patch"": ""@@ -164,9 +164,12 @@\n\n     if (u4_curr_bit == 31)\n     {\n         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;\n-        u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n \n-        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+        {\n+            u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n+            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        }\n     }\n     ps_stream->u4_offset          = u4_offset;\n \n@@ -189,7 +192,11 @@\n\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n \n-    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+\n+    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+    {\n+        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+    }\n     return;\n }\n /******************************************************************************\n""}<_**next**_>{""filename"": ""decoder/impeg2d_d_pic.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_d_pic.c"", ""patch"": ""@@ -172,7 +172,8 @@\n\n         /*------------------------------------------------------------------*/\n         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n         /*------------------------------------------------------------------*/\n-        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n+        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n+                ps_stream->u4_offset < ps_stream->u4_max_offset)\n             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n \n         /*------------------------------------------------------------------*/\n""}<_**next**_>{""filename"": ""decoder/impeg2d_dec_hdr.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_dec_hdr.c"", ""patch"": ""@@ -82,8 +82,8 @@\n\n     ps_stream = &ps_dec->s_bit_stream;\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&\n+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n \n         if (impeg2d_bit_stream_get(ps_stream,8) != 0)\n@@ -111,7 +111,7 @@\n\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n         impeg2d_bit_stream_get(ps_stream,8);\n     }\n@@ -669,7 +669,8 @@\n\n     /*  }                                                                    */\n     /*  extra_bit_picture             1                                      */\n     /*-----------------------------------------------------------------------*/\n-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+           ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_get(ps_stream,9);\n     }\n@@ -800,7 +801,8 @@\n\n     {\n         impeg2d_bit_stream_flush(ps_stream,9);\n         /* Flush extra bit information */\n-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+               ps_stream->u4_offset < ps_stream->u4_max_offset)\n         {\n             impeg2d_bit_stream_flush(ps_stream,9);\n         }\n@@ -1322,10 +1324,12 @@\n\n     ps_stream    = &ps_dec->s_bit_stream;\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n \n-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)\n+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1354,7 +1358,8 @@\n\n     while(u4_start_code == USER_DATA_START_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1384,7 +1389,8 @@\n\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n@@ -1436,7 +1442,8 @@\n\n     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while ( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n""}<_**next**_>{""filename"": ""decoder/impeg2d_pic_proc.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_pic_proc.c"", ""patch"": ""@@ -219,7 +219,8 @@\n\n UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)\n {\n     UWORD16 u2_mb_addr_incr = 0;\n-    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)\n+    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&\n+            ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);\n         u2_mb_addr_incr += 33;\n""}","void impeg2d_dec_user_data(dec_state_t *ps_dec)
{
    UWORD32 u4_start_code;
 stream_t *ps_stream;

    ps_stream    = &ps_dec->s_bit_stream;
    u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);


     while(u4_start_code == USER_DATA_START_CODE)
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&
                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
}
","void impeg2d_dec_user_data(dec_state_t *ps_dec)
{
    UWORD32 u4_start_code;
 stream_t *ps_stream;

    ps_stream    = &ps_dec->s_bit_stream;
    u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);


     while(u4_start_code == USER_DATA_START_CODE)
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
}
",C,"        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&
                (ps_stream->u4_offset < ps_stream->u4_max_offset))
","        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
",,"@@ -82,8 +82,8 @@

     ps_stream = &ps_dec->s_bit_stream;
     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)
-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&
+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
 
         if (impeg2d_bit_stream_get(ps_stream,8) != 0)
@@ -111,7 +111,7 @@

     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
         impeg2d_bit_stream_get(ps_stream,8);
     }
@@ -669,7 +669,8 @@

     /*  }                                                                    */
     /*  extra_bit_picture             1                                      */
     /*-----------------------------------------------------------------------*/
-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
+           ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         impeg2d_bit_stream_get(ps_stream,9);
     }
@@ -800,7 +801,8 @@

     {
         impeg2d_bit_stream_flush(ps_stream,9);
         /* Flush extra bit information */
-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
+               ps_stream->u4_offset < ps_stream->u4_max_offset)
         {
             impeg2d_bit_stream_flush(ps_stream,9);
         }
@@ -1322,10 +1324,12 @@

     ps_stream    = &ps_dec->s_bit_stream;
     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 
-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)
+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&
+                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
@@ -1354,7 +1358,8 @@

     while(u4_start_code == USER_DATA_START_CODE)
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&
+                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
@@ -1384,7 +1389,8 @@

     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
@@ -1436,7 +1442,8 @@

     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while ( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
",Android,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3%5E/,1,"void impeg2d_dec_user_data(dec_state_t *ps_dec)
{
    UWORD32 u4_start_code;
 stream_t *ps_stream;

    ps_stream    = &ps_dec->s_bit_stream;
    u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);


     while(u4_start_code == USER_DATA_START_CODE)
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
//flaw_line_below:
        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
//fix_flaw_line_below:
//        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&
//fix_flaw_line_below:
//                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
}
"
10235,187971,,Remote,Not required,,CVE-2016-0824,https://www.cvedetails.com/cve/CVE-2016-0824/,CWE-254,Low,Partial,,,2016-03-12,5.0,"libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",2016-11-28,Bypass +Info ,4,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,ffab15eb80630dc799eb410855c93525b75233c3,"Fixed bit stream access to make sure that it is not read beyond the allocated size.

Bug: 25765591

Change-Id: I98c23a3c3f84f6710f29bffe5ed73adcf51d47f6
",2,decoder/impeg2d_dec_hdr.c,"{""filename"": ""decoder/impeg2d_bitstream.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_bitstream.c"", ""patch"": ""@@ -164,9 +164,12 @@\n\n     if (u4_curr_bit == 31)\n     {\n         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;\n-        u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n \n-        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+        {\n+            u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n+            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        }\n     }\n     ps_stream->u4_offset          = u4_offset;\n \n@@ -189,7 +192,11 @@\n\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n \n-    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+\n+    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+    {\n+        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+    }\n     return;\n }\n /******************************************************************************\n""}<_**next**_>{""filename"": ""decoder/impeg2d_d_pic.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_d_pic.c"", ""patch"": ""@@ -172,7 +172,8 @@\n\n         /*------------------------------------------------------------------*/\n         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n         /*------------------------------------------------------------------*/\n-        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n+        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n+                ps_stream->u4_offset < ps_stream->u4_max_offset)\n             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n \n         /*------------------------------------------------------------------*/\n""}<_**next**_>{""filename"": ""decoder/impeg2d_dec_hdr.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_dec_hdr.c"", ""patch"": ""@@ -82,8 +82,8 @@\n\n     ps_stream = &ps_dec->s_bit_stream;\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&\n+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n \n         if (impeg2d_bit_stream_get(ps_stream,8) != 0)\n@@ -111,7 +111,7 @@\n\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n         impeg2d_bit_stream_get(ps_stream,8);\n     }\n@@ -669,7 +669,8 @@\n\n     /*  }                                                                    */\n     /*  extra_bit_picture             1                                      */\n     /*-----------------------------------------------------------------------*/\n-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+           ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_get(ps_stream,9);\n     }\n@@ -800,7 +801,8 @@\n\n     {\n         impeg2d_bit_stream_flush(ps_stream,9);\n         /* Flush extra bit information */\n-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+               ps_stream->u4_offset < ps_stream->u4_max_offset)\n         {\n             impeg2d_bit_stream_flush(ps_stream,9);\n         }\n@@ -1322,10 +1324,12 @@\n\n     ps_stream    = &ps_dec->s_bit_stream;\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n \n-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)\n+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1354,7 +1358,8 @@\n\n     while(u4_start_code == USER_DATA_START_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1384,7 +1389,8 @@\n\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n@@ -1436,7 +1442,8 @@\n\n     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while ( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n""}<_**next**_>{""filename"": ""decoder/impeg2d_pic_proc.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_pic_proc.c"", ""patch"": ""@@ -219,7 +219,8 @@\n\n UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)\n {\n     UWORD16 u2_mb_addr_incr = 0;\n-    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)\n+    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&\n+            ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);\n         u2_mb_addr_incr += 33;\n""}","void impeg2d_flush_ext_and_user_data(dec_state_t *ps_dec)
{
    UWORD32 u4_start_code;
 stream_t *ps_stream;


     ps_stream    = &ps_dec->s_bit_stream;
     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 
    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&
            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&
                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
}
","void impeg2d_flush_ext_and_user_data(dec_state_t *ps_dec)
{
    UWORD32 u4_start_code;
 stream_t *ps_stream;


     ps_stream    = &ps_dec->s_bit_stream;
     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 
    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
}
",C,"    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&
            (ps_stream->u4_offset < ps_stream->u4_max_offset))
        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&
                (ps_stream->u4_offset < ps_stream->u4_max_offset))
","    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)
        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
",,"@@ -82,8 +82,8 @@

     ps_stream = &ps_dec->s_bit_stream;
     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)
-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&
+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
 
         if (impeg2d_bit_stream_get(ps_stream,8) != 0)
@@ -111,7 +111,7 @@

     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
         impeg2d_bit_stream_get(ps_stream,8);
     }
@@ -669,7 +669,8 @@

     /*  }                                                                    */
     /*  extra_bit_picture             1                                      */
     /*-----------------------------------------------------------------------*/
-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
+           ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         impeg2d_bit_stream_get(ps_stream,9);
     }
@@ -800,7 +801,8 @@

     {
         impeg2d_bit_stream_flush(ps_stream,9);
         /* Flush extra bit information */
-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
+               ps_stream->u4_offset < ps_stream->u4_max_offset)
         {
             impeg2d_bit_stream_flush(ps_stream,9);
         }
@@ -1322,10 +1324,12 @@

     ps_stream    = &ps_dec->s_bit_stream;
     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 
-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)
+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&
+                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
@@ -1354,7 +1358,8 @@

     while(u4_start_code == USER_DATA_START_CODE)
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&
+                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
@@ -1384,7 +1389,8 @@

     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
@@ -1436,7 +1442,8 @@

     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while ( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
",Android,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3%5E/,1,"void impeg2d_flush_ext_and_user_data(dec_state_t *ps_dec)
{
    UWORD32 u4_start_code;
 stream_t *ps_stream;


     ps_stream    = &ps_dec->s_bit_stream;
     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 
//flaw_line_below:
    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)
//fix_flaw_line_below:
//    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&
//fix_flaw_line_below:
//            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
//flaw_line_below:
        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
//fix_flaw_line_below:
//        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&
//fix_flaw_line_below:
//                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
}
"
10236,187972,,Remote,Not required,,CVE-2016-0824,https://www.cvedetails.com/cve/CVE-2016-0824/,CWE-254,Low,Partial,,,2016-03-12,5.0,"libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",2016-11-28,Bypass +Info ,2,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,ffab15eb80630dc799eb410855c93525b75233c3,"Fixed bit stream access to make sure that it is not read beyond the allocated size.

Bug: 25765591

Change-Id: I98c23a3c3f84f6710f29bffe5ed73adcf51d47f6
",2,decoder/impeg2d_dec_hdr.c,"{""filename"": ""decoder/impeg2d_bitstream.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_bitstream.c"", ""patch"": ""@@ -164,9 +164,12 @@\n\n     if (u4_curr_bit == 31)\n     {\n         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;\n-        u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n \n-        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+        {\n+            u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n+            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        }\n     }\n     ps_stream->u4_offset          = u4_offset;\n \n@@ -189,7 +192,11 @@\n\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n \n-    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+\n+    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+    {\n+        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+    }\n     return;\n }\n /******************************************************************************\n""}<_**next**_>{""filename"": ""decoder/impeg2d_d_pic.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_d_pic.c"", ""patch"": ""@@ -172,7 +172,8 @@\n\n         /*------------------------------------------------------------------*/\n         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n         /*------------------------------------------------------------------*/\n-        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n+        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n+                ps_stream->u4_offset < ps_stream->u4_max_offset)\n             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n \n         /*------------------------------------------------------------------*/\n""}<_**next**_>{""filename"": ""decoder/impeg2d_dec_hdr.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_dec_hdr.c"", ""patch"": ""@@ -82,8 +82,8 @@\n\n     ps_stream = &ps_dec->s_bit_stream;\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&\n+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n \n         if (impeg2d_bit_stream_get(ps_stream,8) != 0)\n@@ -111,7 +111,7 @@\n\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n         impeg2d_bit_stream_get(ps_stream,8);\n     }\n@@ -669,7 +669,8 @@\n\n     /*  }                                                                    */\n     /*  extra_bit_picture             1                                      */\n     /*-----------------------------------------------------------------------*/\n-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+           ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_get(ps_stream,9);\n     }\n@@ -800,7 +801,8 @@\n\n     {\n         impeg2d_bit_stream_flush(ps_stream,9);\n         /* Flush extra bit information */\n-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+               ps_stream->u4_offset < ps_stream->u4_max_offset)\n         {\n             impeg2d_bit_stream_flush(ps_stream,9);\n         }\n@@ -1322,10 +1324,12 @@\n\n     ps_stream    = &ps_dec->s_bit_stream;\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n \n-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)\n+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1354,7 +1358,8 @@\n\n     while(u4_start_code == USER_DATA_START_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1384,7 +1389,8 @@\n\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n@@ -1436,7 +1442,8 @@\n\n     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while ( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n""}<_**next**_>{""filename"": ""decoder/impeg2d_pic_proc.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_pic_proc.c"", ""patch"": ""@@ -219,7 +219,8 @@\n\n UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)\n {\n     UWORD16 u2_mb_addr_incr = 0;\n-    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)\n+    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&\n+            ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);\n         u2_mb_addr_incr += 33;\n""}","void impeg2d_next_code(dec_state_t *ps_dec, UWORD32 u4_start_code_val)
{
 stream_t *ps_stream;

     ps_stream = &ps_dec->s_bit_stream;
     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&
            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
 
         if (impeg2d_bit_stream_get(ps_stream,8) != 0)
 {
 /* Ignore stuffing bit errors. */
 }

 }
 return;
}
","void impeg2d_next_code(dec_state_t *ps_dec, UWORD32 u4_start_code_val)
{
 stream_t *ps_stream;

     ps_stream = &ps_dec->s_bit_stream;
     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)
        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
     {
 
         if (impeg2d_bit_stream_get(ps_stream,8) != 0)
 {
 /* Ignore stuffing bit errors. */
 }

 }
 return;
}
",C,"    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&
            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
","    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)
        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
",,"@@ -82,8 +82,8 @@

     ps_stream = &ps_dec->s_bit_stream;
     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)
-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&
+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
 
         if (impeg2d_bit_stream_get(ps_stream,8) != 0)
@@ -111,7 +111,7 @@

     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
         impeg2d_bit_stream_get(ps_stream,8);
     }
@@ -669,7 +669,8 @@

     /*  }                                                                    */
     /*  extra_bit_picture             1                                      */
     /*-----------------------------------------------------------------------*/
-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
+           ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         impeg2d_bit_stream_get(ps_stream,9);
     }
@@ -800,7 +801,8 @@

     {
         impeg2d_bit_stream_flush(ps_stream,9);
         /* Flush extra bit information */
-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
+               ps_stream->u4_offset < ps_stream->u4_max_offset)
         {
             impeg2d_bit_stream_flush(ps_stream,9);
         }
@@ -1322,10 +1324,12 @@

     ps_stream    = &ps_dec->s_bit_stream;
     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 
-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)
+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&
+                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
@@ -1354,7 +1358,8 @@

     while(u4_start_code == USER_DATA_START_CODE)
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&
+                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
@@ -1384,7 +1389,8 @@

     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
@@ -1436,7 +1442,8 @@

     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while ( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
",Android,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3%5E/,1,"void impeg2d_next_code(dec_state_t *ps_dec, UWORD32 u4_start_code_val)
{
 stream_t *ps_stream;

     ps_stream = &ps_dec->s_bit_stream;
     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
//flaw_line_below:
    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)
//flaw_line_below:
        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
//fix_flaw_line_below:
//    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&
//fix_flaw_line_below:
//            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
 
         if (impeg2d_bit_stream_get(ps_stream,8) != 0)
 {
 /* Ignore stuffing bit errors. */
 }

 }
 return;
}
"
10237,187973,,Remote,Not required,,CVE-2016-0824,https://www.cvedetails.com/cve/CVE-2016-0824/,CWE-254,Low,Partial,,,2016-03-12,5.0,"libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",2016-11-28,Bypass +Info ,1,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,ffab15eb80630dc799eb410855c93525b75233c3,"Fixed bit stream access to make sure that it is not read beyond the allocated size.

Bug: 25765591

Change-Id: I98c23a3c3f84f6710f29bffe5ed73adcf51d47f6
",1,decoder/impeg2d_dec_hdr.c,"{""filename"": ""decoder/impeg2d_bitstream.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_bitstream.c"", ""patch"": ""@@ -164,9 +164,12 @@\n\n     if (u4_curr_bit == 31)\n     {\n         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;\n-        u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n \n-        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+        {\n+            u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n+            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        }\n     }\n     ps_stream->u4_offset          = u4_offset;\n \n@@ -189,7 +192,11 @@\n\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n \n-    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+\n+    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+    {\n+        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+    }\n     return;\n }\n /******************************************************************************\n""}<_**next**_>{""filename"": ""decoder/impeg2d_d_pic.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_d_pic.c"", ""patch"": ""@@ -172,7 +172,8 @@\n\n         /*------------------------------------------------------------------*/\n         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n         /*------------------------------------------------------------------*/\n-        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n+        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n+                ps_stream->u4_offset < ps_stream->u4_max_offset)\n             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n \n         /*------------------------------------------------------------------*/\n""}<_**next**_>{""filename"": ""decoder/impeg2d_dec_hdr.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_dec_hdr.c"", ""patch"": ""@@ -82,8 +82,8 @@\n\n     ps_stream = &ps_dec->s_bit_stream;\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&\n+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n \n         if (impeg2d_bit_stream_get(ps_stream,8) != 0)\n@@ -111,7 +111,7 @@\n\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n         impeg2d_bit_stream_get(ps_stream,8);\n     }\n@@ -669,7 +669,8 @@\n\n     /*  }                                                                    */\n     /*  extra_bit_picture             1                                      */\n     /*-----------------------------------------------------------------------*/\n-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+           ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_get(ps_stream,9);\n     }\n@@ -800,7 +801,8 @@\n\n     {\n         impeg2d_bit_stream_flush(ps_stream,9);\n         /* Flush extra bit information */\n-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+               ps_stream->u4_offset < ps_stream->u4_max_offset)\n         {\n             impeg2d_bit_stream_flush(ps_stream,9);\n         }\n@@ -1322,10 +1324,12 @@\n\n     ps_stream    = &ps_dec->s_bit_stream;\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n \n-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)\n+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1354,7 +1358,8 @@\n\n     while(u4_start_code == USER_DATA_START_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1384,7 +1389,8 @@\n\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n@@ -1436,7 +1442,8 @@\n\n     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while ( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n""}<_**next**_>{""filename"": ""decoder/impeg2d_pic_proc.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_pic_proc.c"", ""patch"": ""@@ -219,7 +219,8 @@\n\n UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)\n {\n     UWORD16 u2_mb_addr_incr = 0;\n-    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)\n+    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&\n+            ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);\n         u2_mb_addr_incr += 33;\n""}","void impeg2d_peek_next_start_code(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;

     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
         impeg2d_bit_stream_get(ps_stream,8);
     }
 return;
}
","void impeg2d_peek_next_start_code(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;

     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
     {
         impeg2d_bit_stream_get(ps_stream,8);
     }
 return;
}
",C,"        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
","        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
",,"@@ -82,8 +82,8 @@

     ps_stream = &ps_dec->s_bit_stream;
     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)
-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&
+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
 
         if (impeg2d_bit_stream_get(ps_stream,8) != 0)
@@ -111,7 +111,7 @@

     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
         impeg2d_bit_stream_get(ps_stream,8);
     }
@@ -669,7 +669,8 @@

     /*  }                                                                    */
     /*  extra_bit_picture             1                                      */
     /*-----------------------------------------------------------------------*/
-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
+           ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         impeg2d_bit_stream_get(ps_stream,9);
     }
@@ -800,7 +801,8 @@

     {
         impeg2d_bit_stream_flush(ps_stream,9);
         /* Flush extra bit information */
-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
+               ps_stream->u4_offset < ps_stream->u4_max_offset)
         {
             impeg2d_bit_stream_flush(ps_stream,9);
         }
@@ -1322,10 +1324,12 @@

     ps_stream    = &ps_dec->s_bit_stream;
     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 
-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)
+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&
+                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
@@ -1354,7 +1358,8 @@

     while(u4_start_code == USER_DATA_START_CODE)
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&
+                (ps_stream->u4_offset < ps_stream->u4_max_offset))
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
@@ -1384,7 +1389,8 @@

     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
@@ -1436,7 +1442,8 @@

     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while ( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
+            (ps_stream->u4_offset < ps_stream->u4_max_offset))
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
",Android,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3%5E/,1,"void impeg2d_peek_next_start_code(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;

     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
//flaw_line_below:
        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
//fix_flaw_line_below:
//        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
     {
         impeg2d_bit_stream_get(ps_stream,8);
     }
 return;
}
"
10238,187974,,Remote,Not required,,CVE-2016-0824,https://www.cvedetails.com/cve/CVE-2016-0824/,CWE-254,Low,Partial,,,2016-03-12,5.0,"libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",2016-11-28,Bypass +Info ,2,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,ffab15eb80630dc799eb410855c93525b75233c3,"Fixed bit stream access to make sure that it is not read beyond the allocated size.

Bug: 25765591

Change-Id: I98c23a3c3f84f6710f29bffe5ed73adcf51d47f6
",1,decoder/impeg2d_pic_proc.c,"{""filename"": ""decoder/impeg2d_bitstream.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_bitstream.c"", ""patch"": ""@@ -164,9 +164,12 @@\n\n     if (u4_curr_bit == 31)\n     {\n         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;\n-        u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n \n-        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+        {\n+            u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n+            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        }\n     }\n     ps_stream->u4_offset          = u4_offset;\n \n@@ -189,7 +192,11 @@\n\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n \n-    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+\n+    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+    {\n+        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+    }\n     return;\n }\n /******************************************************************************\n""}<_**next**_>{""filename"": ""decoder/impeg2d_d_pic.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_d_pic.c"", ""patch"": ""@@ -172,7 +172,8 @@\n\n         /*------------------------------------------------------------------*/\n         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n         /*------------------------------------------------------------------*/\n-        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n+        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n+                ps_stream->u4_offset < ps_stream->u4_max_offset)\n             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n \n         /*------------------------------------------------------------------*/\n""}<_**next**_>{""filename"": ""decoder/impeg2d_dec_hdr.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_dec_hdr.c"", ""patch"": ""@@ -82,8 +82,8 @@\n\n     ps_stream = &ps_dec->s_bit_stream;\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&\n+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n \n         if (impeg2d_bit_stream_get(ps_stream,8) != 0)\n@@ -111,7 +111,7 @@\n\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n         impeg2d_bit_stream_get(ps_stream,8);\n     }\n@@ -669,7 +669,8 @@\n\n     /*  }                                                                    */\n     /*  extra_bit_picture             1                                      */\n     /*-----------------------------------------------------------------------*/\n-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+           ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_get(ps_stream,9);\n     }\n@@ -800,7 +801,8 @@\n\n     {\n         impeg2d_bit_stream_flush(ps_stream,9);\n         /* Flush extra bit information */\n-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+               ps_stream->u4_offset < ps_stream->u4_max_offset)\n         {\n             impeg2d_bit_stream_flush(ps_stream,9);\n         }\n@@ -1322,10 +1324,12 @@\n\n     ps_stream    = &ps_dec->s_bit_stream;\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n \n-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)\n+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1354,7 +1358,8 @@\n\n     while(u4_start_code == USER_DATA_START_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n@@ -1384,7 +1389,8 @@\n\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n@@ -1436,7 +1442,8 @@\n\n     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while ( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n""}<_**next**_>{""filename"": ""decoder/impeg2d_pic_proc.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/decoder/impeg2d_pic_proc.c"", ""patch"": ""@@ -219,7 +219,8 @@\n\n UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)\n {\n     UWORD16 u2_mb_addr_incr = 0;\n-    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)\n+    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&\n+            ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);\n         u2_mb_addr_incr += 33;\n""}"," UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)
 {
     UWORD16 u2_mb_addr_incr = 0;
    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&
            ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);
         u2_mb_addr_incr += 33;
 }
    u2_mb_addr_incr += impeg2d_dec_vld_symbol(ps_stream,gai2_impeg2d_mb_addr_incr,MB_ADDR_INCR_LEN) +
        MB_ADDR_INCR_OFFSET;
 return(u2_mb_addr_incr);
}
"," UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)
 {
     UWORD16 u2_mb_addr_incr = 0;
    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)
     {
         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);
         u2_mb_addr_incr += 33;
 }
    u2_mb_addr_incr += impeg2d_dec_vld_symbol(ps_stream,gai2_impeg2d_mb_addr_incr,MB_ADDR_INCR_LEN) +
        MB_ADDR_INCR_OFFSET;
 return(u2_mb_addr_incr);
}
",C,"    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&
            ps_stream->u4_offset < ps_stream->u4_max_offset)
","    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)
",,"@@ -219,7 +219,8 @@

 UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)
 {
     UWORD16 u2_mb_addr_incr = 0;
-    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)
+    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&
+            ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);
         u2_mb_addr_incr += 33;
",Android,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3/,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3%5E/,1," UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)
 {
     UWORD16 u2_mb_addr_incr = 0;
//flaw_line_below:
    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)
//fix_flaw_line_below:
//    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&
//fix_flaw_line_below:
//            ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);
         u2_mb_addr_incr += 33;
 }
    u2_mb_addr_incr += impeg2d_dec_vld_symbol(ps_stream,gai2_impeg2d_mb_addr_incr,MB_ADDR_INCR_LEN) +
        MB_ADDR_INCR_OFFSET;
 return(u2_mb_addr_incr);
}
"
