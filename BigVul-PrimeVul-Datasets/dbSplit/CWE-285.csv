,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
2380,180116,,Remote,Not required,Partial,CVE-2016-7143,https://www.cvedetails.com/cve/CVE-2016-7143/,CWE-285,Medium,Partial,Partial,,2016-09-21,6.8,The m_authenticate function in modules/m_sasl.c in Charybdis before 3.5.3 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter.,2016-11-28,,6,https://github.com/charybdis-ircd/charybdis/commit/818a3fda944b26d4814132cee14cfda4ea4aa824,818a3fda944b26d4814132cee14cfda4ea4aa824,"SASL: Disallow beginning : and space anywhere in AUTHENTICATE parameter

This is a FIX FOR A SECURITY VULNERABILITY. All Charybdis users must
apply this fix if you support SASL on your servers, or unload m_sasl.so
in the meantime.",0,modules/m_sasl.c,"{""sha"": ""93c5a04124f3ee7f5bce71dfd65ced91749c532e"", ""filename"": ""modules/m_sasl.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/charybdis-ircd/charybdis/blob/818a3fda944b26d4814132cee14cfda4ea4aa824/modules/m_sasl.c"", ""raw_url"": ""https://github.com/charybdis-ircd/charybdis/raw/818a3fda944b26d4814132cee14cfda4ea4aa824/modules/m_sasl.c"", ""contents_url"": ""https://api.github.com/repos/charybdis-ircd/charybdis/contents/modules/m_sasl.c?ref=818a3fda944b26d4814132cee14cfda4ea4aa824"", ""patch"": ""@@ -91,6 +91,12 @@ m_authenticate(struct Client *client_p, struct Client *source_p,\n \t\treturn 0;\n \t}\n \n+\tif (*parv[1] == ':' || strchr(parv[1], ' '))\n+\t{\n+\t\texit_client(client_p, client_p, client_p, \""Malformed AUTHENTICATE\"");\n+\t\treturn 0;\n+\t}\n+\n \tsaslserv_p = find_named_client(ConfigFileEntry.sasl_service);\n \tif (saslserv_p == NULL || !IsService(saslserv_p))\n \t{""}","m_authenticate(struct Client *client_p, struct Client *source_p,
	int parc, const char *parv[])
{
	struct Client *agent_p = NULL;
	struct Client *saslserv_p = NULL;

	/* They really should use CAP for their own sake. */
	if(!IsCapable(source_p, CLICAP_SASL))
		return 0;

	if (strlen(client_p->id) == 3)
	{
		exit_client(client_p, client_p, client_p, ""Mixing client and server protocol"");
 		return 0;
 	}
 
	if (*parv[1] == ':' || strchr(parv[1], ' '))
	{
		exit_client(client_p, client_p, client_p, ""Malformed AUTHENTICATE"");
		return 0;
	}

 	saslserv_p = find_named_client(ConfigFileEntry.sasl_service);
 	if (saslserv_p == NULL || !IsService(saslserv_p))
 	{
		sendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
		return 0;
	}

	if(source_p->localClient->sasl_complete)
	{
		*source_p->localClient->sasl_agent = '\0';
		source_p->localClient->sasl_complete = 0;
	}

	if(strlen(parv[1]) > 400)
	{
		sendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
		return 0;
	}

	if(!*source_p->id)
	{
		/* Allocate a UID. */
		strcpy(source_p->id, generate_uid());
		add_to_id_hash(source_p->id, source_p);
	}

	if(*source_p->localClient->sasl_agent)
		agent_p = find_id(source_p->localClient->sasl_agent);

	if(agent_p == NULL)
	{
		sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s H %s %s"",
					me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
					source_p->host, source_p->sockhost);

		if (!strcmp(parv[1], ""EXTERNAL"") && source_p->certfp != NULL)
			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s %s"",
						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
						parv[1], source_p->certfp);
		else
			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s"",
						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
						parv[1]);

		rb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);
	}
	else
		sendto_one(agent_p, "":%s ENCAP %s SASL %s %s C %s"",
				me.id, agent_p->servptr->name, source_p->id, agent_p->id,
				parv[1]);
	source_p->localClient->sasl_out++;

	return 0;
}
","m_authenticate(struct Client *client_p, struct Client *source_p,
	int parc, const char *parv[])
{
	struct Client *agent_p = NULL;
	struct Client *saslserv_p = NULL;

	/* They really should use CAP for their own sake. */
	if(!IsCapable(source_p, CLICAP_SASL))
		return 0;

	if (strlen(client_p->id) == 3)
	{
		exit_client(client_p, client_p, client_p, ""Mixing client and server protocol"");
 		return 0;
 	}
 
 	saslserv_p = find_named_client(ConfigFileEntry.sasl_service);
 	if (saslserv_p == NULL || !IsService(saslserv_p))
 	{
		sendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
		return 0;
	}

	if(source_p->localClient->sasl_complete)
	{
		*source_p->localClient->sasl_agent = '\0';
		source_p->localClient->sasl_complete = 0;
	}

	if(strlen(parv[1]) > 400)
	{
		sendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
		return 0;
	}

	if(!*source_p->id)
	{
		/* Allocate a UID. */
		strcpy(source_p->id, generate_uid());
		add_to_id_hash(source_p->id, source_p);
	}

	if(*source_p->localClient->sasl_agent)
		agent_p = find_id(source_p->localClient->sasl_agent);

	if(agent_p == NULL)
	{
		sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s H %s %s"",
					me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
					source_p->host, source_p->sockhost);

		if (!strcmp(parv[1], ""EXTERNAL"") && source_p->certfp != NULL)
			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s %s"",
						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
						parv[1], source_p->certfp);
		else
			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s"",
						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
						parv[1]);

		rb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);
	}
	else
		sendto_one(agent_p, "":%s ENCAP %s SASL %s %s C %s"",
				me.id, agent_p->servptr->name, source_p->id, agent_p->id,
				parv[1]);
	source_p->localClient->sasl_out++;

	return 0;
}
",C,"	if (*parv[1] == ':' || strchr(parv[1], ' '))
	{
		exit_client(client_p, client_p, client_p, ""Malformed AUTHENTICATE"");
		return 0;
	}

",,,"@@ -91,6 +91,12 @@ m_authenticate(struct Client *client_p, struct Client *source_p,
 		return 0;
 	}
 
+	if (*parv[1] == ':' || strchr(parv[1], ' '))
+	{
+		exit_client(client_p, client_p, client_p, ""Malformed AUTHENTICATE"");
+		return 0;
+	}
+
 	saslserv_p = find_named_client(ConfigFileEntry.sasl_service);
 	if (saslserv_p == NULL || !IsService(saslserv_p))
 	{",charybdis,818a3fda944b26d4814132cee14cfda4ea4aa824,f92b4d81d44580cd6df2d0b2f3cdfd7ad067ecd4,1,"m_authenticate(struct Client *client_p, struct Client *source_p,
	int parc, const char *parv[])
{
	struct Client *agent_p = NULL;
	struct Client *saslserv_p = NULL;

	/* They really should use CAP for their own sake. */
	if(!IsCapable(source_p, CLICAP_SASL))
		return 0;

	if (strlen(client_p->id) == 3)
	{
		exit_client(client_p, client_p, client_p, ""Mixing client and server protocol"");
 		return 0;
 	}
 
//fix_flaw_line_below:
//	if (*parv[1] == ':' || strchr(parv[1], ' '))
//fix_flaw_line_below:
//	{
//fix_flaw_line_below:
//		exit_client(client_p, client_p, client_p, ""Malformed AUTHENTICATE"");
//fix_flaw_line_below:
//		return 0;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	saslserv_p = find_named_client(ConfigFileEntry.sasl_service);
 	if (saslserv_p == NULL || !IsService(saslserv_p))
 	{
		sendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
		return 0;
	}

	if(source_p->localClient->sasl_complete)
	{
		*source_p->localClient->sasl_agent = '\0';
		source_p->localClient->sasl_complete = 0;
	}

	if(strlen(parv[1]) > 400)
	{
		sendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
		return 0;
	}

	if(!*source_p->id)
	{
		/* Allocate a UID. */
		strcpy(source_p->id, generate_uid());
		add_to_id_hash(source_p->id, source_p);
	}

	if(*source_p->localClient->sasl_agent)
		agent_p = find_id(source_p->localClient->sasl_agent);

	if(agent_p == NULL)
	{
		sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s H %s %s"",
					me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
					source_p->host, source_p->sockhost);

		if (!strcmp(parv[1], ""EXTERNAL"") && source_p->certfp != NULL)
			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s %s"",
						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
						parv[1], source_p->certfp);
		else
			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s"",
						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
						parv[1]);

		rb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);
	}
	else
		sendto_one(agent_p, "":%s ENCAP %s SASL %s %s C %s"",
				me.id, agent_p->servptr->name, source_p->id, agent_p->id,
				parv[1]);
	source_p->localClient->sasl_out++;

	return 0;
}
"
2402,180138,,Local,Not required,,CVE-2016-7097,https://www.cvedetails.com/cve/CVE-2016-7097/,CWE-285,Low,Partial,Partial,,2016-10-16,3.6,"The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",2018-01-04,+Priv ,17,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,073931017b49d9458aa351605b43a7e34598caef,"posix_acl: Clear SGID bit when setting file permissions

When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

References: CVE-2016-7097
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>",23,fs/9p/acl.c,"{""sha"": ""b3c2cc79c20d255f5d3cdf59e407ad65c67c7089"", ""filename"": ""fs/9p/acl.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 23, ""changes"": 40, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/9p/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -276,32 +276,26 @@ static int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n \tswitch (handler->flags) {\n \tcase ACL_TYPE_ACCESS:\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (retval < 0)\n+\t\t\tstruct iattr iattr;\n+\n+\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n+\t\t\tif (retval)\n \t\t\t\tgoto err_out;\n-\t\t\telse {\n-\t\t\t\tstruct iattr iattr;\n-\t\t\t\tif (retval == 0) {\n-\t\t\t\t\t/*\n-\t\t\t\t\t * ACL can be represented\n-\t\t\t\t\t * by the mode bits. So don't\n-\t\t\t\t\t * update ACL.\n-\t\t\t\t\t */\n-\t\t\t\t\tacl = NULL;\n-\t\t\t\t\tvalue = NULL;\n-\t\t\t\t\tsize = 0;\n-\t\t\t\t}\n-\t\t\t\t/* Updte the mode bits */\n-\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n-\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n-\t\t\t\tiattr.ia_valid = ATTR_MODE;\n-\t\t\t\t/* FIXME should we update ctime ?\n-\t\t\t\t * What is the following setxattr update the\n-\t\t\t\t * mode ?\n+\t\t\tif (!acl) {\n+\t\t\t\t/*\n+\t\t\t\t * ACL can be represented\n+\t\t\t\t * by the mode bits. So don't\n+\t\t\t\t * update ACL.\n \t\t\t\t */\n-\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n+\t\t\t\tvalue = NULL;\n+\t\t\t\tsize = 0;\n \t\t\t}\n+\t\t\tiattr.ia_valid = ATTR_MODE;\n+\t\t\t/* FIXME should we update ctime ?\n+\t\t\t * What is the following setxattr update the\n+\t\t\t * mode ?\n+\t\t\t */\n+\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""247b8dfaf6e5e53b2f8a898f036375819a1ac225"", ""filename"": ""fs/btrfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -79,11 +79,9 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\treturn ret;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tret = 0;\n \t\tbreak;""}<_**next**_>{""sha"": ""d0b6b342dff982c487880beb9d5bd3868f7502d6"", ""filename"": ""fs/ceph/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ceph/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -95,11 +95,9 @@ int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &new_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\tgoto out;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""e725aa0890e00ea9e97f8255cf9b4c8e082a0bb2"", ""filename"": ""fs/ext2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -190,15 +190,11 @@ ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\tcase ACL_TYPE_ACCESS:\n \t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\t\tif (acl) {\n-\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\t\tif (error < 0)\n+\t\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\t\tif (error)\n \t\t\t\t\treturn error;\n-\t\t\t\telse {\n-\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n-\t\t\t\t\tmark_inode_dirty(inode);\n-\t\t\t\t\tif (error == 0)\n-\t\t\t\t\t\tacl = NULL;\n-\t\t\t\t}\n+\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n+\t\t\t\tmark_inode_dirty(inode);\n \t\t\t}\n \t\t\tbreak;\n ""}<_**next**_>{""sha"": ""dfa519979038b9c2475f335a1f44e8326eb8f799"", ""filename"": ""fs/ext4/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -193,15 +193,11 @@ __ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n-\t\t\t\text4_mark_inode_dirty(handle, inode);\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n+\t\t\tinode->i_ctime = ext4_current_time(inode);\n+\t\t\text4_mark_inode_dirty(handle, inode);\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""31344247ce891bbadf4432a5a1dd9bfeb1e514f9"", ""filename"": ""fs/f2fs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -210,12 +210,10 @@ static int __f2fs_set_acl(struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n \t\t\tset_acl_inode(inode, inode->i_mode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""2524807ee0703643867e7e04c803d10b1aab9182"", ""filename"": ""fs/gfs2/acl.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 9, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -92,17 +92,11 @@ int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tif (type == ACL_TYPE_ACCESS) {\n \t\tumode_t mode = inode->i_mode;\n \n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\tif (error < 0)\n+\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\tif (error)\n \t\t\treturn error;\n-\n-\t\tif (error == 0)\n-\t\t\tacl = NULL;\n-\n-\t\tif (mode != inode->i_mode) {\n-\t\t\tinode->i_mode = mode;\n+\t\tif (mode != inode->i_mode)\n \t\t\tmark_inode_dirty(inode);\n-\t\t}\n \t}\n \n \tif (acl) {""}<_**next**_>{""sha"": ""9b92058a12409d6aa4040ed228ab1d2e5a6d8537"", ""filename"": ""fs/hfsplus/posix_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/hfsplus/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -65,8 +65,8 @@ int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n \tcase ACL_TYPE_ACCESS:\n \t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (err < 0)\n+\t\t\terr = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (err)\n \t\t\t\treturn err;\n \t\t}\n \t\terr = 0;""}<_**next**_>{""sha"": ""2a0f2a1044c16009ff2c48334b48a49157e7aece"", ""filename"": ""fs/jffs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jffs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -233,9 +233,10 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (rc < 0)\n+\t\t\tumode_t mode;\n+\n+\t\t\trc = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tif (inode->i_mode != mode) {\n \t\t\t\tstruct iattr attr;\n@@ -247,8 +248,6 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tif (rc < 0)\n \t\t\t\t\treturn rc;\n \t\t\t}\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""3a1e1554a4e3598132bd6665f05c200922345a9a"", ""filename"": ""fs/jfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -78,13 +78,11 @@ static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (rc < 0)\n+\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tinode->i_ctime = CURRENT_TIME;\n \t\t\tmark_inode_dirty(inode);\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""164307b994052cb658b08cb8c28da524dedfe644"", ""filename"": ""fs/ocfs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 6, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -241,13 +241,11 @@ int ocfs2_set_acl(handle_t *handle,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (ret < 0)\n-\t\t\t\treturn ret;\n+\t\t\tumode_t mode;\n \n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n+\t\t\tret = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (ret)\n+\t\t\t\treturn ret;\n \n \t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n \t\t\t\t\t\t handle, mode);""}<_**next**_>{""sha"": ""7a3754488312c650b3003f5cb23a06bb17a53aeb"", ""filename"": ""fs/orangefs/acl.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 10, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/orangefs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -73,14 +73,11 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\t/*\n-\t\t\t * can we represent this with the traditional file\n-\t\t\t * mode permission bits?\n-\t\t\t */\n-\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (error < 0) {\n-\t\t\t\tgossip_err(\""%s: posix_acl_equiv_mode err: %d\\n\"",\n+\t\t\tumode_t mode;\n+\n+\t\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (error) {\n+\t\t\t\tgossip_err(\""%s: posix_acl_update_mode err: %d\\n\"",\n \t\t\t\t\t   __func__,\n \t\t\t\t\t   error);\n \t\t\t\treturn error;\n@@ -90,8 +87,6 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tSetModeFlag(orangefs_inode);\n \t\t\tinode->i_mode = mode;\n \t\t\tmark_inode_dirty_sync(inode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""bfc3ec38832282ca9834bb06379ffc0132e041c5"", ""filename"": ""fs/posix_acl.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -626,6 +626,37 @@ posix_acl_create(struct inode *dir, umode_t *mode,\n }\n EXPORT_SYMBOL_GPL(posix_acl_create);\n \n+/**\n+ * posix_acl_update_mode  -  update mode in set_acl\n+ *\n+ * Update the file mode when setting an ACL: compute the new file permission\n+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n+ * file mode, set *acl to NULL to indicate that no ACL should be set.\n+ *\n+ * As with chmod, clear the setgit bit if the caller is not in the owning group\n+ * or capable of CAP_FSETID (see inode_change_ok).\n+ *\n+ * Called from set_acl inode operations.\n+ */\n+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n+\t\t\t  struct posix_acl **acl)\n+{\n+\tumode_t mode = inode->i_mode;\n+\tint error;\n+\n+\terror = posix_acl_equiv_mode(*acl, &mode);\n+\tif (error < 0)\n+\t\treturn error;\n+\tif (error == 0)\n+\t\t*acl = NULL;\n+\tif (!in_group_p(inode->i_gid) &&\n+\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n+\t\tmode &= ~S_ISGID;\n+\t*mode_p = mode;\n+\treturn 0;\n+}\n+EXPORT_SYMBOL(posix_acl_update_mode);\n+\n /*\n  * Fix up the uids and gids in posix acl extended attributes in place.\n  */""}<_**next**_>{""sha"": ""27376681c6405f439a6b5026554ee5e20e11e4d5"", ""filename"": ""fs/reiserfs/xattr_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 6, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/xattr_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -242,13 +242,9 @@ __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""8a0dec89ca560622ffa491a7dba8855145889601"", ""filename"": ""fs/xfs/xfs_acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 9, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -257,16 +257,11 @@ xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\treturn error;\n \n \tif (type == ACL_TYPE_ACCESS) {\n-\t\tumode_t mode = inode->i_mode;\n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\n-\t\tif (error <= 0) {\n-\t\t\tacl = NULL;\n-\n-\t\t\tif (error < 0)\n-\t\t\t\treturn error;\n-\t\t}\n+\t\tumode_t mode;\n \n+\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\tif (error)\n+\t\t\treturn error;\n \t\terror = xfs_set_mode(inode, mode);\n \t\tif (error)\n \t\t\treturn error;""}<_**next**_>{""sha"": ""bf1046d0397bbbde8806459faa3833d8bbf2d79f"", ""filename"": ""include/linux/posix_acl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/posix_acl.h?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -93,6 +93,7 @@ extern int set_posix_acl(struct inode *, int, struct posix_acl *);\n extern int posix_acl_chmod(struct inode *, umode_t);\n extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,\n \t\tstruct posix_acl **);\n+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);\n \n extern int simple_set_acl(struct inode *, struct posix_acl *, int);\n extern int simple_acl_create(struct inode *, struct inode *);""}","static int v9fs_xattr_set_acl(const struct xattr_handler *handler,
			      struct dentry *dentry, struct inode *inode,
			      const char *name, const void *value,
			      size_t size, int flags)
{
	int retval;
	struct posix_acl *acl;
	struct v9fs_session_info *v9ses;

	v9ses = v9fs_dentry2v9ses(dentry);
	/*
	 * set the attribute on the remote. Without even looking at the
	 * xattr value. We leave it to the server to validate
	 */
	if ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT)
		return v9fs_xattr_set(dentry, handler->name, value, size,
				      flags);

	if (S_ISLNK(inode->i_mode))
		return -EOPNOTSUPP;
	if (!inode_owner_or_capable(inode))
		return -EPERM;
	if (value) {
		/* update the cached acl value */
		acl = posix_acl_from_xattr(&init_user_ns, value, size);
		if (IS_ERR(acl))
			return PTR_ERR(acl);
		else if (acl) {
			retval = posix_acl_valid(inode->i_sb->s_user_ns, acl);
			if (retval)
				goto err_out;
		}
	} else
		acl = NULL;

 	switch (handler->flags) {
 	case ACL_TYPE_ACCESS:
 		if (acl) {
			struct iattr iattr;

			retval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);
			if (retval)
 				goto err_out;
			if (!acl) {
				/*
				 * ACL can be represented
				 * by the mode bits. So don't
				 * update ACL.
 				 */
				value = NULL;
				size = 0;
 			}
			iattr.ia_valid = ATTR_MODE;
			/* FIXME should we update ctime ?
			 * What is the following setxattr update the
			 * mode ?
			 */
			v9fs_vfs_setattr_dotl(dentry, &iattr);
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		if (!S_ISDIR(inode->i_mode)) {
			retval = acl ? -EINVAL : 0;
			goto err_out;
		}
		break;
	default:
		BUG();
	}
	retval = v9fs_xattr_set(dentry, handler->name, value, size, flags);
	if (!retval)
		set_cached_acl(inode, handler->flags, acl);
err_out:
	posix_acl_release(acl);
	return retval;
}
","static int v9fs_xattr_set_acl(const struct xattr_handler *handler,
			      struct dentry *dentry, struct inode *inode,
			      const char *name, const void *value,
			      size_t size, int flags)
{
	int retval;
	struct posix_acl *acl;
	struct v9fs_session_info *v9ses;

	v9ses = v9fs_dentry2v9ses(dentry);
	/*
	 * set the attribute on the remote. Without even looking at the
	 * xattr value. We leave it to the server to validate
	 */
	if ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT)
		return v9fs_xattr_set(dentry, handler->name, value, size,
				      flags);

	if (S_ISLNK(inode->i_mode))
		return -EOPNOTSUPP;
	if (!inode_owner_or_capable(inode))
		return -EPERM;
	if (value) {
		/* update the cached acl value */
		acl = posix_acl_from_xattr(&init_user_ns, value, size);
		if (IS_ERR(acl))
			return PTR_ERR(acl);
		else if (acl) {
			retval = posix_acl_valid(inode->i_sb->s_user_ns, acl);
			if (retval)
				goto err_out;
		}
	} else
		acl = NULL;

 	switch (handler->flags) {
 	case ACL_TYPE_ACCESS:
 		if (acl) {
			umode_t mode = inode->i_mode;
			retval = posix_acl_equiv_mode(acl, &mode);
			if (retval < 0)
 				goto err_out;
			else {
				struct iattr iattr;
				if (retval == 0) {
					/*
					 * ACL can be represented
					 * by the mode bits. So don't
					 * update ACL.
					 */
					acl = NULL;
					value = NULL;
					size = 0;
				}
				/* Updte the mode bits */
				iattr.ia_mode = ((mode & S_IALLUGO) |
						 (inode->i_mode & ~S_IALLUGO));
				iattr.ia_valid = ATTR_MODE;
				/* FIXME should we update ctime ?
				 * What is the following setxattr update the
				 * mode ?
 				 */
				v9fs_vfs_setattr_dotl(dentry, &iattr);
 			}
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		if (!S_ISDIR(inode->i_mode)) {
			retval = acl ? -EINVAL : 0;
			goto err_out;
		}
		break;
	default:
		BUG();
	}
	retval = v9fs_xattr_set(dentry, handler->name, value, size, flags);
	if (!retval)
		set_cached_acl(inode, handler->flags, acl);
err_out:
	posix_acl_release(acl);
	return retval;
}
",C,"			struct iattr iattr;

			retval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);
			if (retval)
			if (!acl) {
				/*
				 * ACL can be represented
				 * by the mode bits. So don't
				 * update ACL.
				value = NULL;
				size = 0;
			iattr.ia_valid = ATTR_MODE;
			/* FIXME should we update ctime ?
			 * What is the following setxattr update the
			 * mode ?
			 */
			v9fs_vfs_setattr_dotl(dentry, &iattr);
","			umode_t mode = inode->i_mode;
			retval = posix_acl_equiv_mode(acl, &mode);
			if (retval < 0)
			else {
				struct iattr iattr;
				if (retval == 0) {
					/*
					 * ACL can be represented
					 * by the mode bits. So don't
					 * update ACL.
					 */
					acl = NULL;
					value = NULL;
					size = 0;
				}
				/* Updte the mode bits */
				iattr.ia_mode = ((mode & S_IALLUGO) |
						 (inode->i_mode & ~S_IALLUGO));
				iattr.ia_valid = ATTR_MODE;
				/* FIXME should we update ctime ?
				 * What is the following setxattr update the
				 * mode ?
				v9fs_vfs_setattr_dotl(dentry, &iattr);
",,"@@ -276,32 +276,26 @@ static int v9fs_xattr_set_acl(const struct xattr_handler *handler,
 	switch (handler->flags) {
 	case ACL_TYPE_ACCESS:
 		if (acl) {
-			umode_t mode = inode->i_mode;
-			retval = posix_acl_equiv_mode(acl, &mode);
-			if (retval < 0)
+			struct iattr iattr;
+
+			retval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);
+			if (retval)
 				goto err_out;
-			else {
-				struct iattr iattr;
-				if (retval == 0) {
-					/*
-					 * ACL can be represented
-					 * by the mode bits. So don't
-					 * update ACL.
-					 */
-					acl = NULL;
-					value = NULL;
-					size = 0;
-				}
-				/* Updte the mode bits */
-				iattr.ia_mode = ((mode & S_IALLUGO) |
-						 (inode->i_mode & ~S_IALLUGO));
-				iattr.ia_valid = ATTR_MODE;
-				/* FIXME should we update ctime ?
-				 * What is the following setxattr update the
-				 * mode ?
+			if (!acl) {
+				/*
+				 * ACL can be represented
+				 * by the mode bits. So don't
+				 * update ACL.
 				 */
-				v9fs_vfs_setattr_dotl(dentry, &iattr);
+				value = NULL;
+				size = 0;
 			}
+			iattr.ia_valid = ATTR_MODE;
+			/* FIXME should we update ctime ?
+			 * What is the following setxattr update the
+			 * mode ?
+			 */
+			v9fs_vfs_setattr_dotl(dentry, &iattr);
 		}
 		break;
 	case ACL_TYPE_DEFAULT:",linux,073931017b49d9458aa351605b43a7e34598caef,5d3ddd84eaefffd23c028bce5610dac8726f71c1,1,"static int v9fs_xattr_set_acl(const struct xattr_handler *handler,
			      struct dentry *dentry, struct inode *inode,
			      const char *name, const void *value,
			      size_t size, int flags)
{
	int retval;
	struct posix_acl *acl;
	struct v9fs_session_info *v9ses;

	v9ses = v9fs_dentry2v9ses(dentry);
	/*
	 * set the attribute on the remote. Without even looking at the
	 * xattr value. We leave it to the server to validate
	 */
	if ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT)
		return v9fs_xattr_set(dentry, handler->name, value, size,
				      flags);

	if (S_ISLNK(inode->i_mode))
		return -EOPNOTSUPP;
	if (!inode_owner_or_capable(inode))
		return -EPERM;
	if (value) {
		/* update the cached acl value */
		acl = posix_acl_from_xattr(&init_user_ns, value, size);
		if (IS_ERR(acl))
			return PTR_ERR(acl);
		else if (acl) {
			retval = posix_acl_valid(inode->i_sb->s_user_ns, acl);
			if (retval)
				goto err_out;
		}
	} else
		acl = NULL;

 	switch (handler->flags) {
 	case ACL_TYPE_ACCESS:
 		if (acl) {
//flaw_line_below:
			umode_t mode = inode->i_mode;
//flaw_line_below:
			retval = posix_acl_equiv_mode(acl, &mode);
//flaw_line_below:
			if (retval < 0)
//fix_flaw_line_below:
//			struct iattr iattr;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//			retval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);
//fix_flaw_line_below:
//			if (retval)
 				goto err_out;
//flaw_line_below:
			else {
//flaw_line_below:
				struct iattr iattr;
//flaw_line_below:
				if (retval == 0) {
//flaw_line_below:
					/*
//flaw_line_below:
					 * ACL can be represented
//flaw_line_below:
					 * by the mode bits. So don't
//flaw_line_below:
					 * update ACL.
//flaw_line_below:
					 */
//flaw_line_below:
					acl = NULL;
//flaw_line_below:
					value = NULL;
//flaw_line_below:
					size = 0;
//flaw_line_below:
				}
//flaw_line_below:
				/* Updte the mode bits */
//flaw_line_below:
				iattr.ia_mode = ((mode & S_IALLUGO) |
//flaw_line_below:
						 (inode->i_mode & ~S_IALLUGO));
//flaw_line_below:
				iattr.ia_valid = ATTR_MODE;
//flaw_line_below:
				/* FIXME should we update ctime ?
//flaw_line_below:
				 * What is the following setxattr update the
//flaw_line_below:
				 * mode ?
//fix_flaw_line_below:
//			if (!acl) {
//fix_flaw_line_below:
//				/*
//fix_flaw_line_below:
//				 * ACL can be represented
//fix_flaw_line_below:
//				 * by the mode bits. So don't
//fix_flaw_line_below:
//				 * update ACL.
 				 */
//flaw_line_below:
				v9fs_vfs_setattr_dotl(dentry, &iattr);
//fix_flaw_line_below:
//				value = NULL;
//fix_flaw_line_below:
//				size = 0;
 			}
//fix_flaw_line_below:
//			iattr.ia_valid = ATTR_MODE;
//fix_flaw_line_below:
//			/* FIXME should we update ctime ?
//fix_flaw_line_below:
//			 * What is the following setxattr update the
//fix_flaw_line_below:
//			 * mode ?
//fix_flaw_line_below:
//			 */
//fix_flaw_line_below:
//			v9fs_vfs_setattr_dotl(dentry, &iattr);
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		if (!S_ISDIR(inode->i_mode)) {
			retval = acl ? -EINVAL : 0;
			goto err_out;
		}
		break;
	default:
		BUG();
	}
	retval = v9fs_xattr_set(dentry, handler->name, value, size, flags);
	if (!retval)
		set_cached_acl(inode, handler->flags, acl);
err_out:
	posix_acl_release(acl);
	return retval;
}
"
2403,180139,,Local,Not required,,CVE-2016-7097,https://www.cvedetails.com/cve/CVE-2016-7097/,CWE-285,Low,Partial,Partial,,2016-10-16,3.6,"The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",2018-01-04,+Priv ,2,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,073931017b49d9458aa351605b43a7e34598caef,"posix_acl: Clear SGID bit when setting file permissions

When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

References: CVE-2016-7097
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>",4,fs/btrfs/acl.c,"{""sha"": ""b3c2cc79c20d255f5d3cdf59e407ad65c67c7089"", ""filename"": ""fs/9p/acl.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 23, ""changes"": 40, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/9p/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -276,32 +276,26 @@ static int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n \tswitch (handler->flags) {\n \tcase ACL_TYPE_ACCESS:\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (retval < 0)\n+\t\t\tstruct iattr iattr;\n+\n+\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n+\t\t\tif (retval)\n \t\t\t\tgoto err_out;\n-\t\t\telse {\n-\t\t\t\tstruct iattr iattr;\n-\t\t\t\tif (retval == 0) {\n-\t\t\t\t\t/*\n-\t\t\t\t\t * ACL can be represented\n-\t\t\t\t\t * by the mode bits. So don't\n-\t\t\t\t\t * update ACL.\n-\t\t\t\t\t */\n-\t\t\t\t\tacl = NULL;\n-\t\t\t\t\tvalue = NULL;\n-\t\t\t\t\tsize = 0;\n-\t\t\t\t}\n-\t\t\t\t/* Updte the mode bits */\n-\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n-\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n-\t\t\t\tiattr.ia_valid = ATTR_MODE;\n-\t\t\t\t/* FIXME should we update ctime ?\n-\t\t\t\t * What is the following setxattr update the\n-\t\t\t\t * mode ?\n+\t\t\tif (!acl) {\n+\t\t\t\t/*\n+\t\t\t\t * ACL can be represented\n+\t\t\t\t * by the mode bits. So don't\n+\t\t\t\t * update ACL.\n \t\t\t\t */\n-\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n+\t\t\t\tvalue = NULL;\n+\t\t\t\tsize = 0;\n \t\t\t}\n+\t\t\tiattr.ia_valid = ATTR_MODE;\n+\t\t\t/* FIXME should we update ctime ?\n+\t\t\t * What is the following setxattr update the\n+\t\t\t * mode ?\n+\t\t\t */\n+\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""247b8dfaf6e5e53b2f8a898f036375819a1ac225"", ""filename"": ""fs/btrfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -79,11 +79,9 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\treturn ret;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tret = 0;\n \t\tbreak;""}<_**next**_>{""sha"": ""d0b6b342dff982c487880beb9d5bd3868f7502d6"", ""filename"": ""fs/ceph/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ceph/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -95,11 +95,9 @@ int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &new_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\tgoto out;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""e725aa0890e00ea9e97f8255cf9b4c8e082a0bb2"", ""filename"": ""fs/ext2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -190,15 +190,11 @@ ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\tcase ACL_TYPE_ACCESS:\n \t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\t\tif (acl) {\n-\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\t\tif (error < 0)\n+\t\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\t\tif (error)\n \t\t\t\t\treturn error;\n-\t\t\t\telse {\n-\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n-\t\t\t\t\tmark_inode_dirty(inode);\n-\t\t\t\t\tif (error == 0)\n-\t\t\t\t\t\tacl = NULL;\n-\t\t\t\t}\n+\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n+\t\t\t\tmark_inode_dirty(inode);\n \t\t\t}\n \t\t\tbreak;\n ""}<_**next**_>{""sha"": ""dfa519979038b9c2475f335a1f44e8326eb8f799"", ""filename"": ""fs/ext4/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -193,15 +193,11 @@ __ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n-\t\t\t\text4_mark_inode_dirty(handle, inode);\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n+\t\t\tinode->i_ctime = ext4_current_time(inode);\n+\t\t\text4_mark_inode_dirty(handle, inode);\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""31344247ce891bbadf4432a5a1dd9bfeb1e514f9"", ""filename"": ""fs/f2fs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -210,12 +210,10 @@ static int __f2fs_set_acl(struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n \t\t\tset_acl_inode(inode, inode->i_mode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""2524807ee0703643867e7e04c803d10b1aab9182"", ""filename"": ""fs/gfs2/acl.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 9, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -92,17 +92,11 @@ int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tif (type == ACL_TYPE_ACCESS) {\n \t\tumode_t mode = inode->i_mode;\n \n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\tif (error < 0)\n+\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\tif (error)\n \t\t\treturn error;\n-\n-\t\tif (error == 0)\n-\t\t\tacl = NULL;\n-\n-\t\tif (mode != inode->i_mode) {\n-\t\t\tinode->i_mode = mode;\n+\t\tif (mode != inode->i_mode)\n \t\t\tmark_inode_dirty(inode);\n-\t\t}\n \t}\n \n \tif (acl) {""}<_**next**_>{""sha"": ""9b92058a12409d6aa4040ed228ab1d2e5a6d8537"", ""filename"": ""fs/hfsplus/posix_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/hfsplus/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -65,8 +65,8 @@ int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n \tcase ACL_TYPE_ACCESS:\n \t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (err < 0)\n+\t\t\terr = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (err)\n \t\t\t\treturn err;\n \t\t}\n \t\terr = 0;""}<_**next**_>{""sha"": ""2a0f2a1044c16009ff2c48334b48a49157e7aece"", ""filename"": ""fs/jffs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jffs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -233,9 +233,10 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (rc < 0)\n+\t\t\tumode_t mode;\n+\n+\t\t\trc = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tif (inode->i_mode != mode) {\n \t\t\t\tstruct iattr attr;\n@@ -247,8 +248,6 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tif (rc < 0)\n \t\t\t\t\treturn rc;\n \t\t\t}\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""3a1e1554a4e3598132bd6665f05c200922345a9a"", ""filename"": ""fs/jfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -78,13 +78,11 @@ static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (rc < 0)\n+\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tinode->i_ctime = CURRENT_TIME;\n \t\t\tmark_inode_dirty(inode);\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""164307b994052cb658b08cb8c28da524dedfe644"", ""filename"": ""fs/ocfs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 6, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -241,13 +241,11 @@ int ocfs2_set_acl(handle_t *handle,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (ret < 0)\n-\t\t\t\treturn ret;\n+\t\t\tumode_t mode;\n \n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n+\t\t\tret = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (ret)\n+\t\t\t\treturn ret;\n \n \t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n \t\t\t\t\t\t handle, mode);""}<_**next**_>{""sha"": ""7a3754488312c650b3003f5cb23a06bb17a53aeb"", ""filename"": ""fs/orangefs/acl.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 10, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/orangefs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -73,14 +73,11 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\t/*\n-\t\t\t * can we represent this with the traditional file\n-\t\t\t * mode permission bits?\n-\t\t\t */\n-\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (error < 0) {\n-\t\t\t\tgossip_err(\""%s: posix_acl_equiv_mode err: %d\\n\"",\n+\t\t\tumode_t mode;\n+\n+\t\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (error) {\n+\t\t\t\tgossip_err(\""%s: posix_acl_update_mode err: %d\\n\"",\n \t\t\t\t\t   __func__,\n \t\t\t\t\t   error);\n \t\t\t\treturn error;\n@@ -90,8 +87,6 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tSetModeFlag(orangefs_inode);\n \t\t\tinode->i_mode = mode;\n \t\t\tmark_inode_dirty_sync(inode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""bfc3ec38832282ca9834bb06379ffc0132e041c5"", ""filename"": ""fs/posix_acl.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -626,6 +626,37 @@ posix_acl_create(struct inode *dir, umode_t *mode,\n }\n EXPORT_SYMBOL_GPL(posix_acl_create);\n \n+/**\n+ * posix_acl_update_mode  -  update mode in set_acl\n+ *\n+ * Update the file mode when setting an ACL: compute the new file permission\n+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n+ * file mode, set *acl to NULL to indicate that no ACL should be set.\n+ *\n+ * As with chmod, clear the setgit bit if the caller is not in the owning group\n+ * or capable of CAP_FSETID (see inode_change_ok).\n+ *\n+ * Called from set_acl inode operations.\n+ */\n+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n+\t\t\t  struct posix_acl **acl)\n+{\n+\tumode_t mode = inode->i_mode;\n+\tint error;\n+\n+\terror = posix_acl_equiv_mode(*acl, &mode);\n+\tif (error < 0)\n+\t\treturn error;\n+\tif (error == 0)\n+\t\t*acl = NULL;\n+\tif (!in_group_p(inode->i_gid) &&\n+\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n+\t\tmode &= ~S_ISGID;\n+\t*mode_p = mode;\n+\treturn 0;\n+}\n+EXPORT_SYMBOL(posix_acl_update_mode);\n+\n /*\n  * Fix up the uids and gids in posix acl extended attributes in place.\n  */""}<_**next**_>{""sha"": ""27376681c6405f439a6b5026554ee5e20e11e4d5"", ""filename"": ""fs/reiserfs/xattr_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 6, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/xattr_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -242,13 +242,9 @@ __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""8a0dec89ca560622ffa491a7dba8855145889601"", ""filename"": ""fs/xfs/xfs_acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 9, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -257,16 +257,11 @@ xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\treturn error;\n \n \tif (type == ACL_TYPE_ACCESS) {\n-\t\tumode_t mode = inode->i_mode;\n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\n-\t\tif (error <= 0) {\n-\t\t\tacl = NULL;\n-\n-\t\t\tif (error < 0)\n-\t\t\t\treturn error;\n-\t\t}\n+\t\tumode_t mode;\n \n+\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\tif (error)\n+\t\t\treturn error;\n \t\terror = xfs_set_mode(inode, mode);\n \t\tif (error)\n \t\t\treturn error;""}<_**next**_>{""sha"": ""bf1046d0397bbbde8806459faa3833d8bbf2d79f"", ""filename"": ""include/linux/posix_acl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/posix_acl.h?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -93,6 +93,7 @@ extern int set_posix_acl(struct inode *, int, struct posix_acl *);\n extern int posix_acl_chmod(struct inode *, umode_t);\n extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,\n \t\tstruct posix_acl **);\n+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);\n \n extern int simple_set_acl(struct inode *, struct posix_acl *, int);\n extern int simple_acl_create(struct inode *, struct inode *);""}","static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
			 struct inode *inode, struct posix_acl *acl, int type)
{
	int ret, size = 0;
	const char *name;
	char *value = NULL;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
			ret = posix_acl_update_mode(inode, &inode->i_mode, &acl);
			if (ret)
 				return ret;
 		}
 		ret = 0;
 		break;
	case ACL_TYPE_DEFAULT:
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EINVAL : 0;
		name = XATTR_NAME_POSIX_ACL_DEFAULT;
		break;
	default:
		return -EINVAL;
	}

	if (acl) {
		size = posix_acl_xattr_size(acl->a_count);
		value = kmalloc(size, GFP_KERNEL);
		if (!value) {
			ret = -ENOMEM;
			goto out;
		}

		ret = posix_acl_to_xattr(&init_user_ns, acl, value, size);
		if (ret < 0)
			goto out;
	}

	ret = __btrfs_setxattr(trans, inode, name, value, size, 0);
out:
	kfree(value);

	if (!ret)
		set_cached_acl(inode, type, acl);

	return ret;
}
","static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
			 struct inode *inode, struct posix_acl *acl, int type)
{
	int ret, size = 0;
	const char *name;
	char *value = NULL;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
			ret = posix_acl_equiv_mode(acl, &inode->i_mode);
			if (ret < 0)
 				return ret;
			if (ret == 0)
				acl = NULL;
 		}
 		ret = 0;
 		break;
	case ACL_TYPE_DEFAULT:
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EINVAL : 0;
		name = XATTR_NAME_POSIX_ACL_DEFAULT;
		break;
	default:
		return -EINVAL;
	}

	if (acl) {
		size = posix_acl_xattr_size(acl->a_count);
		value = kmalloc(size, GFP_KERNEL);
		if (!value) {
			ret = -ENOMEM;
			goto out;
		}

		ret = posix_acl_to_xattr(&init_user_ns, acl, value, size);
		if (ret < 0)
			goto out;
	}

	ret = __btrfs_setxattr(trans, inode, name, value, size, 0);
out:
	kfree(value);

	if (!ret)
		set_cached_acl(inode, type, acl);

	return ret;
}
",C,"			ret = posix_acl_update_mode(inode, &inode->i_mode, &acl);
			if (ret)
","			ret = posix_acl_equiv_mode(acl, &inode->i_mode);
			if (ret < 0)
			if (ret == 0)
				acl = NULL;
",,"@@ -79,11 +79,9 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
-			ret = posix_acl_equiv_mode(acl, &inode->i_mode);
-			if (ret < 0)
+			ret = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+			if (ret)
 				return ret;
-			if (ret == 0)
-				acl = NULL;
 		}
 		ret = 0;
 		break;",linux,073931017b49d9458aa351605b43a7e34598caef,5d3ddd84eaefffd23c028bce5610dac8726f71c1,1,"static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
			 struct inode *inode, struct posix_acl *acl, int type)
{
	int ret, size = 0;
	const char *name;
	char *value = NULL;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
//flaw_line_below:
			ret = posix_acl_equiv_mode(acl, &inode->i_mode);
//flaw_line_below:
			if (ret < 0)
//fix_flaw_line_below:
//			ret = posix_acl_update_mode(inode, &inode->i_mode, &acl);
//fix_flaw_line_below:
//			if (ret)
 				return ret;
//flaw_line_below:
			if (ret == 0)
//flaw_line_below:
				acl = NULL;
 		}
 		ret = 0;
 		break;
	case ACL_TYPE_DEFAULT:
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EINVAL : 0;
		name = XATTR_NAME_POSIX_ACL_DEFAULT;
		break;
	default:
		return -EINVAL;
	}

	if (acl) {
		size = posix_acl_xattr_size(acl->a_count);
		value = kmalloc(size, GFP_KERNEL);
		if (!value) {
			ret = -ENOMEM;
			goto out;
		}

		ret = posix_acl_to_xattr(&init_user_ns, acl, value, size);
		if (ret < 0)
			goto out;
	}

	ret = __btrfs_setxattr(trans, inode, name, value, size, 0);
out:
	kfree(value);

	if (!ret)
		set_cached_acl(inode, type, acl);

	return ret;
}
"
2404,180140,,Local,Not required,,CVE-2016-7097,https://www.cvedetails.com/cve/CVE-2016-7097/,CWE-285,Low,Partial,Partial,,2016-10-16,3.6,"The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",2018-01-04,+Priv ,2,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,073931017b49d9458aa351605b43a7e34598caef,"posix_acl: Clear SGID bit when setting file permissions

When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

References: CVE-2016-7097
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>",4,fs/ceph/acl.c,"{""sha"": ""b3c2cc79c20d255f5d3cdf59e407ad65c67c7089"", ""filename"": ""fs/9p/acl.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 23, ""changes"": 40, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/9p/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -276,32 +276,26 @@ static int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n \tswitch (handler->flags) {\n \tcase ACL_TYPE_ACCESS:\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (retval < 0)\n+\t\t\tstruct iattr iattr;\n+\n+\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n+\t\t\tif (retval)\n \t\t\t\tgoto err_out;\n-\t\t\telse {\n-\t\t\t\tstruct iattr iattr;\n-\t\t\t\tif (retval == 0) {\n-\t\t\t\t\t/*\n-\t\t\t\t\t * ACL can be represented\n-\t\t\t\t\t * by the mode bits. So don't\n-\t\t\t\t\t * update ACL.\n-\t\t\t\t\t */\n-\t\t\t\t\tacl = NULL;\n-\t\t\t\t\tvalue = NULL;\n-\t\t\t\t\tsize = 0;\n-\t\t\t\t}\n-\t\t\t\t/* Updte the mode bits */\n-\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n-\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n-\t\t\t\tiattr.ia_valid = ATTR_MODE;\n-\t\t\t\t/* FIXME should we update ctime ?\n-\t\t\t\t * What is the following setxattr update the\n-\t\t\t\t * mode ?\n+\t\t\tif (!acl) {\n+\t\t\t\t/*\n+\t\t\t\t * ACL can be represented\n+\t\t\t\t * by the mode bits. So don't\n+\t\t\t\t * update ACL.\n \t\t\t\t */\n-\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n+\t\t\t\tvalue = NULL;\n+\t\t\t\tsize = 0;\n \t\t\t}\n+\t\t\tiattr.ia_valid = ATTR_MODE;\n+\t\t\t/* FIXME should we update ctime ?\n+\t\t\t * What is the following setxattr update the\n+\t\t\t * mode ?\n+\t\t\t */\n+\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""247b8dfaf6e5e53b2f8a898f036375819a1ac225"", ""filename"": ""fs/btrfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -79,11 +79,9 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\treturn ret;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tret = 0;\n \t\tbreak;""}<_**next**_>{""sha"": ""d0b6b342dff982c487880beb9d5bd3868f7502d6"", ""filename"": ""fs/ceph/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ceph/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -95,11 +95,9 @@ int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &new_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\tgoto out;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""e725aa0890e00ea9e97f8255cf9b4c8e082a0bb2"", ""filename"": ""fs/ext2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -190,15 +190,11 @@ ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\tcase ACL_TYPE_ACCESS:\n \t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\t\tif (acl) {\n-\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\t\tif (error < 0)\n+\t\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\t\tif (error)\n \t\t\t\t\treturn error;\n-\t\t\t\telse {\n-\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n-\t\t\t\t\tmark_inode_dirty(inode);\n-\t\t\t\t\tif (error == 0)\n-\t\t\t\t\t\tacl = NULL;\n-\t\t\t\t}\n+\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n+\t\t\t\tmark_inode_dirty(inode);\n \t\t\t}\n \t\t\tbreak;\n ""}<_**next**_>{""sha"": ""dfa519979038b9c2475f335a1f44e8326eb8f799"", ""filename"": ""fs/ext4/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -193,15 +193,11 @@ __ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n-\t\t\t\text4_mark_inode_dirty(handle, inode);\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n+\t\t\tinode->i_ctime = ext4_current_time(inode);\n+\t\t\text4_mark_inode_dirty(handle, inode);\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""31344247ce891bbadf4432a5a1dd9bfeb1e514f9"", ""filename"": ""fs/f2fs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -210,12 +210,10 @@ static int __f2fs_set_acl(struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n \t\t\tset_acl_inode(inode, inode->i_mode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""2524807ee0703643867e7e04c803d10b1aab9182"", ""filename"": ""fs/gfs2/acl.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 9, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -92,17 +92,11 @@ int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tif (type == ACL_TYPE_ACCESS) {\n \t\tumode_t mode = inode->i_mode;\n \n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\tif (error < 0)\n+\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\tif (error)\n \t\t\treturn error;\n-\n-\t\tif (error == 0)\n-\t\t\tacl = NULL;\n-\n-\t\tif (mode != inode->i_mode) {\n-\t\t\tinode->i_mode = mode;\n+\t\tif (mode != inode->i_mode)\n \t\t\tmark_inode_dirty(inode);\n-\t\t}\n \t}\n \n \tif (acl) {""}<_**next**_>{""sha"": ""9b92058a12409d6aa4040ed228ab1d2e5a6d8537"", ""filename"": ""fs/hfsplus/posix_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/hfsplus/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -65,8 +65,8 @@ int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n \tcase ACL_TYPE_ACCESS:\n \t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (err < 0)\n+\t\t\terr = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (err)\n \t\t\t\treturn err;\n \t\t}\n \t\terr = 0;""}<_**next**_>{""sha"": ""2a0f2a1044c16009ff2c48334b48a49157e7aece"", ""filename"": ""fs/jffs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jffs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -233,9 +233,10 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (rc < 0)\n+\t\t\tumode_t mode;\n+\n+\t\t\trc = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tif (inode->i_mode != mode) {\n \t\t\t\tstruct iattr attr;\n@@ -247,8 +248,6 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tif (rc < 0)\n \t\t\t\t\treturn rc;\n \t\t\t}\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""3a1e1554a4e3598132bd6665f05c200922345a9a"", ""filename"": ""fs/jfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -78,13 +78,11 @@ static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (rc < 0)\n+\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tinode->i_ctime = CURRENT_TIME;\n \t\t\tmark_inode_dirty(inode);\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""164307b994052cb658b08cb8c28da524dedfe644"", ""filename"": ""fs/ocfs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 6, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -241,13 +241,11 @@ int ocfs2_set_acl(handle_t *handle,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (ret < 0)\n-\t\t\t\treturn ret;\n+\t\t\tumode_t mode;\n \n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n+\t\t\tret = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (ret)\n+\t\t\t\treturn ret;\n \n \t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n \t\t\t\t\t\t handle, mode);""}<_**next**_>{""sha"": ""7a3754488312c650b3003f5cb23a06bb17a53aeb"", ""filename"": ""fs/orangefs/acl.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 10, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/orangefs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -73,14 +73,11 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\t/*\n-\t\t\t * can we represent this with the traditional file\n-\t\t\t * mode permission bits?\n-\t\t\t */\n-\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (error < 0) {\n-\t\t\t\tgossip_err(\""%s: posix_acl_equiv_mode err: %d\\n\"",\n+\t\t\tumode_t mode;\n+\n+\t\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (error) {\n+\t\t\t\tgossip_err(\""%s: posix_acl_update_mode err: %d\\n\"",\n \t\t\t\t\t   __func__,\n \t\t\t\t\t   error);\n \t\t\t\treturn error;\n@@ -90,8 +87,6 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tSetModeFlag(orangefs_inode);\n \t\t\tinode->i_mode = mode;\n \t\t\tmark_inode_dirty_sync(inode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""bfc3ec38832282ca9834bb06379ffc0132e041c5"", ""filename"": ""fs/posix_acl.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -626,6 +626,37 @@ posix_acl_create(struct inode *dir, umode_t *mode,\n }\n EXPORT_SYMBOL_GPL(posix_acl_create);\n \n+/**\n+ * posix_acl_update_mode  -  update mode in set_acl\n+ *\n+ * Update the file mode when setting an ACL: compute the new file permission\n+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n+ * file mode, set *acl to NULL to indicate that no ACL should be set.\n+ *\n+ * As with chmod, clear the setgit bit if the caller is not in the owning group\n+ * or capable of CAP_FSETID (see inode_change_ok).\n+ *\n+ * Called from set_acl inode operations.\n+ */\n+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n+\t\t\t  struct posix_acl **acl)\n+{\n+\tumode_t mode = inode->i_mode;\n+\tint error;\n+\n+\terror = posix_acl_equiv_mode(*acl, &mode);\n+\tif (error < 0)\n+\t\treturn error;\n+\tif (error == 0)\n+\t\t*acl = NULL;\n+\tif (!in_group_p(inode->i_gid) &&\n+\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n+\t\tmode &= ~S_ISGID;\n+\t*mode_p = mode;\n+\treturn 0;\n+}\n+EXPORT_SYMBOL(posix_acl_update_mode);\n+\n /*\n  * Fix up the uids and gids in posix acl extended attributes in place.\n  */""}<_**next**_>{""sha"": ""27376681c6405f439a6b5026554ee5e20e11e4d5"", ""filename"": ""fs/reiserfs/xattr_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 6, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/xattr_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -242,13 +242,9 @@ __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""8a0dec89ca560622ffa491a7dba8855145889601"", ""filename"": ""fs/xfs/xfs_acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 9, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -257,16 +257,11 @@ xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\treturn error;\n \n \tif (type == ACL_TYPE_ACCESS) {\n-\t\tumode_t mode = inode->i_mode;\n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\n-\t\tif (error <= 0) {\n-\t\t\tacl = NULL;\n-\n-\t\t\tif (error < 0)\n-\t\t\t\treturn error;\n-\t\t}\n+\t\tumode_t mode;\n \n+\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\tif (error)\n+\t\t\treturn error;\n \t\terror = xfs_set_mode(inode, mode);\n \t\tif (error)\n \t\t\treturn error;""}<_**next**_>{""sha"": ""bf1046d0397bbbde8806459faa3833d8bbf2d79f"", ""filename"": ""include/linux/posix_acl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/posix_acl.h?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -93,6 +93,7 @@ extern int set_posix_acl(struct inode *, int, struct posix_acl *);\n extern int posix_acl_chmod(struct inode *, umode_t);\n extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,\n \t\tstruct posix_acl **);\n+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);\n \n extern int simple_set_acl(struct inode *, struct posix_acl *, int);\n extern int simple_acl_create(struct inode *, struct inode *);""}","int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	int ret = 0, size = 0;
	const char *name = NULL;
	char *value = NULL;
	struct iattr newattrs;
	umode_t new_mode = inode->i_mode, old_mode = inode->i_mode;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
			ret = posix_acl_update_mode(inode, &new_mode, &acl);
			if (ret)
 				goto out;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		if (!S_ISDIR(inode->i_mode)) {
			ret = acl ? -EINVAL : 0;
			goto out;
		}
		name = XATTR_NAME_POSIX_ACL_DEFAULT;
		break;
	default:
		ret = -EINVAL;
		goto out;
	}

	if (acl) {
		size = posix_acl_xattr_size(acl->a_count);
		value = kmalloc(size, GFP_NOFS);
		if (!value) {
			ret = -ENOMEM;
			goto out;
		}

		ret = posix_acl_to_xattr(&init_user_ns, acl, value, size);
		if (ret < 0)
			goto out_free;
	}

	if (new_mode != old_mode) {
		newattrs.ia_mode = new_mode;
		newattrs.ia_valid = ATTR_MODE;
		ret = __ceph_setattr(inode, &newattrs);
		if (ret)
			goto out_free;
	}

	ret = __ceph_setxattr(inode, name, value, size, 0);
	if (ret) {
		if (new_mode != old_mode) {
			newattrs.ia_mode = old_mode;
			newattrs.ia_valid = ATTR_MODE;
			__ceph_setattr(inode, &newattrs);
		}
		goto out_free;
	}

	ceph_set_cached_acl(inode, type, acl);

out_free:
	kfree(value);
out:
	return ret;
}
","int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	int ret = 0, size = 0;
	const char *name = NULL;
	char *value = NULL;
	struct iattr newattrs;
	umode_t new_mode = inode->i_mode, old_mode = inode->i_mode;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
			ret = posix_acl_equiv_mode(acl, &new_mode);
			if (ret < 0)
 				goto out;
			if (ret == 0)
				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		if (!S_ISDIR(inode->i_mode)) {
			ret = acl ? -EINVAL : 0;
			goto out;
		}
		name = XATTR_NAME_POSIX_ACL_DEFAULT;
		break;
	default:
		ret = -EINVAL;
		goto out;
	}

	if (acl) {
		size = posix_acl_xattr_size(acl->a_count);
		value = kmalloc(size, GFP_NOFS);
		if (!value) {
			ret = -ENOMEM;
			goto out;
		}

		ret = posix_acl_to_xattr(&init_user_ns, acl, value, size);
		if (ret < 0)
			goto out_free;
	}

	if (new_mode != old_mode) {
		newattrs.ia_mode = new_mode;
		newattrs.ia_valid = ATTR_MODE;
		ret = __ceph_setattr(inode, &newattrs);
		if (ret)
			goto out_free;
	}

	ret = __ceph_setxattr(inode, name, value, size, 0);
	if (ret) {
		if (new_mode != old_mode) {
			newattrs.ia_mode = old_mode;
			newattrs.ia_valid = ATTR_MODE;
			__ceph_setattr(inode, &newattrs);
		}
		goto out_free;
	}

	ceph_set_cached_acl(inode, type, acl);

out_free:
	kfree(value);
out:
	return ret;
}
",C,"			ret = posix_acl_update_mode(inode, &new_mode, &acl);
			if (ret)
","			ret = posix_acl_equiv_mode(acl, &new_mode);
			if (ret < 0)
			if (ret == 0)
				acl = NULL;
",,"@@ -95,11 +95,9 @@ int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
-			ret = posix_acl_equiv_mode(acl, &new_mode);
-			if (ret < 0)
+			ret = posix_acl_update_mode(inode, &new_mode, &acl);
+			if (ret)
 				goto out;
-			if (ret == 0)
-				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:",linux,073931017b49d9458aa351605b43a7e34598caef,5d3ddd84eaefffd23c028bce5610dac8726f71c1,1,"int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	int ret = 0, size = 0;
	const char *name = NULL;
	char *value = NULL;
	struct iattr newattrs;
	umode_t new_mode = inode->i_mode, old_mode = inode->i_mode;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
//flaw_line_below:
			ret = posix_acl_equiv_mode(acl, &new_mode);
//flaw_line_below:
			if (ret < 0)
//fix_flaw_line_below:
//			ret = posix_acl_update_mode(inode, &new_mode, &acl);
//fix_flaw_line_below:
//			if (ret)
 				goto out;
//flaw_line_below:
			if (ret == 0)
//flaw_line_below:
				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		if (!S_ISDIR(inode->i_mode)) {
			ret = acl ? -EINVAL : 0;
			goto out;
		}
		name = XATTR_NAME_POSIX_ACL_DEFAULT;
		break;
	default:
		ret = -EINVAL;
		goto out;
	}

	if (acl) {
		size = posix_acl_xattr_size(acl->a_count);
		value = kmalloc(size, GFP_NOFS);
		if (!value) {
			ret = -ENOMEM;
			goto out;
		}

		ret = posix_acl_to_xattr(&init_user_ns, acl, value, size);
		if (ret < 0)
			goto out_free;
	}

	if (new_mode != old_mode) {
		newattrs.ia_mode = new_mode;
		newattrs.ia_valid = ATTR_MODE;
		ret = __ceph_setattr(inode, &newattrs);
		if (ret)
			goto out_free;
	}

	ret = __ceph_setxattr(inode, name, value, size, 0);
	if (ret) {
		if (new_mode != old_mode) {
			newattrs.ia_mode = old_mode;
			newattrs.ia_valid = ATTR_MODE;
			__ceph_setattr(inode, &newattrs);
		}
		goto out_free;
	}

	ceph_set_cached_acl(inode, type, acl);

out_free:
	kfree(value);
out:
	return ret;
}
"
2405,180141,,Local,Not required,,CVE-2016-7097,https://www.cvedetails.com/cve/CVE-2016-7097/,CWE-285,Low,Partial,Partial,,2016-10-16,3.6,"The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",2018-01-04,+Priv ,4,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,073931017b49d9458aa351605b43a7e34598caef,"posix_acl: Clear SGID bit when setting file permissions

When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

References: CVE-2016-7097
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>",8,fs/ext2/acl.c,"{""sha"": ""b3c2cc79c20d255f5d3cdf59e407ad65c67c7089"", ""filename"": ""fs/9p/acl.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 23, ""changes"": 40, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/9p/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -276,32 +276,26 @@ static int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n \tswitch (handler->flags) {\n \tcase ACL_TYPE_ACCESS:\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (retval < 0)\n+\t\t\tstruct iattr iattr;\n+\n+\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n+\t\t\tif (retval)\n \t\t\t\tgoto err_out;\n-\t\t\telse {\n-\t\t\t\tstruct iattr iattr;\n-\t\t\t\tif (retval == 0) {\n-\t\t\t\t\t/*\n-\t\t\t\t\t * ACL can be represented\n-\t\t\t\t\t * by the mode bits. So don't\n-\t\t\t\t\t * update ACL.\n-\t\t\t\t\t */\n-\t\t\t\t\tacl = NULL;\n-\t\t\t\t\tvalue = NULL;\n-\t\t\t\t\tsize = 0;\n-\t\t\t\t}\n-\t\t\t\t/* Updte the mode bits */\n-\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n-\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n-\t\t\t\tiattr.ia_valid = ATTR_MODE;\n-\t\t\t\t/* FIXME should we update ctime ?\n-\t\t\t\t * What is the following setxattr update the\n-\t\t\t\t * mode ?\n+\t\t\tif (!acl) {\n+\t\t\t\t/*\n+\t\t\t\t * ACL can be represented\n+\t\t\t\t * by the mode bits. So don't\n+\t\t\t\t * update ACL.\n \t\t\t\t */\n-\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n+\t\t\t\tvalue = NULL;\n+\t\t\t\tsize = 0;\n \t\t\t}\n+\t\t\tiattr.ia_valid = ATTR_MODE;\n+\t\t\t/* FIXME should we update ctime ?\n+\t\t\t * What is the following setxattr update the\n+\t\t\t * mode ?\n+\t\t\t */\n+\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""247b8dfaf6e5e53b2f8a898f036375819a1ac225"", ""filename"": ""fs/btrfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -79,11 +79,9 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\treturn ret;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tret = 0;\n \t\tbreak;""}<_**next**_>{""sha"": ""d0b6b342dff982c487880beb9d5bd3868f7502d6"", ""filename"": ""fs/ceph/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ceph/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -95,11 +95,9 @@ int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &new_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\tgoto out;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""e725aa0890e00ea9e97f8255cf9b4c8e082a0bb2"", ""filename"": ""fs/ext2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -190,15 +190,11 @@ ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\tcase ACL_TYPE_ACCESS:\n \t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\t\tif (acl) {\n-\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\t\tif (error < 0)\n+\t\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\t\tif (error)\n \t\t\t\t\treturn error;\n-\t\t\t\telse {\n-\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n-\t\t\t\t\tmark_inode_dirty(inode);\n-\t\t\t\t\tif (error == 0)\n-\t\t\t\t\t\tacl = NULL;\n-\t\t\t\t}\n+\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n+\t\t\t\tmark_inode_dirty(inode);\n \t\t\t}\n \t\t\tbreak;\n ""}<_**next**_>{""sha"": ""dfa519979038b9c2475f335a1f44e8326eb8f799"", ""filename"": ""fs/ext4/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -193,15 +193,11 @@ __ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n-\t\t\t\text4_mark_inode_dirty(handle, inode);\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n+\t\t\tinode->i_ctime = ext4_current_time(inode);\n+\t\t\text4_mark_inode_dirty(handle, inode);\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""31344247ce891bbadf4432a5a1dd9bfeb1e514f9"", ""filename"": ""fs/f2fs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -210,12 +210,10 @@ static int __f2fs_set_acl(struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n \t\t\tset_acl_inode(inode, inode->i_mode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""2524807ee0703643867e7e04c803d10b1aab9182"", ""filename"": ""fs/gfs2/acl.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 9, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -92,17 +92,11 @@ int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tif (type == ACL_TYPE_ACCESS) {\n \t\tumode_t mode = inode->i_mode;\n \n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\tif (error < 0)\n+\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\tif (error)\n \t\t\treturn error;\n-\n-\t\tif (error == 0)\n-\t\t\tacl = NULL;\n-\n-\t\tif (mode != inode->i_mode) {\n-\t\t\tinode->i_mode = mode;\n+\t\tif (mode != inode->i_mode)\n \t\t\tmark_inode_dirty(inode);\n-\t\t}\n \t}\n \n \tif (acl) {""}<_**next**_>{""sha"": ""9b92058a12409d6aa4040ed228ab1d2e5a6d8537"", ""filename"": ""fs/hfsplus/posix_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/hfsplus/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -65,8 +65,8 @@ int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n \tcase ACL_TYPE_ACCESS:\n \t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (err < 0)\n+\t\t\terr = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (err)\n \t\t\t\treturn err;\n \t\t}\n \t\terr = 0;""}<_**next**_>{""sha"": ""2a0f2a1044c16009ff2c48334b48a49157e7aece"", ""filename"": ""fs/jffs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jffs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -233,9 +233,10 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (rc < 0)\n+\t\t\tumode_t mode;\n+\n+\t\t\trc = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tif (inode->i_mode != mode) {\n \t\t\t\tstruct iattr attr;\n@@ -247,8 +248,6 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tif (rc < 0)\n \t\t\t\t\treturn rc;\n \t\t\t}\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""3a1e1554a4e3598132bd6665f05c200922345a9a"", ""filename"": ""fs/jfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -78,13 +78,11 @@ static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (rc < 0)\n+\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tinode->i_ctime = CURRENT_TIME;\n \t\t\tmark_inode_dirty(inode);\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""164307b994052cb658b08cb8c28da524dedfe644"", ""filename"": ""fs/ocfs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 6, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -241,13 +241,11 @@ int ocfs2_set_acl(handle_t *handle,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (ret < 0)\n-\t\t\t\treturn ret;\n+\t\t\tumode_t mode;\n \n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n+\t\t\tret = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (ret)\n+\t\t\t\treturn ret;\n \n \t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n \t\t\t\t\t\t handle, mode);""}<_**next**_>{""sha"": ""7a3754488312c650b3003f5cb23a06bb17a53aeb"", ""filename"": ""fs/orangefs/acl.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 10, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/orangefs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -73,14 +73,11 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\t/*\n-\t\t\t * can we represent this with the traditional file\n-\t\t\t * mode permission bits?\n-\t\t\t */\n-\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (error < 0) {\n-\t\t\t\tgossip_err(\""%s: posix_acl_equiv_mode err: %d\\n\"",\n+\t\t\tumode_t mode;\n+\n+\t\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (error) {\n+\t\t\t\tgossip_err(\""%s: posix_acl_update_mode err: %d\\n\"",\n \t\t\t\t\t   __func__,\n \t\t\t\t\t   error);\n \t\t\t\treturn error;\n@@ -90,8 +87,6 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tSetModeFlag(orangefs_inode);\n \t\t\tinode->i_mode = mode;\n \t\t\tmark_inode_dirty_sync(inode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""bfc3ec38832282ca9834bb06379ffc0132e041c5"", ""filename"": ""fs/posix_acl.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -626,6 +626,37 @@ posix_acl_create(struct inode *dir, umode_t *mode,\n }\n EXPORT_SYMBOL_GPL(posix_acl_create);\n \n+/**\n+ * posix_acl_update_mode  -  update mode in set_acl\n+ *\n+ * Update the file mode when setting an ACL: compute the new file permission\n+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n+ * file mode, set *acl to NULL to indicate that no ACL should be set.\n+ *\n+ * As with chmod, clear the setgit bit if the caller is not in the owning group\n+ * or capable of CAP_FSETID (see inode_change_ok).\n+ *\n+ * Called from set_acl inode operations.\n+ */\n+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n+\t\t\t  struct posix_acl **acl)\n+{\n+\tumode_t mode = inode->i_mode;\n+\tint error;\n+\n+\terror = posix_acl_equiv_mode(*acl, &mode);\n+\tif (error < 0)\n+\t\treturn error;\n+\tif (error == 0)\n+\t\t*acl = NULL;\n+\tif (!in_group_p(inode->i_gid) &&\n+\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n+\t\tmode &= ~S_ISGID;\n+\t*mode_p = mode;\n+\treturn 0;\n+}\n+EXPORT_SYMBOL(posix_acl_update_mode);\n+\n /*\n  * Fix up the uids and gids in posix acl extended attributes in place.\n  */""}<_**next**_>{""sha"": ""27376681c6405f439a6b5026554ee5e20e11e4d5"", ""filename"": ""fs/reiserfs/xattr_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 6, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/xattr_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -242,13 +242,9 @@ __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""8a0dec89ca560622ffa491a7dba8855145889601"", ""filename"": ""fs/xfs/xfs_acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 9, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -257,16 +257,11 @@ xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\treturn error;\n \n \tif (type == ACL_TYPE_ACCESS) {\n-\t\tumode_t mode = inode->i_mode;\n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\n-\t\tif (error <= 0) {\n-\t\t\tacl = NULL;\n-\n-\t\t\tif (error < 0)\n-\t\t\t\treturn error;\n-\t\t}\n+\t\tumode_t mode;\n \n+\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\tif (error)\n+\t\t\treturn error;\n \t\terror = xfs_set_mode(inode, mode);\n \t\tif (error)\n \t\t\treturn error;""}<_**next**_>{""sha"": ""bf1046d0397bbbde8806459faa3833d8bbf2d79f"", ""filename"": ""include/linux/posix_acl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/posix_acl.h?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -93,6 +93,7 @@ extern int set_posix_acl(struct inode *, int, struct posix_acl *);\n extern int posix_acl_chmod(struct inode *, umode_t);\n extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,\n \t\tstruct posix_acl **);\n+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);\n \n extern int simple_set_acl(struct inode *, struct posix_acl *, int);\n extern int simple_acl_create(struct inode *, struct inode *);""}","ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	int name_index;
	void *value = NULL;
	size_t size = 0;
	int error;

	switch(type) {
 		case ACL_TYPE_ACCESS:
 			name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;
 			if (acl) {
				error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
				if (error)
 					return error;
				inode->i_ctime = CURRENT_TIME_SEC;
				mark_inode_dirty(inode);
 			}
 			break;
 
		case ACL_TYPE_DEFAULT:
			name_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT;
			if (!S_ISDIR(inode->i_mode))
				return acl ? -EACCES : 0;
			break;

		default:
			return -EINVAL;
	}
 	if (acl) {
		value = ext2_acl_to_disk(acl, &size);
		if (IS_ERR(value))
			return (int)PTR_ERR(value);
	}

	error = ext2_xattr_set(inode, name_index, """", value, size, 0);

	kfree(value);
	if (!error)
		set_cached_acl(inode, type, acl);
	return error;
}
","ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	int name_index;
	void *value = NULL;
	size_t size = 0;
	int error;

	switch(type) {
 		case ACL_TYPE_ACCESS:
 			name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;
 			if (acl) {
				error = posix_acl_equiv_mode(acl, &inode->i_mode);
				if (error < 0)
 					return error;
				else {
					inode->i_ctime = CURRENT_TIME_SEC;
					mark_inode_dirty(inode);
					if (error == 0)
						acl = NULL;
				}
 			}
 			break;
 
		case ACL_TYPE_DEFAULT:
			name_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT;
			if (!S_ISDIR(inode->i_mode))
				return acl ? -EACCES : 0;
			break;

		default:
			return -EINVAL;
	}
 	if (acl) {
		value = ext2_acl_to_disk(acl, &size);
		if (IS_ERR(value))
			return (int)PTR_ERR(value);
	}

	error = ext2_xattr_set(inode, name_index, """", value, size, 0);

	kfree(value);
	if (!error)
		set_cached_acl(inode, type, acl);
	return error;
}
",C,"				error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
				if (error)
				inode->i_ctime = CURRENT_TIME_SEC;
				mark_inode_dirty(inode);
","				error = posix_acl_equiv_mode(acl, &inode->i_mode);
				if (error < 0)
				else {
					inode->i_ctime = CURRENT_TIME_SEC;
					mark_inode_dirty(inode);
					if (error == 0)
						acl = NULL;
				}
",,"@@ -190,15 +190,11 @@ ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 		case ACL_TYPE_ACCESS:
 			name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;
 			if (acl) {
-				error = posix_acl_equiv_mode(acl, &inode->i_mode);
-				if (error < 0)
+				error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+				if (error)
 					return error;
-				else {
-					inode->i_ctime = CURRENT_TIME_SEC;
-					mark_inode_dirty(inode);
-					if (error == 0)
-						acl = NULL;
-				}
+				inode->i_ctime = CURRENT_TIME_SEC;
+				mark_inode_dirty(inode);
 			}
 			break;
 ",linux,073931017b49d9458aa351605b43a7e34598caef,5d3ddd84eaefffd23c028bce5610dac8726f71c1,1,"ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	int name_index;
	void *value = NULL;
	size_t size = 0;
	int error;

	switch(type) {
 		case ACL_TYPE_ACCESS:
 			name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;
 			if (acl) {
//flaw_line_below:
				error = posix_acl_equiv_mode(acl, &inode->i_mode);
//flaw_line_below:
				if (error < 0)
//fix_flaw_line_below:
//				error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
//fix_flaw_line_below:
//				if (error)
 					return error;
//flaw_line_below:
				else {
//flaw_line_below:
					inode->i_ctime = CURRENT_TIME_SEC;
//flaw_line_below:
					mark_inode_dirty(inode);
//flaw_line_below:
					if (error == 0)
//flaw_line_below:
						acl = NULL;
//flaw_line_below:
				}
//fix_flaw_line_below:
//				inode->i_ctime = CURRENT_TIME_SEC;
//fix_flaw_line_below:
//				mark_inode_dirty(inode);
 			}
 			break;
 
		case ACL_TYPE_DEFAULT:
			name_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT;
			if (!S_ISDIR(inode->i_mode))
				return acl ? -EACCES : 0;
			break;

		default:
			return -EINVAL;
	}
 	if (acl) {
		value = ext2_acl_to_disk(acl, &size);
		if (IS_ERR(value))
			return (int)PTR_ERR(value);
	}

	error = ext2_xattr_set(inode, name_index, """", value, size, 0);

	kfree(value);
	if (!error)
		set_cached_acl(inode, type, acl);
	return error;
}
"
2406,180142,,Local,Not required,,CVE-2016-7097,https://www.cvedetails.com/cve/CVE-2016-7097/,CWE-285,Low,Partial,Partial,,2016-10-16,3.6,"The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",2018-01-04,+Priv ,4,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,073931017b49d9458aa351605b43a7e34598caef,"posix_acl: Clear SGID bit when setting file permissions

When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

References: CVE-2016-7097
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>",8,fs/ext4/acl.c,"{""sha"": ""b3c2cc79c20d255f5d3cdf59e407ad65c67c7089"", ""filename"": ""fs/9p/acl.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 23, ""changes"": 40, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/9p/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -276,32 +276,26 @@ static int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n \tswitch (handler->flags) {\n \tcase ACL_TYPE_ACCESS:\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (retval < 0)\n+\t\t\tstruct iattr iattr;\n+\n+\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n+\t\t\tif (retval)\n \t\t\t\tgoto err_out;\n-\t\t\telse {\n-\t\t\t\tstruct iattr iattr;\n-\t\t\t\tif (retval == 0) {\n-\t\t\t\t\t/*\n-\t\t\t\t\t * ACL can be represented\n-\t\t\t\t\t * by the mode bits. So don't\n-\t\t\t\t\t * update ACL.\n-\t\t\t\t\t */\n-\t\t\t\t\tacl = NULL;\n-\t\t\t\t\tvalue = NULL;\n-\t\t\t\t\tsize = 0;\n-\t\t\t\t}\n-\t\t\t\t/* Updte the mode bits */\n-\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n-\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n-\t\t\t\tiattr.ia_valid = ATTR_MODE;\n-\t\t\t\t/* FIXME should we update ctime ?\n-\t\t\t\t * What is the following setxattr update the\n-\t\t\t\t * mode ?\n+\t\t\tif (!acl) {\n+\t\t\t\t/*\n+\t\t\t\t * ACL can be represented\n+\t\t\t\t * by the mode bits. So don't\n+\t\t\t\t * update ACL.\n \t\t\t\t */\n-\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n+\t\t\t\tvalue = NULL;\n+\t\t\t\tsize = 0;\n \t\t\t}\n+\t\t\tiattr.ia_valid = ATTR_MODE;\n+\t\t\t/* FIXME should we update ctime ?\n+\t\t\t * What is the following setxattr update the\n+\t\t\t * mode ?\n+\t\t\t */\n+\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""247b8dfaf6e5e53b2f8a898f036375819a1ac225"", ""filename"": ""fs/btrfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -79,11 +79,9 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\treturn ret;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tret = 0;\n \t\tbreak;""}<_**next**_>{""sha"": ""d0b6b342dff982c487880beb9d5bd3868f7502d6"", ""filename"": ""fs/ceph/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ceph/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -95,11 +95,9 @@ int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &new_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\tgoto out;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""e725aa0890e00ea9e97f8255cf9b4c8e082a0bb2"", ""filename"": ""fs/ext2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -190,15 +190,11 @@ ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\tcase ACL_TYPE_ACCESS:\n \t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\t\tif (acl) {\n-\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\t\tif (error < 0)\n+\t\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\t\tif (error)\n \t\t\t\t\treturn error;\n-\t\t\t\telse {\n-\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n-\t\t\t\t\tmark_inode_dirty(inode);\n-\t\t\t\t\tif (error == 0)\n-\t\t\t\t\t\tacl = NULL;\n-\t\t\t\t}\n+\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n+\t\t\t\tmark_inode_dirty(inode);\n \t\t\t}\n \t\t\tbreak;\n ""}<_**next**_>{""sha"": ""dfa519979038b9c2475f335a1f44e8326eb8f799"", ""filename"": ""fs/ext4/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -193,15 +193,11 @@ __ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n-\t\t\t\text4_mark_inode_dirty(handle, inode);\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n+\t\t\tinode->i_ctime = ext4_current_time(inode);\n+\t\t\text4_mark_inode_dirty(handle, inode);\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""31344247ce891bbadf4432a5a1dd9bfeb1e514f9"", ""filename"": ""fs/f2fs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -210,12 +210,10 @@ static int __f2fs_set_acl(struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n \t\t\tset_acl_inode(inode, inode->i_mode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""2524807ee0703643867e7e04c803d10b1aab9182"", ""filename"": ""fs/gfs2/acl.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 9, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -92,17 +92,11 @@ int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tif (type == ACL_TYPE_ACCESS) {\n \t\tumode_t mode = inode->i_mode;\n \n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\tif (error < 0)\n+\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\tif (error)\n \t\t\treturn error;\n-\n-\t\tif (error == 0)\n-\t\t\tacl = NULL;\n-\n-\t\tif (mode != inode->i_mode) {\n-\t\t\tinode->i_mode = mode;\n+\t\tif (mode != inode->i_mode)\n \t\t\tmark_inode_dirty(inode);\n-\t\t}\n \t}\n \n \tif (acl) {""}<_**next**_>{""sha"": ""9b92058a12409d6aa4040ed228ab1d2e5a6d8537"", ""filename"": ""fs/hfsplus/posix_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/hfsplus/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -65,8 +65,8 @@ int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n \tcase ACL_TYPE_ACCESS:\n \t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (err < 0)\n+\t\t\terr = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (err)\n \t\t\t\treturn err;\n \t\t}\n \t\terr = 0;""}<_**next**_>{""sha"": ""2a0f2a1044c16009ff2c48334b48a49157e7aece"", ""filename"": ""fs/jffs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jffs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -233,9 +233,10 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (rc < 0)\n+\t\t\tumode_t mode;\n+\n+\t\t\trc = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tif (inode->i_mode != mode) {\n \t\t\t\tstruct iattr attr;\n@@ -247,8 +248,6 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tif (rc < 0)\n \t\t\t\t\treturn rc;\n \t\t\t}\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""3a1e1554a4e3598132bd6665f05c200922345a9a"", ""filename"": ""fs/jfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -78,13 +78,11 @@ static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (rc < 0)\n+\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tinode->i_ctime = CURRENT_TIME;\n \t\t\tmark_inode_dirty(inode);\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""164307b994052cb658b08cb8c28da524dedfe644"", ""filename"": ""fs/ocfs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 6, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -241,13 +241,11 @@ int ocfs2_set_acl(handle_t *handle,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (ret < 0)\n-\t\t\t\treturn ret;\n+\t\t\tumode_t mode;\n \n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n+\t\t\tret = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (ret)\n+\t\t\t\treturn ret;\n \n \t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n \t\t\t\t\t\t handle, mode);""}<_**next**_>{""sha"": ""7a3754488312c650b3003f5cb23a06bb17a53aeb"", ""filename"": ""fs/orangefs/acl.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 10, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/orangefs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -73,14 +73,11 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\t/*\n-\t\t\t * can we represent this with the traditional file\n-\t\t\t * mode permission bits?\n-\t\t\t */\n-\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (error < 0) {\n-\t\t\t\tgossip_err(\""%s: posix_acl_equiv_mode err: %d\\n\"",\n+\t\t\tumode_t mode;\n+\n+\t\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (error) {\n+\t\t\t\tgossip_err(\""%s: posix_acl_update_mode err: %d\\n\"",\n \t\t\t\t\t   __func__,\n \t\t\t\t\t   error);\n \t\t\t\treturn error;\n@@ -90,8 +87,6 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tSetModeFlag(orangefs_inode);\n \t\t\tinode->i_mode = mode;\n \t\t\tmark_inode_dirty_sync(inode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""bfc3ec38832282ca9834bb06379ffc0132e041c5"", ""filename"": ""fs/posix_acl.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -626,6 +626,37 @@ posix_acl_create(struct inode *dir, umode_t *mode,\n }\n EXPORT_SYMBOL_GPL(posix_acl_create);\n \n+/**\n+ * posix_acl_update_mode  -  update mode in set_acl\n+ *\n+ * Update the file mode when setting an ACL: compute the new file permission\n+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n+ * file mode, set *acl to NULL to indicate that no ACL should be set.\n+ *\n+ * As with chmod, clear the setgit bit if the caller is not in the owning group\n+ * or capable of CAP_FSETID (see inode_change_ok).\n+ *\n+ * Called from set_acl inode operations.\n+ */\n+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n+\t\t\t  struct posix_acl **acl)\n+{\n+\tumode_t mode = inode->i_mode;\n+\tint error;\n+\n+\terror = posix_acl_equiv_mode(*acl, &mode);\n+\tif (error < 0)\n+\t\treturn error;\n+\tif (error == 0)\n+\t\t*acl = NULL;\n+\tif (!in_group_p(inode->i_gid) &&\n+\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n+\t\tmode &= ~S_ISGID;\n+\t*mode_p = mode;\n+\treturn 0;\n+}\n+EXPORT_SYMBOL(posix_acl_update_mode);\n+\n /*\n  * Fix up the uids and gids in posix acl extended attributes in place.\n  */""}<_**next**_>{""sha"": ""27376681c6405f439a6b5026554ee5e20e11e4d5"", ""filename"": ""fs/reiserfs/xattr_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 6, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/xattr_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -242,13 +242,9 @@ __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""8a0dec89ca560622ffa491a7dba8855145889601"", ""filename"": ""fs/xfs/xfs_acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 9, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -257,16 +257,11 @@ xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\treturn error;\n \n \tif (type == ACL_TYPE_ACCESS) {\n-\t\tumode_t mode = inode->i_mode;\n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\n-\t\tif (error <= 0) {\n-\t\t\tacl = NULL;\n-\n-\t\t\tif (error < 0)\n-\t\t\t\treturn error;\n-\t\t}\n+\t\tumode_t mode;\n \n+\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\tif (error)\n+\t\t\treturn error;\n \t\terror = xfs_set_mode(inode, mode);\n \t\tif (error)\n \t\t\treturn error;""}<_**next**_>{""sha"": ""bf1046d0397bbbde8806459faa3833d8bbf2d79f"", ""filename"": ""include/linux/posix_acl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/posix_acl.h?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -93,6 +93,7 @@ extern int set_posix_acl(struct inode *, int, struct posix_acl *);\n extern int posix_acl_chmod(struct inode *, umode_t);\n extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,\n \t\tstruct posix_acl **);\n+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);\n \n extern int simple_set_acl(struct inode *, struct posix_acl *, int);\n extern int simple_acl_create(struct inode *, struct inode *);""}","__ext4_set_acl(handle_t *handle, struct inode *inode, int type,
	     struct posix_acl *acl)
{
	int name_index;
	void *value = NULL;
	size_t size = 0;
	int error;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
			if (error)
 				return error;
			inode->i_ctime = ext4_current_time(inode);
			ext4_mark_inode_dirty(handle, inode);
 		}
 		break;
 
	case ACL_TYPE_DEFAULT:
		name_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;

	default:
		return -EINVAL;
	}
	if (acl) {
		value = ext4_acl_to_disk(acl, &size);
		if (IS_ERR(value))
			return (int)PTR_ERR(value);
	}

	error = ext4_xattr_set_handle(handle, inode, name_index, """",
				      value, size, 0);

	kfree(value);
	if (!error)
		set_cached_acl(inode, type, acl);

	return error;
}
","__ext4_set_acl(handle_t *handle, struct inode *inode, int type,
	     struct posix_acl *acl)
{
	int name_index;
	void *value = NULL;
	size_t size = 0;
	int error;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
			error = posix_acl_equiv_mode(acl, &inode->i_mode);
			if (error < 0)
 				return error;
			else {
				inode->i_ctime = ext4_current_time(inode);
				ext4_mark_inode_dirty(handle, inode);
				if (error == 0)
					acl = NULL;
			}
 		}
 		break;
 
	case ACL_TYPE_DEFAULT:
		name_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;

	default:
		return -EINVAL;
	}
	if (acl) {
		value = ext4_acl_to_disk(acl, &size);
		if (IS_ERR(value))
			return (int)PTR_ERR(value);
	}

	error = ext4_xattr_set_handle(handle, inode, name_index, """",
				      value, size, 0);

	kfree(value);
	if (!error)
		set_cached_acl(inode, type, acl);

	return error;
}
",C,"			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
			if (error)
			inode->i_ctime = ext4_current_time(inode);
			ext4_mark_inode_dirty(handle, inode);
","			error = posix_acl_equiv_mode(acl, &inode->i_mode);
			if (error < 0)
			else {
				inode->i_ctime = ext4_current_time(inode);
				ext4_mark_inode_dirty(handle, inode);
				if (error == 0)
					acl = NULL;
			}
",,"@@ -193,15 +193,11 @@ __ext4_set_acl(handle_t *handle, struct inode *inode, int type,
 	case ACL_TYPE_ACCESS:
 		name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
-			error = posix_acl_equiv_mode(acl, &inode->i_mode);
-			if (error < 0)
+			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+			if (error)
 				return error;
-			else {
-				inode->i_ctime = ext4_current_time(inode);
-				ext4_mark_inode_dirty(handle, inode);
-				if (error == 0)
-					acl = NULL;
-			}
+			inode->i_ctime = ext4_current_time(inode);
+			ext4_mark_inode_dirty(handle, inode);
 		}
 		break;
 ",linux,073931017b49d9458aa351605b43a7e34598caef,5d3ddd84eaefffd23c028bce5610dac8726f71c1,1,"__ext4_set_acl(handle_t *handle, struct inode *inode, int type,
	     struct posix_acl *acl)
{
	int name_index;
	void *value = NULL;
	size_t size = 0;
	int error;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
//flaw_line_below:
			error = posix_acl_equiv_mode(acl, &inode->i_mode);
//flaw_line_below:
			if (error < 0)
//fix_flaw_line_below:
//			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
//fix_flaw_line_below:
//			if (error)
 				return error;
//flaw_line_below:
			else {
//flaw_line_below:
				inode->i_ctime = ext4_current_time(inode);
//flaw_line_below:
				ext4_mark_inode_dirty(handle, inode);
//flaw_line_below:
				if (error == 0)
//flaw_line_below:
					acl = NULL;
//flaw_line_below:
			}
//fix_flaw_line_below:
//			inode->i_ctime = ext4_current_time(inode);
//fix_flaw_line_below:
//			ext4_mark_inode_dirty(handle, inode);
 		}
 		break;
 
	case ACL_TYPE_DEFAULT:
		name_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;

	default:
		return -EINVAL;
	}
	if (acl) {
		value = ext4_acl_to_disk(acl, &size);
		if (IS_ERR(value))
			return (int)PTR_ERR(value);
	}

	error = ext4_xattr_set_handle(handle, inode, name_index, """",
				      value, size, 0);

	kfree(value);
	if (!error)
		set_cached_acl(inode, type, acl);

	return error;
}
"
2407,180143,,Local,Not required,,CVE-2016-7097,https://www.cvedetails.com/cve/CVE-2016-7097/,CWE-285,Low,Partial,Partial,,2016-10-16,3.6,"The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",2018-01-04,+Priv ,2,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,073931017b49d9458aa351605b43a7e34598caef,"posix_acl: Clear SGID bit when setting file permissions

When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

References: CVE-2016-7097
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>",4,fs/f2fs/acl.c,"{""sha"": ""b3c2cc79c20d255f5d3cdf59e407ad65c67c7089"", ""filename"": ""fs/9p/acl.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 23, ""changes"": 40, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/9p/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -276,32 +276,26 @@ static int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n \tswitch (handler->flags) {\n \tcase ACL_TYPE_ACCESS:\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (retval < 0)\n+\t\t\tstruct iattr iattr;\n+\n+\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n+\t\t\tif (retval)\n \t\t\t\tgoto err_out;\n-\t\t\telse {\n-\t\t\t\tstruct iattr iattr;\n-\t\t\t\tif (retval == 0) {\n-\t\t\t\t\t/*\n-\t\t\t\t\t * ACL can be represented\n-\t\t\t\t\t * by the mode bits. So don't\n-\t\t\t\t\t * update ACL.\n-\t\t\t\t\t */\n-\t\t\t\t\tacl = NULL;\n-\t\t\t\t\tvalue = NULL;\n-\t\t\t\t\tsize = 0;\n-\t\t\t\t}\n-\t\t\t\t/* Updte the mode bits */\n-\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n-\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n-\t\t\t\tiattr.ia_valid = ATTR_MODE;\n-\t\t\t\t/* FIXME should we update ctime ?\n-\t\t\t\t * What is the following setxattr update the\n-\t\t\t\t * mode ?\n+\t\t\tif (!acl) {\n+\t\t\t\t/*\n+\t\t\t\t * ACL can be represented\n+\t\t\t\t * by the mode bits. So don't\n+\t\t\t\t * update ACL.\n \t\t\t\t */\n-\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n+\t\t\t\tvalue = NULL;\n+\t\t\t\tsize = 0;\n \t\t\t}\n+\t\t\tiattr.ia_valid = ATTR_MODE;\n+\t\t\t/* FIXME should we update ctime ?\n+\t\t\t * What is the following setxattr update the\n+\t\t\t * mode ?\n+\t\t\t */\n+\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""247b8dfaf6e5e53b2f8a898f036375819a1ac225"", ""filename"": ""fs/btrfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -79,11 +79,9 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\treturn ret;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tret = 0;\n \t\tbreak;""}<_**next**_>{""sha"": ""d0b6b342dff982c487880beb9d5bd3868f7502d6"", ""filename"": ""fs/ceph/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ceph/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -95,11 +95,9 @@ int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &new_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\tgoto out;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""e725aa0890e00ea9e97f8255cf9b4c8e082a0bb2"", ""filename"": ""fs/ext2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -190,15 +190,11 @@ ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\tcase ACL_TYPE_ACCESS:\n \t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\t\tif (acl) {\n-\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\t\tif (error < 0)\n+\t\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\t\tif (error)\n \t\t\t\t\treturn error;\n-\t\t\t\telse {\n-\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n-\t\t\t\t\tmark_inode_dirty(inode);\n-\t\t\t\t\tif (error == 0)\n-\t\t\t\t\t\tacl = NULL;\n-\t\t\t\t}\n+\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n+\t\t\t\tmark_inode_dirty(inode);\n \t\t\t}\n \t\t\tbreak;\n ""}<_**next**_>{""sha"": ""dfa519979038b9c2475f335a1f44e8326eb8f799"", ""filename"": ""fs/ext4/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -193,15 +193,11 @@ __ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n-\t\t\t\text4_mark_inode_dirty(handle, inode);\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n+\t\t\tinode->i_ctime = ext4_current_time(inode);\n+\t\t\text4_mark_inode_dirty(handle, inode);\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""31344247ce891bbadf4432a5a1dd9bfeb1e514f9"", ""filename"": ""fs/f2fs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -210,12 +210,10 @@ static int __f2fs_set_acl(struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n \t\t\tset_acl_inode(inode, inode->i_mode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""2524807ee0703643867e7e04c803d10b1aab9182"", ""filename"": ""fs/gfs2/acl.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 9, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -92,17 +92,11 @@ int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tif (type == ACL_TYPE_ACCESS) {\n \t\tumode_t mode = inode->i_mode;\n \n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\tif (error < 0)\n+\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\tif (error)\n \t\t\treturn error;\n-\n-\t\tif (error == 0)\n-\t\t\tacl = NULL;\n-\n-\t\tif (mode != inode->i_mode) {\n-\t\t\tinode->i_mode = mode;\n+\t\tif (mode != inode->i_mode)\n \t\t\tmark_inode_dirty(inode);\n-\t\t}\n \t}\n \n \tif (acl) {""}<_**next**_>{""sha"": ""9b92058a12409d6aa4040ed228ab1d2e5a6d8537"", ""filename"": ""fs/hfsplus/posix_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/hfsplus/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -65,8 +65,8 @@ int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n \tcase ACL_TYPE_ACCESS:\n \t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (err < 0)\n+\t\t\terr = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (err)\n \t\t\t\treturn err;\n \t\t}\n \t\terr = 0;""}<_**next**_>{""sha"": ""2a0f2a1044c16009ff2c48334b48a49157e7aece"", ""filename"": ""fs/jffs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jffs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -233,9 +233,10 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (rc < 0)\n+\t\t\tumode_t mode;\n+\n+\t\t\trc = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tif (inode->i_mode != mode) {\n \t\t\t\tstruct iattr attr;\n@@ -247,8 +248,6 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tif (rc < 0)\n \t\t\t\t\treturn rc;\n \t\t\t}\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""3a1e1554a4e3598132bd6665f05c200922345a9a"", ""filename"": ""fs/jfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -78,13 +78,11 @@ static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (rc < 0)\n+\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tinode->i_ctime = CURRENT_TIME;\n \t\t\tmark_inode_dirty(inode);\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""164307b994052cb658b08cb8c28da524dedfe644"", ""filename"": ""fs/ocfs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 6, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -241,13 +241,11 @@ int ocfs2_set_acl(handle_t *handle,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (ret < 0)\n-\t\t\t\treturn ret;\n+\t\t\tumode_t mode;\n \n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n+\t\t\tret = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (ret)\n+\t\t\t\treturn ret;\n \n \t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n \t\t\t\t\t\t handle, mode);""}<_**next**_>{""sha"": ""7a3754488312c650b3003f5cb23a06bb17a53aeb"", ""filename"": ""fs/orangefs/acl.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 10, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/orangefs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -73,14 +73,11 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\t/*\n-\t\t\t * can we represent this with the traditional file\n-\t\t\t * mode permission bits?\n-\t\t\t */\n-\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (error < 0) {\n-\t\t\t\tgossip_err(\""%s: posix_acl_equiv_mode err: %d\\n\"",\n+\t\t\tumode_t mode;\n+\n+\t\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (error) {\n+\t\t\t\tgossip_err(\""%s: posix_acl_update_mode err: %d\\n\"",\n \t\t\t\t\t   __func__,\n \t\t\t\t\t   error);\n \t\t\t\treturn error;\n@@ -90,8 +87,6 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tSetModeFlag(orangefs_inode);\n \t\t\tinode->i_mode = mode;\n \t\t\tmark_inode_dirty_sync(inode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""bfc3ec38832282ca9834bb06379ffc0132e041c5"", ""filename"": ""fs/posix_acl.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -626,6 +626,37 @@ posix_acl_create(struct inode *dir, umode_t *mode,\n }\n EXPORT_SYMBOL_GPL(posix_acl_create);\n \n+/**\n+ * posix_acl_update_mode  -  update mode in set_acl\n+ *\n+ * Update the file mode when setting an ACL: compute the new file permission\n+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n+ * file mode, set *acl to NULL to indicate that no ACL should be set.\n+ *\n+ * As with chmod, clear the setgit bit if the caller is not in the owning group\n+ * or capable of CAP_FSETID (see inode_change_ok).\n+ *\n+ * Called from set_acl inode operations.\n+ */\n+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n+\t\t\t  struct posix_acl **acl)\n+{\n+\tumode_t mode = inode->i_mode;\n+\tint error;\n+\n+\terror = posix_acl_equiv_mode(*acl, &mode);\n+\tif (error < 0)\n+\t\treturn error;\n+\tif (error == 0)\n+\t\t*acl = NULL;\n+\tif (!in_group_p(inode->i_gid) &&\n+\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n+\t\tmode &= ~S_ISGID;\n+\t*mode_p = mode;\n+\treturn 0;\n+}\n+EXPORT_SYMBOL(posix_acl_update_mode);\n+\n /*\n  * Fix up the uids and gids in posix acl extended attributes in place.\n  */""}<_**next**_>{""sha"": ""27376681c6405f439a6b5026554ee5e20e11e4d5"", ""filename"": ""fs/reiserfs/xattr_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 6, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/xattr_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -242,13 +242,9 @@ __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""8a0dec89ca560622ffa491a7dba8855145889601"", ""filename"": ""fs/xfs/xfs_acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 9, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -257,16 +257,11 @@ xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\treturn error;\n \n \tif (type == ACL_TYPE_ACCESS) {\n-\t\tumode_t mode = inode->i_mode;\n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\n-\t\tif (error <= 0) {\n-\t\t\tacl = NULL;\n-\n-\t\t\tif (error < 0)\n-\t\t\t\treturn error;\n-\t\t}\n+\t\tumode_t mode;\n \n+\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\tif (error)\n+\t\t\treturn error;\n \t\terror = xfs_set_mode(inode, mode);\n \t\tif (error)\n \t\t\treturn error;""}<_**next**_>{""sha"": ""bf1046d0397bbbde8806459faa3833d8bbf2d79f"", ""filename"": ""include/linux/posix_acl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/posix_acl.h?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -93,6 +93,7 @@ extern int set_posix_acl(struct inode *, int, struct posix_acl *);\n extern int posix_acl_chmod(struct inode *, umode_t);\n extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,\n \t\tstruct posix_acl **);\n+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);\n \n extern int simple_set_acl(struct inode *, struct posix_acl *, int);\n extern int simple_acl_create(struct inode *, struct inode *);""}","static int __f2fs_set_acl(struct inode *inode, int type,
			struct posix_acl *acl, struct page *ipage)
{
	int name_index;
	void *value = NULL;
	size_t size = 0;
	int error;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
			if (error)
 				return error;
 			set_acl_inode(inode, inode->i_mode);
 		}
 		break;
 
	case ACL_TYPE_DEFAULT:
		name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;

	default:
		return -EINVAL;
	}

	if (acl) {
		value = f2fs_acl_to_disk(acl, &size);
		if (IS_ERR(value)) {
			clear_inode_flag(inode, FI_ACL_MODE);
			return (int)PTR_ERR(value);
		}
	}

	error = f2fs_setxattr(inode, name_index, """", value, size, ipage, 0);

	kfree(value);
	if (!error)
		set_cached_acl(inode, type, acl);

	clear_inode_flag(inode, FI_ACL_MODE);
	return error;
}
","static int __f2fs_set_acl(struct inode *inode, int type,
			struct posix_acl *acl, struct page *ipage)
{
	int name_index;
	void *value = NULL;
	size_t size = 0;
	int error;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
			error = posix_acl_equiv_mode(acl, &inode->i_mode);
			if (error < 0)
 				return error;
 			set_acl_inode(inode, inode->i_mode);
			if (error == 0)
				acl = NULL;
 		}
 		break;
 
	case ACL_TYPE_DEFAULT:
		name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;

	default:
		return -EINVAL;
	}

	if (acl) {
		value = f2fs_acl_to_disk(acl, &size);
		if (IS_ERR(value)) {
			clear_inode_flag(inode, FI_ACL_MODE);
			return (int)PTR_ERR(value);
		}
	}

	error = f2fs_setxattr(inode, name_index, """", value, size, ipage, 0);

	kfree(value);
	if (!error)
		set_cached_acl(inode, type, acl);

	clear_inode_flag(inode, FI_ACL_MODE);
	return error;
}
",C,"			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
			if (error)
","			error = posix_acl_equiv_mode(acl, &inode->i_mode);
			if (error < 0)
			if (error == 0)
				acl = NULL;
",,"@@ -210,12 +210,10 @@ static int __f2fs_set_acl(struct inode *inode, int type,
 	case ACL_TYPE_ACCESS:
 		name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
-			error = posix_acl_equiv_mode(acl, &inode->i_mode);
-			if (error < 0)
+			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+			if (error)
 				return error;
 			set_acl_inode(inode, inode->i_mode);
-			if (error == 0)
-				acl = NULL;
 		}
 		break;
 ",linux,073931017b49d9458aa351605b43a7e34598caef,5d3ddd84eaefffd23c028bce5610dac8726f71c1,1,"static int __f2fs_set_acl(struct inode *inode, int type,
			struct posix_acl *acl, struct page *ipage)
{
	int name_index;
	void *value = NULL;
	size_t size = 0;
	int error;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
//flaw_line_below:
			error = posix_acl_equiv_mode(acl, &inode->i_mode);
//flaw_line_below:
			if (error < 0)
//fix_flaw_line_below:
//			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
//fix_flaw_line_below:
//			if (error)
 				return error;
 			set_acl_inode(inode, inode->i_mode);
//flaw_line_below:
			if (error == 0)
//flaw_line_below:
				acl = NULL;
 		}
 		break;
 
	case ACL_TYPE_DEFAULT:
		name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;

	default:
		return -EINVAL;
	}

	if (acl) {
		value = f2fs_acl_to_disk(acl, &size);
		if (IS_ERR(value)) {
			clear_inode_flag(inode, FI_ACL_MODE);
			return (int)PTR_ERR(value);
		}
	}

	error = f2fs_setxattr(inode, name_index, """", value, size, ipage, 0);

	kfree(value);
	if (!error)
		set_cached_acl(inode, type, acl);

	clear_inode_flag(inode, FI_ACL_MODE);
	return error;
}
"
2408,180144,,Local,Not required,,CVE-2016-7097,https://www.cvedetails.com/cve/CVE-2016-7097/,CWE-285,Low,Partial,Partial,,2016-10-16,3.6,"The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",2018-01-04,+Priv ,3,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,073931017b49d9458aa351605b43a7e34598caef,"posix_acl: Clear SGID bit when setting file permissions

When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

References: CVE-2016-7097
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>",7,fs/gfs2/acl.c,"{""sha"": ""b3c2cc79c20d255f5d3cdf59e407ad65c67c7089"", ""filename"": ""fs/9p/acl.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 23, ""changes"": 40, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/9p/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -276,32 +276,26 @@ static int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n \tswitch (handler->flags) {\n \tcase ACL_TYPE_ACCESS:\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (retval < 0)\n+\t\t\tstruct iattr iattr;\n+\n+\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n+\t\t\tif (retval)\n \t\t\t\tgoto err_out;\n-\t\t\telse {\n-\t\t\t\tstruct iattr iattr;\n-\t\t\t\tif (retval == 0) {\n-\t\t\t\t\t/*\n-\t\t\t\t\t * ACL can be represented\n-\t\t\t\t\t * by the mode bits. So don't\n-\t\t\t\t\t * update ACL.\n-\t\t\t\t\t */\n-\t\t\t\t\tacl = NULL;\n-\t\t\t\t\tvalue = NULL;\n-\t\t\t\t\tsize = 0;\n-\t\t\t\t}\n-\t\t\t\t/* Updte the mode bits */\n-\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n-\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n-\t\t\t\tiattr.ia_valid = ATTR_MODE;\n-\t\t\t\t/* FIXME should we update ctime ?\n-\t\t\t\t * What is the following setxattr update the\n-\t\t\t\t * mode ?\n+\t\t\tif (!acl) {\n+\t\t\t\t/*\n+\t\t\t\t * ACL can be represented\n+\t\t\t\t * by the mode bits. So don't\n+\t\t\t\t * update ACL.\n \t\t\t\t */\n-\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n+\t\t\t\tvalue = NULL;\n+\t\t\t\tsize = 0;\n \t\t\t}\n+\t\t\tiattr.ia_valid = ATTR_MODE;\n+\t\t\t/* FIXME should we update ctime ?\n+\t\t\t * What is the following setxattr update the\n+\t\t\t * mode ?\n+\t\t\t */\n+\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""247b8dfaf6e5e53b2f8a898f036375819a1ac225"", ""filename"": ""fs/btrfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -79,11 +79,9 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\treturn ret;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tret = 0;\n \t\tbreak;""}<_**next**_>{""sha"": ""d0b6b342dff982c487880beb9d5bd3868f7502d6"", ""filename"": ""fs/ceph/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ceph/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -95,11 +95,9 @@ int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &new_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\tgoto out;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""e725aa0890e00ea9e97f8255cf9b4c8e082a0bb2"", ""filename"": ""fs/ext2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -190,15 +190,11 @@ ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\tcase ACL_TYPE_ACCESS:\n \t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\t\tif (acl) {\n-\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\t\tif (error < 0)\n+\t\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\t\tif (error)\n \t\t\t\t\treturn error;\n-\t\t\t\telse {\n-\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n-\t\t\t\t\tmark_inode_dirty(inode);\n-\t\t\t\t\tif (error == 0)\n-\t\t\t\t\t\tacl = NULL;\n-\t\t\t\t}\n+\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n+\t\t\t\tmark_inode_dirty(inode);\n \t\t\t}\n \t\t\tbreak;\n ""}<_**next**_>{""sha"": ""dfa519979038b9c2475f335a1f44e8326eb8f799"", ""filename"": ""fs/ext4/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -193,15 +193,11 @@ __ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n-\t\t\t\text4_mark_inode_dirty(handle, inode);\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n+\t\t\tinode->i_ctime = ext4_current_time(inode);\n+\t\t\text4_mark_inode_dirty(handle, inode);\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""31344247ce891bbadf4432a5a1dd9bfeb1e514f9"", ""filename"": ""fs/f2fs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -210,12 +210,10 @@ static int __f2fs_set_acl(struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n \t\t\tset_acl_inode(inode, inode->i_mode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""2524807ee0703643867e7e04c803d10b1aab9182"", ""filename"": ""fs/gfs2/acl.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 9, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -92,17 +92,11 @@ int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tif (type == ACL_TYPE_ACCESS) {\n \t\tumode_t mode = inode->i_mode;\n \n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\tif (error < 0)\n+\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\tif (error)\n \t\t\treturn error;\n-\n-\t\tif (error == 0)\n-\t\t\tacl = NULL;\n-\n-\t\tif (mode != inode->i_mode) {\n-\t\t\tinode->i_mode = mode;\n+\t\tif (mode != inode->i_mode)\n \t\t\tmark_inode_dirty(inode);\n-\t\t}\n \t}\n \n \tif (acl) {""}<_**next**_>{""sha"": ""9b92058a12409d6aa4040ed228ab1d2e5a6d8537"", ""filename"": ""fs/hfsplus/posix_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/hfsplus/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -65,8 +65,8 @@ int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n \tcase ACL_TYPE_ACCESS:\n \t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (err < 0)\n+\t\t\terr = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (err)\n \t\t\t\treturn err;\n \t\t}\n \t\terr = 0;""}<_**next**_>{""sha"": ""2a0f2a1044c16009ff2c48334b48a49157e7aece"", ""filename"": ""fs/jffs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jffs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -233,9 +233,10 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (rc < 0)\n+\t\t\tumode_t mode;\n+\n+\t\t\trc = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tif (inode->i_mode != mode) {\n \t\t\t\tstruct iattr attr;\n@@ -247,8 +248,6 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tif (rc < 0)\n \t\t\t\t\treturn rc;\n \t\t\t}\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""3a1e1554a4e3598132bd6665f05c200922345a9a"", ""filename"": ""fs/jfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -78,13 +78,11 @@ static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (rc < 0)\n+\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tinode->i_ctime = CURRENT_TIME;\n \t\t\tmark_inode_dirty(inode);\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""164307b994052cb658b08cb8c28da524dedfe644"", ""filename"": ""fs/ocfs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 6, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -241,13 +241,11 @@ int ocfs2_set_acl(handle_t *handle,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (ret < 0)\n-\t\t\t\treturn ret;\n+\t\t\tumode_t mode;\n \n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n+\t\t\tret = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (ret)\n+\t\t\t\treturn ret;\n \n \t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n \t\t\t\t\t\t handle, mode);""}<_**next**_>{""sha"": ""7a3754488312c650b3003f5cb23a06bb17a53aeb"", ""filename"": ""fs/orangefs/acl.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 10, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/orangefs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -73,14 +73,11 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\t/*\n-\t\t\t * can we represent this with the traditional file\n-\t\t\t * mode permission bits?\n-\t\t\t */\n-\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (error < 0) {\n-\t\t\t\tgossip_err(\""%s: posix_acl_equiv_mode err: %d\\n\"",\n+\t\t\tumode_t mode;\n+\n+\t\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (error) {\n+\t\t\t\tgossip_err(\""%s: posix_acl_update_mode err: %d\\n\"",\n \t\t\t\t\t   __func__,\n \t\t\t\t\t   error);\n \t\t\t\treturn error;\n@@ -90,8 +87,6 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tSetModeFlag(orangefs_inode);\n \t\t\tinode->i_mode = mode;\n \t\t\tmark_inode_dirty_sync(inode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""bfc3ec38832282ca9834bb06379ffc0132e041c5"", ""filename"": ""fs/posix_acl.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -626,6 +626,37 @@ posix_acl_create(struct inode *dir, umode_t *mode,\n }\n EXPORT_SYMBOL_GPL(posix_acl_create);\n \n+/**\n+ * posix_acl_update_mode  -  update mode in set_acl\n+ *\n+ * Update the file mode when setting an ACL: compute the new file permission\n+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n+ * file mode, set *acl to NULL to indicate that no ACL should be set.\n+ *\n+ * As with chmod, clear the setgit bit if the caller is not in the owning group\n+ * or capable of CAP_FSETID (see inode_change_ok).\n+ *\n+ * Called from set_acl inode operations.\n+ */\n+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n+\t\t\t  struct posix_acl **acl)\n+{\n+\tumode_t mode = inode->i_mode;\n+\tint error;\n+\n+\terror = posix_acl_equiv_mode(*acl, &mode);\n+\tif (error < 0)\n+\t\treturn error;\n+\tif (error == 0)\n+\t\t*acl = NULL;\n+\tif (!in_group_p(inode->i_gid) &&\n+\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n+\t\tmode &= ~S_ISGID;\n+\t*mode_p = mode;\n+\treturn 0;\n+}\n+EXPORT_SYMBOL(posix_acl_update_mode);\n+\n /*\n  * Fix up the uids and gids in posix acl extended attributes in place.\n  */""}<_**next**_>{""sha"": ""27376681c6405f439a6b5026554ee5e20e11e4d5"", ""filename"": ""fs/reiserfs/xattr_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 6, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/xattr_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -242,13 +242,9 @@ __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""8a0dec89ca560622ffa491a7dba8855145889601"", ""filename"": ""fs/xfs/xfs_acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 9, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -257,16 +257,11 @@ xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\treturn error;\n \n \tif (type == ACL_TYPE_ACCESS) {\n-\t\tumode_t mode = inode->i_mode;\n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\n-\t\tif (error <= 0) {\n-\t\t\tacl = NULL;\n-\n-\t\t\tif (error < 0)\n-\t\t\t\treturn error;\n-\t\t}\n+\t\tumode_t mode;\n \n+\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\tif (error)\n+\t\t\treturn error;\n \t\terror = xfs_set_mode(inode, mode);\n \t\tif (error)\n \t\t\treturn error;""}<_**next**_>{""sha"": ""bf1046d0397bbbde8806459faa3833d8bbf2d79f"", ""filename"": ""include/linux/posix_acl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/posix_acl.h?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -93,6 +93,7 @@ extern int set_posix_acl(struct inode *, int, struct posix_acl *);\n extern int posix_acl_chmod(struct inode *, umode_t);\n extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,\n \t\tstruct posix_acl **);\n+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);\n \n extern int simple_set_acl(struct inode *, struct posix_acl *, int);\n extern int simple_acl_create(struct inode *, struct inode *);""}","int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	int error;
	int len;
	char *data;
	const char *name = gfs2_acl_name(type);

	if (acl && acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))
		return -E2BIG;

 	if (type == ACL_TYPE_ACCESS) {
 		umode_t mode = inode->i_mode;
 
		error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
		if (error)
 			return error;
		if (mode != inode->i_mode)
 			mark_inode_dirty(inode);
 	}
 
 	if (acl) {
		len = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);
		if (len == 0)
			return 0;
		data = kmalloc(len, GFP_NOFS);
		if (data == NULL)
			return -ENOMEM;
		error = posix_acl_to_xattr(&init_user_ns, acl, data, len);
		if (error < 0)
			goto out;
	} else {
		data = NULL;
		len = 0;
	}

	error = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);
	if (error)
		goto out;
	set_cached_acl(inode, type, acl);
out:
	kfree(data);
	return error;
}
","int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	int error;
	int len;
	char *data;
	const char *name = gfs2_acl_name(type);

	if (acl && acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))
		return -E2BIG;

 	if (type == ACL_TYPE_ACCESS) {
 		umode_t mode = inode->i_mode;
 
		error = posix_acl_equiv_mode(acl, &mode);
		if (error < 0)
 			return error;
		if (error == 0)
			acl = NULL;
		if (mode != inode->i_mode) {
			inode->i_mode = mode;
 			mark_inode_dirty(inode);
		}
 	}
 
 	if (acl) {
		len = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);
		if (len == 0)
			return 0;
		data = kmalloc(len, GFP_NOFS);
		if (data == NULL)
			return -ENOMEM;
		error = posix_acl_to_xattr(&init_user_ns, acl, data, len);
		if (error < 0)
			goto out;
	} else {
		data = NULL;
		len = 0;
	}

	error = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);
	if (error)
		goto out;
	set_cached_acl(inode, type, acl);
out:
	kfree(data);
	return error;
}
",C,"		error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
		if (error)
		if (mode != inode->i_mode)
","		error = posix_acl_equiv_mode(acl, &mode);
		if (error < 0)
		if (error == 0)
			acl = NULL;
		if (mode != inode->i_mode) {
			inode->i_mode = mode;
		}
",,"@@ -92,17 +92,11 @@ int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 	if (type == ACL_TYPE_ACCESS) {
 		umode_t mode = inode->i_mode;
 
-		error = posix_acl_equiv_mode(acl, &mode);
-		if (error < 0)
+		error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+		if (error)
 			return error;
-
-		if (error == 0)
-			acl = NULL;
-
-		if (mode != inode->i_mode) {
-			inode->i_mode = mode;
+		if (mode != inode->i_mode)
 			mark_inode_dirty(inode);
-		}
 	}
 
 	if (acl) {",linux,073931017b49d9458aa351605b43a7e34598caef,5d3ddd84eaefffd23c028bce5610dac8726f71c1,1,"int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	int error;
	int len;
	char *data;
	const char *name = gfs2_acl_name(type);

	if (acl && acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))
		return -E2BIG;

 	if (type == ACL_TYPE_ACCESS) {
 		umode_t mode = inode->i_mode;
 
//flaw_line_below:
		error = posix_acl_equiv_mode(acl, &mode);
//flaw_line_below:
		if (error < 0)
//fix_flaw_line_below:
//		error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
//fix_flaw_line_below:
//		if (error)
 			return error;
//flaw_line_below:

//flaw_line_below:
		if (error == 0)
//flaw_line_below:
			acl = NULL;
//flaw_line_below:

//flaw_line_below:
		if (mode != inode->i_mode) {
//flaw_line_below:
			inode->i_mode = mode;
//fix_flaw_line_below:
//		if (mode != inode->i_mode)
 			mark_inode_dirty(inode);
//flaw_line_below:
		}
 	}
 
 	if (acl) {
		len = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);
		if (len == 0)
			return 0;
		data = kmalloc(len, GFP_NOFS);
		if (data == NULL)
			return -ENOMEM;
		error = posix_acl_to_xattr(&init_user_ns, acl, data, len);
		if (error < 0)
			goto out;
	} else {
		data = NULL;
		len = 0;
	}

	error = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);
	if (error)
		goto out;
	set_cached_acl(inode, type, acl);
out:
	kfree(data);
	return error;
}
"
2409,180145,,Local,Not required,,CVE-2016-7097,https://www.cvedetails.com/cve/CVE-2016-7097/,CWE-285,Low,Partial,Partial,,2016-10-16,3.6,"The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",2018-01-04,+Priv ,2,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,073931017b49d9458aa351605b43a7e34598caef,"posix_acl: Clear SGID bit when setting file permissions

When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

References: CVE-2016-7097
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>",2,fs/hfsplus/posix_acl.c,"{""sha"": ""b3c2cc79c20d255f5d3cdf59e407ad65c67c7089"", ""filename"": ""fs/9p/acl.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 23, ""changes"": 40, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/9p/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -276,32 +276,26 @@ static int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n \tswitch (handler->flags) {\n \tcase ACL_TYPE_ACCESS:\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (retval < 0)\n+\t\t\tstruct iattr iattr;\n+\n+\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n+\t\t\tif (retval)\n \t\t\t\tgoto err_out;\n-\t\t\telse {\n-\t\t\t\tstruct iattr iattr;\n-\t\t\t\tif (retval == 0) {\n-\t\t\t\t\t/*\n-\t\t\t\t\t * ACL can be represented\n-\t\t\t\t\t * by the mode bits. So don't\n-\t\t\t\t\t * update ACL.\n-\t\t\t\t\t */\n-\t\t\t\t\tacl = NULL;\n-\t\t\t\t\tvalue = NULL;\n-\t\t\t\t\tsize = 0;\n-\t\t\t\t}\n-\t\t\t\t/* Updte the mode bits */\n-\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n-\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n-\t\t\t\tiattr.ia_valid = ATTR_MODE;\n-\t\t\t\t/* FIXME should we update ctime ?\n-\t\t\t\t * What is the following setxattr update the\n-\t\t\t\t * mode ?\n+\t\t\tif (!acl) {\n+\t\t\t\t/*\n+\t\t\t\t * ACL can be represented\n+\t\t\t\t * by the mode bits. So don't\n+\t\t\t\t * update ACL.\n \t\t\t\t */\n-\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n+\t\t\t\tvalue = NULL;\n+\t\t\t\tsize = 0;\n \t\t\t}\n+\t\t\tiattr.ia_valid = ATTR_MODE;\n+\t\t\t/* FIXME should we update ctime ?\n+\t\t\t * What is the following setxattr update the\n+\t\t\t * mode ?\n+\t\t\t */\n+\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""247b8dfaf6e5e53b2f8a898f036375819a1ac225"", ""filename"": ""fs/btrfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -79,11 +79,9 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\treturn ret;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tret = 0;\n \t\tbreak;""}<_**next**_>{""sha"": ""d0b6b342dff982c487880beb9d5bd3868f7502d6"", ""filename"": ""fs/ceph/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ceph/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -95,11 +95,9 @@ int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &new_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\tgoto out;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""e725aa0890e00ea9e97f8255cf9b4c8e082a0bb2"", ""filename"": ""fs/ext2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -190,15 +190,11 @@ ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\tcase ACL_TYPE_ACCESS:\n \t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\t\tif (acl) {\n-\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\t\tif (error < 0)\n+\t\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\t\tif (error)\n \t\t\t\t\treturn error;\n-\t\t\t\telse {\n-\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n-\t\t\t\t\tmark_inode_dirty(inode);\n-\t\t\t\t\tif (error == 0)\n-\t\t\t\t\t\tacl = NULL;\n-\t\t\t\t}\n+\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n+\t\t\t\tmark_inode_dirty(inode);\n \t\t\t}\n \t\t\tbreak;\n ""}<_**next**_>{""sha"": ""dfa519979038b9c2475f335a1f44e8326eb8f799"", ""filename"": ""fs/ext4/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -193,15 +193,11 @@ __ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n-\t\t\t\text4_mark_inode_dirty(handle, inode);\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n+\t\t\tinode->i_ctime = ext4_current_time(inode);\n+\t\t\text4_mark_inode_dirty(handle, inode);\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""31344247ce891bbadf4432a5a1dd9bfeb1e514f9"", ""filename"": ""fs/f2fs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -210,12 +210,10 @@ static int __f2fs_set_acl(struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n \t\t\tset_acl_inode(inode, inode->i_mode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""2524807ee0703643867e7e04c803d10b1aab9182"", ""filename"": ""fs/gfs2/acl.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 9, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -92,17 +92,11 @@ int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tif (type == ACL_TYPE_ACCESS) {\n \t\tumode_t mode = inode->i_mode;\n \n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\tif (error < 0)\n+\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\tif (error)\n \t\t\treturn error;\n-\n-\t\tif (error == 0)\n-\t\t\tacl = NULL;\n-\n-\t\tif (mode != inode->i_mode) {\n-\t\t\tinode->i_mode = mode;\n+\t\tif (mode != inode->i_mode)\n \t\t\tmark_inode_dirty(inode);\n-\t\t}\n \t}\n \n \tif (acl) {""}<_**next**_>{""sha"": ""9b92058a12409d6aa4040ed228ab1d2e5a6d8537"", ""filename"": ""fs/hfsplus/posix_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/hfsplus/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -65,8 +65,8 @@ int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n \tcase ACL_TYPE_ACCESS:\n \t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (err < 0)\n+\t\t\terr = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (err)\n \t\t\t\treturn err;\n \t\t}\n \t\terr = 0;""}<_**next**_>{""sha"": ""2a0f2a1044c16009ff2c48334b48a49157e7aece"", ""filename"": ""fs/jffs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jffs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -233,9 +233,10 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (rc < 0)\n+\t\t\tumode_t mode;\n+\n+\t\t\trc = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tif (inode->i_mode != mode) {\n \t\t\t\tstruct iattr attr;\n@@ -247,8 +248,6 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tif (rc < 0)\n \t\t\t\t\treturn rc;\n \t\t\t}\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""3a1e1554a4e3598132bd6665f05c200922345a9a"", ""filename"": ""fs/jfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -78,13 +78,11 @@ static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (rc < 0)\n+\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tinode->i_ctime = CURRENT_TIME;\n \t\t\tmark_inode_dirty(inode);\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""164307b994052cb658b08cb8c28da524dedfe644"", ""filename"": ""fs/ocfs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 6, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -241,13 +241,11 @@ int ocfs2_set_acl(handle_t *handle,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (ret < 0)\n-\t\t\t\treturn ret;\n+\t\t\tumode_t mode;\n \n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n+\t\t\tret = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (ret)\n+\t\t\t\treturn ret;\n \n \t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n \t\t\t\t\t\t handle, mode);""}<_**next**_>{""sha"": ""7a3754488312c650b3003f5cb23a06bb17a53aeb"", ""filename"": ""fs/orangefs/acl.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 10, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/orangefs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -73,14 +73,11 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\t/*\n-\t\t\t * can we represent this with the traditional file\n-\t\t\t * mode permission bits?\n-\t\t\t */\n-\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (error < 0) {\n-\t\t\t\tgossip_err(\""%s: posix_acl_equiv_mode err: %d\\n\"",\n+\t\t\tumode_t mode;\n+\n+\t\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (error) {\n+\t\t\t\tgossip_err(\""%s: posix_acl_update_mode err: %d\\n\"",\n \t\t\t\t\t   __func__,\n \t\t\t\t\t   error);\n \t\t\t\treturn error;\n@@ -90,8 +87,6 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tSetModeFlag(orangefs_inode);\n \t\t\tinode->i_mode = mode;\n \t\t\tmark_inode_dirty_sync(inode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""bfc3ec38832282ca9834bb06379ffc0132e041c5"", ""filename"": ""fs/posix_acl.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -626,6 +626,37 @@ posix_acl_create(struct inode *dir, umode_t *mode,\n }\n EXPORT_SYMBOL_GPL(posix_acl_create);\n \n+/**\n+ * posix_acl_update_mode  -  update mode in set_acl\n+ *\n+ * Update the file mode when setting an ACL: compute the new file permission\n+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n+ * file mode, set *acl to NULL to indicate that no ACL should be set.\n+ *\n+ * As with chmod, clear the setgit bit if the caller is not in the owning group\n+ * or capable of CAP_FSETID (see inode_change_ok).\n+ *\n+ * Called from set_acl inode operations.\n+ */\n+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n+\t\t\t  struct posix_acl **acl)\n+{\n+\tumode_t mode = inode->i_mode;\n+\tint error;\n+\n+\terror = posix_acl_equiv_mode(*acl, &mode);\n+\tif (error < 0)\n+\t\treturn error;\n+\tif (error == 0)\n+\t\t*acl = NULL;\n+\tif (!in_group_p(inode->i_gid) &&\n+\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n+\t\tmode &= ~S_ISGID;\n+\t*mode_p = mode;\n+\treturn 0;\n+}\n+EXPORT_SYMBOL(posix_acl_update_mode);\n+\n /*\n  * Fix up the uids and gids in posix acl extended attributes in place.\n  */""}<_**next**_>{""sha"": ""27376681c6405f439a6b5026554ee5e20e11e4d5"", ""filename"": ""fs/reiserfs/xattr_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 6, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/xattr_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -242,13 +242,9 @@ __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""8a0dec89ca560622ffa491a7dba8855145889601"", ""filename"": ""fs/xfs/xfs_acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 9, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -257,16 +257,11 @@ xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\treturn error;\n \n \tif (type == ACL_TYPE_ACCESS) {\n-\t\tumode_t mode = inode->i_mode;\n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\n-\t\tif (error <= 0) {\n-\t\t\tacl = NULL;\n-\n-\t\t\tif (error < 0)\n-\t\t\t\treturn error;\n-\t\t}\n+\t\tumode_t mode;\n \n+\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\tif (error)\n+\t\t\treturn error;\n \t\terror = xfs_set_mode(inode, mode);\n \t\tif (error)\n \t\t\treturn error;""}<_**next**_>{""sha"": ""bf1046d0397bbbde8806459faa3833d8bbf2d79f"", ""filename"": ""include/linux/posix_acl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/posix_acl.h?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -93,6 +93,7 @@ extern int set_posix_acl(struct inode *, int, struct posix_acl *);\n extern int posix_acl_chmod(struct inode *, umode_t);\n extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,\n \t\tstruct posix_acl **);\n+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);\n \n extern int simple_set_acl(struct inode *, struct posix_acl *, int);\n extern int simple_acl_create(struct inode *, struct inode *);""}","int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,
		int type)
{
	int err;
	char *xattr_name;
	size_t size = 0;
	char *value = NULL;

	hfs_dbg(ACL_MOD, ""[%s]: ino %lu\n"", __func__, inode->i_ino);

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		xattr_name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
			err = posix_acl_update_mode(inode, &inode->i_mode, &acl);
			if (err)
 				return err;
 		}
 		err = 0;
		break;

	case ACL_TYPE_DEFAULT:
		xattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;

	default:
		return -EINVAL;
	}

	if (acl) {
		size = posix_acl_xattr_size(acl->a_count);
		if (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))
			return -ENOMEM;
		value = (char *)hfsplus_alloc_attr_entry();
		if (unlikely(!value))
			return -ENOMEM;
		err = posix_acl_to_xattr(&init_user_ns, acl, value, size);
		if (unlikely(err < 0))
			goto end_set_acl;
	}

	err = __hfsplus_setxattr(inode, xattr_name, value, size, 0);

end_set_acl:
	hfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);

	if (!err)
		set_cached_acl(inode, type, acl);

	return err;
}
","int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,
		int type)
{
	int err;
	char *xattr_name;
	size_t size = 0;
	char *value = NULL;

	hfs_dbg(ACL_MOD, ""[%s]: ino %lu\n"", __func__, inode->i_ino);

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		xattr_name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
			err = posix_acl_equiv_mode(acl, &inode->i_mode);
			if (err < 0)
 				return err;
 		}
 		err = 0;
		break;

	case ACL_TYPE_DEFAULT:
		xattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;

	default:
		return -EINVAL;
	}

	if (acl) {
		size = posix_acl_xattr_size(acl->a_count);
		if (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))
			return -ENOMEM;
		value = (char *)hfsplus_alloc_attr_entry();
		if (unlikely(!value))
			return -ENOMEM;
		err = posix_acl_to_xattr(&init_user_ns, acl, value, size);
		if (unlikely(err < 0))
			goto end_set_acl;
	}

	err = __hfsplus_setxattr(inode, xattr_name, value, size, 0);

end_set_acl:
	hfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);

	if (!err)
		set_cached_acl(inode, type, acl);

	return err;
}
",C,"			err = posix_acl_update_mode(inode, &inode->i_mode, &acl);
			if (err)
","			err = posix_acl_equiv_mode(acl, &inode->i_mode);
			if (err < 0)
",,"@@ -65,8 +65,8 @@ int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,
 	case ACL_TYPE_ACCESS:
 		xattr_name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
-			err = posix_acl_equiv_mode(acl, &inode->i_mode);
-			if (err < 0)
+			err = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+			if (err)
 				return err;
 		}
 		err = 0;",linux,073931017b49d9458aa351605b43a7e34598caef,5d3ddd84eaefffd23c028bce5610dac8726f71c1,1,"int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,
		int type)
{
	int err;
	char *xattr_name;
	size_t size = 0;
	char *value = NULL;

	hfs_dbg(ACL_MOD, ""[%s]: ino %lu\n"", __func__, inode->i_ino);

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		xattr_name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
//flaw_line_below:
			err = posix_acl_equiv_mode(acl, &inode->i_mode);
//flaw_line_below:
			if (err < 0)
//fix_flaw_line_below:
//			err = posix_acl_update_mode(inode, &inode->i_mode, &acl);
//fix_flaw_line_below:
//			if (err)
 				return err;
 		}
 		err = 0;
		break;

	case ACL_TYPE_DEFAULT:
		xattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;

	default:
		return -EINVAL;
	}

	if (acl) {
		size = posix_acl_xattr_size(acl->a_count);
		if (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))
			return -ENOMEM;
		value = (char *)hfsplus_alloc_attr_entry();
		if (unlikely(!value))
			return -ENOMEM;
		err = posix_acl_to_xattr(&init_user_ns, acl, value, size);
		if (unlikely(err < 0))
			goto end_set_acl;
	}

	err = __hfsplus_setxattr(inode, xattr_name, value, size, 0);

end_set_acl:
	hfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);

	if (!err)
		set_cached_acl(inode, type, acl);

	return err;
}
"
2410,180146,,Local,Not required,,CVE-2016-7097,https://www.cvedetails.com/cve/CVE-2016-7097/,CWE-285,Low,Partial,Partial,,2016-10-16,3.6,"The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",2018-01-04,+Priv ,4,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,073931017b49d9458aa351605b43a7e34598caef,"posix_acl: Clear SGID bit when setting file permissions

When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

References: CVE-2016-7097
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>",5,fs/jffs2/acl.c,"{""sha"": ""b3c2cc79c20d255f5d3cdf59e407ad65c67c7089"", ""filename"": ""fs/9p/acl.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 23, ""changes"": 40, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/9p/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -276,32 +276,26 @@ static int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n \tswitch (handler->flags) {\n \tcase ACL_TYPE_ACCESS:\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (retval < 0)\n+\t\t\tstruct iattr iattr;\n+\n+\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n+\t\t\tif (retval)\n \t\t\t\tgoto err_out;\n-\t\t\telse {\n-\t\t\t\tstruct iattr iattr;\n-\t\t\t\tif (retval == 0) {\n-\t\t\t\t\t/*\n-\t\t\t\t\t * ACL can be represented\n-\t\t\t\t\t * by the mode bits. So don't\n-\t\t\t\t\t * update ACL.\n-\t\t\t\t\t */\n-\t\t\t\t\tacl = NULL;\n-\t\t\t\t\tvalue = NULL;\n-\t\t\t\t\tsize = 0;\n-\t\t\t\t}\n-\t\t\t\t/* Updte the mode bits */\n-\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n-\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n-\t\t\t\tiattr.ia_valid = ATTR_MODE;\n-\t\t\t\t/* FIXME should we update ctime ?\n-\t\t\t\t * What is the following setxattr update the\n-\t\t\t\t * mode ?\n+\t\t\tif (!acl) {\n+\t\t\t\t/*\n+\t\t\t\t * ACL can be represented\n+\t\t\t\t * by the mode bits. So don't\n+\t\t\t\t * update ACL.\n \t\t\t\t */\n-\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n+\t\t\t\tvalue = NULL;\n+\t\t\t\tsize = 0;\n \t\t\t}\n+\t\t\tiattr.ia_valid = ATTR_MODE;\n+\t\t\t/* FIXME should we update ctime ?\n+\t\t\t * What is the following setxattr update the\n+\t\t\t * mode ?\n+\t\t\t */\n+\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""247b8dfaf6e5e53b2f8a898f036375819a1ac225"", ""filename"": ""fs/btrfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -79,11 +79,9 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\treturn ret;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tret = 0;\n \t\tbreak;""}<_**next**_>{""sha"": ""d0b6b342dff982c487880beb9d5bd3868f7502d6"", ""filename"": ""fs/ceph/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ceph/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -95,11 +95,9 @@ int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &new_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\tgoto out;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""e725aa0890e00ea9e97f8255cf9b4c8e082a0bb2"", ""filename"": ""fs/ext2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -190,15 +190,11 @@ ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\tcase ACL_TYPE_ACCESS:\n \t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\t\tif (acl) {\n-\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\t\tif (error < 0)\n+\t\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\t\tif (error)\n \t\t\t\t\treturn error;\n-\t\t\t\telse {\n-\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n-\t\t\t\t\tmark_inode_dirty(inode);\n-\t\t\t\t\tif (error == 0)\n-\t\t\t\t\t\tacl = NULL;\n-\t\t\t\t}\n+\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n+\t\t\t\tmark_inode_dirty(inode);\n \t\t\t}\n \t\t\tbreak;\n ""}<_**next**_>{""sha"": ""dfa519979038b9c2475f335a1f44e8326eb8f799"", ""filename"": ""fs/ext4/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -193,15 +193,11 @@ __ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n-\t\t\t\text4_mark_inode_dirty(handle, inode);\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n+\t\t\tinode->i_ctime = ext4_current_time(inode);\n+\t\t\text4_mark_inode_dirty(handle, inode);\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""31344247ce891bbadf4432a5a1dd9bfeb1e514f9"", ""filename"": ""fs/f2fs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -210,12 +210,10 @@ static int __f2fs_set_acl(struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n \t\t\tset_acl_inode(inode, inode->i_mode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""2524807ee0703643867e7e04c803d10b1aab9182"", ""filename"": ""fs/gfs2/acl.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 9, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -92,17 +92,11 @@ int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tif (type == ACL_TYPE_ACCESS) {\n \t\tumode_t mode = inode->i_mode;\n \n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\tif (error < 0)\n+\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\tif (error)\n \t\t\treturn error;\n-\n-\t\tif (error == 0)\n-\t\t\tacl = NULL;\n-\n-\t\tif (mode != inode->i_mode) {\n-\t\t\tinode->i_mode = mode;\n+\t\tif (mode != inode->i_mode)\n \t\t\tmark_inode_dirty(inode);\n-\t\t}\n \t}\n \n \tif (acl) {""}<_**next**_>{""sha"": ""9b92058a12409d6aa4040ed228ab1d2e5a6d8537"", ""filename"": ""fs/hfsplus/posix_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/hfsplus/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -65,8 +65,8 @@ int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n \tcase ACL_TYPE_ACCESS:\n \t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (err < 0)\n+\t\t\terr = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (err)\n \t\t\t\treturn err;\n \t\t}\n \t\terr = 0;""}<_**next**_>{""sha"": ""2a0f2a1044c16009ff2c48334b48a49157e7aece"", ""filename"": ""fs/jffs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jffs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -233,9 +233,10 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (rc < 0)\n+\t\t\tumode_t mode;\n+\n+\t\t\trc = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tif (inode->i_mode != mode) {\n \t\t\t\tstruct iattr attr;\n@@ -247,8 +248,6 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tif (rc < 0)\n \t\t\t\t\treturn rc;\n \t\t\t}\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""3a1e1554a4e3598132bd6665f05c200922345a9a"", ""filename"": ""fs/jfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -78,13 +78,11 @@ static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (rc < 0)\n+\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tinode->i_ctime = CURRENT_TIME;\n \t\t\tmark_inode_dirty(inode);\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""164307b994052cb658b08cb8c28da524dedfe644"", ""filename"": ""fs/ocfs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 6, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -241,13 +241,11 @@ int ocfs2_set_acl(handle_t *handle,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (ret < 0)\n-\t\t\t\treturn ret;\n+\t\t\tumode_t mode;\n \n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n+\t\t\tret = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (ret)\n+\t\t\t\treturn ret;\n \n \t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n \t\t\t\t\t\t handle, mode);""}<_**next**_>{""sha"": ""7a3754488312c650b3003f5cb23a06bb17a53aeb"", ""filename"": ""fs/orangefs/acl.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 10, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/orangefs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -73,14 +73,11 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\t/*\n-\t\t\t * can we represent this with the traditional file\n-\t\t\t * mode permission bits?\n-\t\t\t */\n-\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (error < 0) {\n-\t\t\t\tgossip_err(\""%s: posix_acl_equiv_mode err: %d\\n\"",\n+\t\t\tumode_t mode;\n+\n+\t\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (error) {\n+\t\t\t\tgossip_err(\""%s: posix_acl_update_mode err: %d\\n\"",\n \t\t\t\t\t   __func__,\n \t\t\t\t\t   error);\n \t\t\t\treturn error;\n@@ -90,8 +87,6 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tSetModeFlag(orangefs_inode);\n \t\t\tinode->i_mode = mode;\n \t\t\tmark_inode_dirty_sync(inode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""bfc3ec38832282ca9834bb06379ffc0132e041c5"", ""filename"": ""fs/posix_acl.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -626,6 +626,37 @@ posix_acl_create(struct inode *dir, umode_t *mode,\n }\n EXPORT_SYMBOL_GPL(posix_acl_create);\n \n+/**\n+ * posix_acl_update_mode  -  update mode in set_acl\n+ *\n+ * Update the file mode when setting an ACL: compute the new file permission\n+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n+ * file mode, set *acl to NULL to indicate that no ACL should be set.\n+ *\n+ * As with chmod, clear the setgit bit if the caller is not in the owning group\n+ * or capable of CAP_FSETID (see inode_change_ok).\n+ *\n+ * Called from set_acl inode operations.\n+ */\n+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n+\t\t\t  struct posix_acl **acl)\n+{\n+\tumode_t mode = inode->i_mode;\n+\tint error;\n+\n+\terror = posix_acl_equiv_mode(*acl, &mode);\n+\tif (error < 0)\n+\t\treturn error;\n+\tif (error == 0)\n+\t\t*acl = NULL;\n+\tif (!in_group_p(inode->i_gid) &&\n+\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n+\t\tmode &= ~S_ISGID;\n+\t*mode_p = mode;\n+\treturn 0;\n+}\n+EXPORT_SYMBOL(posix_acl_update_mode);\n+\n /*\n  * Fix up the uids and gids in posix acl extended attributes in place.\n  */""}<_**next**_>{""sha"": ""27376681c6405f439a6b5026554ee5e20e11e4d5"", ""filename"": ""fs/reiserfs/xattr_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 6, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/xattr_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -242,13 +242,9 @@ __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""8a0dec89ca560622ffa491a7dba8855145889601"", ""filename"": ""fs/xfs/xfs_acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 9, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -257,16 +257,11 @@ xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\treturn error;\n \n \tif (type == ACL_TYPE_ACCESS) {\n-\t\tumode_t mode = inode->i_mode;\n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\n-\t\tif (error <= 0) {\n-\t\t\tacl = NULL;\n-\n-\t\t\tif (error < 0)\n-\t\t\t\treturn error;\n-\t\t}\n+\t\tumode_t mode;\n \n+\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\tif (error)\n+\t\t\treturn error;\n \t\terror = xfs_set_mode(inode, mode);\n \t\tif (error)\n \t\t\treturn error;""}<_**next**_>{""sha"": ""bf1046d0397bbbde8806459faa3833d8bbf2d79f"", ""filename"": ""include/linux/posix_acl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/posix_acl.h?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -93,6 +93,7 @@ extern int set_posix_acl(struct inode *, int, struct posix_acl *);\n extern int posix_acl_chmod(struct inode *, umode_t);\n extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,\n \t\tstruct posix_acl **);\n+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);\n \n extern int simple_set_acl(struct inode *, struct posix_acl *, int);\n extern int simple_acl_create(struct inode *, struct inode *);""}","int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	int rc, xprefix;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		xprefix = JFFS2_XPREFIX_ACL_ACCESS;
 		if (acl) {
			umode_t mode;

			rc = posix_acl_update_mode(inode, &mode, &acl);
			if (rc)
 				return rc;
 			if (inode->i_mode != mode) {
 				struct iattr attr;

				attr.ia_valid = ATTR_MODE | ATTR_CTIME;
				attr.ia_mode = mode;
				attr.ia_ctime = CURRENT_TIME_SEC;
				rc = jffs2_do_setattr(inode, &attr);
 				if (rc < 0)
 					return rc;
 			}
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		xprefix = JFFS2_XPREFIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;
	default:
		return -EINVAL;
	}
	rc = __jffs2_set_acl(inode, xprefix, acl);
	if (!rc)
		set_cached_acl(inode, type, acl);
	return rc;
}
","int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	int rc, xprefix;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		xprefix = JFFS2_XPREFIX_ACL_ACCESS;
 		if (acl) {
			umode_t mode = inode->i_mode;
			rc = posix_acl_equiv_mode(acl, &mode);
			if (rc < 0)
 				return rc;
 			if (inode->i_mode != mode) {
 				struct iattr attr;

				attr.ia_valid = ATTR_MODE | ATTR_CTIME;
				attr.ia_mode = mode;
				attr.ia_ctime = CURRENT_TIME_SEC;
				rc = jffs2_do_setattr(inode, &attr);
 				if (rc < 0)
 					return rc;
 			}
			if (rc == 0)
				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		xprefix = JFFS2_XPREFIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;
	default:
		return -EINVAL;
	}
	rc = __jffs2_set_acl(inode, xprefix, acl);
	if (!rc)
		set_cached_acl(inode, type, acl);
	return rc;
}
",C,"			umode_t mode;

			rc = posix_acl_update_mode(inode, &mode, &acl);
			if (rc)
","			umode_t mode = inode->i_mode;
			rc = posix_acl_equiv_mode(acl, &mode);
			if (rc < 0)
			if (rc == 0)
				acl = NULL;
",,"@@ -233,9 +233,10 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 	case ACL_TYPE_ACCESS:
 		xprefix = JFFS2_XPREFIX_ACL_ACCESS;
 		if (acl) {
-			umode_t mode = inode->i_mode;
-			rc = posix_acl_equiv_mode(acl, &mode);
-			if (rc < 0)
+			umode_t mode;
+
+			rc = posix_acl_update_mode(inode, &mode, &acl);
+			if (rc)
 				return rc;
 			if (inode->i_mode != mode) {
 				struct iattr attr;
@@ -247,8 +248,6 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 				if (rc < 0)
 					return rc;
 			}
-			if (rc == 0)
-				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:",linux,073931017b49d9458aa351605b43a7e34598caef,5d3ddd84eaefffd23c028bce5610dac8726f71c1,1,"int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	int rc, xprefix;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		xprefix = JFFS2_XPREFIX_ACL_ACCESS;
 		if (acl) {
//flaw_line_below:
			umode_t mode = inode->i_mode;
//flaw_line_below:
			rc = posix_acl_equiv_mode(acl, &mode);
//flaw_line_below:
			if (rc < 0)
//fix_flaw_line_below:
//			umode_t mode;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//			rc = posix_acl_update_mode(inode, &mode, &acl);
//fix_flaw_line_below:
//			if (rc)
 				return rc;
 			if (inode->i_mode != mode) {
 				struct iattr attr;

				attr.ia_valid = ATTR_MODE | ATTR_CTIME;
				attr.ia_mode = mode;
				attr.ia_ctime = CURRENT_TIME_SEC;
				rc = jffs2_do_setattr(inode, &attr);
 				if (rc < 0)
 					return rc;
 			}
//flaw_line_below:
			if (rc == 0)
//flaw_line_below:
				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		xprefix = JFFS2_XPREFIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;
	default:
		return -EINVAL;
	}
	rc = __jffs2_set_acl(inode, xprefix, acl);
	if (!rc)
		set_cached_acl(inode, type, acl);
	return rc;
}
"
2411,180147,,Local,Not required,,CVE-2016-7097,https://www.cvedetails.com/cve/CVE-2016-7097/,CWE-285,Low,Partial,Partial,,2016-10-16,3.6,"The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",2018-01-04,+Priv ,2,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,073931017b49d9458aa351605b43a7e34598caef,"posix_acl: Clear SGID bit when setting file permissions

When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

References: CVE-2016-7097
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>",4,fs/jfs/acl.c,"{""sha"": ""b3c2cc79c20d255f5d3cdf59e407ad65c67c7089"", ""filename"": ""fs/9p/acl.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 23, ""changes"": 40, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/9p/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -276,32 +276,26 @@ static int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n \tswitch (handler->flags) {\n \tcase ACL_TYPE_ACCESS:\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (retval < 0)\n+\t\t\tstruct iattr iattr;\n+\n+\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n+\t\t\tif (retval)\n \t\t\t\tgoto err_out;\n-\t\t\telse {\n-\t\t\t\tstruct iattr iattr;\n-\t\t\t\tif (retval == 0) {\n-\t\t\t\t\t/*\n-\t\t\t\t\t * ACL can be represented\n-\t\t\t\t\t * by the mode bits. So don't\n-\t\t\t\t\t * update ACL.\n-\t\t\t\t\t */\n-\t\t\t\t\tacl = NULL;\n-\t\t\t\t\tvalue = NULL;\n-\t\t\t\t\tsize = 0;\n-\t\t\t\t}\n-\t\t\t\t/* Updte the mode bits */\n-\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n-\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n-\t\t\t\tiattr.ia_valid = ATTR_MODE;\n-\t\t\t\t/* FIXME should we update ctime ?\n-\t\t\t\t * What is the following setxattr update the\n-\t\t\t\t * mode ?\n+\t\t\tif (!acl) {\n+\t\t\t\t/*\n+\t\t\t\t * ACL can be represented\n+\t\t\t\t * by the mode bits. So don't\n+\t\t\t\t * update ACL.\n \t\t\t\t */\n-\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n+\t\t\t\tvalue = NULL;\n+\t\t\t\tsize = 0;\n \t\t\t}\n+\t\t\tiattr.ia_valid = ATTR_MODE;\n+\t\t\t/* FIXME should we update ctime ?\n+\t\t\t * What is the following setxattr update the\n+\t\t\t * mode ?\n+\t\t\t */\n+\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""247b8dfaf6e5e53b2f8a898f036375819a1ac225"", ""filename"": ""fs/btrfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -79,11 +79,9 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\treturn ret;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tret = 0;\n \t\tbreak;""}<_**next**_>{""sha"": ""d0b6b342dff982c487880beb9d5bd3868f7502d6"", ""filename"": ""fs/ceph/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ceph/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -95,11 +95,9 @@ int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &new_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\tgoto out;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""e725aa0890e00ea9e97f8255cf9b4c8e082a0bb2"", ""filename"": ""fs/ext2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -190,15 +190,11 @@ ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\tcase ACL_TYPE_ACCESS:\n \t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\t\tif (acl) {\n-\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\t\tif (error < 0)\n+\t\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\t\tif (error)\n \t\t\t\t\treturn error;\n-\t\t\t\telse {\n-\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n-\t\t\t\t\tmark_inode_dirty(inode);\n-\t\t\t\t\tif (error == 0)\n-\t\t\t\t\t\tacl = NULL;\n-\t\t\t\t}\n+\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n+\t\t\t\tmark_inode_dirty(inode);\n \t\t\t}\n \t\t\tbreak;\n ""}<_**next**_>{""sha"": ""dfa519979038b9c2475f335a1f44e8326eb8f799"", ""filename"": ""fs/ext4/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -193,15 +193,11 @@ __ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n-\t\t\t\text4_mark_inode_dirty(handle, inode);\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n+\t\t\tinode->i_ctime = ext4_current_time(inode);\n+\t\t\text4_mark_inode_dirty(handle, inode);\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""31344247ce891bbadf4432a5a1dd9bfeb1e514f9"", ""filename"": ""fs/f2fs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -210,12 +210,10 @@ static int __f2fs_set_acl(struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n \t\t\tset_acl_inode(inode, inode->i_mode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""2524807ee0703643867e7e04c803d10b1aab9182"", ""filename"": ""fs/gfs2/acl.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 9, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -92,17 +92,11 @@ int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tif (type == ACL_TYPE_ACCESS) {\n \t\tumode_t mode = inode->i_mode;\n \n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\tif (error < 0)\n+\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\tif (error)\n \t\t\treturn error;\n-\n-\t\tif (error == 0)\n-\t\t\tacl = NULL;\n-\n-\t\tif (mode != inode->i_mode) {\n-\t\t\tinode->i_mode = mode;\n+\t\tif (mode != inode->i_mode)\n \t\t\tmark_inode_dirty(inode);\n-\t\t}\n \t}\n \n \tif (acl) {""}<_**next**_>{""sha"": ""9b92058a12409d6aa4040ed228ab1d2e5a6d8537"", ""filename"": ""fs/hfsplus/posix_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/hfsplus/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -65,8 +65,8 @@ int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n \tcase ACL_TYPE_ACCESS:\n \t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (err < 0)\n+\t\t\terr = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (err)\n \t\t\t\treturn err;\n \t\t}\n \t\terr = 0;""}<_**next**_>{""sha"": ""2a0f2a1044c16009ff2c48334b48a49157e7aece"", ""filename"": ""fs/jffs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jffs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -233,9 +233,10 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (rc < 0)\n+\t\t\tumode_t mode;\n+\n+\t\t\trc = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tif (inode->i_mode != mode) {\n \t\t\t\tstruct iattr attr;\n@@ -247,8 +248,6 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tif (rc < 0)\n \t\t\t\t\treturn rc;\n \t\t\t}\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""3a1e1554a4e3598132bd6665f05c200922345a9a"", ""filename"": ""fs/jfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -78,13 +78,11 @@ static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (rc < 0)\n+\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tinode->i_ctime = CURRENT_TIME;\n \t\t\tmark_inode_dirty(inode);\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""164307b994052cb658b08cb8c28da524dedfe644"", ""filename"": ""fs/ocfs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 6, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -241,13 +241,11 @@ int ocfs2_set_acl(handle_t *handle,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (ret < 0)\n-\t\t\t\treturn ret;\n+\t\t\tumode_t mode;\n \n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n+\t\t\tret = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (ret)\n+\t\t\t\treturn ret;\n \n \t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n \t\t\t\t\t\t handle, mode);""}<_**next**_>{""sha"": ""7a3754488312c650b3003f5cb23a06bb17a53aeb"", ""filename"": ""fs/orangefs/acl.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 10, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/orangefs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -73,14 +73,11 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\t/*\n-\t\t\t * can we represent this with the traditional file\n-\t\t\t * mode permission bits?\n-\t\t\t */\n-\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (error < 0) {\n-\t\t\t\tgossip_err(\""%s: posix_acl_equiv_mode err: %d\\n\"",\n+\t\t\tumode_t mode;\n+\n+\t\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (error) {\n+\t\t\t\tgossip_err(\""%s: posix_acl_update_mode err: %d\\n\"",\n \t\t\t\t\t   __func__,\n \t\t\t\t\t   error);\n \t\t\t\treturn error;\n@@ -90,8 +87,6 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tSetModeFlag(orangefs_inode);\n \t\t\tinode->i_mode = mode;\n \t\t\tmark_inode_dirty_sync(inode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""bfc3ec38832282ca9834bb06379ffc0132e041c5"", ""filename"": ""fs/posix_acl.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -626,6 +626,37 @@ posix_acl_create(struct inode *dir, umode_t *mode,\n }\n EXPORT_SYMBOL_GPL(posix_acl_create);\n \n+/**\n+ * posix_acl_update_mode  -  update mode in set_acl\n+ *\n+ * Update the file mode when setting an ACL: compute the new file permission\n+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n+ * file mode, set *acl to NULL to indicate that no ACL should be set.\n+ *\n+ * As with chmod, clear the setgit bit if the caller is not in the owning group\n+ * or capable of CAP_FSETID (see inode_change_ok).\n+ *\n+ * Called from set_acl inode operations.\n+ */\n+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n+\t\t\t  struct posix_acl **acl)\n+{\n+\tumode_t mode = inode->i_mode;\n+\tint error;\n+\n+\terror = posix_acl_equiv_mode(*acl, &mode);\n+\tif (error < 0)\n+\t\treturn error;\n+\tif (error == 0)\n+\t\t*acl = NULL;\n+\tif (!in_group_p(inode->i_gid) &&\n+\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n+\t\tmode &= ~S_ISGID;\n+\t*mode_p = mode;\n+\treturn 0;\n+}\n+EXPORT_SYMBOL(posix_acl_update_mode);\n+\n /*\n  * Fix up the uids and gids in posix acl extended attributes in place.\n  */""}<_**next**_>{""sha"": ""27376681c6405f439a6b5026554ee5e20e11e4d5"", ""filename"": ""fs/reiserfs/xattr_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 6, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/xattr_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -242,13 +242,9 @@ __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""8a0dec89ca560622ffa491a7dba8855145889601"", ""filename"": ""fs/xfs/xfs_acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 9, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -257,16 +257,11 @@ xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\treturn error;\n \n \tif (type == ACL_TYPE_ACCESS) {\n-\t\tumode_t mode = inode->i_mode;\n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\n-\t\tif (error <= 0) {\n-\t\t\tacl = NULL;\n-\n-\t\t\tif (error < 0)\n-\t\t\t\treturn error;\n-\t\t}\n+\t\tumode_t mode;\n \n+\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\tif (error)\n+\t\t\treturn error;\n \t\terror = xfs_set_mode(inode, mode);\n \t\tif (error)\n \t\t\treturn error;""}<_**next**_>{""sha"": ""bf1046d0397bbbde8806459faa3833d8bbf2d79f"", ""filename"": ""include/linux/posix_acl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/posix_acl.h?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -93,6 +93,7 @@ extern int set_posix_acl(struct inode *, int, struct posix_acl *);\n extern int posix_acl_chmod(struct inode *, umode_t);\n extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,\n \t\tstruct posix_acl **);\n+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);\n \n extern int simple_set_acl(struct inode *, struct posix_acl *, int);\n extern int simple_acl_create(struct inode *, struct inode *);""}","static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,
		       struct posix_acl *acl)
{
	char *ea_name;
	int rc;
	int size = 0;
	char *value = NULL;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		ea_name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
			rc = posix_acl_update_mode(inode, &inode->i_mode, &acl);
			if (rc)
 				return rc;
 			inode->i_ctime = CURRENT_TIME;
 			mark_inode_dirty(inode);
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		ea_name = XATTR_NAME_POSIX_ACL_DEFAULT;
		break;
	default:
		return -EINVAL;
	}

	if (acl) {
		size = posix_acl_xattr_size(acl->a_count);
		value = kmalloc(size, GFP_KERNEL);
		if (!value)
			return -ENOMEM;
		rc = posix_acl_to_xattr(&init_user_ns, acl, value, size);
		if (rc < 0)
			goto out;
	}
	rc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);
out:
	kfree(value);

	if (!rc)
		set_cached_acl(inode, type, acl);

	return rc;
}
","static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,
		       struct posix_acl *acl)
{
	char *ea_name;
	int rc;
	int size = 0;
	char *value = NULL;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		ea_name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
			rc = posix_acl_equiv_mode(acl, &inode->i_mode);
			if (rc < 0)
 				return rc;
 			inode->i_ctime = CURRENT_TIME;
 			mark_inode_dirty(inode);
			if (rc == 0)
				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		ea_name = XATTR_NAME_POSIX_ACL_DEFAULT;
		break;
	default:
		return -EINVAL;
	}

	if (acl) {
		size = posix_acl_xattr_size(acl->a_count);
		value = kmalloc(size, GFP_KERNEL);
		if (!value)
			return -ENOMEM;
		rc = posix_acl_to_xattr(&init_user_ns, acl, value, size);
		if (rc < 0)
			goto out;
	}
	rc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);
out:
	kfree(value);

	if (!rc)
		set_cached_acl(inode, type, acl);

	return rc;
}
",C,"			rc = posix_acl_update_mode(inode, &inode->i_mode, &acl);
			if (rc)
","			rc = posix_acl_equiv_mode(acl, &inode->i_mode);
			if (rc < 0)
			if (rc == 0)
				acl = NULL;
",,"@@ -78,13 +78,11 @@ static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,
 	case ACL_TYPE_ACCESS:
 		ea_name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
-			rc = posix_acl_equiv_mode(acl, &inode->i_mode);
-			if (rc < 0)
+			rc = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+			if (rc)
 				return rc;
 			inode->i_ctime = CURRENT_TIME;
 			mark_inode_dirty(inode);
-			if (rc == 0)
-				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:",linux,073931017b49d9458aa351605b43a7e34598caef,5d3ddd84eaefffd23c028bce5610dac8726f71c1,1,"static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,
		       struct posix_acl *acl)
{
	char *ea_name;
	int rc;
	int size = 0;
	char *value = NULL;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		ea_name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
//flaw_line_below:
			rc = posix_acl_equiv_mode(acl, &inode->i_mode);
//flaw_line_below:
			if (rc < 0)
//fix_flaw_line_below:
//			rc = posix_acl_update_mode(inode, &inode->i_mode, &acl);
//fix_flaw_line_below:
//			if (rc)
 				return rc;
 			inode->i_ctime = CURRENT_TIME;
 			mark_inode_dirty(inode);
//flaw_line_below:
			if (rc == 0)
//flaw_line_below:
				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		ea_name = XATTR_NAME_POSIX_ACL_DEFAULT;
		break;
	default:
		return -EINVAL;
	}

	if (acl) {
		size = posix_acl_xattr_size(acl->a_count);
		value = kmalloc(size, GFP_KERNEL);
		if (!value)
			return -ENOMEM;
		rc = posix_acl_to_xattr(&init_user_ns, acl, value, size);
		if (rc < 0)
			goto out;
	}
	rc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);
out:
	kfree(value);

	if (!rc)
		set_cached_acl(inode, type, acl);

	return rc;
}
"
2412,180148,,Local,Not required,,CVE-2016-7097,https://www.cvedetails.com/cve/CVE-2016-7097/,CWE-285,Low,Partial,Partial,,2016-10-16,3.6,"The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",2018-01-04,+Priv ,4,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,073931017b49d9458aa351605b43a7e34598caef,"posix_acl: Clear SGID bit when setting file permissions

When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

References: CVE-2016-7097
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>",6,fs/ocfs2/acl.c,"{""sha"": ""b3c2cc79c20d255f5d3cdf59e407ad65c67c7089"", ""filename"": ""fs/9p/acl.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 23, ""changes"": 40, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/9p/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -276,32 +276,26 @@ static int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n \tswitch (handler->flags) {\n \tcase ACL_TYPE_ACCESS:\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (retval < 0)\n+\t\t\tstruct iattr iattr;\n+\n+\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n+\t\t\tif (retval)\n \t\t\t\tgoto err_out;\n-\t\t\telse {\n-\t\t\t\tstruct iattr iattr;\n-\t\t\t\tif (retval == 0) {\n-\t\t\t\t\t/*\n-\t\t\t\t\t * ACL can be represented\n-\t\t\t\t\t * by the mode bits. So don't\n-\t\t\t\t\t * update ACL.\n-\t\t\t\t\t */\n-\t\t\t\t\tacl = NULL;\n-\t\t\t\t\tvalue = NULL;\n-\t\t\t\t\tsize = 0;\n-\t\t\t\t}\n-\t\t\t\t/* Updte the mode bits */\n-\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n-\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n-\t\t\t\tiattr.ia_valid = ATTR_MODE;\n-\t\t\t\t/* FIXME should we update ctime ?\n-\t\t\t\t * What is the following setxattr update the\n-\t\t\t\t * mode ?\n+\t\t\tif (!acl) {\n+\t\t\t\t/*\n+\t\t\t\t * ACL can be represented\n+\t\t\t\t * by the mode bits. So don't\n+\t\t\t\t * update ACL.\n \t\t\t\t */\n-\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n+\t\t\t\tvalue = NULL;\n+\t\t\t\tsize = 0;\n \t\t\t}\n+\t\t\tiattr.ia_valid = ATTR_MODE;\n+\t\t\t/* FIXME should we update ctime ?\n+\t\t\t * What is the following setxattr update the\n+\t\t\t * mode ?\n+\t\t\t */\n+\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""247b8dfaf6e5e53b2f8a898f036375819a1ac225"", ""filename"": ""fs/btrfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -79,11 +79,9 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\treturn ret;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tret = 0;\n \t\tbreak;""}<_**next**_>{""sha"": ""d0b6b342dff982c487880beb9d5bd3868f7502d6"", ""filename"": ""fs/ceph/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ceph/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -95,11 +95,9 @@ int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &new_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\tgoto out;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""e725aa0890e00ea9e97f8255cf9b4c8e082a0bb2"", ""filename"": ""fs/ext2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -190,15 +190,11 @@ ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\tcase ACL_TYPE_ACCESS:\n \t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\t\tif (acl) {\n-\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\t\tif (error < 0)\n+\t\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\t\tif (error)\n \t\t\t\t\treturn error;\n-\t\t\t\telse {\n-\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n-\t\t\t\t\tmark_inode_dirty(inode);\n-\t\t\t\t\tif (error == 0)\n-\t\t\t\t\t\tacl = NULL;\n-\t\t\t\t}\n+\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n+\t\t\t\tmark_inode_dirty(inode);\n \t\t\t}\n \t\t\tbreak;\n ""}<_**next**_>{""sha"": ""dfa519979038b9c2475f335a1f44e8326eb8f799"", ""filename"": ""fs/ext4/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -193,15 +193,11 @@ __ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n-\t\t\t\text4_mark_inode_dirty(handle, inode);\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n+\t\t\tinode->i_ctime = ext4_current_time(inode);\n+\t\t\text4_mark_inode_dirty(handle, inode);\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""31344247ce891bbadf4432a5a1dd9bfeb1e514f9"", ""filename"": ""fs/f2fs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -210,12 +210,10 @@ static int __f2fs_set_acl(struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n \t\t\tset_acl_inode(inode, inode->i_mode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""2524807ee0703643867e7e04c803d10b1aab9182"", ""filename"": ""fs/gfs2/acl.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 9, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -92,17 +92,11 @@ int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tif (type == ACL_TYPE_ACCESS) {\n \t\tumode_t mode = inode->i_mode;\n \n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\tif (error < 0)\n+\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\tif (error)\n \t\t\treturn error;\n-\n-\t\tif (error == 0)\n-\t\t\tacl = NULL;\n-\n-\t\tif (mode != inode->i_mode) {\n-\t\t\tinode->i_mode = mode;\n+\t\tif (mode != inode->i_mode)\n \t\t\tmark_inode_dirty(inode);\n-\t\t}\n \t}\n \n \tif (acl) {""}<_**next**_>{""sha"": ""9b92058a12409d6aa4040ed228ab1d2e5a6d8537"", ""filename"": ""fs/hfsplus/posix_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/hfsplus/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -65,8 +65,8 @@ int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n \tcase ACL_TYPE_ACCESS:\n \t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (err < 0)\n+\t\t\terr = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (err)\n \t\t\t\treturn err;\n \t\t}\n \t\terr = 0;""}<_**next**_>{""sha"": ""2a0f2a1044c16009ff2c48334b48a49157e7aece"", ""filename"": ""fs/jffs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jffs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -233,9 +233,10 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (rc < 0)\n+\t\t\tumode_t mode;\n+\n+\t\t\trc = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tif (inode->i_mode != mode) {\n \t\t\t\tstruct iattr attr;\n@@ -247,8 +248,6 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tif (rc < 0)\n \t\t\t\t\treturn rc;\n \t\t\t}\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""3a1e1554a4e3598132bd6665f05c200922345a9a"", ""filename"": ""fs/jfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -78,13 +78,11 @@ static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (rc < 0)\n+\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tinode->i_ctime = CURRENT_TIME;\n \t\t\tmark_inode_dirty(inode);\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""164307b994052cb658b08cb8c28da524dedfe644"", ""filename"": ""fs/ocfs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 6, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -241,13 +241,11 @@ int ocfs2_set_acl(handle_t *handle,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (ret < 0)\n-\t\t\t\treturn ret;\n+\t\t\tumode_t mode;\n \n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n+\t\t\tret = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (ret)\n+\t\t\t\treturn ret;\n \n \t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n \t\t\t\t\t\t handle, mode);""}<_**next**_>{""sha"": ""7a3754488312c650b3003f5cb23a06bb17a53aeb"", ""filename"": ""fs/orangefs/acl.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 10, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/orangefs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -73,14 +73,11 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\t/*\n-\t\t\t * can we represent this with the traditional file\n-\t\t\t * mode permission bits?\n-\t\t\t */\n-\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (error < 0) {\n-\t\t\t\tgossip_err(\""%s: posix_acl_equiv_mode err: %d\\n\"",\n+\t\t\tumode_t mode;\n+\n+\t\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (error) {\n+\t\t\t\tgossip_err(\""%s: posix_acl_update_mode err: %d\\n\"",\n \t\t\t\t\t   __func__,\n \t\t\t\t\t   error);\n \t\t\t\treturn error;\n@@ -90,8 +87,6 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tSetModeFlag(orangefs_inode);\n \t\t\tinode->i_mode = mode;\n \t\t\tmark_inode_dirty_sync(inode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""bfc3ec38832282ca9834bb06379ffc0132e041c5"", ""filename"": ""fs/posix_acl.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -626,6 +626,37 @@ posix_acl_create(struct inode *dir, umode_t *mode,\n }\n EXPORT_SYMBOL_GPL(posix_acl_create);\n \n+/**\n+ * posix_acl_update_mode  -  update mode in set_acl\n+ *\n+ * Update the file mode when setting an ACL: compute the new file permission\n+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n+ * file mode, set *acl to NULL to indicate that no ACL should be set.\n+ *\n+ * As with chmod, clear the setgit bit if the caller is not in the owning group\n+ * or capable of CAP_FSETID (see inode_change_ok).\n+ *\n+ * Called from set_acl inode operations.\n+ */\n+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n+\t\t\t  struct posix_acl **acl)\n+{\n+\tumode_t mode = inode->i_mode;\n+\tint error;\n+\n+\terror = posix_acl_equiv_mode(*acl, &mode);\n+\tif (error < 0)\n+\t\treturn error;\n+\tif (error == 0)\n+\t\t*acl = NULL;\n+\tif (!in_group_p(inode->i_gid) &&\n+\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n+\t\tmode &= ~S_ISGID;\n+\t*mode_p = mode;\n+\treturn 0;\n+}\n+EXPORT_SYMBOL(posix_acl_update_mode);\n+\n /*\n  * Fix up the uids and gids in posix acl extended attributes in place.\n  */""}<_**next**_>{""sha"": ""27376681c6405f439a6b5026554ee5e20e11e4d5"", ""filename"": ""fs/reiserfs/xattr_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 6, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/xattr_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -242,13 +242,9 @@ __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""8a0dec89ca560622ffa491a7dba8855145889601"", ""filename"": ""fs/xfs/xfs_acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 9, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -257,16 +257,11 @@ xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\treturn error;\n \n \tif (type == ACL_TYPE_ACCESS) {\n-\t\tumode_t mode = inode->i_mode;\n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\n-\t\tif (error <= 0) {\n-\t\t\tacl = NULL;\n-\n-\t\t\tif (error < 0)\n-\t\t\t\treturn error;\n-\t\t}\n+\t\tumode_t mode;\n \n+\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\tif (error)\n+\t\t\treturn error;\n \t\terror = xfs_set_mode(inode, mode);\n \t\tif (error)\n \t\t\treturn error;""}<_**next**_>{""sha"": ""bf1046d0397bbbde8806459faa3833d8bbf2d79f"", ""filename"": ""include/linux/posix_acl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/posix_acl.h?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -93,6 +93,7 @@ extern int set_posix_acl(struct inode *, int, struct posix_acl *);\n extern int posix_acl_chmod(struct inode *, umode_t);\n extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,\n \t\tstruct posix_acl **);\n+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);\n \n extern int simple_set_acl(struct inode *, struct posix_acl *, int);\n extern int simple_acl_create(struct inode *, struct inode *);""}","int ocfs2_set_acl(handle_t *handle,
			 struct inode *inode,
			 struct buffer_head *di_bh,
			 int type,
			 struct posix_acl *acl,
			 struct ocfs2_alloc_context *meta_ac,
			 struct ocfs2_alloc_context *data_ac)
{
	int name_index;
	void *value = NULL;
	size_t size = 0;
	int ret;

	if (S_ISLNK(inode->i_mode))
		return -EOPNOTSUPP;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
			umode_t mode;
 
			ret = posix_acl_update_mode(inode, &mode, &acl);
			if (ret)
				return ret;
 
 			ret = ocfs2_acl_set_mode(inode, di_bh,
 						 handle, mode);
			if (ret)
				return ret;
		}
		break;
	case ACL_TYPE_DEFAULT:
		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;
	default:
		return -EINVAL;
	}

	if (acl) {
		value = ocfs2_acl_to_xattr(acl, &size);
		if (IS_ERR(value))
			return (int)PTR_ERR(value);
	}

	if (handle)
		ret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,
					     """", value, size, 0,
					     meta_ac, data_ac);
	else
		ret = ocfs2_xattr_set(inode, name_index, """", value, size, 0);

	kfree(value);

	return ret;
}
","int ocfs2_set_acl(handle_t *handle,
			 struct inode *inode,
			 struct buffer_head *di_bh,
			 int type,
			 struct posix_acl *acl,
			 struct ocfs2_alloc_context *meta_ac,
			 struct ocfs2_alloc_context *data_ac)
{
	int name_index;
	void *value = NULL;
	size_t size = 0;
	int ret;

	if (S_ISLNK(inode->i_mode))
		return -EOPNOTSUPP;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
			umode_t mode = inode->i_mode;
			ret = posix_acl_equiv_mode(acl, &mode);
			if (ret < 0)
				return ret;
 
			if (ret == 0)
				acl = NULL;
 
 			ret = ocfs2_acl_set_mode(inode, di_bh,
 						 handle, mode);
			if (ret)
				return ret;
		}
		break;
	case ACL_TYPE_DEFAULT:
		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;
	default:
		return -EINVAL;
	}

	if (acl) {
		value = ocfs2_acl_to_xattr(acl, &size);
		if (IS_ERR(value))
			return (int)PTR_ERR(value);
	}

	if (handle)
		ret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,
					     """", value, size, 0,
					     meta_ac, data_ac);
	else
		ret = ocfs2_xattr_set(inode, name_index, """", value, size, 0);

	kfree(value);

	return ret;
}
",C,"			umode_t mode;
			ret = posix_acl_update_mode(inode, &mode, &acl);
			if (ret)
				return ret;
","			umode_t mode = inode->i_mode;
			ret = posix_acl_equiv_mode(acl, &mode);
			if (ret < 0)
				return ret;
			if (ret == 0)
				acl = NULL;
",,"@@ -241,13 +241,11 @@ int ocfs2_set_acl(handle_t *handle,
 	case ACL_TYPE_ACCESS:
 		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
-			umode_t mode = inode->i_mode;
-			ret = posix_acl_equiv_mode(acl, &mode);
-			if (ret < 0)
-				return ret;
+			umode_t mode;
 
-			if (ret == 0)
-				acl = NULL;
+			ret = posix_acl_update_mode(inode, &mode, &acl);
+			if (ret)
+				return ret;
 
 			ret = ocfs2_acl_set_mode(inode, di_bh,
 						 handle, mode);",linux,073931017b49d9458aa351605b43a7e34598caef,5d3ddd84eaefffd23c028bce5610dac8726f71c1,1,"int ocfs2_set_acl(handle_t *handle,
			 struct inode *inode,
			 struct buffer_head *di_bh,
			 int type,
			 struct posix_acl *acl,
			 struct ocfs2_alloc_context *meta_ac,
			 struct ocfs2_alloc_context *data_ac)
{
	int name_index;
	void *value = NULL;
	size_t size = 0;
	int ret;

	if (S_ISLNK(inode->i_mode))
		return -EOPNOTSUPP;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
//flaw_line_below:
			umode_t mode = inode->i_mode;
//flaw_line_below:
			ret = posix_acl_equiv_mode(acl, &mode);
//flaw_line_below:
			if (ret < 0)
//flaw_line_below:
				return ret;
//fix_flaw_line_below:
//			umode_t mode;
 
//flaw_line_below:
			if (ret == 0)
//flaw_line_below:
				acl = NULL;
//fix_flaw_line_below:
//			ret = posix_acl_update_mode(inode, &mode, &acl);
//fix_flaw_line_below:
//			if (ret)
//fix_flaw_line_below:
//				return ret;
 
 			ret = ocfs2_acl_set_mode(inode, di_bh,
 						 handle, mode);
			if (ret)
				return ret;
		}
		break;
	case ACL_TYPE_DEFAULT:
		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;
	default:
		return -EINVAL;
	}

	if (acl) {
		value = ocfs2_acl_to_xattr(acl, &size);
		if (IS_ERR(value))
			return (int)PTR_ERR(value);
	}

	if (handle)
		ret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,
					     """", value, size, 0,
					     meta_ac, data_ac);
	else
		ret = ocfs2_xattr_set(inode, name_index, """", value, size, 0);

	kfree(value);

	return ret;
}
"
2413,180149,,Local,Not required,,CVE-2016-7097,https://www.cvedetails.com/cve/CVE-2016-7097/,CWE-285,Low,Partial,Partial,,2016-10-16,3.6,"The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",2018-01-04,+Priv ,5,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,073931017b49d9458aa351605b43a7e34598caef,"posix_acl: Clear SGID bit when setting file permissions

When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

References: CVE-2016-7097
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>",10,fs/orangefs/acl.c,"{""sha"": ""b3c2cc79c20d255f5d3cdf59e407ad65c67c7089"", ""filename"": ""fs/9p/acl.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 23, ""changes"": 40, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/9p/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -276,32 +276,26 @@ static int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n \tswitch (handler->flags) {\n \tcase ACL_TYPE_ACCESS:\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (retval < 0)\n+\t\t\tstruct iattr iattr;\n+\n+\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n+\t\t\tif (retval)\n \t\t\t\tgoto err_out;\n-\t\t\telse {\n-\t\t\t\tstruct iattr iattr;\n-\t\t\t\tif (retval == 0) {\n-\t\t\t\t\t/*\n-\t\t\t\t\t * ACL can be represented\n-\t\t\t\t\t * by the mode bits. So don't\n-\t\t\t\t\t * update ACL.\n-\t\t\t\t\t */\n-\t\t\t\t\tacl = NULL;\n-\t\t\t\t\tvalue = NULL;\n-\t\t\t\t\tsize = 0;\n-\t\t\t\t}\n-\t\t\t\t/* Updte the mode bits */\n-\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n-\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n-\t\t\t\tiattr.ia_valid = ATTR_MODE;\n-\t\t\t\t/* FIXME should we update ctime ?\n-\t\t\t\t * What is the following setxattr update the\n-\t\t\t\t * mode ?\n+\t\t\tif (!acl) {\n+\t\t\t\t/*\n+\t\t\t\t * ACL can be represented\n+\t\t\t\t * by the mode bits. So don't\n+\t\t\t\t * update ACL.\n \t\t\t\t */\n-\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n+\t\t\t\tvalue = NULL;\n+\t\t\t\tsize = 0;\n \t\t\t}\n+\t\t\tiattr.ia_valid = ATTR_MODE;\n+\t\t\t/* FIXME should we update ctime ?\n+\t\t\t * What is the following setxattr update the\n+\t\t\t * mode ?\n+\t\t\t */\n+\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""247b8dfaf6e5e53b2f8a898f036375819a1ac225"", ""filename"": ""fs/btrfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -79,11 +79,9 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\treturn ret;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tret = 0;\n \t\tbreak;""}<_**next**_>{""sha"": ""d0b6b342dff982c487880beb9d5bd3868f7502d6"", ""filename"": ""fs/ceph/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ceph/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -95,11 +95,9 @@ int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &new_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\tgoto out;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""e725aa0890e00ea9e97f8255cf9b4c8e082a0bb2"", ""filename"": ""fs/ext2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -190,15 +190,11 @@ ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\tcase ACL_TYPE_ACCESS:\n \t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\t\tif (acl) {\n-\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\t\tif (error < 0)\n+\t\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\t\tif (error)\n \t\t\t\t\treturn error;\n-\t\t\t\telse {\n-\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n-\t\t\t\t\tmark_inode_dirty(inode);\n-\t\t\t\t\tif (error == 0)\n-\t\t\t\t\t\tacl = NULL;\n-\t\t\t\t}\n+\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n+\t\t\t\tmark_inode_dirty(inode);\n \t\t\t}\n \t\t\tbreak;\n ""}<_**next**_>{""sha"": ""dfa519979038b9c2475f335a1f44e8326eb8f799"", ""filename"": ""fs/ext4/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -193,15 +193,11 @@ __ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n-\t\t\t\text4_mark_inode_dirty(handle, inode);\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n+\t\t\tinode->i_ctime = ext4_current_time(inode);\n+\t\t\text4_mark_inode_dirty(handle, inode);\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""31344247ce891bbadf4432a5a1dd9bfeb1e514f9"", ""filename"": ""fs/f2fs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -210,12 +210,10 @@ static int __f2fs_set_acl(struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n \t\t\tset_acl_inode(inode, inode->i_mode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""2524807ee0703643867e7e04c803d10b1aab9182"", ""filename"": ""fs/gfs2/acl.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 9, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -92,17 +92,11 @@ int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tif (type == ACL_TYPE_ACCESS) {\n \t\tumode_t mode = inode->i_mode;\n \n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\tif (error < 0)\n+\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\tif (error)\n \t\t\treturn error;\n-\n-\t\tif (error == 0)\n-\t\t\tacl = NULL;\n-\n-\t\tif (mode != inode->i_mode) {\n-\t\t\tinode->i_mode = mode;\n+\t\tif (mode != inode->i_mode)\n \t\t\tmark_inode_dirty(inode);\n-\t\t}\n \t}\n \n \tif (acl) {""}<_**next**_>{""sha"": ""9b92058a12409d6aa4040ed228ab1d2e5a6d8537"", ""filename"": ""fs/hfsplus/posix_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/hfsplus/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -65,8 +65,8 @@ int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n \tcase ACL_TYPE_ACCESS:\n \t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (err < 0)\n+\t\t\terr = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (err)\n \t\t\t\treturn err;\n \t\t}\n \t\terr = 0;""}<_**next**_>{""sha"": ""2a0f2a1044c16009ff2c48334b48a49157e7aece"", ""filename"": ""fs/jffs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jffs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -233,9 +233,10 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (rc < 0)\n+\t\t\tumode_t mode;\n+\n+\t\t\trc = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tif (inode->i_mode != mode) {\n \t\t\t\tstruct iattr attr;\n@@ -247,8 +248,6 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tif (rc < 0)\n \t\t\t\t\treturn rc;\n \t\t\t}\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""3a1e1554a4e3598132bd6665f05c200922345a9a"", ""filename"": ""fs/jfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -78,13 +78,11 @@ static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (rc < 0)\n+\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tinode->i_ctime = CURRENT_TIME;\n \t\t\tmark_inode_dirty(inode);\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""164307b994052cb658b08cb8c28da524dedfe644"", ""filename"": ""fs/ocfs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 6, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -241,13 +241,11 @@ int ocfs2_set_acl(handle_t *handle,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (ret < 0)\n-\t\t\t\treturn ret;\n+\t\t\tumode_t mode;\n \n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n+\t\t\tret = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (ret)\n+\t\t\t\treturn ret;\n \n \t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n \t\t\t\t\t\t handle, mode);""}<_**next**_>{""sha"": ""7a3754488312c650b3003f5cb23a06bb17a53aeb"", ""filename"": ""fs/orangefs/acl.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 10, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/orangefs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -73,14 +73,11 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\t/*\n-\t\t\t * can we represent this with the traditional file\n-\t\t\t * mode permission bits?\n-\t\t\t */\n-\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (error < 0) {\n-\t\t\t\tgossip_err(\""%s: posix_acl_equiv_mode err: %d\\n\"",\n+\t\t\tumode_t mode;\n+\n+\t\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (error) {\n+\t\t\t\tgossip_err(\""%s: posix_acl_update_mode err: %d\\n\"",\n \t\t\t\t\t   __func__,\n \t\t\t\t\t   error);\n \t\t\t\treturn error;\n@@ -90,8 +87,6 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tSetModeFlag(orangefs_inode);\n \t\t\tinode->i_mode = mode;\n \t\t\tmark_inode_dirty_sync(inode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""bfc3ec38832282ca9834bb06379ffc0132e041c5"", ""filename"": ""fs/posix_acl.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -626,6 +626,37 @@ posix_acl_create(struct inode *dir, umode_t *mode,\n }\n EXPORT_SYMBOL_GPL(posix_acl_create);\n \n+/**\n+ * posix_acl_update_mode  -  update mode in set_acl\n+ *\n+ * Update the file mode when setting an ACL: compute the new file permission\n+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n+ * file mode, set *acl to NULL to indicate that no ACL should be set.\n+ *\n+ * As with chmod, clear the setgit bit if the caller is not in the owning group\n+ * or capable of CAP_FSETID (see inode_change_ok).\n+ *\n+ * Called from set_acl inode operations.\n+ */\n+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n+\t\t\t  struct posix_acl **acl)\n+{\n+\tumode_t mode = inode->i_mode;\n+\tint error;\n+\n+\terror = posix_acl_equiv_mode(*acl, &mode);\n+\tif (error < 0)\n+\t\treturn error;\n+\tif (error == 0)\n+\t\t*acl = NULL;\n+\tif (!in_group_p(inode->i_gid) &&\n+\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n+\t\tmode &= ~S_ISGID;\n+\t*mode_p = mode;\n+\treturn 0;\n+}\n+EXPORT_SYMBOL(posix_acl_update_mode);\n+\n /*\n  * Fix up the uids and gids in posix acl extended attributes in place.\n  */""}<_**next**_>{""sha"": ""27376681c6405f439a6b5026554ee5e20e11e4d5"", ""filename"": ""fs/reiserfs/xattr_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 6, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/xattr_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -242,13 +242,9 @@ __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""8a0dec89ca560622ffa491a7dba8855145889601"", ""filename"": ""fs/xfs/xfs_acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 9, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -257,16 +257,11 @@ xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\treturn error;\n \n \tif (type == ACL_TYPE_ACCESS) {\n-\t\tumode_t mode = inode->i_mode;\n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\n-\t\tif (error <= 0) {\n-\t\t\tacl = NULL;\n-\n-\t\t\tif (error < 0)\n-\t\t\t\treturn error;\n-\t\t}\n+\t\tumode_t mode;\n \n+\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\tif (error)\n+\t\t\treturn error;\n \t\terror = xfs_set_mode(inode, mode);\n \t\tif (error)\n \t\t\treturn error;""}<_**next**_>{""sha"": ""bf1046d0397bbbde8806459faa3833d8bbf2d79f"", ""filename"": ""include/linux/posix_acl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/posix_acl.h?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -93,6 +93,7 @@ extern int set_posix_acl(struct inode *, int, struct posix_acl *);\n extern int posix_acl_chmod(struct inode *, umode_t);\n extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,\n \t\tstruct posix_acl **);\n+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);\n \n extern int simple_set_acl(struct inode *, struct posix_acl *, int);\n extern int simple_acl_create(struct inode *, struct inode *);""}","int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
	int error = 0;
	void *value = NULL;
	size_t size = 0;
	const char *name = NULL;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
			umode_t mode;

			error = posix_acl_update_mode(inode, &mode, &acl);
			if (error) {
				gossip_err(""%s: posix_acl_update_mode err: %d\n"",
 					   __func__,
 					   error);
 				return error;
			}

			if (inode->i_mode != mode)
 				SetModeFlag(orangefs_inode);
 			inode->i_mode = mode;
 			mark_inode_dirty_sync(inode);
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		name = XATTR_NAME_POSIX_ACL_DEFAULT;
		break;
	default:
		gossip_err(""%s: invalid type %d!\n"", __func__, type);
		return -EINVAL;
	}

	gossip_debug(GOSSIP_ACL_DEBUG,
		     ""%s: inode %pU, key %s type %d\n"",
		     __func__, get_khandle_from_ino(inode),
		     name,
		     type);

	if (acl) {
		size = posix_acl_xattr_size(acl->a_count);
		value = kmalloc(size, GFP_KERNEL);
		if (!value)
			return -ENOMEM;

		error = posix_acl_to_xattr(&init_user_ns, acl, value, size);
		if (error < 0)
			goto out;
	}

	gossip_debug(GOSSIP_ACL_DEBUG,
		     ""%s: name %s, value %p, size %zd, acl %p\n"",
		     __func__, name, value, size, acl);
	/*
	 * Go ahead and set the extended attribute now. NOTE: Suppose acl
	 * was NULL, then value will be NULL and size will be 0 and that
	 * will xlate to a removexattr. However, we don't want removexattr
	 * complain if attributes does not exist.
	 */
	error = orangefs_inode_setxattr(inode, name, value, size, 0);

out:
	kfree(value);
	if (!error)
		set_cached_acl(inode, type, acl);
	return error;
}
","int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
	int error = 0;
	void *value = NULL;
	size_t size = 0;
	const char *name = NULL;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
			umode_t mode = inode->i_mode;
			/*
			 * can we represent this with the traditional file
			 * mode permission bits?
			 */
			error = posix_acl_equiv_mode(acl, &mode);
			if (error < 0) {
				gossip_err(""%s: posix_acl_equiv_mode err: %d\n"",
 					   __func__,
 					   error);
 				return error;
			}

			if (inode->i_mode != mode)
 				SetModeFlag(orangefs_inode);
 			inode->i_mode = mode;
 			mark_inode_dirty_sync(inode);
			if (error == 0)
				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		name = XATTR_NAME_POSIX_ACL_DEFAULT;
		break;
	default:
		gossip_err(""%s: invalid type %d!\n"", __func__, type);
		return -EINVAL;
	}

	gossip_debug(GOSSIP_ACL_DEBUG,
		     ""%s: inode %pU, key %s type %d\n"",
		     __func__, get_khandle_from_ino(inode),
		     name,
		     type);

	if (acl) {
		size = posix_acl_xattr_size(acl->a_count);
		value = kmalloc(size, GFP_KERNEL);
		if (!value)
			return -ENOMEM;

		error = posix_acl_to_xattr(&init_user_ns, acl, value, size);
		if (error < 0)
			goto out;
	}

	gossip_debug(GOSSIP_ACL_DEBUG,
		     ""%s: name %s, value %p, size %zd, acl %p\n"",
		     __func__, name, value, size, acl);
	/*
	 * Go ahead and set the extended attribute now. NOTE: Suppose acl
	 * was NULL, then value will be NULL and size will be 0 and that
	 * will xlate to a removexattr. However, we don't want removexattr
	 * complain if attributes does not exist.
	 */
	error = orangefs_inode_setxattr(inode, name, value, size, 0);

out:
	kfree(value);
	if (!error)
		set_cached_acl(inode, type, acl);
	return error;
}
",C,"			umode_t mode;

			error = posix_acl_update_mode(inode, &mode, &acl);
			if (error) {
				gossip_err(""%s: posix_acl_update_mode err: %d\n"",
","			umode_t mode = inode->i_mode;
			/*
			 * can we represent this with the traditional file
			 * mode permission bits?
			 */
			error = posix_acl_equiv_mode(acl, &mode);
			if (error < 0) {
				gossip_err(""%s: posix_acl_equiv_mode err: %d\n"",
			if (error == 0)
				acl = NULL;
",,"@@ -73,14 +73,11 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
-			umode_t mode = inode->i_mode;
-			/*
-			 * can we represent this with the traditional file
-			 * mode permission bits?
-			 */
-			error = posix_acl_equiv_mode(acl, &mode);
-			if (error < 0) {
-				gossip_err(""%s: posix_acl_equiv_mode err: %d\n"",
+			umode_t mode;
+
+			error = posix_acl_update_mode(inode, &mode, &acl);
+			if (error) {
+				gossip_err(""%s: posix_acl_update_mode err: %d\n"",
 					   __func__,
 					   error);
 				return error;
@@ -90,8 +87,6 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 				SetModeFlag(orangefs_inode);
 			inode->i_mode = mode;
 			mark_inode_dirty_sync(inode);
-			if (error == 0)
-				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:",linux,073931017b49d9458aa351605b43a7e34598caef,5d3ddd84eaefffd23c028bce5610dac8726f71c1,1,"int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
	int error = 0;
	void *value = NULL;
	size_t size = 0;
	const char *name = NULL;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
//flaw_line_below:
			umode_t mode = inode->i_mode;
//flaw_line_below:
			/*
//flaw_line_below:
			 * can we represent this with the traditional file
//flaw_line_below:
			 * mode permission bits?
//flaw_line_below:
			 */
//flaw_line_below:
			error = posix_acl_equiv_mode(acl, &mode);
//flaw_line_below:
			if (error < 0) {
//flaw_line_below:
				gossip_err(""%s: posix_acl_equiv_mode err: %d\n"",
//fix_flaw_line_below:
//			umode_t mode;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//			error = posix_acl_update_mode(inode, &mode, &acl);
//fix_flaw_line_below:
//			if (error) {
//fix_flaw_line_below:
//				gossip_err(""%s: posix_acl_update_mode err: %d\n"",
 					   __func__,
 					   error);
 				return error;
			}

			if (inode->i_mode != mode)
 				SetModeFlag(orangefs_inode);
 			inode->i_mode = mode;
 			mark_inode_dirty_sync(inode);
//flaw_line_below:
			if (error == 0)
//flaw_line_below:
				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		name = XATTR_NAME_POSIX_ACL_DEFAULT;
		break;
	default:
		gossip_err(""%s: invalid type %d!\n"", __func__, type);
		return -EINVAL;
	}

	gossip_debug(GOSSIP_ACL_DEBUG,
		     ""%s: inode %pU, key %s type %d\n"",
		     __func__, get_khandle_from_ino(inode),
		     name,
		     type);

	if (acl) {
		size = posix_acl_xattr_size(acl->a_count);
		value = kmalloc(size, GFP_KERNEL);
		if (!value)
			return -ENOMEM;

		error = posix_acl_to_xattr(&init_user_ns, acl, value, size);
		if (error < 0)
			goto out;
	}

	gossip_debug(GOSSIP_ACL_DEBUG,
		     ""%s: name %s, value %p, size %zd, acl %p\n"",
		     __func__, name, value, size, acl);
	/*
	 * Go ahead and set the extended attribute now. NOTE: Suppose acl
	 * was NULL, then value will be NULL and size will be 0 and that
	 * will xlate to a removexattr. However, we don't want removexattr
	 * complain if attributes does not exist.
	 */
	error = orangefs_inode_setxattr(inode, name, value, size, 0);

out:
	kfree(value);
	if (!error)
		set_cached_acl(inode, type, acl);
	return error;
}
"
2414,180150,,Local,Not required,,CVE-2016-7097,https://www.cvedetails.com/cve/CVE-2016-7097/,CWE-285,Low,Partial,Partial,,2016-10-16,3.6,"The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",2018-01-04,+Priv ,2,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,073931017b49d9458aa351605b43a7e34598caef,"posix_acl: Clear SGID bit when setting file permissions

When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

References: CVE-2016-7097
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>",6,fs/reiserfs/xattr_acl.c,"{""sha"": ""b3c2cc79c20d255f5d3cdf59e407ad65c67c7089"", ""filename"": ""fs/9p/acl.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 23, ""changes"": 40, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/9p/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -276,32 +276,26 @@ static int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n \tswitch (handler->flags) {\n \tcase ACL_TYPE_ACCESS:\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (retval < 0)\n+\t\t\tstruct iattr iattr;\n+\n+\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n+\t\t\tif (retval)\n \t\t\t\tgoto err_out;\n-\t\t\telse {\n-\t\t\t\tstruct iattr iattr;\n-\t\t\t\tif (retval == 0) {\n-\t\t\t\t\t/*\n-\t\t\t\t\t * ACL can be represented\n-\t\t\t\t\t * by the mode bits. So don't\n-\t\t\t\t\t * update ACL.\n-\t\t\t\t\t */\n-\t\t\t\t\tacl = NULL;\n-\t\t\t\t\tvalue = NULL;\n-\t\t\t\t\tsize = 0;\n-\t\t\t\t}\n-\t\t\t\t/* Updte the mode bits */\n-\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n-\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n-\t\t\t\tiattr.ia_valid = ATTR_MODE;\n-\t\t\t\t/* FIXME should we update ctime ?\n-\t\t\t\t * What is the following setxattr update the\n-\t\t\t\t * mode ?\n+\t\t\tif (!acl) {\n+\t\t\t\t/*\n+\t\t\t\t * ACL can be represented\n+\t\t\t\t * by the mode bits. So don't\n+\t\t\t\t * update ACL.\n \t\t\t\t */\n-\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n+\t\t\t\tvalue = NULL;\n+\t\t\t\tsize = 0;\n \t\t\t}\n+\t\t\tiattr.ia_valid = ATTR_MODE;\n+\t\t\t/* FIXME should we update ctime ?\n+\t\t\t * What is the following setxattr update the\n+\t\t\t * mode ?\n+\t\t\t */\n+\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""247b8dfaf6e5e53b2f8a898f036375819a1ac225"", ""filename"": ""fs/btrfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -79,11 +79,9 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\treturn ret;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tret = 0;\n \t\tbreak;""}<_**next**_>{""sha"": ""d0b6b342dff982c487880beb9d5bd3868f7502d6"", ""filename"": ""fs/ceph/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ceph/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -95,11 +95,9 @@ int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &new_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\tgoto out;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""e725aa0890e00ea9e97f8255cf9b4c8e082a0bb2"", ""filename"": ""fs/ext2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -190,15 +190,11 @@ ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\tcase ACL_TYPE_ACCESS:\n \t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\t\tif (acl) {\n-\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\t\tif (error < 0)\n+\t\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\t\tif (error)\n \t\t\t\t\treturn error;\n-\t\t\t\telse {\n-\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n-\t\t\t\t\tmark_inode_dirty(inode);\n-\t\t\t\t\tif (error == 0)\n-\t\t\t\t\t\tacl = NULL;\n-\t\t\t\t}\n+\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n+\t\t\t\tmark_inode_dirty(inode);\n \t\t\t}\n \t\t\tbreak;\n ""}<_**next**_>{""sha"": ""dfa519979038b9c2475f335a1f44e8326eb8f799"", ""filename"": ""fs/ext4/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -193,15 +193,11 @@ __ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n-\t\t\t\text4_mark_inode_dirty(handle, inode);\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n+\t\t\tinode->i_ctime = ext4_current_time(inode);\n+\t\t\text4_mark_inode_dirty(handle, inode);\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""31344247ce891bbadf4432a5a1dd9bfeb1e514f9"", ""filename"": ""fs/f2fs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -210,12 +210,10 @@ static int __f2fs_set_acl(struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n \t\t\tset_acl_inode(inode, inode->i_mode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""2524807ee0703643867e7e04c803d10b1aab9182"", ""filename"": ""fs/gfs2/acl.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 9, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -92,17 +92,11 @@ int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tif (type == ACL_TYPE_ACCESS) {\n \t\tumode_t mode = inode->i_mode;\n \n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\tif (error < 0)\n+\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\tif (error)\n \t\t\treturn error;\n-\n-\t\tif (error == 0)\n-\t\t\tacl = NULL;\n-\n-\t\tif (mode != inode->i_mode) {\n-\t\t\tinode->i_mode = mode;\n+\t\tif (mode != inode->i_mode)\n \t\t\tmark_inode_dirty(inode);\n-\t\t}\n \t}\n \n \tif (acl) {""}<_**next**_>{""sha"": ""9b92058a12409d6aa4040ed228ab1d2e5a6d8537"", ""filename"": ""fs/hfsplus/posix_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/hfsplus/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -65,8 +65,8 @@ int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n \tcase ACL_TYPE_ACCESS:\n \t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (err < 0)\n+\t\t\terr = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (err)\n \t\t\t\treturn err;\n \t\t}\n \t\terr = 0;""}<_**next**_>{""sha"": ""2a0f2a1044c16009ff2c48334b48a49157e7aece"", ""filename"": ""fs/jffs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jffs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -233,9 +233,10 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (rc < 0)\n+\t\t\tumode_t mode;\n+\n+\t\t\trc = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tif (inode->i_mode != mode) {\n \t\t\t\tstruct iattr attr;\n@@ -247,8 +248,6 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tif (rc < 0)\n \t\t\t\t\treturn rc;\n \t\t\t}\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""3a1e1554a4e3598132bd6665f05c200922345a9a"", ""filename"": ""fs/jfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -78,13 +78,11 @@ static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (rc < 0)\n+\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tinode->i_ctime = CURRENT_TIME;\n \t\t\tmark_inode_dirty(inode);\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""164307b994052cb658b08cb8c28da524dedfe644"", ""filename"": ""fs/ocfs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 6, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -241,13 +241,11 @@ int ocfs2_set_acl(handle_t *handle,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (ret < 0)\n-\t\t\t\treturn ret;\n+\t\t\tumode_t mode;\n \n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n+\t\t\tret = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (ret)\n+\t\t\t\treturn ret;\n \n \t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n \t\t\t\t\t\t handle, mode);""}<_**next**_>{""sha"": ""7a3754488312c650b3003f5cb23a06bb17a53aeb"", ""filename"": ""fs/orangefs/acl.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 10, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/orangefs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -73,14 +73,11 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\t/*\n-\t\t\t * can we represent this with the traditional file\n-\t\t\t * mode permission bits?\n-\t\t\t */\n-\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (error < 0) {\n-\t\t\t\tgossip_err(\""%s: posix_acl_equiv_mode err: %d\\n\"",\n+\t\t\tumode_t mode;\n+\n+\t\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (error) {\n+\t\t\t\tgossip_err(\""%s: posix_acl_update_mode err: %d\\n\"",\n \t\t\t\t\t   __func__,\n \t\t\t\t\t   error);\n \t\t\t\treturn error;\n@@ -90,8 +87,6 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tSetModeFlag(orangefs_inode);\n \t\t\tinode->i_mode = mode;\n \t\t\tmark_inode_dirty_sync(inode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""bfc3ec38832282ca9834bb06379ffc0132e041c5"", ""filename"": ""fs/posix_acl.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -626,6 +626,37 @@ posix_acl_create(struct inode *dir, umode_t *mode,\n }\n EXPORT_SYMBOL_GPL(posix_acl_create);\n \n+/**\n+ * posix_acl_update_mode  -  update mode in set_acl\n+ *\n+ * Update the file mode when setting an ACL: compute the new file permission\n+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n+ * file mode, set *acl to NULL to indicate that no ACL should be set.\n+ *\n+ * As with chmod, clear the setgit bit if the caller is not in the owning group\n+ * or capable of CAP_FSETID (see inode_change_ok).\n+ *\n+ * Called from set_acl inode operations.\n+ */\n+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n+\t\t\t  struct posix_acl **acl)\n+{\n+\tumode_t mode = inode->i_mode;\n+\tint error;\n+\n+\terror = posix_acl_equiv_mode(*acl, &mode);\n+\tif (error < 0)\n+\t\treturn error;\n+\tif (error == 0)\n+\t\t*acl = NULL;\n+\tif (!in_group_p(inode->i_gid) &&\n+\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n+\t\tmode &= ~S_ISGID;\n+\t*mode_p = mode;\n+\treturn 0;\n+}\n+EXPORT_SYMBOL(posix_acl_update_mode);\n+\n /*\n  * Fix up the uids and gids in posix acl extended attributes in place.\n  */""}<_**next**_>{""sha"": ""27376681c6405f439a6b5026554ee5e20e11e4d5"", ""filename"": ""fs/reiserfs/xattr_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 6, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/xattr_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -242,13 +242,9 @@ __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""8a0dec89ca560622ffa491a7dba8855145889601"", ""filename"": ""fs/xfs/xfs_acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 9, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -257,16 +257,11 @@ xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\treturn error;\n \n \tif (type == ACL_TYPE_ACCESS) {\n-\t\tumode_t mode = inode->i_mode;\n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\n-\t\tif (error <= 0) {\n-\t\t\tacl = NULL;\n-\n-\t\t\tif (error < 0)\n-\t\t\t\treturn error;\n-\t\t}\n+\t\tumode_t mode;\n \n+\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\tif (error)\n+\t\t\treturn error;\n \t\terror = xfs_set_mode(inode, mode);\n \t\tif (error)\n \t\t\treturn error;""}<_**next**_>{""sha"": ""bf1046d0397bbbde8806459faa3833d8bbf2d79f"", ""filename"": ""include/linux/posix_acl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/posix_acl.h?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -93,6 +93,7 @@ extern int set_posix_acl(struct inode *, int, struct posix_acl *);\n extern int posix_acl_chmod(struct inode *, umode_t);\n extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,\n \t\tstruct posix_acl **);\n+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);\n \n extern int simple_set_acl(struct inode *, struct posix_acl *, int);\n extern int simple_acl_create(struct inode *, struct inode *);""}","__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,
		 int type, struct posix_acl *acl)
{
	char *name;
	void *value = NULL;
	size_t size = 0;
	int error;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
			if (error)
 				return error;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		name = XATTR_NAME_POSIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;
	default:
		return -EINVAL;
	}

	if (acl) {
		value = reiserfs_posix_acl_to_disk(acl, &size);
		if (IS_ERR(value))
			return (int)PTR_ERR(value);
	}

	error = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);

	/*
	 * Ensure that the inode gets dirtied if we're only using
	 * the mode bits and an old ACL didn't exist. We don't need
	 * to check if the inode is hashed here since we won't get
	 * called by reiserfs_inherit_default_acl().
	 */
	if (error == -ENODATA) {
		error = 0;
		if (type == ACL_TYPE_ACCESS) {
			inode->i_ctime = CURRENT_TIME_SEC;
			mark_inode_dirty(inode);
		}
	}

	kfree(value);

	if (!error)
		set_cached_acl(inode, type, acl);

	return error;
}
","__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,
		 int type, struct posix_acl *acl)
{
	char *name;
	void *value = NULL;
	size_t size = 0;
	int error;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
			error = posix_acl_equiv_mode(acl, &inode->i_mode);
			if (error < 0)
 				return error;
			else {
				if (error == 0)
					acl = NULL;
			}
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		name = XATTR_NAME_POSIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;
	default:
		return -EINVAL;
	}

	if (acl) {
		value = reiserfs_posix_acl_to_disk(acl, &size);
		if (IS_ERR(value))
			return (int)PTR_ERR(value);
	}

	error = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);

	/*
	 * Ensure that the inode gets dirtied if we're only using
	 * the mode bits and an old ACL didn't exist. We don't need
	 * to check if the inode is hashed here since we won't get
	 * called by reiserfs_inherit_default_acl().
	 */
	if (error == -ENODATA) {
		error = 0;
		if (type == ACL_TYPE_ACCESS) {
			inode->i_ctime = CURRENT_TIME_SEC;
			mark_inode_dirty(inode);
		}
	}

	kfree(value);

	if (!error)
		set_cached_acl(inode, type, acl);

	return error;
}
",C,"			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
			if (error)
","			error = posix_acl_equiv_mode(acl, &inode->i_mode);
			if (error < 0)
			else {
				if (error == 0)
					acl = NULL;
			}
",,"@@ -242,13 +242,9 @@ __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
-			error = posix_acl_equiv_mode(acl, &inode->i_mode);
-			if (error < 0)
+			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+			if (error)
 				return error;
-			else {
-				if (error == 0)
-					acl = NULL;
-			}
 		}
 		break;
 	case ACL_TYPE_DEFAULT:",linux,073931017b49d9458aa351605b43a7e34598caef,5d3ddd84eaefffd23c028bce5610dac8726f71c1,1,"__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,
		 int type, struct posix_acl *acl)
{
	char *name;
	void *value = NULL;
	size_t size = 0;
	int error;

	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
//flaw_line_below:
			error = posix_acl_equiv_mode(acl, &inode->i_mode);
//flaw_line_below:
			if (error < 0)
//fix_flaw_line_below:
//			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
//fix_flaw_line_below:
//			if (error)
 				return error;
//flaw_line_below:
			else {
//flaw_line_below:
				if (error == 0)
//flaw_line_below:
					acl = NULL;
//flaw_line_below:
			}
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
		name = XATTR_NAME_POSIX_ACL_DEFAULT;
		if (!S_ISDIR(inode->i_mode))
			return acl ? -EACCES : 0;
		break;
	default:
		return -EINVAL;
	}

	if (acl) {
		value = reiserfs_posix_acl_to_disk(acl, &size);
		if (IS_ERR(value))
			return (int)PTR_ERR(value);
	}

	error = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);

	/*
	 * Ensure that the inode gets dirtied if we're only using
	 * the mode bits and an old ACL didn't exist. We don't need
	 * to check if the inode is hashed here since we won't get
	 * called by reiserfs_inherit_default_acl().
	 */
	if (error == -ENODATA) {
		error = 0;
		if (type == ACL_TYPE_ACCESS) {
			inode->i_ctime = CURRENT_TIME_SEC;
			mark_inode_dirty(inode);
		}
	}

	kfree(value);

	if (!error)
		set_cached_acl(inode, type, acl);

	return error;
}
"
2415,180151,,Local,Not required,,CVE-2016-7097,https://www.cvedetails.com/cve/CVE-2016-7097/,CWE-285,Low,Partial,Partial,,2016-10-16,3.6,"The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",2018-01-04,+Priv ,4,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,073931017b49d9458aa351605b43a7e34598caef,"posix_acl: Clear SGID bit when setting file permissions

When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

References: CVE-2016-7097
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>",7,fs/xfs/xfs_acl.c,"{""sha"": ""b3c2cc79c20d255f5d3cdf59e407ad65c67c7089"", ""filename"": ""fs/9p/acl.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 23, ""changes"": 40, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/9p/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/9p/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -276,32 +276,26 @@ static int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n \tswitch (handler->flags) {\n \tcase ACL_TYPE_ACCESS:\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (retval < 0)\n+\t\t\tstruct iattr iattr;\n+\n+\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n+\t\t\tif (retval)\n \t\t\t\tgoto err_out;\n-\t\t\telse {\n-\t\t\t\tstruct iattr iattr;\n-\t\t\t\tif (retval == 0) {\n-\t\t\t\t\t/*\n-\t\t\t\t\t * ACL can be represented\n-\t\t\t\t\t * by the mode bits. So don't\n-\t\t\t\t\t * update ACL.\n-\t\t\t\t\t */\n-\t\t\t\t\tacl = NULL;\n-\t\t\t\t\tvalue = NULL;\n-\t\t\t\t\tsize = 0;\n-\t\t\t\t}\n-\t\t\t\t/* Updte the mode bits */\n-\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n-\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n-\t\t\t\tiattr.ia_valid = ATTR_MODE;\n-\t\t\t\t/* FIXME should we update ctime ?\n-\t\t\t\t * What is the following setxattr update the\n-\t\t\t\t * mode ?\n+\t\t\tif (!acl) {\n+\t\t\t\t/*\n+\t\t\t\t * ACL can be represented\n+\t\t\t\t * by the mode bits. So don't\n+\t\t\t\t * update ACL.\n \t\t\t\t */\n-\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n+\t\t\t\tvalue = NULL;\n+\t\t\t\tsize = 0;\n \t\t\t}\n+\t\t\tiattr.ia_valid = ATTR_MODE;\n+\t\t\t/* FIXME should we update ctime ?\n+\t\t\t * What is the following setxattr update the\n+\t\t\t * mode ?\n+\t\t\t */\n+\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""247b8dfaf6e5e53b2f8a898f036375819a1ac225"", ""filename"": ""fs/btrfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/btrfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -79,11 +79,9 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\treturn ret;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tret = 0;\n \t\tbreak;""}<_**next**_>{""sha"": ""d0b6b342dff982c487880beb9d5bd3868f7502d6"", ""filename"": ""fs/ceph/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ceph/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ceph/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -95,11 +95,9 @@ int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n-\t\t\tif (ret < 0)\n+\t\t\tret = posix_acl_update_mode(inode, &new_mode, &acl);\n+\t\t\tif (ret)\n \t\t\t\tgoto out;\n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""e725aa0890e00ea9e97f8255cf9b4c8e082a0bb2"", ""filename"": ""fs/ext2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -190,15 +190,11 @@ ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\tcase ACL_TYPE_ACCESS:\n \t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\t\tif (acl) {\n-\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\t\tif (error < 0)\n+\t\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\t\tif (error)\n \t\t\t\t\treturn error;\n-\t\t\t\telse {\n-\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n-\t\t\t\t\tmark_inode_dirty(inode);\n-\t\t\t\t\tif (error == 0)\n-\t\t\t\t\t\tacl = NULL;\n-\t\t\t\t}\n+\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n+\t\t\t\tmark_inode_dirty(inode);\n \t\t\t}\n \t\t\tbreak;\n ""}<_**next**_>{""sha"": ""dfa519979038b9c2475f335a1f44e8326eb8f799"", ""filename"": ""fs/ext4/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ext4/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -193,15 +193,11 @@ __ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n-\t\t\t\text4_mark_inode_dirty(handle, inode);\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n+\t\t\tinode->i_ctime = ext4_current_time(inode);\n+\t\t\text4_mark_inode_dirty(handle, inode);\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""31344247ce891bbadf4432a5a1dd9bfeb1e514f9"", ""filename"": ""fs/f2fs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/f2fs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -210,12 +210,10 @@ static int __f2fs_set_acl(struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n \t\t\tset_acl_inode(inode, inode->i_mode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n ""}<_**next**_>{""sha"": ""2524807ee0703643867e7e04c803d10b1aab9182"", ""filename"": ""fs/gfs2/acl.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 9, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/gfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -92,17 +92,11 @@ int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tif (type == ACL_TYPE_ACCESS) {\n \t\tumode_t mode = inode->i_mode;\n \n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\tif (error < 0)\n+\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\tif (error)\n \t\t\treturn error;\n-\n-\t\tif (error == 0)\n-\t\t\tacl = NULL;\n-\n-\t\tif (mode != inode->i_mode) {\n-\t\t\tinode->i_mode = mode;\n+\t\tif (mode != inode->i_mode)\n \t\t\tmark_inode_dirty(inode);\n-\t\t}\n \t}\n \n \tif (acl) {""}<_**next**_>{""sha"": ""9b92058a12409d6aa4040ed228ab1d2e5a6d8537"", ""filename"": ""fs/hfsplus/posix_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/hfsplus/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/hfsplus/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -65,8 +65,8 @@ int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n \tcase ACL_TYPE_ACCESS:\n \t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (err < 0)\n+\t\t\terr = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (err)\n \t\t\t\treturn err;\n \t\t}\n \t\terr = 0;""}<_**next**_>{""sha"": ""2a0f2a1044c16009ff2c48334b48a49157e7aece"", ""filename"": ""fs/jffs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jffs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jffs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -233,9 +233,10 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (rc < 0)\n+\t\t\tumode_t mode;\n+\n+\t\t\trc = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tif (inode->i_mode != mode) {\n \t\t\t\tstruct iattr attr;\n@@ -247,8 +248,6 @@ int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tif (rc < 0)\n \t\t\t\t\treturn rc;\n \t\t\t}\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""3a1e1554a4e3598132bd6665f05c200922345a9a"", ""filename"": ""fs/jfs/acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/jfs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -78,13 +78,11 @@ static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n \tcase ACL_TYPE_ACCESS:\n \t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (rc < 0)\n+\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (rc)\n \t\t\t\treturn rc;\n \t\t\tinode->i_ctime = CURRENT_TIME;\n \t\t\tmark_inode_dirty(inode);\n-\t\t\tif (rc == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""164307b994052cb658b08cb8c28da524dedfe644"", ""filename"": ""fs/ocfs2/acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 6, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/ocfs2/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -241,13 +241,11 @@ int ocfs2_set_acl(handle_t *handle,\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (ret < 0)\n-\t\t\t\treturn ret;\n+\t\t\tumode_t mode;\n \n-\t\t\tif (ret == 0)\n-\t\t\t\tacl = NULL;\n+\t\t\tret = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (ret)\n+\t\t\t\treturn ret;\n \n \t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n \t\t\t\t\t\t handle, mode);""}<_**next**_>{""sha"": ""7a3754488312c650b3003f5cb23a06bb17a53aeb"", ""filename"": ""fs/orangefs/acl.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 10, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/orangefs/acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/orangefs/acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -73,14 +73,11 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\tumode_t mode = inode->i_mode;\n-\t\t\t/*\n-\t\t\t * can we represent this with the traditional file\n-\t\t\t * mode permission bits?\n-\t\t\t */\n-\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\t\t\tif (error < 0) {\n-\t\t\t\tgossip_err(\""%s: posix_acl_equiv_mode err: %d\\n\"",\n+\t\t\tumode_t mode;\n+\n+\t\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\t\tif (error) {\n+\t\t\t\tgossip_err(\""%s: posix_acl_update_mode err: %d\\n\"",\n \t\t\t\t\t   __func__,\n \t\t\t\t\t   error);\n \t\t\t\treturn error;\n@@ -90,8 +87,6 @@ int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\t\t\tSetModeFlag(orangefs_inode);\n \t\t\tinode->i_mode = mode;\n \t\t\tmark_inode_dirty_sync(inode);\n-\t\t\tif (error == 0)\n-\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""bfc3ec38832282ca9834bb06379ffc0132e041c5"", ""filename"": ""fs/posix_acl.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/posix_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/posix_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -626,6 +626,37 @@ posix_acl_create(struct inode *dir, umode_t *mode,\n }\n EXPORT_SYMBOL_GPL(posix_acl_create);\n \n+/**\n+ * posix_acl_update_mode  -  update mode in set_acl\n+ *\n+ * Update the file mode when setting an ACL: compute the new file permission\n+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n+ * file mode, set *acl to NULL to indicate that no ACL should be set.\n+ *\n+ * As with chmod, clear the setgit bit if the caller is not in the owning group\n+ * or capable of CAP_FSETID (see inode_change_ok).\n+ *\n+ * Called from set_acl inode operations.\n+ */\n+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n+\t\t\t  struct posix_acl **acl)\n+{\n+\tumode_t mode = inode->i_mode;\n+\tint error;\n+\n+\terror = posix_acl_equiv_mode(*acl, &mode);\n+\tif (error < 0)\n+\t\treturn error;\n+\tif (error == 0)\n+\t\t*acl = NULL;\n+\tif (!in_group_p(inode->i_gid) &&\n+\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n+\t\tmode &= ~S_ISGID;\n+\t*mode_p = mode;\n+\treturn 0;\n+}\n+EXPORT_SYMBOL(posix_acl_update_mode);\n+\n /*\n  * Fix up the uids and gids in posix acl extended attributes in place.\n  */""}<_**next**_>{""sha"": ""27376681c6405f439a6b5026554ee5e20e11e4d5"", ""filename"": ""fs/reiserfs/xattr_acl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 6, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/reiserfs/xattr_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/xattr_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -242,13 +242,9 @@ __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n-\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\t\tif (error < 0)\n+\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n+\t\t\tif (error)\n \t\t\t\treturn error;\n-\t\t\telse {\n-\t\t\t\tif (error == 0)\n-\t\t\t\t\tacl = NULL;\n-\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:""}<_**next**_>{""sha"": ""8a0dec89ca560622ffa491a7dba8855145889601"", ""filename"": ""fs/xfs/xfs_acl.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 9, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/fs/xfs/xfs_acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_acl.c?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -257,16 +257,11 @@ xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \t\treturn error;\n \n \tif (type == ACL_TYPE_ACCESS) {\n-\t\tumode_t mode = inode->i_mode;\n-\t\terror = posix_acl_equiv_mode(acl, &mode);\n-\n-\t\tif (error <= 0) {\n-\t\t\tacl = NULL;\n-\n-\t\t\tif (error < 0)\n-\t\t\t\treturn error;\n-\t\t}\n+\t\tumode_t mode;\n \n+\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n+\t\tif (error)\n+\t\t\treturn error;\n \t\terror = xfs_set_mode(inode, mode);\n \t\tif (error)\n \t\t\treturn error;""}<_**next**_>{""sha"": ""bf1046d0397bbbde8806459faa3833d8bbf2d79f"", ""filename"": ""include/linux/posix_acl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073931017b49d9458aa351605b43a7e34598caef/include/linux/posix_acl.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/posix_acl.h?ref=073931017b49d9458aa351605b43a7e34598caef"", ""patch"": ""@@ -93,6 +93,7 @@ extern int set_posix_acl(struct inode *, int, struct posix_acl *);\n extern int posix_acl_chmod(struct inode *, umode_t);\n extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,\n \t\tstruct posix_acl **);\n+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);\n \n extern int simple_set_acl(struct inode *, struct posix_acl *, int);\n extern int simple_acl_create(struct inode *, struct inode *);""}","xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	int error = 0;

	if (!acl)
		goto set_acl;

	error = -E2BIG;
	if (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))
 		return error;
 
 	if (type == ACL_TYPE_ACCESS) {
		umode_t mode;
 
		error = posix_acl_update_mode(inode, &mode, &acl);
		if (error)
			return error;
 		error = xfs_set_mode(inode, mode);
 		if (error)
 			return error;
	}

 set_acl:
	return __xfs_set_acl(inode, type, acl);
}
","xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	int error = 0;

	if (!acl)
		goto set_acl;

	error = -E2BIG;
	if (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))
 		return error;
 
 	if (type == ACL_TYPE_ACCESS) {
		umode_t mode = inode->i_mode;
		error = posix_acl_equiv_mode(acl, &mode);
		if (error <= 0) {
			acl = NULL;
			if (error < 0)
				return error;
		}
 
 		error = xfs_set_mode(inode, mode);
 		if (error)
 			return error;
	}

 set_acl:
	return __xfs_set_acl(inode, type, acl);
}
",C,"		umode_t mode;
		error = posix_acl_update_mode(inode, &mode, &acl);
		if (error)
			return error;
","		umode_t mode = inode->i_mode;
		error = posix_acl_equiv_mode(acl, &mode);
		if (error <= 0) {
			acl = NULL;
			if (error < 0)
				return error;
		}
",,"@@ -257,16 +257,11 @@ xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 		return error;
 
 	if (type == ACL_TYPE_ACCESS) {
-		umode_t mode = inode->i_mode;
-		error = posix_acl_equiv_mode(acl, &mode);
-
-		if (error <= 0) {
-			acl = NULL;
-
-			if (error < 0)
-				return error;
-		}
+		umode_t mode;
 
+		error = posix_acl_update_mode(inode, &mode, &acl);
+		if (error)
+			return error;
 		error = xfs_set_mode(inode, mode);
 		if (error)
 			return error;",linux,073931017b49d9458aa351605b43a7e34598caef,5d3ddd84eaefffd23c028bce5610dac8726f71c1,1,"xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
	int error = 0;

	if (!acl)
		goto set_acl;

	error = -E2BIG;
	if (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))
 		return error;
 
 	if (type == ACL_TYPE_ACCESS) {
//flaw_line_below:
		umode_t mode = inode->i_mode;
//flaw_line_below:
		error = posix_acl_equiv_mode(acl, &mode);
//flaw_line_below:

//flaw_line_below:
		if (error <= 0) {
//flaw_line_below:
			acl = NULL;
//flaw_line_below:

//flaw_line_below:
			if (error < 0)
//flaw_line_below:
				return error;
//flaw_line_below:
		}
//fix_flaw_line_below:
//		umode_t mode;
 
//fix_flaw_line_below:
//		error = posix_acl_update_mode(inode, &mode, &acl);
//fix_flaw_line_below:
//		if (error)
//fix_flaw_line_below:
//			return error;
 		error = xfs_set_mode(inode, mode);
 		if (error)
 			return error;
	}

 set_acl:
	return __xfs_set_acl(inode, type, acl);
}
"
4884,182620,,Local,Not required,Complete,CVE-2016-7035,https://www.cvedetails.com/cve/CVE-2016-7035/,CWE-285,Low,Complete,Complete,,2018-09-10,7.2,"An authorization flaw was found in Pacemaker before 1.1.16, where it did not properly guard its IPC interface. An attacker with an unprivileged account on a Pacemaker node could use this flaw to, for example, force the Local Resource Manager daemon to execute a script as root and thereby gain root access on the machine.",2019-10-09,+Priv ,3,https://github.com/ClusterLabs/pacemaker/commit/5d71e65049,5d71e65049,"High: libcrmcommon: fix CVE-2016-7035 (improper IPC guarding)

It was discovered that at some not so uncommon circumstances, some
pacemaker daemons could be talked to, via libqb-facilitated IPC, by
unprivileged clients due to flawed authorization decision.  Depending
on the capabilities of affected daemons, this might equip unauthorized
user with local privilege escalation or up to cluster-wide remote
execution of possibly arbitrary commands when such user happens to
reside at standard or remote/guest cluster node, respectively.

The original vulnerability was introduced in an attempt to allow
unprivileged IPC clients to clean up the file system materialized
leftovers in case the server (otherwise responsible for the lifecycle
of these files) crashes.  While the intended part of such behavior is
now effectively voided (along with the unintended one), a best-effort
fix to address this corner case systemically at libqb is coming along
(https://github.com/ClusterLabs/libqb/pull/231).

Affected versions:  1.1.10-rc1 (2013-04-17) - 1.1.15 (2016-06-21)
Impact:             Important
CVSSv3 ranking:     8.8 : AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H

Credits for independent findings, in chronological order:
  Jan ""poki"" Pokorn, of Red Hat
  Alain Moulle, of ATOS/BULL",9,lib/common/ipc.c,"{""sha"": ""2949837e3737874799d01745d59fde36235aefc6"", ""filename"": ""lib/common/ipc.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 11, ""changes"": 14, ""blob_url"": ""https://github.com/ClusterLabs/pacemaker/blob/5d71e65049d143435b03d6b3709d82900f32276f/lib/common/ipc.c"", ""raw_url"": ""https://github.com/ClusterLabs/pacemaker/raw/5d71e65049d143435b03d6b3709d82900f32276f/lib/common/ipc.c"", ""contents_url"": ""https://api.github.com/repos/ClusterLabs/pacemaker/contents/lib/common/ipc.c?ref=5d71e65049d143435b03d6b3709d82900f32276f"", ""patch"": ""@@ -293,7 +293,6 @@ crm_client_disconnect_all(qb_ipcs_service_t *service)\n crm_client_t *\n crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n {\n-    static uid_t uid_server = 0;\n     static gid_t gid_cluster = 0;\n \n     crm_client_t *client = NULL;\n@@ -304,7 +303,6 @@ crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n     }\n \n     if (gid_cluster == 0) {\n-        uid_server = getuid();\n         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {\n             static bool have_error = FALSE;\n             if(have_error == FALSE) {\n@@ -314,16 +312,10 @@ crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n         }\n     }\n \n-    if(gid_cluster != 0 && gid_client != 0) {\n-        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */\n-\n-        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */\n-            best_uid = QB_MAX(uid_client, uid_server);\n-            crm_trace(\""Allowing user %u to clean up after disconnect\"", best_uid);\n-        }\n-\n+    if (uid_client != 0) {\n         crm_trace(\""Giving access to group %u\"", gid_cluster);\n-        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n+        /* Passing -1 to chown(2) means don't change */\n+        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n     }\n \n     crm_client_init();""}"," crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
 {
     static gid_t gid_cluster = 0;
 
     crm_client_t *client = NULL;

    CRM_LOG_ASSERT(c);
    if (c == NULL) {
        return NULL;
     }
 
     if (gid_cluster == 0) {
         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {
             static bool have_error = FALSE;
             if(have_error == FALSE) {
                crm_warn(""Could not find group for user %s"", CRM_DAEMON_USER);
                have_error = TRUE;
            }
         }
     }
 
    if (uid_client != 0) {
         crm_trace(""Giving access to group %u"", gid_cluster);
        /* Passing -1 to chown(2) means don't change */
        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
     }
 
     crm_client_init();

    /* TODO: Do our own auth checking, return NULL if unauthorized */
    client = calloc(1, sizeof(crm_client_t));

    client->ipcs = c;
    client->kind = CRM_CLIENT_IPC;
    client->pid = crm_ipcs_client_pid(c);

    client->id = crm_generate_uuid();

    crm_debug(""Connecting %p for uid=%d gid=%d pid=%u id=%s"", c, uid_client, gid_client, client->pid, client->id);

#if ENABLE_ACL
    client->user = uid2username(uid_client);
#endif

    g_hash_table_insert(client_connections, c, client);
    return client;
}
"," crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
 {
    static uid_t uid_server = 0;
     static gid_t gid_cluster = 0;
 
     crm_client_t *client = NULL;

    CRM_LOG_ASSERT(c);
    if (c == NULL) {
        return NULL;
     }
 
     if (gid_cluster == 0) {
        uid_server = getuid();
         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {
             static bool have_error = FALSE;
             if(have_error == FALSE) {
                crm_warn(""Could not find group for user %s"", CRM_DAEMON_USER);
                have_error = TRUE;
            }
         }
     }
 
    if(gid_cluster != 0 && gid_client != 0) {
        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */
        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */
            best_uid = QB_MAX(uid_client, uid_server);
            crm_trace(""Allowing user %u to clean up after disconnect"", best_uid);
        }
         crm_trace(""Giving access to group %u"", gid_cluster);
        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
     }
 
     crm_client_init();

    /* TODO: Do our own auth checking, return NULL if unauthorized */
    client = calloc(1, sizeof(crm_client_t));

    client->ipcs = c;
    client->kind = CRM_CLIENT_IPC;
    client->pid = crm_ipcs_client_pid(c);

    client->id = crm_generate_uuid();

    crm_debug(""Connecting %p for uid=%d gid=%d pid=%u id=%s"", c, uid_client, gid_client, client->pid, client->id);

#if ENABLE_ACL
    client->user = uid2username(uid_client);
#endif

    g_hash_table_insert(client_connections, c, client);
    return client;
}
",C,"    if (uid_client != 0) {
        /* Passing -1 to chown(2) means don't change */
        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
","    static uid_t uid_server = 0;
        uid_server = getuid();
    if(gid_cluster != 0 && gid_client != 0) {
        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */
        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */
            best_uid = QB_MAX(uid_client, uid_server);
            crm_trace(""Allowing user %u to clean up after disconnect"", best_uid);
        }
        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
",,"@@ -293,7 +293,6 @@ crm_client_disconnect_all(qb_ipcs_service_t *service)
 crm_client_t *
 crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
 {
-    static uid_t uid_server = 0;
     static gid_t gid_cluster = 0;
 
     crm_client_t *client = NULL;
@@ -304,7 +303,6 @@ crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
     }
 
     if (gid_cluster == 0) {
-        uid_server = getuid();
         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {
             static bool have_error = FALSE;
             if(have_error == FALSE) {
@@ -314,16 +312,10 @@ crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
         }
     }
 
-    if(gid_cluster != 0 && gid_client != 0) {
-        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */
-
-        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */
-            best_uid = QB_MAX(uid_client, uid_server);
-            crm_trace(""Allowing user %u to clean up after disconnect"", best_uid);
-        }
-
+    if (uid_client != 0) {
         crm_trace(""Giving access to group %u"", gid_cluster);
-        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
+        /* Passing -1 to chown(2) means don't change */
+        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
     }
 
     crm_client_init();",pacemaker,5d71e65049,23f8e91a3ee1f9b4d55a50274ee932895dc2d355,1," crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
 {
//flaw_line_below:
    static uid_t uid_server = 0;
     static gid_t gid_cluster = 0;
 
     crm_client_t *client = NULL;

    CRM_LOG_ASSERT(c);
    if (c == NULL) {
        return NULL;
     }
 
     if (gid_cluster == 0) {
//flaw_line_below:
        uid_server = getuid();
         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {
             static bool have_error = FALSE;
             if(have_error == FALSE) {
                crm_warn(""Could not find group for user %s"", CRM_DAEMON_USER);
                have_error = TRUE;
            }
         }
     }
 
//flaw_line_below:
    if(gid_cluster != 0 && gid_client != 0) {
//flaw_line_below:
        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */
//flaw_line_below:

//flaw_line_below:
        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */
//flaw_line_below:
            best_uid = QB_MAX(uid_client, uid_server);
//flaw_line_below:
            crm_trace(""Allowing user %u to clean up after disconnect"", best_uid);
//flaw_line_below:
        }
//flaw_line_below:

//fix_flaw_line_below:
//    if (uid_client != 0) {
         crm_trace(""Giving access to group %u"", gid_cluster);
//flaw_line_below:
        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
//fix_flaw_line_below:
//        /* Passing -1 to chown(2) means don't change */
//fix_flaw_line_below:
//        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
     }
 
     crm_client_init();

    /* TODO: Do our own auth checking, return NULL if unauthorized */
    client = calloc(1, sizeof(crm_client_t));

    client->ipcs = c;
    client->kind = CRM_CLIENT_IPC;
    client->pid = crm_ipcs_client_pid(c);

    client->id = crm_generate_uuid();

    crm_debug(""Connecting %p for uid=%d gid=%d pid=%u id=%s"", c, uid_client, gid_client, client->pid, client->id);

#if ENABLE_ACL
    client->user = uid2username(uid_client);
#endif

    g_hash_table_insert(client_connections, c, client);
    return client;
}
"
9435,187171,,Remote,Not required,,CVE-2018-16073,https://www.cvedetails.com/cve/CVE-2018-16073/,CWE-285,Medium,Partial,,,2019-06-27,4.3,Insufficient policy enforcement in site isolation in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass site isolation via a crafted HTML page.,2019-07-01,Bypass ,17,https://github.com/chromium/chromium/commit/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca,0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca,"Use unique processes for data URLs on restore.

Data URLs are usually put into the process that created them, but this
info is not tracked after a tab restore.  Ensure that they do not end up
in the parent frame's process (or each other's process), in case they
are malicious.

BUG=863069

Change-Id: Ib391f90c7bdf28a0a9c057c5cc7918c10aed968b
Reviewed-on: https://chromium-review.googlesource.com/1150767
Reviewed-by: Alex Moshchuk <alexmos@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Commit-Queue: Charlie Reis <creis@chromium.org>
Cr-Commit-Position: refs/heads/master@{#581023}",1,chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc,"{""sha"": ""53bcd4ac40273b55e101c55172ad64938fb52f0f"", ""filename"": ""chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 13, ""changes"": 37, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -32,6 +32,7 @@\n #include \""content/public/browser/web_contents_observer.h\""\n #include \""content/public/common/content_switches.h\""\n #include \""content/public/test/browser_test_utils.h\""\n+#include \""content/public/test/test_utils.h\""\n #include \""media/base/media_switches.h\""\n #include \""net/base/filename_util.h\""\n #include \""net/test/embedded_test_server/embedded_test_server.h\""\n@@ -155,7 +156,7 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {\n     const extensions::Extension* extension =\n         LoadExtension(test_data_dir_.AppendASCII(\""options_page\""));\n \n-    // Change the first tab to be the omnibox page (TYPE_WEBUI).\n+    // Change the first tab to be the omnibox page (WebUI).\n     GURL omnibox(chrome::kChromeUIOmniboxURL);\n     ui_test_utils::NavigateToURL(browser(), omnibox);\n     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n@@ -164,7 +165,7 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {\n     EXPECT_EQ(omnibox, tab1->GetURL());\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n \n-    // Create a new TYPE_TABBED tab.  It should be in its own process.\n+    // Create a new normal tab with a data URL. It should be in its own process.\n     GURL page1(\""data:text/html,hello world1\"");\n \n     ui_test_utils::WindowedTabAddedNotificationObserver observer1(\n@@ -181,23 +182,30 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n     EXPECT_NE(rph1, rph2);\n \n-    // Create another TYPE_TABBED tab.  It should share the previous process.\n+    // Create another data URL tab.  With Site Isolation, this will require its\n+    // own process, but without Site Isolation, it can share the previous\n+    // process.\n     GURL page2(\""data:text/html,hello world2\"");\n     ui_test_utils::WindowedTabAddedNotificationObserver observer2(\n         content::NotificationService::AllSources());\n     ::ShowSingletonTab(browser(), page2);\n     observer2.Wait();\n     tab_count++;\n+    if (content::AreAllSitesIsolatedForTesting())\n+      host_count++;\n     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n     tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);\n     EXPECT_EQ(tab2->GetURL(), page2);\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n-    EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);\n-\n-    // Create another TYPE_WEBUI tab.  It should share the process with omnibox.\n-    // Note: intentionally create this tab after the TYPE_TABBED tabs to\n-    // exercise bug 43448 where extension and WebUI tabs could get combined into\n-    // normal renderers.\n+    if (content::AreAllSitesIsolatedForTesting())\n+      EXPECT_NE(tab2->GetMainFrame()->GetProcess(), rph2);\n+    else\n+      EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);\n+\n+    // Create another WebUI tab.  It should share the process with omnibox.\n+    // Note: intentionally create this tab after the normal tabs to exercise bug\n+    // 43448 where extension and WebUI tabs could get combined into normal\n+    // renderers.\n     GURL history(chrome::kChromeUIHistoryURL);\n     ui_test_utils::WindowedTabAddedNotificationObserver observer3(\n         content::NotificationService::AllSources());\n@@ -210,7 +218,7 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n     EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph1);\n \n-    // Create a TYPE_EXTENSION tab.  It should be in its own process.\n+    // Create an extension tab.  It should be in its own process.\n     GURL extension_url(\""chrome-extension://\"" + extension->id());\n     ui_test_utils::WindowedTabAddedNotificationObserver observer4(\n         content::NotificationService::AllSources());\n@@ -256,13 +264,13 @@ IN_PROC_BROWSER_TEST_F(ChromeRenderProcessHostTest, MAYBE_ProcessPerTab) {\n   int tab_count = 1;\n   int host_count = 1;\n \n-  // Change the first tab to be the new tab page (TYPE_WEBUI).\n+  // Change the first tab to be a WebUI page.\n   GURL omnibox(chrome::kChromeUIOmniboxURL);\n   ui_test_utils::NavigateToURL(browser(), omnibox);\n   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n   EXPECT_EQ(host_count, RenderProcessHostCount());\n \n-  // Create a new TYPE_TABBED tab.  It should be in its own process.\n+  // Create a new normal tab with a data URL.  It should be in its own process.\n   GURL page1(\""data:text/html,hello world1\"");\n   ui_test_utils::WindowedTabAddedNotificationObserver observer1(\n       content::NotificationService::AllSources());\n@@ -273,13 +281,16 @@ IN_PROC_BROWSER_TEST_F(ChromeRenderProcessHostTest, MAYBE_ProcessPerTab) {\n   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n   EXPECT_EQ(host_count, RenderProcessHostCount());\n \n-  // Create another TYPE_TABBED tab.  It should share the previous process.\n+  // Create another data URL tab.  With Site Isolation, this will require its\n+  // own process, but without Site Isolation, it can share the previous process.\n   GURL page2(\""data:text/html,hello world2\"");\n   ui_test_utils::WindowedTabAddedNotificationObserver observer2(\n       content::NotificationService::AllSources());\n   ::ShowSingletonTab(browser(), page2);\n   observer2.Wait();\n   tab_count++;\n+  if (content::AreAllSitesIsolatedForTesting())\n+    host_count++;\n   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n   EXPECT_EQ(host_count, RenderProcessHostCount());\n ""}<_**next**_>{""sha"": ""406302b6b76051ba0995f92ec9dc579dfe14f707"", ""filename"": ""content/browser/frame_host/render_frame_host_manager.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 15, ""changes"": 32, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/frame_host/render_frame_host_manager.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/frame_host/render_frame_host_manager.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_manager.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -1971,7 +1971,7 @@ RenderFrameHostManager::GetSiteInstanceForNavigationRequest(\n     // allowed to swap processes.\n     no_renderer_swap_allowed |= !CanSubframeSwapProcess(\n         request.common_params().url, request.source_site_instance(),\n-        request.dest_site_instance(), was_server_redirect);\n+        request.dest_site_instance());\n   }\n \n   if (no_renderer_swap_allowed)\n@@ -2543,8 +2543,7 @@ void RenderFrameHostManager::SendPageMessage(IPC::Message* msg,\n bool RenderFrameHostManager::CanSubframeSwapProcess(\n     const GURL& dest_url,\n     SiteInstance* source_instance,\n-    SiteInstance* dest_instance,\n-    bool was_server_redirect) {\n+    SiteInstance* dest_instance) {\n   // On renderer-initiated navigations, when the frame initiating the navigation\n   // and the frame being navigated differ, |source_instance| is set to the\n   // SiteInstance of the initiating frame. |dest_instance| is present on session\n@@ -2561,22 +2560,25 @@ bool RenderFrameHostManager::CanSubframeSwapProcess(\n       resolved_url = dest_instance->GetSiteURL();\n     } else {\n       // If there is no SiteInstance this unique origin can be associated with,\n-      // there are two cases:\n-      // (1) If there was a server redirect, allow a process swap.  Normally,\n-      // redirects to data: or about: URLs are disallowed as\n+      // then check whether it is safe to put into the parent frame's process.\n+      // This is the case for about:blank URLs (with or without fragments),\n+      // since they contain no active data.  This is also the case for\n+      // about:srcdoc, since such URLs only get active content from their parent\n+      // frame.  Using the parent frame's process avoids putting blank frames\n+      // into OOPIFs and preserves scripting for about:srcdoc.\n+      //\n+      // Allow a process swap for other unique origin URLs, such as data: URLs.\n+      // These have active content and may have come from an untrusted source,\n+      // such as a restored frame from a different site or a redirect.\n+      // (Normally, redirects to data: or about: URLs are disallowed as\n       // net::ERR_UNSAFE_REDIRECT. However, extensions can still redirect\n       // arbitary requests to those URLs using the chrome.webRequest or\n       // chrome.declarativeWebRequest API, which will end up here (for an\n-      // example, see ExtensionWebRequestApiTest.WebRequestDeclarative1).  It's\n-      // safest to swap processes for those redirects if we are in an\n-      // appropriate OOPIF-enabled mode.\n-      //\n-      // (2) Otherwise, avoid a process swap.  We can get here during session\n-      // restore, and this avoids putting all data: and about:blank subframes\n-      // in OOPIFs. We can also get here in tests with browser-initiated\n-      // subframe navigations (NavigateFrameToURL).\n-      if (!was_server_redirect)\n+      // example, see ExtensionWebRequestApiTest.WebRequestDeclarative1).)\n+      if (resolved_url.IsAboutBlank() ||\n+          resolved_url == GURL(content::kAboutSrcDocURL)) {\n         return false;\n+      }\n     }\n   }\n ""}<_**next**_>{""sha"": ""d8cf377f4e2e812080e3b65e324272f2da04270c"", ""filename"": ""content/browser/frame_host/render_frame_host_manager.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/frame_host/render_frame_host_manager.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/frame_host/render_frame_host_manager.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_manager.h?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -730,8 +730,7 @@ class CONTENT_EXPORT RenderFrameHostManager\n   // Returns true if a subframe can navigate cross-process.\n   bool CanSubframeSwapProcess(const GURL& dest_url,\n                               SiteInstance* source_instance,\n-                              SiteInstance* dest_instance,\n-                              bool was_server_redirect);\n+                              SiteInstance* dest_instance);\n \n   // After a renderer process crash we'd have marked the host as invisible, so\n   // we need to set the visibility of the new View to the correct value here""}<_**next**_>{""sha"": ""4385285e7ce5b3dc21203bf84cb686d580d7d04a"", ""filename"": ""content/browser/site_instance_impl.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 6, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_instance_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_instance_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_instance_impl.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -457,16 +457,27 @@ GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,\n     return GURL(origin.scheme() + \"":\"");\n   } else if (url.has_scheme()) {\n     // In some cases, it is not safe to use just the scheme as a site URL, as\n-    // that might allow two URLs created by different sites to to share a\n-    // process.  See https://crbug.com/863623.\n+    // that might allow two URLs created by different sites to share a process.\n+    // See https://crbug.com/863623 and https://crbug.com/863069.\n     //\n     // TODO(alexmos,creis): This should eventually be expanded to certain other\n-    // schemes, such as data: and file:.\n-    if (url.SchemeIsBlob()) {\n+    // schemes, such as file:.\n+    // TODO(creis): This currently causes problems with tests on Android and\n+    // Android WebView.  For now, skip it when Site Isolation is not enabled,\n+    // since there's no need to isolate data and blob URLs from each other in\n+    // that case.\n+    bool is_site_isolation_enabled =\n+        SiteIsolationPolicy::UseDedicatedProcessesForAllSites() ||\n+        SiteIsolationPolicy::AreIsolatedOriginsEnabled();\n+    if (is_site_isolation_enabled &&\n+        (url.SchemeIsBlob() || url.scheme() == url::kDataScheme)) {\n       // We get here for blob URLs of form blob:null/guid.  Use the full URL\n       // with the guid in that case, which isolates all blob URLs with unique\n-      // origins from each other.  Remove hash from the URL, since\n-      // same-document navigations shouldn't use a different site URL.\n+      // origins from each other.  We also get here for browser-initiated\n+      // navigations to data URLs, which have a unique origin and should only\n+      // share a process when they are identical.  Remove hash from the URL in\n+      // either case, since same-document navigations shouldn't use a different\n+      // site URL.\n       if (url.has_ref()) {\n         GURL::Replacements replacements;\n         replacements.ClearRef();""}<_**next**_>{""sha"": ""66159134d65a635172ee4b476d83e43fc6cb0656"", ""filename"": ""content/browser/site_instance_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 7, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_instance_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_instance_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_instance_impl_unittest.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -316,12 +316,25 @@ TEST_F(SiteInstanceTest, GetSiteForURL) {\n   EXPECT_EQ(\""file\"", site_url.scheme());\n   EXPECT_FALSE(site_url.has_host());\n \n-  // Data URLs should include the scheme.\n+  // Data URLs should include the whole URL, except for the hash, when Site\n+  // Isolation is enabled.  Otherwise they just include the scheme.\n   test_url = GURL(\""data:text/html,foo\"");\n   site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n-  EXPECT_EQ(GURL(\""data:\""), site_url);\n+  if (AreAllSitesIsolatedForTesting())\n+    EXPECT_EQ(test_url, site_url);\n+  else\n+    EXPECT_EQ(GURL(\""data:\""), site_url);\n   EXPECT_EQ(\""data\"", site_url.scheme());\n   EXPECT_FALSE(site_url.has_host());\n+  test_url = GURL(\""data:text/html,foo#bar\"");\n+  site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n+  EXPECT_FALSE(site_url.has_ref());\n+  if (AreAllSitesIsolatedForTesting()) {\n+    EXPECT_NE(test_url, site_url);\n+    EXPECT_TRUE(site_url.EqualsIgnoringRef(test_url));\n+  } else {\n+    EXPECT_EQ(GURL(\""data:\""), site_url);\n+  }\n \n   // Javascript URLs should include the scheme.\n   test_url = GURL(\""javascript:foo();\"");\n@@ -344,16 +357,24 @@ TEST_F(SiteInstanceTest, GetSiteForURL) {\n   EXPECT_EQ(\""file\"", site_url.scheme());\n   EXPECT_FALSE(site_url.has_host());\n \n-  // Blob URLs created from a unique origin use the full URL as the site URL,\n-  // except for the hash.\n+  // Blob URLs created from a unique origin use the full URL as the site URL\n+  // when Site Isolation is enabled, except for the hash.  Otherwise they just\n+  // include the scheme.\n   test_url = GURL(\""blob:null/1029e5a4-2983-4b90-a585-ed217563acfeb\"");\n   site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n-  EXPECT_EQ(site_url, test_url);\n+  if (AreAllSitesIsolatedForTesting())\n+    EXPECT_EQ(test_url, site_url);\n+  else\n+    EXPECT_EQ(GURL(\""blob:\""), site_url);\n   test_url = GURL(\""blob:null/1029e5a4-2983-4b90-a585-ed217563acfeb#foo\"");\n   site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n-  EXPECT_NE(site_url, test_url);\n   EXPECT_FALSE(site_url.has_ref());\n-  EXPECT_TRUE(site_url.EqualsIgnoringRef(test_url));\n+  if (AreAllSitesIsolatedForTesting()) {\n+    EXPECT_NE(test_url, site_url);\n+    EXPECT_TRUE(site_url.EqualsIgnoringRef(test_url));\n+  } else {\n+    EXPECT_EQ(GURL(\""blob:\""), site_url);\n+  }\n \n   // Private domains are preserved, appspot being such a site.\n   test_url = GURL(""}<_**next**_>{""sha"": ""26dbd2cdf254fb8c0d6fa5606165f7128afacb92"", ""filename"": ""content/browser/site_per_process_browsertest.cc"", ""status"": ""modified"", ""additions"": 283, ""deletions"": 3, ""changes"": 286, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_per_process_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_per_process_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_per_process_browsertest.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -7289,8 +7289,8 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n }\n \n // Ensures that navigating to data: URLs present in session history will\n-// correctly commit the navigation in the same process as the parent frame.\n-// See https://crbug.com/606996.\n+// correctly commit the navigation in the same process as the one used for the\n+// original navigation. See https://crbug.com/606996.\n IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n                        NavigateSubframeToDataUrlInSessionHistory) {\n   GURL main_url(embedded_test_server()->GetURL(\n@@ -7316,7 +7316,7 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n   EXPECT_TRUE(observer.last_navigation_succeeded());\n   EXPECT_EQ(data_url, observer.last_navigation_url());\n   scoped_refptr<SiteInstanceImpl> orig_site_instance =\n-    child->current_frame_host()->GetSiteInstance();\n+      child->current_frame_host()->GetSiteInstance();\n   EXPECT_NE(root->current_frame_host()->GetSiteInstance(), orig_site_instance);\n \n   // Navigate it to another cross-site url.\n@@ -7336,6 +7336,286 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n   EXPECT_EQ(orig_site_instance, child->current_frame_host()->GetSiteInstance());\n }\n \n+// Ensures that subframes navigated to data: URLs start in a process based on\n+// their creator, but end up in unique processes after a restore (since\n+// SiteInstance relationships are not preserved on restore, until\n+// https://crbug.com/14987 is fixed).  This is better than restoring into the\n+// parent process, per https://crbug.com/863069.\n+IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n+                       SubframeDataUrlsAfterRestore) {\n+  // We must use a page that has iframes in the HTML here, unlike\n+  // cross_site_iframe_factory.html which loads them dynamically.  In the latter\n+  // case, Chrome will not restore subframe URLs from history, which is needed\n+  // for this test.\n+  GURL main_url(embedded_test_server()->GetURL(\n+      \""a.com\"", \""/frame_tree/page_with_two_iframes.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+\n+  FrameTreeNode* root = web_contents()->GetFrameTree()->root();\n+  EXPECT_EQ(2U, root->child_count());\n+  EXPECT_EQ(\n+      \"" Site A ------------ proxies for B C\\n\""\n+      \""   |--Site B ------- proxies for A C\\n\""\n+      \""   +--Site C ------- proxies for A B\\n\""\n+      \""Where A = http://a.com/\\n\""\n+      \""      B = http://bar.com/\\n\""\n+      \""      C = http://baz.com/\"",\n+      DepictFrameTree(root));\n+\n+  FrameTreeNode* child_0 = root->child_at(0);\n+  FrameTreeNode* child_1 = root->child_at(1);\n+  scoped_refptr<SiteInstanceImpl> child_site_instance_0 =\n+      child_0->current_frame_host()->GetSiteInstance();\n+  scoped_refptr<SiteInstanceImpl> child_site_instance_1 =\n+      child_1->current_frame_host()->GetSiteInstance();\n+\n+  // Navigate the iframes to data URLs via renderer initiated navigations, which\n+  // will commit in the existing SiteInstances.\n+  TestNavigationObserver observer(shell()->web_contents());\n+  GURL data_url_0(\""data:text/html,dataurl_0\"");\n+  {\n+    TestFrameNavigationObserver commit_observer(child_0);\n+    EXPECT_TRUE(\n+        ExecuteScript(child_0, \""location.href = '\"" + data_url_0.spec() + \""';\""));\n+    commit_observer.WaitForCommit();\n+  }\n+  EXPECT_TRUE(observer.last_navigation_succeeded());\n+  EXPECT_EQ(data_url_0, observer.last_navigation_url());\n+  EXPECT_EQ(child_site_instance_0,\n+            child_0->current_frame_host()->GetSiteInstance());\n+\n+  GURL data_url_1(\""data:text/html,dataurl_1\"");\n+  {\n+    TestFrameNavigationObserver commit_observer(child_1);\n+    EXPECT_TRUE(\n+        ExecuteScript(child_1, \""location.href = '\"" + data_url_1.spec() + \""';\""));\n+    commit_observer.WaitForCommit();\n+  }\n+  EXPECT_TRUE(observer.last_navigation_succeeded());\n+  EXPECT_EQ(data_url_1, observer.last_navigation_url());\n+  EXPECT_EQ(child_site_instance_1,\n+            child_1->current_frame_host()->GetSiteInstance());\n+\n+  // Grab the NavigationEntry and clone its PageState into a new entry for\n+  // restoring into a new tab.\n+  const NavigationControllerImpl& controller =\n+      static_cast<const NavigationControllerImpl&>(\n+          shell()->web_contents()->GetController());\n+  NavigationEntryImpl* entry = controller.GetLastCommittedEntry();\n+  std::unique_ptr<NavigationEntryImpl> restored_entry =\n+      NavigationEntryImpl::FromNavigationEntry(\n+          NavigationController::CreateNavigationEntry(\n+              main_url, Referrer(), ui::PAGE_TRANSITION_RELOAD, false,\n+              std::string(), controller.GetBrowserContext(),\n+              nullptr /* blob_url_loader_factory */));\n+  EXPECT_EQ(0U, restored_entry->root_node()->children.size());\n+  restored_entry->SetPageState(entry->GetPageState());\n+  ASSERT_EQ(2U, restored_entry->root_node()->children.size());\n+\n+  // Restore the NavigationEntry into a new tab and check that the data URLs are\n+  // not loaded into the parent's SiteInstance.\n+  std::vector<std::unique_ptr<NavigationEntry>> entries;\n+  entries.push_back(std::move(restored_entry));\n+  Shell* new_shell = Shell::CreateNewWindow(\n+      controller.GetBrowserContext(), GURL::EmptyGURL(), nullptr, gfx::Size());\n+  FrameTreeNode* new_root =\n+      static_cast<WebContentsImpl*>(new_shell->web_contents())\n+          ->GetFrameTree()\n+          ->root();\n+  NavigationControllerImpl& new_controller =\n+      static_cast<NavigationControllerImpl&>(\n+          new_shell->web_contents()->GetController());\n+  new_controller.Restore(entries.size() - 1,\n+                         RestoreType::LAST_SESSION_EXITED_CLEANLY, &entries);\n+  ASSERT_EQ(0u, entries.size());\n+  {\n+    TestNavigationObserver restore_observer(new_shell->web_contents());\n+    new_controller.LoadIfNecessary();\n+    restore_observer.Wait();\n+  }\n+  ASSERT_EQ(2U, new_root->child_count());\n+  EXPECT_EQ(main_url, new_root->current_url());\n+  EXPECT_EQ(\""data\"", new_root->child_at(0)->current_url().scheme());\n+  EXPECT_EQ(\""data\"", new_root->child_at(1)->current_url().scheme());\n+\n+  EXPECT_NE(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(0)->current_frame_host()->GetSiteInstance());\n+  EXPECT_NE(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(1)->current_frame_host()->GetSiteInstance());\n+  EXPECT_NE(new_root->child_at(0)->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(1)->current_frame_host()->GetSiteInstance());\n+}\n+\n+// Similar to SubframeDataUrlsAfterRestore, but ensures that about:blank frames\n+// do get put into their parent process after restore, even if they weren't\n+// originally.  This is safe because they do not contain active content (even\n+// when there's a fragment in the URL), and it avoids unnecessary OOPIFs.\n+IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n+                       SubframeBlankUrlsAfterRestore) {\n+  // We must use a page that has iframes in the HTML here, unlike\n+  // cross_site_iframe_factory.html which loads them dynamically.  In the latter\n+  // case, Chrome will not restore subframe URLs from history, which is needed\n+  // for this test.\n+  GURL main_url(embedded_test_server()->GetURL(\n+      \""a.com\"", \""/frame_tree/page_with_two_iframes.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+\n+  FrameTreeNode* root = web_contents()->GetFrameTree()->root();\n+  EXPECT_EQ(2U, root->child_count());\n+  EXPECT_EQ(\n+      \"" Site A ------------ proxies for B C\\n\""\n+      \""   |--Site B ------- proxies for A C\\n\""\n+      \""   +--Site C ------- proxies for A B\\n\""\n+      \""Where A = http://a.com/\\n\""\n+      \""      B = http://bar.com/\\n\""\n+      \""      C = http://baz.com/\"",\n+      DepictFrameTree(root));\n+\n+  FrameTreeNode* child_0 = root->child_at(0);\n+  FrameTreeNode* child_1 = root->child_at(1);\n+  scoped_refptr<SiteInstanceImpl> child_site_instance_0 =\n+      child_0->current_frame_host()->GetSiteInstance();\n+  scoped_refptr<SiteInstanceImpl> child_site_instance_1 =\n+      child_1->current_frame_host()->GetSiteInstance();\n+\n+  // Navigate the iframes to about:blank URLs via renderer initiated\n+  // navigations, which will commit in the existing SiteInstances.\n+  TestNavigationObserver observer(shell()->web_contents());\n+  GURL blank_url(\""about:blank\"");\n+  {\n+    TestFrameNavigationObserver commit_observer(child_0);\n+    EXPECT_TRUE(\n+        ExecuteScript(child_0, \""location.href = '\"" + blank_url.spec() + \""';\""));\n+    commit_observer.WaitForCommit();\n+  }\n+  EXPECT_TRUE(observer.last_navigation_succeeded());\n+  EXPECT_EQ(blank_url, observer.last_navigation_url());\n+  EXPECT_EQ(child_site_instance_0,\n+            child_0->current_frame_host()->GetSiteInstance());\n+\n+  GURL blank_url_ref(\""about:blank#1\"");\n+  {\n+    TestFrameNavigationObserver commit_observer(child_1);\n+    EXPECT_TRUE(ExecuteScript(\n+        child_1, \""location.href = '\"" + blank_url_ref.spec() + \""';\""));\n+    commit_observer.WaitForCommit();\n+  }\n+  EXPECT_TRUE(observer.last_navigation_succeeded());\n+  EXPECT_EQ(blank_url_ref, observer.last_navigation_url());\n+  EXPECT_EQ(child_site_instance_1,\n+            child_1->current_frame_host()->GetSiteInstance());\n+\n+  // Grab the NavigationEntry and clone its PageState into a new entry for\n+  // restoring into a new tab.\n+  const NavigationControllerImpl& controller =\n+      static_cast<const NavigationControllerImpl&>(\n+          shell()->web_contents()->GetController());\n+  NavigationEntryImpl* entry = controller.GetLastCommittedEntry();\n+  std::unique_ptr<NavigationEntryImpl> restored_entry =\n+      NavigationEntryImpl::FromNavigationEntry(\n+          NavigationController::CreateNavigationEntry(\n+              main_url, Referrer(), ui::PAGE_TRANSITION_RELOAD, false,\n+              std::string(), controller.GetBrowserContext(),\n+              nullptr /* blob_url_loader_factory */));\n+  EXPECT_EQ(0U, restored_entry->root_node()->children.size());\n+  restored_entry->SetPageState(entry->GetPageState());\n+  ASSERT_EQ(2U, restored_entry->root_node()->children.size());\n+\n+  // Restore the NavigationEntry into a new tab and check that the data URLs are\n+  // not loaded into the parent's SiteInstance.\n+  std::vector<std::unique_ptr<NavigationEntry>> entries;\n+  entries.push_back(std::move(restored_entry));\n+  Shell* new_shell = Shell::CreateNewWindow(\n+      controller.GetBrowserContext(), GURL::EmptyGURL(), nullptr, gfx::Size());\n+  FrameTreeNode* new_root =\n+      static_cast<WebContentsImpl*>(new_shell->web_contents())\n+          ->GetFrameTree()\n+          ->root();\n+  NavigationControllerImpl& new_controller =\n+      static_cast<NavigationControllerImpl&>(\n+          new_shell->web_contents()->GetController());\n+  new_controller.Restore(entries.size() - 1,\n+                         RestoreType::LAST_SESSION_EXITED_CLEANLY, &entries);\n+  ASSERT_EQ(0u, entries.size());\n+  {\n+    TestNavigationObserver restore_observer(new_shell->web_contents());\n+    new_controller.LoadIfNecessary();\n+    restore_observer.Wait();\n+  }\n+  ASSERT_EQ(2U, new_root->child_count());\n+  EXPECT_EQ(main_url, new_root->current_url());\n+  EXPECT_TRUE(new_root->child_at(0)->current_url().IsAboutBlank());\n+  EXPECT_TRUE(new_root->child_at(1)->current_url().IsAboutBlank());\n+\n+  EXPECT_EQ(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(0)->current_frame_host()->GetSiteInstance());\n+  EXPECT_EQ(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(1)->current_frame_host()->GetSiteInstance());\n+}\n+\n+// Similar to SubframeBlankUrlsAfterRestore, but ensures that about:srcdoc ends\n+// up in its parent's process after restore, since that's where its content\n+// comes from.\n+IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n+                       SubframeSrcdocUrlAfterRestore) {\n+  // Load a page that uses iframe srcdoc.\n+  GURL main_url(embedded_test_server()->GetURL(\n+      \""a.com\"", \""/frame_tree/page_with_srcdoc_frame.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+\n+  FrameTreeNode* root = web_contents()->GetFrameTree()->root();\n+  EXPECT_EQ(1U, root->child_count());\n+  FrameTreeNode* child = root->child_at(0);\n+  scoped_refptr<SiteInstanceImpl> child_site_instance =\n+      child->current_frame_host()->GetSiteInstance();\n+  EXPECT_EQ(child_site_instance, root->current_frame_host()->GetSiteInstance());\n+\n+  // Grab the NavigationEntry and clone its PageState into a new entry for\n+  // restoring into a new tab.\n+  const NavigationControllerImpl& controller =\n+      static_cast<const NavigationControllerImpl&>(\n+          shell()->web_contents()->GetController());\n+  NavigationEntryImpl* entry = controller.GetLastCommittedEntry();\n+  std::unique_ptr<NavigationEntryImpl> restored_entry =\n+      NavigationEntryImpl::FromNavigationEntry(\n+          NavigationController::CreateNavigationEntry(\n+              main_url, Referrer(), ui::PAGE_TRANSITION_RELOAD, false,\n+              std::string(), controller.GetBrowserContext(),\n+              nullptr /* blob_url_loader_factory */));\n+  EXPECT_EQ(0U, restored_entry->root_node()->children.size());\n+  restored_entry->SetPageState(entry->GetPageState());\n+  ASSERT_EQ(1U, restored_entry->root_node()->children.size());\n+\n+  // Restore the NavigationEntry into a new tab and check that the srcdoc URLs\n+  // are still loaded into the parent's SiteInstance.\n+  std::vector<std::unique_ptr<NavigationEntry>> entries;\n+  entries.push_back(std::move(restored_entry));\n+  Shell* new_shell = Shell::CreateNewWindow(\n+      controller.GetBrowserContext(), GURL::EmptyGURL(), nullptr, gfx::Size());\n+  FrameTreeNode* new_root =\n+      static_cast<WebContentsImpl*>(new_shell->web_contents())\n+          ->GetFrameTree()\n+          ->root();\n+  NavigationControllerImpl& new_controller =\n+      static_cast<NavigationControllerImpl&>(\n+          new_shell->web_contents()->GetController());\n+  new_controller.Restore(entries.size() - 1,\n+                         RestoreType::LAST_SESSION_EXITED_CLEANLY, &entries);\n+  ASSERT_EQ(0u, entries.size());\n+  {\n+    TestNavigationObserver restore_observer(new_shell->web_contents());\n+    new_controller.LoadIfNecessary();\n+    restore_observer.Wait();\n+  }\n+  ASSERT_EQ(1U, new_root->child_count());\n+  EXPECT_EQ(main_url, new_root->current_url());\n+  EXPECT_EQ(GURL(content::kAboutSrcDocURL),\n+            new_root->child_at(0)->current_url());\n+\n+  EXPECT_EQ(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(0)->current_frame_host()->GetSiteInstance());\n+}\n+\n // Ensures that navigating to about:blank URLs present in session history will\n // correctly commit the navigation in the same process as the one used for\n // the original navigation.""}<_**next**_>{""sha"": ""a5bce3fd2565d8f458555a0c6f42d0504a848bd5"", ""filename"": ""third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-1.html"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-1.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-1.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-1.html?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -0,0 +1 @@\n+test1""}<_**next**_>{""sha"": ""180cf8328022becee9aaa2577a8f84ea2b9f3827"", ""filename"": ""third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-2.html"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-2.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-2.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-2.html?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -0,0 +1 @@\n+test2""}<_**next**_>{""sha"": ""b8ae010756f6d0452c849c17607ab4bd3f11670b"", ""filename"": ""third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child.html"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child.html?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -1,9 +1,10 @@\n <p>This tests that navigating to two pages in a subframe, and then going back does not cause an assertion.</p>\n <p>SUCCESS - Didn't assert!</p>\n <script>\n+\n if (window.testRunner) {\n-    testRunner.queueLoad('data:text/html,test1', 'target')\n-    testRunner.queueLoad('data:text/html,test2', 'target')\n+    testRunner.queueLoad('resources/frame-navigation-child-1.html', 'target')\n+    testRunner.queueLoad('resources/frame-navigation-child-2.html', 'target')\n     testRunner.queueBackNavigation(1);\n } else\n     document.write('This test must be run by DumpRenderTree!')""}","  void TestProcessOverflow() {
    int tab_count = 1;
    int host_count = 1;
    WebContents* tab1 = NULL;
    WebContents* tab2 = NULL;
    content::RenderProcessHost* rph1 = NULL;
    content::RenderProcessHost* rph2 = NULL;
    content::RenderProcessHost* rph3 = NULL;

     const extensions::Extension* extension =
         LoadExtension(test_data_dir_.AppendASCII(""options_page""));
 
    // Change the first tab to be the omnibox page (WebUI).
     GURL omnibox(chrome::kChromeUIOmniboxURL);
     ui_test_utils::NavigateToURL(browser(), omnibox);
     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
    tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
    rph1 = tab1->GetMainFrame()->GetProcess();
     EXPECT_EQ(omnibox, tab1->GetURL());
     EXPECT_EQ(host_count, RenderProcessHostCount());
 
    // Create a new normal tab with a data URL. It should be in its own process.
     GURL page1(""data:text/html,hello world1"");
 
     ui_test_utils::WindowedTabAddedNotificationObserver observer1(
        content::NotificationService::AllSources());
    ::ShowSingletonTab(browser(), page1);
    observer1.Wait();

    tab_count++;
    host_count++;
    EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
    tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
    rph2 = tab1->GetMainFrame()->GetProcess();
    EXPECT_EQ(tab1->GetURL(), page1);
     EXPECT_EQ(host_count, RenderProcessHostCount());
     EXPECT_NE(rph1, rph2);
 
    // Create another data URL tab.  With Site Isolation, this will require its
    // own process, but without Site Isolation, it can share the previous
    // process.
     GURL page2(""data:text/html,hello world2"");
     ui_test_utils::WindowedTabAddedNotificationObserver observer2(
         content::NotificationService::AllSources());
     ::ShowSingletonTab(browser(), page2);
     observer2.Wait();
     tab_count++;
    if (content::AreAllSitesIsolatedForTesting())
      host_count++;
     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
     tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
     EXPECT_EQ(tab2->GetURL(), page2);
     EXPECT_EQ(host_count, RenderProcessHostCount());
    if (content::AreAllSitesIsolatedForTesting())
      EXPECT_NE(tab2->GetMainFrame()->GetProcess(), rph2);
    else
      EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);

    // Create another WebUI tab.  It should share the process with omnibox.
    // Note: intentionally create this tab after the normal tabs to exercise bug
    // 43448 where extension and WebUI tabs could get combined into normal
    // renderers.
     GURL history(chrome::kChromeUIHistoryURL);
     ui_test_utils::WindowedTabAddedNotificationObserver observer3(
         content::NotificationService::AllSources());
    ::ShowSingletonTab(browser(), history);
    observer3.Wait();
    tab_count++;
    EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
    tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
    EXPECT_EQ(tab2->GetURL(), GURL(history));
     EXPECT_EQ(host_count, RenderProcessHostCount());
     EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph1);
 
    // Create an extension tab.  It should be in its own process.
     GURL extension_url(""chrome-extension://"" + extension->id());
     ui_test_utils::WindowedTabAddedNotificationObserver observer4(
         content::NotificationService::AllSources());
    ::ShowSingletonTab(browser(), extension_url);

    observer4.Wait();
    tab_count++;
    host_count++;
    EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
    tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
    rph3 = tab1->GetMainFrame()->GetProcess();
    EXPECT_EQ(tab1->GetURL(), extension_url);
    EXPECT_EQ(host_count, RenderProcessHostCount());
    EXPECT_NE(rph1, rph3);
    EXPECT_NE(rph2, rph3);
  }
","  void TestProcessOverflow() {
    int tab_count = 1;
    int host_count = 1;
    WebContents* tab1 = NULL;
    WebContents* tab2 = NULL;
    content::RenderProcessHost* rph1 = NULL;
    content::RenderProcessHost* rph2 = NULL;
    content::RenderProcessHost* rph3 = NULL;

     const extensions::Extension* extension =
         LoadExtension(test_data_dir_.AppendASCII(""options_page""));
 
     GURL omnibox(chrome::kChromeUIOmniboxURL);
     ui_test_utils::NavigateToURL(browser(), omnibox);
     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
    tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
    rph1 = tab1->GetMainFrame()->GetProcess();
     EXPECT_EQ(omnibox, tab1->GetURL());
     EXPECT_EQ(host_count, RenderProcessHostCount());
 
     GURL page1(""data:text/html,hello world1"");
 
     ui_test_utils::WindowedTabAddedNotificationObserver observer1(
        content::NotificationService::AllSources());
    ::ShowSingletonTab(browser(), page1);
    observer1.Wait();

    tab_count++;
    host_count++;
    EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
    tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
    rph2 = tab1->GetMainFrame()->GetProcess();
    EXPECT_EQ(tab1->GetURL(), page1);
     EXPECT_EQ(host_count, RenderProcessHostCount());
     EXPECT_NE(rph1, rph2);
 
     GURL page2(""data:text/html,hello world2"");
     ui_test_utils::WindowedTabAddedNotificationObserver observer2(
         content::NotificationService::AllSources());
     ::ShowSingletonTab(browser(), page2);
     observer2.Wait();
     tab_count++;
     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
     tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
     EXPECT_EQ(tab2->GetURL(), page2);
     EXPECT_EQ(host_count, RenderProcessHostCount());
    EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);
     GURL history(chrome::kChromeUIHistoryURL);
     ui_test_utils::WindowedTabAddedNotificationObserver observer3(
         content::NotificationService::AllSources());
    ::ShowSingletonTab(browser(), history);
    observer3.Wait();
    tab_count++;
    EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
    tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
    EXPECT_EQ(tab2->GetURL(), GURL(history));
     EXPECT_EQ(host_count, RenderProcessHostCount());
     EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph1);
 
     GURL extension_url(""chrome-extension://"" + extension->id());
     ui_test_utils::WindowedTabAddedNotificationObserver observer4(
         content::NotificationService::AllSources());
    ::ShowSingletonTab(browser(), extension_url);

    observer4.Wait();
    tab_count++;
    host_count++;
    EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
    tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
    rph3 = tab1->GetMainFrame()->GetProcess();
    EXPECT_EQ(tab1->GetURL(), extension_url);
    EXPECT_EQ(host_count, RenderProcessHostCount());
    EXPECT_NE(rph1, rph3);
    EXPECT_NE(rph2, rph3);
  }
",C,"    // Change the first tab to be the omnibox page (WebUI).
    // Create a new normal tab with a data URL. It should be in its own process.
    // Create another data URL tab.  With Site Isolation, this will require its
    // own process, but without Site Isolation, it can share the previous
    // process.
    if (content::AreAllSitesIsolatedForTesting())
      host_count++;
    if (content::AreAllSitesIsolatedForTesting())
      EXPECT_NE(tab2->GetMainFrame()->GetProcess(), rph2);
    else
      EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);

    // Create another WebUI tab.  It should share the process with omnibox.
    // Note: intentionally create this tab after the normal tabs to exercise bug
    // 43448 where extension and WebUI tabs could get combined into normal
    // renderers.
    // Create an extension tab.  It should be in its own process.
","    EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);
",,"@@ -32,6 +32,7 @@
 #include ""content/public/browser/web_contents_observer.h""
 #include ""content/public/common/content_switches.h""
 #include ""content/public/test/browser_test_utils.h""
+#include ""content/public/test/test_utils.h""
 #include ""media/base/media_switches.h""
 #include ""net/base/filename_util.h""
 #include ""net/test/embedded_test_server/embedded_test_server.h""
@@ -155,7 +156,7 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {
     const extensions::Extension* extension =
         LoadExtension(test_data_dir_.AppendASCII(""options_page""));
 
-    // Change the first tab to be the omnibox page (TYPE_WEBUI).
+    // Change the first tab to be the omnibox page (WebUI).
     GURL omnibox(chrome::kChromeUIOmniboxURL);
     ui_test_utils::NavigateToURL(browser(), omnibox);
     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
@@ -164,7 +165,7 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {
     EXPECT_EQ(omnibox, tab1->GetURL());
     EXPECT_EQ(host_count, RenderProcessHostCount());
 
-    // Create a new TYPE_TABBED tab.  It should be in its own process.
+    // Create a new normal tab with a data URL. It should be in its own process.
     GURL page1(""data:text/html,hello world1"");
 
     ui_test_utils::WindowedTabAddedNotificationObserver observer1(
@@ -181,23 +182,30 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {
     EXPECT_EQ(host_count, RenderProcessHostCount());
     EXPECT_NE(rph1, rph2);
 
-    // Create another TYPE_TABBED tab.  It should share the previous process.
+    // Create another data URL tab.  With Site Isolation, this will require its
+    // own process, but without Site Isolation, it can share the previous
+    // process.
     GURL page2(""data:text/html,hello world2"");
     ui_test_utils::WindowedTabAddedNotificationObserver observer2(
         content::NotificationService::AllSources());
     ::ShowSingletonTab(browser(), page2);
     observer2.Wait();
     tab_count++;
+    if (content::AreAllSitesIsolatedForTesting())
+      host_count++;
     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
     tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
     EXPECT_EQ(tab2->GetURL(), page2);
     EXPECT_EQ(host_count, RenderProcessHostCount());
-    EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);
-
-    // Create another TYPE_WEBUI tab.  It should share the process with omnibox.
-    // Note: intentionally create this tab after the TYPE_TABBED tabs to
-    // exercise bug 43448 where extension and WebUI tabs could get combined into
-    // normal renderers.
+    if (content::AreAllSitesIsolatedForTesting())
+      EXPECT_NE(tab2->GetMainFrame()->GetProcess(), rph2);
+    else
+      EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);
+
+    // Create another WebUI tab.  It should share the process with omnibox.
+    // Note: intentionally create this tab after the normal tabs to exercise bug
+    // 43448 where extension and WebUI tabs could get combined into normal
+    // renderers.
     GURL history(chrome::kChromeUIHistoryURL);
     ui_test_utils::WindowedTabAddedNotificationObserver observer3(
         content::NotificationService::AllSources());
@@ -210,7 +218,7 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {
     EXPECT_EQ(host_count, RenderProcessHostCount());
     EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph1);
 
-    // Create a TYPE_EXTENSION tab.  It should be in its own process.
+    // Create an extension tab.  It should be in its own process.
     GURL extension_url(""chrome-extension://"" + extension->id());
     ui_test_utils::WindowedTabAddedNotificationObserver observer4(
         content::NotificationService::AllSources());
@@ -256,13 +264,13 @@ IN_PROC_BROWSER_TEST_F(ChromeRenderProcessHostTest, MAYBE_ProcessPerTab) {
   int tab_count = 1;
   int host_count = 1;
 
-  // Change the first tab to be the new tab page (TYPE_WEBUI).
+  // Change the first tab to be a WebUI page.
   GURL omnibox(chrome::kChromeUIOmniboxURL);
   ui_test_utils::NavigateToURL(browser(), omnibox);
   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
   EXPECT_EQ(host_count, RenderProcessHostCount());
 
-  // Create a new TYPE_TABBED tab.  It should be in its own process.
+  // Create a new normal tab with a data URL.  It should be in its own process.
   GURL page1(""data:text/html,hello world1"");
   ui_test_utils::WindowedTabAddedNotificationObserver observer1(
       content::NotificationService::AllSources());
@@ -273,13 +281,16 @@ IN_PROC_BROWSER_TEST_F(ChromeRenderProcessHostTest, MAYBE_ProcessPerTab) {
   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
   EXPECT_EQ(host_count, RenderProcessHostCount());
 
-  // Create another TYPE_TABBED tab.  It should share the previous process.
+  // Create another data URL tab.  With Site Isolation, this will require its
+  // own process, but without Site Isolation, it can share the previous process.
   GURL page2(""data:text/html,hello world2"");
   ui_test_utils::WindowedTabAddedNotificationObserver observer2(
       content::NotificationService::AllSources());
   ::ShowSingletonTab(browser(), page2);
   observer2.Wait();
   tab_count++;
+  if (content::AreAllSitesIsolatedForTesting())
+    host_count++;
   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
   EXPECT_EQ(host_count, RenderProcessHostCount());
 ",Chrome,0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca,659c9e34e14cfcecf33f2b2e52aa133db5806fa2,1,"  void TestProcessOverflow() {
    int tab_count = 1;
    int host_count = 1;
    WebContents* tab1 = NULL;
    WebContents* tab2 = NULL;
    content::RenderProcessHost* rph1 = NULL;
    content::RenderProcessHost* rph2 = NULL;
    content::RenderProcessHost* rph3 = NULL;

     const extensions::Extension* extension =
         LoadExtension(test_data_dir_.AppendASCII(""options_page""));
 
//flaw_line_below:
    // Change the first tab to be the omnibox page (TYPE_WEBUI).
//fix_flaw_line_below:
//    // Change the first tab to be the omnibox page (WebUI).
     GURL omnibox(chrome::kChromeUIOmniboxURL);
     ui_test_utils::NavigateToURL(browser(), omnibox);
     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
    tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
    rph1 = tab1->GetMainFrame()->GetProcess();
     EXPECT_EQ(omnibox, tab1->GetURL());
     EXPECT_EQ(host_count, RenderProcessHostCount());
 
//flaw_line_below:
    // Create a new TYPE_TABBED tab.  It should be in its own process.
//fix_flaw_line_below:
//    // Create a new normal tab with a data URL. It should be in its own process.
     GURL page1(""data:text/html,hello world1"");
 
     ui_test_utils::WindowedTabAddedNotificationObserver observer1(
        content::NotificationService::AllSources());
    ::ShowSingletonTab(browser(), page1);
    observer1.Wait();

    tab_count++;
    host_count++;
    EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
    tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
    rph2 = tab1->GetMainFrame()->GetProcess();
    EXPECT_EQ(tab1->GetURL(), page1);
     EXPECT_EQ(host_count, RenderProcessHostCount());
     EXPECT_NE(rph1, rph2);
 
//flaw_line_below:
    // Create another TYPE_TABBED tab.  It should share the previous process.
//fix_flaw_line_below:
//    // Create another data URL tab.  With Site Isolation, this will require its
//fix_flaw_line_below:
//    // own process, but without Site Isolation, it can share the previous
//fix_flaw_line_below:
//    // process.
     GURL page2(""data:text/html,hello world2"");
     ui_test_utils::WindowedTabAddedNotificationObserver observer2(
         content::NotificationService::AllSources());
     ::ShowSingletonTab(browser(), page2);
     observer2.Wait();
     tab_count++;
//fix_flaw_line_below:
//    if (content::AreAllSitesIsolatedForTesting())
//fix_flaw_line_below:
//      host_count++;
     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
     tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
     EXPECT_EQ(tab2->GetURL(), page2);
     EXPECT_EQ(host_count, RenderProcessHostCount());
//flaw_line_below:
    EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);
//flaw_line_below:

//flaw_line_below:
    // Create another TYPE_WEBUI tab.  It should share the process with omnibox.
//flaw_line_below:
    // Note: intentionally create this tab after the TYPE_TABBED tabs to
//flaw_line_below:
    // exercise bug 43448 where extension and WebUI tabs could get combined into
//flaw_line_below:
    // normal renderers.
//fix_flaw_line_below:
//    if (content::AreAllSitesIsolatedForTesting())
//fix_flaw_line_below:
//      EXPECT_NE(tab2->GetMainFrame()->GetProcess(), rph2);
//fix_flaw_line_below:
//    else
//fix_flaw_line_below:
//      EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    // Create another WebUI tab.  It should share the process with omnibox.
//fix_flaw_line_below:
//    // Note: intentionally create this tab after the normal tabs to exercise bug
//fix_flaw_line_below:
//    // 43448 where extension and WebUI tabs could get combined into normal
//fix_flaw_line_below:
//    // renderers.
     GURL history(chrome::kChromeUIHistoryURL);
     ui_test_utils::WindowedTabAddedNotificationObserver observer3(
         content::NotificationService::AllSources());
    ::ShowSingletonTab(browser(), history);
    observer3.Wait();
    tab_count++;
    EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
    tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
    EXPECT_EQ(tab2->GetURL(), GURL(history));
     EXPECT_EQ(host_count, RenderProcessHostCount());
     EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph1);
 
//flaw_line_below:
    // Create a TYPE_EXTENSION tab.  It should be in its own process.
//fix_flaw_line_below:
//    // Create an extension tab.  It should be in its own process.
     GURL extension_url(""chrome-extension://"" + extension->id());
     ui_test_utils::WindowedTabAddedNotificationObserver observer4(
         content::NotificationService::AllSources());
    ::ShowSingletonTab(browser(), extension_url);

    observer4.Wait();
    tab_count++;
    host_count++;
    EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
    tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
    rph3 = tab1->GetMainFrame()->GetProcess();
    EXPECT_EQ(tab1->GetURL(), extension_url);
    EXPECT_EQ(host_count, RenderProcessHostCount());
    EXPECT_NE(rph1, rph3);
    EXPECT_NE(rph2, rph3);
  }
"
9436,187172,,Remote,Not required,,CVE-2018-16073,https://www.cvedetails.com/cve/CVE-2018-16073/,CWE-285,Medium,Partial,,,2019-06-27,4.3,Insufficient policy enforcement in site isolation in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass site isolation via a crafted HTML page.,2019-07-01,Bypass ,16,https://github.com/chromium/chromium/commit/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca,0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca,"Use unique processes for data URLs on restore.

Data URLs are usually put into the process that created them, but this
info is not tracked after a tab restore.  Ensure that they do not end up
in the parent frame's process (or each other's process), in case they
are malicious.

BUG=863069

Change-Id: Ib391f90c7bdf28a0a9c057c5cc7918c10aed968b
Reviewed-on: https://chromium-review.googlesource.com/1150767
Reviewed-by: Alex Moshchuk <alexmos@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Commit-Queue: Charlie Reis <creis@chromium.org>
Cr-Commit-Position: refs/heads/master@{#581023}",3,content/browser/frame_host/render_frame_host_manager.cc,"{""sha"": ""53bcd4ac40273b55e101c55172ad64938fb52f0f"", ""filename"": ""chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 13, ""changes"": 37, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -32,6 +32,7 @@\n #include \""content/public/browser/web_contents_observer.h\""\n #include \""content/public/common/content_switches.h\""\n #include \""content/public/test/browser_test_utils.h\""\n+#include \""content/public/test/test_utils.h\""\n #include \""media/base/media_switches.h\""\n #include \""net/base/filename_util.h\""\n #include \""net/test/embedded_test_server/embedded_test_server.h\""\n@@ -155,7 +156,7 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {\n     const extensions::Extension* extension =\n         LoadExtension(test_data_dir_.AppendASCII(\""options_page\""));\n \n-    // Change the first tab to be the omnibox page (TYPE_WEBUI).\n+    // Change the first tab to be the omnibox page (WebUI).\n     GURL omnibox(chrome::kChromeUIOmniboxURL);\n     ui_test_utils::NavigateToURL(browser(), omnibox);\n     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n@@ -164,7 +165,7 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {\n     EXPECT_EQ(omnibox, tab1->GetURL());\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n \n-    // Create a new TYPE_TABBED tab.  It should be in its own process.\n+    // Create a new normal tab with a data URL. It should be in its own process.\n     GURL page1(\""data:text/html,hello world1\"");\n \n     ui_test_utils::WindowedTabAddedNotificationObserver observer1(\n@@ -181,23 +182,30 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n     EXPECT_NE(rph1, rph2);\n \n-    // Create another TYPE_TABBED tab.  It should share the previous process.\n+    // Create another data URL tab.  With Site Isolation, this will require its\n+    // own process, but without Site Isolation, it can share the previous\n+    // process.\n     GURL page2(\""data:text/html,hello world2\"");\n     ui_test_utils::WindowedTabAddedNotificationObserver observer2(\n         content::NotificationService::AllSources());\n     ::ShowSingletonTab(browser(), page2);\n     observer2.Wait();\n     tab_count++;\n+    if (content::AreAllSitesIsolatedForTesting())\n+      host_count++;\n     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n     tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);\n     EXPECT_EQ(tab2->GetURL(), page2);\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n-    EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);\n-\n-    // Create another TYPE_WEBUI tab.  It should share the process with omnibox.\n-    // Note: intentionally create this tab after the TYPE_TABBED tabs to\n-    // exercise bug 43448 where extension and WebUI tabs could get combined into\n-    // normal renderers.\n+    if (content::AreAllSitesIsolatedForTesting())\n+      EXPECT_NE(tab2->GetMainFrame()->GetProcess(), rph2);\n+    else\n+      EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);\n+\n+    // Create another WebUI tab.  It should share the process with omnibox.\n+    // Note: intentionally create this tab after the normal tabs to exercise bug\n+    // 43448 where extension and WebUI tabs could get combined into normal\n+    // renderers.\n     GURL history(chrome::kChromeUIHistoryURL);\n     ui_test_utils::WindowedTabAddedNotificationObserver observer3(\n         content::NotificationService::AllSources());\n@@ -210,7 +218,7 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n     EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph1);\n \n-    // Create a TYPE_EXTENSION tab.  It should be in its own process.\n+    // Create an extension tab.  It should be in its own process.\n     GURL extension_url(\""chrome-extension://\"" + extension->id());\n     ui_test_utils::WindowedTabAddedNotificationObserver observer4(\n         content::NotificationService::AllSources());\n@@ -256,13 +264,13 @@ IN_PROC_BROWSER_TEST_F(ChromeRenderProcessHostTest, MAYBE_ProcessPerTab) {\n   int tab_count = 1;\n   int host_count = 1;\n \n-  // Change the first tab to be the new tab page (TYPE_WEBUI).\n+  // Change the first tab to be a WebUI page.\n   GURL omnibox(chrome::kChromeUIOmniboxURL);\n   ui_test_utils::NavigateToURL(browser(), omnibox);\n   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n   EXPECT_EQ(host_count, RenderProcessHostCount());\n \n-  // Create a new TYPE_TABBED tab.  It should be in its own process.\n+  // Create a new normal tab with a data URL.  It should be in its own process.\n   GURL page1(\""data:text/html,hello world1\"");\n   ui_test_utils::WindowedTabAddedNotificationObserver observer1(\n       content::NotificationService::AllSources());\n@@ -273,13 +281,16 @@ IN_PROC_BROWSER_TEST_F(ChromeRenderProcessHostTest, MAYBE_ProcessPerTab) {\n   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n   EXPECT_EQ(host_count, RenderProcessHostCount());\n \n-  // Create another TYPE_TABBED tab.  It should share the previous process.\n+  // Create another data URL tab.  With Site Isolation, this will require its\n+  // own process, but without Site Isolation, it can share the previous process.\n   GURL page2(\""data:text/html,hello world2\"");\n   ui_test_utils::WindowedTabAddedNotificationObserver observer2(\n       content::NotificationService::AllSources());\n   ::ShowSingletonTab(browser(), page2);\n   observer2.Wait();\n   tab_count++;\n+  if (content::AreAllSitesIsolatedForTesting())\n+    host_count++;\n   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n   EXPECT_EQ(host_count, RenderProcessHostCount());\n ""}<_**next**_>{""sha"": ""406302b6b76051ba0995f92ec9dc579dfe14f707"", ""filename"": ""content/browser/frame_host/render_frame_host_manager.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 15, ""changes"": 32, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/frame_host/render_frame_host_manager.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/frame_host/render_frame_host_manager.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_manager.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -1971,7 +1971,7 @@ RenderFrameHostManager::GetSiteInstanceForNavigationRequest(\n     // allowed to swap processes.\n     no_renderer_swap_allowed |= !CanSubframeSwapProcess(\n         request.common_params().url, request.source_site_instance(),\n-        request.dest_site_instance(), was_server_redirect);\n+        request.dest_site_instance());\n   }\n \n   if (no_renderer_swap_allowed)\n@@ -2543,8 +2543,7 @@ void RenderFrameHostManager::SendPageMessage(IPC::Message* msg,\n bool RenderFrameHostManager::CanSubframeSwapProcess(\n     const GURL& dest_url,\n     SiteInstance* source_instance,\n-    SiteInstance* dest_instance,\n-    bool was_server_redirect) {\n+    SiteInstance* dest_instance) {\n   // On renderer-initiated navigations, when the frame initiating the navigation\n   // and the frame being navigated differ, |source_instance| is set to the\n   // SiteInstance of the initiating frame. |dest_instance| is present on session\n@@ -2561,22 +2560,25 @@ bool RenderFrameHostManager::CanSubframeSwapProcess(\n       resolved_url = dest_instance->GetSiteURL();\n     } else {\n       // If there is no SiteInstance this unique origin can be associated with,\n-      // there are two cases:\n-      // (1) If there was a server redirect, allow a process swap.  Normally,\n-      // redirects to data: or about: URLs are disallowed as\n+      // then check whether it is safe to put into the parent frame's process.\n+      // This is the case for about:blank URLs (with or without fragments),\n+      // since they contain no active data.  This is also the case for\n+      // about:srcdoc, since such URLs only get active content from their parent\n+      // frame.  Using the parent frame's process avoids putting blank frames\n+      // into OOPIFs and preserves scripting for about:srcdoc.\n+      //\n+      // Allow a process swap for other unique origin URLs, such as data: URLs.\n+      // These have active content and may have come from an untrusted source,\n+      // such as a restored frame from a different site or a redirect.\n+      // (Normally, redirects to data: or about: URLs are disallowed as\n       // net::ERR_UNSAFE_REDIRECT. However, extensions can still redirect\n       // arbitary requests to those URLs using the chrome.webRequest or\n       // chrome.declarativeWebRequest API, which will end up here (for an\n-      // example, see ExtensionWebRequestApiTest.WebRequestDeclarative1).  It's\n-      // safest to swap processes for those redirects if we are in an\n-      // appropriate OOPIF-enabled mode.\n-      //\n-      // (2) Otherwise, avoid a process swap.  We can get here during session\n-      // restore, and this avoids putting all data: and about:blank subframes\n-      // in OOPIFs. We can also get here in tests with browser-initiated\n-      // subframe navigations (NavigateFrameToURL).\n-      if (!was_server_redirect)\n+      // example, see ExtensionWebRequestApiTest.WebRequestDeclarative1).)\n+      if (resolved_url.IsAboutBlank() ||\n+          resolved_url == GURL(content::kAboutSrcDocURL)) {\n         return false;\n+      }\n     }\n   }\n ""}<_**next**_>{""sha"": ""d8cf377f4e2e812080e3b65e324272f2da04270c"", ""filename"": ""content/browser/frame_host/render_frame_host_manager.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/frame_host/render_frame_host_manager.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/frame_host/render_frame_host_manager.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_manager.h?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -730,8 +730,7 @@ class CONTENT_EXPORT RenderFrameHostManager\n   // Returns true if a subframe can navigate cross-process.\n   bool CanSubframeSwapProcess(const GURL& dest_url,\n                               SiteInstance* source_instance,\n-                              SiteInstance* dest_instance,\n-                              bool was_server_redirect);\n+                              SiteInstance* dest_instance);\n \n   // After a renderer process crash we'd have marked the host as invisible, so\n   // we need to set the visibility of the new View to the correct value here""}<_**next**_>{""sha"": ""4385285e7ce5b3dc21203bf84cb686d580d7d04a"", ""filename"": ""content/browser/site_instance_impl.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 6, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_instance_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_instance_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_instance_impl.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -457,16 +457,27 @@ GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,\n     return GURL(origin.scheme() + \"":\"");\n   } else if (url.has_scheme()) {\n     // In some cases, it is not safe to use just the scheme as a site URL, as\n-    // that might allow two URLs created by different sites to to share a\n-    // process.  See https://crbug.com/863623.\n+    // that might allow two URLs created by different sites to share a process.\n+    // See https://crbug.com/863623 and https://crbug.com/863069.\n     //\n     // TODO(alexmos,creis): This should eventually be expanded to certain other\n-    // schemes, such as data: and file:.\n-    if (url.SchemeIsBlob()) {\n+    // schemes, such as file:.\n+    // TODO(creis): This currently causes problems with tests on Android and\n+    // Android WebView.  For now, skip it when Site Isolation is not enabled,\n+    // since there's no need to isolate data and blob URLs from each other in\n+    // that case.\n+    bool is_site_isolation_enabled =\n+        SiteIsolationPolicy::UseDedicatedProcessesForAllSites() ||\n+        SiteIsolationPolicy::AreIsolatedOriginsEnabled();\n+    if (is_site_isolation_enabled &&\n+        (url.SchemeIsBlob() || url.scheme() == url::kDataScheme)) {\n       // We get here for blob URLs of form blob:null/guid.  Use the full URL\n       // with the guid in that case, which isolates all blob URLs with unique\n-      // origins from each other.  Remove hash from the URL, since\n-      // same-document navigations shouldn't use a different site URL.\n+      // origins from each other.  We also get here for browser-initiated\n+      // navigations to data URLs, which have a unique origin and should only\n+      // share a process when they are identical.  Remove hash from the URL in\n+      // either case, since same-document navigations shouldn't use a different\n+      // site URL.\n       if (url.has_ref()) {\n         GURL::Replacements replacements;\n         replacements.ClearRef();""}<_**next**_>{""sha"": ""66159134d65a635172ee4b476d83e43fc6cb0656"", ""filename"": ""content/browser/site_instance_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 7, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_instance_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_instance_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_instance_impl_unittest.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -316,12 +316,25 @@ TEST_F(SiteInstanceTest, GetSiteForURL) {\n   EXPECT_EQ(\""file\"", site_url.scheme());\n   EXPECT_FALSE(site_url.has_host());\n \n-  // Data URLs should include the scheme.\n+  // Data URLs should include the whole URL, except for the hash, when Site\n+  // Isolation is enabled.  Otherwise they just include the scheme.\n   test_url = GURL(\""data:text/html,foo\"");\n   site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n-  EXPECT_EQ(GURL(\""data:\""), site_url);\n+  if (AreAllSitesIsolatedForTesting())\n+    EXPECT_EQ(test_url, site_url);\n+  else\n+    EXPECT_EQ(GURL(\""data:\""), site_url);\n   EXPECT_EQ(\""data\"", site_url.scheme());\n   EXPECT_FALSE(site_url.has_host());\n+  test_url = GURL(\""data:text/html,foo#bar\"");\n+  site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n+  EXPECT_FALSE(site_url.has_ref());\n+  if (AreAllSitesIsolatedForTesting()) {\n+    EXPECT_NE(test_url, site_url);\n+    EXPECT_TRUE(site_url.EqualsIgnoringRef(test_url));\n+  } else {\n+    EXPECT_EQ(GURL(\""data:\""), site_url);\n+  }\n \n   // Javascript URLs should include the scheme.\n   test_url = GURL(\""javascript:foo();\"");\n@@ -344,16 +357,24 @@ TEST_F(SiteInstanceTest, GetSiteForURL) {\n   EXPECT_EQ(\""file\"", site_url.scheme());\n   EXPECT_FALSE(site_url.has_host());\n \n-  // Blob URLs created from a unique origin use the full URL as the site URL,\n-  // except for the hash.\n+  // Blob URLs created from a unique origin use the full URL as the site URL\n+  // when Site Isolation is enabled, except for the hash.  Otherwise they just\n+  // include the scheme.\n   test_url = GURL(\""blob:null/1029e5a4-2983-4b90-a585-ed217563acfeb\"");\n   site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n-  EXPECT_EQ(site_url, test_url);\n+  if (AreAllSitesIsolatedForTesting())\n+    EXPECT_EQ(test_url, site_url);\n+  else\n+    EXPECT_EQ(GURL(\""blob:\""), site_url);\n   test_url = GURL(\""blob:null/1029e5a4-2983-4b90-a585-ed217563acfeb#foo\"");\n   site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n-  EXPECT_NE(site_url, test_url);\n   EXPECT_FALSE(site_url.has_ref());\n-  EXPECT_TRUE(site_url.EqualsIgnoringRef(test_url));\n+  if (AreAllSitesIsolatedForTesting()) {\n+    EXPECT_NE(test_url, site_url);\n+    EXPECT_TRUE(site_url.EqualsIgnoringRef(test_url));\n+  } else {\n+    EXPECT_EQ(GURL(\""blob:\""), site_url);\n+  }\n \n   // Private domains are preserved, appspot being such a site.\n   test_url = GURL(""}<_**next**_>{""sha"": ""26dbd2cdf254fb8c0d6fa5606165f7128afacb92"", ""filename"": ""content/browser/site_per_process_browsertest.cc"", ""status"": ""modified"", ""additions"": 283, ""deletions"": 3, ""changes"": 286, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_per_process_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_per_process_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_per_process_browsertest.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -7289,8 +7289,8 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n }\n \n // Ensures that navigating to data: URLs present in session history will\n-// correctly commit the navigation in the same process as the parent frame.\n-// See https://crbug.com/606996.\n+// correctly commit the navigation in the same process as the one used for the\n+// original navigation. See https://crbug.com/606996.\n IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n                        NavigateSubframeToDataUrlInSessionHistory) {\n   GURL main_url(embedded_test_server()->GetURL(\n@@ -7316,7 +7316,7 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n   EXPECT_TRUE(observer.last_navigation_succeeded());\n   EXPECT_EQ(data_url, observer.last_navigation_url());\n   scoped_refptr<SiteInstanceImpl> orig_site_instance =\n-    child->current_frame_host()->GetSiteInstance();\n+      child->current_frame_host()->GetSiteInstance();\n   EXPECT_NE(root->current_frame_host()->GetSiteInstance(), orig_site_instance);\n \n   // Navigate it to another cross-site url.\n@@ -7336,6 +7336,286 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n   EXPECT_EQ(orig_site_instance, child->current_frame_host()->GetSiteInstance());\n }\n \n+// Ensures that subframes navigated to data: URLs start in a process based on\n+// their creator, but end up in unique processes after a restore (since\n+// SiteInstance relationships are not preserved on restore, until\n+// https://crbug.com/14987 is fixed).  This is better than restoring into the\n+// parent process, per https://crbug.com/863069.\n+IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n+                       SubframeDataUrlsAfterRestore) {\n+  // We must use a page that has iframes in the HTML here, unlike\n+  // cross_site_iframe_factory.html which loads them dynamically.  In the latter\n+  // case, Chrome will not restore subframe URLs from history, which is needed\n+  // for this test.\n+  GURL main_url(embedded_test_server()->GetURL(\n+      \""a.com\"", \""/frame_tree/page_with_two_iframes.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+\n+  FrameTreeNode* root = web_contents()->GetFrameTree()->root();\n+  EXPECT_EQ(2U, root->child_count());\n+  EXPECT_EQ(\n+      \"" Site A ------------ proxies for B C\\n\""\n+      \""   |--Site B ------- proxies for A C\\n\""\n+      \""   +--Site C ------- proxies for A B\\n\""\n+      \""Where A = http://a.com/\\n\""\n+      \""      B = http://bar.com/\\n\""\n+      \""      C = http://baz.com/\"",\n+      DepictFrameTree(root));\n+\n+  FrameTreeNode* child_0 = root->child_at(0);\n+  FrameTreeNode* child_1 = root->child_at(1);\n+  scoped_refptr<SiteInstanceImpl> child_site_instance_0 =\n+      child_0->current_frame_host()->GetSiteInstance();\n+  scoped_refptr<SiteInstanceImpl> child_site_instance_1 =\n+      child_1->current_frame_host()->GetSiteInstance();\n+\n+  // Navigate the iframes to data URLs via renderer initiated navigations, which\n+  // will commit in the existing SiteInstances.\n+  TestNavigationObserver observer(shell()->web_contents());\n+  GURL data_url_0(\""data:text/html,dataurl_0\"");\n+  {\n+    TestFrameNavigationObserver commit_observer(child_0);\n+    EXPECT_TRUE(\n+        ExecuteScript(child_0, \""location.href = '\"" + data_url_0.spec() + \""';\""));\n+    commit_observer.WaitForCommit();\n+  }\n+  EXPECT_TRUE(observer.last_navigation_succeeded());\n+  EXPECT_EQ(data_url_0, observer.last_navigation_url());\n+  EXPECT_EQ(child_site_instance_0,\n+            child_0->current_frame_host()->GetSiteInstance());\n+\n+  GURL data_url_1(\""data:text/html,dataurl_1\"");\n+  {\n+    TestFrameNavigationObserver commit_observer(child_1);\n+    EXPECT_TRUE(\n+        ExecuteScript(child_1, \""location.href = '\"" + data_url_1.spec() + \""';\""));\n+    commit_observer.WaitForCommit();\n+  }\n+  EXPECT_TRUE(observer.last_navigation_succeeded());\n+  EXPECT_EQ(data_url_1, observer.last_navigation_url());\n+  EXPECT_EQ(child_site_instance_1,\n+            child_1->current_frame_host()->GetSiteInstance());\n+\n+  // Grab the NavigationEntry and clone its PageState into a new entry for\n+  // restoring into a new tab.\n+  const NavigationControllerImpl& controller =\n+      static_cast<const NavigationControllerImpl&>(\n+          shell()->web_contents()->GetController());\n+  NavigationEntryImpl* entry = controller.GetLastCommittedEntry();\n+  std::unique_ptr<NavigationEntryImpl> restored_entry =\n+      NavigationEntryImpl::FromNavigationEntry(\n+          NavigationController::CreateNavigationEntry(\n+              main_url, Referrer(), ui::PAGE_TRANSITION_RELOAD, false,\n+              std::string(), controller.GetBrowserContext(),\n+              nullptr /* blob_url_loader_factory */));\n+  EXPECT_EQ(0U, restored_entry->root_node()->children.size());\n+  restored_entry->SetPageState(entry->GetPageState());\n+  ASSERT_EQ(2U, restored_entry->root_node()->children.size());\n+\n+  // Restore the NavigationEntry into a new tab and check that the data URLs are\n+  // not loaded into the parent's SiteInstance.\n+  std::vector<std::unique_ptr<NavigationEntry>> entries;\n+  entries.push_back(std::move(restored_entry));\n+  Shell* new_shell = Shell::CreateNewWindow(\n+      controller.GetBrowserContext(), GURL::EmptyGURL(), nullptr, gfx::Size());\n+  FrameTreeNode* new_root =\n+      static_cast<WebContentsImpl*>(new_shell->web_contents())\n+          ->GetFrameTree()\n+          ->root();\n+  NavigationControllerImpl& new_controller =\n+      static_cast<NavigationControllerImpl&>(\n+          new_shell->web_contents()->GetController());\n+  new_controller.Restore(entries.size() - 1,\n+                         RestoreType::LAST_SESSION_EXITED_CLEANLY, &entries);\n+  ASSERT_EQ(0u, entries.size());\n+  {\n+    TestNavigationObserver restore_observer(new_shell->web_contents());\n+    new_controller.LoadIfNecessary();\n+    restore_observer.Wait();\n+  }\n+  ASSERT_EQ(2U, new_root->child_count());\n+  EXPECT_EQ(main_url, new_root->current_url());\n+  EXPECT_EQ(\""data\"", new_root->child_at(0)->current_url().scheme());\n+  EXPECT_EQ(\""data\"", new_root->child_at(1)->current_url().scheme());\n+\n+  EXPECT_NE(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(0)->current_frame_host()->GetSiteInstance());\n+  EXPECT_NE(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(1)->current_frame_host()->GetSiteInstance());\n+  EXPECT_NE(new_root->child_at(0)->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(1)->current_frame_host()->GetSiteInstance());\n+}\n+\n+// Similar to SubframeDataUrlsAfterRestore, but ensures that about:blank frames\n+// do get put into their parent process after restore, even if they weren't\n+// originally.  This is safe because they do not contain active content (even\n+// when there's a fragment in the URL), and it avoids unnecessary OOPIFs.\n+IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n+                       SubframeBlankUrlsAfterRestore) {\n+  // We must use a page that has iframes in the HTML here, unlike\n+  // cross_site_iframe_factory.html which loads them dynamically.  In the latter\n+  // case, Chrome will not restore subframe URLs from history, which is needed\n+  // for this test.\n+  GURL main_url(embedded_test_server()->GetURL(\n+      \""a.com\"", \""/frame_tree/page_with_two_iframes.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+\n+  FrameTreeNode* root = web_contents()->GetFrameTree()->root();\n+  EXPECT_EQ(2U, root->child_count());\n+  EXPECT_EQ(\n+      \"" Site A ------------ proxies for B C\\n\""\n+      \""   |--Site B ------- proxies for A C\\n\""\n+      \""   +--Site C ------- proxies for A B\\n\""\n+      \""Where A = http://a.com/\\n\""\n+      \""      B = http://bar.com/\\n\""\n+      \""      C = http://baz.com/\"",\n+      DepictFrameTree(root));\n+\n+  FrameTreeNode* child_0 = root->child_at(0);\n+  FrameTreeNode* child_1 = root->child_at(1);\n+  scoped_refptr<SiteInstanceImpl> child_site_instance_0 =\n+      child_0->current_frame_host()->GetSiteInstance();\n+  scoped_refptr<SiteInstanceImpl> child_site_instance_1 =\n+      child_1->current_frame_host()->GetSiteInstance();\n+\n+  // Navigate the iframes to about:blank URLs via renderer initiated\n+  // navigations, which will commit in the existing SiteInstances.\n+  TestNavigationObserver observer(shell()->web_contents());\n+  GURL blank_url(\""about:blank\"");\n+  {\n+    TestFrameNavigationObserver commit_observer(child_0);\n+    EXPECT_TRUE(\n+        ExecuteScript(child_0, \""location.href = '\"" + blank_url.spec() + \""';\""));\n+    commit_observer.WaitForCommit();\n+  }\n+  EXPECT_TRUE(observer.last_navigation_succeeded());\n+  EXPECT_EQ(blank_url, observer.last_navigation_url());\n+  EXPECT_EQ(child_site_instance_0,\n+            child_0->current_frame_host()->GetSiteInstance());\n+\n+  GURL blank_url_ref(\""about:blank#1\"");\n+  {\n+    TestFrameNavigationObserver commit_observer(child_1);\n+    EXPECT_TRUE(ExecuteScript(\n+        child_1, \""location.href = '\"" + blank_url_ref.spec() + \""';\""));\n+    commit_observer.WaitForCommit();\n+  }\n+  EXPECT_TRUE(observer.last_navigation_succeeded());\n+  EXPECT_EQ(blank_url_ref, observer.last_navigation_url());\n+  EXPECT_EQ(child_site_instance_1,\n+            child_1->current_frame_host()->GetSiteInstance());\n+\n+  // Grab the NavigationEntry and clone its PageState into a new entry for\n+  // restoring into a new tab.\n+  const NavigationControllerImpl& controller =\n+      static_cast<const NavigationControllerImpl&>(\n+          shell()->web_contents()->GetController());\n+  NavigationEntryImpl* entry = controller.GetLastCommittedEntry();\n+  std::unique_ptr<NavigationEntryImpl> restored_entry =\n+      NavigationEntryImpl::FromNavigationEntry(\n+          NavigationController::CreateNavigationEntry(\n+              main_url, Referrer(), ui::PAGE_TRANSITION_RELOAD, false,\n+              std::string(), controller.GetBrowserContext(),\n+              nullptr /* blob_url_loader_factory */));\n+  EXPECT_EQ(0U, restored_entry->root_node()->children.size());\n+  restored_entry->SetPageState(entry->GetPageState());\n+  ASSERT_EQ(2U, restored_entry->root_node()->children.size());\n+\n+  // Restore the NavigationEntry into a new tab and check that the data URLs are\n+  // not loaded into the parent's SiteInstance.\n+  std::vector<std::unique_ptr<NavigationEntry>> entries;\n+  entries.push_back(std::move(restored_entry));\n+  Shell* new_shell = Shell::CreateNewWindow(\n+      controller.GetBrowserContext(), GURL::EmptyGURL(), nullptr, gfx::Size());\n+  FrameTreeNode* new_root =\n+      static_cast<WebContentsImpl*>(new_shell->web_contents())\n+          ->GetFrameTree()\n+          ->root();\n+  NavigationControllerImpl& new_controller =\n+      static_cast<NavigationControllerImpl&>(\n+          new_shell->web_contents()->GetController());\n+  new_controller.Restore(entries.size() - 1,\n+                         RestoreType::LAST_SESSION_EXITED_CLEANLY, &entries);\n+  ASSERT_EQ(0u, entries.size());\n+  {\n+    TestNavigationObserver restore_observer(new_shell->web_contents());\n+    new_controller.LoadIfNecessary();\n+    restore_observer.Wait();\n+  }\n+  ASSERT_EQ(2U, new_root->child_count());\n+  EXPECT_EQ(main_url, new_root->current_url());\n+  EXPECT_TRUE(new_root->child_at(0)->current_url().IsAboutBlank());\n+  EXPECT_TRUE(new_root->child_at(1)->current_url().IsAboutBlank());\n+\n+  EXPECT_EQ(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(0)->current_frame_host()->GetSiteInstance());\n+  EXPECT_EQ(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(1)->current_frame_host()->GetSiteInstance());\n+}\n+\n+// Similar to SubframeBlankUrlsAfterRestore, but ensures that about:srcdoc ends\n+// up in its parent's process after restore, since that's where its content\n+// comes from.\n+IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n+                       SubframeSrcdocUrlAfterRestore) {\n+  // Load a page that uses iframe srcdoc.\n+  GURL main_url(embedded_test_server()->GetURL(\n+      \""a.com\"", \""/frame_tree/page_with_srcdoc_frame.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+\n+  FrameTreeNode* root = web_contents()->GetFrameTree()->root();\n+  EXPECT_EQ(1U, root->child_count());\n+  FrameTreeNode* child = root->child_at(0);\n+  scoped_refptr<SiteInstanceImpl> child_site_instance =\n+      child->current_frame_host()->GetSiteInstance();\n+  EXPECT_EQ(child_site_instance, root->current_frame_host()->GetSiteInstance());\n+\n+  // Grab the NavigationEntry and clone its PageState into a new entry for\n+  // restoring into a new tab.\n+  const NavigationControllerImpl& controller =\n+      static_cast<const NavigationControllerImpl&>(\n+          shell()->web_contents()->GetController());\n+  NavigationEntryImpl* entry = controller.GetLastCommittedEntry();\n+  std::unique_ptr<NavigationEntryImpl> restored_entry =\n+      NavigationEntryImpl::FromNavigationEntry(\n+          NavigationController::CreateNavigationEntry(\n+              main_url, Referrer(), ui::PAGE_TRANSITION_RELOAD, false,\n+              std::string(), controller.GetBrowserContext(),\n+              nullptr /* blob_url_loader_factory */));\n+  EXPECT_EQ(0U, restored_entry->root_node()->children.size());\n+  restored_entry->SetPageState(entry->GetPageState());\n+  ASSERT_EQ(1U, restored_entry->root_node()->children.size());\n+\n+  // Restore the NavigationEntry into a new tab and check that the srcdoc URLs\n+  // are still loaded into the parent's SiteInstance.\n+  std::vector<std::unique_ptr<NavigationEntry>> entries;\n+  entries.push_back(std::move(restored_entry));\n+  Shell* new_shell = Shell::CreateNewWindow(\n+      controller.GetBrowserContext(), GURL::EmptyGURL(), nullptr, gfx::Size());\n+  FrameTreeNode* new_root =\n+      static_cast<WebContentsImpl*>(new_shell->web_contents())\n+          ->GetFrameTree()\n+          ->root();\n+  NavigationControllerImpl& new_controller =\n+      static_cast<NavigationControllerImpl&>(\n+          new_shell->web_contents()->GetController());\n+  new_controller.Restore(entries.size() - 1,\n+                         RestoreType::LAST_SESSION_EXITED_CLEANLY, &entries);\n+  ASSERT_EQ(0u, entries.size());\n+  {\n+    TestNavigationObserver restore_observer(new_shell->web_contents());\n+    new_controller.LoadIfNecessary();\n+    restore_observer.Wait();\n+  }\n+  ASSERT_EQ(1U, new_root->child_count());\n+  EXPECT_EQ(main_url, new_root->current_url());\n+  EXPECT_EQ(GURL(content::kAboutSrcDocURL),\n+            new_root->child_at(0)->current_url());\n+\n+  EXPECT_EQ(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(0)->current_frame_host()->GetSiteInstance());\n+}\n+\n // Ensures that navigating to about:blank URLs present in session history will\n // correctly commit the navigation in the same process as the one used for\n // the original navigation.""}<_**next**_>{""sha"": ""a5bce3fd2565d8f458555a0c6f42d0504a848bd5"", ""filename"": ""third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-1.html"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-1.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-1.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-1.html?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -0,0 +1 @@\n+test1""}<_**next**_>{""sha"": ""180cf8328022becee9aaa2577a8f84ea2b9f3827"", ""filename"": ""third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-2.html"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-2.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-2.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-2.html?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -0,0 +1 @@\n+test2""}<_**next**_>{""sha"": ""b8ae010756f6d0452c849c17607ab4bd3f11670b"", ""filename"": ""third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child.html"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child.html?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -1,9 +1,10 @@\n <p>This tests that navigating to two pages in a subframe, and then going back does not cause an assertion.</p>\n <p>SUCCESS - Didn't assert!</p>\n <script>\n+\n if (window.testRunner) {\n-    testRunner.queueLoad('data:text/html,test1', 'target')\n-    testRunner.queueLoad('data:text/html,test2', 'target')\n+    testRunner.queueLoad('resources/frame-navigation-child-1.html', 'target')\n+    testRunner.queueLoad('resources/frame-navigation-child-2.html', 'target')\n     testRunner.queueBackNavigation(1);\n } else\n     document.write('This test must be run by DumpRenderTree!')""}"," bool RenderFrameHostManager::CanSubframeSwapProcess(
     const GURL& dest_url,
     SiteInstance* source_instance,
    SiteInstance* dest_instance) {
  DCHECK(!source_instance || !dest_instance);

  GURL resolved_url = dest_url;
  if (url::Origin::Create(resolved_url).unique()) {
    if (source_instance) {
      resolved_url = source_instance->GetSiteURL();
    } else if (dest_instance) {
       resolved_url = dest_instance->GetSiteURL();
     } else {
      // then check whether it is safe to put into the parent frame's process.
      // This is the case for about:blank URLs (with or without fragments),
      // since they contain no active data.  This is also the case for
      // about:srcdoc, since such URLs only get active content from their parent
      // frame.  Using the parent frame's process avoids putting blank frames
      // into OOPIFs and preserves scripting for about:srcdoc.
      //
      // Allow a process swap for other unique origin URLs, such as data: URLs.
      // These have active content and may have come from an untrusted source,
      // such as a restored frame from a different site or a redirect.
      // (Normally, redirects to data: or about: URLs are disallowed as
      // example, see ExtensionWebRequestApiTest.WebRequestDeclarative1).)
      if (resolved_url.IsAboutBlank() ||
          resolved_url == GURL(content::kAboutSrcDocURL)) {
         return false;
      }
     }
   }
 
  if (!IsRendererTransferNeededForNavigation(render_frame_host_.get(),
                                             resolved_url)) {
    DCHECK(!dest_instance ||
           dest_instance == render_frame_host_->GetSiteInstance());
    return false;
  }

  return true;
}
"," bool RenderFrameHostManager::CanSubframeSwapProcess(
     const GURL& dest_url,
     SiteInstance* source_instance,
    SiteInstance* dest_instance,
    bool was_server_redirect) {
  DCHECK(!source_instance || !dest_instance);

  GURL resolved_url = dest_url;
  if (url::Origin::Create(resolved_url).unique()) {
    if (source_instance) {
      resolved_url = source_instance->GetSiteURL();
    } else if (dest_instance) {
       resolved_url = dest_instance->GetSiteURL();
     } else {
      if (!was_server_redirect)
         return false;
     }
   }
 
  if (!IsRendererTransferNeededForNavigation(render_frame_host_.get(),
                                             resolved_url)) {
    DCHECK(!dest_instance ||
           dest_instance == render_frame_host_->GetSiteInstance());
    return false;
  }

  return true;
}
",C,"    SiteInstance* dest_instance) {
      // then check whether it is safe to put into the parent frame's process.
      // This is the case for about:blank URLs (with or without fragments),
      // since they contain no active data.  This is also the case for
      // about:srcdoc, since such URLs only get active content from their parent
      // frame.  Using the parent frame's process avoids putting blank frames
      // into OOPIFs and preserves scripting for about:srcdoc.
      //
      // Allow a process swap for other unique origin URLs, such as data: URLs.
      // These have active content and may have come from an untrusted source,
      // such as a restored frame from a different site or a redirect.
      // (Normally, redirects to data: or about: URLs are disallowed as
      // example, see ExtensionWebRequestApiTest.WebRequestDeclarative1).)
      if (resolved_url.IsAboutBlank() ||
          resolved_url == GURL(content::kAboutSrcDocURL)) {
      }
","    SiteInstance* dest_instance,
    bool was_server_redirect) {
      if (!was_server_redirect)
",,"@@ -1971,7 +1971,7 @@ RenderFrameHostManager::GetSiteInstanceForNavigationRequest(
     // allowed to swap processes.
     no_renderer_swap_allowed |= !CanSubframeSwapProcess(
         request.common_params().url, request.source_site_instance(),
-        request.dest_site_instance(), was_server_redirect);
+        request.dest_site_instance());
   }
 
   if (no_renderer_swap_allowed)
@@ -2543,8 +2543,7 @@ void RenderFrameHostManager::SendPageMessage(IPC::Message* msg,
 bool RenderFrameHostManager::CanSubframeSwapProcess(
     const GURL& dest_url,
     SiteInstance* source_instance,
-    SiteInstance* dest_instance,
-    bool was_server_redirect) {
+    SiteInstance* dest_instance) {
   // On renderer-initiated navigations, when the frame initiating the navigation
   // and the frame being navigated differ, |source_instance| is set to the
   // SiteInstance of the initiating frame. |dest_instance| is present on session
@@ -2561,22 +2560,25 @@ bool RenderFrameHostManager::CanSubframeSwapProcess(
       resolved_url = dest_instance->GetSiteURL();
     } else {
       // If there is no SiteInstance this unique origin can be associated with,
-      // there are two cases:
-      // (1) If there was a server redirect, allow a process swap.  Normally,
-      // redirects to data: or about: URLs are disallowed as
+      // then check whether it is safe to put into the parent frame's process.
+      // This is the case for about:blank URLs (with or without fragments),
+      // since they contain no active data.  This is also the case for
+      // about:srcdoc, since such URLs only get active content from their parent
+      // frame.  Using the parent frame's process avoids putting blank frames
+      // into OOPIFs and preserves scripting for about:srcdoc.
+      //
+      // Allow a process swap for other unique origin URLs, such as data: URLs.
+      // These have active content and may have come from an untrusted source,
+      // such as a restored frame from a different site or a redirect.
+      // (Normally, redirects to data: or about: URLs are disallowed as
       // net::ERR_UNSAFE_REDIRECT. However, extensions can still redirect
       // arbitary requests to those URLs using the chrome.webRequest or
       // chrome.declarativeWebRequest API, which will end up here (for an
-      // example, see ExtensionWebRequestApiTest.WebRequestDeclarative1).  It's
-      // safest to swap processes for those redirects if we are in an
-      // appropriate OOPIF-enabled mode.
-      //
-      // (2) Otherwise, avoid a process swap.  We can get here during session
-      // restore, and this avoids putting all data: and about:blank subframes
-      // in OOPIFs. We can also get here in tests with browser-initiated
-      // subframe navigations (NavigateFrameToURL).
-      if (!was_server_redirect)
+      // example, see ExtensionWebRequestApiTest.WebRequestDeclarative1).)
+      if (resolved_url.IsAboutBlank() ||
+          resolved_url == GURL(content::kAboutSrcDocURL)) {
         return false;
+      }
     }
   }
 ",Chrome,0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca,659c9e34e14cfcecf33f2b2e52aa133db5806fa2,1," bool RenderFrameHostManager::CanSubframeSwapProcess(
     const GURL& dest_url,
     SiteInstance* source_instance,
//flaw_line_below:
    SiteInstance* dest_instance,
//flaw_line_below:
    bool was_server_redirect) {
//fix_flaw_line_below:
//    SiteInstance* dest_instance) {
   // On renderer-initiated navigations, when the frame initiating the navigation
   // and the frame being navigated differ, |source_instance| is set to the
   // SiteInstance of the initiating frame. |dest_instance| is present on session
  // history navigations. The two cannot be set simultaneously.
  DCHECK(!source_instance || !dest_instance);

  // If dest_url is a unique origin like about:blank, then the need for a swap
  // is determined by the source_instance or dest_instance.
  GURL resolved_url = dest_url;
  if (url::Origin::Create(resolved_url).unique()) {
    if (source_instance) {
      resolved_url = source_instance->GetSiteURL();
    } else if (dest_instance) {
       resolved_url = dest_instance->GetSiteURL();
     } else {
       // If there is no SiteInstance this unique origin can be associated with,
//flaw_line_below:
      // there are two cases:
//flaw_line_below:
      // (1) If there was a server redirect, allow a process swap.  Normally,
//flaw_line_below:
      // redirects to data: or about: URLs are disallowed as
//fix_flaw_line_below:
//      // then check whether it is safe to put into the parent frame's process.
//fix_flaw_line_below:
//      // This is the case for about:blank URLs (with or without fragments),
//fix_flaw_line_below:
//      // since they contain no active data.  This is also the case for
//fix_flaw_line_below:
//      // about:srcdoc, since such URLs only get active content from their parent
//fix_flaw_line_below:
//      // frame.  Using the parent frame's process avoids putting blank frames
//fix_flaw_line_below:
//      // into OOPIFs and preserves scripting for about:srcdoc.
//fix_flaw_line_below:
//      //
//fix_flaw_line_below:
//      // Allow a process swap for other unique origin URLs, such as data: URLs.
//fix_flaw_line_below:
//      // These have active content and may have come from an untrusted source,
//fix_flaw_line_below:
//      // such as a restored frame from a different site or a redirect.
//fix_flaw_line_below:
//      // (Normally, redirects to data: or about: URLs are disallowed as
       // net::ERR_UNSAFE_REDIRECT. However, extensions can still redirect
       // arbitary requests to those URLs using the chrome.webRequest or
       // chrome.declarativeWebRequest API, which will end up here (for an
//flaw_line_below:
      // example, see ExtensionWebRequestApiTest.WebRequestDeclarative1).  It's
//flaw_line_below:
      // safest to swap processes for those redirects if we are in an
//flaw_line_below:
      // appropriate OOPIF-enabled mode.
//flaw_line_below:
      //
//flaw_line_below:
      // (2) Otherwise, avoid a process swap.  We can get here during session
//flaw_line_below:
      // restore, and this avoids putting all data: and about:blank subframes
//flaw_line_below:
      // in OOPIFs. We can also get here in tests with browser-initiated
//flaw_line_below:
      // subframe navigations (NavigateFrameToURL).
//flaw_line_below:
      if (!was_server_redirect)
//fix_flaw_line_below:
//      // example, see ExtensionWebRequestApiTest.WebRequestDeclarative1).)
//fix_flaw_line_below:
//      if (resolved_url.IsAboutBlank() ||
//fix_flaw_line_below:
//          resolved_url == GURL(content::kAboutSrcDocURL)) {
         return false;
//fix_flaw_line_below:
//      }
     }
   }
 
  // If we are in an OOPIF mode that only applies to some sites, only swap if
  // the policy determines that a transfer would have been needed.  We can get
  // here for session restore.
  if (!IsRendererTransferNeededForNavigation(render_frame_host_.get(),
                                             resolved_url)) {
    DCHECK(!dest_instance ||
           dest_instance == render_frame_host_->GetSiteInstance());
    return false;
  }

  return true;
}
"
9437,187173,,Remote,Not required,,CVE-2018-16073,https://www.cvedetails.com/cve/CVE-2018-16073/,CWE-285,Medium,Partial,,,2019-06-27,4.3,Insufficient policy enforcement in site isolation in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass site isolation via a crafted HTML page.,2019-07-01,Bypass ,1,https://github.com/chromium/chromium/commit/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca,0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca,"Use unique processes for data URLs on restore.

Data URLs are usually put into the process that created them, but this
info is not tracked after a tab restore.  Ensure that they do not end up
in the parent frame's process (or each other's process), in case they
are malicious.

BUG=863069

Change-Id: Ib391f90c7bdf28a0a9c057c5cc7918c10aed968b
Reviewed-on: https://chromium-review.googlesource.com/1150767
Reviewed-by: Alex Moshchuk <alexmos@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Commit-Queue: Charlie Reis <creis@chromium.org>
Cr-Commit-Position: refs/heads/master@{#581023}",1,content/browser/frame_host/render_frame_host_manager.cc,"{""sha"": ""53bcd4ac40273b55e101c55172ad64938fb52f0f"", ""filename"": ""chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 13, ""changes"": 37, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -32,6 +32,7 @@\n #include \""content/public/browser/web_contents_observer.h\""\n #include \""content/public/common/content_switches.h\""\n #include \""content/public/test/browser_test_utils.h\""\n+#include \""content/public/test/test_utils.h\""\n #include \""media/base/media_switches.h\""\n #include \""net/base/filename_util.h\""\n #include \""net/test/embedded_test_server/embedded_test_server.h\""\n@@ -155,7 +156,7 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {\n     const extensions::Extension* extension =\n         LoadExtension(test_data_dir_.AppendASCII(\""options_page\""));\n \n-    // Change the first tab to be the omnibox page (TYPE_WEBUI).\n+    // Change the first tab to be the omnibox page (WebUI).\n     GURL omnibox(chrome::kChromeUIOmniboxURL);\n     ui_test_utils::NavigateToURL(browser(), omnibox);\n     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n@@ -164,7 +165,7 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {\n     EXPECT_EQ(omnibox, tab1->GetURL());\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n \n-    // Create a new TYPE_TABBED tab.  It should be in its own process.\n+    // Create a new normal tab with a data URL. It should be in its own process.\n     GURL page1(\""data:text/html,hello world1\"");\n \n     ui_test_utils::WindowedTabAddedNotificationObserver observer1(\n@@ -181,23 +182,30 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n     EXPECT_NE(rph1, rph2);\n \n-    // Create another TYPE_TABBED tab.  It should share the previous process.\n+    // Create another data URL tab.  With Site Isolation, this will require its\n+    // own process, but without Site Isolation, it can share the previous\n+    // process.\n     GURL page2(\""data:text/html,hello world2\"");\n     ui_test_utils::WindowedTabAddedNotificationObserver observer2(\n         content::NotificationService::AllSources());\n     ::ShowSingletonTab(browser(), page2);\n     observer2.Wait();\n     tab_count++;\n+    if (content::AreAllSitesIsolatedForTesting())\n+      host_count++;\n     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n     tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);\n     EXPECT_EQ(tab2->GetURL(), page2);\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n-    EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);\n-\n-    // Create another TYPE_WEBUI tab.  It should share the process with omnibox.\n-    // Note: intentionally create this tab after the TYPE_TABBED tabs to\n-    // exercise bug 43448 where extension and WebUI tabs could get combined into\n-    // normal renderers.\n+    if (content::AreAllSitesIsolatedForTesting())\n+      EXPECT_NE(tab2->GetMainFrame()->GetProcess(), rph2);\n+    else\n+      EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);\n+\n+    // Create another WebUI tab.  It should share the process with omnibox.\n+    // Note: intentionally create this tab after the normal tabs to exercise bug\n+    // 43448 where extension and WebUI tabs could get combined into normal\n+    // renderers.\n     GURL history(chrome::kChromeUIHistoryURL);\n     ui_test_utils::WindowedTabAddedNotificationObserver observer3(\n         content::NotificationService::AllSources());\n@@ -210,7 +218,7 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n     EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph1);\n \n-    // Create a TYPE_EXTENSION tab.  It should be in its own process.\n+    // Create an extension tab.  It should be in its own process.\n     GURL extension_url(\""chrome-extension://\"" + extension->id());\n     ui_test_utils::WindowedTabAddedNotificationObserver observer4(\n         content::NotificationService::AllSources());\n@@ -256,13 +264,13 @@ IN_PROC_BROWSER_TEST_F(ChromeRenderProcessHostTest, MAYBE_ProcessPerTab) {\n   int tab_count = 1;\n   int host_count = 1;\n \n-  // Change the first tab to be the new tab page (TYPE_WEBUI).\n+  // Change the first tab to be a WebUI page.\n   GURL omnibox(chrome::kChromeUIOmniboxURL);\n   ui_test_utils::NavigateToURL(browser(), omnibox);\n   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n   EXPECT_EQ(host_count, RenderProcessHostCount());\n \n-  // Create a new TYPE_TABBED tab.  It should be in its own process.\n+  // Create a new normal tab with a data URL.  It should be in its own process.\n   GURL page1(\""data:text/html,hello world1\"");\n   ui_test_utils::WindowedTabAddedNotificationObserver observer1(\n       content::NotificationService::AllSources());\n@@ -273,13 +281,16 @@ IN_PROC_BROWSER_TEST_F(ChromeRenderProcessHostTest, MAYBE_ProcessPerTab) {\n   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n   EXPECT_EQ(host_count, RenderProcessHostCount());\n \n-  // Create another TYPE_TABBED tab.  It should share the previous process.\n+  // Create another data URL tab.  With Site Isolation, this will require its\n+  // own process, but without Site Isolation, it can share the previous process.\n   GURL page2(\""data:text/html,hello world2\"");\n   ui_test_utils::WindowedTabAddedNotificationObserver observer2(\n       content::NotificationService::AllSources());\n   ::ShowSingletonTab(browser(), page2);\n   observer2.Wait();\n   tab_count++;\n+  if (content::AreAllSitesIsolatedForTesting())\n+    host_count++;\n   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n   EXPECT_EQ(host_count, RenderProcessHostCount());\n ""}<_**next**_>{""sha"": ""406302b6b76051ba0995f92ec9dc579dfe14f707"", ""filename"": ""content/browser/frame_host/render_frame_host_manager.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 15, ""changes"": 32, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/frame_host/render_frame_host_manager.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/frame_host/render_frame_host_manager.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_manager.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -1971,7 +1971,7 @@ RenderFrameHostManager::GetSiteInstanceForNavigationRequest(\n     // allowed to swap processes.\n     no_renderer_swap_allowed |= !CanSubframeSwapProcess(\n         request.common_params().url, request.source_site_instance(),\n-        request.dest_site_instance(), was_server_redirect);\n+        request.dest_site_instance());\n   }\n \n   if (no_renderer_swap_allowed)\n@@ -2543,8 +2543,7 @@ void RenderFrameHostManager::SendPageMessage(IPC::Message* msg,\n bool RenderFrameHostManager::CanSubframeSwapProcess(\n     const GURL& dest_url,\n     SiteInstance* source_instance,\n-    SiteInstance* dest_instance,\n-    bool was_server_redirect) {\n+    SiteInstance* dest_instance) {\n   // On renderer-initiated navigations, when the frame initiating the navigation\n   // and the frame being navigated differ, |source_instance| is set to the\n   // SiteInstance of the initiating frame. |dest_instance| is present on session\n@@ -2561,22 +2560,25 @@ bool RenderFrameHostManager::CanSubframeSwapProcess(\n       resolved_url = dest_instance->GetSiteURL();\n     } else {\n       // If there is no SiteInstance this unique origin can be associated with,\n-      // there are two cases:\n-      // (1) If there was a server redirect, allow a process swap.  Normally,\n-      // redirects to data: or about: URLs are disallowed as\n+      // then check whether it is safe to put into the parent frame's process.\n+      // This is the case for about:blank URLs (with or without fragments),\n+      // since they contain no active data.  This is also the case for\n+      // about:srcdoc, since such URLs only get active content from their parent\n+      // frame.  Using the parent frame's process avoids putting blank frames\n+      // into OOPIFs and preserves scripting for about:srcdoc.\n+      //\n+      // Allow a process swap for other unique origin URLs, such as data: URLs.\n+      // These have active content and may have come from an untrusted source,\n+      // such as a restored frame from a different site or a redirect.\n+      // (Normally, redirects to data: or about: URLs are disallowed as\n       // net::ERR_UNSAFE_REDIRECT. However, extensions can still redirect\n       // arbitary requests to those URLs using the chrome.webRequest or\n       // chrome.declarativeWebRequest API, which will end up here (for an\n-      // example, see ExtensionWebRequestApiTest.WebRequestDeclarative1).  It's\n-      // safest to swap processes for those redirects if we are in an\n-      // appropriate OOPIF-enabled mode.\n-      //\n-      // (2) Otherwise, avoid a process swap.  We can get here during session\n-      // restore, and this avoids putting all data: and about:blank subframes\n-      // in OOPIFs. We can also get here in tests with browser-initiated\n-      // subframe navigations (NavigateFrameToURL).\n-      if (!was_server_redirect)\n+      // example, see ExtensionWebRequestApiTest.WebRequestDeclarative1).)\n+      if (resolved_url.IsAboutBlank() ||\n+          resolved_url == GURL(content::kAboutSrcDocURL)) {\n         return false;\n+      }\n     }\n   }\n ""}<_**next**_>{""sha"": ""d8cf377f4e2e812080e3b65e324272f2da04270c"", ""filename"": ""content/browser/frame_host/render_frame_host_manager.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/frame_host/render_frame_host_manager.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/frame_host/render_frame_host_manager.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_manager.h?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -730,8 +730,7 @@ class CONTENT_EXPORT RenderFrameHostManager\n   // Returns true if a subframe can navigate cross-process.\n   bool CanSubframeSwapProcess(const GURL& dest_url,\n                               SiteInstance* source_instance,\n-                              SiteInstance* dest_instance,\n-                              bool was_server_redirect);\n+                              SiteInstance* dest_instance);\n \n   // After a renderer process crash we'd have marked the host as invisible, so\n   // we need to set the visibility of the new View to the correct value here""}<_**next**_>{""sha"": ""4385285e7ce5b3dc21203bf84cb686d580d7d04a"", ""filename"": ""content/browser/site_instance_impl.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 6, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_instance_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_instance_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_instance_impl.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -457,16 +457,27 @@ GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,\n     return GURL(origin.scheme() + \"":\"");\n   } else if (url.has_scheme()) {\n     // In some cases, it is not safe to use just the scheme as a site URL, as\n-    // that might allow two URLs created by different sites to to share a\n-    // process.  See https://crbug.com/863623.\n+    // that might allow two URLs created by different sites to share a process.\n+    // See https://crbug.com/863623 and https://crbug.com/863069.\n     //\n     // TODO(alexmos,creis): This should eventually be expanded to certain other\n-    // schemes, such as data: and file:.\n-    if (url.SchemeIsBlob()) {\n+    // schemes, such as file:.\n+    // TODO(creis): This currently causes problems with tests on Android and\n+    // Android WebView.  For now, skip it when Site Isolation is not enabled,\n+    // since there's no need to isolate data and blob URLs from each other in\n+    // that case.\n+    bool is_site_isolation_enabled =\n+        SiteIsolationPolicy::UseDedicatedProcessesForAllSites() ||\n+        SiteIsolationPolicy::AreIsolatedOriginsEnabled();\n+    if (is_site_isolation_enabled &&\n+        (url.SchemeIsBlob() || url.scheme() == url::kDataScheme)) {\n       // We get here for blob URLs of form blob:null/guid.  Use the full URL\n       // with the guid in that case, which isolates all blob URLs with unique\n-      // origins from each other.  Remove hash from the URL, since\n-      // same-document navigations shouldn't use a different site URL.\n+      // origins from each other.  We also get here for browser-initiated\n+      // navigations to data URLs, which have a unique origin and should only\n+      // share a process when they are identical.  Remove hash from the URL in\n+      // either case, since same-document navigations shouldn't use a different\n+      // site URL.\n       if (url.has_ref()) {\n         GURL::Replacements replacements;\n         replacements.ClearRef();""}<_**next**_>{""sha"": ""66159134d65a635172ee4b476d83e43fc6cb0656"", ""filename"": ""content/browser/site_instance_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 7, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_instance_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_instance_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_instance_impl_unittest.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -316,12 +316,25 @@ TEST_F(SiteInstanceTest, GetSiteForURL) {\n   EXPECT_EQ(\""file\"", site_url.scheme());\n   EXPECT_FALSE(site_url.has_host());\n \n-  // Data URLs should include the scheme.\n+  // Data URLs should include the whole URL, except for the hash, when Site\n+  // Isolation is enabled.  Otherwise they just include the scheme.\n   test_url = GURL(\""data:text/html,foo\"");\n   site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n-  EXPECT_EQ(GURL(\""data:\""), site_url);\n+  if (AreAllSitesIsolatedForTesting())\n+    EXPECT_EQ(test_url, site_url);\n+  else\n+    EXPECT_EQ(GURL(\""data:\""), site_url);\n   EXPECT_EQ(\""data\"", site_url.scheme());\n   EXPECT_FALSE(site_url.has_host());\n+  test_url = GURL(\""data:text/html,foo#bar\"");\n+  site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n+  EXPECT_FALSE(site_url.has_ref());\n+  if (AreAllSitesIsolatedForTesting()) {\n+    EXPECT_NE(test_url, site_url);\n+    EXPECT_TRUE(site_url.EqualsIgnoringRef(test_url));\n+  } else {\n+    EXPECT_EQ(GURL(\""data:\""), site_url);\n+  }\n \n   // Javascript URLs should include the scheme.\n   test_url = GURL(\""javascript:foo();\"");\n@@ -344,16 +357,24 @@ TEST_F(SiteInstanceTest, GetSiteForURL) {\n   EXPECT_EQ(\""file\"", site_url.scheme());\n   EXPECT_FALSE(site_url.has_host());\n \n-  // Blob URLs created from a unique origin use the full URL as the site URL,\n-  // except for the hash.\n+  // Blob URLs created from a unique origin use the full URL as the site URL\n+  // when Site Isolation is enabled, except for the hash.  Otherwise they just\n+  // include the scheme.\n   test_url = GURL(\""blob:null/1029e5a4-2983-4b90-a585-ed217563acfeb\"");\n   site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n-  EXPECT_EQ(site_url, test_url);\n+  if (AreAllSitesIsolatedForTesting())\n+    EXPECT_EQ(test_url, site_url);\n+  else\n+    EXPECT_EQ(GURL(\""blob:\""), site_url);\n   test_url = GURL(\""blob:null/1029e5a4-2983-4b90-a585-ed217563acfeb#foo\"");\n   site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n-  EXPECT_NE(site_url, test_url);\n   EXPECT_FALSE(site_url.has_ref());\n-  EXPECT_TRUE(site_url.EqualsIgnoringRef(test_url));\n+  if (AreAllSitesIsolatedForTesting()) {\n+    EXPECT_NE(test_url, site_url);\n+    EXPECT_TRUE(site_url.EqualsIgnoringRef(test_url));\n+  } else {\n+    EXPECT_EQ(GURL(\""blob:\""), site_url);\n+  }\n \n   // Private domains are preserved, appspot being such a site.\n   test_url = GURL(""}<_**next**_>{""sha"": ""26dbd2cdf254fb8c0d6fa5606165f7128afacb92"", ""filename"": ""content/browser/site_per_process_browsertest.cc"", ""status"": ""modified"", ""additions"": 283, ""deletions"": 3, ""changes"": 286, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_per_process_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_per_process_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_per_process_browsertest.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -7289,8 +7289,8 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n }\n \n // Ensures that navigating to data: URLs present in session history will\n-// correctly commit the navigation in the same process as the parent frame.\n-// See https://crbug.com/606996.\n+// correctly commit the navigation in the same process as the one used for the\n+// original navigation. See https://crbug.com/606996.\n IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n                        NavigateSubframeToDataUrlInSessionHistory) {\n   GURL main_url(embedded_test_server()->GetURL(\n@@ -7316,7 +7316,7 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n   EXPECT_TRUE(observer.last_navigation_succeeded());\n   EXPECT_EQ(data_url, observer.last_navigation_url());\n   scoped_refptr<SiteInstanceImpl> orig_site_instance =\n-    child->current_frame_host()->GetSiteInstance();\n+      child->current_frame_host()->GetSiteInstance();\n   EXPECT_NE(root->current_frame_host()->GetSiteInstance(), orig_site_instance);\n \n   // Navigate it to another cross-site url.\n@@ -7336,6 +7336,286 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n   EXPECT_EQ(orig_site_instance, child->current_frame_host()->GetSiteInstance());\n }\n \n+// Ensures that subframes navigated to data: URLs start in a process based on\n+// their creator, but end up in unique processes after a restore (since\n+// SiteInstance relationships are not preserved on restore, until\n+// https://crbug.com/14987 is fixed).  This is better than restoring into the\n+// parent process, per https://crbug.com/863069.\n+IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n+                       SubframeDataUrlsAfterRestore) {\n+  // We must use a page that has iframes in the HTML here, unlike\n+  // cross_site_iframe_factory.html which loads them dynamically.  In the latter\n+  // case, Chrome will not restore subframe URLs from history, which is needed\n+  // for this test.\n+  GURL main_url(embedded_test_server()->GetURL(\n+      \""a.com\"", \""/frame_tree/page_with_two_iframes.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+\n+  FrameTreeNode* root = web_contents()->GetFrameTree()->root();\n+  EXPECT_EQ(2U, root->child_count());\n+  EXPECT_EQ(\n+      \"" Site A ------------ proxies for B C\\n\""\n+      \""   |--Site B ------- proxies for A C\\n\""\n+      \""   +--Site C ------- proxies for A B\\n\""\n+      \""Where A = http://a.com/\\n\""\n+      \""      B = http://bar.com/\\n\""\n+      \""      C = http://baz.com/\"",\n+      DepictFrameTree(root));\n+\n+  FrameTreeNode* child_0 = root->child_at(0);\n+  FrameTreeNode* child_1 = root->child_at(1);\n+  scoped_refptr<SiteInstanceImpl> child_site_instance_0 =\n+      child_0->current_frame_host()->GetSiteInstance();\n+  scoped_refptr<SiteInstanceImpl> child_site_instance_1 =\n+      child_1->current_frame_host()->GetSiteInstance();\n+\n+  // Navigate the iframes to data URLs via renderer initiated navigations, which\n+  // will commit in the existing SiteInstances.\n+  TestNavigationObserver observer(shell()->web_contents());\n+  GURL data_url_0(\""data:text/html,dataurl_0\"");\n+  {\n+    TestFrameNavigationObserver commit_observer(child_0);\n+    EXPECT_TRUE(\n+        ExecuteScript(child_0, \""location.href = '\"" + data_url_0.spec() + \""';\""));\n+    commit_observer.WaitForCommit();\n+  }\n+  EXPECT_TRUE(observer.last_navigation_succeeded());\n+  EXPECT_EQ(data_url_0, observer.last_navigation_url());\n+  EXPECT_EQ(child_site_instance_0,\n+            child_0->current_frame_host()->GetSiteInstance());\n+\n+  GURL data_url_1(\""data:text/html,dataurl_1\"");\n+  {\n+    TestFrameNavigationObserver commit_observer(child_1);\n+    EXPECT_TRUE(\n+        ExecuteScript(child_1, \""location.href = '\"" + data_url_1.spec() + \""';\""));\n+    commit_observer.WaitForCommit();\n+  }\n+  EXPECT_TRUE(observer.last_navigation_succeeded());\n+  EXPECT_EQ(data_url_1, observer.last_navigation_url());\n+  EXPECT_EQ(child_site_instance_1,\n+            child_1->current_frame_host()->GetSiteInstance());\n+\n+  // Grab the NavigationEntry and clone its PageState into a new entry for\n+  // restoring into a new tab.\n+  const NavigationControllerImpl& controller =\n+      static_cast<const NavigationControllerImpl&>(\n+          shell()->web_contents()->GetController());\n+  NavigationEntryImpl* entry = controller.GetLastCommittedEntry();\n+  std::unique_ptr<NavigationEntryImpl> restored_entry =\n+      NavigationEntryImpl::FromNavigationEntry(\n+          NavigationController::CreateNavigationEntry(\n+              main_url, Referrer(), ui::PAGE_TRANSITION_RELOAD, false,\n+              std::string(), controller.GetBrowserContext(),\n+              nullptr /* blob_url_loader_factory */));\n+  EXPECT_EQ(0U, restored_entry->root_node()->children.size());\n+  restored_entry->SetPageState(entry->GetPageState());\n+  ASSERT_EQ(2U, restored_entry->root_node()->children.size());\n+\n+  // Restore the NavigationEntry into a new tab and check that the data URLs are\n+  // not loaded into the parent's SiteInstance.\n+  std::vector<std::unique_ptr<NavigationEntry>> entries;\n+  entries.push_back(std::move(restored_entry));\n+  Shell* new_shell = Shell::CreateNewWindow(\n+      controller.GetBrowserContext(), GURL::EmptyGURL(), nullptr, gfx::Size());\n+  FrameTreeNode* new_root =\n+      static_cast<WebContentsImpl*>(new_shell->web_contents())\n+          ->GetFrameTree()\n+          ->root();\n+  NavigationControllerImpl& new_controller =\n+      static_cast<NavigationControllerImpl&>(\n+          new_shell->web_contents()->GetController());\n+  new_controller.Restore(entries.size() - 1,\n+                         RestoreType::LAST_SESSION_EXITED_CLEANLY, &entries);\n+  ASSERT_EQ(0u, entries.size());\n+  {\n+    TestNavigationObserver restore_observer(new_shell->web_contents());\n+    new_controller.LoadIfNecessary();\n+    restore_observer.Wait();\n+  }\n+  ASSERT_EQ(2U, new_root->child_count());\n+  EXPECT_EQ(main_url, new_root->current_url());\n+  EXPECT_EQ(\""data\"", new_root->child_at(0)->current_url().scheme());\n+  EXPECT_EQ(\""data\"", new_root->child_at(1)->current_url().scheme());\n+\n+  EXPECT_NE(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(0)->current_frame_host()->GetSiteInstance());\n+  EXPECT_NE(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(1)->current_frame_host()->GetSiteInstance());\n+  EXPECT_NE(new_root->child_at(0)->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(1)->current_frame_host()->GetSiteInstance());\n+}\n+\n+// Similar to SubframeDataUrlsAfterRestore, but ensures that about:blank frames\n+// do get put into their parent process after restore, even if they weren't\n+// originally.  This is safe because they do not contain active content (even\n+// when there's a fragment in the URL), and it avoids unnecessary OOPIFs.\n+IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n+                       SubframeBlankUrlsAfterRestore) {\n+  // We must use a page that has iframes in the HTML here, unlike\n+  // cross_site_iframe_factory.html which loads them dynamically.  In the latter\n+  // case, Chrome will not restore subframe URLs from history, which is needed\n+  // for this test.\n+  GURL main_url(embedded_test_server()->GetURL(\n+      \""a.com\"", \""/frame_tree/page_with_two_iframes.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+\n+  FrameTreeNode* root = web_contents()->GetFrameTree()->root();\n+  EXPECT_EQ(2U, root->child_count());\n+  EXPECT_EQ(\n+      \"" Site A ------------ proxies for B C\\n\""\n+      \""   |--Site B ------- proxies for A C\\n\""\n+      \""   +--Site C ------- proxies for A B\\n\""\n+      \""Where A = http://a.com/\\n\""\n+      \""      B = http://bar.com/\\n\""\n+      \""      C = http://baz.com/\"",\n+      DepictFrameTree(root));\n+\n+  FrameTreeNode* child_0 = root->child_at(0);\n+  FrameTreeNode* child_1 = root->child_at(1);\n+  scoped_refptr<SiteInstanceImpl> child_site_instance_0 =\n+      child_0->current_frame_host()->GetSiteInstance();\n+  scoped_refptr<SiteInstanceImpl> child_site_instance_1 =\n+      child_1->current_frame_host()->GetSiteInstance();\n+\n+  // Navigate the iframes to about:blank URLs via renderer initiated\n+  // navigations, which will commit in the existing SiteInstances.\n+  TestNavigationObserver observer(shell()->web_contents());\n+  GURL blank_url(\""about:blank\"");\n+  {\n+    TestFrameNavigationObserver commit_observer(child_0);\n+    EXPECT_TRUE(\n+        ExecuteScript(child_0, \""location.href = '\"" + blank_url.spec() + \""';\""));\n+    commit_observer.WaitForCommit();\n+  }\n+  EXPECT_TRUE(observer.last_navigation_succeeded());\n+  EXPECT_EQ(blank_url, observer.last_navigation_url());\n+  EXPECT_EQ(child_site_instance_0,\n+            child_0->current_frame_host()->GetSiteInstance());\n+\n+  GURL blank_url_ref(\""about:blank#1\"");\n+  {\n+    TestFrameNavigationObserver commit_observer(child_1);\n+    EXPECT_TRUE(ExecuteScript(\n+        child_1, \""location.href = '\"" + blank_url_ref.spec() + \""';\""));\n+    commit_observer.WaitForCommit();\n+  }\n+  EXPECT_TRUE(observer.last_navigation_succeeded());\n+  EXPECT_EQ(blank_url_ref, observer.last_navigation_url());\n+  EXPECT_EQ(child_site_instance_1,\n+            child_1->current_frame_host()->GetSiteInstance());\n+\n+  // Grab the NavigationEntry and clone its PageState into a new entry for\n+  // restoring into a new tab.\n+  const NavigationControllerImpl& controller =\n+      static_cast<const NavigationControllerImpl&>(\n+          shell()->web_contents()->GetController());\n+  NavigationEntryImpl* entry = controller.GetLastCommittedEntry();\n+  std::unique_ptr<NavigationEntryImpl> restored_entry =\n+      NavigationEntryImpl::FromNavigationEntry(\n+          NavigationController::CreateNavigationEntry(\n+              main_url, Referrer(), ui::PAGE_TRANSITION_RELOAD, false,\n+              std::string(), controller.GetBrowserContext(),\n+              nullptr /* blob_url_loader_factory */));\n+  EXPECT_EQ(0U, restored_entry->root_node()->children.size());\n+  restored_entry->SetPageState(entry->GetPageState());\n+  ASSERT_EQ(2U, restored_entry->root_node()->children.size());\n+\n+  // Restore the NavigationEntry into a new tab and check that the data URLs are\n+  // not loaded into the parent's SiteInstance.\n+  std::vector<std::unique_ptr<NavigationEntry>> entries;\n+  entries.push_back(std::move(restored_entry));\n+  Shell* new_shell = Shell::CreateNewWindow(\n+      controller.GetBrowserContext(), GURL::EmptyGURL(), nullptr, gfx::Size());\n+  FrameTreeNode* new_root =\n+      static_cast<WebContentsImpl*>(new_shell->web_contents())\n+          ->GetFrameTree()\n+          ->root();\n+  NavigationControllerImpl& new_controller =\n+      static_cast<NavigationControllerImpl&>(\n+          new_shell->web_contents()->GetController());\n+  new_controller.Restore(entries.size() - 1,\n+                         RestoreType::LAST_SESSION_EXITED_CLEANLY, &entries);\n+  ASSERT_EQ(0u, entries.size());\n+  {\n+    TestNavigationObserver restore_observer(new_shell->web_contents());\n+    new_controller.LoadIfNecessary();\n+    restore_observer.Wait();\n+  }\n+  ASSERT_EQ(2U, new_root->child_count());\n+  EXPECT_EQ(main_url, new_root->current_url());\n+  EXPECT_TRUE(new_root->child_at(0)->current_url().IsAboutBlank());\n+  EXPECT_TRUE(new_root->child_at(1)->current_url().IsAboutBlank());\n+\n+  EXPECT_EQ(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(0)->current_frame_host()->GetSiteInstance());\n+  EXPECT_EQ(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(1)->current_frame_host()->GetSiteInstance());\n+}\n+\n+// Similar to SubframeBlankUrlsAfterRestore, but ensures that about:srcdoc ends\n+// up in its parent's process after restore, since that's where its content\n+// comes from.\n+IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n+                       SubframeSrcdocUrlAfterRestore) {\n+  // Load a page that uses iframe srcdoc.\n+  GURL main_url(embedded_test_server()->GetURL(\n+      \""a.com\"", \""/frame_tree/page_with_srcdoc_frame.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+\n+  FrameTreeNode* root = web_contents()->GetFrameTree()->root();\n+  EXPECT_EQ(1U, root->child_count());\n+  FrameTreeNode* child = root->child_at(0);\n+  scoped_refptr<SiteInstanceImpl> child_site_instance =\n+      child->current_frame_host()->GetSiteInstance();\n+  EXPECT_EQ(child_site_instance, root->current_frame_host()->GetSiteInstance());\n+\n+  // Grab the NavigationEntry and clone its PageState into a new entry for\n+  // restoring into a new tab.\n+  const NavigationControllerImpl& controller =\n+      static_cast<const NavigationControllerImpl&>(\n+          shell()->web_contents()->GetController());\n+  NavigationEntryImpl* entry = controller.GetLastCommittedEntry();\n+  std::unique_ptr<NavigationEntryImpl> restored_entry =\n+      NavigationEntryImpl::FromNavigationEntry(\n+          NavigationController::CreateNavigationEntry(\n+              main_url, Referrer(), ui::PAGE_TRANSITION_RELOAD, false,\n+              std::string(), controller.GetBrowserContext(),\n+              nullptr /* blob_url_loader_factory */));\n+  EXPECT_EQ(0U, restored_entry->root_node()->children.size());\n+  restored_entry->SetPageState(entry->GetPageState());\n+  ASSERT_EQ(1U, restored_entry->root_node()->children.size());\n+\n+  // Restore the NavigationEntry into a new tab and check that the srcdoc URLs\n+  // are still loaded into the parent's SiteInstance.\n+  std::vector<std::unique_ptr<NavigationEntry>> entries;\n+  entries.push_back(std::move(restored_entry));\n+  Shell* new_shell = Shell::CreateNewWindow(\n+      controller.GetBrowserContext(), GURL::EmptyGURL(), nullptr, gfx::Size());\n+  FrameTreeNode* new_root =\n+      static_cast<WebContentsImpl*>(new_shell->web_contents())\n+          ->GetFrameTree()\n+          ->root();\n+  NavigationControllerImpl& new_controller =\n+      static_cast<NavigationControllerImpl&>(\n+          new_shell->web_contents()->GetController());\n+  new_controller.Restore(entries.size() - 1,\n+                         RestoreType::LAST_SESSION_EXITED_CLEANLY, &entries);\n+  ASSERT_EQ(0u, entries.size());\n+  {\n+    TestNavigationObserver restore_observer(new_shell->web_contents());\n+    new_controller.LoadIfNecessary();\n+    restore_observer.Wait();\n+  }\n+  ASSERT_EQ(1U, new_root->child_count());\n+  EXPECT_EQ(main_url, new_root->current_url());\n+  EXPECT_EQ(GURL(content::kAboutSrcDocURL),\n+            new_root->child_at(0)->current_url());\n+\n+  EXPECT_EQ(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(0)->current_frame_host()->GetSiteInstance());\n+}\n+\n // Ensures that navigating to about:blank URLs present in session history will\n // correctly commit the navigation in the same process as the one used for\n // the original navigation.""}<_**next**_>{""sha"": ""a5bce3fd2565d8f458555a0c6f42d0504a848bd5"", ""filename"": ""third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-1.html"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-1.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-1.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-1.html?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -0,0 +1 @@\n+test1""}<_**next**_>{""sha"": ""180cf8328022becee9aaa2577a8f84ea2b9f3827"", ""filename"": ""third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-2.html"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-2.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-2.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-2.html?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -0,0 +1 @@\n+test2""}<_**next**_>{""sha"": ""b8ae010756f6d0452c849c17607ab4bd3f11670b"", ""filename"": ""third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child.html"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child.html?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -1,9 +1,10 @@\n <p>This tests that navigating to two pages in a subframe, and then going back does not cause an assertion.</p>\n <p>SUCCESS - Didn't assert!</p>\n <script>\n+\n if (window.testRunner) {\n-    testRunner.queueLoad('data:text/html,test1', 'target')\n-    testRunner.queueLoad('data:text/html,test2', 'target')\n+    testRunner.queueLoad('resources/frame-navigation-child-1.html', 'target')\n+    testRunner.queueLoad('resources/frame-navigation-child-2.html', 'target')\n     testRunner.queueBackNavigation(1);\n } else\n     document.write('This test must be run by DumpRenderTree!')""}","RenderFrameHostManager::GetSiteInstanceForNavigationRequest(
    const NavigationRequest& request) {
  SiteInstance* current_site_instance = render_frame_host_->GetSiteInstance();
  bool no_renderer_swap_allowed = false;
  bool was_server_redirect = request.navigation_handle() &&
                             request.navigation_handle()->WasServerRedirect();

  if (frame_tree_node_->IsMainFrame()) {
    bool can_renderer_initiate_transfer =
        (request.state() == NavigationRequest::FAILED &&
         SiteIsolationPolicy::IsErrorPageIsolationEnabled(
             true /* in_main_frame */)) ||
        (render_frame_host_->IsRenderFrameLive() &&
         IsURLHandledByNetworkStack(request.common_params().url) &&
         IsRendererTransferNeededForNavigation(render_frame_host_.get(),
                                               request.common_params().url));
    no_renderer_swap_allowed |=
        request.from_begin_navigation() && !can_renderer_initiate_transfer;
  } else {
     no_renderer_swap_allowed |= !CanSubframeSwapProcess(
         request.common_params().url, request.source_site_instance(),
        request.dest_site_instance());
   }
 
   if (no_renderer_swap_allowed)
    return scoped_refptr<SiteInstance>(current_site_instance);

  SiteInstance* candidate_site_instance =
      speculative_render_frame_host_
          ? speculative_render_frame_host_->GetSiteInstance()
          : nullptr;

  scoped_refptr<SiteInstance> dest_site_instance = GetSiteInstanceForNavigation(
      request.common_params().url, request.source_site_instance(),
      request.dest_site_instance(), candidate_site_instance,
      request.common_params().transition,
      request.state() == NavigationRequest::FAILED,
      request.restore_type() != RestoreType::NONE, request.is_view_source(),
      was_server_redirect);

  return dest_site_instance;
}
","RenderFrameHostManager::GetSiteInstanceForNavigationRequest(
    const NavigationRequest& request) {
  SiteInstance* current_site_instance = render_frame_host_->GetSiteInstance();
  bool no_renderer_swap_allowed = false;
  bool was_server_redirect = request.navigation_handle() &&
                             request.navigation_handle()->WasServerRedirect();

  if (frame_tree_node_->IsMainFrame()) {
    bool can_renderer_initiate_transfer =
        (request.state() == NavigationRequest::FAILED &&
         SiteIsolationPolicy::IsErrorPageIsolationEnabled(
             true /* in_main_frame */)) ||
        (render_frame_host_->IsRenderFrameLive() &&
         IsURLHandledByNetworkStack(request.common_params().url) &&
         IsRendererTransferNeededForNavigation(render_frame_host_.get(),
                                               request.common_params().url));
    no_renderer_swap_allowed |=
        request.from_begin_navigation() && !can_renderer_initiate_transfer;
  } else {
     no_renderer_swap_allowed |= !CanSubframeSwapProcess(
         request.common_params().url, request.source_site_instance(),
        request.dest_site_instance(), was_server_redirect);
   }
 
   if (no_renderer_swap_allowed)
    return scoped_refptr<SiteInstance>(current_site_instance);

  SiteInstance* candidate_site_instance =
      speculative_render_frame_host_
          ? speculative_render_frame_host_->GetSiteInstance()
          : nullptr;

  scoped_refptr<SiteInstance> dest_site_instance = GetSiteInstanceForNavigation(
      request.common_params().url, request.source_site_instance(),
      request.dest_site_instance(), candidate_site_instance,
      request.common_params().transition,
      request.state() == NavigationRequest::FAILED,
      request.restore_type() != RestoreType::NONE, request.is_view_source(),
      was_server_redirect);

  return dest_site_instance;
}
",C,"        request.dest_site_instance());
","        request.dest_site_instance(), was_server_redirect);
",,"@@ -1971,7 +1971,7 @@ RenderFrameHostManager::GetSiteInstanceForNavigationRequest(
     // allowed to swap processes.
     no_renderer_swap_allowed |= !CanSubframeSwapProcess(
         request.common_params().url, request.source_site_instance(),
-        request.dest_site_instance(), was_server_redirect);
+        request.dest_site_instance());
   }
 
   if (no_renderer_swap_allowed)
@@ -2543,8 +2543,7 @@ void RenderFrameHostManager::SendPageMessage(IPC::Message* msg,
 bool RenderFrameHostManager::CanSubframeSwapProcess(
     const GURL& dest_url,
     SiteInstance* source_instance,
-    SiteInstance* dest_instance,
-    bool was_server_redirect) {
+    SiteInstance* dest_instance) {
   // On renderer-initiated navigations, when the frame initiating the navigation
   // and the frame being navigated differ, |source_instance| is set to the
   // SiteInstance of the initiating frame. |dest_instance| is present on session
@@ -2561,22 +2560,25 @@ bool RenderFrameHostManager::CanSubframeSwapProcess(
       resolved_url = dest_instance->GetSiteURL();
     } else {
       // If there is no SiteInstance this unique origin can be associated with,
-      // there are two cases:
-      // (1) If there was a server redirect, allow a process swap.  Normally,
-      // redirects to data: or about: URLs are disallowed as
+      // then check whether it is safe to put into the parent frame's process.
+      // This is the case for about:blank URLs (with or without fragments),
+      // since they contain no active data.  This is also the case for
+      // about:srcdoc, since such URLs only get active content from their parent
+      // frame.  Using the parent frame's process avoids putting blank frames
+      // into OOPIFs and preserves scripting for about:srcdoc.
+      //
+      // Allow a process swap for other unique origin URLs, such as data: URLs.
+      // These have active content and may have come from an untrusted source,
+      // such as a restored frame from a different site or a redirect.
+      // (Normally, redirects to data: or about: URLs are disallowed as
       // net::ERR_UNSAFE_REDIRECT. However, extensions can still redirect
       // arbitary requests to those URLs using the chrome.webRequest or
       // chrome.declarativeWebRequest API, which will end up here (for an
-      // example, see ExtensionWebRequestApiTest.WebRequestDeclarative1).  It's
-      // safest to swap processes for those redirects if we are in an
-      // appropriate OOPIF-enabled mode.
-      //
-      // (2) Otherwise, avoid a process swap.  We can get here during session
-      // restore, and this avoids putting all data: and about:blank subframes
-      // in OOPIFs. We can also get here in tests with browser-initiated
-      // subframe navigations (NavigateFrameToURL).
-      if (!was_server_redirect)
+      // example, see ExtensionWebRequestApiTest.WebRequestDeclarative1).)
+      if (resolved_url.IsAboutBlank() ||
+          resolved_url == GURL(content::kAboutSrcDocURL)) {
         return false;
+      }
     }
   }
 ",Chrome,0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca,659c9e34e14cfcecf33f2b2e52aa133db5806fa2,1,"RenderFrameHostManager::GetSiteInstanceForNavigationRequest(
    const NavigationRequest& request) {
  // First, check if the navigation can switch SiteInstances. If not, the
  // navigation should use the current SiteInstance.
  SiteInstance* current_site_instance = render_frame_host_->GetSiteInstance();
  bool no_renderer_swap_allowed = false;
  bool was_server_redirect = request.navigation_handle() &&
                             request.navigation_handle()->WasServerRedirect();

  if (frame_tree_node_->IsMainFrame()) {
    // Renderer-initiated main frame navigations that may require a
    // SiteInstance swap are sent to the browser via the OpenURL IPC and are
    // afterwards treated as browser-initiated navigations. NavigationRequests
    // marked as renderer-initiated are created by receiving a BeginNavigation
    // IPC, and will then proceed in the same renderer. In site-per-process
    // mode, it is possible for renderer-intiated navigations to be allowed to
    // go cross-process. Main frame navigations resulting in an error are also
    // expected to change process. Check it first.
    bool can_renderer_initiate_transfer =
        (request.state() == NavigationRequest::FAILED &&
         SiteIsolationPolicy::IsErrorPageIsolationEnabled(
             true /* in_main_frame */)) ||
        (render_frame_host_->IsRenderFrameLive() &&
         IsURLHandledByNetworkStack(request.common_params().url) &&
         IsRendererTransferNeededForNavigation(render_frame_host_.get(),
                                               request.common_params().url));
    no_renderer_swap_allowed |=
        request.from_begin_navigation() && !can_renderer_initiate_transfer;
  } else {
    // Subframe navigations will use the current renderer, unless specifically
     // allowed to swap processes.
     no_renderer_swap_allowed |= !CanSubframeSwapProcess(
         request.common_params().url, request.source_site_instance(),
//flaw_line_below:
        request.dest_site_instance(), was_server_redirect);
//fix_flaw_line_below:
//        request.dest_site_instance());
   }
 
   if (no_renderer_swap_allowed)
    return scoped_refptr<SiteInstance>(current_site_instance);

  // If the navigation can swap SiteInstances, compute the SiteInstance it
  // should use.
  // TODO(clamy): We should also consider as a candidate SiteInstance the
  // speculative SiteInstance that was computed on redirects.
  SiteInstance* candidate_site_instance =
      speculative_render_frame_host_
          ? speculative_render_frame_host_->GetSiteInstance()
          : nullptr;

  scoped_refptr<SiteInstance> dest_site_instance = GetSiteInstanceForNavigation(
      request.common_params().url, request.source_site_instance(),
      request.dest_site_instance(), candidate_site_instance,
      request.common_params().transition,
      request.state() == NavigationRequest::FAILED,
      request.restore_type() != RestoreType::NONE, request.is_view_source(),
      was_server_redirect);

  return dest_site_instance;
}
"
9438,187174,,Remote,Not required,,CVE-2018-16073,https://www.cvedetails.com/cve/CVE-2018-16073/,CWE-285,Medium,Partial,,,2019-06-27,4.3,Insufficient policy enforcement in site isolation in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass site isolation via a crafted HTML page.,2019-07-01,Bypass ,17,https://github.com/chromium/chromium/commit/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca,0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca,"Use unique processes for data URLs on restore.

Data URLs are usually put into the process that created them, but this
info is not tracked after a tab restore.  Ensure that they do not end up
in the parent frame's process (or each other's process), in case they
are malicious.

BUG=863069

Change-Id: Ib391f90c7bdf28a0a9c057c5cc7918c10aed968b
Reviewed-on: https://chromium-review.googlesource.com/1150767
Reviewed-by: Alex Moshchuk <alexmos@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Commit-Queue: Charlie Reis <creis@chromium.org>
Cr-Commit-Position: refs/heads/master@{#581023}",1,content/browser/site_instance_impl.cc,"{""sha"": ""53bcd4ac40273b55e101c55172ad64938fb52f0f"", ""filename"": ""chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 13, ""changes"": 37, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/renderer_host/render_process_host_chrome_browsertest.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -32,6 +32,7 @@\n #include \""content/public/browser/web_contents_observer.h\""\n #include \""content/public/common/content_switches.h\""\n #include \""content/public/test/browser_test_utils.h\""\n+#include \""content/public/test/test_utils.h\""\n #include \""media/base/media_switches.h\""\n #include \""net/base/filename_util.h\""\n #include \""net/test/embedded_test_server/embedded_test_server.h\""\n@@ -155,7 +156,7 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {\n     const extensions::Extension* extension =\n         LoadExtension(test_data_dir_.AppendASCII(\""options_page\""));\n \n-    // Change the first tab to be the omnibox page (TYPE_WEBUI).\n+    // Change the first tab to be the omnibox page (WebUI).\n     GURL omnibox(chrome::kChromeUIOmniboxURL);\n     ui_test_utils::NavigateToURL(browser(), omnibox);\n     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n@@ -164,7 +165,7 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {\n     EXPECT_EQ(omnibox, tab1->GetURL());\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n \n-    // Create a new TYPE_TABBED tab.  It should be in its own process.\n+    // Create a new normal tab with a data URL. It should be in its own process.\n     GURL page1(\""data:text/html,hello world1\"");\n \n     ui_test_utils::WindowedTabAddedNotificationObserver observer1(\n@@ -181,23 +182,30 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n     EXPECT_NE(rph1, rph2);\n \n-    // Create another TYPE_TABBED tab.  It should share the previous process.\n+    // Create another data URL tab.  With Site Isolation, this will require its\n+    // own process, but without Site Isolation, it can share the previous\n+    // process.\n     GURL page2(\""data:text/html,hello world2\"");\n     ui_test_utils::WindowedTabAddedNotificationObserver observer2(\n         content::NotificationService::AllSources());\n     ::ShowSingletonTab(browser(), page2);\n     observer2.Wait();\n     tab_count++;\n+    if (content::AreAllSitesIsolatedForTesting())\n+      host_count++;\n     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n     tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);\n     EXPECT_EQ(tab2->GetURL(), page2);\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n-    EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);\n-\n-    // Create another TYPE_WEBUI tab.  It should share the process with omnibox.\n-    // Note: intentionally create this tab after the TYPE_TABBED tabs to\n-    // exercise bug 43448 where extension and WebUI tabs could get combined into\n-    // normal renderers.\n+    if (content::AreAllSitesIsolatedForTesting())\n+      EXPECT_NE(tab2->GetMainFrame()->GetProcess(), rph2);\n+    else\n+      EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);\n+\n+    // Create another WebUI tab.  It should share the process with omnibox.\n+    // Note: intentionally create this tab after the normal tabs to exercise bug\n+    // 43448 where extension and WebUI tabs could get combined into normal\n+    // renderers.\n     GURL history(chrome::kChromeUIHistoryURL);\n     ui_test_utils::WindowedTabAddedNotificationObserver observer3(\n         content::NotificationService::AllSources());\n@@ -210,7 +218,7 @@ class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n     EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph1);\n \n-    // Create a TYPE_EXTENSION tab.  It should be in its own process.\n+    // Create an extension tab.  It should be in its own process.\n     GURL extension_url(\""chrome-extension://\"" + extension->id());\n     ui_test_utils::WindowedTabAddedNotificationObserver observer4(\n         content::NotificationService::AllSources());\n@@ -256,13 +264,13 @@ IN_PROC_BROWSER_TEST_F(ChromeRenderProcessHostTest, MAYBE_ProcessPerTab) {\n   int tab_count = 1;\n   int host_count = 1;\n \n-  // Change the first tab to be the new tab page (TYPE_WEBUI).\n+  // Change the first tab to be a WebUI page.\n   GURL omnibox(chrome::kChromeUIOmniboxURL);\n   ui_test_utils::NavigateToURL(browser(), omnibox);\n   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n   EXPECT_EQ(host_count, RenderProcessHostCount());\n \n-  // Create a new TYPE_TABBED tab.  It should be in its own process.\n+  // Create a new normal tab with a data URL.  It should be in its own process.\n   GURL page1(\""data:text/html,hello world1\"");\n   ui_test_utils::WindowedTabAddedNotificationObserver observer1(\n       content::NotificationService::AllSources());\n@@ -273,13 +281,16 @@ IN_PROC_BROWSER_TEST_F(ChromeRenderProcessHostTest, MAYBE_ProcessPerTab) {\n   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n   EXPECT_EQ(host_count, RenderProcessHostCount());\n \n-  // Create another TYPE_TABBED tab.  It should share the previous process.\n+  // Create another data URL tab.  With Site Isolation, this will require its\n+  // own process, but without Site Isolation, it can share the previous process.\n   GURL page2(\""data:text/html,hello world2\"");\n   ui_test_utils::WindowedTabAddedNotificationObserver observer2(\n       content::NotificationService::AllSources());\n   ::ShowSingletonTab(browser(), page2);\n   observer2.Wait();\n   tab_count++;\n+  if (content::AreAllSitesIsolatedForTesting())\n+    host_count++;\n   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n   EXPECT_EQ(host_count, RenderProcessHostCount());\n ""}<_**next**_>{""sha"": ""406302b6b76051ba0995f92ec9dc579dfe14f707"", ""filename"": ""content/browser/frame_host/render_frame_host_manager.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 15, ""changes"": 32, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/frame_host/render_frame_host_manager.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/frame_host/render_frame_host_manager.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_manager.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -1971,7 +1971,7 @@ RenderFrameHostManager::GetSiteInstanceForNavigationRequest(\n     // allowed to swap processes.\n     no_renderer_swap_allowed |= !CanSubframeSwapProcess(\n         request.common_params().url, request.source_site_instance(),\n-        request.dest_site_instance(), was_server_redirect);\n+        request.dest_site_instance());\n   }\n \n   if (no_renderer_swap_allowed)\n@@ -2543,8 +2543,7 @@ void RenderFrameHostManager::SendPageMessage(IPC::Message* msg,\n bool RenderFrameHostManager::CanSubframeSwapProcess(\n     const GURL& dest_url,\n     SiteInstance* source_instance,\n-    SiteInstance* dest_instance,\n-    bool was_server_redirect) {\n+    SiteInstance* dest_instance) {\n   // On renderer-initiated navigations, when the frame initiating the navigation\n   // and the frame being navigated differ, |source_instance| is set to the\n   // SiteInstance of the initiating frame. |dest_instance| is present on session\n@@ -2561,22 +2560,25 @@ bool RenderFrameHostManager::CanSubframeSwapProcess(\n       resolved_url = dest_instance->GetSiteURL();\n     } else {\n       // If there is no SiteInstance this unique origin can be associated with,\n-      // there are two cases:\n-      // (1) If there was a server redirect, allow a process swap.  Normally,\n-      // redirects to data: or about: URLs are disallowed as\n+      // then check whether it is safe to put into the parent frame's process.\n+      // This is the case for about:blank URLs (with or without fragments),\n+      // since they contain no active data.  This is also the case for\n+      // about:srcdoc, since such URLs only get active content from their parent\n+      // frame.  Using the parent frame's process avoids putting blank frames\n+      // into OOPIFs and preserves scripting for about:srcdoc.\n+      //\n+      // Allow a process swap for other unique origin URLs, such as data: URLs.\n+      // These have active content and may have come from an untrusted source,\n+      // such as a restored frame from a different site or a redirect.\n+      // (Normally, redirects to data: or about: URLs are disallowed as\n       // net::ERR_UNSAFE_REDIRECT. However, extensions can still redirect\n       // arbitary requests to those URLs using the chrome.webRequest or\n       // chrome.declarativeWebRequest API, which will end up here (for an\n-      // example, see ExtensionWebRequestApiTest.WebRequestDeclarative1).  It's\n-      // safest to swap processes for those redirects if we are in an\n-      // appropriate OOPIF-enabled mode.\n-      //\n-      // (2) Otherwise, avoid a process swap.  We can get here during session\n-      // restore, and this avoids putting all data: and about:blank subframes\n-      // in OOPIFs. We can also get here in tests with browser-initiated\n-      // subframe navigations (NavigateFrameToURL).\n-      if (!was_server_redirect)\n+      // example, see ExtensionWebRequestApiTest.WebRequestDeclarative1).)\n+      if (resolved_url.IsAboutBlank() ||\n+          resolved_url == GURL(content::kAboutSrcDocURL)) {\n         return false;\n+      }\n     }\n   }\n ""}<_**next**_>{""sha"": ""d8cf377f4e2e812080e3b65e324272f2da04270c"", ""filename"": ""content/browser/frame_host/render_frame_host_manager.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/frame_host/render_frame_host_manager.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/frame_host/render_frame_host_manager.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_manager.h?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -730,8 +730,7 @@ class CONTENT_EXPORT RenderFrameHostManager\n   // Returns true if a subframe can navigate cross-process.\n   bool CanSubframeSwapProcess(const GURL& dest_url,\n                               SiteInstance* source_instance,\n-                              SiteInstance* dest_instance,\n-                              bool was_server_redirect);\n+                              SiteInstance* dest_instance);\n \n   // After a renderer process crash we'd have marked the host as invisible, so\n   // we need to set the visibility of the new View to the correct value here""}<_**next**_>{""sha"": ""4385285e7ce5b3dc21203bf84cb686d580d7d04a"", ""filename"": ""content/browser/site_instance_impl.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 6, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_instance_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_instance_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_instance_impl.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -457,16 +457,27 @@ GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,\n     return GURL(origin.scheme() + \"":\"");\n   } else if (url.has_scheme()) {\n     // In some cases, it is not safe to use just the scheme as a site URL, as\n-    // that might allow two URLs created by different sites to to share a\n-    // process.  See https://crbug.com/863623.\n+    // that might allow two URLs created by different sites to share a process.\n+    // See https://crbug.com/863623 and https://crbug.com/863069.\n     //\n     // TODO(alexmos,creis): This should eventually be expanded to certain other\n-    // schemes, such as data: and file:.\n-    if (url.SchemeIsBlob()) {\n+    // schemes, such as file:.\n+    // TODO(creis): This currently causes problems with tests on Android and\n+    // Android WebView.  For now, skip it when Site Isolation is not enabled,\n+    // since there's no need to isolate data and blob URLs from each other in\n+    // that case.\n+    bool is_site_isolation_enabled =\n+        SiteIsolationPolicy::UseDedicatedProcessesForAllSites() ||\n+        SiteIsolationPolicy::AreIsolatedOriginsEnabled();\n+    if (is_site_isolation_enabled &&\n+        (url.SchemeIsBlob() || url.scheme() == url::kDataScheme)) {\n       // We get here for blob URLs of form blob:null/guid.  Use the full URL\n       // with the guid in that case, which isolates all blob URLs with unique\n-      // origins from each other.  Remove hash from the URL, since\n-      // same-document navigations shouldn't use a different site URL.\n+      // origins from each other.  We also get here for browser-initiated\n+      // navigations to data URLs, which have a unique origin and should only\n+      // share a process when they are identical.  Remove hash from the URL in\n+      // either case, since same-document navigations shouldn't use a different\n+      // site URL.\n       if (url.has_ref()) {\n         GURL::Replacements replacements;\n         replacements.ClearRef();""}<_**next**_>{""sha"": ""66159134d65a635172ee4b476d83e43fc6cb0656"", ""filename"": ""content/browser/site_instance_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 7, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_instance_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_instance_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_instance_impl_unittest.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -316,12 +316,25 @@ TEST_F(SiteInstanceTest, GetSiteForURL) {\n   EXPECT_EQ(\""file\"", site_url.scheme());\n   EXPECT_FALSE(site_url.has_host());\n \n-  // Data URLs should include the scheme.\n+  // Data URLs should include the whole URL, except for the hash, when Site\n+  // Isolation is enabled.  Otherwise they just include the scheme.\n   test_url = GURL(\""data:text/html,foo\"");\n   site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n-  EXPECT_EQ(GURL(\""data:\""), site_url);\n+  if (AreAllSitesIsolatedForTesting())\n+    EXPECT_EQ(test_url, site_url);\n+  else\n+    EXPECT_EQ(GURL(\""data:\""), site_url);\n   EXPECT_EQ(\""data\"", site_url.scheme());\n   EXPECT_FALSE(site_url.has_host());\n+  test_url = GURL(\""data:text/html,foo#bar\"");\n+  site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n+  EXPECT_FALSE(site_url.has_ref());\n+  if (AreAllSitesIsolatedForTesting()) {\n+    EXPECT_NE(test_url, site_url);\n+    EXPECT_TRUE(site_url.EqualsIgnoringRef(test_url));\n+  } else {\n+    EXPECT_EQ(GURL(\""data:\""), site_url);\n+  }\n \n   // Javascript URLs should include the scheme.\n   test_url = GURL(\""javascript:foo();\"");\n@@ -344,16 +357,24 @@ TEST_F(SiteInstanceTest, GetSiteForURL) {\n   EXPECT_EQ(\""file\"", site_url.scheme());\n   EXPECT_FALSE(site_url.has_host());\n \n-  // Blob URLs created from a unique origin use the full URL as the site URL,\n-  // except for the hash.\n+  // Blob URLs created from a unique origin use the full URL as the site URL\n+  // when Site Isolation is enabled, except for the hash.  Otherwise they just\n+  // include the scheme.\n   test_url = GURL(\""blob:null/1029e5a4-2983-4b90-a585-ed217563acfeb\"");\n   site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n-  EXPECT_EQ(site_url, test_url);\n+  if (AreAllSitesIsolatedForTesting())\n+    EXPECT_EQ(test_url, site_url);\n+  else\n+    EXPECT_EQ(GURL(\""blob:\""), site_url);\n   test_url = GURL(\""blob:null/1029e5a4-2983-4b90-a585-ed217563acfeb#foo\"");\n   site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n-  EXPECT_NE(site_url, test_url);\n   EXPECT_FALSE(site_url.has_ref());\n-  EXPECT_TRUE(site_url.EqualsIgnoringRef(test_url));\n+  if (AreAllSitesIsolatedForTesting()) {\n+    EXPECT_NE(test_url, site_url);\n+    EXPECT_TRUE(site_url.EqualsIgnoringRef(test_url));\n+  } else {\n+    EXPECT_EQ(GURL(\""blob:\""), site_url);\n+  }\n \n   // Private domains are preserved, appspot being such a site.\n   test_url = GURL(""}<_**next**_>{""sha"": ""26dbd2cdf254fb8c0d6fa5606165f7128afacb92"", ""filename"": ""content/browser/site_per_process_browsertest.cc"", ""status"": ""modified"", ""additions"": 283, ""deletions"": 3, ""changes"": 286, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_per_process_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/content/browser/site_per_process_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_per_process_browsertest.cc?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -7289,8 +7289,8 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n }\n \n // Ensures that navigating to data: URLs present in session history will\n-// correctly commit the navigation in the same process as the parent frame.\n-// See https://crbug.com/606996.\n+// correctly commit the navigation in the same process as the one used for the\n+// original navigation. See https://crbug.com/606996.\n IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n                        NavigateSubframeToDataUrlInSessionHistory) {\n   GURL main_url(embedded_test_server()->GetURL(\n@@ -7316,7 +7316,7 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n   EXPECT_TRUE(observer.last_navigation_succeeded());\n   EXPECT_EQ(data_url, observer.last_navigation_url());\n   scoped_refptr<SiteInstanceImpl> orig_site_instance =\n-    child->current_frame_host()->GetSiteInstance();\n+      child->current_frame_host()->GetSiteInstance();\n   EXPECT_NE(root->current_frame_host()->GetSiteInstance(), orig_site_instance);\n \n   // Navigate it to another cross-site url.\n@@ -7336,6 +7336,286 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n   EXPECT_EQ(orig_site_instance, child->current_frame_host()->GetSiteInstance());\n }\n \n+// Ensures that subframes navigated to data: URLs start in a process based on\n+// their creator, but end up in unique processes after a restore (since\n+// SiteInstance relationships are not preserved on restore, until\n+// https://crbug.com/14987 is fixed).  This is better than restoring into the\n+// parent process, per https://crbug.com/863069.\n+IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n+                       SubframeDataUrlsAfterRestore) {\n+  // We must use a page that has iframes in the HTML here, unlike\n+  // cross_site_iframe_factory.html which loads them dynamically.  In the latter\n+  // case, Chrome will not restore subframe URLs from history, which is needed\n+  // for this test.\n+  GURL main_url(embedded_test_server()->GetURL(\n+      \""a.com\"", \""/frame_tree/page_with_two_iframes.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+\n+  FrameTreeNode* root = web_contents()->GetFrameTree()->root();\n+  EXPECT_EQ(2U, root->child_count());\n+  EXPECT_EQ(\n+      \"" Site A ------------ proxies for B C\\n\""\n+      \""   |--Site B ------- proxies for A C\\n\""\n+      \""   +--Site C ------- proxies for A B\\n\""\n+      \""Where A = http://a.com/\\n\""\n+      \""      B = http://bar.com/\\n\""\n+      \""      C = http://baz.com/\"",\n+      DepictFrameTree(root));\n+\n+  FrameTreeNode* child_0 = root->child_at(0);\n+  FrameTreeNode* child_1 = root->child_at(1);\n+  scoped_refptr<SiteInstanceImpl> child_site_instance_0 =\n+      child_0->current_frame_host()->GetSiteInstance();\n+  scoped_refptr<SiteInstanceImpl> child_site_instance_1 =\n+      child_1->current_frame_host()->GetSiteInstance();\n+\n+  // Navigate the iframes to data URLs via renderer initiated navigations, which\n+  // will commit in the existing SiteInstances.\n+  TestNavigationObserver observer(shell()->web_contents());\n+  GURL data_url_0(\""data:text/html,dataurl_0\"");\n+  {\n+    TestFrameNavigationObserver commit_observer(child_0);\n+    EXPECT_TRUE(\n+        ExecuteScript(child_0, \""location.href = '\"" + data_url_0.spec() + \""';\""));\n+    commit_observer.WaitForCommit();\n+  }\n+  EXPECT_TRUE(observer.last_navigation_succeeded());\n+  EXPECT_EQ(data_url_0, observer.last_navigation_url());\n+  EXPECT_EQ(child_site_instance_0,\n+            child_0->current_frame_host()->GetSiteInstance());\n+\n+  GURL data_url_1(\""data:text/html,dataurl_1\"");\n+  {\n+    TestFrameNavigationObserver commit_observer(child_1);\n+    EXPECT_TRUE(\n+        ExecuteScript(child_1, \""location.href = '\"" + data_url_1.spec() + \""';\""));\n+    commit_observer.WaitForCommit();\n+  }\n+  EXPECT_TRUE(observer.last_navigation_succeeded());\n+  EXPECT_EQ(data_url_1, observer.last_navigation_url());\n+  EXPECT_EQ(child_site_instance_1,\n+            child_1->current_frame_host()->GetSiteInstance());\n+\n+  // Grab the NavigationEntry and clone its PageState into a new entry for\n+  // restoring into a new tab.\n+  const NavigationControllerImpl& controller =\n+      static_cast<const NavigationControllerImpl&>(\n+          shell()->web_contents()->GetController());\n+  NavigationEntryImpl* entry = controller.GetLastCommittedEntry();\n+  std::unique_ptr<NavigationEntryImpl> restored_entry =\n+      NavigationEntryImpl::FromNavigationEntry(\n+          NavigationController::CreateNavigationEntry(\n+              main_url, Referrer(), ui::PAGE_TRANSITION_RELOAD, false,\n+              std::string(), controller.GetBrowserContext(),\n+              nullptr /* blob_url_loader_factory */));\n+  EXPECT_EQ(0U, restored_entry->root_node()->children.size());\n+  restored_entry->SetPageState(entry->GetPageState());\n+  ASSERT_EQ(2U, restored_entry->root_node()->children.size());\n+\n+  // Restore the NavigationEntry into a new tab and check that the data URLs are\n+  // not loaded into the parent's SiteInstance.\n+  std::vector<std::unique_ptr<NavigationEntry>> entries;\n+  entries.push_back(std::move(restored_entry));\n+  Shell* new_shell = Shell::CreateNewWindow(\n+      controller.GetBrowserContext(), GURL::EmptyGURL(), nullptr, gfx::Size());\n+  FrameTreeNode* new_root =\n+      static_cast<WebContentsImpl*>(new_shell->web_contents())\n+          ->GetFrameTree()\n+          ->root();\n+  NavigationControllerImpl& new_controller =\n+      static_cast<NavigationControllerImpl&>(\n+          new_shell->web_contents()->GetController());\n+  new_controller.Restore(entries.size() - 1,\n+                         RestoreType::LAST_SESSION_EXITED_CLEANLY, &entries);\n+  ASSERT_EQ(0u, entries.size());\n+  {\n+    TestNavigationObserver restore_observer(new_shell->web_contents());\n+    new_controller.LoadIfNecessary();\n+    restore_observer.Wait();\n+  }\n+  ASSERT_EQ(2U, new_root->child_count());\n+  EXPECT_EQ(main_url, new_root->current_url());\n+  EXPECT_EQ(\""data\"", new_root->child_at(0)->current_url().scheme());\n+  EXPECT_EQ(\""data\"", new_root->child_at(1)->current_url().scheme());\n+\n+  EXPECT_NE(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(0)->current_frame_host()->GetSiteInstance());\n+  EXPECT_NE(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(1)->current_frame_host()->GetSiteInstance());\n+  EXPECT_NE(new_root->child_at(0)->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(1)->current_frame_host()->GetSiteInstance());\n+}\n+\n+// Similar to SubframeDataUrlsAfterRestore, but ensures that about:blank frames\n+// do get put into their parent process after restore, even if they weren't\n+// originally.  This is safe because they do not contain active content (even\n+// when there's a fragment in the URL), and it avoids unnecessary OOPIFs.\n+IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n+                       SubframeBlankUrlsAfterRestore) {\n+  // We must use a page that has iframes in the HTML here, unlike\n+  // cross_site_iframe_factory.html which loads them dynamically.  In the latter\n+  // case, Chrome will not restore subframe URLs from history, which is needed\n+  // for this test.\n+  GURL main_url(embedded_test_server()->GetURL(\n+      \""a.com\"", \""/frame_tree/page_with_two_iframes.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+\n+  FrameTreeNode* root = web_contents()->GetFrameTree()->root();\n+  EXPECT_EQ(2U, root->child_count());\n+  EXPECT_EQ(\n+      \"" Site A ------------ proxies for B C\\n\""\n+      \""   |--Site B ------- proxies for A C\\n\""\n+      \""   +--Site C ------- proxies for A B\\n\""\n+      \""Where A = http://a.com/\\n\""\n+      \""      B = http://bar.com/\\n\""\n+      \""      C = http://baz.com/\"",\n+      DepictFrameTree(root));\n+\n+  FrameTreeNode* child_0 = root->child_at(0);\n+  FrameTreeNode* child_1 = root->child_at(1);\n+  scoped_refptr<SiteInstanceImpl> child_site_instance_0 =\n+      child_0->current_frame_host()->GetSiteInstance();\n+  scoped_refptr<SiteInstanceImpl> child_site_instance_1 =\n+      child_1->current_frame_host()->GetSiteInstance();\n+\n+  // Navigate the iframes to about:blank URLs via renderer initiated\n+  // navigations, which will commit in the existing SiteInstances.\n+  TestNavigationObserver observer(shell()->web_contents());\n+  GURL blank_url(\""about:blank\"");\n+  {\n+    TestFrameNavigationObserver commit_observer(child_0);\n+    EXPECT_TRUE(\n+        ExecuteScript(child_0, \""location.href = '\"" + blank_url.spec() + \""';\""));\n+    commit_observer.WaitForCommit();\n+  }\n+  EXPECT_TRUE(observer.last_navigation_succeeded());\n+  EXPECT_EQ(blank_url, observer.last_navigation_url());\n+  EXPECT_EQ(child_site_instance_0,\n+            child_0->current_frame_host()->GetSiteInstance());\n+\n+  GURL blank_url_ref(\""about:blank#1\"");\n+  {\n+    TestFrameNavigationObserver commit_observer(child_1);\n+    EXPECT_TRUE(ExecuteScript(\n+        child_1, \""location.href = '\"" + blank_url_ref.spec() + \""';\""));\n+    commit_observer.WaitForCommit();\n+  }\n+  EXPECT_TRUE(observer.last_navigation_succeeded());\n+  EXPECT_EQ(blank_url_ref, observer.last_navigation_url());\n+  EXPECT_EQ(child_site_instance_1,\n+            child_1->current_frame_host()->GetSiteInstance());\n+\n+  // Grab the NavigationEntry and clone its PageState into a new entry for\n+  // restoring into a new tab.\n+  const NavigationControllerImpl& controller =\n+      static_cast<const NavigationControllerImpl&>(\n+          shell()->web_contents()->GetController());\n+  NavigationEntryImpl* entry = controller.GetLastCommittedEntry();\n+  std::unique_ptr<NavigationEntryImpl> restored_entry =\n+      NavigationEntryImpl::FromNavigationEntry(\n+          NavigationController::CreateNavigationEntry(\n+              main_url, Referrer(), ui::PAGE_TRANSITION_RELOAD, false,\n+              std::string(), controller.GetBrowserContext(),\n+              nullptr /* blob_url_loader_factory */));\n+  EXPECT_EQ(0U, restored_entry->root_node()->children.size());\n+  restored_entry->SetPageState(entry->GetPageState());\n+  ASSERT_EQ(2U, restored_entry->root_node()->children.size());\n+\n+  // Restore the NavigationEntry into a new tab and check that the data URLs are\n+  // not loaded into the parent's SiteInstance.\n+  std::vector<std::unique_ptr<NavigationEntry>> entries;\n+  entries.push_back(std::move(restored_entry));\n+  Shell* new_shell = Shell::CreateNewWindow(\n+      controller.GetBrowserContext(), GURL::EmptyGURL(), nullptr, gfx::Size());\n+  FrameTreeNode* new_root =\n+      static_cast<WebContentsImpl*>(new_shell->web_contents())\n+          ->GetFrameTree()\n+          ->root();\n+  NavigationControllerImpl& new_controller =\n+      static_cast<NavigationControllerImpl&>(\n+          new_shell->web_contents()->GetController());\n+  new_controller.Restore(entries.size() - 1,\n+                         RestoreType::LAST_SESSION_EXITED_CLEANLY, &entries);\n+  ASSERT_EQ(0u, entries.size());\n+  {\n+    TestNavigationObserver restore_observer(new_shell->web_contents());\n+    new_controller.LoadIfNecessary();\n+    restore_observer.Wait();\n+  }\n+  ASSERT_EQ(2U, new_root->child_count());\n+  EXPECT_EQ(main_url, new_root->current_url());\n+  EXPECT_TRUE(new_root->child_at(0)->current_url().IsAboutBlank());\n+  EXPECT_TRUE(new_root->child_at(1)->current_url().IsAboutBlank());\n+\n+  EXPECT_EQ(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(0)->current_frame_host()->GetSiteInstance());\n+  EXPECT_EQ(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(1)->current_frame_host()->GetSiteInstance());\n+}\n+\n+// Similar to SubframeBlankUrlsAfterRestore, but ensures that about:srcdoc ends\n+// up in its parent's process after restore, since that's where its content\n+// comes from.\n+IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n+                       SubframeSrcdocUrlAfterRestore) {\n+  // Load a page that uses iframe srcdoc.\n+  GURL main_url(embedded_test_server()->GetURL(\n+      \""a.com\"", \""/frame_tree/page_with_srcdoc_frame.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+\n+  FrameTreeNode* root = web_contents()->GetFrameTree()->root();\n+  EXPECT_EQ(1U, root->child_count());\n+  FrameTreeNode* child = root->child_at(0);\n+  scoped_refptr<SiteInstanceImpl> child_site_instance =\n+      child->current_frame_host()->GetSiteInstance();\n+  EXPECT_EQ(child_site_instance, root->current_frame_host()->GetSiteInstance());\n+\n+  // Grab the NavigationEntry and clone its PageState into a new entry for\n+  // restoring into a new tab.\n+  const NavigationControllerImpl& controller =\n+      static_cast<const NavigationControllerImpl&>(\n+          shell()->web_contents()->GetController());\n+  NavigationEntryImpl* entry = controller.GetLastCommittedEntry();\n+  std::unique_ptr<NavigationEntryImpl> restored_entry =\n+      NavigationEntryImpl::FromNavigationEntry(\n+          NavigationController::CreateNavigationEntry(\n+              main_url, Referrer(), ui::PAGE_TRANSITION_RELOAD, false,\n+              std::string(), controller.GetBrowserContext(),\n+              nullptr /* blob_url_loader_factory */));\n+  EXPECT_EQ(0U, restored_entry->root_node()->children.size());\n+  restored_entry->SetPageState(entry->GetPageState());\n+  ASSERT_EQ(1U, restored_entry->root_node()->children.size());\n+\n+  // Restore the NavigationEntry into a new tab and check that the srcdoc URLs\n+  // are still loaded into the parent's SiteInstance.\n+  std::vector<std::unique_ptr<NavigationEntry>> entries;\n+  entries.push_back(std::move(restored_entry));\n+  Shell* new_shell = Shell::CreateNewWindow(\n+      controller.GetBrowserContext(), GURL::EmptyGURL(), nullptr, gfx::Size());\n+  FrameTreeNode* new_root =\n+      static_cast<WebContentsImpl*>(new_shell->web_contents())\n+          ->GetFrameTree()\n+          ->root();\n+  NavigationControllerImpl& new_controller =\n+      static_cast<NavigationControllerImpl&>(\n+          new_shell->web_contents()->GetController());\n+  new_controller.Restore(entries.size() - 1,\n+                         RestoreType::LAST_SESSION_EXITED_CLEANLY, &entries);\n+  ASSERT_EQ(0u, entries.size());\n+  {\n+    TestNavigationObserver restore_observer(new_shell->web_contents());\n+    new_controller.LoadIfNecessary();\n+    restore_observer.Wait();\n+  }\n+  ASSERT_EQ(1U, new_root->child_count());\n+  EXPECT_EQ(main_url, new_root->current_url());\n+  EXPECT_EQ(GURL(content::kAboutSrcDocURL),\n+            new_root->child_at(0)->current_url());\n+\n+  EXPECT_EQ(new_root->current_frame_host()->GetSiteInstance(),\n+            new_root->child_at(0)->current_frame_host()->GetSiteInstance());\n+}\n+\n // Ensures that navigating to about:blank URLs present in session history will\n // correctly commit the navigation in the same process as the one used for\n // the original navigation.""}<_**next**_>{""sha"": ""a5bce3fd2565d8f458555a0c6f42d0504a848bd5"", ""filename"": ""third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-1.html"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-1.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-1.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-1.html?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -0,0 +1 @@\n+test1""}<_**next**_>{""sha"": ""180cf8328022becee9aaa2577a8f84ea2b9f3827"", ""filename"": ""third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-2.html"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-2.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-2.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child-2.html?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -0,0 +1 @@\n+test2""}<_**next**_>{""sha"": ""b8ae010756f6d0452c849c17607ab4bd3f11670b"", ""filename"": ""third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child.html"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/frames/resources/frame-navigation-child.html?ref=0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca"", ""patch"": ""@@ -1,9 +1,10 @@\n <p>This tests that navigating to two pages in a subframe, and then going back does not cause an assertion.</p>\n <p>SUCCESS - Didn't assert!</p>\n <script>\n+\n if (window.testRunner) {\n-    testRunner.queueLoad('data:text/html,test1', 'target')\n-    testRunner.queueLoad('data:text/html,test2', 'target')\n+    testRunner.queueLoad('resources/frame-navigation-child-1.html', 'target')\n+    testRunner.queueLoad('resources/frame-navigation-child-2.html', 'target')\n     testRunner.queueBackNavigation(1);\n } else\n     document.write('This test must be run by DumpRenderTree!')""}","GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
                                 const GURL& real_url) {
  if (real_url.SchemeIs(kGuestScheme))
    return real_url;

  GURL url = SiteInstanceImpl::GetEffectiveURL(browser_context, real_url);
  url::Origin origin = url::Origin::Create(url);

  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
  url::Origin isolated_origin;
  if (policy->GetMatchingIsolatedOrigin(origin, &isolated_origin))
    return isolated_origin.GetURL();

  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {
    std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(
        origin.host(),
        net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);
    std::string site = origin.scheme();
    site += url::kStandardSchemeSeparator;
    site += domain.empty() ? origin.host() : domain;
    return GURL(site);
  }

  if (!origin.unique()) {
    DCHECK(!origin.scheme().empty());
     return GURL(origin.scheme() + "":"");
   } else if (url.has_scheme()) {
    // that might allow two URLs created by different sites to share a process.
    // See https://crbug.com/863623 and https://crbug.com/863069.
    // schemes, such as file:.
    // TODO(creis): This currently causes problems with tests on Android and
    // Android WebView.  For now, skip it when Site Isolation is not enabled,
    // since there's no need to isolate data and blob URLs from each other in
    // that case.
    bool is_site_isolation_enabled =
        SiteIsolationPolicy::UseDedicatedProcessesForAllSites() ||
        SiteIsolationPolicy::AreIsolatedOriginsEnabled();
    if (is_site_isolation_enabled &&
        (url.SchemeIsBlob() || url.scheme() == url::kDataScheme)) {
      // origins from each other.  We also get here for browser-initiated
      // navigations to data URLs, which have a unique origin and should only
      // share a process when they are identical.  Remove hash from the URL in
      // either case, since same-document navigations shouldn't use a different
      // site URL.
       if (url.has_ref()) {
         GURL::Replacements replacements;
         replacements.ClearRef();
        url = url.ReplaceComponents(replacements);
      }
      return url;
    }

    DCHECK(!url.scheme().empty());
    return GURL(url.scheme() + "":"");
  }

  DCHECK(!url.is_valid()) << url;
  return GURL();
}
","GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
                                 const GURL& real_url) {
  if (real_url.SchemeIs(kGuestScheme))
    return real_url;

  GURL url = SiteInstanceImpl::GetEffectiveURL(browser_context, real_url);
  url::Origin origin = url::Origin::Create(url);

  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
  url::Origin isolated_origin;
  if (policy->GetMatchingIsolatedOrigin(origin, &isolated_origin))
    return isolated_origin.GetURL();

  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {
    std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(
        origin.host(),
        net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);
    std::string site = origin.scheme();
    site += url::kStandardSchemeSeparator;
    site += domain.empty() ? origin.host() : domain;
    return GURL(site);
  }

  if (!origin.unique()) {
    DCHECK(!origin.scheme().empty());
     return GURL(origin.scheme() + "":"");
   } else if (url.has_scheme()) {
    if (url.SchemeIsBlob()) {
       if (url.has_ref()) {
         GURL::Replacements replacements;
         replacements.ClearRef();
        url = url.ReplaceComponents(replacements);
      }
      return url;
    }

    DCHECK(!url.scheme().empty());
    return GURL(url.scheme() + "":"");
  }

  DCHECK(!url.is_valid()) << url;
  return GURL();
}
",C,"    // that might allow two URLs created by different sites to share a process.
    // See https://crbug.com/863623 and https://crbug.com/863069.
    // schemes, such as file:.
    // TODO(creis): This currently causes problems with tests on Android and
    // Android WebView.  For now, skip it when Site Isolation is not enabled,
    // since there's no need to isolate data and blob URLs from each other in
    // that case.
    bool is_site_isolation_enabled =
        SiteIsolationPolicy::UseDedicatedProcessesForAllSites() ||
        SiteIsolationPolicy::AreIsolatedOriginsEnabled();
    if (is_site_isolation_enabled &&
        (url.SchemeIsBlob() || url.scheme() == url::kDataScheme)) {
      // origins from each other.  We also get here for browser-initiated
      // navigations to data URLs, which have a unique origin and should only
      // share a process when they are identical.  Remove hash from the URL in
      // either case, since same-document navigations shouldn't use a different
      // site URL.
","    if (url.SchemeIsBlob()) {
",,"@@ -457,16 +457,27 @@ GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
     return GURL(origin.scheme() + "":"");
   } else if (url.has_scheme()) {
     // In some cases, it is not safe to use just the scheme as a site URL, as
-    // that might allow two URLs created by different sites to to share a
-    // process.  See https://crbug.com/863623.
+    // that might allow two URLs created by different sites to share a process.
+    // See https://crbug.com/863623 and https://crbug.com/863069.
     //
     // TODO(alexmos,creis): This should eventually be expanded to certain other
-    // schemes, such as data: and file:.
-    if (url.SchemeIsBlob()) {
+    // schemes, such as file:.
+    // TODO(creis): This currently causes problems with tests on Android and
+    // Android WebView.  For now, skip it when Site Isolation is not enabled,
+    // since there's no need to isolate data and blob URLs from each other in
+    // that case.
+    bool is_site_isolation_enabled =
+        SiteIsolationPolicy::UseDedicatedProcessesForAllSites() ||
+        SiteIsolationPolicy::AreIsolatedOriginsEnabled();
+    if (is_site_isolation_enabled &&
+        (url.SchemeIsBlob() || url.scheme() == url::kDataScheme)) {
       // We get here for blob URLs of form blob:null/guid.  Use the full URL
       // with the guid in that case, which isolates all blob URLs with unique
-      // origins from each other.  Remove hash from the URL, since
-      // same-document navigations shouldn't use a different site URL.
+      // origins from each other.  We also get here for browser-initiated
+      // navigations to data URLs, which have a unique origin and should only
+      // share a process when they are identical.  Remove hash from the URL in
+      // either case, since same-document navigations shouldn't use a different
+      // site URL.
       if (url.has_ref()) {
         GURL::Replacements replacements;
         replacements.ClearRef();",Chrome,0bb3f5c715eb66bb5c1fb05fd81d902ca57f33ca,659c9e34e14cfcecf33f2b2e52aa133db5806fa2,1,"GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
                                 const GURL& real_url) {
  // TODO(fsamuel, creis): For some reason appID is not recognized as a host.
  if (real_url.SchemeIs(kGuestScheme))
    return real_url;

  GURL url = SiteInstanceImpl::GetEffectiveURL(browser_context, real_url);
  url::Origin origin = url::Origin::Create(url);

  // Isolated origins should use the full origin as their site URL. A subdomain
  // of an isolated origin should also use that isolated origin's site URL. It
  // is important to check |url| rather than |real_url| here, since some
  // effective URLs (such as for NTP) need to be resolved prior to the isolated
  // origin lookup.
  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
  url::Origin isolated_origin;
  if (policy->GetMatchingIsolatedOrigin(origin, &isolated_origin))
    return isolated_origin.GetURL();

  // If the url has a host, then determine the site.  Skip file URLs to avoid a
  // situation where site URL of file://localhost/ would mismatch Blink's origin
  // (which ignores the hostname in this case - see https://crbug.com/776160).
  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {
    // Only keep the scheme and registered domain of |origin|.
    std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(
        origin.host(),
        net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);
    std::string site = origin.scheme();
    site += url::kStandardSchemeSeparator;
    site += domain.empty() ? origin.host() : domain;
    return GURL(site);
  }

  // If there is no host but there is a scheme, return the scheme.
  // This is useful for cases like file URLs.
  if (!origin.unique()) {
    // Prefer to use the scheme of |origin| rather than |url|, to correctly
    // cover blob:file: and filesystem:file: URIs (see also
    // https://crbug.com/697111).
    DCHECK(!origin.scheme().empty());
     return GURL(origin.scheme() + "":"");
   } else if (url.has_scheme()) {
     // In some cases, it is not safe to use just the scheme as a site URL, as
//flaw_line_below:
    // that might allow two URLs created by different sites to to share a
//flaw_line_below:
    // process.  See https://crbug.com/863623.
//fix_flaw_line_below:
//    // that might allow two URLs created by different sites to share a process.
//fix_flaw_line_below:
//    // See https://crbug.com/863623 and https://crbug.com/863069.
     //
     // TODO(alexmos,creis): This should eventually be expanded to certain other
//flaw_line_below:
    // schemes, such as data: and file:.
//flaw_line_below:
    if (url.SchemeIsBlob()) {
//fix_flaw_line_below:
//    // schemes, such as file:.
//fix_flaw_line_below:
//    // TODO(creis): This currently causes problems with tests on Android and
//fix_flaw_line_below:
//    // Android WebView.  For now, skip it when Site Isolation is not enabled,
//fix_flaw_line_below:
//    // since there's no need to isolate data and blob URLs from each other in
//fix_flaw_line_below:
//    // that case.
//fix_flaw_line_below:
//    bool is_site_isolation_enabled =
//fix_flaw_line_below:
//        SiteIsolationPolicy::UseDedicatedProcessesForAllSites() ||
//fix_flaw_line_below:
//        SiteIsolationPolicy::AreIsolatedOriginsEnabled();
//fix_flaw_line_below:
//    if (is_site_isolation_enabled &&
//fix_flaw_line_below:
//        (url.SchemeIsBlob() || url.scheme() == url::kDataScheme)) {
       // We get here for blob URLs of form blob:null/guid.  Use the full URL
       // with the guid in that case, which isolates all blob URLs with unique
//flaw_line_below:
      // origins from each other.  Remove hash from the URL, since
//flaw_line_below:
      // same-document navigations shouldn't use a different site URL.
//fix_flaw_line_below:
//      // origins from each other.  We also get here for browser-initiated
//fix_flaw_line_below:
//      // navigations to data URLs, which have a unique origin and should only
//fix_flaw_line_below:
//      // share a process when they are identical.  Remove hash from the URL in
//fix_flaw_line_below:
//      // either case, since same-document navigations shouldn't use a different
//fix_flaw_line_below:
//      // site URL.
       if (url.has_ref()) {
         GURL::Replacements replacements;
         replacements.ClearRef();
        url = url.ReplaceComponents(replacements);
      }
      return url;
    }

    DCHECK(!url.scheme().empty());
    return GURL(url.scheme() + "":"");
  }

  // Otherwise the URL should be invalid; return an empty site.
  DCHECK(!url.is_valid()) << url;
  return GURL();
}
"
9439,187175,,Remote,Not required,,CVE-2018-16074,https://www.cvedetails.com/cve/CVE-2018-16074/,CWE-285,Medium,Partial,,,2019-06-27,4.3,Insufficient policy enforcement in site isolation in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass site isolation via a crafted HTML page.,2019-07-01,Bypass ,21,https://github.com/chromium/chromium/commit/b1f87486936ca0d6d9abf4d3b9b423a9c976fd59,b1f87486936ca0d6d9abf4d3b9b423a9c976fd59,"Avoid sharing process for blob URLs with null origin.

Previously, when a frame with a unique origin, such as from a data
URL, created a blob URL, the blob URL looked like blob:null/guid and
resulted in a site URL of ""blob:"" when navigated to.  This incorrectly
allowed all such blob URLs to share a process, even if they were
created by different sites.

This CL changes the site URL assigned in such cases to be the full
blob URL, which includes the GUID.  This avoids process sharing for
all blob URLs with unique origins.

This fix is conservative in the sense that it would also isolate
different blob URLs created by the same unique origin from each other.
This case isn't expected to be common, so it's unlikely to affect
process count.  There's ongoing work to maintain a GUID for unique
origins, so longer-term, we could try using that to track down the
creator and potentially use that GUID in the site URL instead of the
blob URL's GUID, to avoid unnecessary process isolation in scenarios
like this.

Note that as part of this, we discovered a bug where data URLs aren't
able to script blob URLs that they create: https://crbug.com/865254.
This scripting bug should be fixed independently of this CL, and as
far as we can tell, this CL doesn't regress scripting cases like this
further.

Bug: 863623
Change-Id: Ib50407adbba3d5ee0cf6d72d3df7f8d8f24684ee
Reviewed-on: https://chromium-review.googlesource.com/1142389
Commit-Queue: Alex Moshchuk <alexmos@chromium.org>
Reviewed-by: Charlie Reis <creis@chromium.org>
Cr-Commit-Position: refs/heads/master@{#576318}",0,content/browser/site_instance_impl.cc,"{""sha"": ""df77d7f7605bce424440a1c109d17011a4fd51b2"", ""filename"": ""content/browser/site_instance_impl.cc"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 1, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/b1f87486936ca0d6d9abf4d3b9b423a9c976fd59/content/browser/site_instance_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b1f87486936ca0d6d9abf4d3b9b423a9c976fd59/content/browser/site_instance_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_instance_impl.cc?ref=b1f87486936ca0d6d9abf4d3b9b423a9c976fd59"", ""patch"": ""@@ -449,10 +449,30 @@ GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,\n   // This is useful for cases like file URLs.\n   if (!origin.unique()) {\n     // Prefer to use the scheme of |origin| rather than |url|, to correctly\n-    // cover blob: and filesystem: URIs (see also https://crbug.com/697111).\n+    // cover blob:file: and filesystem:file: URIs (see also\n+    // https://crbug.com/697111).\n     DCHECK(!origin.scheme().empty());\n     return GURL(origin.scheme() + \"":\"");\n   } else if (url.has_scheme()) {\n+    // In some cases, it is not safe to use just the scheme as a site URL, as\n+    // that might allow two URLs created by different sites to to share a\n+    // process.  See https://crbug.com/863623.\n+    //\n+    // TODO(alexmos,creis): This should eventually be expanded to certain other\n+    // schemes, such as data: and file:.\n+    if (url.SchemeIsBlob()) {\n+      // We get here for blob URLs of form blob:null/guid.  Use the full URL\n+      // with the guid in that case, which isolates all blob URLs with unique\n+      // origins from each other.  Remove hash from the URL, since\n+      // same-document navigations shouldn't use a different site URL.\n+      if (url.has_ref()) {\n+        GURL::Replacements replacements;\n+        replacements.ClearRef();\n+        url = url.ReplaceComponents(replacements);\n+      }\n+      return url;\n+    }\n+\n     DCHECK(!url.scheme().empty());\n     return GURL(url.scheme() + \"":\"");\n   }""}<_**next**_>{""sha"": ""8e92db4991f5bd591ca12d2b684078b07ababf2a"", ""filename"": ""content/browser/site_instance_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/b1f87486936ca0d6d9abf4d3b9b423a9c976fd59/content/browser/site_instance_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b1f87486936ca0d6d9abf4d3b9b423a9c976fd59/content/browser/site_instance_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_instance_impl_unittest.cc?ref=b1f87486936ca0d6d9abf4d3b9b423a9c976fd59"", ""patch"": ""@@ -344,6 +344,17 @@ TEST_F(SiteInstanceTest, GetSiteForURL) {\n   EXPECT_EQ(\""file\"", site_url.scheme());\n   EXPECT_FALSE(site_url.has_host());\n \n+  // Blob URLs created from a unique origin use the full URL as the site URL,\n+  // except for the hash.\n+  test_url = GURL(\""blob:null/1029e5a4-2983-4b90-a585-ed217563acfeb\"");\n+  site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n+  EXPECT_EQ(site_url, test_url);\n+  test_url = GURL(\""blob:null/1029e5a4-2983-4b90-a585-ed217563acfeb#foo\"");\n+  site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n+  EXPECT_NE(site_url, test_url);\n+  EXPECT_FALSE(site_url.has_ref());\n+  EXPECT_TRUE(site_url.EqualsIgnoringRef(test_url));\n+\n   // Private domains are preserved, appspot being such a site.\n   test_url = GURL(\n       \""blob:http://www.example.appspot.com:44/\""""}<_**next**_>{""sha"": ""7aa65cb6339166c914b910740b39f352ebeb7033"", ""filename"": ""content/browser/site_per_process_browsertest.cc"", ""status"": ""modified"", ""additions"": 50, ""deletions"": 0, ""changes"": 50, ""blob_url"": ""https://github.com/chromium/chromium/blob/b1f87486936ca0d6d9abf4d3b9b423a9c976fd59/content/browser/site_per_process_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b1f87486936ca0d6d9abf4d3b9b423a9c976fd59/content/browser/site_per_process_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_per_process_browsertest.cc?ref=b1f87486936ca0d6d9abf4d3b9b423a9c976fd59"", ""patch"": ""@@ -12675,4 +12675,54 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n             subframe->effective_frame_policy().sandbox_flags);\n }\n \n+// Ensure that when two cross-site frames have subframes with unique origins,\n+// and those subframes create blob URLs and navigate to them, the blob URLs end\n+// up in different processes. See https://crbug.com/863623.\n+IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n+                       TwoBlobURLsWithNullOriginDontShareProcess) {\n+  GURL main_url(embedded_test_server()->GetURL(\n+      \""a.com\"", \""/navigation_controller/page_with_data_iframe.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+  FrameTreeNode* root = web_contents()->GetFrameTree()->root();\n+  FrameTreeNode* subframe = root->child_at(0);\n+\n+  // Create a blob URL in the subframe, and navigate to it.\n+  TestNavigationObserver observer(shell()->web_contents());\n+  std::string blob_script =\n+      \""var blob = new Blob(['foo'], {type : 'text/html'});\""\n+      \""var url = URL.createObjectURL(blob);\""\n+      \""location = url;\"";\n+  EXPECT_TRUE(ExecuteScript(subframe, blob_script));\n+  observer.Wait();\n+  RenderFrameHostImpl* subframe_rfh = subframe->current_frame_host();\n+  EXPECT_TRUE(subframe_rfh->GetLastCommittedURL().SchemeIsBlob());\n+\n+  // Open a cross-site popup and repeat these steps.\n+  GURL popup_url(embedded_test_server()->GetURL(\n+      \""b.com\"", \""/navigation_controller/page_with_data_iframe.html\""));\n+  Shell* new_shell = OpenPopup(root, popup_url, \""\"");\n+  FrameTreeNode* popup_root =\n+      static_cast<WebContentsImpl*>(new_shell->web_contents())\n+          ->GetFrameTree()\n+          ->root();\n+  FrameTreeNode* popup_subframe = popup_root->child_at(0);\n+\n+  TestNavigationObserver popup_observer(new_shell->web_contents());\n+  EXPECT_TRUE(ExecuteScript(popup_subframe, blob_script));\n+  popup_observer.Wait();\n+  RenderFrameHostImpl* popup_subframe_rfh =\n+      popup_subframe->current_frame_host();\n+  EXPECT_TRUE(popup_subframe_rfh->GetLastCommittedURL().SchemeIsBlob());\n+\n+  // Ensure that the two blob subframes don't share a process or SiteInstance.\n+  EXPECT_NE(subframe->current_frame_host()->GetSiteInstance(),\n+            popup_subframe->current_frame_host()->GetSiteInstance());\n+  EXPECT_NE(\n+      subframe->current_frame_host()->GetSiteInstance()->GetProcess(),\n+      popup_subframe->current_frame_host()->GetSiteInstance()->GetProcess());\n+  EXPECT_NE(\n+      subframe->current_frame_host()->GetSiteInstance()->GetSiteURL(),\n+      popup_subframe->current_frame_host()->GetSiteInstance()->GetSiteURL());\n+}\n+\n }  // namespace content""}","GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
                                 const GURL& real_url) {
  if (real_url.SchemeIs(kGuestScheme))
    return real_url;

  GURL url = SiteInstanceImpl::GetEffectiveURL(browser_context, real_url);
  url::Origin origin = url::Origin::Create(url);

  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
  url::Origin isolated_origin;
  if (policy->GetMatchingIsolatedOrigin(origin, &isolated_origin))
    return isolated_origin.GetURL();

  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {
    std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(
        origin.host(),
        net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);
    std::string site = origin.scheme();
    site += url::kStandardSchemeSeparator;
    site += domain.empty() ? origin.host() : domain;
    return GURL(site);
  }

   if (!origin.unique()) {
    // cover blob:file: and filesystem:file: URIs (see also
    // https://crbug.com/697111).
     DCHECK(!origin.scheme().empty());
     return GURL(origin.scheme() + "":"");
   } else if (url.has_scheme()) {
    // In some cases, it is not safe to use just the scheme as a site URL, as
    // that might allow two URLs created by different sites to to share a
    // process.  See https://crbug.com/863623.
    //
    // TODO(alexmos,creis): This should eventually be expanded to certain other
    // schemes, such as data: and file:.
    if (url.SchemeIsBlob()) {
      // We get here for blob URLs of form blob:null/guid.  Use the full URL
      // with the guid in that case, which isolates all blob URLs with unique
      // origins from each other.  Remove hash from the URL, since
      // same-document navigations shouldn't use a different site URL.
      if (url.has_ref()) {
        GURL::Replacements replacements;
        replacements.ClearRef();
        url = url.ReplaceComponents(replacements);
      }
      return url;
    }

     DCHECK(!url.scheme().empty());
     return GURL(url.scheme() + "":"");
   }

  DCHECK(!url.is_valid()) << url;
  return GURL();
}
","GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
                                 const GURL& real_url) {
  if (real_url.SchemeIs(kGuestScheme))
    return real_url;

  GURL url = SiteInstanceImpl::GetEffectiveURL(browser_context, real_url);
  url::Origin origin = url::Origin::Create(url);

  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
  url::Origin isolated_origin;
  if (policy->GetMatchingIsolatedOrigin(origin, &isolated_origin))
    return isolated_origin.GetURL();

  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {
    std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(
        origin.host(),
        net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);
    std::string site = origin.scheme();
    site += url::kStandardSchemeSeparator;
    site += domain.empty() ? origin.host() : domain;
    return GURL(site);
  }

   if (!origin.unique()) {
     DCHECK(!origin.scheme().empty());
     return GURL(origin.scheme() + "":"");
   } else if (url.has_scheme()) {
     DCHECK(!url.scheme().empty());
     return GURL(url.scheme() + "":"");
   }

  DCHECK(!url.is_valid()) << url;
  return GURL();
}
",C,"    // cover blob:file: and filesystem:file: URIs (see also
    // https://crbug.com/697111).
    // In some cases, it is not safe to use just the scheme as a site URL, as
    // that might allow two URLs created by different sites to to share a
    // process.  See https://crbug.com/863623.
    //
    // TODO(alexmos,creis): This should eventually be expanded to certain other
    // schemes, such as data: and file:.
    if (url.SchemeIsBlob()) {
      // We get here for blob URLs of form blob:null/guid.  Use the full URL
      // with the guid in that case, which isolates all blob URLs with unique
      // origins from each other.  Remove hash from the URL, since
      // same-document navigations shouldn't use a different site URL.
      if (url.has_ref()) {
        GURL::Replacements replacements;
        replacements.ClearRef();
        url = url.ReplaceComponents(replacements);
      }
      return url;
    }

",,,"@@ -449,10 +449,30 @@ GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
   // This is useful for cases like file URLs.
   if (!origin.unique()) {
     // Prefer to use the scheme of |origin| rather than |url|, to correctly
-    // cover blob: and filesystem: URIs (see also https://crbug.com/697111).
+    // cover blob:file: and filesystem:file: URIs (see also
+    // https://crbug.com/697111).
     DCHECK(!origin.scheme().empty());
     return GURL(origin.scheme() + "":"");
   } else if (url.has_scheme()) {
+    // In some cases, it is not safe to use just the scheme as a site URL, as
+    // that might allow two URLs created by different sites to to share a
+    // process.  See https://crbug.com/863623.
+    //
+    // TODO(alexmos,creis): This should eventually be expanded to certain other
+    // schemes, such as data: and file:.
+    if (url.SchemeIsBlob()) {
+      // We get here for blob URLs of form blob:null/guid.  Use the full URL
+      // with the guid in that case, which isolates all blob URLs with unique
+      // origins from each other.  Remove hash from the URL, since
+      // same-document navigations shouldn't use a different site URL.
+      if (url.has_ref()) {
+        GURL::Replacements replacements;
+        replacements.ClearRef();
+        url = url.ReplaceComponents(replacements);
+      }
+      return url;
+    }
+
     DCHECK(!url.scheme().empty());
     return GURL(url.scheme() + "":"");
   }",Chrome,b1f87486936ca0d6d9abf4d3b9b423a9c976fd59,0ea138d60b5c616ac59cd0561022a3105fd35f01,1,"GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
                                 const GURL& real_url) {
  // TODO(fsamuel, creis): For some reason appID is not recognized as a host.
  if (real_url.SchemeIs(kGuestScheme))
    return real_url;

  GURL url = SiteInstanceImpl::GetEffectiveURL(browser_context, real_url);
  url::Origin origin = url::Origin::Create(url);

  // Isolated origins should use the full origin as their site URL. A subdomain
  // of an isolated origin should also use that isolated origin's site URL. It
  // is important to check |url| rather than |real_url| here, since some
  // effective URLs (such as for NTP) need to be resolved prior to the isolated
  // origin lookup.
  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
  url::Origin isolated_origin;
  if (policy->GetMatchingIsolatedOrigin(origin, &isolated_origin))
    return isolated_origin.GetURL();

  // If the url has a host, then determine the site.  Skip file URLs to avoid a
  // situation where site URL of file://localhost/ would mismatch Blink's origin
  // (which ignores the hostname in this case - see https://crbug.com/776160).
  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {
    // Only keep the scheme and registered domain of |origin|.
    std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(
        origin.host(),
        net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);
    std::string site = origin.scheme();
    site += url::kStandardSchemeSeparator;
    site += domain.empty() ? origin.host() : domain;
    return GURL(site);
  }

  // If there is no host but there is a scheme, return the scheme.
   // This is useful for cases like file URLs.
   if (!origin.unique()) {
     // Prefer to use the scheme of |origin| rather than |url|, to correctly
//flaw_line_below:
    // cover blob: and filesystem: URIs (see also https://crbug.com/697111).
//fix_flaw_line_below:
//    // cover blob:file: and filesystem:file: URIs (see also
//fix_flaw_line_below:
//    // https://crbug.com/697111).
     DCHECK(!origin.scheme().empty());
     return GURL(origin.scheme() + "":"");
   } else if (url.has_scheme()) {
//fix_flaw_line_below:
//    // In some cases, it is not safe to use just the scheme as a site URL, as
//fix_flaw_line_below:
//    // that might allow two URLs created by different sites to to share a
//fix_flaw_line_below:
//    // process.  See https://crbug.com/863623.
//fix_flaw_line_below:
//    //
//fix_flaw_line_below:
//    // TODO(alexmos,creis): This should eventually be expanded to certain other
//fix_flaw_line_below:
//    // schemes, such as data: and file:.
//fix_flaw_line_below:
//    if (url.SchemeIsBlob()) {
//fix_flaw_line_below:
//      // We get here for blob URLs of form blob:null/guid.  Use the full URL
//fix_flaw_line_below:
//      // with the guid in that case, which isolates all blob URLs with unique
//fix_flaw_line_below:
//      // origins from each other.  Remove hash from the URL, since
//fix_flaw_line_below:
//      // same-document navigations shouldn't use a different site URL.
//fix_flaw_line_below:
//      if (url.has_ref()) {
//fix_flaw_line_below:
//        GURL::Replacements replacements;
//fix_flaw_line_below:
//        replacements.ClearRef();
//fix_flaw_line_below:
//        url = url.ReplaceComponents(replacements);
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//      return url;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     DCHECK(!url.scheme().empty());
     return GURL(url.scheme() + "":"");
   }

  // Otherwise the URL should be invalid; return an empty site.
  DCHECK(!url.is_valid()) << url;
  return GURL();
}
"
9450,187186,,Remote,Not required,,CVE-2018-16077,https://www.cvedetails.com/cve/CVE-2018-16077/,CWE-285,Medium,,Partial,,2019-06-27,4.3,Object lifecycle issue in Blink in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass content security policy via a crafted HTML page.,2019-07-03,Bypass ,4,https://github.com/chromium/chromium/commit/90f878780cce9c4b0475fcea14d91b8f510cce11,90f878780cce9c4b0475fcea14d91b8f510cce11,"Prevent sandboxed documents from reusing the default window

Bug: 377995
Change-Id: Iff66c6d214dfd0cb7ea9c80f83afeedfff703541
Reviewed-on: https://chromium-review.googlesource.com/983558
Commit-Queue: Andy Paicu <andypaicu@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Cr-Commit-Position: refs/heads/master@{#567663}",1,third_party/blink/renderer/core/dom/document.cc,"{""sha"": ""e58402e4ba668220326f7ca7757e22e1f4647a8f"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/sandbox-allow-scripts.sub.html"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/sandbox-allow-scripts.sub.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/sandbox-allow-scripts.sub.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/sandbox-allow-scripts.sub.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -16,7 +16,7 @@\n        }\n     </script>\n \n-    <iframe src=\""support/sandboxed-post-message-to-parent.sub.html?sandbox=allow-scripts\""></iframe>\n+    <iframe src=\""support/sandboxed-post-message-to-parent.html?sandbox=allow-scripts\""></iframe>\n </body>\n \n </html>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""ef4b1a0b95a7e00275c423d49dd28f98545950d3"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.html"", ""status"": ""renamed"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""previous_filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.sub.html""}<_**next**_>{""sha"": ""ebbb54d36d86fe3ee3696b7dc302de11cb4ac30c"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html"", ""status"": ""added"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -0,0 +1,3 @@\n+<script>\n+  window.opener.postMessage(window.testProperty, \""*\"");\n+</script>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""a7ea308208d81a9f9a2ec24004d5d1f72cf21f84"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html.sub.headers"", ""status"": ""renamed"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html.sub.headers"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html.sub.headers"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html.sub.headers?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""previous_filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.sub.html.sub.headers""}<_**next**_>{""sha"": ""ebbb54d36d86fe3ee3696b7dc302de11cb4ac30c"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/unsandboxed-post-property-to-opener.html"", ""status"": ""added"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/unsandboxed-post-property-to-opener.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/unsandboxed-post-property-to-opener.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/unsandboxed-post-property-to-opener.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -0,0 +1,3 @@\n+<script>\n+  window.opener.postMessage(window.testProperty, \""*\"");\n+</script>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""a7a080daf72ee8ae97f5adf433f17c947892d4ce"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-sandboxed.html"", ""status"": ""added"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-sandboxed.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-sandboxed.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-sandboxed.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -0,0 +1,22 @@\n+<!DOCTYPE html>\n+<html>\n+\n+<head>\n+    <script src=\""/resources/testharness.js\""></script>\n+    <script src=\""/resources/testharnessreport.js\""></script>\n+</head>\n+\n+<body>\n+    <script>\n+      var t = async_test(\""Window object should not be reused\"");\n+\n+      window.onmessage = t.step_func_done(function(e) {\n+        assert_equals(e.data, undefined);\n+      });\n+\n+      w = window.open(\""support/sandboxed-post-property-to-opener.html?sandbox=allow-scripts\"",\""\"",\""width=400,height=400\"");\n+      w.testProperty = \""test\"";\n+    </script>\n+</body>\n+\n+</html>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""dd69c41354b583e427d4e12a060f1b6f71eb2c86"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-unsandboxed.html"", ""status"": ""added"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-unsandboxed.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-unsandboxed.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-unsandboxed.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -0,0 +1,22 @@\n+<!DOCTYPE html>\n+<html>\n+\n+<head>\n+    <script src=\""/resources/testharness.js\""></script>\n+    <script src=\""/resources/testharnessreport.js\""></script>\n+</head>\n+\n+<body>\n+    <script>\n+      var t = async_test(\""Window object should be reused\"");\n+\n+      window.onmessage = t.step_func_done(function(e) {\n+        assert_equals(e.data, \""test\"");\n+      });\n+\n+      w = window.open(\""support/unsandboxed-post-property-to-opener.html\"",\""\"",\""width=400,height=400\"");\n+      w.testProperty = \""test\"";\n+    </script>\n+</body>\n+\n+</html>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""c51cf5bfd4df6c9768e28caba8fcceb5a4332fef"", ""filename"": ""third_party/blink/renderer/core/dom/document.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/dom/document.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/dom/document.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/dom/document.cc?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -3569,7 +3569,10 @@ void Document::DispatchUnloadEvents() {\n   bool keep_event_listeners =\n       frame_->Loader().GetProvisionalDocumentLoader() &&\n       frame_->ShouldReuseDefaultView(\n-          frame_->Loader().GetProvisionalDocumentLoader()->Url());\n+          frame_->Loader().GetProvisionalDocumentLoader()->Url(),\n+          frame_->Loader()\n+              .GetProvisionalDocumentLoader()\n+              ->GetContentSecurityPolicy());\n   if (!keep_event_listeners)\n     RemoveAllEventListenersRecursively();\n }""}<_**next**_>{""sha"": ""12569fa32df76e82f80b638658a75571c227b98a"", ""filename"": ""third_party/blink/renderer/core/execution_context/security_context.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/execution_context/security_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/execution_context/security_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/execution_context/security_context.h?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -79,7 +79,12 @@ class CORE_EXPORT SecurityContext : public GarbageCollectedMixin {\n   virtual void DidUpdateSecurityOrigin() = 0;\n \n   SandboxFlags GetSandboxFlags() const { return sandbox_flags_; }\n-  bool IsSandboxed(SandboxFlags mask) const { return sandbox_flags_ & mask; }\n+  bool IsSandboxed(SandboxFlags mask) const {\n+    return IsSandboxed(mask, sandbox_flags_);\n+  }\n+  static bool IsSandboxed(SandboxFlags mask, SandboxFlags sandbox_flags) {\n+    return sandbox_flags & mask;\n+  }\n   virtual void EnforceSandboxFlags(SandboxFlags mask);\n \n   void SetAddressSpace(mojom::IPAddressSpace space) { address_space_ = space; }""}<_**next**_>{""sha"": ""204bb1e4547d523bbba1018e3448c00c45b4f73e"", ""filename"": ""third_party/blink/renderer/core/frame/csp/content_security_policy.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/csp/content_security_policy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/csp/content_security_policy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/frame/csp/content_security_policy.h?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -455,6 +455,12 @@ class CORE_EXPORT ContentSecurityPolicy\n   // perform these checks in NavigationRequest::CheckContentSecurityPolicy.\n   WebContentSecurityPolicyList ExposeForNavigationalChecks() const;\n \n+  // Retrieves the parsed sandbox flags. A lot of the time the execution\n+  // context will be used for all sandbox checks but there are situations\n+  // (before installing the document that this CSP will bind to) when\n+  // there is no execution context to enforce the sandbox flags.\n+  SandboxFlags GetSandboxMask() const { return sandbox_mask_; }\n+\n  private:\n   FRIEND_TEST_ALL_PREFIXES(ContentSecurityPolicyTest, NonceInline);\n   FRIEND_TEST_ALL_PREFIXES(ContentSecurityPolicyTest, NonceSinglePolicy);""}<_**next**_>{""sha"": ""ccc77a631977883052d2bd6e7826ef8726944301"", ""filename"": ""third_party/blink/renderer/core/frame/local_frame.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/local_frame.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/local_frame.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/frame/local_frame.cc?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -822,12 +822,24 @@ Document* LocalFrame::DocumentAtPoint(const LayoutPoint& point_in_root_frame) {\n   return result.InnerNode() ? &result.InnerNode()->GetDocument() : nullptr;\n }\n \n-bool LocalFrame::ShouldReuseDefaultView(const KURL& url) const {\n+bool LocalFrame::ShouldReuseDefaultView(\n+    const KURL& url,\n+    const ContentSecurityPolicy* csp) const {\n   // Secure transitions can only happen when navigating from the initial empty\n   // document.\n   if (!Loader().StateMachine()->IsDisplayingInitialEmptyDocument())\n     return false;\n \n+  // The Window object should only be re-used if it is same-origin.\n+  // Since sandboxing turns the origin into an opaque origin it needs to also\n+  // be considered when deciding whether to reuse it.\n+  // Spec:\n+  // https://html.spec.whatwg.org/multipage/browsing-the-web.html#initialise-the-document-object\n+  if (csp &&\n+      SecurityContext::IsSandboxed(kSandboxOrigin, csp->GetSandboxMask())) {\n+    return false;\n+  }\n+\n   return GetDocument()->IsSecureTransitionTo(url);\n }\n ""}<_**next**_>{""sha"": ""9633b2e5b26664936682590a04b3f5794b673c33"", ""filename"": ""third_party/blink/renderer/core/frame/local_frame.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/local_frame.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/local_frame.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/frame/local_frame.h?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -230,7 +230,7 @@ class CORE_EXPORT LocalFrame final : public Frame,\n   PositionForPoint(const LayoutPoint& frame_point);\n   Document* DocumentAtPoint(const LayoutPoint&);\n \n-  bool ShouldReuseDefaultView(const KURL&) const;\n+  bool ShouldReuseDefaultView(const KURL&, const ContentSecurityPolicy*) const;\n   void RemoveSpellingMarkersUnderWords(const Vector<String>& words);\n \n   bool ShouldThrottleRendering() const;""}<_**next**_>{""sha"": ""6c62eca9db3829767e1f57da62585180ac1ba0cc"", ""filename"": ""third_party/blink/renderer/core/loader/document_loader.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 6, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/document_loader.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/document_loader.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/loader/document_loader.cc?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -711,12 +711,13 @@ void DocumentLoader::CommitNavigation(const AtomicString& mime_type,\n   if (!Document::ThreadedParsingEnabledForTesting())\n     parsing_policy = kForceSynchronousParsing;\n \n-  InstallNewDocument(Url(), owner_document,\n-                     frame_->ShouldReuseDefaultView(Url())\n-                         ? WebGlobalObjectReusePolicy::kUseExisting\n-                         : WebGlobalObjectReusePolicy::kCreateNew,\n-                     mime_type, encoding, InstallNewDocumentReason::kNavigation,\n-                     parsing_policy, overriding_url);\n+  InstallNewDocument(\n+      Url(), owner_document,\n+      frame_->ShouldReuseDefaultView(Url(), GetContentSecurityPolicy())\n+          ? WebGlobalObjectReusePolicy::kUseExisting\n+          : WebGlobalObjectReusePolicy::kCreateNew,\n+      mime_type, encoding, InstallNewDocumentReason::kNavigation,\n+      parsing_policy, overriding_url);\n   parser_->SetDocumentWasLoadedAsPartOfNavigation();\n   if (request_.WasDiscarded())\n     frame_->GetDocument()->SetWasDiscarded(true);""}<_**next**_>{""sha"": ""0e1a7006f5549970828957b647fdcb44c38e8d64"", ""filename"": ""third_party/blink/renderer/core/loader/document_loader.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/document_loader.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/document_loader.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/loader/document_loader.h?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -252,6 +252,13 @@ class CORE_EXPORT DocumentLoader\n   void BlockParser();\n   void ResumeParser();\n \n+  // Returns the currently stored content security policy, if this is called\n+  // after the document has been installed it will return nullptr as the\n+  // CSP belongs to the document at that point.\n+  const ContentSecurityPolicy* GetContentSecurityPolicy() const {\n+    return content_security_policy_.Get();\n+  }\n+\n  protected:\n   DocumentLoader(LocalFrame*,\n                  const ResourceRequest&,""}<_**next**_>{""sha"": ""b18dcdec03934315d44a79a965cb84e0d0501e11"", ""filename"": ""third_party/blink/renderer/core/loader/frame_loader.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/frame_loader.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/frame_loader.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/loader/frame_loader.cc?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -365,8 +365,12 @@ void FrameLoader::ReplaceDocumentWhileExecutingJavaScriptURL(\n \n   // Compute this before clearing the frame, because it may need to inherit an\n   // aliased security context.\n+  // The document CSP is the correct one as it is used for CSP checks\n+  // done previously before getting here:\n+  // HTMLFormElement::ScheduleFormSubmission\n+  // HTMLFrameElementBase::OpenURL\n   WebGlobalObjectReusePolicy global_object_reuse_policy =\n-      frame_->ShouldReuseDefaultView(url)\n+      frame_->ShouldReuseDefaultView(url, document->GetContentSecurityPolicy())\n           ? WebGlobalObjectReusePolicy::kUseExisting\n           : WebGlobalObjectReusePolicy::kCreateNew;\n ""}","void Document::DispatchUnloadEvents() {
  PluginScriptForbiddenScope forbid_plugin_destructor_scripting;
  if (parser_)
    parser_->StopParsing();

  if (load_event_progress_ == kLoadEventNotRun)
    return;

  if (load_event_progress_ <= kUnloadEventInProgress) {
    Element* current_focused_element = FocusedElement();
    if (auto* input = ToHTMLInputElementOrNull(current_focused_element))
      input->EndEditing();
    if (load_event_progress_ < kPageHideInProgress) {
      load_event_progress_ = kPageHideInProgress;
      if (LocalDOMWindow* window = domWindow()) {
        const TimeTicks pagehide_event_start = CurrentTimeTicks();
        window->DispatchEvent(
            PageTransitionEvent::Create(EventTypeNames::pagehide, false), this);
        const TimeTicks pagehide_event_end = CurrentTimeTicks();
        DEFINE_STATIC_LOCAL(
            CustomCountHistogram, pagehide_histogram,
            (""DocumentEventTiming.PageHideDuration"", 0, 10000000, 50));
        pagehide_histogram.Count(
            (pagehide_event_end - pagehide_event_start).InMicroseconds());
      }
      if (!frame_)
        return;

      mojom::PageVisibilityState visibility_state = GetPageVisibilityState();
      load_event_progress_ = kUnloadVisibilityChangeInProgress;
      if (visibility_state != mojom::PageVisibilityState::kHidden) {
        const TimeTicks pagevisibility_hidden_event_start = CurrentTimeTicks();
        DispatchEvent(Event::CreateBubble(EventTypeNames::visibilitychange));
        const TimeTicks pagevisibility_hidden_event_end = CurrentTimeTicks();
        DEFINE_STATIC_LOCAL(CustomCountHistogram, pagevisibility_histogram,
                            (""DocumentEventTiming.PageVibilityHiddenDuration"",
                             0, 10000000, 50));
        pagevisibility_histogram.Count((pagevisibility_hidden_event_end -
                                        pagevisibility_hidden_event_start)
                                           .InMicroseconds());
        DispatchEvent(
            Event::CreateBubble(EventTypeNames::webkitvisibilitychange));
      }
      if (!frame_)
        return;

      frame_->Loader().SaveScrollAnchor();

      DocumentLoader* document_loader =
          frame_->Loader().GetProvisionalDocumentLoader();
      load_event_progress_ = kUnloadEventInProgress;
      Event* unload_event(Event::Create(EventTypeNames::unload));
      if (document_loader &&
          document_loader->GetTiming().UnloadEventStart().is_null() &&
          document_loader->GetTiming().UnloadEventEnd().is_null()) {
        DocumentLoadTiming& timing = document_loader->GetTiming();
        DCHECK(!timing.NavigationStart().is_null());
        const TimeTicks unload_event_start = CurrentTimeTicks();
        timing.MarkUnloadEventStart(unload_event_start);
        frame_->DomWindow()->DispatchEvent(unload_event, this);
        const TimeTicks unload_event_end = CurrentTimeTicks();
        DEFINE_STATIC_LOCAL(
            CustomCountHistogram, unload_histogram,
            (""DocumentEventTiming.UnloadDuration"", 0, 10000000, 50));
        unload_histogram.Count(
            (unload_event_end - unload_event_start).InMicroseconds());
        timing.MarkUnloadEventEnd(unload_event_end);
      } else {
        frame_->DomWindow()->DispatchEvent(unload_event, frame_->GetDocument());
      }
    }
    load_event_progress_ = kUnloadEventHandled;
  }

  if (!frame_)
    return;

   bool keep_event_listeners =
       frame_->Loader().GetProvisionalDocumentLoader() &&
       frame_->ShouldReuseDefaultView(
          frame_->Loader().GetProvisionalDocumentLoader()->Url(),
          frame_->Loader()
              .GetProvisionalDocumentLoader()
              ->GetContentSecurityPolicy());
   if (!keep_event_listeners)
     RemoveAllEventListenersRecursively();
 }
","void Document::DispatchUnloadEvents() {
  PluginScriptForbiddenScope forbid_plugin_destructor_scripting;
  if (parser_)
    parser_->StopParsing();

  if (load_event_progress_ == kLoadEventNotRun)
    return;

  if (load_event_progress_ <= kUnloadEventInProgress) {
    Element* current_focused_element = FocusedElement();
    if (auto* input = ToHTMLInputElementOrNull(current_focused_element))
      input->EndEditing();
    if (load_event_progress_ < kPageHideInProgress) {
      load_event_progress_ = kPageHideInProgress;
      if (LocalDOMWindow* window = domWindow()) {
        const TimeTicks pagehide_event_start = CurrentTimeTicks();
        window->DispatchEvent(
            PageTransitionEvent::Create(EventTypeNames::pagehide, false), this);
        const TimeTicks pagehide_event_end = CurrentTimeTicks();
        DEFINE_STATIC_LOCAL(
            CustomCountHistogram, pagehide_histogram,
            (""DocumentEventTiming.PageHideDuration"", 0, 10000000, 50));
        pagehide_histogram.Count(
            (pagehide_event_end - pagehide_event_start).InMicroseconds());
      }
      if (!frame_)
        return;

      mojom::PageVisibilityState visibility_state = GetPageVisibilityState();
      load_event_progress_ = kUnloadVisibilityChangeInProgress;
      if (visibility_state != mojom::PageVisibilityState::kHidden) {
        const TimeTicks pagevisibility_hidden_event_start = CurrentTimeTicks();
        DispatchEvent(Event::CreateBubble(EventTypeNames::visibilitychange));
        const TimeTicks pagevisibility_hidden_event_end = CurrentTimeTicks();
        DEFINE_STATIC_LOCAL(CustomCountHistogram, pagevisibility_histogram,
                            (""DocumentEventTiming.PageVibilityHiddenDuration"",
                             0, 10000000, 50));
        pagevisibility_histogram.Count((pagevisibility_hidden_event_end -
                                        pagevisibility_hidden_event_start)
                                           .InMicroseconds());
        DispatchEvent(
            Event::CreateBubble(EventTypeNames::webkitvisibilitychange));
      }
      if (!frame_)
        return;

      frame_->Loader().SaveScrollAnchor();

      DocumentLoader* document_loader =
          frame_->Loader().GetProvisionalDocumentLoader();
      load_event_progress_ = kUnloadEventInProgress;
      Event* unload_event(Event::Create(EventTypeNames::unload));
      if (document_loader &&
          document_loader->GetTiming().UnloadEventStart().is_null() &&
          document_loader->GetTiming().UnloadEventEnd().is_null()) {
        DocumentLoadTiming& timing = document_loader->GetTiming();
        DCHECK(!timing.NavigationStart().is_null());
        const TimeTicks unload_event_start = CurrentTimeTicks();
        timing.MarkUnloadEventStart(unload_event_start);
        frame_->DomWindow()->DispatchEvent(unload_event, this);
        const TimeTicks unload_event_end = CurrentTimeTicks();
        DEFINE_STATIC_LOCAL(
            CustomCountHistogram, unload_histogram,
            (""DocumentEventTiming.UnloadDuration"", 0, 10000000, 50));
        unload_histogram.Count(
            (unload_event_end - unload_event_start).InMicroseconds());
        timing.MarkUnloadEventEnd(unload_event_end);
      } else {
        frame_->DomWindow()->DispatchEvent(unload_event, frame_->GetDocument());
      }
    }
    load_event_progress_ = kUnloadEventHandled;
  }

  if (!frame_)
    return;

   bool keep_event_listeners =
       frame_->Loader().GetProvisionalDocumentLoader() &&
       frame_->ShouldReuseDefaultView(
          frame_->Loader().GetProvisionalDocumentLoader()->Url());
   if (!keep_event_listeners)
     RemoveAllEventListenersRecursively();
 }
",C,"          frame_->Loader().GetProvisionalDocumentLoader()->Url(),
          frame_->Loader()
              .GetProvisionalDocumentLoader()
              ->GetContentSecurityPolicy());
","          frame_->Loader().GetProvisionalDocumentLoader()->Url());
",,"@@ -3569,7 +3569,10 @@ void Document::DispatchUnloadEvents() {
   bool keep_event_listeners =
       frame_->Loader().GetProvisionalDocumentLoader() &&
       frame_->ShouldReuseDefaultView(
-          frame_->Loader().GetProvisionalDocumentLoader()->Url());
+          frame_->Loader().GetProvisionalDocumentLoader()->Url(),
+          frame_->Loader()
+              .GetProvisionalDocumentLoader()
+              ->GetContentSecurityPolicy());
   if (!keep_event_listeners)
     RemoveAllEventListenersRecursively();
 }",Chrome,90f878780cce9c4b0475fcea14d91b8f510cce11,3476f410bff123a62a0542a6699f04f7536c38f8,1,"void Document::DispatchUnloadEvents() {
  PluginScriptForbiddenScope forbid_plugin_destructor_scripting;
  if (parser_)
    parser_->StopParsing();

  if (load_event_progress_ == kLoadEventNotRun)
    return;

  if (load_event_progress_ <= kUnloadEventInProgress) {
    Element* current_focused_element = FocusedElement();
    if (auto* input = ToHTMLInputElementOrNull(current_focused_element))
      input->EndEditing();
    if (load_event_progress_ < kPageHideInProgress) {
      load_event_progress_ = kPageHideInProgress;
      if (LocalDOMWindow* window = domWindow()) {
        const TimeTicks pagehide_event_start = CurrentTimeTicks();
        window->DispatchEvent(
            PageTransitionEvent::Create(EventTypeNames::pagehide, false), this);
        const TimeTicks pagehide_event_end = CurrentTimeTicks();
        DEFINE_STATIC_LOCAL(
            CustomCountHistogram, pagehide_histogram,
            (""DocumentEventTiming.PageHideDuration"", 0, 10000000, 50));
        pagehide_histogram.Count(
            (pagehide_event_end - pagehide_event_start).InMicroseconds());
      }
      if (!frame_)
        return;

      mojom::PageVisibilityState visibility_state = GetPageVisibilityState();
      load_event_progress_ = kUnloadVisibilityChangeInProgress;
      if (visibility_state != mojom::PageVisibilityState::kHidden) {
        // Dispatch visibilitychange event, but don't bother doing
        // other notifications as we're about to be unloaded.
        const TimeTicks pagevisibility_hidden_event_start = CurrentTimeTicks();
        DispatchEvent(Event::CreateBubble(EventTypeNames::visibilitychange));
        const TimeTicks pagevisibility_hidden_event_end = CurrentTimeTicks();
        DEFINE_STATIC_LOCAL(CustomCountHistogram, pagevisibility_histogram,
                            (""DocumentEventTiming.PageVibilityHiddenDuration"",
                             0, 10000000, 50));
        pagevisibility_histogram.Count((pagevisibility_hidden_event_end -
                                        pagevisibility_hidden_event_start)
                                           .InMicroseconds());
        DispatchEvent(
            Event::CreateBubble(EventTypeNames::webkitvisibilitychange));
      }
      if (!frame_)
        return;

      frame_->Loader().SaveScrollAnchor();

      DocumentLoader* document_loader =
          frame_->Loader().GetProvisionalDocumentLoader();
      load_event_progress_ = kUnloadEventInProgress;
      Event* unload_event(Event::Create(EventTypeNames::unload));
      if (document_loader &&
          document_loader->GetTiming().UnloadEventStart().is_null() &&
          document_loader->GetTiming().UnloadEventEnd().is_null()) {
        DocumentLoadTiming& timing = document_loader->GetTiming();
        DCHECK(!timing.NavigationStart().is_null());
        const TimeTicks unload_event_start = CurrentTimeTicks();
        timing.MarkUnloadEventStart(unload_event_start);
        frame_->DomWindow()->DispatchEvent(unload_event, this);
        const TimeTicks unload_event_end = CurrentTimeTicks();
        DEFINE_STATIC_LOCAL(
            CustomCountHistogram, unload_histogram,
            (""DocumentEventTiming.UnloadDuration"", 0, 10000000, 50));
        unload_histogram.Count(
            (unload_event_end - unload_event_start).InMicroseconds());
        timing.MarkUnloadEventEnd(unload_event_end);
      } else {
        frame_->DomWindow()->DispatchEvent(unload_event, frame_->GetDocument());
      }
    }
    load_event_progress_ = kUnloadEventHandled;
  }

  if (!frame_)
    return;

  // Don't remove event listeners from a transitional empty document (see
  // https://bugs.webkit.org/show_bug.cgi?id=28716 for more information).
   bool keep_event_listeners =
       frame_->Loader().GetProvisionalDocumentLoader() &&
       frame_->ShouldReuseDefaultView(
//flaw_line_below:
          frame_->Loader().GetProvisionalDocumentLoader()->Url());
//fix_flaw_line_below:
//          frame_->Loader().GetProvisionalDocumentLoader()->Url(),
//fix_flaw_line_below:
//          frame_->Loader()
//fix_flaw_line_below:
//              .GetProvisionalDocumentLoader()
//fix_flaw_line_below:
//              ->GetContentSecurityPolicy());
   if (!keep_event_listeners)
     RemoveAllEventListenersRecursively();
 }
"
9451,187187,,Remote,Not required,,CVE-2018-16077,https://www.cvedetails.com/cve/CVE-2018-16077/,CWE-285,Medium,,Partial,,2019-06-27,4.3,Object lifecycle issue in Blink in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass content security policy via a crafted HTML page.,2019-07-03,Bypass ,13,https://github.com/chromium/chromium/commit/90f878780cce9c4b0475fcea14d91b8f510cce11,90f878780cce9c4b0475fcea14d91b8f510cce11,"Prevent sandboxed documents from reusing the default window

Bug: 377995
Change-Id: Iff66c6d214dfd0cb7ea9c80f83afeedfff703541
Reviewed-on: https://chromium-review.googlesource.com/983558
Commit-Queue: Andy Paicu <andypaicu@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Cr-Commit-Position: refs/heads/master@{#567663}",0,third_party/blink/renderer/core/frame/local_frame.cc,"{""sha"": ""e58402e4ba668220326f7ca7757e22e1f4647a8f"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/sandbox-allow-scripts.sub.html"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/sandbox-allow-scripts.sub.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/sandbox-allow-scripts.sub.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/sandbox-allow-scripts.sub.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -16,7 +16,7 @@\n        }\n     </script>\n \n-    <iframe src=\""support/sandboxed-post-message-to-parent.sub.html?sandbox=allow-scripts\""></iframe>\n+    <iframe src=\""support/sandboxed-post-message-to-parent.html?sandbox=allow-scripts\""></iframe>\n </body>\n \n </html>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""ef4b1a0b95a7e00275c423d49dd28f98545950d3"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.html"", ""status"": ""renamed"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""previous_filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.sub.html""}<_**next**_>{""sha"": ""ebbb54d36d86fe3ee3696b7dc302de11cb4ac30c"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html"", ""status"": ""added"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -0,0 +1,3 @@\n+<script>\n+  window.opener.postMessage(window.testProperty, \""*\"");\n+</script>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""a7ea308208d81a9f9a2ec24004d5d1f72cf21f84"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html.sub.headers"", ""status"": ""renamed"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html.sub.headers"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html.sub.headers"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html.sub.headers?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""previous_filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.sub.html.sub.headers""}<_**next**_>{""sha"": ""ebbb54d36d86fe3ee3696b7dc302de11cb4ac30c"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/unsandboxed-post-property-to-opener.html"", ""status"": ""added"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/unsandboxed-post-property-to-opener.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/unsandboxed-post-property-to-opener.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/unsandboxed-post-property-to-opener.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -0,0 +1,3 @@\n+<script>\n+  window.opener.postMessage(window.testProperty, \""*\"");\n+</script>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""a7a080daf72ee8ae97f5adf433f17c947892d4ce"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-sandboxed.html"", ""status"": ""added"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-sandboxed.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-sandboxed.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-sandboxed.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -0,0 +1,22 @@\n+<!DOCTYPE html>\n+<html>\n+\n+<head>\n+    <script src=\""/resources/testharness.js\""></script>\n+    <script src=\""/resources/testharnessreport.js\""></script>\n+</head>\n+\n+<body>\n+    <script>\n+      var t = async_test(\""Window object should not be reused\"");\n+\n+      window.onmessage = t.step_func_done(function(e) {\n+        assert_equals(e.data, undefined);\n+      });\n+\n+      w = window.open(\""support/sandboxed-post-property-to-opener.html?sandbox=allow-scripts\"",\""\"",\""width=400,height=400\"");\n+      w.testProperty = \""test\"";\n+    </script>\n+</body>\n+\n+</html>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""dd69c41354b583e427d4e12a060f1b6f71eb2c86"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-unsandboxed.html"", ""status"": ""added"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-unsandboxed.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-unsandboxed.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-unsandboxed.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -0,0 +1,22 @@\n+<!DOCTYPE html>\n+<html>\n+\n+<head>\n+    <script src=\""/resources/testharness.js\""></script>\n+    <script src=\""/resources/testharnessreport.js\""></script>\n+</head>\n+\n+<body>\n+    <script>\n+      var t = async_test(\""Window object should be reused\"");\n+\n+      window.onmessage = t.step_func_done(function(e) {\n+        assert_equals(e.data, \""test\"");\n+      });\n+\n+      w = window.open(\""support/unsandboxed-post-property-to-opener.html\"",\""\"",\""width=400,height=400\"");\n+      w.testProperty = \""test\"";\n+    </script>\n+</body>\n+\n+</html>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""c51cf5bfd4df6c9768e28caba8fcceb5a4332fef"", ""filename"": ""third_party/blink/renderer/core/dom/document.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/dom/document.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/dom/document.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/dom/document.cc?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -3569,7 +3569,10 @@ void Document::DispatchUnloadEvents() {\n   bool keep_event_listeners =\n       frame_->Loader().GetProvisionalDocumentLoader() &&\n       frame_->ShouldReuseDefaultView(\n-          frame_->Loader().GetProvisionalDocumentLoader()->Url());\n+          frame_->Loader().GetProvisionalDocumentLoader()->Url(),\n+          frame_->Loader()\n+              .GetProvisionalDocumentLoader()\n+              ->GetContentSecurityPolicy());\n   if (!keep_event_listeners)\n     RemoveAllEventListenersRecursively();\n }""}<_**next**_>{""sha"": ""12569fa32df76e82f80b638658a75571c227b98a"", ""filename"": ""third_party/blink/renderer/core/execution_context/security_context.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/execution_context/security_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/execution_context/security_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/execution_context/security_context.h?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -79,7 +79,12 @@ class CORE_EXPORT SecurityContext : public GarbageCollectedMixin {\n   virtual void DidUpdateSecurityOrigin() = 0;\n \n   SandboxFlags GetSandboxFlags() const { return sandbox_flags_; }\n-  bool IsSandboxed(SandboxFlags mask) const { return sandbox_flags_ & mask; }\n+  bool IsSandboxed(SandboxFlags mask) const {\n+    return IsSandboxed(mask, sandbox_flags_);\n+  }\n+  static bool IsSandboxed(SandboxFlags mask, SandboxFlags sandbox_flags) {\n+    return sandbox_flags & mask;\n+  }\n   virtual void EnforceSandboxFlags(SandboxFlags mask);\n \n   void SetAddressSpace(mojom::IPAddressSpace space) { address_space_ = space; }""}<_**next**_>{""sha"": ""204bb1e4547d523bbba1018e3448c00c45b4f73e"", ""filename"": ""third_party/blink/renderer/core/frame/csp/content_security_policy.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/csp/content_security_policy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/csp/content_security_policy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/frame/csp/content_security_policy.h?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -455,6 +455,12 @@ class CORE_EXPORT ContentSecurityPolicy\n   // perform these checks in NavigationRequest::CheckContentSecurityPolicy.\n   WebContentSecurityPolicyList ExposeForNavigationalChecks() const;\n \n+  // Retrieves the parsed sandbox flags. A lot of the time the execution\n+  // context will be used for all sandbox checks but there are situations\n+  // (before installing the document that this CSP will bind to) when\n+  // there is no execution context to enforce the sandbox flags.\n+  SandboxFlags GetSandboxMask() const { return sandbox_mask_; }\n+\n  private:\n   FRIEND_TEST_ALL_PREFIXES(ContentSecurityPolicyTest, NonceInline);\n   FRIEND_TEST_ALL_PREFIXES(ContentSecurityPolicyTest, NonceSinglePolicy);""}<_**next**_>{""sha"": ""ccc77a631977883052d2bd6e7826ef8726944301"", ""filename"": ""third_party/blink/renderer/core/frame/local_frame.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/local_frame.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/local_frame.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/frame/local_frame.cc?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -822,12 +822,24 @@ Document* LocalFrame::DocumentAtPoint(const LayoutPoint& point_in_root_frame) {\n   return result.InnerNode() ? &result.InnerNode()->GetDocument() : nullptr;\n }\n \n-bool LocalFrame::ShouldReuseDefaultView(const KURL& url) const {\n+bool LocalFrame::ShouldReuseDefaultView(\n+    const KURL& url,\n+    const ContentSecurityPolicy* csp) const {\n   // Secure transitions can only happen when navigating from the initial empty\n   // document.\n   if (!Loader().StateMachine()->IsDisplayingInitialEmptyDocument())\n     return false;\n \n+  // The Window object should only be re-used if it is same-origin.\n+  // Since sandboxing turns the origin into an opaque origin it needs to also\n+  // be considered when deciding whether to reuse it.\n+  // Spec:\n+  // https://html.spec.whatwg.org/multipage/browsing-the-web.html#initialise-the-document-object\n+  if (csp &&\n+      SecurityContext::IsSandboxed(kSandboxOrigin, csp->GetSandboxMask())) {\n+    return false;\n+  }\n+\n   return GetDocument()->IsSecureTransitionTo(url);\n }\n ""}<_**next**_>{""sha"": ""9633b2e5b26664936682590a04b3f5794b673c33"", ""filename"": ""third_party/blink/renderer/core/frame/local_frame.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/local_frame.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/local_frame.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/frame/local_frame.h?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -230,7 +230,7 @@ class CORE_EXPORT LocalFrame final : public Frame,\n   PositionForPoint(const LayoutPoint& frame_point);\n   Document* DocumentAtPoint(const LayoutPoint&);\n \n-  bool ShouldReuseDefaultView(const KURL&) const;\n+  bool ShouldReuseDefaultView(const KURL&, const ContentSecurityPolicy*) const;\n   void RemoveSpellingMarkersUnderWords(const Vector<String>& words);\n \n   bool ShouldThrottleRendering() const;""}<_**next**_>{""sha"": ""6c62eca9db3829767e1f57da62585180ac1ba0cc"", ""filename"": ""third_party/blink/renderer/core/loader/document_loader.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 6, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/document_loader.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/document_loader.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/loader/document_loader.cc?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -711,12 +711,13 @@ void DocumentLoader::CommitNavigation(const AtomicString& mime_type,\n   if (!Document::ThreadedParsingEnabledForTesting())\n     parsing_policy = kForceSynchronousParsing;\n \n-  InstallNewDocument(Url(), owner_document,\n-                     frame_->ShouldReuseDefaultView(Url())\n-                         ? WebGlobalObjectReusePolicy::kUseExisting\n-                         : WebGlobalObjectReusePolicy::kCreateNew,\n-                     mime_type, encoding, InstallNewDocumentReason::kNavigation,\n-                     parsing_policy, overriding_url);\n+  InstallNewDocument(\n+      Url(), owner_document,\n+      frame_->ShouldReuseDefaultView(Url(), GetContentSecurityPolicy())\n+          ? WebGlobalObjectReusePolicy::kUseExisting\n+          : WebGlobalObjectReusePolicy::kCreateNew,\n+      mime_type, encoding, InstallNewDocumentReason::kNavigation,\n+      parsing_policy, overriding_url);\n   parser_->SetDocumentWasLoadedAsPartOfNavigation();\n   if (request_.WasDiscarded())\n     frame_->GetDocument()->SetWasDiscarded(true);""}<_**next**_>{""sha"": ""0e1a7006f5549970828957b647fdcb44c38e8d64"", ""filename"": ""third_party/blink/renderer/core/loader/document_loader.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/document_loader.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/document_loader.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/loader/document_loader.h?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -252,6 +252,13 @@ class CORE_EXPORT DocumentLoader\n   void BlockParser();\n   void ResumeParser();\n \n+  // Returns the currently stored content security policy, if this is called\n+  // after the document has been installed it will return nullptr as the\n+  // CSP belongs to the document at that point.\n+  const ContentSecurityPolicy* GetContentSecurityPolicy() const {\n+    return content_security_policy_.Get();\n+  }\n+\n  protected:\n   DocumentLoader(LocalFrame*,\n                  const ResourceRequest&,""}<_**next**_>{""sha"": ""b18dcdec03934315d44a79a965cb84e0d0501e11"", ""filename"": ""third_party/blink/renderer/core/loader/frame_loader.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/frame_loader.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/frame_loader.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/loader/frame_loader.cc?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -365,8 +365,12 @@ void FrameLoader::ReplaceDocumentWhileExecutingJavaScriptURL(\n \n   // Compute this before clearing the frame, because it may need to inherit an\n   // aliased security context.\n+  // The document CSP is the correct one as it is used for CSP checks\n+  // done previously before getting here:\n+  // HTMLFormElement::ScheduleFormSubmission\n+  // HTMLFrameElementBase::OpenURL\n   WebGlobalObjectReusePolicy global_object_reuse_policy =\n-      frame_->ShouldReuseDefaultView(url)\n+      frame_->ShouldReuseDefaultView(url, document->GetContentSecurityPolicy())\n           ? WebGlobalObjectReusePolicy::kUseExisting\n           : WebGlobalObjectReusePolicy::kCreateNew;\n ""}","bool LocalFrame::ShouldReuseDefaultView(const KURL& url) const {
bool LocalFrame::ShouldReuseDefaultView(
    const KURL& url,
    const ContentSecurityPolicy* csp) const {
   if (!Loader().StateMachine()->IsDisplayingInitialEmptyDocument())
     return false;
 
  // The Window object should only be re-used if it is same-origin.
  // Since sandboxing turns the origin into an opaque origin it needs to also
  // be considered when deciding whether to reuse it.
  // Spec:
  // https://html.spec.whatwg.org/multipage/browsing-the-web.html#initialise-the-document-object
  if (csp &&
      SecurityContext::IsSandboxed(kSandboxOrigin, csp->GetSandboxMask())) {
    return false;
  }

   return GetDocument()->IsSecureTransitionTo(url);
 }
","bool LocalFrame::ShouldReuseDefaultView(const KURL& url) const {
   if (!Loader().StateMachine()->IsDisplayingInitialEmptyDocument())
     return false;
 
   return GetDocument()->IsSecureTransitionTo(url);
 }
",C,"bool LocalFrame::ShouldReuseDefaultView(
    const KURL& url,
    const ContentSecurityPolicy* csp) const {
  // The Window object should only be re-used if it is same-origin.
  // Since sandboxing turns the origin into an opaque origin it needs to also
  // be considered when deciding whether to reuse it.
  // Spec:
  // https://html.spec.whatwg.org/multipage/browsing-the-web.html#initialise-the-document-object
  if (csp &&
      SecurityContext::IsSandboxed(kSandboxOrigin, csp->GetSandboxMask())) {
    return false;
  }

",,,"@@ -822,12 +822,24 @@ Document* LocalFrame::DocumentAtPoint(const LayoutPoint& point_in_root_frame) {
   return result.InnerNode() ? &result.InnerNode()->GetDocument() : nullptr;
 }
 
-bool LocalFrame::ShouldReuseDefaultView(const KURL& url) const {
+bool LocalFrame::ShouldReuseDefaultView(
+    const KURL& url,
+    const ContentSecurityPolicy* csp) const {
   // Secure transitions can only happen when navigating from the initial empty
   // document.
   if (!Loader().StateMachine()->IsDisplayingInitialEmptyDocument())
     return false;
 
+  // The Window object should only be re-used if it is same-origin.
+  // Since sandboxing turns the origin into an opaque origin it needs to also
+  // be considered when deciding whether to reuse it.
+  // Spec:
+  // https://html.spec.whatwg.org/multipage/browsing-the-web.html#initialise-the-document-object
+  if (csp &&
+      SecurityContext::IsSandboxed(kSandboxOrigin, csp->GetSandboxMask())) {
+    return false;
+  }
+
   return GetDocument()->IsSecureTransitionTo(url);
 }
 ",Chrome,90f878780cce9c4b0475fcea14d91b8f510cce11,3476f410bff123a62a0542a6699f04f7536c38f8,1,"bool LocalFrame::ShouldReuseDefaultView(const KURL& url) const {
//fix_flaw_line_below:
//bool LocalFrame::ShouldReuseDefaultView(
//fix_flaw_line_below:
//    const KURL& url,
//fix_flaw_line_below:
//    const ContentSecurityPolicy* csp) const {
   // Secure transitions can only happen when navigating from the initial empty
   // document.
   if (!Loader().StateMachine()->IsDisplayingInitialEmptyDocument())
     return false;
 
//fix_flaw_line_below:
//  // The Window object should only be re-used if it is same-origin.
//fix_flaw_line_below:
//  // Since sandboxing turns the origin into an opaque origin it needs to also
//fix_flaw_line_below:
//  // be considered when deciding whether to reuse it.
//fix_flaw_line_below:
//  // Spec:
//fix_flaw_line_below:
//  // https://html.spec.whatwg.org/multipage/browsing-the-web.html#initialise-the-document-object
//fix_flaw_line_below:
//  if (csp &&
//fix_flaw_line_below:
//      SecurityContext::IsSandboxed(kSandboxOrigin, csp->GetSandboxMask())) {
//fix_flaw_line_below:
//    return false;
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   return GetDocument()->IsSecureTransitionTo(url);
 }
"
9452,187188,,Remote,Not required,,CVE-2018-16077,https://www.cvedetails.com/cve/CVE-2018-16077/,CWE-285,Medium,,Partial,,2019-06-27,4.3,Object lifecycle issue in Blink in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass content security policy via a crafted HTML page.,2019-07-03,Bypass ,7,https://github.com/chromium/chromium/commit/90f878780cce9c4b0475fcea14d91b8f510cce11,90f878780cce9c4b0475fcea14d91b8f510cce11,"Prevent sandboxed documents from reusing the default window

Bug: 377995
Change-Id: Iff66c6d214dfd0cb7ea9c80f83afeedfff703541
Reviewed-on: https://chromium-review.googlesource.com/983558
Commit-Queue: Andy Paicu <andypaicu@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Cr-Commit-Position: refs/heads/master@{#567663}",6,third_party/blink/renderer/core/loader/document_loader.cc,"{""sha"": ""e58402e4ba668220326f7ca7757e22e1f4647a8f"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/sandbox-allow-scripts.sub.html"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/sandbox-allow-scripts.sub.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/sandbox-allow-scripts.sub.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/sandbox-allow-scripts.sub.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -16,7 +16,7 @@\n        }\n     </script>\n \n-    <iframe src=\""support/sandboxed-post-message-to-parent.sub.html?sandbox=allow-scripts\""></iframe>\n+    <iframe src=\""support/sandboxed-post-message-to-parent.html?sandbox=allow-scripts\""></iframe>\n </body>\n \n </html>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""ef4b1a0b95a7e00275c423d49dd28f98545950d3"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.html"", ""status"": ""renamed"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""previous_filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.sub.html""}<_**next**_>{""sha"": ""ebbb54d36d86fe3ee3696b7dc302de11cb4ac30c"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html"", ""status"": ""added"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -0,0 +1,3 @@\n+<script>\n+  window.opener.postMessage(window.testProperty, \""*\"");\n+</script>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""a7ea308208d81a9f9a2ec24004d5d1f72cf21f84"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html.sub.headers"", ""status"": ""renamed"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html.sub.headers"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html.sub.headers"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html.sub.headers?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""previous_filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.sub.html.sub.headers""}<_**next**_>{""sha"": ""ebbb54d36d86fe3ee3696b7dc302de11cb4ac30c"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/unsandboxed-post-property-to-opener.html"", ""status"": ""added"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/unsandboxed-post-property-to-opener.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/unsandboxed-post-property-to-opener.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/unsandboxed-post-property-to-opener.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -0,0 +1,3 @@\n+<script>\n+  window.opener.postMessage(window.testProperty, \""*\"");\n+</script>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""a7a080daf72ee8ae97f5adf433f17c947892d4ce"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-sandboxed.html"", ""status"": ""added"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-sandboxed.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-sandboxed.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-sandboxed.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -0,0 +1,22 @@\n+<!DOCTYPE html>\n+<html>\n+\n+<head>\n+    <script src=\""/resources/testharness.js\""></script>\n+    <script src=\""/resources/testharnessreport.js\""></script>\n+</head>\n+\n+<body>\n+    <script>\n+      var t = async_test(\""Window object should not be reused\"");\n+\n+      window.onmessage = t.step_func_done(function(e) {\n+        assert_equals(e.data, undefined);\n+      });\n+\n+      w = window.open(\""support/sandboxed-post-property-to-opener.html?sandbox=allow-scripts\"",\""\"",\""width=400,height=400\"");\n+      w.testProperty = \""test\"";\n+    </script>\n+</body>\n+\n+</html>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""dd69c41354b583e427d4e12a060f1b6f71eb2c86"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-unsandboxed.html"", ""status"": ""added"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-unsandboxed.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-unsandboxed.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-unsandboxed.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -0,0 +1,22 @@\n+<!DOCTYPE html>\n+<html>\n+\n+<head>\n+    <script src=\""/resources/testharness.js\""></script>\n+    <script src=\""/resources/testharnessreport.js\""></script>\n+</head>\n+\n+<body>\n+    <script>\n+      var t = async_test(\""Window object should be reused\"");\n+\n+      window.onmessage = t.step_func_done(function(e) {\n+        assert_equals(e.data, \""test\"");\n+      });\n+\n+      w = window.open(\""support/unsandboxed-post-property-to-opener.html\"",\""\"",\""width=400,height=400\"");\n+      w.testProperty = \""test\"";\n+    </script>\n+</body>\n+\n+</html>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""c51cf5bfd4df6c9768e28caba8fcceb5a4332fef"", ""filename"": ""third_party/blink/renderer/core/dom/document.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/dom/document.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/dom/document.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/dom/document.cc?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -3569,7 +3569,10 @@ void Document::DispatchUnloadEvents() {\n   bool keep_event_listeners =\n       frame_->Loader().GetProvisionalDocumentLoader() &&\n       frame_->ShouldReuseDefaultView(\n-          frame_->Loader().GetProvisionalDocumentLoader()->Url());\n+          frame_->Loader().GetProvisionalDocumentLoader()->Url(),\n+          frame_->Loader()\n+              .GetProvisionalDocumentLoader()\n+              ->GetContentSecurityPolicy());\n   if (!keep_event_listeners)\n     RemoveAllEventListenersRecursively();\n }""}<_**next**_>{""sha"": ""12569fa32df76e82f80b638658a75571c227b98a"", ""filename"": ""third_party/blink/renderer/core/execution_context/security_context.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/execution_context/security_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/execution_context/security_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/execution_context/security_context.h?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -79,7 +79,12 @@ class CORE_EXPORT SecurityContext : public GarbageCollectedMixin {\n   virtual void DidUpdateSecurityOrigin() = 0;\n \n   SandboxFlags GetSandboxFlags() const { return sandbox_flags_; }\n-  bool IsSandboxed(SandboxFlags mask) const { return sandbox_flags_ & mask; }\n+  bool IsSandboxed(SandboxFlags mask) const {\n+    return IsSandboxed(mask, sandbox_flags_);\n+  }\n+  static bool IsSandboxed(SandboxFlags mask, SandboxFlags sandbox_flags) {\n+    return sandbox_flags & mask;\n+  }\n   virtual void EnforceSandboxFlags(SandboxFlags mask);\n \n   void SetAddressSpace(mojom::IPAddressSpace space) { address_space_ = space; }""}<_**next**_>{""sha"": ""204bb1e4547d523bbba1018e3448c00c45b4f73e"", ""filename"": ""third_party/blink/renderer/core/frame/csp/content_security_policy.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/csp/content_security_policy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/csp/content_security_policy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/frame/csp/content_security_policy.h?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -455,6 +455,12 @@ class CORE_EXPORT ContentSecurityPolicy\n   // perform these checks in NavigationRequest::CheckContentSecurityPolicy.\n   WebContentSecurityPolicyList ExposeForNavigationalChecks() const;\n \n+  // Retrieves the parsed sandbox flags. A lot of the time the execution\n+  // context will be used for all sandbox checks but there are situations\n+  // (before installing the document that this CSP will bind to) when\n+  // there is no execution context to enforce the sandbox flags.\n+  SandboxFlags GetSandboxMask() const { return sandbox_mask_; }\n+\n  private:\n   FRIEND_TEST_ALL_PREFIXES(ContentSecurityPolicyTest, NonceInline);\n   FRIEND_TEST_ALL_PREFIXES(ContentSecurityPolicyTest, NonceSinglePolicy);""}<_**next**_>{""sha"": ""ccc77a631977883052d2bd6e7826ef8726944301"", ""filename"": ""third_party/blink/renderer/core/frame/local_frame.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/local_frame.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/local_frame.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/frame/local_frame.cc?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -822,12 +822,24 @@ Document* LocalFrame::DocumentAtPoint(const LayoutPoint& point_in_root_frame) {\n   return result.InnerNode() ? &result.InnerNode()->GetDocument() : nullptr;\n }\n \n-bool LocalFrame::ShouldReuseDefaultView(const KURL& url) const {\n+bool LocalFrame::ShouldReuseDefaultView(\n+    const KURL& url,\n+    const ContentSecurityPolicy* csp) const {\n   // Secure transitions can only happen when navigating from the initial empty\n   // document.\n   if (!Loader().StateMachine()->IsDisplayingInitialEmptyDocument())\n     return false;\n \n+  // The Window object should only be re-used if it is same-origin.\n+  // Since sandboxing turns the origin into an opaque origin it needs to also\n+  // be considered when deciding whether to reuse it.\n+  // Spec:\n+  // https://html.spec.whatwg.org/multipage/browsing-the-web.html#initialise-the-document-object\n+  if (csp &&\n+      SecurityContext::IsSandboxed(kSandboxOrigin, csp->GetSandboxMask())) {\n+    return false;\n+  }\n+\n   return GetDocument()->IsSecureTransitionTo(url);\n }\n ""}<_**next**_>{""sha"": ""9633b2e5b26664936682590a04b3f5794b673c33"", ""filename"": ""third_party/blink/renderer/core/frame/local_frame.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/local_frame.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/local_frame.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/frame/local_frame.h?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -230,7 +230,7 @@ class CORE_EXPORT LocalFrame final : public Frame,\n   PositionForPoint(const LayoutPoint& frame_point);\n   Document* DocumentAtPoint(const LayoutPoint&);\n \n-  bool ShouldReuseDefaultView(const KURL&) const;\n+  bool ShouldReuseDefaultView(const KURL&, const ContentSecurityPolicy*) const;\n   void RemoveSpellingMarkersUnderWords(const Vector<String>& words);\n \n   bool ShouldThrottleRendering() const;""}<_**next**_>{""sha"": ""6c62eca9db3829767e1f57da62585180ac1ba0cc"", ""filename"": ""third_party/blink/renderer/core/loader/document_loader.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 6, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/document_loader.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/document_loader.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/loader/document_loader.cc?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -711,12 +711,13 @@ void DocumentLoader::CommitNavigation(const AtomicString& mime_type,\n   if (!Document::ThreadedParsingEnabledForTesting())\n     parsing_policy = kForceSynchronousParsing;\n \n-  InstallNewDocument(Url(), owner_document,\n-                     frame_->ShouldReuseDefaultView(Url())\n-                         ? WebGlobalObjectReusePolicy::kUseExisting\n-                         : WebGlobalObjectReusePolicy::kCreateNew,\n-                     mime_type, encoding, InstallNewDocumentReason::kNavigation,\n-                     parsing_policy, overriding_url);\n+  InstallNewDocument(\n+      Url(), owner_document,\n+      frame_->ShouldReuseDefaultView(Url(), GetContentSecurityPolicy())\n+          ? WebGlobalObjectReusePolicy::kUseExisting\n+          : WebGlobalObjectReusePolicy::kCreateNew,\n+      mime_type, encoding, InstallNewDocumentReason::kNavigation,\n+      parsing_policy, overriding_url);\n   parser_->SetDocumentWasLoadedAsPartOfNavigation();\n   if (request_.WasDiscarded())\n     frame_->GetDocument()->SetWasDiscarded(true);""}<_**next**_>{""sha"": ""0e1a7006f5549970828957b647fdcb44c38e8d64"", ""filename"": ""third_party/blink/renderer/core/loader/document_loader.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/document_loader.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/document_loader.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/loader/document_loader.h?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -252,6 +252,13 @@ class CORE_EXPORT DocumentLoader\n   void BlockParser();\n   void ResumeParser();\n \n+  // Returns the currently stored content security policy, if this is called\n+  // after the document has been installed it will return nullptr as the\n+  // CSP belongs to the document at that point.\n+  const ContentSecurityPolicy* GetContentSecurityPolicy() const {\n+    return content_security_policy_.Get();\n+  }\n+\n  protected:\n   DocumentLoader(LocalFrame*,\n                  const ResourceRequest&,""}<_**next**_>{""sha"": ""b18dcdec03934315d44a79a965cb84e0d0501e11"", ""filename"": ""third_party/blink/renderer/core/loader/frame_loader.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/frame_loader.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/frame_loader.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/loader/frame_loader.cc?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -365,8 +365,12 @@ void FrameLoader::ReplaceDocumentWhileExecutingJavaScriptURL(\n \n   // Compute this before clearing the frame, because it may need to inherit an\n   // aliased security context.\n+  // The document CSP is the correct one as it is used for CSP checks\n+  // done previously before getting here:\n+  // HTMLFormElement::ScheduleFormSubmission\n+  // HTMLFrameElementBase::OpenURL\n   WebGlobalObjectReusePolicy global_object_reuse_policy =\n-      frame_->ShouldReuseDefaultView(url)\n+      frame_->ShouldReuseDefaultView(url, document->GetContentSecurityPolicy())\n           ? WebGlobalObjectReusePolicy::kUseExisting\n           : WebGlobalObjectReusePolicy::kCreateNew;\n ""}","void DocumentLoader::CommitNavigation(const AtomicString& mime_type,
                                      const KURL& overriding_url) {
  if (state_ != kProvisional)
    return;

  if (!GetFrameLoader().StateMachine()->CreatingInitialEmptyDocument()) {
    SetHistoryItemStateForCommit(
        GetFrameLoader().GetDocumentLoader()->GetHistoryItem(), load_type_,
        HistoryNavigationType::kDifferentDocument);
  }

  DCHECK_EQ(state_, kProvisional);
  GetFrameLoader().CommitProvisionalLoad();
  if (!frame_)
    return;

  const AtomicString& encoding = GetResponse().TextEncodingName();

  Document* owner_document = nullptr;
  if (Document::ShouldInheritSecurityOriginFromOwner(Url())) {
    Frame* owner_frame = frame_->Tree().Parent();
    if (!owner_frame)
      owner_frame = frame_->Loader().Opener();
    if (owner_frame && owner_frame->IsLocalFrame())
      owner_document = ToLocalFrame(owner_frame)->GetDocument();
  }
  DCHECK(frame_->GetPage());

  ParserSynchronizationPolicy parsing_policy = kAllowAsynchronousParsing;
   if (!Document::ThreadedParsingEnabledForTesting())
     parsing_policy = kForceSynchronousParsing;
 
  InstallNewDocument(
      Url(), owner_document,
      frame_->ShouldReuseDefaultView(Url(), GetContentSecurityPolicy())
          ? WebGlobalObjectReusePolicy::kUseExisting
          : WebGlobalObjectReusePolicy::kCreateNew,
      mime_type, encoding, InstallNewDocumentReason::kNavigation,
      parsing_policy, overriding_url);
   parser_->SetDocumentWasLoadedAsPartOfNavigation();
   if (request_.WasDiscarded())
     frame_->GetDocument()->SetWasDiscarded(true);
  frame_->GetDocument()->MaybeHandleHttpRefresh(
      response_.HttpHeaderField(HTTPNames::Refresh),
      Document::kHttpRefreshFromHeader);
}
","void DocumentLoader::CommitNavigation(const AtomicString& mime_type,
                                      const KURL& overriding_url) {
  if (state_ != kProvisional)
    return;

  if (!GetFrameLoader().StateMachine()->CreatingInitialEmptyDocument()) {
    SetHistoryItemStateForCommit(
        GetFrameLoader().GetDocumentLoader()->GetHistoryItem(), load_type_,
        HistoryNavigationType::kDifferentDocument);
  }

  DCHECK_EQ(state_, kProvisional);
  GetFrameLoader().CommitProvisionalLoad();
  if (!frame_)
    return;

  const AtomicString& encoding = GetResponse().TextEncodingName();

  Document* owner_document = nullptr;
  if (Document::ShouldInheritSecurityOriginFromOwner(Url())) {
    Frame* owner_frame = frame_->Tree().Parent();
    if (!owner_frame)
      owner_frame = frame_->Loader().Opener();
    if (owner_frame && owner_frame->IsLocalFrame())
      owner_document = ToLocalFrame(owner_frame)->GetDocument();
  }
  DCHECK(frame_->GetPage());

  ParserSynchronizationPolicy parsing_policy = kAllowAsynchronousParsing;
   if (!Document::ThreadedParsingEnabledForTesting())
     parsing_policy = kForceSynchronousParsing;
 
  InstallNewDocument(Url(), owner_document,
                     frame_->ShouldReuseDefaultView(Url())
                         ? WebGlobalObjectReusePolicy::kUseExisting
                         : WebGlobalObjectReusePolicy::kCreateNew,
                     mime_type, encoding, InstallNewDocumentReason::kNavigation,
                     parsing_policy, overriding_url);
   parser_->SetDocumentWasLoadedAsPartOfNavigation();
   if (request_.WasDiscarded())
     frame_->GetDocument()->SetWasDiscarded(true);
  frame_->GetDocument()->MaybeHandleHttpRefresh(
      response_.HttpHeaderField(HTTPNames::Refresh),
      Document::kHttpRefreshFromHeader);
}
",C,"  InstallNewDocument(
      Url(), owner_document,
      frame_->ShouldReuseDefaultView(Url(), GetContentSecurityPolicy())
          ? WebGlobalObjectReusePolicy::kUseExisting
          : WebGlobalObjectReusePolicy::kCreateNew,
      mime_type, encoding, InstallNewDocumentReason::kNavigation,
      parsing_policy, overriding_url);
","  InstallNewDocument(Url(), owner_document,
                     frame_->ShouldReuseDefaultView(Url())
                         ? WebGlobalObjectReusePolicy::kUseExisting
                         : WebGlobalObjectReusePolicy::kCreateNew,
                     mime_type, encoding, InstallNewDocumentReason::kNavigation,
                     parsing_policy, overriding_url);
",,"@@ -711,12 +711,13 @@ void DocumentLoader::CommitNavigation(const AtomicString& mime_type,
   if (!Document::ThreadedParsingEnabledForTesting())
     parsing_policy = kForceSynchronousParsing;
 
-  InstallNewDocument(Url(), owner_document,
-                     frame_->ShouldReuseDefaultView(Url())
-                         ? WebGlobalObjectReusePolicy::kUseExisting
-                         : WebGlobalObjectReusePolicy::kCreateNew,
-                     mime_type, encoding, InstallNewDocumentReason::kNavigation,
-                     parsing_policy, overriding_url);
+  InstallNewDocument(
+      Url(), owner_document,
+      frame_->ShouldReuseDefaultView(Url(), GetContentSecurityPolicy())
+          ? WebGlobalObjectReusePolicy::kUseExisting
+          : WebGlobalObjectReusePolicy::kCreateNew,
+      mime_type, encoding, InstallNewDocumentReason::kNavigation,
+      parsing_policy, overriding_url);
   parser_->SetDocumentWasLoadedAsPartOfNavigation();
   if (request_.WasDiscarded())
     frame_->GetDocument()->SetWasDiscarded(true);",Chrome,90f878780cce9c4b0475fcea14d91b8f510cce11,3476f410bff123a62a0542a6699f04f7536c38f8,1,"void DocumentLoader::CommitNavigation(const AtomicString& mime_type,
                                      const KURL& overriding_url) {
  if (state_ != kProvisional)
    return;

  // Set history state before commitProvisionalLoad() so that we still have
  // access to the previous committed DocumentLoader's HistoryItem, in case we
  // need to copy state from it.
  if (!GetFrameLoader().StateMachine()->CreatingInitialEmptyDocument()) {
    SetHistoryItemStateForCommit(
        GetFrameLoader().GetDocumentLoader()->GetHistoryItem(), load_type_,
        HistoryNavigationType::kDifferentDocument);
  }

  DCHECK_EQ(state_, kProvisional);
  GetFrameLoader().CommitProvisionalLoad();
  if (!frame_)
    return;

  const AtomicString& encoding = GetResponse().TextEncodingName();

  // Prepare a DocumentInit before clearing the frame, because it may need to
  // inherit an aliased security context.
  Document* owner_document = nullptr;
  // TODO(dcheng): This differs from the behavior of both IE and Firefox: the
  // origin is inherited from the document that loaded the URL.
  if (Document::ShouldInheritSecurityOriginFromOwner(Url())) {
    Frame* owner_frame = frame_->Tree().Parent();
    if (!owner_frame)
      owner_frame = frame_->Loader().Opener();
    if (owner_frame && owner_frame->IsLocalFrame())
      owner_document = ToLocalFrame(owner_frame)->GetDocument();
  }
  DCHECK(frame_->GetPage());

  ParserSynchronizationPolicy parsing_policy = kAllowAsynchronousParsing;
   if (!Document::ThreadedParsingEnabledForTesting())
     parsing_policy = kForceSynchronousParsing;
 
//flaw_line_below:
  InstallNewDocument(Url(), owner_document,
//flaw_line_below:
                     frame_->ShouldReuseDefaultView(Url())
//flaw_line_below:
                         ? WebGlobalObjectReusePolicy::kUseExisting
//flaw_line_below:
                         : WebGlobalObjectReusePolicy::kCreateNew,
//flaw_line_below:
                     mime_type, encoding, InstallNewDocumentReason::kNavigation,
//flaw_line_below:
                     parsing_policy, overriding_url);
//fix_flaw_line_below:
//  InstallNewDocument(
//fix_flaw_line_below:
//      Url(), owner_document,
//fix_flaw_line_below:
//      frame_->ShouldReuseDefaultView(Url(), GetContentSecurityPolicy())
//fix_flaw_line_below:
//          ? WebGlobalObjectReusePolicy::kUseExisting
//fix_flaw_line_below:
//          : WebGlobalObjectReusePolicy::kCreateNew,
//fix_flaw_line_below:
//      mime_type, encoding, InstallNewDocumentReason::kNavigation,
//fix_flaw_line_below:
//      parsing_policy, overriding_url);
   parser_->SetDocumentWasLoadedAsPartOfNavigation();
   if (request_.WasDiscarded())
     frame_->GetDocument()->SetWasDiscarded(true);
  frame_->GetDocument()->MaybeHandleHttpRefresh(
      response_.HttpHeaderField(HTTPNames::Refresh),
      Document::kHttpRefreshFromHeader);
}
"
9453,187189,,Remote,Not required,,CVE-2018-16077,https://www.cvedetails.com/cve/CVE-2018-16077/,CWE-285,Medium,,Partial,,2019-06-27,4.3,Object lifecycle issue in Blink in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass content security policy via a crafted HTML page.,2019-07-03,Bypass ,5,https://github.com/chromium/chromium/commit/90f878780cce9c4b0475fcea14d91b8f510cce11,90f878780cce9c4b0475fcea14d91b8f510cce11,"Prevent sandboxed documents from reusing the default window

Bug: 377995
Change-Id: Iff66c6d214dfd0cb7ea9c80f83afeedfff703541
Reviewed-on: https://chromium-review.googlesource.com/983558
Commit-Queue: Andy Paicu <andypaicu@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Cr-Commit-Position: refs/heads/master@{#567663}",1,third_party/blink/renderer/core/loader/frame_loader.cc,"{""sha"": ""e58402e4ba668220326f7ca7757e22e1f4647a8f"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/sandbox-allow-scripts.sub.html"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/sandbox-allow-scripts.sub.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/sandbox-allow-scripts.sub.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/sandbox-allow-scripts.sub.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -16,7 +16,7 @@\n        }\n     </script>\n \n-    <iframe src=\""support/sandboxed-post-message-to-parent.sub.html?sandbox=allow-scripts\""></iframe>\n+    <iframe src=\""support/sandboxed-post-message-to-parent.html?sandbox=allow-scripts\""></iframe>\n </body>\n \n </html>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""ef4b1a0b95a7e00275c423d49dd28f98545950d3"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.html"", ""status"": ""renamed"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""previous_filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.sub.html""}<_**next**_>{""sha"": ""ebbb54d36d86fe3ee3696b7dc302de11cb4ac30c"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html"", ""status"": ""added"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -0,0 +1,3 @@\n+<script>\n+  window.opener.postMessage(window.testProperty, \""*\"");\n+</script>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""a7ea308208d81a9f9a2ec24004d5d1f72cf21f84"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html.sub.headers"", ""status"": ""renamed"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html.sub.headers"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html.sub.headers"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-property-to-opener.html.sub.headers?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""previous_filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/sandboxed-post-message-to-parent.sub.html.sub.headers""}<_**next**_>{""sha"": ""ebbb54d36d86fe3ee3696b7dc302de11cb4ac30c"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/unsandboxed-post-property-to-opener.html"", ""status"": ""added"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/unsandboxed-post-property-to-opener.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/unsandboxed-post-property-to-opener.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/support/unsandboxed-post-property-to-opener.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -0,0 +1,3 @@\n+<script>\n+  window.opener.postMessage(window.testProperty, \""*\"");\n+</script>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""a7a080daf72ee8ae97f5adf433f17c947892d4ce"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-sandboxed.html"", ""status"": ""added"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-sandboxed.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-sandboxed.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-sandboxed.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -0,0 +1,22 @@\n+<!DOCTYPE html>\n+<html>\n+\n+<head>\n+    <script src=\""/resources/testharness.js\""></script>\n+    <script src=\""/resources/testharnessreport.js\""></script>\n+</head>\n+\n+<body>\n+    <script>\n+      var t = async_test(\""Window object should not be reused\"");\n+\n+      window.onmessage = t.step_func_done(function(e) {\n+        assert_equals(e.data, undefined);\n+      });\n+\n+      w = window.open(\""support/sandboxed-post-property-to-opener.html?sandbox=allow-scripts\"",\""\"",\""width=400,height=400\"");\n+      w.testProperty = \""test\"";\n+    </script>\n+</body>\n+\n+</html>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""dd69c41354b583e427d4e12a060f1b6f71eb2c86"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-unsandboxed.html"", ""status"": ""added"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-unsandboxed.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-unsandboxed.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/sandbox/window-reuse-unsandboxed.html?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -0,0 +1,22 @@\n+<!DOCTYPE html>\n+<html>\n+\n+<head>\n+    <script src=\""/resources/testharness.js\""></script>\n+    <script src=\""/resources/testharnessreport.js\""></script>\n+</head>\n+\n+<body>\n+    <script>\n+      var t = async_test(\""Window object should be reused\"");\n+\n+      window.onmessage = t.step_func_done(function(e) {\n+        assert_equals(e.data, \""test\"");\n+      });\n+\n+      w = window.open(\""support/unsandboxed-post-property-to-opener.html\"",\""\"",\""width=400,height=400\"");\n+      w.testProperty = \""test\"";\n+    </script>\n+</body>\n+\n+</html>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""c51cf5bfd4df6c9768e28caba8fcceb5a4332fef"", ""filename"": ""third_party/blink/renderer/core/dom/document.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/dom/document.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/dom/document.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/dom/document.cc?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -3569,7 +3569,10 @@ void Document::DispatchUnloadEvents() {\n   bool keep_event_listeners =\n       frame_->Loader().GetProvisionalDocumentLoader() &&\n       frame_->ShouldReuseDefaultView(\n-          frame_->Loader().GetProvisionalDocumentLoader()->Url());\n+          frame_->Loader().GetProvisionalDocumentLoader()->Url(),\n+          frame_->Loader()\n+              .GetProvisionalDocumentLoader()\n+              ->GetContentSecurityPolicy());\n   if (!keep_event_listeners)\n     RemoveAllEventListenersRecursively();\n }""}<_**next**_>{""sha"": ""12569fa32df76e82f80b638658a75571c227b98a"", ""filename"": ""third_party/blink/renderer/core/execution_context/security_context.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/execution_context/security_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/execution_context/security_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/execution_context/security_context.h?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -79,7 +79,12 @@ class CORE_EXPORT SecurityContext : public GarbageCollectedMixin {\n   virtual void DidUpdateSecurityOrigin() = 0;\n \n   SandboxFlags GetSandboxFlags() const { return sandbox_flags_; }\n-  bool IsSandboxed(SandboxFlags mask) const { return sandbox_flags_ & mask; }\n+  bool IsSandboxed(SandboxFlags mask) const {\n+    return IsSandboxed(mask, sandbox_flags_);\n+  }\n+  static bool IsSandboxed(SandboxFlags mask, SandboxFlags sandbox_flags) {\n+    return sandbox_flags & mask;\n+  }\n   virtual void EnforceSandboxFlags(SandboxFlags mask);\n \n   void SetAddressSpace(mojom::IPAddressSpace space) { address_space_ = space; }""}<_**next**_>{""sha"": ""204bb1e4547d523bbba1018e3448c00c45b4f73e"", ""filename"": ""third_party/blink/renderer/core/frame/csp/content_security_policy.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/csp/content_security_policy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/csp/content_security_policy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/frame/csp/content_security_policy.h?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -455,6 +455,12 @@ class CORE_EXPORT ContentSecurityPolicy\n   // perform these checks in NavigationRequest::CheckContentSecurityPolicy.\n   WebContentSecurityPolicyList ExposeForNavigationalChecks() const;\n \n+  // Retrieves the parsed sandbox flags. A lot of the time the execution\n+  // context will be used for all sandbox checks but there are situations\n+  // (before installing the document that this CSP will bind to) when\n+  // there is no execution context to enforce the sandbox flags.\n+  SandboxFlags GetSandboxMask() const { return sandbox_mask_; }\n+\n  private:\n   FRIEND_TEST_ALL_PREFIXES(ContentSecurityPolicyTest, NonceInline);\n   FRIEND_TEST_ALL_PREFIXES(ContentSecurityPolicyTest, NonceSinglePolicy);""}<_**next**_>{""sha"": ""ccc77a631977883052d2bd6e7826ef8726944301"", ""filename"": ""third_party/blink/renderer/core/frame/local_frame.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/local_frame.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/local_frame.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/frame/local_frame.cc?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -822,12 +822,24 @@ Document* LocalFrame::DocumentAtPoint(const LayoutPoint& point_in_root_frame) {\n   return result.InnerNode() ? &result.InnerNode()->GetDocument() : nullptr;\n }\n \n-bool LocalFrame::ShouldReuseDefaultView(const KURL& url) const {\n+bool LocalFrame::ShouldReuseDefaultView(\n+    const KURL& url,\n+    const ContentSecurityPolicy* csp) const {\n   // Secure transitions can only happen when navigating from the initial empty\n   // document.\n   if (!Loader().StateMachine()->IsDisplayingInitialEmptyDocument())\n     return false;\n \n+  // The Window object should only be re-used if it is same-origin.\n+  // Since sandboxing turns the origin into an opaque origin it needs to also\n+  // be considered when deciding whether to reuse it.\n+  // Spec:\n+  // https://html.spec.whatwg.org/multipage/browsing-the-web.html#initialise-the-document-object\n+  if (csp &&\n+      SecurityContext::IsSandboxed(kSandboxOrigin, csp->GetSandboxMask())) {\n+    return false;\n+  }\n+\n   return GetDocument()->IsSecureTransitionTo(url);\n }\n ""}<_**next**_>{""sha"": ""9633b2e5b26664936682590a04b3f5794b673c33"", ""filename"": ""third_party/blink/renderer/core/frame/local_frame.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/local_frame.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/frame/local_frame.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/frame/local_frame.h?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -230,7 +230,7 @@ class CORE_EXPORT LocalFrame final : public Frame,\n   PositionForPoint(const LayoutPoint& frame_point);\n   Document* DocumentAtPoint(const LayoutPoint&);\n \n-  bool ShouldReuseDefaultView(const KURL&) const;\n+  bool ShouldReuseDefaultView(const KURL&, const ContentSecurityPolicy*) const;\n   void RemoveSpellingMarkersUnderWords(const Vector<String>& words);\n \n   bool ShouldThrottleRendering() const;""}<_**next**_>{""sha"": ""6c62eca9db3829767e1f57da62585180ac1ba0cc"", ""filename"": ""third_party/blink/renderer/core/loader/document_loader.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 6, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/document_loader.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/document_loader.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/loader/document_loader.cc?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -711,12 +711,13 @@ void DocumentLoader::CommitNavigation(const AtomicString& mime_type,\n   if (!Document::ThreadedParsingEnabledForTesting())\n     parsing_policy = kForceSynchronousParsing;\n \n-  InstallNewDocument(Url(), owner_document,\n-                     frame_->ShouldReuseDefaultView(Url())\n-                         ? WebGlobalObjectReusePolicy::kUseExisting\n-                         : WebGlobalObjectReusePolicy::kCreateNew,\n-                     mime_type, encoding, InstallNewDocumentReason::kNavigation,\n-                     parsing_policy, overriding_url);\n+  InstallNewDocument(\n+      Url(), owner_document,\n+      frame_->ShouldReuseDefaultView(Url(), GetContentSecurityPolicy())\n+          ? WebGlobalObjectReusePolicy::kUseExisting\n+          : WebGlobalObjectReusePolicy::kCreateNew,\n+      mime_type, encoding, InstallNewDocumentReason::kNavigation,\n+      parsing_policy, overriding_url);\n   parser_->SetDocumentWasLoadedAsPartOfNavigation();\n   if (request_.WasDiscarded())\n     frame_->GetDocument()->SetWasDiscarded(true);""}<_**next**_>{""sha"": ""0e1a7006f5549970828957b647fdcb44c38e8d64"", ""filename"": ""third_party/blink/renderer/core/loader/document_loader.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/document_loader.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/document_loader.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/loader/document_loader.h?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -252,6 +252,13 @@ class CORE_EXPORT DocumentLoader\n   void BlockParser();\n   void ResumeParser();\n \n+  // Returns the currently stored content security policy, if this is called\n+  // after the document has been installed it will return nullptr as the\n+  // CSP belongs to the document at that point.\n+  const ContentSecurityPolicy* GetContentSecurityPolicy() const {\n+    return content_security_policy_.Get();\n+  }\n+\n  protected:\n   DocumentLoader(LocalFrame*,\n                  const ResourceRequest&,""}<_**next**_>{""sha"": ""b18dcdec03934315d44a79a965cb84e0d0501e11"", ""filename"": ""third_party/blink/renderer/core/loader/frame_loader.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/frame_loader.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90f878780cce9c4b0475fcea14d91b8f510cce11/third_party/blink/renderer/core/loader/frame_loader.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/loader/frame_loader.cc?ref=90f878780cce9c4b0475fcea14d91b8f510cce11"", ""patch"": ""@@ -365,8 +365,12 @@ void FrameLoader::ReplaceDocumentWhileExecutingJavaScriptURL(\n \n   // Compute this before clearing the frame, because it may need to inherit an\n   // aliased security context.\n+  // The document CSP is the correct one as it is used for CSP checks\n+  // done previously before getting here:\n+  // HTMLFormElement::ScheduleFormSubmission\n+  // HTMLFrameElementBase::OpenURL\n   WebGlobalObjectReusePolicy global_object_reuse_policy =\n-      frame_->ShouldReuseDefaultView(url)\n+      frame_->ShouldReuseDefaultView(url, document->GetContentSecurityPolicy())\n           ? WebGlobalObjectReusePolicy::kUseExisting\n           : WebGlobalObjectReusePolicy::kCreateNew;\n ""}","void FrameLoader::ReplaceDocumentWhileExecutingJavaScriptURL(
    const String& source,
    Document* owner_document) {
  Document* document = frame_->GetDocument();
  if (!document_loader_ ||
      document->PageDismissalEventBeingDispatched() != Document::kNoDismissal)
    return;

  UseCounter::Count(*document, WebFeature::kReplaceDocumentViaJavaScriptURL);

  const KURL& url = document->Url();
 
  // The document CSP is the correct one as it is used for CSP checks
  // done previously before getting here:
  // HTMLFormElement::ScheduleFormSubmission
  // HTMLFrameElementBase::OpenURL
   WebGlobalObjectReusePolicy global_object_reuse_policy =
      frame_->ShouldReuseDefaultView(url, document->GetContentSecurityPolicy())
           ? WebGlobalObjectReusePolicy::kUseExisting
           : WebGlobalObjectReusePolicy::kCreateNew;
 
  StopAllLoaders();
  SubframeLoadingDisabler disabler(document);
  frame_->DetachChildren();

  if (!frame_->IsAttached() || document != frame_->GetDocument())
    return;

  frame_->GetDocument()->Shutdown();
  Client()->TransitionToCommittedForNewPage();
  document_loader_->ReplaceDocumentWhileExecutingJavaScriptURL(
      url, owner_document, global_object_reuse_policy, source);
}
","void FrameLoader::ReplaceDocumentWhileExecutingJavaScriptURL(
    const String& source,
    Document* owner_document) {
  Document* document = frame_->GetDocument();
  if (!document_loader_ ||
      document->PageDismissalEventBeingDispatched() != Document::kNoDismissal)
    return;

  UseCounter::Count(*document, WebFeature::kReplaceDocumentViaJavaScriptURL);

  const KURL& url = document->Url();
 
   WebGlobalObjectReusePolicy global_object_reuse_policy =
      frame_->ShouldReuseDefaultView(url)
           ? WebGlobalObjectReusePolicy::kUseExisting
           : WebGlobalObjectReusePolicy::kCreateNew;
 
  StopAllLoaders();
  SubframeLoadingDisabler disabler(document);
  frame_->DetachChildren();

  if (!frame_->IsAttached() || document != frame_->GetDocument())
    return;

  frame_->GetDocument()->Shutdown();
  Client()->TransitionToCommittedForNewPage();
  document_loader_->ReplaceDocumentWhileExecutingJavaScriptURL(
      url, owner_document, global_object_reuse_policy, source);
}
",C,"  // The document CSP is the correct one as it is used for CSP checks
  // done previously before getting here:
  // HTMLFormElement::ScheduleFormSubmission
  // HTMLFrameElementBase::OpenURL
      frame_->ShouldReuseDefaultView(url, document->GetContentSecurityPolicy())
","      frame_->ShouldReuseDefaultView(url)
",,"@@ -365,8 +365,12 @@ void FrameLoader::ReplaceDocumentWhileExecutingJavaScriptURL(
 
   // Compute this before clearing the frame, because it may need to inherit an
   // aliased security context.
+  // The document CSP is the correct one as it is used for CSP checks
+  // done previously before getting here:
+  // HTMLFormElement::ScheduleFormSubmission
+  // HTMLFrameElementBase::OpenURL
   WebGlobalObjectReusePolicy global_object_reuse_policy =
-      frame_->ShouldReuseDefaultView(url)
+      frame_->ShouldReuseDefaultView(url, document->GetContentSecurityPolicy())
           ? WebGlobalObjectReusePolicy::kUseExisting
           : WebGlobalObjectReusePolicy::kCreateNew;
 ",Chrome,90f878780cce9c4b0475fcea14d91b8f510cce11,3476f410bff123a62a0542a6699f04f7536c38f8,1,"void FrameLoader::ReplaceDocumentWhileExecutingJavaScriptURL(
    const String& source,
    Document* owner_document) {
  Document* document = frame_->GetDocument();
  if (!document_loader_ ||
      document->PageDismissalEventBeingDispatched() != Document::kNoDismissal)
    return;

  UseCounter::Count(*document, WebFeature::kReplaceDocumentViaJavaScriptURL);

  const KURL& url = document->Url();
 
   // Compute this before clearing the frame, because it may need to inherit an
   // aliased security context.
//fix_flaw_line_below:
//  // The document CSP is the correct one as it is used for CSP checks
//fix_flaw_line_below:
//  // done previously before getting here:
//fix_flaw_line_below:
//  // HTMLFormElement::ScheduleFormSubmission
//fix_flaw_line_below:
//  // HTMLFrameElementBase::OpenURL
   WebGlobalObjectReusePolicy global_object_reuse_policy =
//flaw_line_below:
      frame_->ShouldReuseDefaultView(url)
//fix_flaw_line_below:
//      frame_->ShouldReuseDefaultView(url, document->GetContentSecurityPolicy())
           ? WebGlobalObjectReusePolicy::kUseExisting
           : WebGlobalObjectReusePolicy::kCreateNew;
 
  StopAllLoaders();
  // Don't allow any new child frames to load in this frame: attaching a new
  // child frame during or after detaching children results in an attached
  // frame on a detached DOM tree, which is bad.
  SubframeLoadingDisabler disabler(document);
  frame_->DetachChildren();

  // detachChildren() potentially detaches or navigates this frame. The load
  // cannot continue in those cases.
  if (!frame_->IsAttached() || document != frame_->GetDocument())
    return;

  frame_->GetDocument()->Shutdown();
  Client()->TransitionToCommittedForNewPage();
  document_loader_->ReplaceDocumentWhileExecutingJavaScriptURL(
      url, owner_document, global_object_reuse_policy, source);
}
"
9465,187201,,Remote,Not required,,CVE-2018-16086,https://www.cvedetails.com/cve/CVE-2018-16086/,CWE-285,Medium,Partial,Partial,,2019-06-27,5.8,Insufficient policy enforcement in extensions API in Google Chrome prior to 69.0.3497.81 allowed an attacker who convinced a user to install a malicious extension to bypass navigation restrictions via a crafted Chrome Extension.,2019-07-01,Bypass ,2,https://github.com/chromium/chromium/commit/8247b125c7b6888dc1c3932e19d6d8fe5a74a460,8247b125c7b6888dc1c3932e19d6d8fe5a74a460,"Extensions: Prevent content script injection in the New tab Page.

r487664 disallowed content script injection in the New Tab Page. However, the
check in RendererPermissionsPolicyDelegate::IsRestrictedUrl for the same, might
not work due to the following reasons:
  - There might be a race between checking if the extension can inject the
    script and setting the new tab url in the renderer (SearchBouncer).
  - The New Tab page url in the SearchBouncer might be set incorrectly due to
    incorrect handling of multiple profiles by InstantService.

Fix this by checking if the current renderer process is an Instant (NTP)
renderer. This should work since the NTP renderer process should not be shared
with other sites.

BUG=844428, 662610

Change-Id: I45f6b27fb2680d3b8df6e1da223452ffee09b0d8
Reviewed-on: https://chromium-review.googlesource.com/1068607
Reviewed-by: Devlin <rdevlin.cronin@chromium.org>
Commit-Queue: Karan Bhatia <karandeepb@chromium.org>
Cr-Commit-Position: refs/heads/master@{#563031}",1,chrome/renderer/extensions/renderer_permissions_policy_delegate.cc,"{""sha"": ""28fcf0e428f5f70b3fc85ccf1706aa699b534547"", ""filename"": ""chrome/browser/extensions/content_script_apitest.cc"", ""status"": ""modified"", ""additions"": 61, ""deletions"": 0, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/browser/extensions/content_script_apitest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/browser/extensions/content_script_apitest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/content_script_apitest.cc?ref=8247b125c7b6888dc1c3932e19d6d8fe5a74a460"", ""patch"": ""@@ -20,8 +20,10 @@\n #include \""chrome/browser/search/search.h\""\n #include \""chrome/browser/ui/browser.h\""\n #include \""chrome/browser/ui/javascript_dialogs/javascript_dialog_tab_helper.h\""\n+#include \""chrome/browser/ui/search/local_ntp_test_utils.h\""\n #include \""chrome/browser/ui/tabs/tab_strip_model.h\""\n #include \""chrome/common/chrome_switches.h\""\n+#include \""chrome/common/webui_url_constants.h\""\n #include \""chrome/test/base/ui_test_utils.h\""\n #include \""content/public/browser/javascript_dialog_manager.h\""\n #include \""content/public/browser/render_frame_host.h\""\n@@ -798,4 +800,63 @@ IN_PROC_BROWSER_TEST_F(ContentScriptApiTest, ExecuteScriptBypassingSandbox) {\n   ASSERT_TRUE(catcher.GetNextResult()) << catcher.message();\n }\n \n+// Test fixture which sets a custom NTP Page.\n+// TODO(karandeepb): Similar logic to set up a custom NTP is used elsewhere as\n+// well. Abstract this away into a reusable test fixture class.\n+class NTPInterceptionTest : public ExtensionApiTest {\n+ public:\n+  NTPInterceptionTest()\n+      : https_test_server_(net::EmbeddedTestServer::TYPE_HTTPS) {}\n+\n+  // ExtensionApiTest override:\n+  void SetUpOnMainThread() override {\n+    ExtensionApiTest::SetUpOnMainThread();\n+    test_data_dir_ = test_data_dir_.AppendASCII(\""ntp_content_script\"");\n+    https_test_server_.ServeFilesFromDirectory(test_data_dir_);\n+    ASSERT_TRUE(https_test_server_.Start());\n+\n+    GURL ntp_url = https_test_server_.GetURL(\""/fake_ntp.html\"");\n+    local_ntp_test_utils::SetUserSelectedDefaultSearchProvider(\n+        profile(), https_test_server_.base_url().spec(), ntp_url.spec());\n+  }\n+\n+  const net::EmbeddedTestServer* https_test_server() const {\n+    return &https_test_server_;\n+  }\n+\n+ private:\n+  net::EmbeddedTestServer https_test_server_;\n+  DISALLOW_COPY_AND_ASSIGN(NTPInterceptionTest);\n+};\n+\n+// Ensure extensions can't inject a content script into the New Tab page.\n+// Regression test for crbug.com/844428.\n+IN_PROC_BROWSER_TEST_F(NTPInterceptionTest, ContentScript) {\n+  // Load an extension which tries to inject a script into every frame.\n+  ExtensionTestMessageListener listener(\""ready\"", false /*will_reply*/);\n+  const Extension* extension = LoadExtension(test_data_dir_);\n+  ASSERT_TRUE(extension);\n+  ASSERT_TRUE(listener.WaitUntilSatisfied());\n+\n+  // Create a corresponding off the record profile for the current profile. This\n+  // is necessary to reproduce crbug.com/844428, which occurs in part due to\n+  // incorrect handling of multiple profiles by the NTP code.\n+  Browser* incognito_browser = CreateIncognitoBrowser(profile());\n+  ASSERT_TRUE(incognito_browser);\n+\n+  // Ensure that the extension isn't able to inject the script into the New Tab\n+  // Page.\n+  ui_test_utils::NavigateToURL(browser(), GURL(chrome::kChromeUINewTabURL));\n+  content::WebContents* web_contents =\n+      browser()->tab_strip_model()->GetActiveWebContents();\n+  ASSERT_TRUE(search::IsInstantNTP(web_contents));\n+\n+  bool script_injected_in_ntp = false;\n+  ASSERT_TRUE(ExecuteScriptAndExtractBool(\n+      web_contents,\n+      \""window.domAutomationController.send(document.title !== 'Fake NTP');\"",\n+      &script_injected_in_ntp));\n+  EXPECT_FALSE(script_injected_in_ntp);\n+}\n+\n }  // namespace extensions""}<_**next**_>{""sha"": ""22fcfa02bd9589a462e2d404ebea98a4e9ad8ca2"", ""filename"": ""chrome/renderer/extensions/renderer_permissions_policy_delegate.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/renderer/extensions/renderer_permissions_policy_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/renderer/extensions/renderer_permissions_policy_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/extensions/renderer_permissions_policy_delegate.cc?ref=8247b125c7b6888dc1c3932e19d6d8fe5a74a460"", ""patch"": ""@@ -4,8 +4,9 @@\n \n #include \""chrome/renderer/extensions/renderer_permissions_policy_delegate.h\""\n \n+#include \""base/command_line.h\""\n+#include \""chrome/common/chrome_switches.h\""\n #include \""chrome/common/extensions/extension_constants.h\""\n-#include \""chrome/renderer/searchbox/search_bouncer.h\""\n #include \""extensions/common/constants.h\""\n #include \""extensions/common/extensions_client.h\""\n #include \""extensions/common/manifest_constants.h\""\n@@ -33,7 +34,8 @@ bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(\n     return true;\n   }\n \n-  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {\n+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n+          ::switches::kInstantProcess)) {\n     if (error)\n       *error = errors::kCannotScriptNtp;\n     return true;""}<_**next**_>{""sha"": ""558f3ed4b5027c73094ec0118f3fda2793022be1"", ""filename"": ""chrome/test/data/extensions/api_test/ntp_content_script/background.js"", ""status"": ""added"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/test/data/extensions/api_test/ntp_content_script/background.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/test/data/extensions/api_test/ntp_content_script/background.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/ntp_content_script/background.js?ref=8247b125c7b6888dc1c3932e19d6d8fe5a74a460"", ""patch"": ""@@ -0,0 +1,5 @@\n+// Copyright 2018 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+chrome.test.sendMessage('ready');""}<_**next**_>{""sha"": ""b8a5a02f13fb19e4fdd03f0c176f4c79cdaf5379"", ""filename"": ""chrome/test/data/extensions/api_test/ntp_content_script/content_script.js"", ""status"": ""added"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/test/data/extensions/api_test/ntp_content_script/content_script.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/test/data/extensions/api_test/ntp_content_script/content_script.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/ntp_content_script/content_script.js?ref=8247b125c7b6888dc1c3932e19d6d8fe5a74a460"", ""patch"": ""@@ -0,0 +1,7 @@\n+// Copyright 2018 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+document.addEventListener('DOMContentLoaded', function() {\n+  document.title = 'injected';\n+});""}<_**next**_>{""sha"": ""2a39a503af9fbc28778166b6b3ae9d2b4114f8e3"", ""filename"": ""chrome/test/data/extensions/api_test/ntp_content_script/fake_ntp.html"", ""status"": ""added"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/test/data/extensions/api_test/ntp_content_script/fake_ntp.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/test/data/extensions/api_test/ntp_content_script/fake_ntp.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/ntp_content_script/fake_ntp.html?ref=8247b125c7b6888dc1c3932e19d6d8fe5a74a460"", ""patch"": ""@@ -0,0 +1,8 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+  <title>Fake NTP</title>\n+</head>\n+<body>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""efa8cc384007b32738737fdfa336623d3a22493c"", ""filename"": ""chrome/test/data/extensions/api_test/ntp_content_script/manifest.json"", ""status"": ""added"", ""additions"": 23, ""deletions"": 0, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/test/data/extensions/api_test/ntp_content_script/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/test/data/extensions/api_test/ntp_content_script/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/ntp_content_script/manifest.json?ref=8247b125c7b6888dc1c3932e19d6d8fe5a74a460"", ""patch"": ""@@ -0,0 +1,23 @@\n+{\n+  \""manifest_version\"": 2,\n+  \""name\"": \""NTP content script injection\"",\n+  \""version\"": \""1\"",\n+  \""description\"": \""Test for crbug.com/844428\"",\n+  \""content_scripts\"": [\n+    {\n+      \""matches\"": [\n+        \""<all_urls>\""\n+      ],\n+      \""js\"": [\n+        \""content_script.js\""\n+      ],\n+      \""run_at\"": \""document_start\"",\n+      \""all_frames\"": true\n+    }\n+  ],\n+  \""background\"": {\n+    \""scripts\"": [\n+      \""background.js\""\n+    ]\n+  }\n+}""}","bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(
    const GURL& document_url,
    std::string* error) {
  if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {
    if (error)
      *error = errors::kCannotScriptGallery;
     return true;
   }
 
  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
          ::switches::kInstantProcess)) {
     if (error)
       *error = errors::kCannotScriptNtp;
     return true;
  }

  return false;
}
","bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(
    const GURL& document_url,
    std::string* error) {
  if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {
    if (error)
      *error = errors::kCannotScriptGallery;
     return true;
   }
 
  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {
     if (error)
       *error = errors::kCannotScriptNtp;
     return true;
  }

  return false;
}
",C,"  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
          ::switches::kInstantProcess)) {
","  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {
",,"@@ -4,8 +4,9 @@
 
 #include ""chrome/renderer/extensions/renderer_permissions_policy_delegate.h""
 
+#include ""base/command_line.h""
+#include ""chrome/common/chrome_switches.h""
 #include ""chrome/common/extensions/extension_constants.h""
-#include ""chrome/renderer/searchbox/search_bouncer.h""
 #include ""extensions/common/constants.h""
 #include ""extensions/common/extensions_client.h""
 #include ""extensions/common/manifest_constants.h""
@@ -33,7 +34,8 @@ bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(
     return true;
   }
 
-  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          ::switches::kInstantProcess)) {
     if (error)
       *error = errors::kCannotScriptNtp;
     return true;",Chrome,8247b125c7b6888dc1c3932e19d6d8fe5a74a460,3d1cba08168abe3a7c51639e49659b8381dfb66f,1,"bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(
    const GURL& document_url,
    std::string* error) {
  if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {
    if (error)
      *error = errors::kCannotScriptGallery;
     return true;
   }
 
//flaw_line_below:
  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {
//fix_flaw_line_below:
//  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
//fix_flaw_line_below:
//          ::switches::kInstantProcess)) {
     if (error)
       *error = errors::kCannotScriptNtp;
     return true;
  }

  return false;
}
"
