,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
807,178543,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,1,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,1,,,"get_cred_handler(Service * /*service*/, int /*i*/, Stream *stream) {
  char * name = NULL;
  int rtnVal = FALSE;
  bool found_cred=false;
  CredentialWrapper * cred = NULL;
  char * owner = NULL;
  const char * user = NULL;
  void * data = NULL;

  ReliSock * socket = (ReliSock*)stream;

  if (!socket->triedAuthentication()) {
    CondorError errstack;
    if( ! SecMan::authenticate_sock(socket, READ, &errstack) ) {
      dprintf (D_ALWAYS, ""Unable to authenticate, qutting\n"");
      goto EXIT;
    }
  }

  socket->decode();

  if (!socket->code(name)) {
    dprintf (D_ALWAYS, ""Error receiving credential name\n""); 
    goto EXIT;
  }

  user = socket->getFullyQualifiedUser();
  dprintf (D_ALWAYS, ""Authenticated as %s\n"", user);

  if (strchr (name, ':')) {

    owner = strdup (name);
    char * pColon = strchr (owner, ':');
     *pColon = '\0';
     
    sprintf (name, ""%s"", (char*)(pColon+sizeof(char)));
   
     if (strcmp (owner, user) != 0) { 
       dprintf (D_ALWAYS, ""Requesting another user's (%s) credential %s\n"", owner, name);

      if (!isSuperUser (user)) {
	dprintf (D_ALWAYS, ""User %s is NOT super user, request DENIED\n"", user);
	goto EXIT;
      } else {
	dprintf (D_FULLDEBUG, ""User %s is super user, request GRANTED\n"", user);
      }
    }

  } else {
    owner = strdup (user);
  }

  dprintf (D_ALWAYS, ""sending cred %s for user %s\n"", name, owner);

  credentials.Rewind();
  while (credentials.Next(cred)) {
	  if (cred->cred->GetType() == X509_CREDENTIAL_TYPE) {
		  if ((strcmp(cred->cred->GetName(), name) == 0) && 
			  (strcmp(cred->cred->GetOwner(), owner) == 0)) {
			  found_cred=true;
			  break; // found it
      }
    }
  }
  
  socket->encode();

  if (found_cred) {
    dprintf (D_FULLDEBUG, ""Found cred %s\n"", cred->GetStorageName());
    
    int data_size;

    
    int rc = LoadData (cred->GetStorageName(), data, data_size);
    dprintf (D_FULLDEBUG, ""Credential::LoadData returned %d\n"", rc);
    if (rc == 0) {
      goto EXIT;
    }
    
    socket->code (data_size);
    socket->code_bytes (data, data_size);
    dprintf (D_ALWAYS, ""Credential name %s for owner %s returned to user %s\n"",
			name, owner, user);
  }
  else {
    dprintf (D_ALWAYS, ""Cannot find cred %s\n"", name);
    int rc = CREDD_CREDENTIAL_NOT_FOUND;
    socket->code (rc);
  }

  rtnVal = TRUE;
EXIT:
  if ( name != NULL) {
	  free (name);
  }
  if ( owner != NULL) {
	  free (owner);
  }
  if ( data != NULL) {
	  free (data);
  }
  return rtnVal;
}
","get_cred_handler(Service * /*service*/, int /*i*/, Stream *stream) {
  char * name = NULL;
  int rtnVal = FALSE;
  bool found_cred=false;
  CredentialWrapper * cred = NULL;
  char * owner = NULL;
  const char * user = NULL;
  void * data = NULL;

  ReliSock * socket = (ReliSock*)stream;

  if (!socket->triedAuthentication()) {
    CondorError errstack;
    if( ! SecMan::authenticate_sock(socket, READ, &errstack) ) {
      dprintf (D_ALWAYS, ""Unable to authenticate, qutting\n"");
      goto EXIT;
    }
  }

  socket->decode();

  if (!socket->code(name)) {
    dprintf (D_ALWAYS, ""Error receiving credential name\n""); 
    goto EXIT;
  }

  user = socket->getFullyQualifiedUser();
  dprintf (D_ALWAYS, ""Authenticated as %s\n"", user);

  if (strchr (name, ':')) {

    owner = strdup (name);
    char * pColon = strchr (owner, ':');
     *pColon = '\0';
     
    sprintf (name, (char*)(pColon+sizeof(char)));
   
     if (strcmp (owner, user) != 0) { 
       dprintf (D_ALWAYS, ""Requesting another user's (%s) credential %s\n"", owner, name);

      if (!isSuperUser (user)) {
	dprintf (D_ALWAYS, ""User %s is NOT super user, request DENIED\n"", user);
	goto EXIT;
      } else {
	dprintf (D_FULLDEBUG, ""User %s is super user, request GRANTED\n"", user);
      }
    }

  } else {
    owner = strdup (user);
  }

  dprintf (D_ALWAYS, ""sending cred %s for user %s\n"", name, owner);

  credentials.Rewind();
  while (credentials.Next(cred)) {
	  if (cred->cred->GetType() == X509_CREDENTIAL_TYPE) {
		  if ((strcmp(cred->cred->GetName(), name) == 0) && 
			  (strcmp(cred->cred->GetOwner(), owner) == 0)) {
			  found_cred=true;
			  break; // found it
      }
    }
  }
  
  socket->encode();

  if (found_cred) {
    dprintf (D_FULLDEBUG, ""Found cred %s\n"", cred->GetStorageName());
    
    int data_size;

    
    int rc = LoadData (cred->GetStorageName(), data, data_size);
    dprintf (D_FULLDEBUG, ""Credential::LoadData returned %d\n"", rc);
    if (rc == 0) {
      goto EXIT;
    }
    
    socket->code (data_size);
    socket->code_bytes (data, data_size);
    dprintf (D_ALWAYS, ""Credential name %s for owner %s returned to user %s\n"",
			name, owner, user);
  }
  else {
    dprintf (D_ALWAYS, ""Cannot find cred %s\n"", name);
    int rc = CREDD_CREDENTIAL_NOT_FOUND;
    socket->code (rc);
  }

  rtnVal = TRUE;
EXIT:
  if ( name != NULL) {
	  free (name);
  }
  if ( owner != NULL) {
	  free (owner);
  }
  if ( data != NULL) {
	  free (data);
  }
  return rtnVal;
}
",CPP,"    sprintf (name, ""%s"", (char*)(pColon+sizeof(char)));
","    sprintf (name, (char*)(pColon+sizeof(char)));
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -263,7 +263,7 @@ get_cred_handler(Service * /*service*/, int /*i*/, Stream *stream) {
     *pColon = '\0';
     
     // Name is the second part
-    sprintf (name, (char*)(pColon+sizeof(char)));
+    sprintf (name, ""%s"", (char*)(pColon+sizeof(char)));
   
     if (strcmp (owner, user) != 0) { 
       dprintf (D_ALWAYS, ""Requesting another user's (%s) credential %s\n"", owner, name);
@@ -455,7 +455,7 @@ rm_cred_handler(Service * /*service*/, int /*i*/, Stream *stream) {
     *pColon = '\0';
     
     // Name is the second part
-    sprintf (name, (char*)(pColon+sizeof(char)));
+    sprintf (name, ""%s"", (char*)(pColon+sizeof(char)));
   
     if (strcmp (owner, user) != 0) { 
       dprintf (D_ALWAYS, ""Requesting another user's (%s) credential %s\n"", owner, name);",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_credd/credd.cpp;h=566f3a10386bd6550dde712f60f25af203928368;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_credd/credd.cpp;h=b275a7e3059ddcaaef936e41d3d414296eee574f,1,"get_cred_handler(Service * /*service*/, int /*i*/, Stream *stream) {
  char * name = NULL;
  int rtnVal = FALSE;
  bool found_cred=false;
  CredentialWrapper * cred = NULL;
  char * owner = NULL;
  const char * user = NULL;
  void * data = NULL;

  ReliSock * socket = (ReliSock*)stream;

  // Authenticate
  if (!socket->triedAuthentication()) {
    CondorError errstack;
    if( ! SecMan::authenticate_sock(socket, READ, &errstack) ) {
      dprintf (D_ALWAYS, ""Unable to authenticate, qutting\n"");
      goto EXIT;
    }
  }

  socket->decode();

  if (!socket->code(name)) {
    dprintf (D_ALWAYS, ""Error receiving credential name\n""); 
    goto EXIT;
  }

  user = socket->getFullyQualifiedUser();
  dprintf (D_ALWAYS, ""Authenticated as %s\n"", user);

  if (strchr (name, ':')) {
    // The name is of the form user:name
    // This better be a super-user!
    // TODO: Check super-user's list

    // Owner is the first part
    owner = strdup (name);
    char * pColon = strchr (owner, ':');
     *pColon = '\0';
     
     // Name is the second part
//flaw_line_below:
    sprintf (name, (char*)(pColon+sizeof(char)));
//fix_flaw_line_below:
//    sprintf (name, ""%s"", (char*)(pColon+sizeof(char)));
   
     if (strcmp (owner, user) != 0) { 
       dprintf (D_ALWAYS, ""Requesting another user's (%s) credential %s\n"", owner, name);

      if (!isSuperUser (user)) {
	dprintf (D_ALWAYS, ""User %s is NOT super user, request DENIED\n"", user);
	goto EXIT;
      } else {
	dprintf (D_FULLDEBUG, ""User %s is super user, request GRANTED\n"", user);
      }
    }

  } else {
    owner = strdup (user);
  }

  dprintf (D_ALWAYS, ""sending cred %s for user %s\n"", name, owner);

  credentials.Rewind();
  while (credentials.Next(cred)) {
	  if (cred->cred->GetType() == X509_CREDENTIAL_TYPE) {
		  if ((strcmp(cred->cred->GetName(), name) == 0) && 
			  (strcmp(cred->cred->GetOwner(), owner) == 0)) {
			  found_cred=true;
			  break; // found it
      }
    }
  }
  
  socket->encode();

  if (found_cred) {
    dprintf (D_FULLDEBUG, ""Found cred %s\n"", cred->GetStorageName());
    
    int data_size;

    
    int rc = LoadData (cred->GetStorageName(), data, data_size);
    dprintf (D_FULLDEBUG, ""Credential::LoadData returned %d\n"", rc);
    if (rc == 0) {
      goto EXIT;
    }
    
    socket->code (data_size);
    socket->code_bytes (data, data_size);
    dprintf (D_ALWAYS, ""Credential name %s for owner %s returned to user %s\n"",
			name, owner, user);
  }
  else {
    dprintf (D_ALWAYS, ""Cannot find cred %s\n"", name);
    int rc = CREDD_CREDENTIAL_NOT_FOUND;
    socket->code (rc);
  }

  rtnVal = TRUE;
EXIT:
  if ( name != NULL) {
	  free (name);
  }
  if ( owner != NULL) {
	  free (owner);
  }
  if ( data != NULL) {
	  free (data);
  }
  return rtnVal;
}
"
808,178544,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,1,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,1,,,"rm_cred_handler(Service * /*service*/, int /*i*/, Stream *stream) {
  char * name = NULL;
  int rtnVal = FALSE;
  int rc;
  bool found_cred;
  CredentialWrapper * cred_wrapper = NULL;
  char * owner = NULL;
  const char * user;

  ReliSock * socket = (ReliSock*)stream;

  if (!socket->triedAuthentication()) {
    CondorError errstack;
    if( ! SecMan::authenticate_sock(socket, READ, &errstack) ) {
      dprintf (D_ALWAYS, ""Unable to authenticate, qutting\n"");
      goto EXIT;
    }
  }


  socket->decode();

  if (!socket->code(name)) {
    dprintf (D_ALWAYS, ""Error receiving credential name\n""); 
    goto EXIT;
  }

  user = socket->getFullyQualifiedUser();

  dprintf (D_ALWAYS, ""Authenticated as %s\n"", user);

  if (strchr (name, ':')) {

    owner = strdup (name);
    char * pColon = strchr (owner, ':');
     *pColon = '\0';
     
    sprintf (name, ""%s"", (char*)(pColon+sizeof(char)));
   
     if (strcmp (owner, user) != 0) { 
       dprintf (D_ALWAYS, ""Requesting another user's (%s) credential %s\n"", owner, name);

      if (!isSuperUser (user)) {
	dprintf (D_ALWAYS, ""User %s is NOT super user, request DENIED\n"", user);
	goto EXIT;
      } else {
	dprintf (D_FULLDEBUG, ""User %s is super user, request GRANTED\n"", user);
      }
    }

  } else {
    owner = strdup (user);
  }

  dprintf (D_ALWAYS, ""Attempting to delete cred %s for user %s\n"", name, owner);
  

  found_cred=false;
  credentials.Rewind();
  while (credentials.Next(cred_wrapper)) {
	  if (cred_wrapper->cred->GetType() == X509_CREDENTIAL_TYPE) {
		  if ((strcmp(cred_wrapper->cred->GetName(), name) == 0) && 
			  (strcmp(cred_wrapper->cred->GetOwner(), owner) == 0)) {
			  credentials.DeleteCurrent();
			  found_cred=true;
			  break; // found it
		  }
	  }
  }


  if (found_cred) {
    priv_state priv = set_root_priv();
    unlink (cred_wrapper->GetStorageName());
    SaveCredentialList();
    set_priv(priv);
    delete cred_wrapper;
    dprintf (D_ALWAYS, ""Removed credential %s for owner %s\n"", name, owner);
  } else {
    dprintf (D_ALWAYS, ""Unable to remove credential %s:%s (not found)\n"", owner, name); 
  }
	    
  
  free (owner);
  
  socket->encode();
 

  rc = (found_cred)?CREDD_SUCCESS:CREDD_CREDENTIAL_NOT_FOUND;
  socket->code(rc);

  rtnVal = TRUE;

EXIT:
  if (name != NULL) {
	  free (name);
  }
  return rtnVal;
}
","rm_cred_handler(Service * /*service*/, int /*i*/, Stream *stream) {
  char * name = NULL;
  int rtnVal = FALSE;
  int rc;
  bool found_cred;
  CredentialWrapper * cred_wrapper = NULL;
  char * owner = NULL;
  const char * user;

  ReliSock * socket = (ReliSock*)stream;

  if (!socket->triedAuthentication()) {
    CondorError errstack;
    if( ! SecMan::authenticate_sock(socket, READ, &errstack) ) {
      dprintf (D_ALWAYS, ""Unable to authenticate, qutting\n"");
      goto EXIT;
    }
  }


  socket->decode();

  if (!socket->code(name)) {
    dprintf (D_ALWAYS, ""Error receiving credential name\n""); 
    goto EXIT;
  }

  user = socket->getFullyQualifiedUser();

  dprintf (D_ALWAYS, ""Authenticated as %s\n"", user);

  if (strchr (name, ':')) {

    owner = strdup (name);
    char * pColon = strchr (owner, ':');
     *pColon = '\0';
     
    sprintf (name, (char*)(pColon+sizeof(char)));
   
     if (strcmp (owner, user) != 0) { 
       dprintf (D_ALWAYS, ""Requesting another user's (%s) credential %s\n"", owner, name);

      if (!isSuperUser (user)) {
	dprintf (D_ALWAYS, ""User %s is NOT super user, request DENIED\n"", user);
	goto EXIT;
      } else {
	dprintf (D_FULLDEBUG, ""User %s is super user, request GRANTED\n"", user);
      }
    }

  } else {
    owner = strdup (user);
  }

  dprintf (D_ALWAYS, ""Attempting to delete cred %s for user %s\n"", name, owner);
  

  found_cred=false;
  credentials.Rewind();
  while (credentials.Next(cred_wrapper)) {
	  if (cred_wrapper->cred->GetType() == X509_CREDENTIAL_TYPE) {
		  if ((strcmp(cred_wrapper->cred->GetName(), name) == 0) && 
			  (strcmp(cred_wrapper->cred->GetOwner(), owner) == 0)) {
			  credentials.DeleteCurrent();
			  found_cred=true;
			  break; // found it
		  }
	  }
  }


  if (found_cred) {
    priv_state priv = set_root_priv();
    unlink (cred_wrapper->GetStorageName());
    SaveCredentialList();
    set_priv(priv);
    delete cred_wrapper;
    dprintf (D_ALWAYS, ""Removed credential %s for owner %s\n"", name, owner);
  } else {
    dprintf (D_ALWAYS, ""Unable to remove credential %s:%s (not found)\n"", owner, name); 
  }
	    
  
  free (owner);
  
  socket->encode();
 

  rc = (found_cred)?CREDD_SUCCESS:CREDD_CREDENTIAL_NOT_FOUND;
  socket->code(rc);

  rtnVal = TRUE;

EXIT:
  if (name != NULL) {
	  free (name);
  }
  return rtnVal;
}
",CPP,"    sprintf (name, ""%s"", (char*)(pColon+sizeof(char)));
","    sprintf (name, (char*)(pColon+sizeof(char)));
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -263,7 +263,7 @@ get_cred_handler(Service * /*service*/, int /*i*/, Stream *stream) {
     *pColon = '\0';
     
     // Name is the second part
-    sprintf (name, (char*)(pColon+sizeof(char)));
+    sprintf (name, ""%s"", (char*)(pColon+sizeof(char)));
   
     if (strcmp (owner, user) != 0) { 
       dprintf (D_ALWAYS, ""Requesting another user's (%s) credential %s\n"", owner, name);
@@ -455,7 +455,7 @@ rm_cred_handler(Service * /*service*/, int /*i*/, Stream *stream) {
     *pColon = '\0';
     
     // Name is the second part
-    sprintf (name, (char*)(pColon+sizeof(char)));
+    sprintf (name, ""%s"", (char*)(pColon+sizeof(char)));
   
     if (strcmp (owner, user) != 0) { 
       dprintf (D_ALWAYS, ""Requesting another user's (%s) credential %s\n"", owner, name);",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_credd/credd.cpp;h=566f3a10386bd6550dde712f60f25af203928368;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_credd/credd.cpp;h=b275a7e3059ddcaaef936e41d3d414296eee574f,1,"rm_cred_handler(Service * /*service*/, int /*i*/, Stream *stream) {
  char * name = NULL;
  int rtnVal = FALSE;
  int rc;
  bool found_cred;
  CredentialWrapper * cred_wrapper = NULL;
  char * owner = NULL;
  const char * user;

  ReliSock * socket = (ReliSock*)stream;

  if (!socket->triedAuthentication()) {
    CondorError errstack;
    if( ! SecMan::authenticate_sock(socket, READ, &errstack) ) {
      dprintf (D_ALWAYS, ""Unable to authenticate, qutting\n"");
      goto EXIT;
    }
  }


  socket->decode();

  if (!socket->code(name)) {
    dprintf (D_ALWAYS, ""Error receiving credential name\n""); 
    goto EXIT;
  }

  user = socket->getFullyQualifiedUser();

  dprintf (D_ALWAYS, ""Authenticated as %s\n"", user);

  if (strchr (name, ':')) {
    // The name is of the form user:name
    // This better be a super-user!
    // TODO: Check super-user's list

    // Owner is the first part
    owner = strdup (name);
    char * pColon = strchr (owner, ':');
     *pColon = '\0';
     
     // Name is the second part
//flaw_line_below:
    sprintf (name, (char*)(pColon+sizeof(char)));
//fix_flaw_line_below:
//    sprintf (name, ""%s"", (char*)(pColon+sizeof(char)));
   
     if (strcmp (owner, user) != 0) { 
       dprintf (D_ALWAYS, ""Requesting another user's (%s) credential %s\n"", owner, name);

      if (!isSuperUser (user)) {
	dprintf (D_ALWAYS, ""User %s is NOT super user, request DENIED\n"", user);
	goto EXIT;
      } else {
	dprintf (D_FULLDEBUG, ""User %s is super user, request GRANTED\n"", user);
      }
    }

  } else {
    owner = strdup (user);
  }

  dprintf (D_ALWAYS, ""Attempting to delete cred %s for user %s\n"", name, owner);
  

  found_cred=false;
  credentials.Rewind();
  while (credentials.Next(cred_wrapper)) {
	  if (cred_wrapper->cred->GetType() == X509_CREDENTIAL_TYPE) {
		  if ((strcmp(cred_wrapper->cred->GetName(), name) == 0) && 
			  (strcmp(cred_wrapper->cred->GetOwner(), owner) == 0)) {
			  credentials.DeleteCurrent();
			  found_cred=true;
			  break; // found it
		  }
	  }
  }


  if (found_cred) {
    priv_state priv = set_root_priv();
    // Remove credential data
    unlink (cred_wrapper->GetStorageName());
    // Save the metadata list
    SaveCredentialList();
    set_priv(priv);
    delete cred_wrapper;
    dprintf (D_ALWAYS, ""Removed credential %s for owner %s\n"", name, owner);
  } else {
    dprintf (D_ALWAYS, ""Unable to remove credential %s:%s (not found)\n"", owner, name); 
  }
	    
  
  free (owner);
  
  socket->encode();
 

  rc = (found_cred)?CREDD_SUCCESS:CREDD_CREDENTIAL_NOT_FOUND;
  socket->code(rc);

  rtnVal = TRUE;

EXIT:
  if (name != NULL) {
	  free (name);
  }
  return rtnVal;
}
"
809,178545,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,2,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,2,,,"GahpServer::Reaper(Service *,int pid,int status)
{
	/* This should be much better.... for now, if our Gahp Server
	   goes away for any reason, we EXCEPT. */

	GahpServer *dead_server = NULL;
	GahpServer *next_server = NULL;

	GahpServersById.startIterations();
	while ( GahpServersById.iterate( next_server ) != 0 ) {
		if ( pid == next_server->m_gahp_pid ) {
			dead_server = next_server;
			break;
		}
	}

	std::string buf;

	sprintf( buf, ""Gahp Server (pid=%d) "", pid );

	if( WIFSIGNALED(status) ) {
		sprintf_cat( buf, ""died due to %s"", 
			daemonCore->GetExceptionString(status) );
	} else {
		sprintf_cat( buf, ""exited with status %d"", WEXITSTATUS(status) );
	}
 
        if ( dead_server ) {
                sprintf_cat( buf, "" unexpectedly"" );
               EXCEPT( ""%s"", buf.c_str() );
        } else {
                sprintf_cat( buf, ""\n"" );
               dprintf( D_ALWAYS, ""%s"", buf.c_str() );
        }
 }
","GahpServer::Reaper(Service *,int pid,int status)
{
	/* This should be much better.... for now, if our Gahp Server
	   goes away for any reason, we EXCEPT. */

	GahpServer *dead_server = NULL;
	GahpServer *next_server = NULL;

	GahpServersById.startIterations();
	while ( GahpServersById.iterate( next_server ) != 0 ) {
		if ( pid == next_server->m_gahp_pid ) {
			dead_server = next_server;
			break;
		}
	}

	std::string buf;

	sprintf( buf, ""Gahp Server (pid=%d) "", pid );

	if( WIFSIGNALED(status) ) {
		sprintf_cat( buf, ""died due to %s"", 
			daemonCore->GetExceptionString(status) );
	} else {
		sprintf_cat( buf, ""exited with status %d"", WEXITSTATUS(status) );
	}
 
        if ( dead_server ) {
                sprintf_cat( buf, "" unexpectedly"" );
               EXCEPT( buf.c_str() );
        } else {
                sprintf_cat( buf, ""\n"" );
               dprintf( D_ALWAYS, buf.c_str() );
        }
 }
",CPP,"               EXCEPT( ""%s"", buf.c_str() );
               dprintf( D_ALWAYS, ""%s"", buf.c_str() );
","               EXCEPT( buf.c_str() );
               dprintf( D_ALWAYS, buf.c_str() );
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -321,10 +321,10 @@ GahpServer::Reaper(Service *,int pid,int status)
 
        if ( dead_server ) {
                sprintf_cat( buf, "" unexpectedly"" );
-               EXCEPT( buf.c_str() );
+               EXCEPT( ""%s"", buf.c_str() );
        } else {
                sprintf_cat( buf, ""\n"" );
-               dprintf( D_ALWAYS, buf.c_str() );
+               dprintf( D_ALWAYS, ""%s"", buf.c_str() );
        }
 }",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_gridmanager/gahp-client.cpp;h=8c6c3fd59255c36477bdcb561a2986bdb238f96e;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_gridmanager/gahp-client.cpp;h=2e83bb81610fc0412b176e650b8d31f8b657fa6e,1,"GahpServer::Reaper(Service *,int pid,int status)
{
	/* This should be much better.... for now, if our Gahp Server
	   goes away for any reason, we EXCEPT. */

	GahpServer *dead_server = NULL;
	GahpServer *next_server = NULL;

	GahpServersById.startIterations();
	while ( GahpServersById.iterate( next_server ) != 0 ) {
		if ( pid == next_server->m_gahp_pid ) {
			dead_server = next_server;
			break;
		}
	}

	std::string buf;

	sprintf( buf, ""Gahp Server (pid=%d) "", pid );

	if( WIFSIGNALED(status) ) {
		sprintf_cat( buf, ""died due to %s"", 
			daemonCore->GetExceptionString(status) );
	} else {
		sprintf_cat( buf, ""exited with status %d"", WEXITSTATUS(status) );
	}
 
        if ( dead_server ) {
                sprintf_cat( buf, "" unexpectedly"" );
//flaw_line_below:
               EXCEPT( buf.c_str() );
//fix_flaw_line_below:
//               EXCEPT( ""%s"", buf.c_str() );
        } else {
                sprintf_cat( buf, ""\n"" );
//flaw_line_below:
               dprintf( D_ALWAYS, buf.c_str() );
//fix_flaw_line_below:
//               dprintf( D_ALWAYS, ""%s"", buf.c_str() );
        }
 }
"
810,178546,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,1,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,1,,,"int SafeSock::handle_incoming_packet()
{

	/* SOCKET_ALTERNATE_LENGTH_TYPE is void on this platform, and
		since noone knows what that void* is supposed to point to
		in recvfrom, I'm going to predict the ""fromlen"" variable
		the recvfrom uses is a size_t sized quantity since
		size_t is how you count bytes right?  Stupid Solaris. */
	bool last;
	int seqNo, length;
	_condorMsgID mID;
	void* data;
	int index;
	int received;
	_condorInMsg *tempMsg, *delMsg, *prev = NULL;
	time_t curTime;

	if( _msgReady ) {
		char const *existing_msg_type;
		bool existing_consumed;
		if( _longMsg ) {
			existing_msg_type = ""long"";
			existing_consumed = _longMsg->consumed();
		}
		else {
			existing_msg_type = ""short"";
			existing_consumed = _shortMsg.consumed();
		}
		dprintf( D_ALWAYS,
				 ""ERROR: receiving new UDP message but found a %s ""
				 ""message still waiting to be closed (consumed=%d). ""
				 ""Closing it now.\n"",
				 existing_msg_type, existing_consumed );


		stream_coding saved_coding = _coding;
		_coding = stream_decode;
		end_of_message();
		_coding = saved_coding;
	}


	received = condor_recvfrom(_sock, _shortMsg.dataGram, 
							   SAFE_MSG_MAX_PACKET_SIZE, 0, _who);

	if(received < 0) {
		dprintf(D_NETWORK, ""recvfrom failed: errno = %d\n"", errno);
                return FALSE;
        }
     char str[50];
    sprintf(str, ""%s"", sock_to_string(_sock));
     dprintf( D_NETWORK, ""RECV %d bytes at %s from %s\n"",
                         received, str, _who.to_sinful().Value());

	length = received;
    _shortMsg.reset(); // To be sure
	
	bool is_full_message = _shortMsg.getHeader(received, last, seqNo, length, mID, data);
	if ( length <= 0 || length > SAFE_MSG_MAX_PACKET_SIZE ) {
		dprintf(D_ALWAYS,""IO: Incoming datagram improperly sized\n"");
		return FALSE;
	}

    if ( is_full_message ) {
        _shortMsg.curIndex = 0;
        _msgReady = true;
        _whole++;
        if(_whole == 1)
            _avgSwhole = length;
        else
            _avgSwhole = ((_whole - 1) * _avgSwhole + length) / _whole;
        
        _noMsgs++;
        dprintf( D_NETWORK, ""\tFull msg [%d bytes]\n"", length);
        return TRUE;
    }

    dprintf( D_NETWORK, ""\tFrag [%d bytes]\n"", length);
    
    /* long message */
    curTime = (unsigned long)time(NULL);
    index = labs(mID.ip_addr + mID.time + mID.msgNo) % SAFE_SOCK_HASH_BUCKET_SIZE;
    tempMsg = _inMsgs[index];
    while(tempMsg != NULL && !same(tempMsg->msgID, mID)) {
        prev = tempMsg;
        tempMsg = tempMsg->nextMsg;
        if(curTime - prev->lastTime > _tOutBtwPkts) {
            dprintf(D_NETWORK, ""found timed out msg: cur=%lu, msg=%lu\n"",
                    curTime, prev->lastTime);
            delMsg = prev;
            prev = delMsg->prevMsg;
            if(prev)
                prev->nextMsg = delMsg->nextMsg;
            else  // delMsg is the 1st message in the chain
                _inMsgs[index] = tempMsg;
            if(tempMsg)
                tempMsg->prevMsg = prev;
            _deleted++;
            if(_deleted == 1)
                _avgSdeleted = delMsg->msgLen;
            else     {
                _avgSdeleted = ((_deleted - 1) * _avgSdeleted + delMsg->msgLen) / _deleted;
            }   
            dprintf(D_NETWORK, ""Deleting timeouted message:\n"");
            delMsg->dumpMsg();
            delete delMsg;
        }   
    }   
    if(tempMsg != NULL) { // found
        if (seqNo == 0) {
            tempMsg->set_sec(_shortMsg.isDataMD5ed(),
                    _shortMsg.md(),
                    _shortMsg.isDataEncrypted());
        }
        bool rst = tempMsg->addPacket(last, seqNo, length, data);
        if (rst) {
            _longMsg = tempMsg;
            _msgReady = true;
            _whole++;
            if(_whole == 1)
                _avgSwhole = _longMsg->msgLen;
            else
                _avgSwhole = ((_whole - 1) * _avgSwhole + _longMsg->msgLen) / _whole;
            return TRUE;
        }
        return FALSE;
    } else { // not found
        if(prev) { // add a new message at the end of the chain
            prev->nextMsg = new _condorInMsg(mID, last, seqNo, length, data, 
                                             _shortMsg.isDataMD5ed(), 
                                             _shortMsg.md(), 
                                             _shortMsg.isDataEncrypted(), prev);
            if(!prev->nextMsg) {    
                EXCEPT(""Error:handle_incomming_packet: Out of Memory"");
            }
        } else { // first message in the bucket
            _inMsgs[index] = new _condorInMsg(mID, last, seqNo, length, data, 
                                              _shortMsg.isDataMD5ed(), 
                                              _shortMsg.md(), 
                                              _shortMsg.isDataEncrypted(), NULL);
            if(!_inMsgs[index]) {
                EXCEPT(""Error:handle_incomming_packet: Out of Memory"");
            }
        }
        _noMsgs++;
        return FALSE;
    }   
}
","int SafeSock::handle_incoming_packet()
{

	/* SOCKET_ALTERNATE_LENGTH_TYPE is void on this platform, and
		since noone knows what that void* is supposed to point to
		in recvfrom, I'm going to predict the ""fromlen"" variable
		the recvfrom uses is a size_t sized quantity since
		size_t is how you count bytes right?  Stupid Solaris. */
	bool last;
	int seqNo, length;
	_condorMsgID mID;
	void* data;
	int index;
	int received;
	_condorInMsg *tempMsg, *delMsg, *prev = NULL;
	time_t curTime;

	if( _msgReady ) {
		char const *existing_msg_type;
		bool existing_consumed;
		if( _longMsg ) {
			existing_msg_type = ""long"";
			existing_consumed = _longMsg->consumed();
		}
		else {
			existing_msg_type = ""short"";
			existing_consumed = _shortMsg.consumed();
		}
		dprintf( D_ALWAYS,
				 ""ERROR: receiving new UDP message but found a %s ""
				 ""message still waiting to be closed (consumed=%d). ""
				 ""Closing it now.\n"",
				 existing_msg_type, existing_consumed );


		stream_coding saved_coding = _coding;
		_coding = stream_decode;
		end_of_message();
		_coding = saved_coding;
	}


	received = condor_recvfrom(_sock, _shortMsg.dataGram, 
							   SAFE_MSG_MAX_PACKET_SIZE, 0, _who);

	if(received < 0) {
		dprintf(D_NETWORK, ""recvfrom failed: errno = %d\n"", errno);
                return FALSE;
        }
     char str[50];
    sprintf(str, sock_to_string(_sock));
     dprintf( D_NETWORK, ""RECV %d bytes at %s from %s\n"",
                         received, str, _who.to_sinful().Value());

	length = received;
    _shortMsg.reset(); // To be sure
	
	bool is_full_message = _shortMsg.getHeader(received, last, seqNo, length, mID, data);
	if ( length <= 0 || length > SAFE_MSG_MAX_PACKET_SIZE ) {
		dprintf(D_ALWAYS,""IO: Incoming datagram improperly sized\n"");
		return FALSE;
	}

    if ( is_full_message ) {
        _shortMsg.curIndex = 0;
        _msgReady = true;
        _whole++;
        if(_whole == 1)
            _avgSwhole = length;
        else
            _avgSwhole = ((_whole - 1) * _avgSwhole + length) / _whole;
        
        _noMsgs++;
        dprintf( D_NETWORK, ""\tFull msg [%d bytes]\n"", length);
        return TRUE;
    }

    dprintf( D_NETWORK, ""\tFrag [%d bytes]\n"", length);
    
    /* long message */
    curTime = (unsigned long)time(NULL);
    index = labs(mID.ip_addr + mID.time + mID.msgNo) % SAFE_SOCK_HASH_BUCKET_SIZE;
    tempMsg = _inMsgs[index];
    while(tempMsg != NULL && !same(tempMsg->msgID, mID)) {
        prev = tempMsg;
        tempMsg = tempMsg->nextMsg;
        if(curTime - prev->lastTime > _tOutBtwPkts) {
            dprintf(D_NETWORK, ""found timed out msg: cur=%lu, msg=%lu\n"",
                    curTime, prev->lastTime);
            delMsg = prev;
            prev = delMsg->prevMsg;
            if(prev)
                prev->nextMsg = delMsg->nextMsg;
            else  // delMsg is the 1st message in the chain
                _inMsgs[index] = tempMsg;
            if(tempMsg)
                tempMsg->prevMsg = prev;
            _deleted++;
            if(_deleted == 1)
                _avgSdeleted = delMsg->msgLen;
            else     {
                _avgSdeleted = ((_deleted - 1) * _avgSdeleted + delMsg->msgLen) / _deleted;
            }   
            dprintf(D_NETWORK, ""Deleting timeouted message:\n"");
            delMsg->dumpMsg();
            delete delMsg;
        }   
    }   
    if(tempMsg != NULL) { // found
        if (seqNo == 0) {
            tempMsg->set_sec(_shortMsg.isDataMD5ed(),
                    _shortMsg.md(),
                    _shortMsg.isDataEncrypted());
        }
        bool rst = tempMsg->addPacket(last, seqNo, length, data);
        if (rst) {
            _longMsg = tempMsg;
            _msgReady = true;
            _whole++;
            if(_whole == 1)
                _avgSwhole = _longMsg->msgLen;
            else
                _avgSwhole = ((_whole - 1) * _avgSwhole + _longMsg->msgLen) / _whole;
            return TRUE;
        }
        return FALSE;
    } else { // not found
        if(prev) { // add a new message at the end of the chain
            prev->nextMsg = new _condorInMsg(mID, last, seqNo, length, data, 
                                             _shortMsg.isDataMD5ed(), 
                                             _shortMsg.md(), 
                                             _shortMsg.isDataEncrypted(), prev);
            if(!prev->nextMsg) {    
                EXCEPT(""Error:handle_incomming_packet: Out of Memory"");
            }
        } else { // first message in the bucket
            _inMsgs[index] = new _condorInMsg(mID, last, seqNo, length, data, 
                                              _shortMsg.isDataMD5ed(), 
                                              _shortMsg.md(), 
                                              _shortMsg.isDataEncrypted(), NULL);
            if(!_inMsgs[index]) {
                EXCEPT(""Error:handle_incomming_packet: Out of Memory"");
            }
        }
        _noMsgs++;
        return FALSE;
    }   
}
",CPP,"    sprintf(str, ""%s"", sock_to_string(_sock));
","    sprintf(str, sock_to_string(_sock));
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -622,7 +622,7 @@ int SafeSock::handle_incoming_packet()
                return FALSE;
        }
     char str[50];
-    sprintf(str, sock_to_string(_sock));
+    sprintf(str, ""%s"", sock_to_string(_sock));
     dprintf( D_NETWORK, ""RECV %d bytes at %s from %s\n"",
                         received, str, _who.to_sinful().Value());
     //char temp_str[10000];",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_io/safe_sock.cpp;h=663331efd182996079406132025788d08ec6e629;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_io/safe_sock.cpp;h=bf76e04dcaa0947fde56591d436560613cd3c188,1,"int SafeSock::handle_incoming_packet()
{

//#if defined(Solaris27) || defined(Solaris28) || defined(Solaris29) || defined(Solaris10) || defined(Solaris11)
	/* SOCKET_ALTERNATE_LENGTH_TYPE is void on this platform, and
		since noone knows what that void* is supposed to point to
		in recvfrom, I'm going to predict the ""fromlen"" variable
		the recvfrom uses is a size_t sized quantity since
		size_t is how you count bytes right?  Stupid Solaris. */
	bool last;
	int seqNo, length;
	_condorMsgID mID;
	void* data;
	int index;
	int received;
	_condorInMsg *tempMsg, *delMsg, *prev = NULL;
	time_t curTime;

	if( _msgReady ) {
		char const *existing_msg_type;
		bool existing_consumed;
		if( _longMsg ) {
			existing_msg_type = ""long"";
			existing_consumed = _longMsg->consumed();
		}
		else {
			existing_msg_type = ""short"";
			existing_consumed = _shortMsg.consumed();
		}
		dprintf( D_ALWAYS,
				 ""ERROR: receiving new UDP message but found a %s ""
				 ""message still waiting to be closed (consumed=%d). ""
				 ""Closing it now.\n"",
				 existing_msg_type, existing_consumed );

			// Now force end_of_message() to be called.  This is especially
			// important if we receive a short UDP message and a long
			// message is still unclosed, because the long message will
			// continue to act as the source for all read operations.

		stream_coding saved_coding = _coding;
		_coding = stream_decode;
		end_of_message();
		_coding = saved_coding;
	}


	received = condor_recvfrom(_sock, _shortMsg.dataGram, 
							   SAFE_MSG_MAX_PACKET_SIZE, 0, _who);

	if(received < 0) {
		dprintf(D_NETWORK, ""recvfrom failed: errno = %d\n"", errno);
                return FALSE;
        }
     char str[50];
//flaw_line_below:
    sprintf(str, sock_to_string(_sock));
//fix_flaw_line_below:
//    sprintf(str, ""%s"", sock_to_string(_sock));
     dprintf( D_NETWORK, ""RECV %d bytes at %s from %s\n"",
                         received, str, _who.to_sinful().Value());
     //char temp_str[10000];
    //temp_str[0] = 0;
    //for (int i=0; i<received; i++) { sprintf(&temp_str[strlen(temp_str)], ""%02x,"", _shortMsg.dataGram[i]); }
    //dprintf(D_NETWORK, ""<---packet [%d bytes]: %s\n"", received, temp_str);

	length = received;
    _shortMsg.reset(); // To be sure
	
	bool is_full_message = _shortMsg.getHeader(received, last, seqNo, length, mID, data);
	if ( length <= 0 || length > SAFE_MSG_MAX_PACKET_SIZE ) {
		// someone maybe sending us random garbage datagrams?
		dprintf(D_ALWAYS,""IO: Incoming datagram improperly sized\n"");
		return FALSE;
	}

    if ( is_full_message ) {
        _shortMsg.curIndex = 0;
        _msgReady = true;
        _whole++;
        if(_whole == 1)
            _avgSwhole = length;
        else
            _avgSwhole = ((_whole - 1) * _avgSwhole + length) / _whole;
        
        _noMsgs++;
        dprintf( D_NETWORK, ""\tFull msg [%d bytes]\n"", length);
        return TRUE;
    }

    dprintf( D_NETWORK, ""\tFrag [%d bytes]\n"", length);
    
    /* long message */
    curTime = (unsigned long)time(NULL);
    index = labs(mID.ip_addr + mID.time + mID.msgNo) % SAFE_SOCK_HASH_BUCKET_SIZE;
    tempMsg = _inMsgs[index];
    while(tempMsg != NULL && !same(tempMsg->msgID, mID)) {
        prev = tempMsg;
        tempMsg = tempMsg->nextMsg;
        // delete 'timeout'ed message
        if(curTime - prev->lastTime > _tOutBtwPkts) {
            dprintf(D_NETWORK, ""found timed out msg: cur=%lu, msg=%lu\n"",
                    curTime, prev->lastTime);
            delMsg = prev;
            prev = delMsg->prevMsg;
            if(prev)
                prev->nextMsg = delMsg->nextMsg;
            else  // delMsg is the 1st message in the chain
                _inMsgs[index] = tempMsg;
            if(tempMsg)
                tempMsg->prevMsg = prev;
            _deleted++;
            if(_deleted == 1)
                _avgSdeleted = delMsg->msgLen;
            else     {
                _avgSdeleted = ((_deleted - 1) * _avgSdeleted + delMsg->msgLen) / _deleted;
            }   
            dprintf(D_NETWORK, ""Deleting timeouted message:\n"");
            delMsg->dumpMsg();
            delete delMsg;
        }   
    }   
    if(tempMsg != NULL) { // found
        if (seqNo == 0) {
            tempMsg->set_sec(_shortMsg.isDataMD5ed(),
                    _shortMsg.md(),
                    _shortMsg.isDataEncrypted());
        }
        bool rst = tempMsg->addPacket(last, seqNo, length, data);
        //dprintf(D_NETWORK, ""new packet added\n"");
        //tempMsg->dumpMsg();
        if (rst) {
            _longMsg = tempMsg;
            _msgReady = true;
            _whole++;
            if(_whole == 1)
                _avgSwhole = _longMsg->msgLen;
            else
                _avgSwhole = ((_whole - 1) * _avgSwhole + _longMsg->msgLen) / _whole;
            return TRUE;
        }
        return FALSE;
    } else { // not found
        if(prev) { // add a new message at the end of the chain
            prev->nextMsg = new _condorInMsg(mID, last, seqNo, length, data, 
                                             _shortMsg.isDataMD5ed(), 
                                             _shortMsg.md(), 
                                             _shortMsg.isDataEncrypted(), prev);
            if(!prev->nextMsg) {    
                EXCEPT(""Error:handle_incomming_packet: Out of Memory"");
            }
            //dprintf(D_NETWORK, ""new msg created\n"");
            //prev->nextMsg->dumpMsg();
        } else { // first message in the bucket
            _inMsgs[index] = new _condorInMsg(mID, last, seqNo, length, data, 
                                              _shortMsg.isDataMD5ed(), 
                                              _shortMsg.md(), 
                                              _shortMsg.isDataEncrypted(), NULL);
            if(!_inMsgs[index]) {
                EXCEPT(""Error:handle_incomming_packet: Out of Memory"");
            }
            //dprintf(D_NETWORK, ""new msg created\n"");
            //_inMsgs[index]->dumpMsg();
        }
        _noMsgs++;
        return FALSE;
    }   
}
"
811,178547,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,1,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,1,,," usage(int iExitCode)
 {
        char word[32];
       sprintf( word, ""%s"", getJobActionString(mode) );
        fprintf( stderr, ""Usage: %s [options] [constraints]\n"", MyName );
        fprintf( stderr, "" where [options] is zero or more of:\n"" );
        fprintf( stderr, ""  -help               Display this message and exit\n"" );
	fprintf( stderr, ""  -version            Display version information and exit\n"" );


	fprintf( stderr, ""  -name schedd_name   Connect to the given schedd\n"" );
	fprintf( stderr, ""  -pool hostname      Use the given central manager to find daemons\n"" );
	fprintf( stderr, ""  -addr <ip:port>     Connect directly to the given \""sinful string\""\n"" );
	if( mode == JA_REMOVE_JOBS || mode == JA_REMOVE_X_JOBS ) {
		fprintf( stderr, ""  -reason reason      Use the given RemoveReason\n"");
	} else if( mode == JA_RELEASE_JOBS ) {
		fprintf( stderr, ""  -reason reason      Use the given ReleaseReason\n"");
	} else if( mode == JA_HOLD_JOBS ) {
		fprintf( stderr, ""  -reason reason      Use the given HoldReason\n"");
		fprintf( stderr, ""  -subcode number     Set HoldReasonSubCode\n"");
	}

	if( mode == JA_REMOVE_JOBS || mode == JA_REMOVE_X_JOBS ) {
		fprintf( stderr,
				     ""  -forcex             Force the immediate local removal of jobs in the X state\n""
		         ""                      (only affects jobs already being removed)\n"" );
	}
	if( mode == JA_VACATE_JOBS || mode == JA_VACATE_FAST_JOBS ) {
		fprintf( stderr,
				     ""  -fast               Use a fast vacate (hardkill)\n"" );
	}
	fprintf( stderr, "" and where [constraints] is one of:\n"" );
	fprintf( stderr, ""  cluster.proc        %s the given job\n"", word );
	fprintf( stderr, ""  cluster             %s the given cluster of jobs\n"", word );
	fprintf( stderr, ""  user                %s all jobs owned by user\n"", word );
	fprintf( stderr, ""  -constraint expr    %s all jobs matching the boolean expression\n"", word );
	fprintf( stderr, ""  -all                %s all jobs ""
			 ""(cannot be used with other constraints)\n"", word );
	exit( iExitCode );
}
"," usage(int iExitCode)
 {
        char word[32];
       sprintf( word, getJobActionString(mode) );
        fprintf( stderr, ""Usage: %s [options] [constraints]\n"", MyName );
        fprintf( stderr, "" where [options] is zero or more of:\n"" );
        fprintf( stderr, ""  -help               Display this message and exit\n"" );
	fprintf( stderr, ""  -version            Display version information and exit\n"" );


	fprintf( stderr, ""  -name schedd_name   Connect to the given schedd\n"" );
	fprintf( stderr, ""  -pool hostname      Use the given central manager to find daemons\n"" );
	fprintf( stderr, ""  -addr <ip:port>     Connect directly to the given \""sinful string\""\n"" );
	if( mode == JA_REMOVE_JOBS || mode == JA_REMOVE_X_JOBS ) {
		fprintf( stderr, ""  -reason reason      Use the given RemoveReason\n"");
	} else if( mode == JA_RELEASE_JOBS ) {
		fprintf( stderr, ""  -reason reason      Use the given ReleaseReason\n"");
	} else if( mode == JA_HOLD_JOBS ) {
		fprintf( stderr, ""  -reason reason      Use the given HoldReason\n"");
		fprintf( stderr, ""  -subcode number     Set HoldReasonSubCode\n"");
	}

	if( mode == JA_REMOVE_JOBS || mode == JA_REMOVE_X_JOBS ) {
		fprintf( stderr,
				     ""  -forcex             Force the immediate local removal of jobs in the X state\n""
		         ""                      (only affects jobs already being removed)\n"" );
	}
	if( mode == JA_VACATE_JOBS || mode == JA_VACATE_FAST_JOBS ) {
		fprintf( stderr,
				     ""  -fast               Use a fast vacate (hardkill)\n"" );
	}
	fprintf( stderr, "" and where [constraints] is one of:\n"" );
	fprintf( stderr, ""  cluster.proc        %s the given job\n"", word );
	fprintf( stderr, ""  cluster             %s the given cluster of jobs\n"", word );
	fprintf( stderr, ""  user                %s all jobs owned by user\n"", word );
	fprintf( stderr, ""  -constraint expr    %s all jobs matching the boolean expression\n"", word );
	fprintf( stderr, ""  -all                %s all jobs ""
			 ""(cannot be used with other constraints)\n"", word );
	exit( iExitCode );
}
",CPP,"       sprintf( word, ""%s"", getJobActionString(mode) );
","       sprintf( word, getJobActionString(mode) );
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -114,7 +114,7 @@ void
 usage(int iExitCode)
 {
        char word[32];
-       sprintf( word, getJobActionString(mode) );
+       sprintf( word, ""%s"", getJobActionString(mode) );
        fprintf( stderr, ""Usage: %s [options] [constraints]\n"", MyName );
        fprintf( stderr, "" where [options] is zero or more of:\n"" );
        fprintf( stderr, ""  -help               Display this message and exit\n"" );",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_rm.V6/rm.cpp;h=e422ede0a89443523ee3d35d5aae646888fc9c25;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_rm.V6/rm.cpp;h=e1eb6095ba7701a3ac6f3400d1b7643541f66c89,1," usage(int iExitCode)
 {
        char word[32];
//flaw_line_below:
       sprintf( word, getJobActionString(mode) );
//fix_flaw_line_below:
//       sprintf( word, ""%s"", getJobActionString(mode) );
        fprintf( stderr, ""Usage: %s [options] [constraints]\n"", MyName );
        fprintf( stderr, "" where [options] is zero or more of:\n"" );
        fprintf( stderr, ""  -help               Display this message and exit\n"" );
	fprintf( stderr, ""  -version            Display version information and exit\n"" );

// i'm not sure we want -debug documented.  if we change our minds, we
// should just uncomment the next line
//	fprintf( stderr, ""  -debug              Display debugging information while running\n"" );

	fprintf( stderr, ""  -name schedd_name   Connect to the given schedd\n"" );
	fprintf( stderr, ""  -pool hostname      Use the given central manager to find daemons\n"" );
	fprintf( stderr, ""  -addr <ip:port>     Connect directly to the given \""sinful string\""\n"" );
	if( mode == JA_REMOVE_JOBS || mode == JA_REMOVE_X_JOBS ) {
		fprintf( stderr, ""  -reason reason      Use the given RemoveReason\n"");
	} else if( mode == JA_RELEASE_JOBS ) {
		fprintf( stderr, ""  -reason reason      Use the given ReleaseReason\n"");
	} else if( mode == JA_HOLD_JOBS ) {
		fprintf( stderr, ""  -reason reason      Use the given HoldReason\n"");
		fprintf( stderr, ""  -subcode number     Set HoldReasonSubCode\n"");
	}

	if( mode == JA_REMOVE_JOBS || mode == JA_REMOVE_X_JOBS ) {
		fprintf( stderr,
				     ""  -forcex             Force the immediate local removal of jobs in the X state\n""
		         ""                      (only affects jobs already being removed)\n"" );
	}
	if( mode == JA_VACATE_JOBS || mode == JA_VACATE_FAST_JOBS ) {
		fprintf( stderr,
				     ""  -fast               Use a fast vacate (hardkill)\n"" );
	}
	fprintf( stderr, "" and where [constraints] is one of:\n"" );
	fprintf( stderr, ""  cluster.proc        %s the given job\n"", word );
	fprintf( stderr, ""  cluster             %s the given cluster of jobs\n"", word );
	fprintf( stderr, ""  user                %s all jobs owned by user\n"", word );
	fprintf( stderr, ""  -constraint expr    %s all jobs matching the boolean expression\n"", word );
	fprintf( stderr, ""  -all                %s all jobs ""
			 ""(cannot be used with other constraints)\n"", word );
	exit( iExitCode );
}
"
812,178548,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,1,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,1,,,"do_REMOTE_syscall()
{
	int condor_sysnum;
	int	rval = -1, result = -1, fd = -1, mode = -1, uid = -1, gid = -1;
	int length = -1;
	condor_errno_t terrno;
	char *path = NULL, *buffer = NULL;
	void *buf = NULL;

	syscall_sock->decode();

	dprintf(D_SYSCALLS, ""About to decode condor_sysnum\n"");

	rval = syscall_sock->code(condor_sysnum);
	if (!rval) {
		MyString err_msg;
		err_msg = ""Can no longer talk to condor_starter <"";
		err_msg += syscall_sock->peer_ip_str();
		err_msg += ':';
		err_msg += syscall_sock->peer_port();
		err_msg += '>';

		thisRemoteResource->closeClaimSock();

            /* It is possible that we are failing to read the
            syscall number because the starter went away
            because we *asked* it to go away. Don't be shocked
            and surprised if the startd/starter actually did
            what we asked when we deactivated the claim */
       if ( thisRemoteResource->wasClaimDeactivated() ) {
           return 0;
       }

		if( Shadow->supportsReconnect() ) {
			dprintf( D_ALWAYS, ""%s\n"", err_msg.Value() );

			const char* txt = ""Socket between submit and execute hosts ""
				""closed unexpectedly"";
			Shadow->logDisconnectedEvent( txt ); 

			if (!Shadow->shouldAttemptReconnect(thisRemoteResource)) {
					dprintf(D_ALWAYS, ""This job cannot reconnect to starter, so job exiting\n"");
					Shadow->gracefulShutDown();
					EXCEPT( ""%s"", err_msg.Value() );
			}
			Shadow->reconnect();
			return 0;
		} else {
			EXCEPT( ""%s"", err_msg.Value() );
		}
	}

	dprintf(D_SYSCALLS,
		""Got request for syscall %s (%d)\n"",
		shadow_syscall_name(condor_sysnum), condor_sysnum);

	switch( condor_sysnum ) {

	case CONDOR_register_starter_info:
	{
		ClassAd ad;
		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_register_starter_info( &ad );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_register_job_info:
	{
		ClassAd ad;
		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_register_job_info( &ad );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_get_job_info:
	{
		ClassAd *ad = NULL;
		bool delete_ad;

		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_get_job_info(ad, delete_ad);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		} else {
			result = ( ad->put(*syscall_sock) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		if ( delete_ad ) {
			delete ad;
		}
		return 0;
	}


	case CONDOR_get_user_info:
	{
		ClassAd *ad = NULL;

		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_get_user_info(ad);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		} else {
			result = ( ad->put(*syscall_sock) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}


	case CONDOR_job_exit:
	{
		int status=0;
		int reason=0;
		ClassAd ad;

		result = ( syscall_sock->code(status) );
		ASSERT( result );
		result = ( syscall_sock->code(reason) );
		ASSERT( result );
		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_job_exit(status, reason, &ad);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return -1;
	}

	case CONDOR_job_termination:
	{
		ClassAd ad;
		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_job_termination( &ad );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_begin_execution:
	{
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_begin_execution();
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_open:
	  {
		open_flags_t flags;
		int   lastarg;

		result = ( syscall_sock->code(flags) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  flags = %d\n"", flags );
		result = ( syscall_sock->code(lastarg) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  lastarg = %d\n"", lastarg );
		path = NULL;
		result = ( syscall_sock->code(path) );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );


		bool access_ok;
		if ( flags & O_RDONLY ) {
			access_ok = read_access(path);
		} else {
			access_ok = write_access(path);
		}

		errno = 0;
		if ( access_ok ) {
			rval = safe_open_wrapper_follow( path , flags , lastarg);
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}

		free( (char *)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_close:
	  {
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = close( fd);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_read:
	  {
		size_t   len;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		buf = (void *)malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = read( fd , buf , len);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		if( rval >= 0 ) {
			result = ( syscall_sock->code_bytes_bool(buf, rval) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_write:
	  {
		size_t   len;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		buf = (void *)malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->code_bytes_bool(buf, len) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = write( fd , buf , len);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_lseek:
	case CONDOR_lseek64:
	case CONDOR_llseek:
	  {
		off_t   offset;
		int   whence;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(offset) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  offset = %ld\n"", (long)offset );
		result = ( syscall_sock->code(whence) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  whence = %d\n"", whence );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = lseek( fd , offset , whence);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_unlink:
	  {
		path = NULL;
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		if ( write_access(path) ) {
			errno = 0;
			rval = unlink( path);
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char *)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_rename:
	  {
		char *  from;
		char *  to;

		to = NULL;
		from = NULL;
		result = ( syscall_sock->code(from) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  from = %s\n"", from );
		result = ( syscall_sock->code(to) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  to = %s\n"", to );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		if ( write_access(from) && write_access(to) ) {
			errno = 0;
			rval = rename( from , to);
		} else {
			rval = -1;
			errno = EACCES;
		}

		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char *)to );
		free( (char *)from );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_register_mpi_master_info:
	{
		ClassAd ad;
		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_register_mpi_master_info( &ad );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_mkdir:
	  {
		path = NULL;
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(mode) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  mode = %d\n"", mode );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		if ( write_access(path) ) {
			errno = 0;
			rval = mkdir(path,mode);
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char *)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_rmdir:
	  {
		path = NULL;
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		if ( write_access(path) ) {
			errno = 0;
			rval = rmdir( path);
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_fsync:
	  {
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fs = %d\n"", fd );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = fsync(fd);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_get_file_info_new:
	  {
		char *  logical_name;
		char *  actual_url;
 
		actual_url = NULL;
		logical_name = NULL;
		ASSERT( syscall_sock->code(logical_name) );
		ASSERT( syscall_sock->end_of_message() );;
 
		errno = (condor_errno_t)0;
		rval = pseudo_get_file_info_new( logical_name , actual_url );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, (int)terrno );
 
		syscall_sock->encode();
		ASSERT( syscall_sock->code(rval) );
		if( rval < 0 ) {
			ASSERT( syscall_sock->code(terrno) );
		}
		if( rval >= 0 ) {
			ASSERT( syscall_sock->code(actual_url) );
		}
		free( (char *)actual_url );
		free( (char *)logical_name );
		ASSERT( syscall_sock->end_of_message() );;
		return 0;
	}

	case CONDOR_ulog:
	{
		ClassAd ad;

		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		rval = pseudo_ulog(&ad);
		dprintf( D_SYSCALLS, ""\trval = %d\n"", rval );


		return 0;
	}

	case CONDOR_get_job_attr:
	  {
		char *  attrname = 0;

		assert( syscall_sock->code(attrname) );
		assert( syscall_sock->end_of_message() );;

		errno = (condor_errno_t)0;
		MyString expr;
		if ( thisRemoteResource->allowRemoteReadAttributeAccess(attrname) ) {
			rval = pseudo_get_job_attr( attrname , expr);
			terrno = (condor_errno_t)errno;
		} else {
			rval = -1;
			terrno = (condor_errno_t)EACCES;
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, (int)terrno );

		syscall_sock->encode();
		assert( syscall_sock->code(rval) );
		if( rval < 0 ) {
			assert( syscall_sock->code(terrno) );
		}
		if( rval >= 0 ) {
			assert( syscall_sock->put(expr.Value()) );
		}
		free( (char *)attrname );
		assert( syscall_sock->end_of_message() );;
		return 0;
	}

	case CONDOR_set_job_attr:
	  {
		char *  attrname = 0;
		char *  expr = 0;

		assert( syscall_sock->code(expr) );
		assert( syscall_sock->code(attrname) );
		assert( syscall_sock->end_of_message() );;

		errno = (condor_errno_t)0;
		if ( thisRemoteResource->allowRemoteWriteAttributeAccess(attrname) ) {
			rval = pseudo_set_job_attr( attrname , expr , true );
			terrno = (condor_errno_t)errno;
		} else {
			rval = -1;
			terrno = (condor_errno_t)EACCES;
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, (int)terrno );

		syscall_sock->encode();
		assert( syscall_sock->code(rval) );
		if( rval < 0 ) {
			assert( syscall_sock->code(terrno) );
		}
		free( (char *)expr );
		free( (char *)attrname );
		assert( syscall_sock->end_of_message() );;
		return 0;
	}

	case CONDOR_constrain:
	  {
		char *  expr = 0;

		assert( syscall_sock->code(expr) );
		assert( syscall_sock->end_of_message() );;

		errno = (condor_errno_t)0;
		if ( thisRemoteResource->allowRemoteWriteAttributeAccess(ATTR_REQUIREMENTS) ) {
			rval = pseudo_constrain( expr);
			terrno = (condor_errno_t)errno;
		} else {
			rval = -1;
			terrno = (condor_errno_t)EACCES;
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, (int)terrno );

		syscall_sock->encode();
		assert( syscall_sock->code(rval) );
		if( rval < 0 ) {
			assert( syscall_sock->code(terrno) );
		}
		free( (char *)expr );
		assert( syscall_sock->end_of_message() );;
		return 0;
	}
	case CONDOR_get_sec_session_info:
	{
		MyString starter_reconnect_session_info;
		MyString starter_filetrans_session_info;
		MyString reconnect_session_id;
		MyString reconnect_session_info;
		MyString reconnect_session_key;
		MyString filetrans_session_id;
		MyString filetrans_session_info;
		MyString filetrans_session_key;
		bool socket_default_crypto = syscall_sock->get_encryption();
		if( !socket_default_crypto ) {
			syscall_sock->set_crypto_mode(true);
		}
		assert( syscall_sock->code(starter_reconnect_session_info) );
		assert( syscall_sock->code(starter_filetrans_session_info) );
		assert( syscall_sock->end_of_message() );

		errno = (condor_errno_t)0;
		rval = pseudo_get_sec_session_info(
			starter_reconnect_session_info.Value(),
			reconnect_session_id,
			reconnect_session_info,
			reconnect_session_key,
			starter_filetrans_session_info.Value(),
			filetrans_session_id,
			filetrans_session_info,
			filetrans_session_key );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, (int)terrno );

		syscall_sock->encode();
		assert( syscall_sock->code(rval) );
		if( rval < 0 ) {
			assert( syscall_sock->code(terrno) );
		}
		else {
			assert( syscall_sock->code(reconnect_session_id) );
			assert( syscall_sock->code(reconnect_session_info) );
			assert( syscall_sock->code(reconnect_session_key) );

			assert( syscall_sock->code(filetrans_session_id) );
			assert( syscall_sock->code(filetrans_session_info) );
			assert( syscall_sock->code(filetrans_session_key) );
		}

		assert( syscall_sock->end_of_message() );

		if( !socket_default_crypto ) {
			syscall_sock->set_crypto_mode( false );  // restore default
		}
		return 0;
	}
#ifdef WIN32
#else
	case CONDOR_pread:
	  {
		size_t len, offset;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		result = ( syscall_sock->code(offset) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  offset = %ld\n"", (long)offset );
		buf = (void *)malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pread( fd , buf , len, offset );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(buf, rval) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_pwrite:
	  {
		size_t   len, offset;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		result = ( syscall_sock->code(offset) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  offset = %ld\n"", (long)offset);
		buf = malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->code_bytes_bool(buf, len) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pwrite( fd , buf , len, offset);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_sread:
	  {
		size_t   len, offset, stride_length, stride_skip;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		result = ( syscall_sock->code(offset) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  offset = %ld\n"", (long)offset );
		result = ( syscall_sock->code(stride_length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  stride_length = %ld\n"", (long)stride_length);
		result = ( syscall_sock->code(stride_skip) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  stride_skip = %ld\n"", (long)stride_skip);
		buf = (void *)malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = EINVAL;
		rval = -1;
		unsigned int total = 0;
		buffer = (char*)buf;

		while(total < len && stride_length > 0) {
			if(len - total < stride_length) {
				stride_length = len - total;
			}
			rval = pread( fd, (void*)&buffer[total], stride_length, offset );
			if(rval >= 0) {
				total += rval;
				offset += stride_skip;
			}
			else {
				break;
			}
		}

		syscall_sock->encode();
		if( rval < 0 ) {
			result = ( syscall_sock->code(rval) );
			ASSERT( result );
			terrno = (condor_errno_t)errno;
			dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", total, terrno );
			result = ( syscall_sock->code(total) );
			ASSERT( result );
			dprintf( D_ALWAYS, ""buffer: %s\n"", buffer);
			result = ( syscall_sock->code_bytes_bool(buf, total) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_swrite:
	  {
		size_t   len, offset, stride_length, stride_skip;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		result = ( syscall_sock->code(offset) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  offset = %ld\n"", (long)offset);
		result = ( syscall_sock->code(stride_length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  stride_length = %ld\n"", (long)stride_length);
		result = ( syscall_sock->code(stride_skip) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  stride_skip = %ld\n"", (long)stride_skip);
		buf = (void *)malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->code_bytes_bool(buf, len) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = EINVAL;
		rval = -1;
		unsigned int total = 0;
		buffer = (char*)buf;

		while(total < len && stride_length > 0) {
			if(len - total < stride_length) {
				stride_length = len - total;
			}
			rval = pwrite( fd, (void*)&buffer[total], stride_length, offset);
			if(rval >= 0) {
				total += rval;
				offset += stride_skip;
			}
			else {
				break;
			}
		}
		
		syscall_sock->encode();
		if( rval < 0 ) {
			terrno = (condor_errno_t)errno;
			dprintf( D_SYSCALLS, ""\trval = %d, errno = %d (%s)\n"", rval, terrno, strerror(errno));
			result = ( syscall_sock->code(rval) );
			ASSERT( result );
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			dprintf( D_SYSCALLS, ""\trval = %d, errno = %d (%s)\n"", total, terrno, strerror(errno));
			result = ( syscall_sock->code(total) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_rmall:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		if ( write_access(path) ) {
			rval = rmdir(path);
			
			if(rval == -1) {
				Directory dir(path);
				if(dir.Remove_Entire_Directory()) {
					rval = rmdir(path);
				}
			}
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char *)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
case CONDOR_getfile:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		fd = safe_open_wrapper_follow( path, O_RDONLY );
		if(fd >= 0) {
			struct stat info;
			stat(path, &info);
			length = info.st_size;
			buf = (void *)malloc( (unsigned)length );
			memset( buf, 0, (unsigned)length );

			errno = 0;
			rval = read( fd , buf , length);
		} else {
			rval = fd;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {	
			result = ( syscall_sock->code_bytes_bool(buf, rval) );
			ASSERT( result );
		}
		free( (char *)path );
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
case CONDOR_putfile:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf(D_SYSCALLS, ""  path: %s\n"", path);
		result = ( syscall_sock->code(mode) );
		ASSERT( result );
		dprintf(D_SYSCALLS, ""  mode: %d\n"", mode);
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf(D_SYSCALLS, ""  length: %d\n"", length);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		fd = safe_open_wrapper_follow(path, O_CREAT | O_WRONLY | O_TRUNC, mode);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		if( fd < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		int num = -1;
		if(fd >= 0) {
			syscall_sock->decode();
			buffer = (char*)malloc( (unsigned)length );
			memset( buffer, 0, (unsigned)length );
			result = ( syscall_sock->code_bytes_bool(buffer, length) );
			ASSERT( result );
			result = ( syscall_sock->end_of_message() );
			ASSERT( result );
			num = write(fd, buffer, length);
		}
		else {
			dprintf(D_SYSCALLS, ""Unable to put file %s\n"", path);
		}
		close(fd);
		
		syscall_sock->encode();
		result = ( syscall_sock->code(num) );
		ASSERT( result );
		if( num < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free((char*)path);
		free((char*)buffer);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
case CONDOR_getlongdir:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = -1;
		MyString msg, check;
		const char *next;
		Directory directory(path);
		struct stat stat_buf;
		char line[1024];
		
		while((next = directory.Next())) {
			dprintf(D_ALWAYS, ""next: %s\n"", next);
			msg.sprintf_cat(""%s\n"", next);
			check.sprintf(""%s%c%s"", path, DIR_DELIM_CHAR, next);
			rval = stat(check.Value(), &stat_buf);
			terrno = (condor_errno_t)errno;
			if(rval == -1) {
				break;
			}
			if(stat_string(line, &stat_buf) < 0) {
				rval = -1;
				break;
			}
			msg.sprintf_cat(""%s"", line);
		}
		terrno = (condor_errno_t)errno;
		if(msg.Length() > 0) {
			msg.sprintf_cat(""\n"");	// Needed to signify end of data
			rval = msg.Length();
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->put(msg.Value()) );
			ASSERT( result );
		}
		free((char*)path);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
case CONDOR_getdir:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = -1;
		MyString msg;
		const char *next;
		Directory directory(path);
 
                while((next = directory.Next())) {
                       msg.sprintf_cat(""%s"", next);
                        msg.sprintf_cat(""\n"");
                }
                terrno = (condor_errno_t)errno;
		if(msg.Length() > 0) {
			msg.sprintf_cat(""\n"");	// Needed to signify end of data
			rval = msg.Length();
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->put(msg.Value()) );
			ASSERT( result );
		}
		free((char*)path);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_whoami:
	{
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  length = %d\n"", length );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		buffer = (char*)malloc( (unsigned)length );
		int size = 6;
		if(length < size) {
			rval = -1;
			terrno = (condor_errno_t) ENOSPC;
		}
		else {
			rval = sprintf(buffer, ""CONDOR"");
			terrno = (condor_errno_t) errno;
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval != size) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(buffer, rval));
			ASSERT( result );
		}
		free((char*)buffer);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_whoareyou:
	{
		char *host = NULL;

		result = ( syscall_sock->code(host) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  host = %s\n"", host );
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  length = %d\n"", length );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		buffer = (char*)malloc( (unsigned)length );
		int size = 7;
		if(length < size) {
			rval = -1;
			terrno = (condor_errno_t) ENOSPC;
		}
		else {
			rval = sprintf(buffer, ""UNKNOWN"");
			terrno = (condor_errno_t) errno;
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval != size) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(buffer, rval));
			ASSERT( result );
		}
		free((char*)buffer);
		free((char*)host);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_fstatfs:
	{
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
#if defined(Solaris)
		struct statvfs statfs_buf;
		rval = fstatvfs(fd, &statfs_buf);
#else
		struct statfs statfs_buf;
		rval = fstatfs(fd, &statfs_buf);
#endif
		terrno = (condor_errno_t)errno;
		char line[1024];
		if(rval == 0) {
			if(statfs_string(line, &statfs_buf) < 0) {
				rval = -1;
				terrno = (condor_errno_t)errno;
			}
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(line, 1024) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;	
	}
	case CONDOR_fchown:
	{
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(uid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  uid = %d\n"", uid );
		result = ( syscall_sock->code(gid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  gid = %d\n"", gid );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = fchown(fd, uid, gid);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_fchmod:
	{
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(mode) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  mode = %d\n"", mode );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = fchmod(fd, (mode_t)mode);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_ftruncate:
	{
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  length = %d\n"", length );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = ftruncate(fd, length);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	
	
	
	
	
	
	case CONDOR_link:
	{
		char *newpath = NULL;

		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(newpath) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  newpath = %s\n"", newpath );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = link(path, newpath);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free((char*)path);
		free((char*)newpath);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_symlink:
	{
		char *newpath = NULL;

		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(newpath) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  newpath = %s\n"", newpath );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = symlink(path, newpath);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free((char*)path);
		free((char*)newpath);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_readlink:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  length = %d\n"", length );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		char *lbuffer = (char*)malloc(length);
		errno = 0;
		rval = readlink(path, lbuffer, length);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(lbuffer, rval));
			ASSERT( result );
		}
		free(lbuffer);
		free(path);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_lstat:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		struct stat stat_buf;
		rval = lstat(path, &stat_buf);
		terrno = (condor_errno_t)errno;
		char line[1024];
		if(rval == 0) {
			if(stat_string(line, &stat_buf) < 0) {
				rval = -1;
				terrno = (condor_errno_t)errno;
			}
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(line, 1024) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_statfs:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
#if defined(Solaris)
		struct statvfs statfs_buf;
		rval = statvfs(path, &statfs_buf);
#else
		struct statfs statfs_buf;
		rval = statfs(path, &statfs_buf);
#endif
		terrno = (condor_errno_t)errno;
		char line[1024];
		if(rval == 0) {
			if(statfs_string(line, &statfs_buf) < 0) {
				rval = -1;
				terrno = (condor_errno_t)errno;
			}
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(line, 1024) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_chown:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(uid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  uid = %d\n"", uid );
		result = ( syscall_sock->code(gid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  gid = %d\n"", gid );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = chown(path, uid, gid);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
	
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_lchown:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(uid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  uid = %d\n"", uid );
		result = ( syscall_sock->code(gid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  gid = %d\n"", gid );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = lchown(path, uid, gid);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
	
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_truncate:
	{
		
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  length = %d\n"", length );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		if ( write_access(path) ) {
			errno = 0;
			rval = truncate(path, length);
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
#endif // ! WIN32

	case CONDOR_fstat:
	{
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		struct stat stat_buf;
		rval = fstat(fd, &stat_buf);
		terrno = (condor_errno_t)errno;
		char line[1024];
		if(rval == 0) {
			if(stat_string(line, &stat_buf) < 0) {
				rval = -1;
				terrno = (condor_errno_t)errno;
			}
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(line, 1024) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;	
	}
	case CONDOR_stat:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		struct stat stat_buf;
		rval = stat(path, &stat_buf);
		terrno = (condor_errno_t)errno;
		char line[1024];
		if(rval == 0) {
			if(stat_string(line, &stat_buf) < 0) {
				rval = -1;
				terrno = (condor_errno_t)errno;
			}
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(line, 1024) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_access:
	{
		int flags = -1;

		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(flags) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  flags = %d\n"", flags );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = access(path, flags);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_chmod:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(mode) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  mode = %d\n"", mode );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = chmod(path, mode);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_utime:
	{
		time_t actime = -1, modtime = -1;

		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(actime) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  actime = %ld\n"", actime );
		result = ( syscall_sock->code(modtime) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  modtime = %ld\n"", modtime );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		struct utimbuf ut;
		ut.actime = actime;
		ut.modtime = modtime;
		
		errno = 0;
		rval = utime(path, &ut);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	default:
	{
		dprintf(D_ALWAYS, ""ERROR: unknown syscall %d received\n"", condor_sysnum );
		return 0;
		
	}

	}	/* End of switch on system call number */

	return -1;

}	/* End of do_REMOTE_syscall() procedure */
","do_REMOTE_syscall()
{
	int condor_sysnum;
	int	rval = -1, result = -1, fd = -1, mode = -1, uid = -1, gid = -1;
	int length = -1;
	condor_errno_t terrno;
	char *path = NULL, *buffer = NULL;
	void *buf = NULL;

	syscall_sock->decode();

	dprintf(D_SYSCALLS, ""About to decode condor_sysnum\n"");

	rval = syscall_sock->code(condor_sysnum);
	if (!rval) {
		MyString err_msg;
		err_msg = ""Can no longer talk to condor_starter <"";
		err_msg += syscall_sock->peer_ip_str();
		err_msg += ':';
		err_msg += syscall_sock->peer_port();
		err_msg += '>';

		thisRemoteResource->closeClaimSock();

            /* It is possible that we are failing to read the
            syscall number because the starter went away
            because we *asked* it to go away. Don't be shocked
            and surprised if the startd/starter actually did
            what we asked when we deactivated the claim */
       if ( thisRemoteResource->wasClaimDeactivated() ) {
           return 0;
       }

		if( Shadow->supportsReconnect() ) {
			dprintf( D_ALWAYS, ""%s\n"", err_msg.Value() );

			const char* txt = ""Socket between submit and execute hosts ""
				""closed unexpectedly"";
			Shadow->logDisconnectedEvent( txt ); 

			if (!Shadow->shouldAttemptReconnect(thisRemoteResource)) {
					dprintf(D_ALWAYS, ""This job cannot reconnect to starter, so job exiting\n"");
					Shadow->gracefulShutDown();
					EXCEPT( ""%s"", err_msg.Value() );
			}
			Shadow->reconnect();
			return 0;
		} else {
			EXCEPT( ""%s"", err_msg.Value() );
		}
	}

	dprintf(D_SYSCALLS,
		""Got request for syscall %s (%d)\n"",
		shadow_syscall_name(condor_sysnum), condor_sysnum);

	switch( condor_sysnum ) {

	case CONDOR_register_starter_info:
	{
		ClassAd ad;
		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_register_starter_info( &ad );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_register_job_info:
	{
		ClassAd ad;
		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_register_job_info( &ad );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_get_job_info:
	{
		ClassAd *ad = NULL;
		bool delete_ad;

		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_get_job_info(ad, delete_ad);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		} else {
			result = ( ad->put(*syscall_sock) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		if ( delete_ad ) {
			delete ad;
		}
		return 0;
	}


	case CONDOR_get_user_info:
	{
		ClassAd *ad = NULL;

		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_get_user_info(ad);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		} else {
			result = ( ad->put(*syscall_sock) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}


	case CONDOR_job_exit:
	{
		int status=0;
		int reason=0;
		ClassAd ad;

		result = ( syscall_sock->code(status) );
		ASSERT( result );
		result = ( syscall_sock->code(reason) );
		ASSERT( result );
		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_job_exit(status, reason, &ad);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return -1;
	}

	case CONDOR_job_termination:
	{
		ClassAd ad;
		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_job_termination( &ad );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_begin_execution:
	{
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_begin_execution();
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_open:
	  {
		open_flags_t flags;
		int   lastarg;

		result = ( syscall_sock->code(flags) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  flags = %d\n"", flags );
		result = ( syscall_sock->code(lastarg) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  lastarg = %d\n"", lastarg );
		path = NULL;
		result = ( syscall_sock->code(path) );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );


		bool access_ok;
		if ( flags & O_RDONLY ) {
			access_ok = read_access(path);
		} else {
			access_ok = write_access(path);
		}

		errno = 0;
		if ( access_ok ) {
			rval = safe_open_wrapper_follow( path , flags , lastarg);
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}

		free( (char *)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_close:
	  {
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = close( fd);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_read:
	  {
		size_t   len;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		buf = (void *)malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = read( fd , buf , len);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		if( rval >= 0 ) {
			result = ( syscall_sock->code_bytes_bool(buf, rval) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_write:
	  {
		size_t   len;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		buf = (void *)malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->code_bytes_bool(buf, len) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = write( fd , buf , len);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_lseek:
	case CONDOR_lseek64:
	case CONDOR_llseek:
	  {
		off_t   offset;
		int   whence;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(offset) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  offset = %ld\n"", (long)offset );
		result = ( syscall_sock->code(whence) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  whence = %d\n"", whence );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = lseek( fd , offset , whence);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_unlink:
	  {
		path = NULL;
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		if ( write_access(path) ) {
			errno = 0;
			rval = unlink( path);
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char *)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_rename:
	  {
		char *  from;
		char *  to;

		to = NULL;
		from = NULL;
		result = ( syscall_sock->code(from) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  from = %s\n"", from );
		result = ( syscall_sock->code(to) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  to = %s\n"", to );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		if ( write_access(from) && write_access(to) ) {
			errno = 0;
			rval = rename( from , to);
		} else {
			rval = -1;
			errno = EACCES;
		}

		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char *)to );
		free( (char *)from );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_register_mpi_master_info:
	{
		ClassAd ad;
		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_register_mpi_master_info( &ad );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_mkdir:
	  {
		path = NULL;
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(mode) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  mode = %d\n"", mode );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		if ( write_access(path) ) {
			errno = 0;
			rval = mkdir(path,mode);
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char *)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_rmdir:
	  {
		path = NULL;
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		if ( write_access(path) ) {
			errno = 0;
			rval = rmdir( path);
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_fsync:
	  {
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fs = %d\n"", fd );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = fsync(fd);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_get_file_info_new:
	  {
		char *  logical_name;
		char *  actual_url;
 
		actual_url = NULL;
		logical_name = NULL;
		ASSERT( syscall_sock->code(logical_name) );
		ASSERT( syscall_sock->end_of_message() );;
 
		errno = (condor_errno_t)0;
		rval = pseudo_get_file_info_new( logical_name , actual_url );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, (int)terrno );
 
		syscall_sock->encode();
		ASSERT( syscall_sock->code(rval) );
		if( rval < 0 ) {
			ASSERT( syscall_sock->code(terrno) );
		}
		if( rval >= 0 ) {
			ASSERT( syscall_sock->code(actual_url) );
		}
		free( (char *)actual_url );
		free( (char *)logical_name );
		ASSERT( syscall_sock->end_of_message() );;
		return 0;
	}

	case CONDOR_ulog:
	{
		ClassAd ad;

		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		rval = pseudo_ulog(&ad);
		dprintf( D_SYSCALLS, ""\trval = %d\n"", rval );


		return 0;
	}

	case CONDOR_get_job_attr:
	  {
		char *  attrname = 0;

		assert( syscall_sock->code(attrname) );
		assert( syscall_sock->end_of_message() );;

		errno = (condor_errno_t)0;
		MyString expr;
		if ( thisRemoteResource->allowRemoteReadAttributeAccess(attrname) ) {
			rval = pseudo_get_job_attr( attrname , expr);
			terrno = (condor_errno_t)errno;
		} else {
			rval = -1;
			terrno = (condor_errno_t)EACCES;
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, (int)terrno );

		syscall_sock->encode();
		assert( syscall_sock->code(rval) );
		if( rval < 0 ) {
			assert( syscall_sock->code(terrno) );
		}
		if( rval >= 0 ) {
			assert( syscall_sock->put(expr.Value()) );
		}
		free( (char *)attrname );
		assert( syscall_sock->end_of_message() );;
		return 0;
	}

	case CONDOR_set_job_attr:
	  {
		char *  attrname = 0;
		char *  expr = 0;

		assert( syscall_sock->code(expr) );
		assert( syscall_sock->code(attrname) );
		assert( syscall_sock->end_of_message() );;

		errno = (condor_errno_t)0;
		if ( thisRemoteResource->allowRemoteWriteAttributeAccess(attrname) ) {
			rval = pseudo_set_job_attr( attrname , expr , true );
			terrno = (condor_errno_t)errno;
		} else {
			rval = -1;
			terrno = (condor_errno_t)EACCES;
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, (int)terrno );

		syscall_sock->encode();
		assert( syscall_sock->code(rval) );
		if( rval < 0 ) {
			assert( syscall_sock->code(terrno) );
		}
		free( (char *)expr );
		free( (char *)attrname );
		assert( syscall_sock->end_of_message() );;
		return 0;
	}

	case CONDOR_constrain:
	  {
		char *  expr = 0;

		assert( syscall_sock->code(expr) );
		assert( syscall_sock->end_of_message() );;

		errno = (condor_errno_t)0;
		if ( thisRemoteResource->allowRemoteWriteAttributeAccess(ATTR_REQUIREMENTS) ) {
			rval = pseudo_constrain( expr);
			terrno = (condor_errno_t)errno;
		} else {
			rval = -1;
			terrno = (condor_errno_t)EACCES;
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, (int)terrno );

		syscall_sock->encode();
		assert( syscall_sock->code(rval) );
		if( rval < 0 ) {
			assert( syscall_sock->code(terrno) );
		}
		free( (char *)expr );
		assert( syscall_sock->end_of_message() );;
		return 0;
	}
	case CONDOR_get_sec_session_info:
	{
		MyString starter_reconnect_session_info;
		MyString starter_filetrans_session_info;
		MyString reconnect_session_id;
		MyString reconnect_session_info;
		MyString reconnect_session_key;
		MyString filetrans_session_id;
		MyString filetrans_session_info;
		MyString filetrans_session_key;
		bool socket_default_crypto = syscall_sock->get_encryption();
		if( !socket_default_crypto ) {
			syscall_sock->set_crypto_mode(true);
		}
		assert( syscall_sock->code(starter_reconnect_session_info) );
		assert( syscall_sock->code(starter_filetrans_session_info) );
		assert( syscall_sock->end_of_message() );

		errno = (condor_errno_t)0;
		rval = pseudo_get_sec_session_info(
			starter_reconnect_session_info.Value(),
			reconnect_session_id,
			reconnect_session_info,
			reconnect_session_key,
			starter_filetrans_session_info.Value(),
			filetrans_session_id,
			filetrans_session_info,
			filetrans_session_key );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, (int)terrno );

		syscall_sock->encode();
		assert( syscall_sock->code(rval) );
		if( rval < 0 ) {
			assert( syscall_sock->code(terrno) );
		}
		else {
			assert( syscall_sock->code(reconnect_session_id) );
			assert( syscall_sock->code(reconnect_session_info) );
			assert( syscall_sock->code(reconnect_session_key) );

			assert( syscall_sock->code(filetrans_session_id) );
			assert( syscall_sock->code(filetrans_session_info) );
			assert( syscall_sock->code(filetrans_session_key) );
		}

		assert( syscall_sock->end_of_message() );

		if( !socket_default_crypto ) {
			syscall_sock->set_crypto_mode( false );  // restore default
		}
		return 0;
	}
#ifdef WIN32
#else
	case CONDOR_pread:
	  {
		size_t len, offset;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		result = ( syscall_sock->code(offset) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  offset = %ld\n"", (long)offset );
		buf = (void *)malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pread( fd , buf , len, offset );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(buf, rval) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_pwrite:
	  {
		size_t   len, offset;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		result = ( syscall_sock->code(offset) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  offset = %ld\n"", (long)offset);
		buf = malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->code_bytes_bool(buf, len) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pwrite( fd , buf , len, offset);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_sread:
	  {
		size_t   len, offset, stride_length, stride_skip;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		result = ( syscall_sock->code(offset) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  offset = %ld\n"", (long)offset );
		result = ( syscall_sock->code(stride_length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  stride_length = %ld\n"", (long)stride_length);
		result = ( syscall_sock->code(stride_skip) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  stride_skip = %ld\n"", (long)stride_skip);
		buf = (void *)malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = EINVAL;
		rval = -1;
		unsigned int total = 0;
		buffer = (char*)buf;

		while(total < len && stride_length > 0) {
			if(len - total < stride_length) {
				stride_length = len - total;
			}
			rval = pread( fd, (void*)&buffer[total], stride_length, offset );
			if(rval >= 0) {
				total += rval;
				offset += stride_skip;
			}
			else {
				break;
			}
		}

		syscall_sock->encode();
		if( rval < 0 ) {
			result = ( syscall_sock->code(rval) );
			ASSERT( result );
			terrno = (condor_errno_t)errno;
			dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", total, terrno );
			result = ( syscall_sock->code(total) );
			ASSERT( result );
			dprintf( D_ALWAYS, ""buffer: %s\n"", buffer);
			result = ( syscall_sock->code_bytes_bool(buf, total) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_swrite:
	  {
		size_t   len, offset, stride_length, stride_skip;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		result = ( syscall_sock->code(offset) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  offset = %ld\n"", (long)offset);
		result = ( syscall_sock->code(stride_length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  stride_length = %ld\n"", (long)stride_length);
		result = ( syscall_sock->code(stride_skip) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  stride_skip = %ld\n"", (long)stride_skip);
		buf = (void *)malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->code_bytes_bool(buf, len) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = EINVAL;
		rval = -1;
		unsigned int total = 0;
		buffer = (char*)buf;

		while(total < len && stride_length > 0) {
			if(len - total < stride_length) {
				stride_length = len - total;
			}
			rval = pwrite( fd, (void*)&buffer[total], stride_length, offset);
			if(rval >= 0) {
				total += rval;
				offset += stride_skip;
			}
			else {
				break;
			}
		}
		
		syscall_sock->encode();
		if( rval < 0 ) {
			terrno = (condor_errno_t)errno;
			dprintf( D_SYSCALLS, ""\trval = %d, errno = %d (%s)\n"", rval, terrno, strerror(errno));
			result = ( syscall_sock->code(rval) );
			ASSERT( result );
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			dprintf( D_SYSCALLS, ""\trval = %d, errno = %d (%s)\n"", total, terrno, strerror(errno));
			result = ( syscall_sock->code(total) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_rmall:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		if ( write_access(path) ) {
			rval = rmdir(path);
			
			if(rval == -1) {
				Directory dir(path);
				if(dir.Remove_Entire_Directory()) {
					rval = rmdir(path);
				}
			}
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char *)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
case CONDOR_getfile:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		fd = safe_open_wrapper_follow( path, O_RDONLY );
		if(fd >= 0) {
			struct stat info;
			stat(path, &info);
			length = info.st_size;
			buf = (void *)malloc( (unsigned)length );
			memset( buf, 0, (unsigned)length );

			errno = 0;
			rval = read( fd , buf , length);
		} else {
			rval = fd;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {	
			result = ( syscall_sock->code_bytes_bool(buf, rval) );
			ASSERT( result );
		}
		free( (char *)path );
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
case CONDOR_putfile:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf(D_SYSCALLS, ""  path: %s\n"", path);
		result = ( syscall_sock->code(mode) );
		ASSERT( result );
		dprintf(D_SYSCALLS, ""  mode: %d\n"", mode);
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf(D_SYSCALLS, ""  length: %d\n"", length);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		fd = safe_open_wrapper_follow(path, O_CREAT | O_WRONLY | O_TRUNC, mode);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		if( fd < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		int num = -1;
		if(fd >= 0) {
			syscall_sock->decode();
			buffer = (char*)malloc( (unsigned)length );
			memset( buffer, 0, (unsigned)length );
			result = ( syscall_sock->code_bytes_bool(buffer, length) );
			ASSERT( result );
			result = ( syscall_sock->end_of_message() );
			ASSERT( result );
			num = write(fd, buffer, length);
		}
		else {
			dprintf(D_SYSCALLS, ""Unable to put file %s\n"", path);
		}
		close(fd);
		
		syscall_sock->encode();
		result = ( syscall_sock->code(num) );
		ASSERT( result );
		if( num < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free((char*)path);
		free((char*)buffer);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
case CONDOR_getlongdir:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = -1;
		MyString msg, check;
		const char *next;
		Directory directory(path);
		struct stat stat_buf;
		char line[1024];
		
		while((next = directory.Next())) {
			dprintf(D_ALWAYS, ""next: %s\n"", next);
			msg.sprintf_cat(""%s\n"", next);
			check.sprintf(""%s%c%s"", path, DIR_DELIM_CHAR, next);
			rval = stat(check.Value(), &stat_buf);
			terrno = (condor_errno_t)errno;
			if(rval == -1) {
				break;
			}
			if(stat_string(line, &stat_buf) < 0) {
				rval = -1;
				break;
			}
			msg.sprintf_cat(""%s"", line);
		}
		terrno = (condor_errno_t)errno;
		if(msg.Length() > 0) {
			msg.sprintf_cat(""\n"");	// Needed to signify end of data
			rval = msg.Length();
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->put(msg.Value()) );
			ASSERT( result );
		}
		free((char*)path);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
case CONDOR_getdir:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = -1;
		MyString msg;
		const char *next;
		Directory directory(path);
 
                while((next = directory.Next())) {
                       msg.sprintf_cat(next);
                        msg.sprintf_cat(""\n"");
                }
                terrno = (condor_errno_t)errno;
		if(msg.Length() > 0) {
			msg.sprintf_cat(""\n"");	// Needed to signify end of data
			rval = msg.Length();
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->put(msg.Value()) );
			ASSERT( result );
		}
		free((char*)path);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_whoami:
	{
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  length = %d\n"", length );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		buffer = (char*)malloc( (unsigned)length );
		int size = 6;
		if(length < size) {
			rval = -1;
			terrno = (condor_errno_t) ENOSPC;
		}
		else {
			rval = sprintf(buffer, ""CONDOR"");
			terrno = (condor_errno_t) errno;
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval != size) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(buffer, rval));
			ASSERT( result );
		}
		free((char*)buffer);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_whoareyou:
	{
		char *host = NULL;

		result = ( syscall_sock->code(host) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  host = %s\n"", host );
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  length = %d\n"", length );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		buffer = (char*)malloc( (unsigned)length );
		int size = 7;
		if(length < size) {
			rval = -1;
			terrno = (condor_errno_t) ENOSPC;
		}
		else {
			rval = sprintf(buffer, ""UNKNOWN"");
			terrno = (condor_errno_t) errno;
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval != size) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(buffer, rval));
			ASSERT( result );
		}
		free((char*)buffer);
		free((char*)host);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_fstatfs:
	{
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
#if defined(Solaris)
		struct statvfs statfs_buf;
		rval = fstatvfs(fd, &statfs_buf);
#else
		struct statfs statfs_buf;
		rval = fstatfs(fd, &statfs_buf);
#endif
		terrno = (condor_errno_t)errno;
		char line[1024];
		if(rval == 0) {
			if(statfs_string(line, &statfs_buf) < 0) {
				rval = -1;
				terrno = (condor_errno_t)errno;
			}
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(line, 1024) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;	
	}
	case CONDOR_fchown:
	{
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(uid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  uid = %d\n"", uid );
		result = ( syscall_sock->code(gid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  gid = %d\n"", gid );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = fchown(fd, uid, gid);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_fchmod:
	{
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(mode) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  mode = %d\n"", mode );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = fchmod(fd, (mode_t)mode);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_ftruncate:
	{
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  length = %d\n"", length );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = ftruncate(fd, length);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	
	
	
	
	
	
	case CONDOR_link:
	{
		char *newpath = NULL;

		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(newpath) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  newpath = %s\n"", newpath );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = link(path, newpath);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free((char*)path);
		free((char*)newpath);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_symlink:
	{
		char *newpath = NULL;

		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(newpath) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  newpath = %s\n"", newpath );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = symlink(path, newpath);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free((char*)path);
		free((char*)newpath);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_readlink:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  length = %d\n"", length );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		char *lbuffer = (char*)malloc(length);
		errno = 0;
		rval = readlink(path, lbuffer, length);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(lbuffer, rval));
			ASSERT( result );
		}
		free(lbuffer);
		free(path);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_lstat:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		struct stat stat_buf;
		rval = lstat(path, &stat_buf);
		terrno = (condor_errno_t)errno;
		char line[1024];
		if(rval == 0) {
			if(stat_string(line, &stat_buf) < 0) {
				rval = -1;
				terrno = (condor_errno_t)errno;
			}
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(line, 1024) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_statfs:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
#if defined(Solaris)
		struct statvfs statfs_buf;
		rval = statvfs(path, &statfs_buf);
#else
		struct statfs statfs_buf;
		rval = statfs(path, &statfs_buf);
#endif
		terrno = (condor_errno_t)errno;
		char line[1024];
		if(rval == 0) {
			if(statfs_string(line, &statfs_buf) < 0) {
				rval = -1;
				terrno = (condor_errno_t)errno;
			}
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(line, 1024) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_chown:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(uid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  uid = %d\n"", uid );
		result = ( syscall_sock->code(gid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  gid = %d\n"", gid );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = chown(path, uid, gid);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
	
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_lchown:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(uid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  uid = %d\n"", uid );
		result = ( syscall_sock->code(gid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  gid = %d\n"", gid );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = lchown(path, uid, gid);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
	
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_truncate:
	{
		
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  length = %d\n"", length );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		if ( write_access(path) ) {
			errno = 0;
			rval = truncate(path, length);
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
#endif // ! WIN32

	case CONDOR_fstat:
	{
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		struct stat stat_buf;
		rval = fstat(fd, &stat_buf);
		terrno = (condor_errno_t)errno;
		char line[1024];
		if(rval == 0) {
			if(stat_string(line, &stat_buf) < 0) {
				rval = -1;
				terrno = (condor_errno_t)errno;
			}
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(line, 1024) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;	
	}
	case CONDOR_stat:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		struct stat stat_buf;
		rval = stat(path, &stat_buf);
		terrno = (condor_errno_t)errno;
		char line[1024];
		if(rval == 0) {
			if(stat_string(line, &stat_buf) < 0) {
				rval = -1;
				terrno = (condor_errno_t)errno;
			}
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(line, 1024) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_access:
	{
		int flags = -1;

		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(flags) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  flags = %d\n"", flags );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = access(path, flags);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_chmod:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(mode) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  mode = %d\n"", mode );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = chmod(path, mode);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_utime:
	{
		time_t actime = -1, modtime = -1;

		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(actime) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  actime = %ld\n"", actime );
		result = ( syscall_sock->code(modtime) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  modtime = %ld\n"", modtime );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		struct utimbuf ut;
		ut.actime = actime;
		ut.modtime = modtime;
		
		errno = 0;
		rval = utime(path, &ut);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	default:
	{
		dprintf(D_ALWAYS, ""ERROR: unknown syscall %d received\n"", condor_sysnum );
		return 0;
		
	}

	}	/* End of switch on system call number */

	return -1;

}	/* End of do_REMOTE_syscall() procedure */
",CPP,"                       msg.sprintf_cat(""%s"", next);
","                       msg.sprintf_cat(next);
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -1397,7 +1397,7 @@ case CONDOR_getdir:
 
                // Get directory's contents
                while((next = directory.Next())) {
-                       msg.sprintf_cat(next);
+                       msg.sprintf_cat(""%s"", next);
                        msg.sprintf_cat(""\n"");
                }
                terrno = (condor_errno_t)errno;",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_shadow.V6.1/NTreceivers.cpp;h=63ea532b7b1839f26b1a897d4f50ad8be158fa89;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_shadow.V6.1/NTreceivers.cpp;h=305963804650e59ddecab59aafcc80f33e66b3b8,1,"do_REMOTE_syscall()
{
	int condor_sysnum;
	int	rval = -1, result = -1, fd = -1, mode = -1, uid = -1, gid = -1;
	int length = -1;
	condor_errno_t terrno;
	char *path = NULL, *buffer = NULL;
	void *buf = NULL;

	syscall_sock->decode();

	dprintf(D_SYSCALLS, ""About to decode condor_sysnum\n"");

	rval = syscall_sock->code(condor_sysnum);
	if (!rval) {
		MyString err_msg;
		err_msg = ""Can no longer talk to condor_starter <"";
		err_msg += syscall_sock->peer_ip_str();
		err_msg += ':';
		err_msg += syscall_sock->peer_port();
		err_msg += '>';

            // the socket is closed, there's no way to recover
            // from this.  so, we have to cancel the socket
            // handler in daemoncore and delete the relisock.
		thisRemoteResource->closeClaimSock();

            /* It is possible that we are failing to read the
            syscall number because the starter went away
            because we *asked* it to go away. Don't be shocked
            and surprised if the startd/starter actually did
            what we asked when we deactivated the claim */
       if ( thisRemoteResource->wasClaimDeactivated() ) {
           return 0;
       }

		if( Shadow->supportsReconnect() ) {
				// instead of having to EXCEPT, we can now try to
				// reconnect.  happy day! :)
			dprintf( D_ALWAYS, ""%s\n"", err_msg.Value() );

			const char* txt = ""Socket between submit and execute hosts ""
				""closed unexpectedly"";
			Shadow->logDisconnectedEvent( txt ); 

			if (!Shadow->shouldAttemptReconnect(thisRemoteResource)) {
					dprintf(D_ALWAYS, ""This job cannot reconnect to starter, so job exiting\n"");
					Shadow->gracefulShutDown();
					EXCEPT( ""%s"", err_msg.Value() );
			}
				// tell the shadow to start trying to reconnect
			Shadow->reconnect();
				// we need to return 0 so that our caller doesn't
				// think the job exited and doesn't do anything to the
				// syscall socket.
			return 0;
		} else {
				// The remote starter doesn't support it, so give up
				// like we always used to.
			EXCEPT( ""%s"", err_msg.Value() );
		}
	}

	dprintf(D_SYSCALLS,
		""Got request for syscall %s (%d)\n"",
		shadow_syscall_name(condor_sysnum), condor_sysnum);

	switch( condor_sysnum ) {

	case CONDOR_register_starter_info:
	{
		ClassAd ad;
		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_register_starter_info( &ad );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_register_job_info:
	{
		ClassAd ad;
		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_register_job_info( &ad );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_get_job_info:
	{
		ClassAd *ad = NULL;
		bool delete_ad;

		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_get_job_info(ad, delete_ad);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		} else {
			result = ( ad->put(*syscall_sock) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		if ( delete_ad ) {
			delete ad;
		}
		return 0;
	}


	case CONDOR_get_user_info:
	{
		ClassAd *ad = NULL;

		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_get_user_info(ad);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		} else {
			result = ( ad->put(*syscall_sock) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}


	case CONDOR_job_exit:
	{
		int status=0;
		int reason=0;
		ClassAd ad;

		result = ( syscall_sock->code(status) );
		ASSERT( result );
		result = ( syscall_sock->code(reason) );
		ASSERT( result );
		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_job_exit(status, reason, &ad);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return -1;
	}

	case CONDOR_job_termination:
	{
		ClassAd ad;
		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_job_termination( &ad );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_begin_execution:
	{
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_begin_execution();
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_open:
	  {
		open_flags_t flags;
		int   lastarg;

		result = ( syscall_sock->code(flags) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  flags = %d\n"", flags );
		result = ( syscall_sock->code(lastarg) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  lastarg = %d\n"", lastarg );
		path = NULL;
		result = ( syscall_sock->code(path) );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );


		bool access_ok;
		if ( flags & O_RDONLY ) {
			access_ok = read_access(path);
		} else {
			access_ok = write_access(path);
		}

		errno = 0;
		if ( access_ok ) {
			rval = safe_open_wrapper_follow( path , flags , lastarg);
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}

		free( (char *)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_close:
	  {
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = close( fd);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_read:
	  {
		size_t   len;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		buf = (void *)malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = read( fd , buf , len);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		if( rval >= 0 ) {
			result = ( syscall_sock->code_bytes_bool(buf, rval) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_write:
	  {
		size_t   len;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		buf = (void *)malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->code_bytes_bool(buf, len) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = write( fd , buf , len);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_lseek:
	case CONDOR_lseek64:
	case CONDOR_llseek:
	  {
		off_t   offset;
		int   whence;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(offset) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  offset = %ld\n"", (long)offset );
		result = ( syscall_sock->code(whence) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  whence = %d\n"", whence );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = lseek( fd , offset , whence);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_unlink:
	  {
		path = NULL;
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		if ( write_access(path) ) {
			errno = 0;
			rval = unlink( path);
		} else {
			// no permission to write to this file
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char *)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_rename:
	  {
		char *  from;
		char *  to;

		to = NULL;
		from = NULL;
		result = ( syscall_sock->code(from) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  from = %s\n"", from );
		result = ( syscall_sock->code(to) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  to = %s\n"", to );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		if ( write_access(from) && write_access(to) ) {
			errno = 0;
			rval = rename( from , to);
		} else {
			rval = -1;
			errno = EACCES;
		}

		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char *)to );
		free( (char *)from );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_register_mpi_master_info:
	{
		ClassAd ad;
		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pseudo_register_mpi_master_info( &ad );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_mkdir:
	  {
		path = NULL;
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(mode) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  mode = %d\n"", mode );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		if ( write_access(path) ) {
			errno = 0;
			rval = mkdir(path,mode);
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char *)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_rmdir:
	  {
		path = NULL;
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		if ( write_access(path) ) {
			errno = 0;
			rval = rmdir( path);
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_fsync:
	  {
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fs = %d\n"", fd );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = fsync(fd);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}

	case CONDOR_get_file_info_new:
	  {
		char *  logical_name;
		char *  actual_url;
 
		actual_url = NULL;
		logical_name = NULL;
		ASSERT( syscall_sock->code(logical_name) );
		ASSERT( syscall_sock->end_of_message() );;
 
		errno = (condor_errno_t)0;
		rval = pseudo_get_file_info_new( logical_name , actual_url );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, (int)terrno );
 
		syscall_sock->encode();
		ASSERT( syscall_sock->code(rval) );
		if( rval < 0 ) {
			ASSERT( syscall_sock->code(terrno) );
		}
		if( rval >= 0 ) {
			ASSERT( syscall_sock->code(actual_url) );
		}
		free( (char *)actual_url );
		free( (char *)logical_name );
		ASSERT( syscall_sock->end_of_message() );;
		return 0;
	}

	case CONDOR_ulog:
	{
		ClassAd ad;

		result = ( ad.initFromStream(*syscall_sock) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		rval = pseudo_ulog(&ad);
		dprintf( D_SYSCALLS, ""\trval = %d\n"", rval );

		//NOTE: caller does not expect a response.

		return 0;
	}

	case CONDOR_get_job_attr:
	  {
		char *  attrname = 0;

		assert( syscall_sock->code(attrname) );
		assert( syscall_sock->end_of_message() );;

		errno = (condor_errno_t)0;
		MyString expr;
		if ( thisRemoteResource->allowRemoteReadAttributeAccess(attrname) ) {
			rval = pseudo_get_job_attr( attrname , expr);
			terrno = (condor_errno_t)errno;
		} else {
			rval = -1;
			terrno = (condor_errno_t)EACCES;
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, (int)terrno );

		syscall_sock->encode();
		assert( syscall_sock->code(rval) );
		if( rval < 0 ) {
			assert( syscall_sock->code(terrno) );
		}
		if( rval >= 0 ) {
			assert( syscall_sock->put(expr.Value()) );
		}
		free( (char *)attrname );
		assert( syscall_sock->end_of_message() );;
		return 0;
	}

	case CONDOR_set_job_attr:
	  {
		char *  attrname = 0;
		char *  expr = 0;

		assert( syscall_sock->code(expr) );
		assert( syscall_sock->code(attrname) );
		assert( syscall_sock->end_of_message() );;

		errno = (condor_errno_t)0;
		if ( thisRemoteResource->allowRemoteWriteAttributeAccess(attrname) ) {
			rval = pseudo_set_job_attr( attrname , expr , true );
			terrno = (condor_errno_t)errno;
		} else {
			rval = -1;
			terrno = (condor_errno_t)EACCES;
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, (int)terrno );

		syscall_sock->encode();
		assert( syscall_sock->code(rval) );
		if( rval < 0 ) {
			assert( syscall_sock->code(terrno) );
		}
		free( (char *)expr );
		free( (char *)attrname );
		assert( syscall_sock->end_of_message() );;
		return 0;
	}

	case CONDOR_constrain:
	  {
		char *  expr = 0;

		assert( syscall_sock->code(expr) );
		assert( syscall_sock->end_of_message() );;

		errno = (condor_errno_t)0;
		if ( thisRemoteResource->allowRemoteWriteAttributeAccess(ATTR_REQUIREMENTS) ) {
			rval = pseudo_constrain( expr);
			terrno = (condor_errno_t)errno;
		} else {
			rval = -1;
			terrno = (condor_errno_t)EACCES;
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, (int)terrno );

		syscall_sock->encode();
		assert( syscall_sock->code(rval) );
		if( rval < 0 ) {
			assert( syscall_sock->code(terrno) );
		}
		free( (char *)expr );
		assert( syscall_sock->end_of_message() );;
		return 0;
	}
	case CONDOR_get_sec_session_info:
	{
		MyString starter_reconnect_session_info;
		MyString starter_filetrans_session_info;
		MyString reconnect_session_id;
		MyString reconnect_session_info;
		MyString reconnect_session_key;
		MyString filetrans_session_id;
		MyString filetrans_session_info;
		MyString filetrans_session_key;
		bool socket_default_crypto = syscall_sock->get_encryption();
		if( !socket_default_crypto ) {
				// always encrypt; we are exchanging super secret session keys
			syscall_sock->set_crypto_mode(true);
		}
		assert( syscall_sock->code(starter_reconnect_session_info) );
		assert( syscall_sock->code(starter_filetrans_session_info) );
		assert( syscall_sock->end_of_message() );

		errno = (condor_errno_t)0;
		rval = pseudo_get_sec_session_info(
			starter_reconnect_session_info.Value(),
			reconnect_session_id,
			reconnect_session_info,
			reconnect_session_key,
			starter_filetrans_session_info.Value(),
			filetrans_session_id,
			filetrans_session_info,
			filetrans_session_key );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, (int)terrno );

		syscall_sock->encode();
		assert( syscall_sock->code(rval) );
		if( rval < 0 ) {
			assert( syscall_sock->code(terrno) );
		}
		else {
			assert( syscall_sock->code(reconnect_session_id) );
			assert( syscall_sock->code(reconnect_session_info) );
			assert( syscall_sock->code(reconnect_session_key) );

			assert( syscall_sock->code(filetrans_session_id) );
			assert( syscall_sock->code(filetrans_session_info) );
			assert( syscall_sock->code(filetrans_session_key) );
		}

		assert( syscall_sock->end_of_message() );

		if( !socket_default_crypto ) {
			syscall_sock->set_crypto_mode( false );  // restore default
		}
		return 0;
	}
#ifdef WIN32
#else
	case CONDOR_pread:
	  {
		size_t len, offset;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		result = ( syscall_sock->code(offset) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  offset = %ld\n"", (long)offset );
		buf = (void *)malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pread( fd , buf , len, offset );
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(buf, rval) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_pwrite:
	  {
		size_t   len, offset;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		result = ( syscall_sock->code(offset) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  offset = %ld\n"", (long)offset);
		buf = malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->code_bytes_bool(buf, len) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = pwrite( fd , buf , len, offset);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_sread:
	  {
		size_t   len, offset, stride_length, stride_skip;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		result = ( syscall_sock->code(offset) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  offset = %ld\n"", (long)offset );
		result = ( syscall_sock->code(stride_length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  stride_length = %ld\n"", (long)stride_length);
		result = ( syscall_sock->code(stride_skip) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  stride_skip = %ld\n"", (long)stride_skip);
		buf = (void *)malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = EINVAL;
		rval = -1;
		unsigned int total = 0;
		buffer = (char*)buf;

		while(total < len && stride_length > 0) {
			// For last read (make sure we only read total of 'len' bytes)
			if(len - total < stride_length) {
				stride_length = len - total;
			}
			rval = pread( fd, (void*)&buffer[total], stride_length, offset );
			if(rval >= 0) {
				total += rval;
				offset += stride_skip;
			}
			else {
				break;
			}
		}

		syscall_sock->encode();
		if( rval < 0 ) {
			result = ( syscall_sock->code(rval) );
			ASSERT( result );
			terrno = (condor_errno_t)errno;
			dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", total, terrno );
			result = ( syscall_sock->code(total) );
			ASSERT( result );
			dprintf( D_ALWAYS, ""buffer: %s\n"", buffer);
			result = ( syscall_sock->code_bytes_bool(buf, total) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_swrite:
	  {
		size_t   len, offset, stride_length, stride_skip;

		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(len) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  len = %ld\n"", (long)len );
		result = ( syscall_sock->code(offset) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  offset = %ld\n"", (long)offset);
		result = ( syscall_sock->code(stride_length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  stride_length = %ld\n"", (long)stride_length);
		result = ( syscall_sock->code(stride_skip) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  stride_skip = %ld\n"", (long)stride_skip);
		buf = (void *)malloc( (unsigned)len );
		memset( buf, 0, (unsigned)len );
		result = ( syscall_sock->code_bytes_bool(buf, len) );
		ASSERT( result );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = EINVAL;
		rval = -1;
		unsigned int total = 0;
		buffer = (char*)buf;

		while(total < len && stride_length > 0) {
			// For last write (make sure we only write 'len' bytes)
			if(len - total < stride_length) {
				stride_length = len - total;
			}
			rval = pwrite( fd, (void*)&buffer[total], stride_length, offset);
			if(rval >= 0) {
				total += rval;
				offset += stride_skip;
			}
			else {
				break;
			}
		}
		
		syscall_sock->encode();
		if( rval < 0 ) {
			terrno = (condor_errno_t)errno;
			dprintf( D_SYSCALLS, ""\trval = %d, errno = %d (%s)\n"", rval, terrno, strerror(errno));
			result = ( syscall_sock->code(rval) );
			ASSERT( result );
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			dprintf( D_SYSCALLS, ""\trval = %d, errno = %d (%s)\n"", total, terrno, strerror(errno));
			result = ( syscall_sock->code(total) );
			ASSERT( result );
		}
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_rmall:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		if ( write_access(path) ) {
			// Try to rmdir 
			rval = rmdir(path);
			
			// If rmdir failed, try again after removing everthing in directory
			if(rval == -1) {
				Directory dir(path);
				if(dir.Remove_Entire_Directory()) {
					rval = rmdir(path);
				}
			}
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char *)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
case CONDOR_getfile:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		fd = safe_open_wrapper_follow( path, O_RDONLY );
		if(fd >= 0) {
			struct stat info;
			stat(path, &info);
			length = info.st_size;
			buf = (void *)malloc( (unsigned)length );
			memset( buf, 0, (unsigned)length );

			errno = 0;
			rval = read( fd , buf , length);
		} else {
			rval = fd;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {	
			result = ( syscall_sock->code_bytes_bool(buf, rval) );
			ASSERT( result );
		}
		free( (char *)path );
		free( buf );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
case CONDOR_putfile:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf(D_SYSCALLS, ""  path: %s\n"", path);
		result = ( syscall_sock->code(mode) );
		ASSERT( result );
		dprintf(D_SYSCALLS, ""  mode: %d\n"", mode);
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf(D_SYSCALLS, ""  length: %d\n"", length);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		fd = safe_open_wrapper_follow(path, O_CREAT | O_WRONLY | O_TRUNC, mode);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		// Need to send reply after file creation
		syscall_sock->encode();
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		if( fd < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		int num = -1;
		if(fd >= 0) {
			syscall_sock->decode();
			buffer = (char*)malloc( (unsigned)length );
			memset( buffer, 0, (unsigned)length );
			result = ( syscall_sock->code_bytes_bool(buffer, length) );
			ASSERT( result );
			result = ( syscall_sock->end_of_message() );
			ASSERT( result );
			num = write(fd, buffer, length);
		}
		else {
			dprintf(D_SYSCALLS, ""Unable to put file %s\n"", path);
		}
		close(fd);
		
		syscall_sock->encode();
		result = ( syscall_sock->code(num) );
		ASSERT( result );
		if( num < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free((char*)path);
		free((char*)buffer);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
case CONDOR_getlongdir:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = -1;
		MyString msg, check;
		const char *next;
		Directory directory(path);
		struct stat stat_buf;
		char line[1024];
		
		// Get directory's contents
		while((next = directory.Next())) {
			dprintf(D_ALWAYS, ""next: %s\n"", next);
			msg.sprintf_cat(""%s\n"", next);
			check.sprintf(""%s%c%s"", path, DIR_DELIM_CHAR, next);
			rval = stat(check.Value(), &stat_buf);
			terrno = (condor_errno_t)errno;
			if(rval == -1) {
				break;
			}
			if(stat_string(line, &stat_buf) < 0) {
				rval = -1;
				break;
			}
			msg.sprintf_cat(""%s"", line);
		}
		terrno = (condor_errno_t)errno;
		if(msg.Length() > 0) {
			msg.sprintf_cat(""\n"");	// Needed to signify end of data
			rval = msg.Length();
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->put(msg.Value()) );
			ASSERT( result );
		}
		free((char*)path);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
case CONDOR_getdir:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		rval = -1;
		MyString msg;
		const char *next;
		Directory directory(path);
 
                // Get directory's contents
                while((next = directory.Next())) {
//flaw_line_below:
                       msg.sprintf_cat(next);
//fix_flaw_line_below:
//                       msg.sprintf_cat(""%s"", next);
                        msg.sprintf_cat(""\n"");
                }
                terrno = (condor_errno_t)errno;
		if(msg.Length() > 0) {
			msg.sprintf_cat(""\n"");	// Needed to signify end of data
			rval = msg.Length();
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->put(msg.Value()) );
			ASSERT( result );
		}
		free((char*)path);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
// Return something more useful?
	case CONDOR_whoami:
	{
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  length = %d\n"", length );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		buffer = (char*)malloc( (unsigned)length );
		int size = 6;
		if(length < size) {
			rval = -1;
			terrno = (condor_errno_t) ENOSPC;
		}
		else {
			rval = sprintf(buffer, ""CONDOR"");
			terrno = (condor_errno_t) errno;
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval != size) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(buffer, rval));
			ASSERT( result );
		}
		free((char*)buffer);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
// Return something more useful?
	case CONDOR_whoareyou:
	{
		char *host = NULL;

		result = ( syscall_sock->code(host) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  host = %s\n"", host );
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  length = %d\n"", length );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		buffer = (char*)malloc( (unsigned)length );
		int size = 7;
		if(length < size) {
			rval = -1;
			terrno = (condor_errno_t) ENOSPC;
		}
		else {
			rval = sprintf(buffer, ""UNKNOWN"");
			terrno = (condor_errno_t) errno;
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval != size) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(buffer, rval));
			ASSERT( result );
		}
		free((char*)buffer);
		free((char*)host);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_fstatfs:
	{
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
#if defined(Solaris)
		struct statvfs statfs_buf;
		rval = fstatvfs(fd, &statfs_buf);
#else
		struct statfs statfs_buf;
		rval = fstatfs(fd, &statfs_buf);
#endif
		terrno = (condor_errno_t)errno;
		char line[1024];
		if(rval == 0) {
			if(statfs_string(line, &statfs_buf) < 0) {
				rval = -1;
				terrno = (condor_errno_t)errno;
			}
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(line, 1024) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;	
	}
	case CONDOR_fchown:
	{
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(uid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  uid = %d\n"", uid );
		result = ( syscall_sock->code(gid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  gid = %d\n"", gid );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = fchown(fd, uid, gid);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_fchmod:
	{
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(mode) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  mode = %d\n"", mode );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = fchmod(fd, (mode_t)mode);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_ftruncate:
	{
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  length = %d\n"", length );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = ftruncate(fd, length);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	
	
	
	
	
	
	case CONDOR_link:
	{
		char *newpath = NULL;

		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(newpath) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  newpath = %s\n"", newpath );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = link(path, newpath);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free((char*)path);
		free((char*)newpath);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_symlink:
	{
		char *newpath = NULL;

		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(newpath) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  newpath = %s\n"", newpath );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = symlink(path, newpath);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free((char*)path);
		free((char*)newpath);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_readlink:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  length = %d\n"", length );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		char *lbuffer = (char*)malloc(length);
		errno = 0;
		rval = readlink(path, lbuffer, length);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(lbuffer, rval));
			ASSERT( result );
		}
		free(lbuffer);
		free(path);
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_lstat:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		struct stat stat_buf;
		rval = lstat(path, &stat_buf);
		terrno = (condor_errno_t)errno;
		char line[1024];
		if(rval == 0) {
			if(stat_string(line, &stat_buf) < 0) {
				rval = -1;
				terrno = (condor_errno_t)errno;
			}
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(line, 1024) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_statfs:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
#if defined(Solaris)
		struct statvfs statfs_buf;
		rval = statvfs(path, &statfs_buf);
#else
		struct statfs statfs_buf;
		rval = statfs(path, &statfs_buf);
#endif
		terrno = (condor_errno_t)errno;
		char line[1024];
		if(rval == 0) {
			if(statfs_string(line, &statfs_buf) < 0) {
				rval = -1;
				terrno = (condor_errno_t)errno;
			}
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(line, 1024) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_chown:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(uid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  uid = %d\n"", uid );
		result = ( syscall_sock->code(gid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  gid = %d\n"", gid );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = chown(path, uid, gid);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
	
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_lchown:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(uid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  uid = %d\n"", uid );
		result = ( syscall_sock->code(gid) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  gid = %d\n"", gid );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = lchown(path, uid, gid);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
	
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_truncate:
	{
		
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(length) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  length = %d\n"", length );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		// fd needs to be open for writing!
		if ( write_access(path) ) {
			errno = 0;
			rval = truncate(path, length);
		} else {
			rval = -1;
			errno = EACCES;
		}
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
#endif // ! WIN32

	case CONDOR_fstat:
	{
		result = ( syscall_sock->code(fd) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  fd = %d\n"", fd );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		struct stat stat_buf;
		rval = fstat(fd, &stat_buf);
		terrno = (condor_errno_t)errno;
		char line[1024];
		if(rval == 0) {
			if(stat_string(line, &stat_buf) < 0) {
				rval = -1;
				terrno = (condor_errno_t)errno;
			}
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(line, 1024) );
			ASSERT( result );
		}
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;	
	}
	case CONDOR_stat:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );

		errno = 0;
		struct stat stat_buf;
		rval = stat(path, &stat_buf);
		terrno = (condor_errno_t)errno;
		char line[1024];
		if(rval == 0) {
			if(stat_string(line, &stat_buf) < 0) {
				rval = -1;
				terrno = (condor_errno_t)errno;
			}
		}
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if( rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		else {
			result = ( syscall_sock->code_bytes_bool(line, 1024) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_access:
	{
		int flags = -1;

		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(flags) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  flags = %d\n"", flags );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = access(path, flags);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0 ) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_chmod:
	{
		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(mode) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  mode = %d\n"", mode );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		errno = 0;
		rval = chmod(path, mode);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );
		
		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	case CONDOR_utime:
	{
		time_t actime = -1, modtime = -1;

		result = ( syscall_sock->code(path) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  path = %s\n"", path );
		result = ( syscall_sock->code(actime) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  actime = %ld\n"", actime );
		result = ( syscall_sock->code(modtime) );
		ASSERT( result );
		dprintf( D_SYSCALLS, ""  modtime = %ld\n"", modtime );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		
		struct utimbuf ut;
		ut.actime = actime;
		ut.modtime = modtime;
		
		errno = 0;
		rval = utime(path, &ut);
		terrno = (condor_errno_t)errno;
		dprintf( D_SYSCALLS, ""\trval = %d, errno = %d\n"", rval, terrno );

		syscall_sock->encode();
		result = ( syscall_sock->code(rval) );
		ASSERT( result );
		if(rval < 0) {
			result = ( syscall_sock->code( terrno ) );
			ASSERT( result );
		}
		free( (char*)path );
		result = ( syscall_sock->end_of_message() );
		ASSERT( result );
		return 0;
	}
	default:
	{
		dprintf(D_ALWAYS, ""ERROR: unknown syscall %d received\n"", condor_sysnum );
			// If we return failure, the shadow will shutdown, so
			// pretend everything's cool...
		return 0;
		
	}

	}	/* End of switch on system call number */

	return -1;

}	/* End of do_REMOTE_syscall() procedure */
"
813,178549,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,1,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,1,,,"BaseShadow::log_except(const char *msg)
{
	ShadowExceptionEvent event;
        bool exception_already_logged = false;
 
        if(!msg) msg = """";
       sprintf(event.message, ""%s"", msg);
 
        if ( BaseShadow::myshadow_ptr ) {
                BaseShadow *shadow = BaseShadow::myshadow_ptr;

		event.recvd_bytes = shadow->bytesSent();
		event.sent_bytes = shadow->bytesReceived();
		exception_already_logged = shadow->exception_already_logged;

		if (shadow->began_execution) {
			event.began_execution = TRUE;
		}

	} else {
		event.recvd_bytes = 0.0;
		event.sent_bytes = 0.0;
	}

	if (!exception_already_logged && !uLog.writeEventNoFsync (&event,NULL))
	{
		::dprintf (D_ALWAYS, ""Unable to log ULOG_SHADOW_EXCEPTION event\n"");
	}
}
","BaseShadow::log_except(const char *msg)
{
	ShadowExceptionEvent event;
        bool exception_already_logged = false;
 
        if(!msg) msg = """";
       sprintf(event.message, msg);
 
        if ( BaseShadow::myshadow_ptr ) {
                BaseShadow *shadow = BaseShadow::myshadow_ptr;

		event.recvd_bytes = shadow->bytesSent();
		event.sent_bytes = shadow->bytesReceived();
		exception_already_logged = shadow->exception_already_logged;

		if (shadow->began_execution) {
			event.began_execution = TRUE;
		}

	} else {
		event.recvd_bytes = 0.0;
		event.sent_bytes = 0.0;
	}

	if (!exception_already_logged && !uLog.writeEventNoFsync (&event,NULL))
	{
		::dprintf (D_ALWAYS, ""Unable to log ULOG_SHADOW_EXCEPTION event\n"");
	}
}
",CPP,"       sprintf(event.message, ""%s"", msg);
","       sprintf(event.message, msg);
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -1141,7 +1141,7 @@ BaseShadow::log_except(const char *msg)
        bool exception_already_logged = false;
 
        if(!msg) msg = """";
-       sprintf(event.message, msg);
+       sprintf(event.message, ""%s"", msg);
 
        if ( BaseShadow::myshadow_ptr ) {
                BaseShadow *shadow = BaseShadow::myshadow_ptr;",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_shadow.V6.1/baseshadow.cpp;h=3e464b314b627f87546663a9c78455a81d23f376;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_shadow.V6.1/baseshadow.cpp;h=e469636f48bb0d66131a00efe8d2b1600e796843,1,"BaseShadow::log_except(const char *msg)
{
	// log shadow exception event
	ShadowExceptionEvent event;
        bool exception_already_logged = false;
 
        if(!msg) msg = """";
//flaw_line_below:
       sprintf(event.message, msg);
//fix_flaw_line_below:
//       sprintf(event.message, ""%s"", msg);
 
        if ( BaseShadow::myshadow_ptr ) {
                BaseShadow *shadow = BaseShadow::myshadow_ptr;

		// we want to log the events from the perspective of the
		// user job, so if the shadow *sent* the bytes, then that
		// means the user job *received* the bytes
		event.recvd_bytes = shadow->bytesSent();
		event.sent_bytes = shadow->bytesReceived();
		exception_already_logged = shadow->exception_already_logged;

		if (shadow->began_execution) {
			event.began_execution = TRUE;
		}

	} else {
		event.recvd_bytes = 0.0;
		event.sent_bytes = 0.0;
	}

	if (!exception_already_logged && !uLog.writeEventNoFsync (&event,NULL))
	{
		::dprintf (D_ALWAYS, ""Unable to log ULOG_SHADOW_EXCEPTION event\n"");
	}
}
"
814,178550,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,1,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,1,,,"pseudo_ulog( ClassAd *ad )
{
	ULogEvent *event = instantiateEvent(ad);
	int result = 0;
	char const *critical_error = NULL;
	MyString CriticalErrorBuf;
	bool event_already_logged = false;
	bool put_job_on_hold = false;
	char const *hold_reason = NULL;
	char *hold_reason_buf = NULL;
	int hold_reason_code = 0;
	int hold_reason_sub_code = 0;

	if(!event) {
		MyString add_str;
		ad->sPrint(add_str);
		dprintf(
		  D_ALWAYS,
		  ""invalid event ClassAd in pseudo_ulog: %s\n"",
		  add_str.Value());
		return -1;
	}

	if(ad->LookupInteger(ATTR_HOLD_REASON_CODE,hold_reason_code)) {
		put_job_on_hold = true;
		ad->LookupInteger(ATTR_HOLD_REASON_SUBCODE,hold_reason_sub_code);
		ad->LookupString(ATTR_HOLD_REASON,&hold_reason_buf);
		if(hold_reason_buf) {
			hold_reason = hold_reason_buf;
		}
	}

	if( event->eventNumber == ULOG_REMOTE_ERROR ) {
		RemoteErrorEvent *err = (RemoteErrorEvent *)event;

		if(!err->getExecuteHost() || !*err->getExecuteHost()) {
			char *execute_host = NULL;
			thisRemoteResource->getMachineName(execute_host);
			err->setExecuteHost(execute_host);
			delete[] execute_host;
		}

		if(err->isCriticalError()) {
			CriticalErrorBuf.sprintf(
			  ""Error from %s: %s"",
			  err->getExecuteHost(),
			  err->getErrorText());

			critical_error = CriticalErrorBuf.Value();
			if(!hold_reason) {
				hold_reason = critical_error;
			}

			BaseShadow::log_except(critical_error);
			event_already_logged = true;
		}
	}

	if( !event_already_logged && !Shadow->uLog.writeEvent( event, ad ) ) {
		MyString add_str;
		ad->sPrint(add_str);
		dprintf(
		  D_ALWAYS,
		  ""unable to log event in pseudo_ulog: %s\n"",
		  add_str.Value());
		result = -1;
	}

	if(put_job_on_hold) {
		hold_reason = critical_error;
		if(!hold_reason) {
			hold_reason = ""Job put on hold by remote host."";
		}
		Shadow->holdJobAndExit(hold_reason,hold_reason_code,hold_reason_sub_code);
	}

	if( critical_error ) {
                Shadow->exception_already_logged = true;
 
               EXCEPT(""%s"", critical_error);
        }
 
        delete event;
	return result;
}
","pseudo_ulog( ClassAd *ad )
{
	ULogEvent *event = instantiateEvent(ad);
	int result = 0;
	char const *critical_error = NULL;
	MyString CriticalErrorBuf;
	bool event_already_logged = false;
	bool put_job_on_hold = false;
	char const *hold_reason = NULL;
	char *hold_reason_buf = NULL;
	int hold_reason_code = 0;
	int hold_reason_sub_code = 0;

	if(!event) {
		MyString add_str;
		ad->sPrint(add_str);
		dprintf(
		  D_ALWAYS,
		  ""invalid event ClassAd in pseudo_ulog: %s\n"",
		  add_str.Value());
		return -1;
	}

	if(ad->LookupInteger(ATTR_HOLD_REASON_CODE,hold_reason_code)) {
		put_job_on_hold = true;
		ad->LookupInteger(ATTR_HOLD_REASON_SUBCODE,hold_reason_sub_code);
		ad->LookupString(ATTR_HOLD_REASON,&hold_reason_buf);
		if(hold_reason_buf) {
			hold_reason = hold_reason_buf;
		}
	}

	if( event->eventNumber == ULOG_REMOTE_ERROR ) {
		RemoteErrorEvent *err = (RemoteErrorEvent *)event;

		if(!err->getExecuteHost() || !*err->getExecuteHost()) {
			char *execute_host = NULL;
			thisRemoteResource->getMachineName(execute_host);
			err->setExecuteHost(execute_host);
			delete[] execute_host;
		}

		if(err->isCriticalError()) {
			CriticalErrorBuf.sprintf(
			  ""Error from %s: %s"",
			  err->getExecuteHost(),
			  err->getErrorText());

			critical_error = CriticalErrorBuf.Value();
			if(!hold_reason) {
				hold_reason = critical_error;
			}

			BaseShadow::log_except(critical_error);
			event_already_logged = true;
		}
	}

	if( !event_already_logged && !Shadow->uLog.writeEvent( event, ad ) ) {
		MyString add_str;
		ad->sPrint(add_str);
		dprintf(
		  D_ALWAYS,
		  ""unable to log event in pseudo_ulog: %s\n"",
		  add_str.Value());
		result = -1;
	}

	if(put_job_on_hold) {
		hold_reason = critical_error;
		if(!hold_reason) {
			hold_reason = ""Job put on hold by remote host."";
		}
		Shadow->holdJobAndExit(hold_reason,hold_reason_code,hold_reason_sub_code);
	}

	if( critical_error ) {
                Shadow->exception_already_logged = true;
 
               EXCEPT(critical_error);
        }
 
        delete event;
	return result;
}
",CPP,"               EXCEPT(""%s"", critical_error);
","               EXCEPT(critical_error);
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -717,7 +717,7 @@ pseudo_ulog( ClassAd *ad )
                Shadow->exception_already_logged = true;
 
                //lame: at the time of this writing, EXCEPT does not want const:
-               EXCEPT(critical_error);
+               EXCEPT(""%s"", critical_error);
        }
 
        delete event;",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_shadow.V6.1/pseudo_ops.cpp;h=5e0fe65ce91bac1e81bc039b6b2c569c1937cfa1;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_shadow.V6.1/pseudo_ops.cpp;h=3aa6a80f34b8e349b724dac62a504a844d50dba9,1,"pseudo_ulog( ClassAd *ad )
{
	ULogEvent *event = instantiateEvent(ad);
	int result = 0;
	char const *critical_error = NULL;
	MyString CriticalErrorBuf;
	bool event_already_logged = false;
	bool put_job_on_hold = false;
	char const *hold_reason = NULL;
	char *hold_reason_buf = NULL;
	int hold_reason_code = 0;
	int hold_reason_sub_code = 0;

	if(!event) {
		MyString add_str;
		ad->sPrint(add_str);
		dprintf(
		  D_ALWAYS,
		  ""invalid event ClassAd in pseudo_ulog: %s\n"",
		  add_str.Value());
		return -1;
	}

	if(ad->LookupInteger(ATTR_HOLD_REASON_CODE,hold_reason_code)) {
		put_job_on_hold = true;
		ad->LookupInteger(ATTR_HOLD_REASON_SUBCODE,hold_reason_sub_code);
		ad->LookupString(ATTR_HOLD_REASON,&hold_reason_buf);
		if(hold_reason_buf) {
			hold_reason = hold_reason_buf;
		}
	}

	if( event->eventNumber == ULOG_REMOTE_ERROR ) {
		RemoteErrorEvent *err = (RemoteErrorEvent *)event;

		if(!err->getExecuteHost() || !*err->getExecuteHost()) {
			//Insert remote host information.
			char *execute_host = NULL;
			thisRemoteResource->getMachineName(execute_host);
			err->setExecuteHost(execute_host);
			delete[] execute_host;
		}

		if(err->isCriticalError()) {
			CriticalErrorBuf.sprintf(
			  ""Error from %s: %s"",
			  err->getExecuteHost(),
			  err->getErrorText());

			critical_error = CriticalErrorBuf.Value();
			if(!hold_reason) {
				hold_reason = critical_error;
			}

			//Temporary: the following causes critical remote errors
			//to be logged as ShadowExceptionEvents, rather than
			//RemoteErrorEvents.  The result is ugly, but guaranteed to
			//be compatible with other user-log reading tools.
			BaseShadow::log_except(critical_error);
			event_already_logged = true;
		}
	}

	if( !event_already_logged && !Shadow->uLog.writeEvent( event, ad ) ) {
		MyString add_str;
		ad->sPrint(add_str);
		dprintf(
		  D_ALWAYS,
		  ""unable to log event in pseudo_ulog: %s\n"",
		  add_str.Value());
		result = -1;
	}

	if(put_job_on_hold) {
		hold_reason = critical_error;
		if(!hold_reason) {
			hold_reason = ""Job put on hold by remote host."";
		}
		Shadow->holdJobAndExit(hold_reason,hold_reason_code,hold_reason_sub_code);
		//should never get here, because holdJobAndExit() exits.
	}

	if( critical_error ) {
		//Suppress ugly ""Shadow exception!""
                Shadow->exception_already_logged = true;
 
                //lame: at the time of this writing, EXCEPT does not want const:
//flaw_line_below:
               EXCEPT(critical_error);
//fix_flaw_line_below:
//               EXCEPT(""%s"", critical_error);
        }
 
        delete event;
	return result;
}
"
815,178551,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,1,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,1,,,"CStarter::removeDeferredJobs() {
	bool ret = true;
	
	if ( this->deferral_tid == -1 ) {
		return ( ret );
	}
	
	m_deferred_job_update = true;
	
	if ( daemonCore->Cancel_Timer( this->deferral_tid ) >= 0 ) {
		dprintf( D_FULLDEBUG, ""Cancelled time deferred execution for ""
							  ""Job %d.%d\n"", 
					this->jic->jobCluster(),
					this->jic->jobProc() );
		this->deferral_tid = -1;

	} else {
		MyString error = ""Failed to cancel deferred execution timer for Job "";
                error += this->jic->jobCluster();
                error += ""."";
                error += this->jic->jobProc();
               EXCEPT( ""%s"", error.Value() );
                ret = false;
        }
        return ( ret );
}
","CStarter::removeDeferredJobs() {
	bool ret = true;
	
	if ( this->deferral_tid == -1 ) {
		return ( ret );
	}
	
	m_deferred_job_update = true;
	
	if ( daemonCore->Cancel_Timer( this->deferral_tid ) >= 0 ) {
		dprintf( D_FULLDEBUG, ""Cancelled time deferred execution for ""
							  ""Job %d.%d\n"", 
					this->jic->jobCluster(),
					this->jic->jobProc() );
		this->deferral_tid = -1;

	} else {
		MyString error = ""Failed to cancel deferred execution timer for Job "";
                error += this->jic->jobCluster();
                error += ""."";
                error += this->jic->jobProc();
               EXCEPT( error.Value() );
                ret = false;
        }
        return ( ret );
}
",CPP,"               EXCEPT( ""%s"", error.Value() );
","               EXCEPT( error.Value() );
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -1800,7 +1800,7 @@ CStarter::removeDeferredJobs() {
                error += this->jic->jobCluster();
                error += ""."";
                error += this->jic->jobProc();
-               EXCEPT( error.Value() );
+               EXCEPT( ""%s"", error.Value() );
                ret = false;
        }
        return ( ret );",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_starter.V6.1/baseStarter.cpp;h=9262ff618c416ab9d3b1e1549072af74d1190600;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_starter.V6.1/baseStarter.cpp;h=341b86b79f488f22040562cad357581609eec791,1,"CStarter::removeDeferredJobs() {
	bool ret = true;
	
	if ( this->deferral_tid == -1 ) {
		return ( ret );
	}
	
	m_deferred_job_update = true;
	
		//
		// Attempt to cancel the the timer
		//
	if ( daemonCore->Cancel_Timer( this->deferral_tid ) >= 0 ) {
		dprintf( D_FULLDEBUG, ""Cancelled time deferred execution for ""
							  ""Job %d.%d\n"", 
					this->jic->jobCluster(),
					this->jic->jobProc() );
		this->deferral_tid = -1;

	} else {
			//
			// We failed to cancel the timer!
			// This is bad because our job might execute when it shouldn't have
			//
		MyString error = ""Failed to cancel deferred execution timer for Job "";
                error += this->jic->jobCluster();
                error += ""."";
                error += this->jic->jobProc();
//flaw_line_below:
               EXCEPT( error.Value() );
//fix_flaw_line_below:
//               EXCEPT( ""%s"", error.Value() );
                ret = false;
        }
        return ( ret );
}
"
816,178552,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,1,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,1,,,"sysapi_translate_arch( const char *machine, const char *)
{
	char tmp[64];
	char *tmparch;

#if defined(AIX)
	/* AIX machines have a ton of different models encoded into the uname
		structure, so go to some other function to decode and group the
		architecture together */
	struct utsname buf;

	if( uname(&buf) < 0 ) {
		return NULL;
	}

	return( get_aix_arch( &buf ) );

#elif defined(HPUX)

	return( get_hpux_arch( ) );
#else

	if( !strcmp(machine, ""alpha"") ) {
		sprintf( tmp, ""ALPHA"" );
	}
	else if( !strcmp(machine, ""i86pc"") ) {
		sprintf( tmp, ""INTEL"" );
	}
	else if( !strcmp(machine, ""i686"") ) {
		sprintf( tmp, ""INTEL"" );
	}
	else if( !strcmp(machine, ""i586"") ) {
		sprintf( tmp, ""INTEL"" );
	}
	else if( !strcmp(machine, ""i486"") ) {
		sprintf( tmp, ""INTEL"" );
	}
	else if( !strcmp(machine, ""i386"") ) { //LDAP entry
#if defined(Darwin)
		/* Mac OS X often claims to be i386 in uname, even if the
		 * hardware is x86_64 and the OS can run 64-bit binaries.
		 * We'll base our architecture name on the default build
		 * target for gcc. In 10.5 and earlier, that's i386.
		 * On 10.6, it's x86_64.
		 * The value we're querying is the kernel version.
		 * 10.6 kernels have a version that starts with ""10.""
		 * Older versions have a lower first number.
		 */
		int ret;
		char val[32];
		size_t len = sizeof(val);

		/* assume x86 */
		sprintf( tmp, ""INTEL"" );
		ret = sysctlbyname(""kern.osrelease"", &val, &len, NULL, 0);
		if (ret == 0 && strncmp(val, ""10."", 3) == 0) {
			/* but we could be proven wrong */
			sprintf( tmp, ""X86_64"" );
		}
#else
		sprintf( tmp, ""INTEL"" );
#endif
	}
	else if( !strcmp(machine, ""ia64"") ) {
		sprintf( tmp, ""IA64"" );
	}
	else if( !strcmp(machine, ""x86_64"") ) {
		sprintf( tmp, ""X86_64"" );
	}
	else if( !strcmp(machine, ""amd64"") ) {
		sprintf( tmp, ""X86_64"" );
	}
	else if( !strcmp(machine, ""sun4u"") ) {
		sprintf( tmp, ""SUN4u"" );
	}
	else if( !strcmp(machine, ""sun4m"") ) {
		sprintf( tmp, ""SUN4x"" );
	}
	else if( !strcmp(machine, ""sun4c"") ) {
		sprintf( tmp, ""SUN4x"" );
	}
	else if( !strcmp(machine, ""sparc"") ) { //LDAP entry
		sprintf( tmp, ""SUN4x"" );
	}
	else if( !strcmp(machine, ""Power Macintosh"") ) { //LDAP entry
		sprintf( tmp, ""PPC"" );
	}
	else if( !strcmp(machine, ""ppc"") ) {
		sprintf( tmp, ""PPC"" );
	}
	else if( !strcmp(machine, ""ppc32"") ) {
		sprintf( tmp, ""PPC"" );
	}
	else if( !strcmp(machine, ""ppc64"") ) {
		sprintf( tmp, ""PPC64"" );
        }
        else {
               sprintf( tmp, ""%s"", machine );
        }
 
        tmparch = strdup( tmp );
	if( !tmparch ) {
		EXCEPT( ""Out of memory!"" );
	}
	return( tmparch );
#endif /* if HPUX else */
}
","sysapi_translate_arch( const char *machine, const char *)
{
	char tmp[64];
	char *tmparch;

#if defined(AIX)
	/* AIX machines have a ton of different models encoded into the uname
		structure, so go to some other function to decode and group the
		architecture together */
	struct utsname buf;

	if( uname(&buf) < 0 ) {
		return NULL;
	}

	return( get_aix_arch( &buf ) );

#elif defined(HPUX)

	return( get_hpux_arch( ) );
#else

	if( !strcmp(machine, ""alpha"") ) {
		sprintf( tmp, ""ALPHA"" );
	}
	else if( !strcmp(machine, ""i86pc"") ) {
		sprintf( tmp, ""INTEL"" );
	}
	else if( !strcmp(machine, ""i686"") ) {
		sprintf( tmp, ""INTEL"" );
	}
	else if( !strcmp(machine, ""i586"") ) {
		sprintf( tmp, ""INTEL"" );
	}
	else if( !strcmp(machine, ""i486"") ) {
		sprintf( tmp, ""INTEL"" );
	}
	else if( !strcmp(machine, ""i386"") ) { //LDAP entry
#if defined(Darwin)
		/* Mac OS X often claims to be i386 in uname, even if the
		 * hardware is x86_64 and the OS can run 64-bit binaries.
		 * We'll base our architecture name on the default build
		 * target for gcc. In 10.5 and earlier, that's i386.
		 * On 10.6, it's x86_64.
		 * The value we're querying is the kernel version.
		 * 10.6 kernels have a version that starts with ""10.""
		 * Older versions have a lower first number.
		 */
		int ret;
		char val[32];
		size_t len = sizeof(val);

		/* assume x86 */
		sprintf( tmp, ""INTEL"" );
		ret = sysctlbyname(""kern.osrelease"", &val, &len, NULL, 0);
		if (ret == 0 && strncmp(val, ""10."", 3) == 0) {
			/* but we could be proven wrong */
			sprintf( tmp, ""X86_64"" );
		}
#else
		sprintf( tmp, ""INTEL"" );
#endif
	}
	else if( !strcmp(machine, ""ia64"") ) {
		sprintf( tmp, ""IA64"" );
	}
	else if( !strcmp(machine, ""x86_64"") ) {
		sprintf( tmp, ""X86_64"" );
	}
	else if( !strcmp(machine, ""amd64"") ) {
		sprintf( tmp, ""X86_64"" );
	}
	else if( !strcmp(machine, ""sun4u"") ) {
		sprintf( tmp, ""SUN4u"" );
	}
	else if( !strcmp(machine, ""sun4m"") ) {
		sprintf( tmp, ""SUN4x"" );
	}
	else if( !strcmp(machine, ""sun4c"") ) {
		sprintf( tmp, ""SUN4x"" );
	}
	else if( !strcmp(machine, ""sparc"") ) { //LDAP entry
		sprintf( tmp, ""SUN4x"" );
	}
	else if( !strcmp(machine, ""Power Macintosh"") ) { //LDAP entry
		sprintf( tmp, ""PPC"" );
	}
	else if( !strcmp(machine, ""ppc"") ) {
		sprintf( tmp, ""PPC"" );
	}
	else if( !strcmp(machine, ""ppc32"") ) {
		sprintf( tmp, ""PPC"" );
	}
	else if( !strcmp(machine, ""ppc64"") ) {
		sprintf( tmp, ""PPC64"" );
        }
        else {
               sprintf( tmp, machine );
        }
 
        tmparch = strdup( tmp );
	if( !tmparch ) {
		EXCEPT( ""Out of memory!"" );
	}
	return( tmparch );
#endif /* if HPUX else */
}
",CPP,"               sprintf( tmp, ""%s"", machine );
","               sprintf( tmp, machine );
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -299,7 +299,7 @@ sysapi_translate_arch( const char *machine, const char *)
        }
        else {
                        // Unknown, just use what uname gave:
-               sprintf( tmp, machine );
+               sprintf( tmp, ""%s"", machine );
        }
 
        tmparch = strdup( tmp );",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_sysapi/arch.cpp;h=169e27e35f183c789d146ae53fe5bfe3bc799d21;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_sysapi/arch.cpp;h=832f845760d3221cb8c1bbbe95f7c7e57d580860,1,"sysapi_translate_arch( const char *machine, const char *)
{
	char tmp[64];
	char *tmparch;

#if defined(AIX)
	/* AIX machines have a ton of different models encoded into the uname
		structure, so go to some other function to decode and group the
		architecture together */
	struct utsname buf;

	if( uname(&buf) < 0 ) {
		return NULL;
	}

	return( get_aix_arch( &buf ) );

#elif defined(HPUX)

	return( get_hpux_arch( ) );
#else

		// Get ARCH
		//mikeu: I modified this to also accept values from Globus' LDAP server
	if( !strcmp(machine, ""alpha"") ) {
		sprintf( tmp, ""ALPHA"" );
	}
	else if( !strcmp(machine, ""i86pc"") ) {
		sprintf( tmp, ""INTEL"" );
	}
	else if( !strcmp(machine, ""i686"") ) {
		sprintf( tmp, ""INTEL"" );
	}
	else if( !strcmp(machine, ""i586"") ) {
		sprintf( tmp, ""INTEL"" );
	}
	else if( !strcmp(machine, ""i486"") ) {
		sprintf( tmp, ""INTEL"" );
	}
	else if( !strcmp(machine, ""i386"") ) { //LDAP entry
#if defined(Darwin)
		/* Mac OS X often claims to be i386 in uname, even if the
		 * hardware is x86_64 and the OS can run 64-bit binaries.
		 * We'll base our architecture name on the default build
		 * target for gcc. In 10.5 and earlier, that's i386.
		 * On 10.6, it's x86_64.
		 * The value we're querying is the kernel version.
		 * 10.6 kernels have a version that starts with ""10.""
		 * Older versions have a lower first number.
		 */
		int ret;
		char val[32];
		size_t len = sizeof(val);

		/* assume x86 */
		sprintf( tmp, ""INTEL"" );
		ret = sysctlbyname(""kern.osrelease"", &val, &len, NULL, 0);
		if (ret == 0 && strncmp(val, ""10."", 3) == 0) {
			/* but we could be proven wrong */
			sprintf( tmp, ""X86_64"" );
		}
#else
		sprintf( tmp, ""INTEL"" );
#endif
	}
	else if( !strcmp(machine, ""ia64"") ) {
		sprintf( tmp, ""IA64"" );
	}
	else if( !strcmp(machine, ""x86_64"") ) {
		sprintf( tmp, ""X86_64"" );
	}
	//
	// FreeBSD 64-bit reports themselves as ""amd64""
	// Andy - 01/25/2008
	//
	else if( !strcmp(machine, ""amd64"") ) {
		sprintf( tmp, ""X86_64"" );
	}
	else if( !strcmp(machine, ""sun4u"") ) {
		sprintf( tmp, ""SUN4u"" );
	}
	else if( !strcmp(machine, ""sun4m"") ) {
		sprintf( tmp, ""SUN4x"" );
	}
	else if( !strcmp(machine, ""sun4c"") ) {
		sprintf( tmp, ""SUN4x"" );
	}
	else if( !strcmp(machine, ""sparc"") ) { //LDAP entry
		sprintf( tmp, ""SUN4x"" );
	}
	else if( !strcmp(machine, ""Power Macintosh"") ) { //LDAP entry
		sprintf( tmp, ""PPC"" );
	}
	else if( !strcmp(machine, ""ppc"") ) {
		sprintf( tmp, ""PPC"" );
	}
	else if( !strcmp(machine, ""ppc32"") ) {
		sprintf( tmp, ""PPC"" );
	}
	else if( !strcmp(machine, ""ppc64"") ) {
		sprintf( tmp, ""PPC64"" );
        }
        else {
                        // Unknown, just use what uname gave:
//flaw_line_below:
               sprintf( tmp, machine );
//fix_flaw_line_below:
//               sprintf( tmp, ""%s"", machine );
        }
 
        tmparch = strdup( tmp );
	if( !tmparch ) {
		EXCEPT( ""Out of memory!"" );
	}
	return( tmparch );
#endif /* if HPUX else */
}
"
817,178553,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,4,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,4,,,"produce_output()
{
	char	*str;
	FILE	*mailer;
	MyString subject,szTmp;
	subject.sprintf(""condor_preen results %s: %d old file%s found"", 
		my_full_hostname(), BadFiles->number(), 
		(BadFiles->number() > 1)?""s"":"""");

	if( MailFlag ) {
		if( (mailer=email_open(PreenAdmin, subject.Value())) == NULL ) {
			EXCEPT( ""Can't do email_open(\""%s\"", \""%s\"")\n"",PreenAdmin,subject.Value());
		}
	} else {
		mailer = stdout;
        }
 
        szTmp.sprintf(""The condor_preen process has found the following stale condor files on <%s>:\n\n"",  get_local_hostname().Value());
       dprintf(D_ALWAYS, ""%s"", szTmp.Value()); 
                
        if( MailFlag ) {
                fprintf( mailer, ""\n"" );
               fprintf( mailer, ""%s"", szTmp.Value());
        }
 
        for( BadFiles->rewind(); (str = BadFiles->next()); ) {
                szTmp.sprintf(""  %s\n"", str);
               dprintf(D_ALWAYS, ""%s"", szTmp.Value() );
               fprintf( mailer, ""%s"", szTmp.Value() );
        }
 
        if( MailFlag ) {
		const char *explanation = ""\n\nWhat is condor_preen?\n\n""
""The condor_preen tool examines the directories belonging to Condor, and\n""
""removes extraneous files and directories which may be left over from Condor\n""
""processes which terminated abnormally either due to internal errors or a\n""
""system crash.  The directories checked are the LOG, EXECUTE, and SPOOL\n""
""directories as defined in the Condor configuration files.  The condor_preen\n""
""tool is intended to be run as user root (or user condor) periodically as a\n""
""backup method to ensure reasonable file system cleanliness in the face of\n""
""errors. This is done automatically by default by the condor_master daemon.\n""
""It may also be explicitly invoked on an as needed basis.\n\n""
""See the Condor manual section on condor_preen for more details.\n"";

		fprintf( mailer, ""%s\n"", explanation );
		email_close( mailer );
	}
}
","produce_output()
{
	char	*str;
	FILE	*mailer;
	MyString subject,szTmp;
	subject.sprintf(""condor_preen results %s: %d old file%s found"", 
		my_full_hostname(), BadFiles->number(), 
		(BadFiles->number() > 1)?""s"":"""");

	if( MailFlag ) {
		if( (mailer=email_open(PreenAdmin, subject.Value())) == NULL ) {
			EXCEPT( ""Can't do email_open(\""%s\"", \""%s\"")\n"",PreenAdmin,subject.Value());
		}
	} else {
		mailer = stdout;
        }
 
        szTmp.sprintf(""The condor_preen process has found the following stale condor files on <%s>:\n\n"",  get_local_hostname().Value());
       dprintf(D_ALWAYS, szTmp.Value()); 
                
        if( MailFlag ) {
                fprintf( mailer, ""\n"" );
               fprintf( mailer, szTmp.Value());
        }
 
        for( BadFiles->rewind(); (str = BadFiles->next()); ) {
                szTmp.sprintf(""  %s\n"", str);
               dprintf(D_ALWAYS, szTmp.Value() );
               fprintf( mailer, szTmp.Value() );
        }
 
        if( MailFlag ) {
		const char *explanation = ""\n\nWhat is condor_preen?\n\n""
""The condor_preen tool examines the directories belonging to Condor, and\n""
""removes extraneous files and directories which may be left over from Condor\n""
""processes which terminated abnormally either due to internal errors or a\n""
""system crash.  The directories checked are the LOG, EXECUTE, and SPOOL\n""
""directories as defined in the Condor configuration files.  The condor_preen\n""
""tool is intended to be run as user root (or user condor) periodically as a\n""
""backup method to ensure reasonable file system cleanliness in the face of\n""
""errors. This is done automatically by default by the condor_master daemon.\n""
""It may also be explicitly invoked on an as needed basis.\n\n""
""See the Condor manual section on condor_preen for more details.\n"";

		fprintf( mailer, ""%s\n"", explanation );
		email_close( mailer );
	}
}
",CPP,"       dprintf(D_ALWAYS, ""%s"", szTmp.Value()); 
               fprintf( mailer, ""%s"", szTmp.Value());
               dprintf(D_ALWAYS, ""%s"", szTmp.Value() );
               fprintf( mailer, ""%s"", szTmp.Value() );
","       dprintf(D_ALWAYS, szTmp.Value()); 
               fprintf( mailer, szTmp.Value());
               dprintf(D_ALWAYS, szTmp.Value() );
               fprintf( mailer, szTmp.Value() );
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -221,17 +221,17 @@ produce_output()
        }
 
        szTmp.sprintf(""The condor_preen process has found the following stale condor files on <%s>:\n\n"",  get_local_hostname().Value());
-       dprintf(D_ALWAYS, szTmp.Value()); 
+       dprintf(D_ALWAYS, ""%s"", szTmp.Value()); 
                
        if( MailFlag ) {
                fprintf( mailer, ""\n"" );
-               fprintf( mailer, szTmp.Value());
+               fprintf( mailer, ""%s"", szTmp.Value());
        }
 
        for( BadFiles->rewind(); (str = BadFiles->next()); ) {
                szTmp.sprintf(""  %s\n"", str);
-               dprintf(D_ALWAYS, szTmp.Value() );
-               fprintf( mailer, szTmp.Value() );
+               dprintf(D_ALWAYS, ""%s"", szTmp.Value() );
+               fprintf( mailer, ""%s"", szTmp.Value() );
        }
 
        if( MailFlag ) {",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_tools/preen.cpp;h=60bfb7ff716f692a04d0d89c7e7889fb5f1fc7cf;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_tools/preen.cpp;h=4a64ddf23077fcd32656a8afac15d279e113f1d9,1,"produce_output()
{
	char	*str;
	FILE	*mailer;
	MyString subject,szTmp;
	subject.sprintf(""condor_preen results %s: %d old file%s found"", 
		my_full_hostname(), BadFiles->number(), 
		(BadFiles->number() > 1)?""s"":"""");

	if( MailFlag ) {
		if( (mailer=email_open(PreenAdmin, subject.Value())) == NULL ) {
			EXCEPT( ""Can't do email_open(\""%s\"", \""%s\"")\n"",PreenAdmin,subject.Value());
		}
	} else {
		mailer = stdout;
        }
 
        szTmp.sprintf(""The condor_preen process has found the following stale condor files on <%s>:\n\n"",  get_local_hostname().Value());
//flaw_line_below:
       dprintf(D_ALWAYS, szTmp.Value()); 
//fix_flaw_line_below:
//       dprintf(D_ALWAYS, ""%s"", szTmp.Value()); 
                
        if( MailFlag ) {
                fprintf( mailer, ""\n"" );
//flaw_line_below:
               fprintf( mailer, szTmp.Value());
//fix_flaw_line_below:
//               fprintf( mailer, ""%s"", szTmp.Value());
        }
 
        for( BadFiles->rewind(); (str = BadFiles->next()); ) {
                szTmp.sprintf(""  %s\n"", str);
//flaw_line_below:
               dprintf(D_ALWAYS, szTmp.Value() );
//flaw_line_below:
               fprintf( mailer, szTmp.Value() );
//fix_flaw_line_below:
//               dprintf(D_ALWAYS, ""%s"", szTmp.Value() );
//fix_flaw_line_below:
//               fprintf( mailer, ""%s"", szTmp.Value() );
        }
 
        if( MailFlag ) {
		const char *explanation = ""\n\nWhat is condor_preen?\n\n""
""The condor_preen tool examines the directories belonging to Condor, and\n""
""removes extraneous files and directories which may be left over from Condor\n""
""processes which terminated abnormally either due to internal errors or a\n""
""system crash.  The directories checked are the LOG, EXECUTE, and SPOOL\n""
""directories as defined in the Condor configuration files.  The condor_preen\n""
""tool is intended to be run as user root (or user condor) periodically as a\n""
""backup method to ensure reasonable file system cleanliness in the face of\n""
""errors. This is done automatically by default by the condor_master daemon.\n""
""It may also be explicitly invoked on an as needed basis.\n\n""
""See the Condor manual section on condor_preen for more details.\n"";

		fprintf( mailer, ""%s\n"", explanation );
		email_close( mailer );
	}
}
"
818,178554,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,1,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,1,,,"validate_entries( bool ignore_invalid_entry ) {
	HASHITER it = hash_iter_begin( ConfigTab, TABLESIZE );
	unsigned int invalid_entries = 0;
	MyString tmp;
	MyString output = ""The following configuration macros appear to contain default values that must be changed before Condor will run.  These macros are:\n"";
	while( ! hash_iter_done(it) ) {
		char * val = hash_iter_value(it);
		if( strstr(val, FORBIDDEN_CONFIG_VAL) ) {
			char * name = hash_iter_key(it);
			MyString filename;
			int line_number;
			param_get_location(name, filename, line_number);
			tmp.sprintf(""   %s (found on line %d of %s)\n"", name, line_number, filename.Value());
			output += tmp;
			invalid_entries++;
		}
		hash_iter_next(it);
	}
	hash_iter_delete(&it);
	if(invalid_entries > 0) {
                if(ignore_invalid_entry) {
                        dprintf(D_ALWAYS, ""%s"", output.Value());
                } else {
                       EXCEPT(""%s"", output.Value());
                }
        }
 }
","validate_entries( bool ignore_invalid_entry ) {
	HASHITER it = hash_iter_begin( ConfigTab, TABLESIZE );
	unsigned int invalid_entries = 0;
	MyString tmp;
	MyString output = ""The following configuration macros appear to contain default values that must be changed before Condor will run.  These macros are:\n"";
	while( ! hash_iter_done(it) ) {
		char * val = hash_iter_value(it);
		if( strstr(val, FORBIDDEN_CONFIG_VAL) ) {
			char * name = hash_iter_key(it);
			MyString filename;
			int line_number;
			param_get_location(name, filename, line_number);
			tmp.sprintf(""   %s (found on line %d of %s)\n"", name, line_number, filename.Value());
			output += tmp;
			invalid_entries++;
		}
		hash_iter_next(it);
	}
	hash_iter_delete(&it);
	if(invalid_entries > 0) {
                if(ignore_invalid_entry) {
                        dprintf(D_ALWAYS, ""%s"", output.Value());
                } else {
                       EXCEPT(output.Value());
                }
        }
 }
",CPP,"                       EXCEPT(""%s"", output.Value());
","                       EXCEPT(output.Value());
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -240,7 +240,7 @@ validate_entries( bool ignore_invalid_entry ) {
                if(ignore_invalid_entry) {
                        dprintf(D_ALWAYS, ""%s"", output.Value());
                } else {
-                       EXCEPT(output.Value());
+                       EXCEPT(""%s"", output.Value());
                }
        }
 }",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_utils/condor_config.cpp;h=e5e3468c84391c20cc777c3d84016f2857b69ac0;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_utils/condor_config.cpp;h=7a131d9631263817f8651c5ceb61446bcda95746,1,"validate_entries( bool ignore_invalid_entry ) {
	HASHITER it = hash_iter_begin( ConfigTab, TABLESIZE );
	unsigned int invalid_entries = 0;
	MyString tmp;
	MyString output = ""The following configuration macros appear to contain default values that must be changed before Condor will run.  These macros are:\n"";
	while( ! hash_iter_done(it) ) {
		char * val = hash_iter_value(it);
		if( strstr(val, FORBIDDEN_CONFIG_VAL) ) {
			char * name = hash_iter_key(it);
			MyString filename;
			int line_number;
			param_get_location(name, filename, line_number);
			tmp.sprintf(""   %s (found on line %d of %s)\n"", name, line_number, filename.Value());
			output += tmp;
			invalid_entries++;
		}
		hash_iter_next(it);
	}
	hash_iter_delete(&it);
	if(invalid_entries > 0) {
                if(ignore_invalid_entry) {
                        dprintf(D_ALWAYS, ""%s"", output.Value());
                } else {
//flaw_line_below:
                       EXCEPT(output.Value());
//fix_flaw_line_below:
//                       EXCEPT(""%s"", output.Value());
                }
        }
 }
"
819,178555,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,1,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,1,,,"CronTab::initRegexObject() {
	if ( ! CronTab::regex.isInitialized() ) {
		const char *errptr;
		int erroffset;
		MyString pattern( CRONTAB_PARAMETER_PATTERN ) ;
                if ( ! CronTab::regex.compile( pattern, &errptr, &erroffset )) {
                        MyString error = ""CronTab: Failed to compile Regex - "";
                        error += pattern;
                       EXCEPT( ""%s"", const_cast<char*>(error.Value()) );
                }
        }
 }
","CronTab::initRegexObject() {
	if ( ! CronTab::regex.isInitialized() ) {
		const char *errptr;
		int erroffset;
		MyString pattern( CRONTAB_PARAMETER_PATTERN ) ;
                if ( ! CronTab::regex.compile( pattern, &errptr, &erroffset )) {
                        MyString error = ""CronTab: Failed to compile Regex - "";
                        error += pattern;
                       EXCEPT( const_cast<char*>(error.Value()));
                }
        }
 }
",CPP,"                       EXCEPT( ""%s"", const_cast<char*>(error.Value()) );
","                       EXCEPT( const_cast<char*>(error.Value()));
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -373,7 +373,7 @@ CronTab::initRegexObject() {
                if ( ! CronTab::regex.compile( pattern, &errptr, &erroffset )) {
                        MyString error = ""CronTab: Failed to compile Regex - "";
                        error += pattern;
-                       EXCEPT( const_cast<char*>(error.Value()));
+                       EXCEPT( ""%s"", const_cast<char*>(error.Value()) );
                }
        }
 }",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_utils/condor_crontab.cpp;h=411dff14ed3c4ccdee11b3f31a46eef0bba925c6;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_utils/condor_crontab.cpp;h=42bd785e9a2eed5101423aacdc136ba2845bc259,1,"CronTab::initRegexObject() {
		//
		// There should be only one Regex object shared for all instances
		// of our object since the pattern that it needs to match is the same
		// So we only need to compile the pattern once
		//
	if ( ! CronTab::regex.isInitialized() ) {
		const char *errptr;
		int erroffset;
		MyString pattern( CRONTAB_PARAMETER_PATTERN ) ;
			//
			// It's a big problem if we can't compile the pattern, so
			// we'll want to dump out right now
			//
                if ( ! CronTab::regex.compile( pattern, &errptr, &erroffset )) {
                        MyString error = ""CronTab: Failed to compile Regex - "";
                        error += pattern;
//flaw_line_below:
                       EXCEPT( const_cast<char*>(error.Value()));
//fix_flaw_line_below:
//                       EXCEPT( ""%s"", const_cast<char*>(error.Value()) );
                }
        }
 }
"
820,178556,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,1,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,1,,,"email_close(FILE *mailer)
{
	char *temp;
	mode_t prev_umask;
	priv_state priv;
	char *customSig;

	if ( mailer == NULL ) {
		return;
	}

	/* Want the letter to come from ""condor"" if possible */
	priv = set_condor_priv();

        customSig = NULL;
        if ((customSig = param(""EMAIL_SIGNATURE"")) != NULL) {
                fprintf( mailer, ""\n\n"");
               fprintf( mailer, ""%s"", customSig);
                fprintf( mailer, ""\n"");
                free(customSig);
        } else {
		
		/* Put a signature on the bottom of the email */
		fprintf( mailer, ""\n\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n"" );
		fprintf( mailer, ""Questions about this message or Condor in general?\n"" );

			/* See if there's an address users should use for help */
		temp = param( ""CONDOR_SUPPORT_EMAIL"" );
		if( ! temp ) {
			temp = param( ""CONDOR_ADMIN"" );
		}
		if( temp ) {
			fprintf( mailer, ""Email address of the local Condor administrator: ""
					 ""%s\n"", temp );
			free( temp );
		}
		fprintf( mailer, ""The Official Condor Homepage is ""
				 ""http://www.cs.wisc.edu/condor\n"" );
	}

	fflush(mailer);
	/* there are some oddities with how pclose can close a file. In some
		arches, pclose will create temp files for locking and they need to
		be of the correct perms in order to be deleted. So the umask is
		set to something useable for the close operation. -pete 9/11/99
	*/
	prev_umask = umask(022);
	/* 
	** we fclose() on UNIX, pclose on win32 
	*/
#if defined(WIN32)
	if (EMAIL_FINAL_COMMAND == NULL) {
		my_pclose( mailer );
	} else {
		char *email_filename = NULL;
		/* Should this be a pclose??? -Erik 9/21/00 */ 
		fclose( mailer );
		dprintf(D_FULLDEBUG,""Sending email via system(%s)\n"",
			EMAIL_FINAL_COMMAND);
		system(EMAIL_FINAL_COMMAND);
		if ( (email_filename=strrchr(EMAIL_FINAL_COMMAND,'<')) ) {
			email_filename++;	/* go past the ""<"" */
			email_filename++;	/* go past the space after the < */
			if ( unlink(email_filename) == -1 ) {
				dprintf(D_ALWAYS,""email_close: cannot unlink temp file %s\n"",
					email_filename);
			}
		}
		free(EMAIL_FINAL_COMMAND);
		EMAIL_FINAL_COMMAND = NULL;
	}
#else
	(void)fclose( mailer );
#endif
	umask(prev_umask);

	/* Set priv state back */
	set_priv(priv);

}
","email_close(FILE *mailer)
{
	char *temp;
	mode_t prev_umask;
	priv_state priv;
	char *customSig;

	if ( mailer == NULL ) {
		return;
	}

	/* Want the letter to come from ""condor"" if possible */
	priv = set_condor_priv();

        customSig = NULL;
        if ((customSig = param(""EMAIL_SIGNATURE"")) != NULL) {
                fprintf( mailer, ""\n\n"");
               fprintf( mailer, customSig);
                fprintf( mailer, ""\n"");
                free(customSig);
        } else {
		
		/* Put a signature on the bottom of the email */
		fprintf( mailer, ""\n\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n"" );
		fprintf( mailer, ""Questions about this message or Condor in general?\n"" );

			/* See if there's an address users should use for help */
		temp = param( ""CONDOR_SUPPORT_EMAIL"" );
		if( ! temp ) {
			temp = param( ""CONDOR_ADMIN"" );
		}
		if( temp ) {
			fprintf( mailer, ""Email address of the local Condor administrator: ""
					 ""%s\n"", temp );
			free( temp );
		}
		fprintf( mailer, ""The Official Condor Homepage is ""
				 ""http://www.cs.wisc.edu/condor\n"" );
	}

	fflush(mailer);
	/* there are some oddities with how pclose can close a file. In some
		arches, pclose will create temp files for locking and they need to
		be of the correct perms in order to be deleted. So the umask is
		set to something useable for the close operation. -pete 9/11/99
	*/
	prev_umask = umask(022);
	/* 
	** we fclose() on UNIX, pclose on win32 
	*/
#if defined(WIN32)
	if (EMAIL_FINAL_COMMAND == NULL) {
		my_pclose( mailer );
	} else {
		char *email_filename = NULL;
		/* Should this be a pclose??? -Erik 9/21/00 */ 
		fclose( mailer );
		dprintf(D_FULLDEBUG,""Sending email via system(%s)\n"",
			EMAIL_FINAL_COMMAND);
		system(EMAIL_FINAL_COMMAND);
		if ( (email_filename=strrchr(EMAIL_FINAL_COMMAND,'<')) ) {
			email_filename++;	/* go past the ""<"" */
			email_filename++;	/* go past the space after the < */
			if ( unlink(email_filename) == -1 ) {
				dprintf(D_ALWAYS,""email_close: cannot unlink temp file %s\n"",
					email_filename);
			}
		}
		free(EMAIL_FINAL_COMMAND);
		EMAIL_FINAL_COMMAND = NULL;
	}
#else
	(void)fclose( mailer );
#endif
	umask(prev_umask);

	/* Set priv state back */
	set_priv(priv);

}
",CPP,"               fprintf( mailer, ""%s"", customSig);
","               fprintf( mailer, customSig);
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -433,7 +433,7 @@ email_close(FILE *mailer)
        customSig = NULL;
        if ((customSig = param(""EMAIL_SIGNATURE"")) != NULL) {
                fprintf( mailer, ""\n\n"");
-               fprintf( mailer, customSig);
+               fprintf( mailer, ""%s"", customSig);
                fprintf( mailer, ""\n"");
                free(customSig);
        } else {",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_utils/email.cpp;h=ab1d6adaf4b67c7c0d0e1086f2b1b8d2b9935bcd;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_utils/email.cpp;h=0ac185ffc26a7b0a8777457ced4e01db309569dd,1,"email_close(FILE *mailer)
{
	char *temp;
	mode_t prev_umask;
	priv_state priv;
	char *customSig;

	if ( mailer == NULL ) {
		return;
	}

	/* Want the letter to come from ""condor"" if possible */
	priv = set_condor_priv();

        customSig = NULL;
        if ((customSig = param(""EMAIL_SIGNATURE"")) != NULL) {
                fprintf( mailer, ""\n\n"");
//flaw_line_below:
               fprintf( mailer, customSig);
//fix_flaw_line_below:
//               fprintf( mailer, ""%s"", customSig);
                fprintf( mailer, ""\n"");
                free(customSig);
        } else {
		
		/* Put a signature on the bottom of the email */
		fprintf( mailer, ""\n\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n"" );
		fprintf( mailer, ""Questions about this message or Condor in general?\n"" );

			/* See if there's an address users should use for help */
		temp = param( ""CONDOR_SUPPORT_EMAIL"" );
		if( ! temp ) {
			temp = param( ""CONDOR_ADMIN"" );
		}
		if( temp ) {
			fprintf( mailer, ""Email address of the local Condor administrator: ""
					 ""%s\n"", temp );
			free( temp );
		}
		fprintf( mailer, ""The Official Condor Homepage is ""
				 ""http://www.cs.wisc.edu/condor\n"" );
	}

	fflush(mailer);
	/* there are some oddities with how pclose can close a file. In some
		arches, pclose will create temp files for locking and they need to
		be of the correct perms in order to be deleted. So the umask is
		set to something useable for the close operation. -pete 9/11/99
	*/
	prev_umask = umask(022);
	/* 
	** we fclose() on UNIX, pclose on win32 
	*/
#if defined(WIN32)
	if (EMAIL_FINAL_COMMAND == NULL) {
		my_pclose( mailer );
	} else {
		char *email_filename = NULL;
		/* Should this be a pclose??? -Erik 9/21/00 */ 
		fclose( mailer );
		dprintf(D_FULLDEBUG,""Sending email via system(%s)\n"",
			EMAIL_FINAL_COMMAND);
		system(EMAIL_FINAL_COMMAND);
		if ( (email_filename=strrchr(EMAIL_FINAL_COMMAND,'<')) ) {
			email_filename++;	/* go past the ""<"" */
			email_filename++;	/* go past the space after the < */
			if ( unlink(email_filename) == -1 ) {
				dprintf(D_ALWAYS,""email_close: cannot unlink temp file %s\n"",
					email_filename);
			}
		}
		free(EMAIL_FINAL_COMMAND);
		EMAIL_FINAL_COMMAND = NULL;
	}
#else
	(void)fclose( mailer );
#endif
	umask(prev_umask);

	/* Set priv state back */
	set_priv(priv);

}
"
821,178557,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,1,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,1,,,"display_sigset( const char *msg, sigset_t *mask )
{
	int					signo;
        NameTableIterator       next_sig( SigNames );
 
        if( msg ) {
               dprintf( D_ALWAYS, ""%s"", msg );
        }
        while( (signo = next_sig()) != -1 ) {
                if( sigismember(mask,signo) ) {
			dprintf( D_ALWAYS | D_NOHEADER, ""%s "", SigNames.get_name(signo) );
		}
	}
	dprintf( D_ALWAYS | D_NOHEADER, ""\n"" );
}
","display_sigset( const char *msg, sigset_t *mask )
{
	int					signo;
        NameTableIterator       next_sig( SigNames );
 
        if( msg ) {
               dprintf( D_ALWAYS, msg );
        }
        while( (signo = next_sig()) != -1 ) {
                if( sigismember(mask,signo) ) {
			dprintf( D_ALWAYS | D_NOHEADER, ""%s "", SigNames.get_name(signo) );
		}
	}
	dprintf( D_ALWAYS | D_NOHEADER, ""\n"" );
}
",CPP,"               dprintf( D_ALWAYS, ""%s"", msg );
","               dprintf( D_ALWAYS, msg );
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -80,7 +80,7 @@ display_sigset( const char *msg, sigset_t *mask )
        NameTableIterator       next_sig( SigNames );
 
        if( msg ) {
-               dprintf( D_ALWAYS, msg );
+               dprintf( D_ALWAYS, ""%s"", msg );
        }
        while( (signo = next_sig()) != -1 ) {
                if( sigismember(mask,signo) ) {",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_utils/event_handler.unix.cpp;h=18a34fbe74e51c2d7f393218b50bf77b07ec0cbe;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_utils/event_handler.unix.cpp;h=6ea1deb5f8a37c1048661cb91713a75dbd252312,1,"display_sigset( const char *msg, sigset_t *mask )
{
	int					signo;
        NameTableIterator       next_sig( SigNames );
 
        if( msg ) {
//flaw_line_below:
               dprintf( D_ALWAYS, msg );
//fix_flaw_line_below:
//               dprintf( D_ALWAYS, ""%s"", msg );
        }
        while( (signo = next_sig()) != -1 ) {
                if( sigismember(mask,signo) ) {
			dprintf( D_ALWAYS | D_NOHEADER, ""%s "", SigNames.get_name(signo) );
		}
	}
	dprintf( D_ALWAYS | D_NOHEADER, ""\n"" );
}
"
822,178558,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,1,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,1,,,"FileTransfer::DoUpload(filesize_t *total_bytes, ReliSock *s)
{
	int rc;
	MyString fullname;
	filesize_t bytes;
	bool is_the_executable;
	bool upload_success = false;
	bool do_download_ack = false;
	bool do_upload_ack = false;
	bool try_again = false;
	int hold_code = 0;
	int hold_subcode = 0;
	MyString error_desc;
	bool I_go_ahead_always = false;
	bool peer_goes_ahead_always = false;
	DCTransferQueue xfer_queue(m_xfer_queue_contact_info);

	CondorError errstack;

	bool first_failed_file_transfer_happened = false;
	bool first_failed_upload_success = false;
	bool first_failed_try_again = false;
	int first_failed_hold_code = 0;
	int first_failed_hold_subcode = 0;
	MyString first_failed_error_desc;
	int first_failed_line_number;


	*total_bytes = 0;
	dprintf(D_FULLDEBUG,""entering FileTransfer::DoUpload\n"");

	priv_state saved_priv = PRIV_UNKNOWN;
	if( want_priv_change ) {
		saved_priv = set_priv( desired_priv_state );
	}

	s->encode();

	if( !s->code(m_final_transfer_flag) ) {
		dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
		return_and_resetpriv( -1 );
	}
	if( !s->end_of_message() ) {
		dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
		return_and_resetpriv( -1 );
	}

	bool socket_default_crypto = s->get_encryption();

	if( want_priv_change && saved_priv == PRIV_UNKNOWN ) {
		saved_priv = set_priv( desired_priv_state );
	}

	FileTransferList filelist;
	ExpandFileTransferList( FilesToSend, filelist );

	FileTransferList::iterator filelist_it;
	for( filelist_it = filelist.begin();
		 filelist_it != filelist.end();
		 filelist_it++ )
	{
		char const *filename = filelist_it->srcName();
		char const *dest_dir = filelist_it->destDir();

		if( dest_dir && *dest_dir ) {
			dprintf(D_FULLDEBUG,""DoUpload: sending file %s to %s%c\n"",filename,dest_dir,DIR_DELIM_CHAR);
		}
		else {
			dprintf(D_FULLDEBUG,""DoUpload: sending file %s\n"",filename);
		}

		bool is_url;
		is_url = false;

		if( param_boolean(""ENABLE_URL_TRANSFERS"", true) && IsUrl(filename) ) {
			is_url = true;
			fullname = filename;
			dprintf(D_FULLDEBUG, ""DoUpload: sending %s as URL.\n"", filename);
		} else if( filename[0] != '/' && filename[0] != '\\' && filename[1] != ':' ){
			fullname.sprintf(""%s%c%s"",Iwd,DIR_DELIM_CHAR,filename);
		} else {
			fullname = filename;
		}

#ifdef WIN32
		if( !is_url && perm_obj && !is_the_executable &&
			(perm_obj->read_access(fullname.Value()) != 1) ) {
			upload_success = false;
			error_desc.sprintf(""error reading from %s: permission denied"",fullname.Value());
			do_upload_ack = true;    // tell receiver that we failed
			do_download_ack = true;
			try_again = false; // put job on hold
			hold_code = CONDOR_HOLD_CODE_UploadFileError;
			hold_subcode = EPERM;
			return ExitDoUpload(total_bytes,s,saved_priv,socket_default_crypto,
			                    upload_success,do_upload_ack,do_download_ack,
								try_again,hold_code,hold_subcode,
								error_desc.Value(),__LINE__);
		}
#endif
		if (is_the_executable) {} // Done to get rid of the compiler set-but-not-used warnings.




		int file_command = 1;
		int file_subcommand = 0;
		
		if ( DontEncryptFiles->file_contains_withwildcard(filename) ) {
			file_command = 3;
		}

		if ( EncryptFiles->file_contains_withwildcard(filename) ) {
			file_command = 2;
		}

		if ( X509UserProxy && file_strcmp( filename, X509UserProxy ) == 0 &&
			 DelegateX509Credentials ) {

			file_command = 4;
		}

		if ( is_url ) {
			file_command = 5;
		}

		if ( m_final_transfer_flag && OutputDestination ) {
			dprintf(D_FULLDEBUG, ""FILETRANSFER: Using command 999:7 for OutputDestionation: %s\n"",
					OutputDestination);

			file_command = 999;
			file_subcommand = 7;
		}

		bool fail_because_mkdir_not_supported = false;
		bool fail_because_symlink_not_supported = false;
		if( filelist_it->is_directory ) {
			if( filelist_it->is_symlink ) {
				fail_because_symlink_not_supported = true;
				dprintf(D_ALWAYS,""DoUpload: attempting to transfer symlink %s which points to a directory.  This is not supported.\n"",filename);
			}
			else if( PeerUnderstandsMkdir ) {
				file_command = 6;
			}
			else {
				fail_because_mkdir_not_supported = true;
				dprintf(D_ALWAYS,""DoUpload: attempting to transfer directory %s, but the version of Condor we are talking to is too old to support that!\n"",
						filename);
			}
		}

		dprintf ( D_FULLDEBUG, ""FILETRANSFER: outgoing file_command is %i for %s\n"",
				file_command, filename );

		if( !s->snd_int(file_command,FALSE) ) {
			dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
			return_and_resetpriv( -1 );
		}
		if( !s->end_of_message() ) {
			dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
			return_and_resetpriv( -1 );
		}

		if (file_command == 2) {
			s->set_crypto_mode(true);
		} else if (file_command == 3) {
			s->set_crypto_mode(false);
		}
		else {
			s->set_crypto_mode(socket_default_crypto);
		}

		MyString dest_filename;
		if ( ExecFile && !simple_init && (file_strcmp(ExecFile,filename)==0 )) {
			is_the_executable = true;
			dest_filename = CONDOR_EXEC;
		} else {
			is_the_executable = false;

			if( dest_dir && *dest_dir ) {
				dest_filename.sprintf(""%s%c"",dest_dir,DIR_DELIM_CHAR);
                        }
 
                       dest_filename.sprintf_cat( ""%s"", condor_basename(filename) );
                }
 
		if( !s->put(dest_filename.Value()) ) {
			dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
			return_and_resetpriv( -1 );
		}

		if( PeerDoesGoAhead ) {
			if( !s->end_of_message() ) {
				dprintf(D_FULLDEBUG, ""DoUpload: failed on eom before GoAhead; exiting at %d\n"",__LINE__);
				return_and_resetpriv( -1 );
			}

			if( !peer_goes_ahead_always ) {
				if( !ReceiveTransferGoAhead(s,fullname.Value(),false,peer_goes_ahead_always) ) {
					dprintf(D_FULLDEBUG, ""DoUpload: exiting at %d\n"",__LINE__);
					return_and_resetpriv( -1 );
				}
			}

			if( !I_go_ahead_always ) {
				if( !ObtainAndSendTransferGoAhead(xfer_queue,false,s,fullname.Value(),I_go_ahead_always) ) {
					dprintf(D_FULLDEBUG, ""DoUpload: exiting at %d\n"",__LINE__);
					return_and_resetpriv( -1 );
				}
			}

			s->encode();
		}

		if ( file_command == 999) {

			ClassAd file_info;
			file_info.Assign(""ProtocolVersion"", 1);
			file_info.Assign(""Command"", file_command);
			file_info.Assign(""SubCommand"", file_subcommand);


			if(file_subcommand == 7) {
				MyString source_filename;
				source_filename = Iwd;
				source_filename += DIR_DELIM_CHAR;
				source_filename += filename;

				MyString URL;
				URL = OutputDestination;
				URL += DIR_DELIM_CHAR;
				URL += filename;

				dprintf (D_FULLDEBUG, ""DoUpload: calling IFTP(fn,U): fn\""%s\"", U\""%s\""\n"", source_filename.Value(), URL.Value());
				dprintf (D_FULLDEBUG, ""LocalProxyName: %s\n"", LocalProxyName.Value());
				rc = InvokeFileTransferPlugin(errstack, source_filename.Value(), URL.Value(), LocalProxyName.Value());
				dprintf (D_FULLDEBUG, ""DoUpload: IFTP(fn,U): fn\""%s\"", U\""%s\"" returns %i\n"", source_filename.Value(), URL.Value(), rc);

				file_info.Assign(""Filename"", source_filename);
				file_info.Assign(""OutputDestination"", URL);

				file_info.Assign(""Result"", rc);

				if (rc) {
					file_info.Assign(""ErrorString"", errstack.getFullText());
				}

				if(!file_info.put(*s)) {
					dprintf(D_FULLDEBUG,""DoDownload: exiting at %d\n"",__LINE__);
					return_and_resetpriv( -1 );
				}

				MyString junkbuf;
				file_info.sPrint(junkbuf);
				bytes = junkbuf.Length();

			} else {
				dprintf( D_ALWAYS, ""DoUpload: invalid subcommand %i, skipping %s."",
						file_subcommand, filename);
				bytes = 0;
				rc = 0;
			}
		} else if ( file_command == 4 ) {
			if ( (PeerDoesGoAhead || s->end_of_message()) ) {
				time_t expiration_time = GetDesiredDelegatedJobCredentialExpiration(&jobAd);
				rc = s->put_x509_delegation( &bytes, fullname.Value(), expiration_time, NULL );
				dprintf( D_FULLDEBUG,
				         ""DoUpload: put_x509_delegation() returned %d\n"",
				         rc );
			} else {
				rc = -1;
			}
		} else if (file_command == 5) {
			if(!s->code(fullname)) {
				dprintf( D_FULLDEBUG, ""DoUpload: failed to send fullname: %s\n"", fullname.Value());
				rc = -1;
			} else {
				dprintf( D_FULLDEBUG, ""DoUpload: sent fullname and NO eom: %s\n"", fullname.Value());
				rc = 0;
			}

			bytes = fullname.Length();

		} else if( file_command == 6 ) { // mkdir
			bytes = sizeof( filelist_it->file_mode );

			if( !s->put( filelist_it->file_mode ) ) {
				rc = -1;
				dprintf(D_ALWAYS,""DoUpload: failed to send mkdir mode\n"");
			}
			else {
				rc = 0;
			}
		} else if( fail_because_mkdir_not_supported || fail_because_symlink_not_supported ) {
			if( TransferFilePermissions ) {
				rc = s->put_file_with_permissions( &bytes, NULL_FILE );
			}
			else {
				rc = s->put_file( &bytes, NULL_FILE );
			}
			if( rc == 0 ) {
				rc = PUT_FILE_OPEN_FAILED;
				errno = EISDIR;
			}
		} else if ( TransferFilePermissions ) {
			rc = s->put_file_with_permissions( &bytes, fullname.Value() );
		} else {
			rc = s->put_file( &bytes, fullname.Value() );
		}
		if( rc < 0 ) {
			int the_error = errno;
			upload_success = false;
			error_desc.sprintf(""error sending %s"",fullname.Value());
			if((rc == PUT_FILE_OPEN_FAILED) || (rc == PUT_FILE_PLUGIN_FAILED)) {
				if (rc == PUT_FILE_OPEN_FAILED) {

					error_desc.replaceString(""sending"",""reading from"");
					error_desc.sprintf_cat("": (errno %d) %s"",the_error,strerror(the_error));
					if( fail_because_mkdir_not_supported ) {
						error_desc.sprintf_cat(""; Remote condor version is too old to transfer directories."");
					}
					if( fail_because_symlink_not_supported ) {
						error_desc.sprintf_cat(""; Transfer of symlinks to directories is not supported."");
					}
				} else {
					error_desc.sprintf_cat("": %s"", errstack.getFullText());
				}
				try_again = false; // put job on hold
				hold_code = CONDOR_HOLD_CODE_UploadFileError;
				hold_subcode = the_error;


				if (first_failed_file_transfer_happened == false) {
					first_failed_file_transfer_happened = true;
					first_failed_upload_success = false;
					first_failed_try_again = false;
					first_failed_hold_code = hold_code;
					first_failed_hold_subcode = the_error;
					first_failed_error_desc = error_desc;
					first_failed_line_number = __LINE__;
				}
			}
			else {
				do_download_ack = true;
				do_upload_ack = false;
				try_again = true;

				return ExitDoUpload(total_bytes,s,saved_priv,
								socket_default_crypto,upload_success,
								do_upload_ack,do_download_ack,
			                    try_again,hold_code,hold_subcode,
			                    error_desc.Value(),__LINE__);
			}
		}

		if( !s->end_of_message() ) {
			dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
			return_and_resetpriv( -1 );
		}
		
		*total_bytes += bytes;


		if( dest_filename.FindChar(DIR_DELIM_CHAR) < 0 &&
			dest_filename != condor_basename(JobStdoutFile.Value()) &&
			dest_filename != condor_basename(JobStderrFile.Value()) )
		{
			Info.addSpooledFile( dest_filename.Value() );
		}
	}

	do_download_ack = true;
	do_upload_ack = true;

	if (first_failed_file_transfer_happened == true) {
		return ExitDoUpload(total_bytes,s,saved_priv,socket_default_crypto,
			first_failed_upload_success,do_upload_ack,do_download_ack,
			first_failed_try_again,first_failed_hold_code,
			first_failed_hold_subcode,first_failed_error_desc.Value(),
			first_failed_line_number);
	} 

	upload_success = true;
	return ExitDoUpload(total_bytes,s,saved_priv,socket_default_crypto,
	                    upload_success,do_upload_ack,do_download_ack,
	                    try_again,hold_code,hold_subcode,NULL,__LINE__);
}
","FileTransfer::DoUpload(filesize_t *total_bytes, ReliSock *s)
{
	int rc;
	MyString fullname;
	filesize_t bytes;
	bool is_the_executable;
	bool upload_success = false;
	bool do_download_ack = false;
	bool do_upload_ack = false;
	bool try_again = false;
	int hold_code = 0;
	int hold_subcode = 0;
	MyString error_desc;
	bool I_go_ahead_always = false;
	bool peer_goes_ahead_always = false;
	DCTransferQueue xfer_queue(m_xfer_queue_contact_info);

	CondorError errstack;

	bool first_failed_file_transfer_happened = false;
	bool first_failed_upload_success = false;
	bool first_failed_try_again = false;
	int first_failed_hold_code = 0;
	int first_failed_hold_subcode = 0;
	MyString first_failed_error_desc;
	int first_failed_line_number;


	*total_bytes = 0;
	dprintf(D_FULLDEBUG,""entering FileTransfer::DoUpload\n"");

	priv_state saved_priv = PRIV_UNKNOWN;
	if( want_priv_change ) {
		saved_priv = set_priv( desired_priv_state );
	}

	s->encode();

	if( !s->code(m_final_transfer_flag) ) {
		dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
		return_and_resetpriv( -1 );
	}
	if( !s->end_of_message() ) {
		dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
		return_and_resetpriv( -1 );
	}

	bool socket_default_crypto = s->get_encryption();

	if( want_priv_change && saved_priv == PRIV_UNKNOWN ) {
		saved_priv = set_priv( desired_priv_state );
	}

	FileTransferList filelist;
	ExpandFileTransferList( FilesToSend, filelist );

	FileTransferList::iterator filelist_it;
	for( filelist_it = filelist.begin();
		 filelist_it != filelist.end();
		 filelist_it++ )
	{
		char const *filename = filelist_it->srcName();
		char const *dest_dir = filelist_it->destDir();

		if( dest_dir && *dest_dir ) {
			dprintf(D_FULLDEBUG,""DoUpload: sending file %s to %s%c\n"",filename,dest_dir,DIR_DELIM_CHAR);
		}
		else {
			dprintf(D_FULLDEBUG,""DoUpload: sending file %s\n"",filename);
		}

		bool is_url;
		is_url = false;

		if( param_boolean(""ENABLE_URL_TRANSFERS"", true) && IsUrl(filename) ) {
			is_url = true;
			fullname = filename;
			dprintf(D_FULLDEBUG, ""DoUpload: sending %s as URL.\n"", filename);
		} else if( filename[0] != '/' && filename[0] != '\\' && filename[1] != ':' ){
			fullname.sprintf(""%s%c%s"",Iwd,DIR_DELIM_CHAR,filename);
		} else {
			fullname = filename;
		}

#ifdef WIN32
		if( !is_url && perm_obj && !is_the_executable &&
			(perm_obj->read_access(fullname.Value()) != 1) ) {
			upload_success = false;
			error_desc.sprintf(""error reading from %s: permission denied"",fullname.Value());
			do_upload_ack = true;    // tell receiver that we failed
			do_download_ack = true;
			try_again = false; // put job on hold
			hold_code = CONDOR_HOLD_CODE_UploadFileError;
			hold_subcode = EPERM;
			return ExitDoUpload(total_bytes,s,saved_priv,socket_default_crypto,
			                    upload_success,do_upload_ack,do_download_ack,
								try_again,hold_code,hold_subcode,
								error_desc.Value(),__LINE__);
		}
#endif
		if (is_the_executable) {} // Done to get rid of the compiler set-but-not-used warnings.




		int file_command = 1;
		int file_subcommand = 0;
		
		if ( DontEncryptFiles->file_contains_withwildcard(filename) ) {
			file_command = 3;
		}

		if ( EncryptFiles->file_contains_withwildcard(filename) ) {
			file_command = 2;
		}

		if ( X509UserProxy && file_strcmp( filename, X509UserProxy ) == 0 &&
			 DelegateX509Credentials ) {

			file_command = 4;
		}

		if ( is_url ) {
			file_command = 5;
		}

		if ( m_final_transfer_flag && OutputDestination ) {
			dprintf(D_FULLDEBUG, ""FILETRANSFER: Using command 999:7 for OutputDestionation: %s\n"",
					OutputDestination);

			file_command = 999;
			file_subcommand = 7;
		}

		bool fail_because_mkdir_not_supported = false;
		bool fail_because_symlink_not_supported = false;
		if( filelist_it->is_directory ) {
			if( filelist_it->is_symlink ) {
				fail_because_symlink_not_supported = true;
				dprintf(D_ALWAYS,""DoUpload: attempting to transfer symlink %s which points to a directory.  This is not supported.\n"",filename);
			}
			else if( PeerUnderstandsMkdir ) {
				file_command = 6;
			}
			else {
				fail_because_mkdir_not_supported = true;
				dprintf(D_ALWAYS,""DoUpload: attempting to transfer directory %s, but the version of Condor we are talking to is too old to support that!\n"",
						filename);
			}
		}

		dprintf ( D_FULLDEBUG, ""FILETRANSFER: outgoing file_command is %i for %s\n"",
				file_command, filename );

		if( !s->snd_int(file_command,FALSE) ) {
			dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
			return_and_resetpriv( -1 );
		}
		if( !s->end_of_message() ) {
			dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
			return_and_resetpriv( -1 );
		}

		if (file_command == 2) {
			s->set_crypto_mode(true);
		} else if (file_command == 3) {
			s->set_crypto_mode(false);
		}
		else {
			s->set_crypto_mode(socket_default_crypto);
		}

		MyString dest_filename;
		if ( ExecFile && !simple_init && (file_strcmp(ExecFile,filename)==0 )) {
			is_the_executable = true;
			dest_filename = CONDOR_EXEC;
		} else {
			is_the_executable = false;

			if( dest_dir && *dest_dir ) {
				dest_filename.sprintf(""%s%c"",dest_dir,DIR_DELIM_CHAR);
                        }
 
                       dest_filename.sprintf_cat( condor_basename(filename) );
                }
 
		if( !s->put(dest_filename.Value()) ) {
			dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
			return_and_resetpriv( -1 );
		}

		if( PeerDoesGoAhead ) {
			if( !s->end_of_message() ) {
				dprintf(D_FULLDEBUG, ""DoUpload: failed on eom before GoAhead; exiting at %d\n"",__LINE__);
				return_and_resetpriv( -1 );
			}

			if( !peer_goes_ahead_always ) {
				if( !ReceiveTransferGoAhead(s,fullname.Value(),false,peer_goes_ahead_always) ) {
					dprintf(D_FULLDEBUG, ""DoUpload: exiting at %d\n"",__LINE__);
					return_and_resetpriv( -1 );
				}
			}

			if( !I_go_ahead_always ) {
				if( !ObtainAndSendTransferGoAhead(xfer_queue,false,s,fullname.Value(),I_go_ahead_always) ) {
					dprintf(D_FULLDEBUG, ""DoUpload: exiting at %d\n"",__LINE__);
					return_and_resetpriv( -1 );
				}
			}

			s->encode();
		}

		if ( file_command == 999) {

			ClassAd file_info;
			file_info.Assign(""ProtocolVersion"", 1);
			file_info.Assign(""Command"", file_command);
			file_info.Assign(""SubCommand"", file_subcommand);


			if(file_subcommand == 7) {
				MyString source_filename;
				source_filename = Iwd;
				source_filename += DIR_DELIM_CHAR;
				source_filename += filename;

				MyString URL;
				URL = OutputDestination;
				URL += DIR_DELIM_CHAR;
				URL += filename;

				dprintf (D_FULLDEBUG, ""DoUpload: calling IFTP(fn,U): fn\""%s\"", U\""%s\""\n"", source_filename.Value(), URL.Value());
				dprintf (D_FULLDEBUG, ""LocalProxyName: %s\n"", LocalProxyName.Value());
				rc = InvokeFileTransferPlugin(errstack, source_filename.Value(), URL.Value(), LocalProxyName.Value());
				dprintf (D_FULLDEBUG, ""DoUpload: IFTP(fn,U): fn\""%s\"", U\""%s\"" returns %i\n"", source_filename.Value(), URL.Value(), rc);

				file_info.Assign(""Filename"", source_filename);
				file_info.Assign(""OutputDestination"", URL);

				file_info.Assign(""Result"", rc);

				if (rc) {
					file_info.Assign(""ErrorString"", errstack.getFullText());
				}

				if(!file_info.put(*s)) {
					dprintf(D_FULLDEBUG,""DoDownload: exiting at %d\n"",__LINE__);
					return_and_resetpriv( -1 );
				}

				MyString junkbuf;
				file_info.sPrint(junkbuf);
				bytes = junkbuf.Length();

			} else {
				dprintf( D_ALWAYS, ""DoUpload: invalid subcommand %i, skipping %s."",
						file_subcommand, filename);
				bytes = 0;
				rc = 0;
			}
		} else if ( file_command == 4 ) {
			if ( (PeerDoesGoAhead || s->end_of_message()) ) {
				time_t expiration_time = GetDesiredDelegatedJobCredentialExpiration(&jobAd);
				rc = s->put_x509_delegation( &bytes, fullname.Value(), expiration_time, NULL );
				dprintf( D_FULLDEBUG,
				         ""DoUpload: put_x509_delegation() returned %d\n"",
				         rc );
			} else {
				rc = -1;
			}
		} else if (file_command == 5) {
			if(!s->code(fullname)) {
				dprintf( D_FULLDEBUG, ""DoUpload: failed to send fullname: %s\n"", fullname.Value());
				rc = -1;
			} else {
				dprintf( D_FULLDEBUG, ""DoUpload: sent fullname and NO eom: %s\n"", fullname.Value());
				rc = 0;
			}

			bytes = fullname.Length();

		} else if( file_command == 6 ) { // mkdir
			bytes = sizeof( filelist_it->file_mode );

			if( !s->put( filelist_it->file_mode ) ) {
				rc = -1;
				dprintf(D_ALWAYS,""DoUpload: failed to send mkdir mode\n"");
			}
			else {
				rc = 0;
			}
		} else if( fail_because_mkdir_not_supported || fail_because_symlink_not_supported ) {
			if( TransferFilePermissions ) {
				rc = s->put_file_with_permissions( &bytes, NULL_FILE );
			}
			else {
				rc = s->put_file( &bytes, NULL_FILE );
			}
			if( rc == 0 ) {
				rc = PUT_FILE_OPEN_FAILED;
				errno = EISDIR;
			}
		} else if ( TransferFilePermissions ) {
			rc = s->put_file_with_permissions( &bytes, fullname.Value() );
		} else {
			rc = s->put_file( &bytes, fullname.Value() );
		}
		if( rc < 0 ) {
			int the_error = errno;
			upload_success = false;
			error_desc.sprintf(""error sending %s"",fullname.Value());
			if((rc == PUT_FILE_OPEN_FAILED) || (rc == PUT_FILE_PLUGIN_FAILED)) {
				if (rc == PUT_FILE_OPEN_FAILED) {

					error_desc.replaceString(""sending"",""reading from"");
					error_desc.sprintf_cat("": (errno %d) %s"",the_error,strerror(the_error));
					if( fail_because_mkdir_not_supported ) {
						error_desc.sprintf_cat(""; Remote condor version is too old to transfer directories."");
					}
					if( fail_because_symlink_not_supported ) {
						error_desc.sprintf_cat(""; Transfer of symlinks to directories is not supported."");
					}
				} else {
					error_desc.sprintf_cat("": %s"", errstack.getFullText());
				}
				try_again = false; // put job on hold
				hold_code = CONDOR_HOLD_CODE_UploadFileError;
				hold_subcode = the_error;


				if (first_failed_file_transfer_happened == false) {
					first_failed_file_transfer_happened = true;
					first_failed_upload_success = false;
					first_failed_try_again = false;
					first_failed_hold_code = hold_code;
					first_failed_hold_subcode = the_error;
					first_failed_error_desc = error_desc;
					first_failed_line_number = __LINE__;
				}
			}
			else {
				do_download_ack = true;
				do_upload_ack = false;
				try_again = true;

				return ExitDoUpload(total_bytes,s,saved_priv,
								socket_default_crypto,upload_success,
								do_upload_ack,do_download_ack,
			                    try_again,hold_code,hold_subcode,
			                    error_desc.Value(),__LINE__);
			}
		}

		if( !s->end_of_message() ) {
			dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
			return_and_resetpriv( -1 );
		}
		
		*total_bytes += bytes;


		if( dest_filename.FindChar(DIR_DELIM_CHAR) < 0 &&
			dest_filename != condor_basename(JobStdoutFile.Value()) &&
			dest_filename != condor_basename(JobStderrFile.Value()) )
		{
			Info.addSpooledFile( dest_filename.Value() );
		}
	}

	do_download_ack = true;
	do_upload_ack = true;

	if (first_failed_file_transfer_happened == true) {
		return ExitDoUpload(total_bytes,s,saved_priv,socket_default_crypto,
			first_failed_upload_success,do_upload_ack,do_download_ack,
			first_failed_try_again,first_failed_hold_code,
			first_failed_hold_subcode,first_failed_error_desc.Value(),
			first_failed_line_number);
	} 

	upload_success = true;
	return ExitDoUpload(total_bytes,s,saved_priv,socket_default_crypto,
	                    upload_success,do_upload_ack,do_download_ack,
	                    try_again,hold_code,hold_subcode,NULL,__LINE__);
}
",CPP,"                       dest_filename.sprintf_cat( ""%s"", condor_basename(filename) );
","                       dest_filename.sprintf_cat( condor_basename(filename) );
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -2716,7 +2716,7 @@ FileTransfer::DoUpload(filesize_t *total_bytes, ReliSock *s)
                        }
 
                        // condor_basename works for URLs
-                       dest_filename.sprintf_cat( condor_basename(filename) );
+                       dest_filename.sprintf_cat( ""%s"", condor_basename(filename) );
                }
 
                // for command 999, this string must equal the Attribute ""Filename"" in",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_utils/file_transfer.cpp;h=52c19cefcce85a6f654dbe8c2ec9a8b2bf2c1ec7;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_utils/file_transfer.cpp;h=57c2cb73e16eb15f6f1a859a66c81826ae083b09,1,"FileTransfer::DoUpload(filesize_t *total_bytes, ReliSock *s)
{
	int rc;
	MyString fullname;
	filesize_t bytes;
	bool is_the_executable;
	bool upload_success = false;
	bool do_download_ack = false;
	bool do_upload_ack = false;
	bool try_again = false;
	int hold_code = 0;
	int hold_subcode = 0;
	MyString error_desc;
	bool I_go_ahead_always = false;
	bool peer_goes_ahead_always = false;
	DCTransferQueue xfer_queue(m_xfer_queue_contact_info);

	// use an error stack to keep track of failures when invoke plugins,
	// perhaps more of this can be instrumented with it later.
	CondorError errstack;

	// If a bunch of file transfers failed strictly due to
	// PUT_FILE_OPEN_FAILED, then we keep track of the information relating to
	// the first failed one, and continue to attempt to transfer the rest in
	// the list. At the end of the transfer, the job will go on hold with the
	// information of the first failed transfer. This is to allow things like
	// corefiles and whatnot to be brought back to the spool even if the user
	// job hadn't completed writing all the files as specified in
	// transfer_output_files. These variables represent the saved state of the
	// first failed transfer. See gt #487.
	bool first_failed_file_transfer_happened = false;
	bool first_failed_upload_success = false;
	bool first_failed_try_again = false;
	int first_failed_hold_code = 0;
	int first_failed_hold_subcode = 0;
	MyString first_failed_error_desc;
	int first_failed_line_number;


	*total_bytes = 0;
	dprintf(D_FULLDEBUG,""entering FileTransfer::DoUpload\n"");

	priv_state saved_priv = PRIV_UNKNOWN;
	if( want_priv_change ) {
		saved_priv = set_priv( desired_priv_state );
	}

	s->encode();

	// tell the server if this is the final transfer our not.
	// if it is the final transfer, the server places the files
	// into the user's Iwd.  if not, the files go into SpoolSpace.
	if( !s->code(m_final_transfer_flag) ) {
		dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
		return_and_resetpriv( -1 );
	}
	if( !s->end_of_message() ) {
		dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
		return_and_resetpriv( -1 );
	}

	// record the state it was in when we started... the ""default"" state
	bool socket_default_crypto = s->get_encryption();

	if( want_priv_change && saved_priv == PRIV_UNKNOWN ) {
		saved_priv = set_priv( desired_priv_state );
	}

	FileTransferList filelist;
	ExpandFileTransferList( FilesToSend, filelist );

	FileTransferList::iterator filelist_it;
	for( filelist_it = filelist.begin();
		 filelist_it != filelist.end();
		 filelist_it++ )
	{
		char const *filename = filelist_it->srcName();
		char const *dest_dir = filelist_it->destDir();

		if( dest_dir && *dest_dir ) {
			dprintf(D_FULLDEBUG,""DoUpload: sending file %s to %s%c\n"",filename,dest_dir,DIR_DELIM_CHAR);
		}
		else {
			dprintf(D_FULLDEBUG,""DoUpload: sending file %s\n"",filename);
		}

		// reset this for each file
		bool is_url;
		is_url = false;

		if( param_boolean(""ENABLE_URL_TRANSFERS"", true) && IsUrl(filename) ) {
			// looks like a URL
			is_url = true;
			fullname = filename;
			dprintf(D_FULLDEBUG, ""DoUpload: sending %s as URL.\n"", filename);
		} else if( filename[0] != '/' && filename[0] != '\\' && filename[1] != ':' ){
			// looks like a relative path
			fullname.sprintf(""%s%c%s"",Iwd,DIR_DELIM_CHAR,filename);
		} else {
			// looks like an unix absolute path or a windows path
			fullname = filename;
		}

		// check for read permission on this file, if we are supposed to check.
		// do not check the executable, since it is likely sitting in the SPOOL
		// directory.
		//
		// also, don't check URLs
#ifdef WIN32
		if( !is_url && perm_obj && !is_the_executable &&
			(perm_obj->read_access(fullname.Value()) != 1) ) {
			// we do _not_ have permission to read this file!!
			upload_success = false;
			error_desc.sprintf(""error reading from %s: permission denied"",fullname.Value());
			do_upload_ack = true;    // tell receiver that we failed
			do_download_ack = true;
			try_again = false; // put job on hold
			hold_code = CONDOR_HOLD_CODE_UploadFileError;
			hold_subcode = EPERM;
			return ExitDoUpload(total_bytes,s,saved_priv,socket_default_crypto,
			                    upload_success,do_upload_ack,do_download_ack,
								try_again,hold_code,hold_subcode,
								error_desc.Value(),__LINE__);
		}
#endif
		if (is_the_executable) {} // Done to get rid of the compiler set-but-not-used warnings.


		// now we send an int to the other side to indicate the next
		// action.  historically, we sent either 1 or 0.  zero meant
		// we were finished and there are no more files to send.  any
		// non-zero value means there is at least one more file.
		//
		// this has been expanded with two new values which indicate
		// encryption settings per-file.  the new values are:
		// 0 - finished
		// 1 - use socket default (on or off) for next file
		// 2 - force encryption on for next file.
		// 3 - force encryption off for next file.
		//
		// this was further expanded to allow delagation of x509 creds
		// 4 - do an x509 credential delegation (using the socket default)
		//
		// and again to tell the remote side to fetch a URL
		// 5 - send a URL and have the other side fetch it
		//
		// and again to allow transferring and creating subdirectories
		// 6 - send a request to make a directory
		//
		// and one more time to make a more flexible protocol.  this magic
		// number 999 means we will still send the filename, and then send a
		// classad immediately following the filename, and the classad will say
		// what action to perform.  this will allow potential changes without
		// breaking the wire protocol and hopefully will be more forward and
		// backward compatible for future updates.
		//
		// 999 - send a classad telling what to do.
		//
		// 999 subcommand 7:
		// send information about a transfer performed using a transfer hook


		// default to the socket default
		int file_command = 1;
		int file_subcommand = 0;
		
		// find out if this file is in DontEncryptFiles
		if ( DontEncryptFiles->file_contains_withwildcard(filename) ) {
			// turn crypto off for this file (actually done below)
			file_command = 3;
		}

		// now find out if this file is in EncryptFiles.  if it was
		// also in DontEncryptFiles, that doesn't matter, this will
		// override.
		if ( EncryptFiles->file_contains_withwildcard(filename) ) {
			// turn crypto on for this file (actually done below)
			file_command = 2;
		}

		// We want to delegate the job's x509 proxy, rather than just
		// copy it.
		if ( X509UserProxy && file_strcmp( filename, X509UserProxy ) == 0 &&
			 DelegateX509Credentials ) {

			file_command = 4;
		}

		if ( is_url ) {
			file_command = 5;
		}

		if ( m_final_transfer_flag && OutputDestination ) {
			dprintf(D_FULLDEBUG, ""FILETRANSFER: Using command 999:7 for OutputDestionation: %s\n"",
					OutputDestination);

			// switch from whatever command we had before to new classad
			// command new classad command 999 and subcommand 7.
			//
			// 7 == invoke plugin to store file
			file_command = 999;
			file_subcommand = 7;
		}

		bool fail_because_mkdir_not_supported = false;
		bool fail_because_symlink_not_supported = false;
		if( filelist_it->is_directory ) {
			if( filelist_it->is_symlink ) {
				fail_because_symlink_not_supported = true;
				dprintf(D_ALWAYS,""DoUpload: attempting to transfer symlink %s which points to a directory.  This is not supported.\n"",filename);
			}
			else if( PeerUnderstandsMkdir ) {
				file_command = 6;
			}
			else {
				fail_because_mkdir_not_supported = true;
				dprintf(D_ALWAYS,""DoUpload: attempting to transfer directory %s, but the version of Condor we are talking to is too old to support that!\n"",
						filename);
			}
		}

		dprintf ( D_FULLDEBUG, ""FILETRANSFER: outgoing file_command is %i for %s\n"",
				file_command, filename );

		if( !s->snd_int(file_command,FALSE) ) {
			dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
			return_and_resetpriv( -1 );
		}
		if( !s->end_of_message() ) {
			dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
			return_and_resetpriv( -1 );
		}

		// now enable the crypto decision we made:
		if (file_command == 2) {
			s->set_crypto_mode(true);
		} else if (file_command == 3) {
			s->set_crypto_mode(false);
		}
		else {
			s->set_crypto_mode(socket_default_crypto);
		}

		MyString dest_filename;
		if ( ExecFile && !simple_init && (file_strcmp(ExecFile,filename)==0 )) {
			// this file is the job executable
			is_the_executable = true;
			dest_filename = CONDOR_EXEC;
		} else {
			// this file is _not_ the job executable
			is_the_executable = false;

			if( dest_dir && *dest_dir ) {
				dest_filename.sprintf(""%s%c"",dest_dir,DIR_DELIM_CHAR);
                        }
 
                        // condor_basename works for URLs
//flaw_line_below:
                       dest_filename.sprintf_cat( condor_basename(filename) );
//fix_flaw_line_below:
//                       dest_filename.sprintf_cat( ""%s"", condor_basename(filename) );
                }
 
                // for command 999, this string must equal the Attribute ""Filename"" in
		// the classad that follows.  it wouldn't really need to be sent here
		// but is more wire-compatible with older versions if we do.
		//
		// should we send a protocol version string instead?  or some other token
		// like 'CLASSAD'?
		//
		if( !s->put(dest_filename.Value()) ) {
			dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
			return_and_resetpriv( -1 );
		}

		if( PeerDoesGoAhead ) {
			if( !s->end_of_message() ) {
				dprintf(D_FULLDEBUG, ""DoUpload: failed on eom before GoAhead; exiting at %d\n"",__LINE__);
				return_and_resetpriv( -1 );
			}

			if( !peer_goes_ahead_always ) {
					// Now wait for our peer to tell us it is ok for us to
					// go ahead and send data.
				if( !ReceiveTransferGoAhead(s,fullname.Value(),false,peer_goes_ahead_always) ) {
					dprintf(D_FULLDEBUG, ""DoUpload: exiting at %d\n"",__LINE__);
					return_and_resetpriv( -1 );
				}
			}

			if( !I_go_ahead_always ) {
					// Now tell our peer when it is ok for us to read data
					// from disk for sending.
				if( !ObtainAndSendTransferGoAhead(xfer_queue,false,s,fullname.Value(),I_go_ahead_always) ) {
					dprintf(D_FULLDEBUG, ""DoUpload: exiting at %d\n"",__LINE__);
					return_and_resetpriv( -1 );
				}
			}

			s->encode();
		}

		if ( file_command == 999) {
			// new-style, send classad

			ClassAd file_info;
			file_info.Assign(""ProtocolVersion"", 1);
			file_info.Assign(""Command"", file_command);
			file_info.Assign(""SubCommand"", file_subcommand);

			// only one subcommand at the moment: 7
			//
			// 7 is ""Report to shadow the final status of invoking a transfer
			// hook to move the output file""

			if(file_subcommand == 7) {
				// make the URL out of Attr OutputDestination and filename
				MyString source_filename;
				source_filename = Iwd;
				source_filename += DIR_DELIM_CHAR;
				source_filename += filename;

				MyString URL;
				URL = OutputDestination;
				URL += DIR_DELIM_CHAR;
				URL += filename;

				// actually invoke the plugin.  this could block indefinitely.
				dprintf (D_FULLDEBUG, ""DoUpload: calling IFTP(fn,U): fn\""%s\"", U\""%s\""\n"", source_filename.Value(), URL.Value());
				dprintf (D_FULLDEBUG, ""LocalProxyName: %s\n"", LocalProxyName.Value());
				rc = InvokeFileTransferPlugin(errstack, source_filename.Value(), URL.Value(), LocalProxyName.Value());
				dprintf (D_FULLDEBUG, ""DoUpload: IFTP(fn,U): fn\""%s\"", U\""%s\"" returns %i\n"", source_filename.Value(), URL.Value(), rc);

				// report the results:
				file_info.Assign(""Filename"", source_filename);
				file_info.Assign(""OutputDestination"", URL);

				// will either be 0 (success) or -4 (GET_FILE_PLUGIN_FAILED)
				file_info.Assign(""Result"", rc);

				// nonzero indicates failure, put the ErrStack into the classad
				if (rc) {
					file_info.Assign(""ErrorString"", errstack.getFullText());
				}

				// it's all assembled, so send the ad using stream s.
				// don't end the message, it's done below.
				if(!file_info.put(*s)) {
					dprintf(D_FULLDEBUG,""DoDownload: exiting at %d\n"",__LINE__);
					return_and_resetpriv( -1 );
				}

				// compute the size of what we sent
				MyString junkbuf;
				file_info.sPrint(junkbuf);
				bytes = junkbuf.Length();

			} else {
				dprintf( D_ALWAYS, ""DoUpload: invalid subcommand %i, skipping %s."",
						file_subcommand, filename);
				bytes = 0;
				rc = 0;
			}
		} else if ( file_command == 4 ) {
			if ( (PeerDoesGoAhead || s->end_of_message()) ) {
				time_t expiration_time = GetDesiredDelegatedJobCredentialExpiration(&jobAd);
				rc = s->put_x509_delegation( &bytes, fullname.Value(), expiration_time, NULL );
				dprintf( D_FULLDEBUG,
				         ""DoUpload: put_x509_delegation() returned %d\n"",
				         rc );
			} else {
				rc = -1;
			}
		} else if (file_command == 5) {
			// send the URL and that's it for now.
			// TODO: this should probably be a classad
			if(!s->code(fullname)) {
				dprintf( D_FULLDEBUG, ""DoUpload: failed to send fullname: %s\n"", fullname.Value());
				rc = -1;
			} else {
				dprintf( D_FULLDEBUG, ""DoUpload: sent fullname and NO eom: %s\n"", fullname.Value());
				rc = 0;
			}

			// on the sending side, we don't know how many bytes the actual
			// file was, since we aren't the ones downloading it.  to find out
			// the length, we'd have to make a connection to some server (via a
			// plugin, for which no API currently exists) and ask it, and i
			// don't want to add that latency.
			// 
			// instead we add the length of the URL itself, since that's what
			// we sent.
			bytes = fullname.Length();

		} else if( file_command == 6 ) { // mkdir
			// the only data sent is the file_mode.
			bytes = sizeof( filelist_it->file_mode );

			if( !s->put( filelist_it->file_mode ) ) {
				rc = -1;
				dprintf(D_ALWAYS,""DoUpload: failed to send mkdir mode\n"");
			}
			else {
				rc = 0;
			}
		} else if( fail_because_mkdir_not_supported || fail_because_symlink_not_supported ) {
			if( TransferFilePermissions ) {
				rc = s->put_file_with_permissions( &bytes, NULL_FILE );
			}
			else {
				rc = s->put_file( &bytes, NULL_FILE );
			}
			if( rc == 0 ) {
				rc = PUT_FILE_OPEN_FAILED;
				errno = EISDIR;
			}
		} else if ( TransferFilePermissions ) {
			rc = s->put_file_with_permissions( &bytes, fullname.Value() );
		} else {
			rc = s->put_file( &bytes, fullname.Value() );
		}
		if( rc < 0 ) {
			int the_error = errno;
			upload_success = false;
			error_desc.sprintf(""error sending %s"",fullname.Value());
			if((rc == PUT_FILE_OPEN_FAILED) || (rc == PUT_FILE_PLUGIN_FAILED)) {
				if (rc == PUT_FILE_OPEN_FAILED) {
					// In this case, put_file() has transmitted a zero-byte
					// file in place of the failed one. This means there is an
					// ack waiting for us to read back which we do at the end of
					// the while loop.

					error_desc.replaceString(""sending"",""reading from"");
					error_desc.sprintf_cat("": (errno %d) %s"",the_error,strerror(the_error));
					if( fail_because_mkdir_not_supported ) {
						error_desc.sprintf_cat(""; Remote condor version is too old to transfer directories."");
					}
					if( fail_because_symlink_not_supported ) {
						error_desc.sprintf_cat(""; Transfer of symlinks to directories is not supported."");
					}
				} else {
					// add on the error string from the errstack used
					error_desc.sprintf_cat("": %s"", errstack.getFullText());
				}
				try_again = false; // put job on hold
				hold_code = CONDOR_HOLD_CODE_UploadFileError;
				hold_subcode = the_error;

				// We'll continue trying to transfer the rest of the files
				// in question, but we'll record the information we need from
				// the first failure. Notice that this means we won't know
				// the complete set of files which failed to transfer back
				// but have become zero length files on the submit side.
				// We'd need to append those failed files to some kind of an
				// attribute in the job ad representing this failure. That
				// is not currently implemented....

				if (first_failed_file_transfer_happened == false) {
					first_failed_file_transfer_happened = true;
					first_failed_upload_success = false;
					first_failed_try_again = false;
					first_failed_hold_code = hold_code;
					first_failed_hold_subcode = the_error;
					first_failed_error_desc = error_desc;
					first_failed_line_number = __LINE__;
				}
			}
			else {
				// We can't currently tell the different between other
				// put_file() errors that will generate an ack error
				// report, and those that are due to a genuine
				// disconnect between us and the receiver.  Therefore,
				// always try reading the download ack.
				do_download_ack = true;
				// The stream _from_ us to the receiver is in an undefined
				// state.  Some network operation may have failed part
				// way through the transmission, so we cannot expect
				// the other side to be able to read our upload ack.
				do_upload_ack = false;
				try_again = true;

				// for the more interesting reasons why the transfer failed,
				// we can try again and see what happens.
				return ExitDoUpload(total_bytes,s,saved_priv,
								socket_default_crypto,upload_success,
								do_upload_ack,do_download_ack,
			                    try_again,hold_code,hold_subcode,
			                    error_desc.Value(),__LINE__);
			}
		}

		if( !s->end_of_message() ) {
			dprintf(D_FULLDEBUG,""DoUpload: exiting at %d\n"",__LINE__);
			return_and_resetpriv( -1 );
		}
		
		*total_bytes += bytes;

			// The spooled files list is used to generate
			// SpooledOutputFiles, which replaces TransferOutputFiles
			// when pulling output from the spool directory.  We don't
			// really know here whether the other side is writing to the
			// spool or not, but we generate the list just in case.
			//
			// If we transfer directories, only include the directory
			// in the spooled files list, not its contents.  Also skip
			// the stdout/stderr files, since those are handled
			// separately when building the list of files to transfer.

		if( dest_filename.FindChar(DIR_DELIM_CHAR) < 0 &&
			dest_filename != condor_basename(JobStdoutFile.Value()) &&
			dest_filename != condor_basename(JobStderrFile.Value()) )
		{
			Info.addSpooledFile( dest_filename.Value() );
		}
	}

	do_download_ack = true;
	do_upload_ack = true;

	if (first_failed_file_transfer_happened == true) {
		return ExitDoUpload(total_bytes,s,saved_priv,socket_default_crypto,
			first_failed_upload_success,do_upload_ack,do_download_ack,
			first_failed_try_again,first_failed_hold_code,
			first_failed_hold_subcode,first_failed_error_desc.Value(),
			first_failed_line_number);
	} 

	upload_success = true;
	return ExitDoUpload(total_bytes,s,saved_priv,socket_default_crypto,
	                    upload_success,do_upload_ack,do_download_ack,
	                    try_again,hold_code,hold_subcode,NULL,__LINE__);
}
"
823,178559,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,1,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,1,,,"ReadUserLogState::SetState( const ReadUserLog::FileState &state )
{
	const ReadUserLogFileState::FileState *istate;
	if ( !convertState(state, istate) ) {
		return false;
	}

	if ( strcmp( istate->m_signature, FileStateSignature ) ) {
		m_init_error = true;
		return false;
	}
	if ( istate->m_version != FILESTATE_VERSION ) {
		m_init_error = true;
		return false;
	}

	m_base_path = istate->m_base_path;

	m_max_rotations = istate->m_max_rotations;
	Rotation( istate->m_rotation, false, true );

	m_log_type = istate->m_log_type;
	m_uniq_id  = istate->m_uniq_id;
	m_sequence = istate->m_sequence;

	m_stat_buf.st_ino   = istate->m_inode;
	m_stat_buf.st_ctime = istate->m_ctime;
	m_stat_buf.st_size  = istate->m_size.asint;
	m_stat_valid = true;

	m_offset = istate->m_offset.asint;
	m_event_num = istate->m_event_num.asint;

	m_log_position = istate->m_log_position.asint;
	m_log_record   = istate->m_log_record.asint;

	m_update_time  = istate->m_update_time;

	m_initialized  = true;
 
        MyString        str;
        GetStateString( str, ""Restored reader state"" );
       dprintf( D_FULLDEBUG, ""%s"", str.Value() );
 
        return true;
 }
","ReadUserLogState::SetState( const ReadUserLog::FileState &state )
{
	const ReadUserLogFileState::FileState *istate;
	if ( !convertState(state, istate) ) {
		return false;
	}

	if ( strcmp( istate->m_signature, FileStateSignature ) ) {
		m_init_error = true;
		return false;
	}
	if ( istate->m_version != FILESTATE_VERSION ) {
		m_init_error = true;
		return false;
	}

	m_base_path = istate->m_base_path;

	m_max_rotations = istate->m_max_rotations;
	Rotation( istate->m_rotation, false, true );

	m_log_type = istate->m_log_type;
	m_uniq_id  = istate->m_uniq_id;
	m_sequence = istate->m_sequence;

	m_stat_buf.st_ino   = istate->m_inode;
	m_stat_buf.st_ctime = istate->m_ctime;
	m_stat_buf.st_size  = istate->m_size.asint;
	m_stat_valid = true;

	m_offset = istate->m_offset.asint;
	m_event_num = istate->m_event_num.asint;

	m_log_position = istate->m_log_position.asint;
	m_log_record   = istate->m_log_record.asint;

	m_update_time  = istate->m_update_time;

	m_initialized  = true;
 
        MyString        str;
        GetStateString( str, ""Restored reader state"" );
       dprintf( D_FULLDEBUG, str.Value() );
 
        return true;
 }
",CPP,"       dprintf( D_FULLDEBUG, ""%s"", str.Value() );
","       dprintf( D_FULLDEBUG, str.Value() );
",9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -752,7 +752,7 @@ ReadUserLogState::SetState( const ReadUserLog::FileState &state )
 
        MyString        str;
        GetStateString( str, ""Restored reader state"" );
-       dprintf( D_FULLDEBUG, str.Value() );
+       dprintf( D_FULLDEBUG, ""%s"", str.Value() );
 
        return true;
 }",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_utils/read_user_log_state.cpp;h=715e0fbac16028399aecf2b98628eab3137f3423;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_utils/read_user_log_state.cpp;h=b7bbfb4fbdc0419236214cf371be89dae2fbedea,1,"ReadUserLogState::SetState( const ReadUserLog::FileState &state )
{
	const ReadUserLogFileState::FileState *istate;
	if ( !convertState(state, istate) ) {
		return false;
	}

	// Verify that the signature matches
	if ( strcmp( istate->m_signature, FileStateSignature ) ) {
		m_init_error = true;
		return false;
	}
	if ( istate->m_version != FILESTATE_VERSION ) {
		m_init_error = true;
		return false;
	}

	m_base_path = istate->m_base_path;

	// Set the rotation & path
	m_max_rotations = istate->m_max_rotations;
	Rotation( istate->m_rotation, false, true );

	m_log_type = istate->m_log_type;
	m_uniq_id  = istate->m_uniq_id;
	m_sequence = istate->m_sequence;

	m_stat_buf.st_ino   = istate->m_inode;
	m_stat_buf.st_ctime = istate->m_ctime;
	m_stat_buf.st_size  = istate->m_size.asint;
	m_stat_valid = true;

	m_offset = istate->m_offset.asint;
	m_event_num = istate->m_event_num.asint;

	m_log_position = istate->m_log_position.asint;
	m_log_record   = istate->m_log_record.asint;

	m_update_time  = istate->m_update_time;

	m_initialized  = true;
 
        MyString        str;
        GetStateString( str, ""Restored reader state"" );
//flaw_line_below:
       dprintf( D_FULLDEBUG, str.Value() );
//fix_flaw_line_below:
//       dprintf( D_FULLDEBUG, ""%s"", str.Value() );
 
        return true;
 }
"
2967,180703,,Remote,Not required,Complete,CVE-2015-8617,https://www.cvedetails.com/cve/CVE-2015-8617/,CWE-134,Low,Complete,Complete,,2016-01-19,10.0,"Format string vulnerability in the zend_throw_or_error function in Zend/zend_execute_API.c in PHP 7.x before 7.0.1 allows remote attackers to execute arbitrary code via format string specifiers in a string that is misused as a class name, leading to incorrect error handling.",2017-09-09,Exec Code ,1,https://github.com/php/php-src/commit/b101a6bbd4f2181c360bd38e7683df4a03cba83e,b101a6bbd4f2181c360bd38e7683df4a03cba83e,Use format string,1,Zend/zend_execute_API.c,"{""sha"": ""fdffed34b275775084eeaf943a12c992edac2e0c"", ""filename"": ""Zend/zend_execute_API.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/php/php-src/blob/b101a6bbd4f2181c360bd38e7683df4a03cba83e/Zend/zend_execute_API.c"", ""raw_url"": ""https://github.com/php/php-src/raw/b101a6bbd4f2181c360bd38e7683df4a03cba83e/Zend/zend_execute_API.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/Zend/zend_execute_API.c?ref=b101a6bbd4f2181c360bd38e7683df4a03cba83e"", ""patch"": ""@@ -218,7 +218,7 @@ static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce,\n \tzend_vspprintf(&message, 0, format, va);\n \n \tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {\n-\t\tzend_throw_error(exception_ce, message);\n+\t\tzend_throw_error(exception_ce, \""%s\"", message);\n \t} else {\n \t\tzend_error(E_ERROR, \""%s\"", message);\n \t}""}","static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) /* {{{ */
{
	va_list va;
	char *message = NULL;

	va_start(va, format);
 	zend_vspprintf(&message, 0, format, va);
 
 	if (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {
		zend_throw_error(exception_ce, ""%s"", message);
 	} else {
 		zend_error(E_ERROR, ""%s"", message);
 	}

	efree(message);
	va_end(va);
}
/* }}} */
","static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) /* {{{ */
{
	va_list va;
	char *message = NULL;

	va_start(va, format);
 	zend_vspprintf(&message, 0, format, va);
 
 	if (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {
		zend_throw_error(exception_ce, message);
 	} else {
 		zend_error(E_ERROR, ""%s"", message);
 	}

	efree(message);
	va_end(va);
}
/* }}} */
",C,"		zend_throw_error(exception_ce, ""%s"", message);
","		zend_throw_error(exception_ce, message);
",,"@@ -218,7 +218,7 @@ static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce,
 	zend_vspprintf(&message, 0, format, va);
 
 	if (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {
-		zend_throw_error(exception_ce, message);
+		zend_throw_error(exception_ce, ""%s"", message);
 	} else {
 		zend_error(E_ERROR, ""%s"", message);
 	}",php-src,b101a6bbd4f2181c360bd38e7683df4a03cba83e,e0691d27d5b83122c78b9a3c4e2cd0aadf57fcb7,1,"static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) /* {{{ */
{
	va_list va;
	char *message = NULL;

	va_start(va, format);
 	zend_vspprintf(&message, 0, format, va);
 
 	if (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {
//flaw_line_below:
		zend_throw_error(exception_ce, message);
//fix_flaw_line_below:
//		zend_throw_error(exception_ce, ""%s"", message);
 	} else {
 		zend_error(E_ERROR, ""%s"", message);
 	}

	efree(message);
	va_end(va);
}
/* }}} */
"
3419,181155,,Remote,Not required,Partial,CVE-2017-12588,https://www.cvedetails.com/cve/CVE-2017-12588/,CWE-134,Low,Partial,Partial,,2017-08-06,7.5,"The zmq3 input and output modules in rsyslog before 8.28.0 interpreted description fields as format strings, possibly allowing a format string attack with unspecified impact.",2017-08-14,,2,https://github.com/rsyslog/rsyslog/commit/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b,062d0c671a29f7c6f7dff4a2f1f35df375bbb30b,"Merge pull request #1565 from Whissi/fix-format-security-issue-in-zmq-modules

Fix format security issue in zmq3 modules",2,contrib/imzmq3/imzmq3.c,"{""sha"": ""d32dcbc26984d7d62a8e736fc043689321b86958"", ""filename"": ""contrib/imzmq3/imzmq3.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/rsyslog/rsyslog/blob/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b/contrib/imzmq3/imzmq3.c"", ""raw_url"": ""https://github.com/rsyslog/rsyslog/raw/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b/contrib/imzmq3/imzmq3.c"", ""contents_url"": ""https://api.github.com/repos/rsyslog/rsyslog/contents/contrib/imzmq3/imzmq3.c?ref=062d0c671a29f7c6f7dff4a2f1f35df375bbb30b"", ""patch"": ""@@ -403,7 +403,7 @@ static rsRetVal createSocket(instanceConf_t* info, void** sock) {\n \n     /* Do the bind/connect... */\n     if (info->action==ACTION_CONNECT) {\n-        rv = zsocket_connect(*sock, info->description);\n+        rv = zsocket_connect(*sock, \""%s\"", info->description);\n         if (rv == -1) {\n             errmsg.LogError(0,\n                             RS_RET_INVALID_PARAMS,\n@@ -413,7 +413,7 @@ static rsRetVal createSocket(instanceConf_t* info, void** sock) {\n         }\n         DBGPRINTF(\""imzmq3: connect for %s successful\\n\"",info->description);\n     } else {\n-        rv = zsocket_bind(*sock, info->description);\n+        rv = zsocket_bind(*sock, \""%s\"", info->description);\n         if (rv == -1) {\n             errmsg.LogError(0,\n                             RS_RET_INVALID_PARAMS,""}<_**next**_>{""sha"": ""ceb461c6df045e166345ed8f8c665ce907b737cd"", ""filename"": ""contrib/omzmq3/omzmq3.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/rsyslog/rsyslog/blob/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b/contrib/omzmq3/omzmq3.c"", ""raw_url"": ""https://github.com/rsyslog/rsyslog/raw/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b/contrib/omzmq3/omzmq3.c"", ""contents_url"": ""https://api.github.com/repos/rsyslog/rsyslog/contents/contrib/omzmq3/omzmq3.c?ref=062d0c671a29f7c6f7dff4a2f1f35df375bbb30b"", ""patch"": ""@@ -242,14 +242,14 @@ static rsRetVal initZMQ(instanceData* pData) {\n     if (pData->action == ACTION_BIND) {\n         /* bind asserts, so no need to test return val here\n            which isn't the greatest api -- oh well */\n-        if(-1 == zsocket_bind(pData->socket, (char*)pData->description)) {\n+        if(-1 == zsocket_bind(pData->socket, \""%s\"", (char*)pData->description)) {\n             errmsg.LogError(0, RS_RET_NO_ERRCODE, \""omzmq3: bind failed for %s: %s\"",\n                             pData->description, zmq_strerror(errno));\n             ABORT_FINALIZE(RS_RET_NO_ERRCODE);\n         }\n         DBGPRINTF(\""omzmq3: bind to %s successful\\n\"",pData->description);\n     } else {\n-        if(-1 == zsocket_connect(pData->socket, (char*)pData->description)) {\n+        if(-1 == zsocket_connect(pData->socket, \""%s\"", (char*)pData->description)) {\n             errmsg.LogError(0, RS_RET_NO_ERRCODE, \""omzmq3: connect failed for %s: %s\"", \n                             pData->description, zmq_strerror(errno));\n             ABORT_FINALIZE(RS_RET_NO_ERRCODE);""}","static rsRetVal createSocket(instanceConf_t* info, void** sock) {
    int rv;
    sublist* sub;

    *sock = zsocket_new(s_context, info->type);
    if (!sock) {
        errmsg.LogError(0,
                        RS_RET_INVALID_PARAMS,
                        ""zsocket_new failed: %s, for type %d"",
                        zmq_strerror(errno),info->type);
        /* DK: invalid params seems right here */
        return RS_RET_INVALID_PARAMS;
    }
    DBGPRINTF(""imzmq3: socket of type %d created successfully\n"", info->type)
    /* Set options *before* the connect/bind. */
    if (info->identity)             zsocket_set_identity(*sock, info->identity);
    if (info->sndBuf > -1)          zsocket_set_sndbuf(*sock, info->sndBuf);
    if (info->rcvBuf > -1)          zsocket_set_rcvbuf(*sock, info->rcvBuf);
    if (info->linger > -1)          zsocket_set_linger(*sock, info->linger);
    if (info->backlog > -1)         zsocket_set_backlog(*sock, info->backlog);
    if (info->sndTimeout > -1)      zsocket_set_sndtimeo(*sock, info->sndTimeout);
    if (info->rcvTimeout > -1)      zsocket_set_rcvtimeo(*sock, info->rcvTimeout);
    if (info->maxMsgSize > -1)      zsocket_set_maxmsgsize(*sock, info->maxMsgSize);
    if (info->rate > -1)            zsocket_set_rate(*sock, info->rate);
    if (info->recoveryIVL > -1)     zsocket_set_recovery_ivl(*sock, info->recoveryIVL);
    if (info->multicastHops > -1)   zsocket_set_multicast_hops(*sock, info->multicastHops);
    if (info->reconnectIVL > -1)    zsocket_set_reconnect_ivl(*sock, info->reconnectIVL);
    if (info->reconnectIVLMax > -1) zsocket_set_reconnect_ivl_max(*sock, info->reconnectIVLMax);
    if (info->ipv4Only > -1)        zsocket_set_ipv4only(*sock, info->ipv4Only);
    if (info->affinity > -1)        zsocket_set_affinity(*sock, info->affinity);
    if (info->sndHWM > -1 )         zsocket_set_sndhwm(*sock, info->sndHWM);
    if (info->rcvHWM > -1 )         zsocket_set_rcvhwm(*sock, info->rcvHWM);
    /* Set subscriptions.*/
    if (info->type == ZMQ_SUB) {
        for(sub = info->subscriptions; sub!=NULL; sub=sub->next) {
            zsocket_set_subscribe(*sock, sub->subscribe);
        }
    }
 
     /* Do the bind/connect... */
     if (info->action==ACTION_CONNECT) {
        rv = zsocket_connect(*sock, ""%s"", info->description);
         if (rv == -1) {
             errmsg.LogError(0,
                             RS_RET_INVALID_PARAMS,
                            ""zmq_connect using %s failed: %s"",
                            info->description, zmq_strerror(errno));
            return RS_RET_INVALID_PARAMS;
         }
         DBGPRINTF(""imzmq3: connect for %s successful\n"",info->description);
     } else {
        rv = zsocket_bind(*sock, ""%s"", info->description);
         if (rv == -1) {
             errmsg.LogError(0,
                             RS_RET_INVALID_PARAMS,
                            ""zmq_bind using %s failed: %s"",
                            info->description, zmq_strerror(errno));
            return RS_RET_INVALID_PARAMS;
        }
        DBGPRINTF(""imzmq3: bind for %s successful\n"",info->description);
    }
    return RS_RET_OK;
}
","static rsRetVal createSocket(instanceConf_t* info, void** sock) {
    int rv;
    sublist* sub;

    *sock = zsocket_new(s_context, info->type);
    if (!sock) {
        errmsg.LogError(0,
                        RS_RET_INVALID_PARAMS,
                        ""zsocket_new failed: %s, for type %d"",
                        zmq_strerror(errno),info->type);
        /* DK: invalid params seems right here */
        return RS_RET_INVALID_PARAMS;
    }
    DBGPRINTF(""imzmq3: socket of type %d created successfully\n"", info->type)
    /* Set options *before* the connect/bind. */
    if (info->identity)             zsocket_set_identity(*sock, info->identity);
    if (info->sndBuf > -1)          zsocket_set_sndbuf(*sock, info->sndBuf);
    if (info->rcvBuf > -1)          zsocket_set_rcvbuf(*sock, info->rcvBuf);
    if (info->linger > -1)          zsocket_set_linger(*sock, info->linger);
    if (info->backlog > -1)         zsocket_set_backlog(*sock, info->backlog);
    if (info->sndTimeout > -1)      zsocket_set_sndtimeo(*sock, info->sndTimeout);
    if (info->rcvTimeout > -1)      zsocket_set_rcvtimeo(*sock, info->rcvTimeout);
    if (info->maxMsgSize > -1)      zsocket_set_maxmsgsize(*sock, info->maxMsgSize);
    if (info->rate > -1)            zsocket_set_rate(*sock, info->rate);
    if (info->recoveryIVL > -1)     zsocket_set_recovery_ivl(*sock, info->recoveryIVL);
    if (info->multicastHops > -1)   zsocket_set_multicast_hops(*sock, info->multicastHops);
    if (info->reconnectIVL > -1)    zsocket_set_reconnect_ivl(*sock, info->reconnectIVL);
    if (info->reconnectIVLMax > -1) zsocket_set_reconnect_ivl_max(*sock, info->reconnectIVLMax);
    if (info->ipv4Only > -1)        zsocket_set_ipv4only(*sock, info->ipv4Only);
    if (info->affinity > -1)        zsocket_set_affinity(*sock, info->affinity);
    if (info->sndHWM > -1 )         zsocket_set_sndhwm(*sock, info->sndHWM);
    if (info->rcvHWM > -1 )         zsocket_set_rcvhwm(*sock, info->rcvHWM);
    /* Set subscriptions.*/
    if (info->type == ZMQ_SUB) {
        for(sub = info->subscriptions; sub!=NULL; sub=sub->next) {
            zsocket_set_subscribe(*sock, sub->subscribe);
        }
    }
 
     /* Do the bind/connect... */
     if (info->action==ACTION_CONNECT) {
        rv = zsocket_connect(*sock, info->description);
         if (rv == -1) {
             errmsg.LogError(0,
                             RS_RET_INVALID_PARAMS,
                            ""zmq_connect using %s failed: %s"",
                            info->description, zmq_strerror(errno));
            return RS_RET_INVALID_PARAMS;
         }
         DBGPRINTF(""imzmq3: connect for %s successful\n"",info->description);
     } else {
        rv = zsocket_bind(*sock, info->description);
         if (rv == -1) {
             errmsg.LogError(0,
                             RS_RET_INVALID_PARAMS,
                            ""zmq_bind using %s failed: %s"",
                            info->description, zmq_strerror(errno));
            return RS_RET_INVALID_PARAMS;
        }
        DBGPRINTF(""imzmq3: bind for %s successful\n"",info->description);
    }
    return RS_RET_OK;
}
",C,"        rv = zsocket_connect(*sock, ""%s"", info->description);
        rv = zsocket_bind(*sock, ""%s"", info->description);
","        rv = zsocket_connect(*sock, info->description);
        rv = zsocket_bind(*sock, info->description);
",,"@@ -403,7 +403,7 @@ static rsRetVal createSocket(instanceConf_t* info, void** sock) {
 
     /* Do the bind/connect... */
     if (info->action==ACTION_CONNECT) {
-        rv = zsocket_connect(*sock, info->description);
+        rv = zsocket_connect(*sock, ""%s"", info->description);
         if (rv == -1) {
             errmsg.LogError(0,
                             RS_RET_INVALID_PARAMS,
@@ -413,7 +413,7 @@ static rsRetVal createSocket(instanceConf_t* info, void** sock) {
         }
         DBGPRINTF(""imzmq3: connect for %s successful\n"",info->description);
     } else {
-        rv = zsocket_bind(*sock, info->description);
+        rv = zsocket_bind(*sock, ""%s"", info->description);
         if (rv == -1) {
             errmsg.LogError(0,
                             RS_RET_INVALID_PARAMS,",rsyslog,062d0c671a29f7c6f7dff4a2f1f35df375bbb30b,fab2e391187c598ea1009122039e83b5894b826f,1,"static rsRetVal createSocket(instanceConf_t* info, void** sock) {
    int rv;
    sublist* sub;

    *sock = zsocket_new(s_context, info->type);
    if (!sock) {
        errmsg.LogError(0,
                        RS_RET_INVALID_PARAMS,
                        ""zsocket_new failed: %s, for type %d"",
                        zmq_strerror(errno),info->type);
        /* DK: invalid params seems right here */
        return RS_RET_INVALID_PARAMS;
    }
    DBGPRINTF(""imzmq3: socket of type %d created successfully\n"", info->type)
    /* Set options *before* the connect/bind. */
    if (info->identity)             zsocket_set_identity(*sock, info->identity);
    if (info->sndBuf > -1)          zsocket_set_sndbuf(*sock, info->sndBuf);
    if (info->rcvBuf > -1)          zsocket_set_rcvbuf(*sock, info->rcvBuf);
    if (info->linger > -1)          zsocket_set_linger(*sock, info->linger);
    if (info->backlog > -1)         zsocket_set_backlog(*sock, info->backlog);
    if (info->sndTimeout > -1)      zsocket_set_sndtimeo(*sock, info->sndTimeout);
    if (info->rcvTimeout > -1)      zsocket_set_rcvtimeo(*sock, info->rcvTimeout);
    if (info->maxMsgSize > -1)      zsocket_set_maxmsgsize(*sock, info->maxMsgSize);
    if (info->rate > -1)            zsocket_set_rate(*sock, info->rate);
    if (info->recoveryIVL > -1)     zsocket_set_recovery_ivl(*sock, info->recoveryIVL);
    if (info->multicastHops > -1)   zsocket_set_multicast_hops(*sock, info->multicastHops);
    if (info->reconnectIVL > -1)    zsocket_set_reconnect_ivl(*sock, info->reconnectIVL);
    if (info->reconnectIVLMax > -1) zsocket_set_reconnect_ivl_max(*sock, info->reconnectIVLMax);
    if (info->ipv4Only > -1)        zsocket_set_ipv4only(*sock, info->ipv4Only);
    if (info->affinity > -1)        zsocket_set_affinity(*sock, info->affinity);
    if (info->sndHWM > -1 )         zsocket_set_sndhwm(*sock, info->sndHWM);
    if (info->rcvHWM > -1 )         zsocket_set_rcvhwm(*sock, info->rcvHWM);
    /* Set subscriptions.*/
    if (info->type == ZMQ_SUB) {
        for(sub = info->subscriptions; sub!=NULL; sub=sub->next) {
            zsocket_set_subscribe(*sock, sub->subscribe);
        }
    }
 
     /* Do the bind/connect... */
     if (info->action==ACTION_CONNECT) {
//flaw_line_below:
        rv = zsocket_connect(*sock, info->description);
//fix_flaw_line_below:
//        rv = zsocket_connect(*sock, ""%s"", info->description);
         if (rv == -1) {
             errmsg.LogError(0,
                             RS_RET_INVALID_PARAMS,
                            ""zmq_connect using %s failed: %s"",
                            info->description, zmq_strerror(errno));
            return RS_RET_INVALID_PARAMS;
         }
         DBGPRINTF(""imzmq3: connect for %s successful\n"",info->description);
     } else {
//flaw_line_below:
        rv = zsocket_bind(*sock, info->description);
//fix_flaw_line_below:
//        rv = zsocket_bind(*sock, ""%s"", info->description);
         if (rv == -1) {
             errmsg.LogError(0,
                             RS_RET_INVALID_PARAMS,
                            ""zmq_bind using %s failed: %s"",
                            info->description, zmq_strerror(errno));
            return RS_RET_INVALID_PARAMS;
        }
        DBGPRINTF(""imzmq3: bind for %s successful\n"",info->description);
    }
    return RS_RET_OK;
}
"
3420,181156,,Remote,Not required,Partial,CVE-2017-12588,https://www.cvedetails.com/cve/CVE-2017-12588/,CWE-134,Low,Partial,Partial,,2017-08-06,7.5,"The zmq3 input and output modules in rsyslog before 8.28.0 interpreted description fields as format strings, possibly allowing a format string attack with unspecified impact.",2017-08-14,,2,https://github.com/rsyslog/rsyslog/commit/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b,062d0c671a29f7c6f7dff4a2f1f35df375bbb30b,"Merge pull request #1565 from Whissi/fix-format-security-issue-in-zmq-modules

Fix format security issue in zmq3 modules",2,contrib/omzmq3/omzmq3.c,"{""sha"": ""d32dcbc26984d7d62a8e736fc043689321b86958"", ""filename"": ""contrib/imzmq3/imzmq3.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/rsyslog/rsyslog/blob/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b/contrib/imzmq3/imzmq3.c"", ""raw_url"": ""https://github.com/rsyslog/rsyslog/raw/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b/contrib/imzmq3/imzmq3.c"", ""contents_url"": ""https://api.github.com/repos/rsyslog/rsyslog/contents/contrib/imzmq3/imzmq3.c?ref=062d0c671a29f7c6f7dff4a2f1f35df375bbb30b"", ""patch"": ""@@ -403,7 +403,7 @@ static rsRetVal createSocket(instanceConf_t* info, void** sock) {\n \n     /* Do the bind/connect... */\n     if (info->action==ACTION_CONNECT) {\n-        rv = zsocket_connect(*sock, info->description);\n+        rv = zsocket_connect(*sock, \""%s\"", info->description);\n         if (rv == -1) {\n             errmsg.LogError(0,\n                             RS_RET_INVALID_PARAMS,\n@@ -413,7 +413,7 @@ static rsRetVal createSocket(instanceConf_t* info, void** sock) {\n         }\n         DBGPRINTF(\""imzmq3: connect for %s successful\\n\"",info->description);\n     } else {\n-        rv = zsocket_bind(*sock, info->description);\n+        rv = zsocket_bind(*sock, \""%s\"", info->description);\n         if (rv == -1) {\n             errmsg.LogError(0,\n                             RS_RET_INVALID_PARAMS,""}<_**next**_>{""sha"": ""ceb461c6df045e166345ed8f8c665ce907b737cd"", ""filename"": ""contrib/omzmq3/omzmq3.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/rsyslog/rsyslog/blob/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b/contrib/omzmq3/omzmq3.c"", ""raw_url"": ""https://github.com/rsyslog/rsyslog/raw/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b/contrib/omzmq3/omzmq3.c"", ""contents_url"": ""https://api.github.com/repos/rsyslog/rsyslog/contents/contrib/omzmq3/omzmq3.c?ref=062d0c671a29f7c6f7dff4a2f1f35df375bbb30b"", ""patch"": ""@@ -242,14 +242,14 @@ static rsRetVal initZMQ(instanceData* pData) {\n     if (pData->action == ACTION_BIND) {\n         /* bind asserts, so no need to test return val here\n            which isn't the greatest api -- oh well */\n-        if(-1 == zsocket_bind(pData->socket, (char*)pData->description)) {\n+        if(-1 == zsocket_bind(pData->socket, \""%s\"", (char*)pData->description)) {\n             errmsg.LogError(0, RS_RET_NO_ERRCODE, \""omzmq3: bind failed for %s: %s\"",\n                             pData->description, zmq_strerror(errno));\n             ABORT_FINALIZE(RS_RET_NO_ERRCODE);\n         }\n         DBGPRINTF(\""omzmq3: bind to %s successful\\n\"",pData->description);\n     } else {\n-        if(-1 == zsocket_connect(pData->socket, (char*)pData->description)) {\n+        if(-1 == zsocket_connect(pData->socket, \""%s\"", (char*)pData->description)) {\n             errmsg.LogError(0, RS_RET_NO_ERRCODE, \""omzmq3: connect failed for %s: %s\"", \n                             pData->description, zmq_strerror(errno));\n             ABORT_FINALIZE(RS_RET_NO_ERRCODE);""}","static rsRetVal initZMQ(instanceData* pData) {
    DEFiRet;
    
    /* create the context if necessary. */
    if (NULL == s_context) {
        zsys_handler_set(NULL);
        s_context = zctx_new();
        if (s_workerThreads > 0) zctx_set_iothreads(s_context, s_workerThreads);
    }
    
    pData->socket = zsocket_new(s_context, pData->type);
    if (NULL == pData->socket) {
        errmsg.LogError(0, RS_RET_NO_ERRCODE,
                        ""omzmq3: zsocket_new failed for %s: %s"",
                        pData->description, zmq_strerror(errno));
        ABORT_FINALIZE(RS_RET_NO_ERRCODE);
    }
    /* use czmq defaults for these, unless set to non-default values */
    if(pData->identity)             zsocket_set_identity(pData->socket, (char*)pData->identity);
    if(pData->sndBuf > -1)          zsocket_set_sndbuf(pData->socket, pData->sndBuf);
    if(pData->rcvBuf > -1)          zsocket_set_sndbuf(pData->socket, pData->rcvBuf);
    if(pData->linger > -1)          zsocket_set_linger(pData->socket, pData->linger);
    if(pData->backlog > -1)         zsocket_set_backlog(pData->socket, pData->backlog);
    if(pData->sndTimeout > -1)      zsocket_set_sndtimeo(pData->socket, pData->sndTimeout);
    if(pData->rcvTimeout > -1)      zsocket_set_rcvtimeo(pData->socket, pData->rcvTimeout);
    if(pData->maxMsgSize > -1)      zsocket_set_maxmsgsize(pData->socket, pData->maxMsgSize);
    if(pData->rate > -1)            zsocket_set_rate(pData->socket, pData->rate);
    if(pData->recoveryIVL > -1)     zsocket_set_recovery_ivl(pData->socket, pData->recoveryIVL);
    if(pData->multicastHops > -1)   zsocket_set_multicast_hops(pData->socket, pData->multicastHops);
    if(pData->reconnectIVL > -1)    zsocket_set_reconnect_ivl(pData->socket, pData->reconnectIVL);
    if(pData->reconnectIVLMax > -1) zsocket_set_reconnect_ivl_max(pData->socket, pData->reconnectIVLMax);
    if(pData->ipv4Only > -1)        zsocket_set_ipv4only(pData->socket, pData->ipv4Only);
    if(pData->affinity != 1)        zsocket_set_affinity(pData->socket, pData->affinity);
    if(pData->rcvHWM > -1)          zsocket_set_rcvhwm(pData->socket, pData->rcvHWM);
    if(pData->sndHWM > -1)          zsocket_set_sndhwm(pData->socket, pData->sndHWM);
    
    /* bind or connect to it */
     if (pData->action == ACTION_BIND) {
         /* bind asserts, so no need to test return val here
            which isn't the greatest api -- oh well */
        if(-1 == zsocket_bind(pData->socket, ""%s"", (char*)pData->description)) {
             errmsg.LogError(0, RS_RET_NO_ERRCODE, ""omzmq3: bind failed for %s: %s"",
                             pData->description, zmq_strerror(errno));
             ABORT_FINALIZE(RS_RET_NO_ERRCODE);
         }
         DBGPRINTF(""omzmq3: bind to %s successful\n"",pData->description);
     } else {
        if(-1 == zsocket_connect(pData->socket, ""%s"", (char*)pData->description)) {
             errmsg.LogError(0, RS_RET_NO_ERRCODE, ""omzmq3: connect failed for %s: %s"", 
                             pData->description, zmq_strerror(errno));
             ABORT_FINALIZE(RS_RET_NO_ERRCODE);
        }
        DBGPRINTF(""omzmq3: connect to %s successful"", pData->description);
    }
 finalize_it:
    RETiRet;
}
","static rsRetVal initZMQ(instanceData* pData) {
    DEFiRet;
    
    /* create the context if necessary. */
    if (NULL == s_context) {
        zsys_handler_set(NULL);
        s_context = zctx_new();
        if (s_workerThreads > 0) zctx_set_iothreads(s_context, s_workerThreads);
    }
    
    pData->socket = zsocket_new(s_context, pData->type);
    if (NULL == pData->socket) {
        errmsg.LogError(0, RS_RET_NO_ERRCODE,
                        ""omzmq3: zsocket_new failed for %s: %s"",
                        pData->description, zmq_strerror(errno));
        ABORT_FINALIZE(RS_RET_NO_ERRCODE);
    }
    /* use czmq defaults for these, unless set to non-default values */
    if(pData->identity)             zsocket_set_identity(pData->socket, (char*)pData->identity);
    if(pData->sndBuf > -1)          zsocket_set_sndbuf(pData->socket, pData->sndBuf);
    if(pData->rcvBuf > -1)          zsocket_set_sndbuf(pData->socket, pData->rcvBuf);
    if(pData->linger > -1)          zsocket_set_linger(pData->socket, pData->linger);
    if(pData->backlog > -1)         zsocket_set_backlog(pData->socket, pData->backlog);
    if(pData->sndTimeout > -1)      zsocket_set_sndtimeo(pData->socket, pData->sndTimeout);
    if(pData->rcvTimeout > -1)      zsocket_set_rcvtimeo(pData->socket, pData->rcvTimeout);
    if(pData->maxMsgSize > -1)      zsocket_set_maxmsgsize(pData->socket, pData->maxMsgSize);
    if(pData->rate > -1)            zsocket_set_rate(pData->socket, pData->rate);
    if(pData->recoveryIVL > -1)     zsocket_set_recovery_ivl(pData->socket, pData->recoveryIVL);
    if(pData->multicastHops > -1)   zsocket_set_multicast_hops(pData->socket, pData->multicastHops);
    if(pData->reconnectIVL > -1)    zsocket_set_reconnect_ivl(pData->socket, pData->reconnectIVL);
    if(pData->reconnectIVLMax > -1) zsocket_set_reconnect_ivl_max(pData->socket, pData->reconnectIVLMax);
    if(pData->ipv4Only > -1)        zsocket_set_ipv4only(pData->socket, pData->ipv4Only);
    if(pData->affinity != 1)        zsocket_set_affinity(pData->socket, pData->affinity);
    if(pData->rcvHWM > -1)          zsocket_set_rcvhwm(pData->socket, pData->rcvHWM);
    if(pData->sndHWM > -1)          zsocket_set_sndhwm(pData->socket, pData->sndHWM);
    
    /* bind or connect to it */
     if (pData->action == ACTION_BIND) {
         /* bind asserts, so no need to test return val here
            which isn't the greatest api -- oh well */
        if(-1 == zsocket_bind(pData->socket, (char*)pData->description)) {
             errmsg.LogError(0, RS_RET_NO_ERRCODE, ""omzmq3: bind failed for %s: %s"",
                             pData->description, zmq_strerror(errno));
             ABORT_FINALIZE(RS_RET_NO_ERRCODE);
         }
         DBGPRINTF(""omzmq3: bind to %s successful\n"",pData->description);
     } else {
        if(-1 == zsocket_connect(pData->socket, (char*)pData->description)) {
             errmsg.LogError(0, RS_RET_NO_ERRCODE, ""omzmq3: connect failed for %s: %s"", 
                             pData->description, zmq_strerror(errno));
             ABORT_FINALIZE(RS_RET_NO_ERRCODE);
        }
        DBGPRINTF(""omzmq3: connect to %s successful"", pData->description);
    }
 finalize_it:
    RETiRet;
}
",C,"        if(-1 == zsocket_bind(pData->socket, ""%s"", (char*)pData->description)) {
        if(-1 == zsocket_connect(pData->socket, ""%s"", (char*)pData->description)) {
","        if(-1 == zsocket_bind(pData->socket, (char*)pData->description)) {
        if(-1 == zsocket_connect(pData->socket, (char*)pData->description)) {
",,"@@ -242,14 +242,14 @@ static rsRetVal initZMQ(instanceData* pData) {
     if (pData->action == ACTION_BIND) {
         /* bind asserts, so no need to test return val here
            which isn't the greatest api -- oh well */
-        if(-1 == zsocket_bind(pData->socket, (char*)pData->description)) {
+        if(-1 == zsocket_bind(pData->socket, ""%s"", (char*)pData->description)) {
             errmsg.LogError(0, RS_RET_NO_ERRCODE, ""omzmq3: bind failed for %s: %s"",
                             pData->description, zmq_strerror(errno));
             ABORT_FINALIZE(RS_RET_NO_ERRCODE);
         }
         DBGPRINTF(""omzmq3: bind to %s successful\n"",pData->description);
     } else {
-        if(-1 == zsocket_connect(pData->socket, (char*)pData->description)) {
+        if(-1 == zsocket_connect(pData->socket, ""%s"", (char*)pData->description)) {
             errmsg.LogError(0, RS_RET_NO_ERRCODE, ""omzmq3: connect failed for %s: %s"", 
                             pData->description, zmq_strerror(errno));
             ABORT_FINALIZE(RS_RET_NO_ERRCODE);",rsyslog,062d0c671a29f7c6f7dff4a2f1f35df375bbb30b,fab2e391187c598ea1009122039e83b5894b826f,1,"static rsRetVal initZMQ(instanceData* pData) {
    DEFiRet;
    
    /* create the context if necessary. */
    if (NULL == s_context) {
        zsys_handler_set(NULL);
        s_context = zctx_new();
        if (s_workerThreads > 0) zctx_set_iothreads(s_context, s_workerThreads);
    }
    
    pData->socket = zsocket_new(s_context, pData->type);
    if (NULL == pData->socket) {
        errmsg.LogError(0, RS_RET_NO_ERRCODE,
                        ""omzmq3: zsocket_new failed for %s: %s"",
                        pData->description, zmq_strerror(errno));
        ABORT_FINALIZE(RS_RET_NO_ERRCODE);
    }
    /* use czmq defaults for these, unless set to non-default values */
    if(pData->identity)             zsocket_set_identity(pData->socket, (char*)pData->identity);
    if(pData->sndBuf > -1)          zsocket_set_sndbuf(pData->socket, pData->sndBuf);
    if(pData->rcvBuf > -1)          zsocket_set_sndbuf(pData->socket, pData->rcvBuf);
    if(pData->linger > -1)          zsocket_set_linger(pData->socket, pData->linger);
    if(pData->backlog > -1)         zsocket_set_backlog(pData->socket, pData->backlog);
    if(pData->sndTimeout > -1)      zsocket_set_sndtimeo(pData->socket, pData->sndTimeout);
    if(pData->rcvTimeout > -1)      zsocket_set_rcvtimeo(pData->socket, pData->rcvTimeout);
    if(pData->maxMsgSize > -1)      zsocket_set_maxmsgsize(pData->socket, pData->maxMsgSize);
    if(pData->rate > -1)            zsocket_set_rate(pData->socket, pData->rate);
    if(pData->recoveryIVL > -1)     zsocket_set_recovery_ivl(pData->socket, pData->recoveryIVL);
    if(pData->multicastHops > -1)   zsocket_set_multicast_hops(pData->socket, pData->multicastHops);
    if(pData->reconnectIVL > -1)    zsocket_set_reconnect_ivl(pData->socket, pData->reconnectIVL);
    if(pData->reconnectIVLMax > -1) zsocket_set_reconnect_ivl_max(pData->socket, pData->reconnectIVLMax);
    if(pData->ipv4Only > -1)        zsocket_set_ipv4only(pData->socket, pData->ipv4Only);
    if(pData->affinity != 1)        zsocket_set_affinity(pData->socket, pData->affinity);
    if(pData->rcvHWM > -1)          zsocket_set_rcvhwm(pData->socket, pData->rcvHWM);
    if(pData->sndHWM > -1)          zsocket_set_sndhwm(pData->socket, pData->sndHWM);
    
    /* bind or connect to it */
     if (pData->action == ACTION_BIND) {
         /* bind asserts, so no need to test return val here
            which isn't the greatest api -- oh well */
//flaw_line_below:
        if(-1 == zsocket_bind(pData->socket, (char*)pData->description)) {
//fix_flaw_line_below:
//        if(-1 == zsocket_bind(pData->socket, ""%s"", (char*)pData->description)) {
             errmsg.LogError(0, RS_RET_NO_ERRCODE, ""omzmq3: bind failed for %s: %s"",
                             pData->description, zmq_strerror(errno));
             ABORT_FINALIZE(RS_RET_NO_ERRCODE);
         }
         DBGPRINTF(""omzmq3: bind to %s successful\n"",pData->description);
     } else {
//flaw_line_below:
        if(-1 == zsocket_connect(pData->socket, (char*)pData->description)) {
//fix_flaw_line_below:
//        if(-1 == zsocket_connect(pData->socket, ""%s"", (char*)pData->description)) {
             errmsg.LogError(0, RS_RET_NO_ERRCODE, ""omzmq3: connect failed for %s: %s"", 
                             pData->description, zmq_strerror(errno));
             ABORT_FINALIZE(RS_RET_NO_ERRCODE);
        }
        DBGPRINTF(""omzmq3: connect to %s successful"", pData->description);
    }
 finalize_it:
    RETiRet;
}
"
