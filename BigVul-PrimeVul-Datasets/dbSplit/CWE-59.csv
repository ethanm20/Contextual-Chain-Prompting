,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
121,177857,,Remote,Not required,Partial,CVE-2019-13636,https://www.cvedetails.com/cve/CVE-2019-13636/,CWE-59,Medium,,Partial,,2019-07-17,5.8,"In GNU patch through 2.7.6, the following of symlinks is mishandled in certain cases other than input files. This affects inp.c and util.c.",2019-07-24,,6,https://git.savannah.gnu.org/cgit/patch.git/commit/?id=dce4683cbbe107a95f1f0d45fabc304acfb5d71a,dce4683cbbe107a95f1f0d45fabc304acfb5d71a,,1,,,"plan_a (char const *filename)
{
  char const *s;
  char const *lim;
  char const **ptr;
  char *buffer;
  lin iline;
  size_t size = instat.st_size;

  /* Fail if the file size doesn't fit in a size_t,
     or if storage isn't available.  */
  if (! (size == instat.st_size
	 && (buffer = malloc (size ? size : (size_t) 1))))
    return false;

  /* Read the input file, but don't bother reading it if it's empty.
     When creating files, the files do not actually exist.  */
  if (size)
     {
       if (S_ISREG (instat.st_mode))
         {
	  int flags = O_RDONLY | binary_transput;
 	  size_t buffered = 0, n;
	  int ifd;

	  if (! follow_symlinks)
	    flags |= O_NOFOLLOW;
	  ifd = safe_open (filename, flags, 0);
 	  if (ifd < 0)
 	    pfatal (""can't open file %s"", quotearg (filename));
 
		  /* Some non-POSIX hosts exaggerate st_size in text mode;
		     or the file may have shrunk!  */
		  size = buffered;
		  break;
		}
	      if (n == (size_t) -1)
		{
		  /* Perhaps size is too large for this host.  */
		  close (ifd);
		  free (buffer);
		  return false;
		}
	      buffered += n;
	    }

	  if (close (ifd) != 0)
	    read_fatal ();
	}
","plan_a (char const *filename)
{
  char const *s;
  char const *lim;
  char const **ptr;
  char *buffer;
  lin iline;
  size_t size = instat.st_size;

  /* Fail if the file size doesn't fit in a size_t,
     or if storage isn't available.  */
  if (! (size == instat.st_size
	 && (buffer = malloc (size ? size : (size_t) 1))))
    return false;

  /* Read the input file, but don't bother reading it if it's empty.
     When creating files, the files do not actually exist.  */
  if (size)
     {
       if (S_ISREG (instat.st_mode))
         {
	  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);
 	  size_t buffered = 0, n;
 	  if (ifd < 0)
 	    pfatal (""can't open file %s"", quotearg (filename));
 
		  /* Some non-POSIX hosts exaggerate st_size in text mode;
		     or the file may have shrunk!  */
		  size = buffered;
		  break;
		}
	      if (n == (size_t) -1)
		{
		  /* Perhaps size is too large for this host.  */
		  close (ifd);
		  free (buffer);
		  return false;
		}
	      buffered += n;
	    }

	  if (close (ifd) != 0)
	    read_fatal ();
	}
",C,"	  int flags = O_RDONLY | binary_transput;
	  int ifd;

	  if (! follow_symlinks)
	    flags |= O_NOFOLLOW;
	  ifd = safe_open (filename, flags, 0);
","	  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);
",61d7788b83b302207a67b82786f4fd79e3538f30,"@@ -238,8 +238,13 @@ plan_a (char const *filename)
     {
       if (S_ISREG (instat.st_mode))
         {
-	  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);
+	  int flags = O_RDONLY | binary_transput;
 	  size_t buffered = 0, n;
+	  int ifd;
+
+	  if (! follow_symlinks)
+	    flags |= O_NOFOLLOW;
+	  ifd = safe_open (filename, flags, 0);
 	  if (ifd < 0)
 	    pfatal (""can't open file %s"", quotearg (filename));
 
@@ -340,6 +345,7 @@ plan_a (char const *filename)
 static void
 plan_b (char const *filename)
 {
+  int flags = O_RDONLY | binary_transput;
   int ifd;
   FILE *ifp;
   int c;
@@ -353,7 +359,9 @@ plan_b (char const *filename)
 
   if (instat.st_size == 0)
     filename = NULL_DEVICE;
-  if ((ifd = safe_open (filename, O_RDONLY | binary_transput, 0)) < 0
+  if (! follow_symlinks)
+    flags |= O_NOFOLLOW;
+  if ((ifd = safe_open (filename, flags, 0)) < 0
       || ! (ifp = fdopen (ifd, binary_transput ? ""rb"" : ""r"")))
     pfatal (""Can't open file %s"", quotearg (filename));
   if (TMPINNAME_needs_removal)",savannah,https://git.savannah.gnu.org/cgit/patch.git/tree/src/inp.c?id=dce4683cbbe107a95f1f0d45fabc304acfb5d71a,https://git.savannah.gnu.org/cgit/patch.git/tree/src/inp.c?id=61d7788b83b302207a67b82786f4fd79e3538f30,1,"plan_a (char const *filename)
{
  char const *s;
  char const *lim;
  char const **ptr;
  char *buffer;
  lin iline;
  size_t size = instat.st_size;

  /* Fail if the file size doesn't fit in a size_t,
     or if storage isn't available.  */
  if (! (size == instat.st_size
	 && (buffer = malloc (size ? size : (size_t) 1))))
    return false;

  /* Read the input file, but don't bother reading it if it's empty.
     When creating files, the files do not actually exist.  */
  if (size)
     {
       if (S_ISREG (instat.st_mode))
         {
//flaw_line_below:
	  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);
//fix_flaw_line_below:
//	  int flags = O_RDONLY | binary_transput;
 	  size_t buffered = 0, n;
//fix_flaw_line_below:
//	  int ifd;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	  if (! follow_symlinks)
//fix_flaw_line_below:
//	    flags |= O_NOFOLLOW;
//fix_flaw_line_below:
//	  ifd = safe_open (filename, flags, 0);
 	  if (ifd < 0)
 	    pfatal (""can't open file %s"", quotearg (filename));
 
		  /* Some non-POSIX hosts exaggerate st_size in text mode;
		     or the file may have shrunk!  */
		  size = buffered;
		  break;
		}
	      if (n == (size_t) -1)
		{
		  /* Perhaps size is too large for this host.  */
		  close (ifd);
		  free (buffer);
		  return false;
		}
	      buffered += n;
	    }

	  if (close (ifd) != 0)
	    read_fatal ();
	}
"
604,178340,,Local,Not required,Partial,CVE-2010-0787,https://www.cvedetails.com/cve/CVE-2010-0787/,CWE-59,Medium,Partial,Partial,,2010-03-02,4.4,"client/mount.cifs.c in mount.cifs in smbfs in Samba 3.0.22, 3.0.28a, 3.2.3, 3.3.2, 3.4.0, and 3.4.5 allows local users to mount a CIFS share on an arbitrary mountpoint, and gain privileges, via a symlink attack on the mountpoint directory file.",2017-08-16,+Priv,1,https://git.samba.org/?p=samba.git;a=commit;h=3ae5dac462c4ed0fb2cd94553583c56fce2f9d80,3ae5dac462c4ed0fb2cd94553583c56fce2f9d80,,1,,,"check_mountpoint(const char *progname, char *mountpoint)
{
	int err;
        struct stat statbuf;
 
        /* does mountpoint exist and is it a directory? */
       err = stat(""."", &statbuf);
        if (err) {
                fprintf(stderr, ""%s: failed to stat %s: %s\n"", progname,
                                mountpoint, strerror(errno));
		return EX_USAGE;
	}

	if (!S_ISDIR(statbuf.st_mode)) {
		fprintf(stderr, ""%s: %s is not a directory!"", progname,
				mountpoint);
		return EX_USAGE;
	}

#if CIFS_LEGACY_SETUID_CHECK
	/* do extra checks on mountpoint for legacy setuid behavior */
	if (!getuid() || geteuid())
		return 0;

	if (statbuf.st_uid != getuid()) {
		fprintf(stderr, ""%s: %s is not owned by user\n"", progname,
			mountpoint);
		return EX_USAGE;
	}

	if ((statbuf.st_mode & S_IRWXU) != S_IRWXU) {
		fprintf(stderr, ""%s: invalid permissions on %s\n"", progname,
			mountpoint);
		return EX_USAGE;
	}
#endif /* CIFS_LEGACY_SETUID_CHECK */

	return 0;
}
","check_mountpoint(const char *progname, char *mountpoint)
{
	int err;
        struct stat statbuf;
 
        /* does mountpoint exist and is it a directory? */
       err = stat(mountpoint, &statbuf);
        if (err) {
                fprintf(stderr, ""%s: failed to stat %s: %s\n"", progname,
                                mountpoint, strerror(errno));
		return EX_USAGE;
	}

	if (!S_ISDIR(statbuf.st_mode)) {
		fprintf(stderr, ""%s: %s is not a directory!"", progname,
				mountpoint);
		return EX_USAGE;
	}

#if CIFS_LEGACY_SETUID_CHECK
	/* do extra checks on mountpoint for legacy setuid behavior */
	if (!getuid() || geteuid())
		return 0;

	if (statbuf.st_uid != getuid()) {
		fprintf(stderr, ""%s: %s is not owned by user\n"", progname,
			mountpoint);
		return EX_USAGE;
	}

	if ((statbuf.st_mode & S_IRWXU) != S_IRWXU) {
		fprintf(stderr, ""%s: invalid permissions on %s\n"", progname,
			mountpoint);
		return EX_USAGE;
	}
#endif /* CIFS_LEGACY_SETUID_CHECK */

	return 0;
}
",C,"       err = stat(""."", &statbuf);
","       err = stat(mountpoint, &statbuf);
",7148eff0b7f3a58be2d2c47516a8b9e3bc3d3c64,"@@ -178,7 +178,7 @@ check_mountpoint(const char *progname, char *mountpoint)
        struct stat statbuf;
 
        /* does mountpoint exist and is it a directory? */
-       err = stat(mountpoint, &statbuf);
+       err = stat(""."", &statbuf);
        if (err) {
                fprintf(stderr, ""%s: failed to stat %s: %s\n"", progname,
                                mountpoint, strerror(errno));
@@ -1377,6 +1377,14 @@ int main(int argc, char ** argv)
        }
 
        /* make sure mountpoint is legit */
+       rc = chdir(mountpoint);
+       if (rc) {
+               fprintf(stderr, ""Couldn't chdir to %s: %s\n"", mountpoint,
+                               strerror(errno));
+               rc = EX_USAGE;
+               goto mount_exit;
+       }
+
        rc = check_mountpoint(thisprogram, mountpoint);
        if (rc)
                goto mount_exit;
@@ -1439,13 +1447,23 @@ int main(int argc, char ** argv)
        
        /* BB save off path and pop after mount returns? */
        resolved_path = (char *)malloc(PATH_MAX+1);
-       if(resolved_path) {
-               /* Note that if we can not canonicalize the name, we get
-               another chance to see if it is valid when we chdir to it */
-               if (realpath(mountpoint, resolved_path)) {
-                       mountpoint = resolved_path; 
-               }
+       if (!resolved_path) {
+               fprintf(stderr, ""Unable to allocate memory.\n"");
+               rc = EX_SYSERR;
+               goto mount_exit;
        }
+
+       /* Note that if we can not canonicalize the name, we get
+          another chance to see if it is valid when we chdir to it */
+       if(!realpath(""."", resolved_path)) {
+               fprintf(stderr, ""Unable to resolve %s to canonical path: %s\n"",
+                               mountpoint, strerror(errno));
+               rc = EX_SYSERR;
+               goto mount_exit;
+       }
+
+       mountpoint = resolved_path; 
+
        if(got_user == 0) {
                /* Note that the password will not be retrieved from the
                   USER env variable (ie user%password form) as there is
@@ -1589,7 +1607,7 @@ mount_retry:
        if (verboseflag)
                fprintf(stderr, ""\n"");
 
-       if (!fakemnt && mount(dev_name, mountpoint, cifs_fstype, flags, options)) {
+       if (!fakemnt && mount(dev_name, ""."", cifs_fstype, flags, options)) {
                switch (errno) {
                case ECONNREFUSED:
                case EHOSTUNREACH:",samba,https://git.samba.org/?p=samba.git;a=blob;f=client/mount.cifs.c;h=f30418bfc268f7a994d00395b63640039df497d7;hb=3ae5dac462c4ed0fb2cd94553583c56fce2f9d80,https://git.samba.org/?p=samba.git;a=blob;f=client/mount.cifs.c;h=459a9f34a95281195150fd2acfbeb83b85095142,1,"check_mountpoint(const char *progname, char *mountpoint)
{
	int err;
        struct stat statbuf;
 
        /* does mountpoint exist and is it a directory? */
//flaw_line_below:
       err = stat(mountpoint, &statbuf);
//fix_flaw_line_below:
//       err = stat(""."", &statbuf);
        if (err) {
                fprintf(stderr, ""%s: failed to stat %s: %s\n"", progname,
                                mountpoint, strerror(errno));
		return EX_USAGE;
	}

	if (!S_ISDIR(statbuf.st_mode)) {
		fprintf(stderr, ""%s: %s is not a directory!"", progname,
				mountpoint);
		return EX_USAGE;
	}

#if CIFS_LEGACY_SETUID_CHECK
	/* do extra checks on mountpoint for legacy setuid behavior */
	if (!getuid() || geteuid())
		return 0;

	if (statbuf.st_uid != getuid()) {
		fprintf(stderr, ""%s: %s is not owned by user\n"", progname,
			mountpoint);
		return EX_USAGE;
	}

	if ((statbuf.st_mode & S_IRWXU) != S_IRWXU) {
		fprintf(stderr, ""%s: invalid permissions on %s\n"", progname,
			mountpoint);
		return EX_USAGE;
	}
#endif /* CIFS_LEGACY_SETUID_CHECK */

	return 0;
}
"
605,178341,,Local,Not required,Partial,CVE-2010-0787,https://www.cvedetails.com/cve/CVE-2010-0787/,CWE-59,Medium,Partial,Partial,,2010-03-02,4.4,"client/mount.cifs.c in mount.cifs in smbfs in Samba 3.0.22, 3.0.28a, 3.2.3, 3.3.2, 3.4.0, and 3.4.5 allows local users to mount a CIFS share on an arbitrary mountpoint, and gain privileges, via a symlink attack on the mountpoint directory file.",2017-08-16,+Priv,8,https://git.samba.org/?p=samba.git;a=commit;h=3ae5dac462c4ed0fb2cd94553583c56fce2f9d80,3ae5dac462c4ed0fb2cd94553583c56fce2f9d80,,0,,,"int main(int argc, char ** argv)
{
	int c;
	unsigned long flags = MS_MANDLOCK;
	char * orgoptions = NULL;
	char * share_name = NULL;
	const char * ipaddr = NULL;
	char * uuid = NULL;
	char * mountpoint = NULL;
	char * options = NULL;
	char * optionstail;
	char * resolved_path = NULL;
	char * temp;
	char * dev_name;
	int rc = 0;
	int rsize = 0;
	int wsize = 0;
	int nomtab = 0;
	int uid = 0;
	int gid = 0;
	int optlen = 0;
	int orgoptlen = 0;
	size_t options_size = 0;
	size_t current_len;
	int retry = 0; /* set when we have to retry mount with uppercase */
	struct addrinfo *addrhead = NULL, *addr;
	struct utsname sysinfo;
	struct mntent mountent;
	struct sockaddr_in *addr4;
	struct sockaddr_in6 *addr6;
	FILE * pmntfile;

	/* setlocale(LC_ALL, """");
	bindtextdomain(PACKAGE, LOCALEDIR);
	textdomain(PACKAGE); */

	if(argc && argv)
		thisprogram = argv[0];
	else
		mount_cifs_usage(stderr);

	if(thisprogram == NULL)
		thisprogram = ""mount.cifs"";

	uname(&sysinfo);
	/* BB add workstation name and domain and pass down */

/* #ifdef _GNU_SOURCE
	fprintf(stderr, "" node: %s machine: %s sysname %s domain %s\n"", sysinfo.nodename,sysinfo.machine,sysinfo.sysname,sysinfo.domainname);
#endif */
	if(argc > 2) {
		dev_name = argv[1];
		share_name = strndup(argv[1], MAX_UNC_LEN);
		if (share_name == NULL) {
			fprintf(stderr, ""%s: %s"", argv[0], strerror(ENOMEM));
			exit(EX_SYSERR);
		}
		mountpoint = argv[2];
	} else if (argc == 2) {
		if ((strcmp(argv[1], ""-V"") == 0) ||
		    (strcmp(argv[1], ""--version"") == 0))
		{
			print_cifs_mount_version();
			exit(0);
		}

		if ((strcmp(argv[1], ""-h"") == 0) ||
		    (strcmp(argv[1], ""-?"") == 0) ||
		    (strcmp(argv[1], ""--help"") == 0))
			mount_cifs_usage(stdout);

		mount_cifs_usage(stderr);
	} else {
		mount_cifs_usage(stderr);
	}


	/* add sharename in opts string as unc= parm */
	while ((c = getopt_long (argc, argv, ""afFhilL:no:O:rsSU:vVwt:"",
			 longopts, NULL)) != -1) {
		switch (c) {
/* No code to do the following  options yet */
/*	case 'l':
		list_with_volumelabel = 1;
		break;
	case 'L':
		volumelabel = optarg;
		break; */
/*	case 'a':	       
		++mount_all;
		break; */

		case '?':
		case 'h':	 /* help */
			mount_cifs_usage(stdout);
		case 'n':
			++nomtab;
			break;
		case 'b':
#ifdef MS_BIND
			flags |= MS_BIND;
#else
			fprintf(stderr,
				""option 'b' (MS_BIND) not supported\n"");
#endif
			break;
		case 'm':
#ifdef MS_MOVE		      
			flags |= MS_MOVE;
#else
			fprintf(stderr,
				""option 'm' (MS_MOVE) not supported\n"");
#endif
			break;
		case 'o':
			orgoptions = strdup(optarg);
		    break;
		case 'r':  /* mount readonly */
			flags |= MS_RDONLY;
			break;
		case 'U':
			uuid = optarg;
			break;
		case 'v':
			++verboseflag;
			break;
		case 'V':
			print_cifs_mount_version();
			exit (0);
		case 'w':
			flags &= ~MS_RDONLY;
			break;
		case 'R':
			rsize = atoi(optarg) ;
			break;
		case 'W':
			wsize = atoi(optarg);
			break;
		case '1':
			if (isdigit(*optarg)) {
				char *ep;

				uid = strtoul(optarg, &ep, 10);
				if (*ep) {
					fprintf(stderr, ""bad uid value \""%s\""\n"", optarg);
					exit(EX_USAGE);
				}
			} else {
				struct passwd *pw;

				if (!(pw = getpwnam(optarg))) {
					fprintf(stderr, ""bad user name \""%s\""\n"", optarg);
					exit(EX_USAGE);
				}
				uid = pw->pw_uid;
				endpwent();
			}
			break;
		case '2':
			if (isdigit(*optarg)) {
				char *ep;

				gid = strtoul(optarg, &ep, 10);
				if (*ep) {
					fprintf(stderr, ""bad gid value \""%s\""\n"", optarg);
					exit(EX_USAGE);
				}
			} else {
				struct group *gr;

				if (!(gr = getgrnam(optarg))) {
					fprintf(stderr, ""bad user name \""%s\""\n"", optarg);
					exit(EX_USAGE);
				}
				gid = gr->gr_gid;
				endpwent();
			}
			break;
		case 'u':
			got_user = 1;
			user_name = optarg;
			break;
		case 'd':
			domain_name = optarg; /* BB fix this - currently ignored */
			got_domain = 1;
			break;
		case 'p':
			if(mountpassword == NULL)
				mountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);
			if(mountpassword) {
				got_password = 1;
				strlcpy(mountpassword,optarg,MOUNT_PASSWD_SIZE+1);
			}
			break;
		case 'S':
			get_password_from_file(0 /* stdin */,NULL);
			break;
		case 't':
			break;
		case 'f':
			++fakemnt;
			break;
		default:
			fprintf(stderr, ""unknown mount option %c\n"",c);
			mount_cifs_usage(stderr);
		}
	}

	if((argc < 3) || (dev_name == NULL) || (mountpoint == NULL)) {
		mount_cifs_usage(stderr);
        }
 
        /* make sure mountpoint is legit */
       rc = chdir(mountpoint);
       if (rc) {
               fprintf(stderr, ""Couldn't chdir to %s: %s\n"", mountpoint,
                               strerror(errno));
               rc = EX_USAGE;
               goto mount_exit;
       }

        rc = check_mountpoint(thisprogram, mountpoint);
        if (rc)
                goto mount_exit;
		/* enable any default user mount flags */
		flags |= CIFS_SETUID_FLAGS;
	}
","int main(int argc, char ** argv)
{
	int c;
	unsigned long flags = MS_MANDLOCK;
	char * orgoptions = NULL;
	char * share_name = NULL;
	const char * ipaddr = NULL;
	char * uuid = NULL;
	char * mountpoint = NULL;
	char * options = NULL;
	char * optionstail;
	char * resolved_path = NULL;
	char * temp;
	char * dev_name;
	int rc = 0;
	int rsize = 0;
	int wsize = 0;
	int nomtab = 0;
	int uid = 0;
	int gid = 0;
	int optlen = 0;
	int orgoptlen = 0;
	size_t options_size = 0;
	size_t current_len;
	int retry = 0; /* set when we have to retry mount with uppercase */
	struct addrinfo *addrhead = NULL, *addr;
	struct utsname sysinfo;
	struct mntent mountent;
	struct sockaddr_in *addr4;
	struct sockaddr_in6 *addr6;
	FILE * pmntfile;

	/* setlocale(LC_ALL, """");
	bindtextdomain(PACKAGE, LOCALEDIR);
	textdomain(PACKAGE); */

	if(argc && argv)
		thisprogram = argv[0];
	else
		mount_cifs_usage(stderr);

	if(thisprogram == NULL)
		thisprogram = ""mount.cifs"";

	uname(&sysinfo);
	/* BB add workstation name and domain and pass down */

/* #ifdef _GNU_SOURCE
	fprintf(stderr, "" node: %s machine: %s sysname %s domain %s\n"", sysinfo.nodename,sysinfo.machine,sysinfo.sysname,sysinfo.domainname);
#endif */
	if(argc > 2) {
		dev_name = argv[1];
		share_name = strndup(argv[1], MAX_UNC_LEN);
		if (share_name == NULL) {
			fprintf(stderr, ""%s: %s"", argv[0], strerror(ENOMEM));
			exit(EX_SYSERR);
		}
		mountpoint = argv[2];
	} else if (argc == 2) {
		if ((strcmp(argv[1], ""-V"") == 0) ||
		    (strcmp(argv[1], ""--version"") == 0))
		{
			print_cifs_mount_version();
			exit(0);
		}

		if ((strcmp(argv[1], ""-h"") == 0) ||
		    (strcmp(argv[1], ""-?"") == 0) ||
		    (strcmp(argv[1], ""--help"") == 0))
			mount_cifs_usage(stdout);

		mount_cifs_usage(stderr);
	} else {
		mount_cifs_usage(stderr);
	}


	/* add sharename in opts string as unc= parm */
	while ((c = getopt_long (argc, argv, ""afFhilL:no:O:rsSU:vVwt:"",
			 longopts, NULL)) != -1) {
		switch (c) {
/* No code to do the following  options yet */
/*	case 'l':
		list_with_volumelabel = 1;
		break;
	case 'L':
		volumelabel = optarg;
		break; */
/*	case 'a':	       
		++mount_all;
		break; */

		case '?':
		case 'h':	 /* help */
			mount_cifs_usage(stdout);
		case 'n':
			++nomtab;
			break;
		case 'b':
#ifdef MS_BIND
			flags |= MS_BIND;
#else
			fprintf(stderr,
				""option 'b' (MS_BIND) not supported\n"");
#endif
			break;
		case 'm':
#ifdef MS_MOVE		      
			flags |= MS_MOVE;
#else
			fprintf(stderr,
				""option 'm' (MS_MOVE) not supported\n"");
#endif
			break;
		case 'o':
			orgoptions = strdup(optarg);
		    break;
		case 'r':  /* mount readonly */
			flags |= MS_RDONLY;
			break;
		case 'U':
			uuid = optarg;
			break;
		case 'v':
			++verboseflag;
			break;
		case 'V':
			print_cifs_mount_version();
			exit (0);
		case 'w':
			flags &= ~MS_RDONLY;
			break;
		case 'R':
			rsize = atoi(optarg) ;
			break;
		case 'W':
			wsize = atoi(optarg);
			break;
		case '1':
			if (isdigit(*optarg)) {
				char *ep;

				uid = strtoul(optarg, &ep, 10);
				if (*ep) {
					fprintf(stderr, ""bad uid value \""%s\""\n"", optarg);
					exit(EX_USAGE);
				}
			} else {
				struct passwd *pw;

				if (!(pw = getpwnam(optarg))) {
					fprintf(stderr, ""bad user name \""%s\""\n"", optarg);
					exit(EX_USAGE);
				}
				uid = pw->pw_uid;
				endpwent();
			}
			break;
		case '2':
			if (isdigit(*optarg)) {
				char *ep;

				gid = strtoul(optarg, &ep, 10);
				if (*ep) {
					fprintf(stderr, ""bad gid value \""%s\""\n"", optarg);
					exit(EX_USAGE);
				}
			} else {
				struct group *gr;

				if (!(gr = getgrnam(optarg))) {
					fprintf(stderr, ""bad user name \""%s\""\n"", optarg);
					exit(EX_USAGE);
				}
				gid = gr->gr_gid;
				endpwent();
			}
			break;
		case 'u':
			got_user = 1;
			user_name = optarg;
			break;
		case 'd':
			domain_name = optarg; /* BB fix this - currently ignored */
			got_domain = 1;
			break;
		case 'p':
			if(mountpassword == NULL)
				mountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);
			if(mountpassword) {
				got_password = 1;
				strlcpy(mountpassword,optarg,MOUNT_PASSWD_SIZE+1);
			}
			break;
		case 'S':
			get_password_from_file(0 /* stdin */,NULL);
			break;
		case 't':
			break;
		case 'f':
			++fakemnt;
			break;
		default:
			fprintf(stderr, ""unknown mount option %c\n"",c);
			mount_cifs_usage(stderr);
		}
	}

	if((argc < 3) || (dev_name == NULL) || (mountpoint == NULL)) {
		mount_cifs_usage(stderr);
        }
 
        /* make sure mountpoint is legit */
        rc = check_mountpoint(thisprogram, mountpoint);
        if (rc)
                goto mount_exit;
		/* enable any default user mount flags */
		flags |= CIFS_SETUID_FLAGS;
	}
",C,"       rc = chdir(mountpoint);
       if (rc) {
               fprintf(stderr, ""Couldn't chdir to %s: %s\n"", mountpoint,
                               strerror(errno));
               rc = EX_USAGE;
               goto mount_exit;
       }

",,7148eff0b7f3a58be2d2c47516a8b9e3bc3d3c64,"@@ -178,7 +178,7 @@ check_mountpoint(const char *progname, char *mountpoint)
        struct stat statbuf;
 
        /* does mountpoint exist and is it a directory? */
-       err = stat(mountpoint, &statbuf);
+       err = stat(""."", &statbuf);
        if (err) {
                fprintf(stderr, ""%s: failed to stat %s: %s\n"", progname,
                                mountpoint, strerror(errno));
@@ -1377,6 +1377,14 @@ int main(int argc, char ** argv)
        }
 
        /* make sure mountpoint is legit */
+       rc = chdir(mountpoint);
+       if (rc) {
+               fprintf(stderr, ""Couldn't chdir to %s: %s\n"", mountpoint,
+                               strerror(errno));
+               rc = EX_USAGE;
+               goto mount_exit;
+       }
+
        rc = check_mountpoint(thisprogram, mountpoint);
        if (rc)
                goto mount_exit;
@@ -1439,13 +1447,23 @@ int main(int argc, char ** argv)
        
        /* BB save off path and pop after mount returns? */
        resolved_path = (char *)malloc(PATH_MAX+1);
-       if(resolved_path) {
-               /* Note that if we can not canonicalize the name, we get
-               another chance to see if it is valid when we chdir to it */
-               if (realpath(mountpoint, resolved_path)) {
-                       mountpoint = resolved_path; 
-               }
+       if (!resolved_path) {
+               fprintf(stderr, ""Unable to allocate memory.\n"");
+               rc = EX_SYSERR;
+               goto mount_exit;
        }
+
+       /* Note that if we can not canonicalize the name, we get
+          another chance to see if it is valid when we chdir to it */
+       if(!realpath(""."", resolved_path)) {
+               fprintf(stderr, ""Unable to resolve %s to canonical path: %s\n"",
+                               mountpoint, strerror(errno));
+               rc = EX_SYSERR;
+               goto mount_exit;
+       }
+
+       mountpoint = resolved_path; 
+
        if(got_user == 0) {
                /* Note that the password will not be retrieved from the
                   USER env variable (ie user%password form) as there is
@@ -1589,7 +1607,7 @@ mount_retry:
        if (verboseflag)
                fprintf(stderr, ""\n"");
 
-       if (!fakemnt && mount(dev_name, mountpoint, cifs_fstype, flags, options)) {
+       if (!fakemnt && mount(dev_name, ""."", cifs_fstype, flags, options)) {
                switch (errno) {
                case ECONNREFUSED:
                case EHOSTUNREACH:",samba,https://git.samba.org/?p=samba.git;a=blob;f=client/mount.cifs.c;h=f30418bfc268f7a994d00395b63640039df497d7;hb=3ae5dac462c4ed0fb2cd94553583c56fce2f9d80,https://git.samba.org/?p=samba.git;a=blob;f=client/mount.cifs.c;h=459a9f34a95281195150fd2acfbeb83b85095142,1,"int main(int argc, char ** argv)
{
	int c;
	unsigned long flags = MS_MANDLOCK;
	char * orgoptions = NULL;
	char * share_name = NULL;
	const char * ipaddr = NULL;
	char * uuid = NULL;
	char * mountpoint = NULL;
	char * options = NULL;
	char * optionstail;
	char * resolved_path = NULL;
	char * temp;
	char * dev_name;
	int rc = 0;
	int rsize = 0;
	int wsize = 0;
	int nomtab = 0;
	int uid = 0;
	int gid = 0;
	int optlen = 0;
	int orgoptlen = 0;
	size_t options_size = 0;
	size_t current_len;
	int retry = 0; /* set when we have to retry mount with uppercase */
	struct addrinfo *addrhead = NULL, *addr;
	struct utsname sysinfo;
	struct mntent mountent;
	struct sockaddr_in *addr4;
	struct sockaddr_in6 *addr6;
	FILE * pmntfile;

	/* setlocale(LC_ALL, """");
	bindtextdomain(PACKAGE, LOCALEDIR);
	textdomain(PACKAGE); */

	if(argc && argv)
		thisprogram = argv[0];
	else
		mount_cifs_usage(stderr);

	if(thisprogram == NULL)
		thisprogram = ""mount.cifs"";

	uname(&sysinfo);
	/* BB add workstation name and domain and pass down */

/* #ifdef _GNU_SOURCE
	fprintf(stderr, "" node: %s machine: %s sysname %s domain %s\n"", sysinfo.nodename,sysinfo.machine,sysinfo.sysname,sysinfo.domainname);
#endif */
	if(argc > 2) {
		dev_name = argv[1];
		share_name = strndup(argv[1], MAX_UNC_LEN);
		if (share_name == NULL) {
			fprintf(stderr, ""%s: %s"", argv[0], strerror(ENOMEM));
			exit(EX_SYSERR);
		}
		mountpoint = argv[2];
	} else if (argc == 2) {
		if ((strcmp(argv[1], ""-V"") == 0) ||
		    (strcmp(argv[1], ""--version"") == 0))
		{
			print_cifs_mount_version();
			exit(0);
		}

		if ((strcmp(argv[1], ""-h"") == 0) ||
		    (strcmp(argv[1], ""-?"") == 0) ||
		    (strcmp(argv[1], ""--help"") == 0))
			mount_cifs_usage(stdout);

		mount_cifs_usage(stderr);
	} else {
		mount_cifs_usage(stderr);
	}


	/* add sharename in opts string as unc= parm */
	while ((c = getopt_long (argc, argv, ""afFhilL:no:O:rsSU:vVwt:"",
			 longopts, NULL)) != -1) {
		switch (c) {
/* No code to do the following  options yet */
/*	case 'l':
		list_with_volumelabel = 1;
		break;
	case 'L':
		volumelabel = optarg;
		break; */
/*	case 'a':	       
		++mount_all;
		break; */

		case '?':
		case 'h':	 /* help */
			mount_cifs_usage(stdout);
		case 'n':
			++nomtab;
			break;
		case 'b':
#ifdef MS_BIND
			flags |= MS_BIND;
#else
			fprintf(stderr,
				""option 'b' (MS_BIND) not supported\n"");
#endif
			break;
		case 'm':
#ifdef MS_MOVE		      
			flags |= MS_MOVE;
#else
			fprintf(stderr,
				""option 'm' (MS_MOVE) not supported\n"");
#endif
			break;
		case 'o':
			orgoptions = strdup(optarg);
		    break;
		case 'r':  /* mount readonly */
			flags |= MS_RDONLY;
			break;
		case 'U':
			uuid = optarg;
			break;
		case 'v':
			++verboseflag;
			break;
		case 'V':
			print_cifs_mount_version();
			exit (0);
		case 'w':
			flags &= ~MS_RDONLY;
			break;
		case 'R':
			rsize = atoi(optarg) ;
			break;
		case 'W':
			wsize = atoi(optarg);
			break;
		case '1':
			if (isdigit(*optarg)) {
				char *ep;

				uid = strtoul(optarg, &ep, 10);
				if (*ep) {
					fprintf(stderr, ""bad uid value \""%s\""\n"", optarg);
					exit(EX_USAGE);
				}
			} else {
				struct passwd *pw;

				if (!(pw = getpwnam(optarg))) {
					fprintf(stderr, ""bad user name \""%s\""\n"", optarg);
					exit(EX_USAGE);
				}
				uid = pw->pw_uid;
				endpwent();
			}
			break;
		case '2':
			if (isdigit(*optarg)) {
				char *ep;

				gid = strtoul(optarg, &ep, 10);
				if (*ep) {
					fprintf(stderr, ""bad gid value \""%s\""\n"", optarg);
					exit(EX_USAGE);
				}
			} else {
				struct group *gr;

				if (!(gr = getgrnam(optarg))) {
					fprintf(stderr, ""bad user name \""%s\""\n"", optarg);
					exit(EX_USAGE);
				}
				gid = gr->gr_gid;
				endpwent();
			}
			break;
		case 'u':
			got_user = 1;
			user_name = optarg;
			break;
		case 'd':
			domain_name = optarg; /* BB fix this - currently ignored */
			got_domain = 1;
			break;
		case 'p':
			if(mountpassword == NULL)
				mountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);
			if(mountpassword) {
				got_password = 1;
				strlcpy(mountpassword,optarg,MOUNT_PASSWD_SIZE+1);
			}
			break;
		case 'S':
			get_password_from_file(0 /* stdin */,NULL);
			break;
		case 't':
			break;
		case 'f':
			++fakemnt;
			break;
		default:
			fprintf(stderr, ""unknown mount option %c\n"",c);
			mount_cifs_usage(stderr);
		}
	}

	if((argc < 3) || (dev_name == NULL) || (mountpoint == NULL)) {
		mount_cifs_usage(stderr);
        }
 
        /* make sure mountpoint is legit */
//fix_flaw_line_below:
//       rc = chdir(mountpoint);
//fix_flaw_line_below:
//       if (rc) {
//fix_flaw_line_below:
//               fprintf(stderr, ""Couldn't chdir to %s: %s\n"", mountpoint,
//fix_flaw_line_below:
//                               strerror(errno));
//fix_flaw_line_below:
//               rc = EX_USAGE;
//fix_flaw_line_below:
//               goto mount_exit;
//fix_flaw_line_below:
//       }
//fix_flaw_line_below:
//
        rc = check_mountpoint(thisprogram, mountpoint);
        if (rc)
                goto mount_exit;
		/* enable any default user mount flags */
		flags |= CIFS_SETUID_FLAGS;
	}
"
673,178409,,Local,Not required,,CVE-2011-4028,https://www.cvedetails.com/cve/CVE-2011-4028/,CWE-59,High,Partial,,,2012-07-03,1.2,"The LockServer function in os/utils.c in X.Org xserver before 1.11.2 allows local users to determine the existence of arbitrary files via a symlink attack on a temporary lock file, which is handled differently if the file exists.",2012-07-17,,1,https://cgit.freedesktop.org/xorg/xserver/commit/?id=6ba44b91e37622ef8c146d8f2ac92d708a18ed34,6ba44b91e37622ef8c146d8f2ac92d708a18ed34,,1,,,"LockServer(void)
{
  char tmp[PATH_MAX], pid_str[12];
  int lfd, i, haslock, l_pid, t;
  char *tmppath = NULL;
  int len;
  char port[20];

  if (nolock) return;
  /*
   * Path names
   */
  tmppath = LOCK_DIR;

  sprintf(port, ""%d"", atoi(display));
  len = strlen(LOCK_PREFIX) > strlen(LOCK_TMP_PREFIX) ? strlen(LOCK_PREFIX) :
						strlen(LOCK_TMP_PREFIX);
  len += strlen(tmppath) + strlen(port) + strlen(LOCK_SUFFIX) + 1;
  if (len > sizeof(LockFile))
    FatalError(""Display name `%s' is too long\n"", port);
  (void)sprintf(tmp, ""%s"" LOCK_TMP_PREFIX ""%s"" LOCK_SUFFIX, tmppath, port);
  (void)sprintf(LockFile, ""%s"" LOCK_PREFIX ""%s"" LOCK_SUFFIX, tmppath, port);

  /*
   * Create a temporary file containing our PID.  Attempt three times
   * to create the file.
   */
  StillLocking = TRUE;
  i = 0;
  do {
    i++;
    lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);
    if (lfd < 0)
       sleep(2);
    else
       break;
  } while (i < 3);
  if (lfd < 0) {
    unlink(tmp);
    i = 0;
    do {
      i++;
      lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);
      if (lfd < 0)
         sleep(2);
      else
         break;
    } while (i < 3);
  }
  if (lfd < 0)
    FatalError(""Could not create lock file in %s\n"", tmp);
  (void) sprintf(pid_str, ""%10ld\n"", (long)getpid());
  (void) write(lfd, pid_str, 11);
  (void) chmod(tmp, 0444);
  (void) close(lfd);

  /*
   * OK.  Now the tmp file exists.  Try three times to move it in place
   * for the lock.
   */
  i = 0;
  haslock = 0;
  while ((!haslock) && (i++ < 3)) {
    haslock = (link(tmp,LockFile) == 0);
    if (haslock) {
      /*
       * We're done.
       */
      break;
    }
    else {
       /*
        * Read the pid from the existing file
        */
      lfd = open(LockFile, O_RDONLY|O_NOFOLLOW);
       if (lfd < 0) {
         unlink(tmp);
         FatalError(""Can't read lock file %s\n"", LockFile);
      }
      pid_str[0] = '\0';
      if (read(lfd, pid_str, 11) != 11) {
        /*
         * Bogus lock file.
         */
        unlink(LockFile);
        close(lfd);
        continue;
      }
      pid_str[11] = '\0';
      sscanf(pid_str, ""%d"", &l_pid);
      close(lfd);

      /*
       * Now try to kill the PID to see if it exists.
       */
      errno = 0;
      t = kill(l_pid, 0);
      if ((t< 0) && (errno == ESRCH)) {
        /*
         * Stale lock file.
         */
        unlink(LockFile);
        continue;
      }
      else if (((t < 0) && (errno == EPERM)) || (t == 0)) {
        /*
         * Process is still active.
         */
        unlink(tmp);
	FatalError(""Server is already active for display %s\n%s %s\n%s\n"",
		   port, ""\tIf this server is no longer running, remove"",
		   LockFile, ""\tand start again."");
      }
    }
  }
  unlink(tmp);
  if (!haslock)
    FatalError(""Could not create server lock file: %s\n"", LockFile);
  StillLocking = FALSE;
}
","LockServer(void)
{
  char tmp[PATH_MAX], pid_str[12];
  int lfd, i, haslock, l_pid, t;
  char *tmppath = NULL;
  int len;
  char port[20];

  if (nolock) return;
  /*
   * Path names
   */
  tmppath = LOCK_DIR;

  sprintf(port, ""%d"", atoi(display));
  len = strlen(LOCK_PREFIX) > strlen(LOCK_TMP_PREFIX) ? strlen(LOCK_PREFIX) :
						strlen(LOCK_TMP_PREFIX);
  len += strlen(tmppath) + strlen(port) + strlen(LOCK_SUFFIX) + 1;
  if (len > sizeof(LockFile))
    FatalError(""Display name `%s' is too long\n"", port);
  (void)sprintf(tmp, ""%s"" LOCK_TMP_PREFIX ""%s"" LOCK_SUFFIX, tmppath, port);
  (void)sprintf(LockFile, ""%s"" LOCK_PREFIX ""%s"" LOCK_SUFFIX, tmppath, port);

  /*
   * Create a temporary file containing our PID.  Attempt three times
   * to create the file.
   */
  StillLocking = TRUE;
  i = 0;
  do {
    i++;
    lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);
    if (lfd < 0)
       sleep(2);
    else
       break;
  } while (i < 3);
  if (lfd < 0) {
    unlink(tmp);
    i = 0;
    do {
      i++;
      lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);
      if (lfd < 0)
         sleep(2);
      else
         break;
    } while (i < 3);
  }
  if (lfd < 0)
    FatalError(""Could not create lock file in %s\n"", tmp);
  (void) sprintf(pid_str, ""%10ld\n"", (long)getpid());
  (void) write(lfd, pid_str, 11);
  (void) chmod(tmp, 0444);
  (void) close(lfd);

  /*
   * OK.  Now the tmp file exists.  Try three times to move it in place
   * for the lock.
   */
  i = 0;
  haslock = 0;
  while ((!haslock) && (i++ < 3)) {
    haslock = (link(tmp,LockFile) == 0);
    if (haslock) {
      /*
       * We're done.
       */
      break;
    }
    else {
       /*
        * Read the pid from the existing file
        */
      lfd = open(LockFile, O_RDONLY);
       if (lfd < 0) {
         unlink(tmp);
         FatalError(""Can't read lock file %s\n"", LockFile);
      }
      pid_str[0] = '\0';
      if (read(lfd, pid_str, 11) != 11) {
        /*
         * Bogus lock file.
         */
        unlink(LockFile);
        close(lfd);
        continue;
      }
      pid_str[11] = '\0';
      sscanf(pid_str, ""%d"", &l_pid);
      close(lfd);

      /*
       * Now try to kill the PID to see if it exists.
       */
      errno = 0;
      t = kill(l_pid, 0);
      if ((t< 0) && (errno == ESRCH)) {
        /*
         * Stale lock file.
         */
        unlink(LockFile);
        continue;
      }
      else if (((t < 0) && (errno == EPERM)) || (t == 0)) {
        /*
         * Process is still active.
         */
        unlink(tmp);
	FatalError(""Server is already active for display %s\n%s %s\n%s\n"",
		   port, ""\tIf this server is no longer running, remove"",
		   LockFile, ""\tand start again."");
      }
    }
  }
  unlink(tmp);
  if (!haslock)
    FatalError(""Could not create server lock file: %s\n"", LockFile);
  StillLocking = FALSE;
}
",C,"      lfd = open(LockFile, O_RDONLY|O_NOFOLLOW);
","      lfd = open(LockFile, O_RDONLY);
",fb84be47db7cdaff406792c08e34670e8e0cbda9,"@@ -318,7 +318,7 @@ LockServer(void)
       /*
        * Read the pid from the existing file
        */
-      lfd = open(LockFile, O_RDONLY);
+      lfd = open(LockFile, O_RDONLY|O_NOFOLLOW);
       if (lfd < 0) {
         unlink(tmp);
         FatalError(""Can't read lock file %s\n"", LockFile);",xserver,https://cgit.freedesktop.org/xorg/xserver/tree/os/utils.c?id=6ba44b91e37622ef8c146d8f2ac92d708a18ed34,https://cgit.freedesktop.org/xorg/xserver/tree/os/utils.c?id=fb84be47db7cdaff406792c08e34670e8e0cbda9,1,"LockServer(void)
{
  char tmp[PATH_MAX], pid_str[12];
  int lfd, i, haslock, l_pid, t;
  char *tmppath = NULL;
  int len;
  char port[20];

  if (nolock) return;
  /*
   * Path names
   */
  tmppath = LOCK_DIR;

  sprintf(port, ""%d"", atoi(display));
  len = strlen(LOCK_PREFIX) > strlen(LOCK_TMP_PREFIX) ? strlen(LOCK_PREFIX) :
						strlen(LOCK_TMP_PREFIX);
  len += strlen(tmppath) + strlen(port) + strlen(LOCK_SUFFIX) + 1;
  if (len > sizeof(LockFile))
    FatalError(""Display name `%s' is too long\n"", port);
  (void)sprintf(tmp, ""%s"" LOCK_TMP_PREFIX ""%s"" LOCK_SUFFIX, tmppath, port);
  (void)sprintf(LockFile, ""%s"" LOCK_PREFIX ""%s"" LOCK_SUFFIX, tmppath, port);

  /*
   * Create a temporary file containing our PID.  Attempt three times
   * to create the file.
   */
  StillLocking = TRUE;
  i = 0;
  do {
    i++;
    lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);
    if (lfd < 0)
       sleep(2);
    else
       break;
  } while (i < 3);
  if (lfd < 0) {
    unlink(tmp);
    i = 0;
    do {
      i++;
      lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);
      if (lfd < 0)
         sleep(2);
      else
         break;
    } while (i < 3);
  }
  if (lfd < 0)
    FatalError(""Could not create lock file in %s\n"", tmp);
  (void) sprintf(pid_str, ""%10ld\n"", (long)getpid());
  (void) write(lfd, pid_str, 11);
  (void) chmod(tmp, 0444);
  (void) close(lfd);

  /*
   * OK.  Now the tmp file exists.  Try three times to move it in place
   * for the lock.
   */
  i = 0;
  haslock = 0;
  while ((!haslock) && (i++ < 3)) {
    haslock = (link(tmp,LockFile) == 0);
    if (haslock) {
      /*
       * We're done.
       */
      break;
    }
    else {
       /*
        * Read the pid from the existing file
        */
//flaw_line_below:
      lfd = open(LockFile, O_RDONLY);
//fix_flaw_line_below:
//      lfd = open(LockFile, O_RDONLY|O_NOFOLLOW);
       if (lfd < 0) {
         unlink(tmp);
         FatalError(""Can't read lock file %s\n"", LockFile);
      }
      pid_str[0] = '\0';
      if (read(lfd, pid_str, 11) != 11) {
        /*
         * Bogus lock file.
         */
        unlink(LockFile);
        close(lfd);
        continue;
      }
      pid_str[11] = '\0';
      sscanf(pid_str, ""%d"", &l_pid);
      close(lfd);

      /*
       * Now try to kill the PID to see if it exists.
       */
      errno = 0;
      t = kill(l_pid, 0);
      if ((t< 0) && (errno == ESRCH)) {
        /*
         * Stale lock file.
         */
        unlink(LockFile);
        continue;
      }
      else if (((t < 0) && (errno == EPERM)) || (t == 0)) {
        /*
         * Process is still active.
         */
        unlink(tmp);
	FatalError(""Server is already active for display %s\n%s %s\n%s\n"",
		   port, ""\tIf this server is no longer running, remove"",
		   LockFile, ""\tand start again."");
      }
    }
  }
  unlink(tmp);
  if (!haslock)
    FatalError(""Could not create server lock file: %s\n"", LockFile);
  StillLocking = FALSE;
}
"
1721,179457,,Local,Not required,Complete,CVE-2014-5045,https://www.cvedetails.com/cve/CVE-2014-5045/,CWE-59,High,Complete,Complete,,2014-08-01,6.2,"The mountpoint_last function in fs/namei.c in the Linux kernel before 3.15.8 does not properly maintain a certain reference count during attempts to use the umount system call in conjunction with a symlink, which allows local users to cause a denial of service (memory consumption or use-after-free) or possibly have unspecified other impact via the umount program.",2017-01-06,DoS ,2,https://github.com/torvalds/linux/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212,295dc39d941dc2ae53d5c170365af4c9d5c16212,"fs: umount on symlink leaks mnt count

Currently umount on symlink blocks following umount:

/vz is separate mount

# ls /vz/ -al | grep test
drwxr-xr-x.  2 root root       4096 Jul 19 01:14 testdir
lrwxrwxrwx.  1 root root         11 Jul 19 01:16 testlink -> /vz/testdir
# umount -l /vz/testlink
umount: /vz/testlink: not mounted (expected)

# lsof /vz
# umount /vz
umount: /vz: device is busy. (unexpected)

In this case mountpoint_last() gets an extra refcount on path->mnt

Signed-off-by: Vasily Averin <vvs@openvz.org>
Acked-by: Ian Kent <raven@themaw.net>
Acked-by: Jeff Layton <jlayton@primarydata.com>
Cc: stable@vger.kernel.org
Signed-off-by: Christoph Hellwig <hch@lst.de>",1,fs/namei.c,"{""sha"": ""9eb787e5c167fb601845590f0181d249bf515fb0"", ""filename"": ""fs/namei.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/295dc39d941dc2ae53d5c170365af4c9d5c16212/fs/namei.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/295dc39d941dc2ae53d5c170365af4c9d5c16212/fs/namei.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namei.c?ref=295dc39d941dc2ae53d5c170365af4c9d5c16212"", ""patch"": ""@@ -2256,9 +2256,10 @@ mountpoint_last(struct nameidata *nd, struct path *path)\n \t\tgoto out;\n \t}\n \tpath->dentry = dentry;\n-\tpath->mnt = mntget(nd->path.mnt);\n+\tpath->mnt = nd->path.mnt;\n \tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n \t\treturn 1;\n+\tmntget(path->mnt);\n \tfollow_mount(path);\n \terror = 0;\n out:""}","mountpoint_last(struct nameidata *nd, struct path *path)
{
	int error = 0;
	struct dentry *dentry;
	struct dentry *dir = nd->path.dentry;

	/* If we're in rcuwalk, drop out of it to handle last component */
	if (nd->flags & LOOKUP_RCU) {
		if (unlazy_walk(nd, NULL)) {
			error = -ECHILD;
			goto out;
		}
	}

	nd->flags &= ~LOOKUP_PARENT;

	if (unlikely(nd->last_type != LAST_NORM)) {
		error = handle_dots(nd, nd->last_type);
		if (error)
			goto out;
		dentry = dget(nd->path.dentry);
		goto done;
	}

	mutex_lock(&dir->d_inode->i_mutex);
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
		 * path doesn't actually point to a mounted dentry.
		 */
		dentry = d_alloc(dir, &nd->last);
		if (!dentry) {
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
		error = PTR_ERR(dentry);
		if (IS_ERR(dentry)) {
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

done:
	if (!dentry->d_inode || d_is_negative(dentry)) {
		error = -ENOENT;
		dput(dentry);
 		goto out;
 	}
 	path->dentry = dentry;
	path->mnt = nd->path.mnt;
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
	mntget(path->mnt);
 	follow_mount(path);
 	error = 0;
 out:
	terminate_walk(nd);
	return error;
}
","mountpoint_last(struct nameidata *nd, struct path *path)
{
	int error = 0;
	struct dentry *dentry;
	struct dentry *dir = nd->path.dentry;

	/* If we're in rcuwalk, drop out of it to handle last component */
	if (nd->flags & LOOKUP_RCU) {
		if (unlazy_walk(nd, NULL)) {
			error = -ECHILD;
			goto out;
		}
	}

	nd->flags &= ~LOOKUP_PARENT;

	if (unlikely(nd->last_type != LAST_NORM)) {
		error = handle_dots(nd, nd->last_type);
		if (error)
			goto out;
		dentry = dget(nd->path.dentry);
		goto done;
	}

	mutex_lock(&dir->d_inode->i_mutex);
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
		 * path doesn't actually point to a mounted dentry.
		 */
		dentry = d_alloc(dir, &nd->last);
		if (!dentry) {
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
		error = PTR_ERR(dentry);
		if (IS_ERR(dentry)) {
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

done:
	if (!dentry->d_inode || d_is_negative(dentry)) {
		error = -ENOENT;
		dput(dentry);
 		goto out;
 	}
 	path->dentry = dentry;
	path->mnt = mntget(nd->path.mnt);
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
 	follow_mount(path);
 	error = 0;
 out:
	terminate_walk(nd);
	return error;
}
",C,"	path->mnt = nd->path.mnt;
	mntget(path->mnt);
","	path->mnt = mntget(nd->path.mnt);
",,"@@ -2256,9 +2256,10 @@ mountpoint_last(struct nameidata *nd, struct path *path)
 		goto out;
 	}
 	path->dentry = dentry;
-	path->mnt = mntget(nd->path.mnt);
+	path->mnt = nd->path.mnt;
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
+	mntget(path->mnt);
 	follow_mount(path);
 	error = 0;
 out:",linux,295dc39d941dc2ae53d5c170365af4c9d5c16212,6fcc5420bfb91049a318bb4d88fe471248b5b391,1,"mountpoint_last(struct nameidata *nd, struct path *path)
{
	int error = 0;
	struct dentry *dentry;
	struct dentry *dir = nd->path.dentry;

	/* If we're in rcuwalk, drop out of it to handle last component */
	if (nd->flags & LOOKUP_RCU) {
		if (unlazy_walk(nd, NULL)) {
			error = -ECHILD;
			goto out;
		}
	}

	nd->flags &= ~LOOKUP_PARENT;

	if (unlikely(nd->last_type != LAST_NORM)) {
		error = handle_dots(nd, nd->last_type);
		if (error)
			goto out;
		dentry = dget(nd->path.dentry);
		goto done;
	}

	mutex_lock(&dir->d_inode->i_mutex);
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
		 * path doesn't actually point to a mounted dentry.
		 */
		dentry = d_alloc(dir, &nd->last);
		if (!dentry) {
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
		error = PTR_ERR(dentry);
		if (IS_ERR(dentry)) {
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

done:
	if (!dentry->d_inode || d_is_negative(dentry)) {
		error = -ENOENT;
		dput(dentry);
 		goto out;
 	}
 	path->dentry = dentry;
//flaw_line_below:
	path->mnt = mntget(nd->path.mnt);
//fix_flaw_line_below:
//	path->mnt = nd->path.mnt;
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
//fix_flaw_line_below:
//	mntget(path->mnt);
 	follow_mount(path);
 	error = 0;
 out:
	terminate_walk(nd);
	return error;
}
"
2040,179776,,Local,Not required,Complete,CVE-2015-5287,https://www.cvedetails.com/cve/CVE-2015-5287/,CWE-59,Medium,Complete,Complete,,2015-12-07,6.9,"The abrt-hook-ccpp help program in Automatic Bug Reporting Tool (ABRT) before 2.7.1 allows local users with certain permissions to gain privileges via a symlink attack on a file with a predictable name, as demonstrated by /var/tmp/abrt/abrt-hax-coredump or /var/spool/abrt/abrt-hax-coredump.",2016-12-07,+Priv ,2,https://github.com/abrt/abrt/commit/3c1b60cfa62d39e5fff5a53a5bc53dae189e740e,3c1b60cfa62d39e5fff5a53a5bc53dae189e740e,"ccpp: save abrt core files only to new files

Prior this commit abrt-hook-ccpp saved a core file generated by a
process running a program whose name starts with ""abrt"" in
DUMP_LOCATION/$(basename program)-coredump. If the file was a symlink,
the hook followed and wrote core file to the symlink's target.

Addresses CVE-2015-5287

Signed-off-by: Jakub Filak <jfilak@redhat.com>",1,src/hooks/abrt-hook-ccpp.c,"{""sha"": ""58d9c28d20a2534cb92eea1dbb19069064393751"", ""filename"": ""src/hooks/abrt-hook-ccpp.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/abrt/abrt/blob/3c1b60cfa62d39e5fff5a53a5bc53dae189e740e/src/hooks/abrt-hook-ccpp.c"", ""raw_url"": ""https://github.com/abrt/abrt/raw/3c1b60cfa62d39e5fff5a53a5bc53dae189e740e/src/hooks/abrt-hook-ccpp.c"", ""contents_url"": ""https://api.github.com/repos/abrt/abrt/contents/src/hooks/abrt-hook-ccpp.c?ref=3c1b60cfa62d39e5fff5a53a5bc53dae189e740e"", ""patch"": ""@@ -718,7 +718,8 @@ int main(int argc, char** argv)\n         if (snprintf(path, sizeof(path), \""%s/%s-coredump\"", g_settings_dump_location, last_slash) >= sizeof(path))\n             error_msg_and_die(\""Error saving '%s': truncated long file path\"", path);\n \n-        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n+        unlink(path);\n+        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);\n         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);\n         if (core_size < 0 || fsync(abrt_core_fd) != 0)\n         {""}","int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
        fd = xdup(fd);
    if (fd > 2)
        close(fd);

    int err = 1;
    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    bool setting_SaveFullCore;
    bool setting_CreateCoreBacktrace;
    bool setting_SaveContainerizedPackageData;
    bool setting_StandaloneHook;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveFullCore"");
        setting_SaveFullCore = value ? string_to_bool(value) : true;
        value = get_map_string_item_or_NULL(settings, ""CreateCoreBacktrace"");
        setting_CreateCoreBacktrace = value ? string_to_bool(value) : true;

        value = get_map_string_item_or_NULL(settings, ""SaveContainerizedPackageData"");
        setting_SaveContainerizedPackageData = value && string_to_bool(value);

        /* Do not call abrt-action-save-package-data with process's root, if ExploreChroots is disabled. */
        if (!g_settings_explorechroots)
        {
            if (setting_SaveContainerizedPackageData)
                log_warning(""Ignoring SaveContainerizedPackageData because ExploreChroots is disabled"");
            setting_SaveContainerizedPackageData = false;
        }

        value = get_map_string_item_or_NULL(settings, ""StandaloneHook"");
        setting_StandaloneHook = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    if (argc == 2 && strcmp(argv[1], ""--config-test""))
        return test_configuration(setting_SaveFullCore, setting_CreateCoreBacktrace);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %P         %i*/
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]        [9]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME GLOBAL_PID [TID]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t local_pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || local_pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }
    const char *global_pid_str = argv[8];
    pid_t pid = xatoi_positive(argv[8]);

    pid_t tid = -1;
    const char *tid_str = argv[9];
    if (tid_str)
    {
        tid = xatoi_positive(tid_str);
    }

    char path[PATH_MAX];

    char *executable = get_executable(pid);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    char *proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid(proc_pid_status);
    if (tmp_fsuid < 0)
        perror_msg_and_die(""Can't parse 'Uid: line' in /proc/%lu/status"", (long)pid);

    const int fsgid = get_fsgid(proc_pid_status);
    if (fsgid < 0)
        error_msg_and_die(""Can't parse 'Gid: line' in /proc/%lu/status"", (long)pid);

    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
            fsuid = tmp_fsuid;
        else
        {
            g_user_core_flags = O_EXCL;
            g_need_nonrelative = 1;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    int user_core_fd = -1;
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, fsgid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *signame = NULL;
    if (!signal_is_fatal(signal_no, &signame))
        return create_user_core(user_core_fd, pid, ulimit_c); // not a signal we care about

    const int abrtd_running = daemon_is_ok();
    if (!setting_StandaloneHook && !abrtd_running)
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    if (setting_StandaloneHook)
        ensure_writable_dir(g_settings_dump_location, DEFAULT_DUMP_LOCATION_MODE, ""abrt"");

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        if (g_settings_debug_level == 0)
        {
            log_warning(""Ignoring crash of %s (SIG%s)."",
                        executable, signame ? signame : signal_str);
            goto cleanup_and_exit;
        }

        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
        unlink(path);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        err = 0;
        goto cleanup_and_exit;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* If you don't want to have fs owner as root then:
     *
     * - use fsuid instead of uid for fs owner, so we don't expose any
     *   sensitive information of suided app in /var/(tmp|spool)/abrt
     *
     * - use dd_create_skeleton() and dd_reset_ownership(), when you finish
     *   creating the new dump directory, to prevent the real owner to write to
     *   the directory until the hook is done (avoid race conditions and defend
     *   hard and symbolic link attacs)
     */
    dd = dd_create(path, /*fs owner*/0, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/root"", (long)pid);
        source_base_ofs -= strlen(""root"");

        /* What's wrong on using /proc/[pid]/root every time ?*/
        /* It creates os_info_in_root_dir for all crashes. */
        char *rootdir = process_has_own_root(pid) ? get_rootdir(pid) : NULL;

        /* Reading data from an arbitrary root directory is not secure. */
        if (g_settings_explorechroots)
        {
            /* Yes, test 'rootdir' but use 'source_filename' because 'rootdir' can
             * be '/' for a process with own namespace. 'source_filename' is /proc/[pid]/root. */
            dd_create_basic_files(dd, fsuid, (rootdir != NULL) ? source_filename : NULL);
        }
        else
        {
            dd_create_basic_files(dd, fsuid, NULL);
        }

        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;


        strcpy(source_filename + source_base_ofs, ""maps"");
        dd_copy_file(dd, FILENAME_MAPS, source_filename);

        strcpy(source_filename + source_base_ofs, ""limits"");
        dd_copy_file(dd, FILENAME_LIMITS, source_filename);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        dd_copy_file(dd, FILENAME_CGROUP, source_filename);

        strcpy(source_filename + source_base_ofs, ""mountinfo"");
        dd_copy_file(dd, FILENAME_MOUNTINFO, source_filename);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        strcpy(source_filename + source_base_ofs, ""fd"");
        dump_fd_info_ext(dest_filename, source_filename, dd->dd_uid, dd->dd_gid);

        strcpy(dest_base, FILENAME_NAMESPACES);
        dump_namespace_diff_ext(dest_filename, 1, pid, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        char *tmp = NULL;
        get_env_variable(pid, ""container"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER, tmp);
            free(tmp);
            tmp = NULL;
        }

        get_env_variable(pid, ""container_uuid"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER_UUID, tmp);
            free(tmp);
        }

        /* There's no need to compare mount namespaces and search for '/' in
         * mountifo.  Comparison of inodes of '/proc/[pid]/root' and '/' works
         * fine. If those inodes do not equal each other, we have to verify
         * that '/proc/[pid]/root' is not a symlink to a chroot.
         */
        const int containerized = (rootdir != NULL && strcmp(rootdir, ""/"") == 0);
        if (containerized)
        {
            log_debug(""Process %d is considered to be containerized"", pid);
            pid_t container_pid;
            if (get_pid_of_container(pid, &container_pid) == 0)
            {
                char *container_cmdline = get_cmdline(container_pid);
                dd_save_text(dd, FILENAME_CONTAINER_CMDLINE, container_cmdline);
                free(container_cmdline);
            }
        }

        dd_save_text(dd, FILENAME_ANALYZER, ""abrt-ccpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_GLOBAL_PID, global_pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (tid_str)
            dd_save_text(dd, FILENAME_TID, tid_str);

        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }
        free(rootdir);

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        /* In case of errors, treat the process as if it has locked memory */
        long unsigned lck_bytes = ULONG_MAX;
        const char *vmlck = strstr(proc_pid_status, ""VmLck:"");
        if (vmlck == NULL)
            error_msg(""/proc/%s/status does not contain 'VmLck:' line"", pid_str);
        else if (1 != sscanf(vmlck + 6, ""%lu kB\n"", &lck_bytes))
            error_msg(""Failed to parse 'VmLck:' line in /proc/%s/status"", pid_str);

        if (lck_bytes)
        {
            log_notice(""Process %s of user %lu has locked memory"",
                        pid_str, (long unsigned)uid);

            dd_mark_as_notreportable(dd, ""The process had locked memory ""
                    ""which usually indicates efforts to protect sensitive ""
                    ""data (passwords) from being written to disk.\n""
                    ""In order to avoid sensitive information leakages, ""
                    ""ABRT will not allow you to report this problem to ""
                    ""bug tracking tools"");
        }

        if (setting_SaveBinaryImage)
        {
            if (save_crashing_binary(pid, dd))
            {
                error_msg(""Error saving '%s'"", path);

                goto cleanup_and_exit;
            }
        }

        off_t core_size = 0;
        if (setting_SaveFullCore)
        {
            strcpy(path + path_len, ""/""FILENAME_COREDUMP);
            int abrt_core_fd = create_or_die(path, user_core_fd);

            /* We write both coredumps at once.
             * We can't write user coredump first, since it might be truncated
             * and thus can't be copied and used as abrt coredump;
             * and if we write abrt coredump first and then copy it as user one,
             * then we have a race when process exits but coredump does not exist yet:
             * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
             * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
             * 21631 Segmentation fault (core dumped) ./test
             * ls: cannot access core*: No such file or directory <=== BAD
             */
            core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
            close_user_core(user_core_fd, core_size);
            if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
            {
                unlink(path);

                /* copyfd_sparse logs the error including errno string,
                 * but it does not log file name */
                error_msg(""Error writing '%s'"", path);

                goto cleanup_and_exit;
            }
        }
        else
        {
            /* User core is created even if WriteFullCore is off. */
            create_user_core(user_core_fd, pid, ulimit_c);
        }

        /* User core is either written or closed */
        user_core_fd = -1;

        /*
         * ! No other errors should cause removal of the user core !
         */

/* Because of #1211835 and #1126850 */
#if 0
        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path, user_core_fd);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    error_msg(""Error saving '%s'"", path);

                    goto cleanup_and_exit;
                }
                close(src_fd);
            }
        }
#endif

        /* Perform crash-time unwind of the guilty thread. */
        if (tid > 0 && setting_CreateCoreBacktrace)
            create_core_backtrace(tid, executable, signal_no, dd);

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        dd = NULL;

        path[path_len] = '\0'; /* path now contains only directory name */

        if (abrtd_running && setting_SaveContainerizedPackageData && containerized)
        {   /* Do we really need to run rpm from core_pattern hook? */
            sprintf(source_filename, ""/proc/%lu/root"", (long)pid);

            const char *cmd_args[6];
            cmd_args[0] = BIN_DIR""/abrt-action-save-package-data"";
            cmd_args[1] = ""-d"";
            cmd_args[2] = path;
            cmd_args[3] = ""-r"";
            cmd_args[4] = source_filename;
            cmd_args[5] = NULL;

            pid_t pid = fork_execv_on_steroids(0, (char **)cmd_args, NULL, NULL, path, 0);
            int stat;
            safe_waitpid(pid, &stat, 0);
        }

        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        if (core_size > 0)
            log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"",
                       (long)pid, executable, path, (long long)core_size);

        if (abrtd_running)
            notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        err = 0;
    }
    else
    {
        /* We didn't create abrt dump, but may need to create compat coredump */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

cleanup_and_exit:
    if (dd)
        dd_delete(dd);

    if (user_core_fd >= 0)
        unlinkat(dirfd(proc_cwd), core_basename, /*only files*/0);

    if (proc_cwd != NULL)
        closedir(proc_cwd);

    return err;
}
","int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
        fd = xdup(fd);
    if (fd > 2)
        close(fd);

    int err = 1;
    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    bool setting_SaveFullCore;
    bool setting_CreateCoreBacktrace;
    bool setting_SaveContainerizedPackageData;
    bool setting_StandaloneHook;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveFullCore"");
        setting_SaveFullCore = value ? string_to_bool(value) : true;
        value = get_map_string_item_or_NULL(settings, ""CreateCoreBacktrace"");
        setting_CreateCoreBacktrace = value ? string_to_bool(value) : true;

        value = get_map_string_item_or_NULL(settings, ""SaveContainerizedPackageData"");
        setting_SaveContainerizedPackageData = value && string_to_bool(value);

        /* Do not call abrt-action-save-package-data with process's root, if ExploreChroots is disabled. */
        if (!g_settings_explorechroots)
        {
            if (setting_SaveContainerizedPackageData)
                log_warning(""Ignoring SaveContainerizedPackageData because ExploreChroots is disabled"");
            setting_SaveContainerizedPackageData = false;
        }

        value = get_map_string_item_or_NULL(settings, ""StandaloneHook"");
        setting_StandaloneHook = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    if (argc == 2 && strcmp(argv[1], ""--config-test""))
        return test_configuration(setting_SaveFullCore, setting_CreateCoreBacktrace);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %P         %i*/
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]        [9]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME GLOBAL_PID [TID]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t local_pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || local_pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }
    const char *global_pid_str = argv[8];
    pid_t pid = xatoi_positive(argv[8]);

    pid_t tid = -1;
    const char *tid_str = argv[9];
    if (tid_str)
    {
        tid = xatoi_positive(tid_str);
    }

    char path[PATH_MAX];

    char *executable = get_executable(pid);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    char *proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid(proc_pid_status);
    if (tmp_fsuid < 0)
        perror_msg_and_die(""Can't parse 'Uid: line' in /proc/%lu/status"", (long)pid);

    const int fsgid = get_fsgid(proc_pid_status);
    if (fsgid < 0)
        error_msg_and_die(""Can't parse 'Gid: line' in /proc/%lu/status"", (long)pid);

    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
            fsuid = tmp_fsuid;
        else
        {
            g_user_core_flags = O_EXCL;
            g_need_nonrelative = 1;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    int user_core_fd = -1;
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, fsgid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *signame = NULL;
    if (!signal_is_fatal(signal_no, &signame))
        return create_user_core(user_core_fd, pid, ulimit_c); // not a signal we care about

    const int abrtd_running = daemon_is_ok();
    if (!setting_StandaloneHook && !abrtd_running)
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    if (setting_StandaloneHook)
        ensure_writable_dir(g_settings_dump_location, DEFAULT_DUMP_LOCATION_MODE, ""abrt"");

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        if (g_settings_debug_level == 0)
        {
            log_warning(""Ignoring crash of %s (SIG%s)."",
                        executable, signame ? signame : signal_str);
            goto cleanup_and_exit;
        }

        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        err = 0;
        goto cleanup_and_exit;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* If you don't want to have fs owner as root then:
     *
     * - use fsuid instead of uid for fs owner, so we don't expose any
     *   sensitive information of suided app in /var/(tmp|spool)/abrt
     *
     * - use dd_create_skeleton() and dd_reset_ownership(), when you finish
     *   creating the new dump directory, to prevent the real owner to write to
     *   the directory until the hook is done (avoid race conditions and defend
     *   hard and symbolic link attacs)
     */
    dd = dd_create(path, /*fs owner*/0, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/root"", (long)pid);
        source_base_ofs -= strlen(""root"");

        /* What's wrong on using /proc/[pid]/root every time ?*/
        /* It creates os_info_in_root_dir for all crashes. */
        char *rootdir = process_has_own_root(pid) ? get_rootdir(pid) : NULL;

        /* Reading data from an arbitrary root directory is not secure. */
        if (g_settings_explorechroots)
        {
            /* Yes, test 'rootdir' but use 'source_filename' because 'rootdir' can
             * be '/' for a process with own namespace. 'source_filename' is /proc/[pid]/root. */
            dd_create_basic_files(dd, fsuid, (rootdir != NULL) ? source_filename : NULL);
        }
        else
        {
            dd_create_basic_files(dd, fsuid, NULL);
        }

        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;


        strcpy(source_filename + source_base_ofs, ""maps"");
        dd_copy_file(dd, FILENAME_MAPS, source_filename);

        strcpy(source_filename + source_base_ofs, ""limits"");
        dd_copy_file(dd, FILENAME_LIMITS, source_filename);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        dd_copy_file(dd, FILENAME_CGROUP, source_filename);

        strcpy(source_filename + source_base_ofs, ""mountinfo"");
        dd_copy_file(dd, FILENAME_MOUNTINFO, source_filename);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        strcpy(source_filename + source_base_ofs, ""fd"");
        dump_fd_info_ext(dest_filename, source_filename, dd->dd_uid, dd->dd_gid);

        strcpy(dest_base, FILENAME_NAMESPACES);
        dump_namespace_diff_ext(dest_filename, 1, pid, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        char *tmp = NULL;
        get_env_variable(pid, ""container"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER, tmp);
            free(tmp);
            tmp = NULL;
        }

        get_env_variable(pid, ""container_uuid"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER_UUID, tmp);
            free(tmp);
        }

        /* There's no need to compare mount namespaces and search for '/' in
         * mountifo.  Comparison of inodes of '/proc/[pid]/root' and '/' works
         * fine. If those inodes do not equal each other, we have to verify
         * that '/proc/[pid]/root' is not a symlink to a chroot.
         */
        const int containerized = (rootdir != NULL && strcmp(rootdir, ""/"") == 0);
        if (containerized)
        {
            log_debug(""Process %d is considered to be containerized"", pid);
            pid_t container_pid;
            if (get_pid_of_container(pid, &container_pid) == 0)
            {
                char *container_cmdline = get_cmdline(container_pid);
                dd_save_text(dd, FILENAME_CONTAINER_CMDLINE, container_cmdline);
                free(container_cmdline);
            }
        }

        dd_save_text(dd, FILENAME_ANALYZER, ""abrt-ccpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_GLOBAL_PID, global_pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (tid_str)
            dd_save_text(dd, FILENAME_TID, tid_str);

        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }
        free(rootdir);

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        /* In case of errors, treat the process as if it has locked memory */
        long unsigned lck_bytes = ULONG_MAX;
        const char *vmlck = strstr(proc_pid_status, ""VmLck:"");
        if (vmlck == NULL)
            error_msg(""/proc/%s/status does not contain 'VmLck:' line"", pid_str);
        else if (1 != sscanf(vmlck + 6, ""%lu kB\n"", &lck_bytes))
            error_msg(""Failed to parse 'VmLck:' line in /proc/%s/status"", pid_str);

        if (lck_bytes)
        {
            log_notice(""Process %s of user %lu has locked memory"",
                        pid_str, (long unsigned)uid);

            dd_mark_as_notreportable(dd, ""The process had locked memory ""
                    ""which usually indicates efforts to protect sensitive ""
                    ""data (passwords) from being written to disk.\n""
                    ""In order to avoid sensitive information leakages, ""
                    ""ABRT will not allow you to report this problem to ""
                    ""bug tracking tools"");
        }

        if (setting_SaveBinaryImage)
        {
            if (save_crashing_binary(pid, dd))
            {
                error_msg(""Error saving '%s'"", path);

                goto cleanup_and_exit;
            }
        }

        off_t core_size = 0;
        if (setting_SaveFullCore)
        {
            strcpy(path + path_len, ""/""FILENAME_COREDUMP);
            int abrt_core_fd = create_or_die(path, user_core_fd);

            /* We write both coredumps at once.
             * We can't write user coredump first, since it might be truncated
             * and thus can't be copied and used as abrt coredump;
             * and if we write abrt coredump first and then copy it as user one,
             * then we have a race when process exits but coredump does not exist yet:
             * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
             * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
             * 21631 Segmentation fault (core dumped) ./test
             * ls: cannot access core*: No such file or directory <=== BAD
             */
            core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
            close_user_core(user_core_fd, core_size);
            if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
            {
                unlink(path);

                /* copyfd_sparse logs the error including errno string,
                 * but it does not log file name */
                error_msg(""Error writing '%s'"", path);

                goto cleanup_and_exit;
            }
        }
        else
        {
            /* User core is created even if WriteFullCore is off. */
            create_user_core(user_core_fd, pid, ulimit_c);
        }

        /* User core is either written or closed */
        user_core_fd = -1;

        /*
         * ! No other errors should cause removal of the user core !
         */

/* Because of #1211835 and #1126850 */
#if 0
        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path, user_core_fd);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    error_msg(""Error saving '%s'"", path);

                    goto cleanup_and_exit;
                }
                close(src_fd);
            }
        }
#endif

        /* Perform crash-time unwind of the guilty thread. */
        if (tid > 0 && setting_CreateCoreBacktrace)
            create_core_backtrace(tid, executable, signal_no, dd);

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        dd = NULL;

        path[path_len] = '\0'; /* path now contains only directory name */

        if (abrtd_running && setting_SaveContainerizedPackageData && containerized)
        {   /* Do we really need to run rpm from core_pattern hook? */
            sprintf(source_filename, ""/proc/%lu/root"", (long)pid);

            const char *cmd_args[6];
            cmd_args[0] = BIN_DIR""/abrt-action-save-package-data"";
            cmd_args[1] = ""-d"";
            cmd_args[2] = path;
            cmd_args[3] = ""-r"";
            cmd_args[4] = source_filename;
            cmd_args[5] = NULL;

            pid_t pid = fork_execv_on_steroids(0, (char **)cmd_args, NULL, NULL, path, 0);
            int stat;
            safe_waitpid(pid, &stat, 0);
        }

        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        if (core_size > 0)
            log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"",
                       (long)pid, executable, path, (long long)core_size);

        if (abrtd_running)
            notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        err = 0;
    }
    else
    {
        /* We didn't create abrt dump, but may need to create compat coredump */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

cleanup_and_exit:
    if (dd)
        dd_delete(dd);

    if (user_core_fd >= 0)
        unlinkat(dirfd(proc_cwd), core_basename, /*only files*/0);

    if (proc_cwd != NULL)
        closedir(proc_cwd);

    return err;
}
",C,"        unlink(path);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
","        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
",,"@@ -718,7 +718,8 @@ int main(int argc, char** argv)
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
-        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
+        unlink(path);
+        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {",abrt,3c1b60cfa62d39e5fff5a53a5bc53dae189e740e,dec3089ff88fe7ada77058dca6ed3ad88c18ee16,1,"int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
        fd = xdup(fd);
    if (fd > 2)
        close(fd);

    int err = 1;
    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    bool setting_SaveFullCore;
    bool setting_CreateCoreBacktrace;
    bool setting_SaveContainerizedPackageData;
    bool setting_StandaloneHook;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveFullCore"");
        setting_SaveFullCore = value ? string_to_bool(value) : true;
        value = get_map_string_item_or_NULL(settings, ""CreateCoreBacktrace"");
        setting_CreateCoreBacktrace = value ? string_to_bool(value) : true;

        value = get_map_string_item_or_NULL(settings, ""SaveContainerizedPackageData"");
        setting_SaveContainerizedPackageData = value && string_to_bool(value);

        /* Do not call abrt-action-save-package-data with process's root, if ExploreChroots is disabled. */
        if (!g_settings_explorechroots)
        {
            if (setting_SaveContainerizedPackageData)
                log_warning(""Ignoring SaveContainerizedPackageData because ExploreChroots is disabled"");
            setting_SaveContainerizedPackageData = false;
        }

        value = get_map_string_item_or_NULL(settings, ""StandaloneHook"");
        setting_StandaloneHook = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    if (argc == 2 && strcmp(argv[1], ""--config-test""))
        return test_configuration(setting_SaveFullCore, setting_CreateCoreBacktrace);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %P         %i*/
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]        [9]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME GLOBAL_PID [TID]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t local_pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || local_pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }
    const char *global_pid_str = argv[8];
    pid_t pid = xatoi_positive(argv[8]);

    pid_t tid = -1;
    const char *tid_str = argv[9];
    if (tid_str)
    {
        tid = xatoi_positive(tid_str);
    }

    char path[PATH_MAX];

    char *executable = get_executable(pid);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    char *proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid(proc_pid_status);
    if (tmp_fsuid < 0)
        perror_msg_and_die(""Can't parse 'Uid: line' in /proc/%lu/status"", (long)pid);

    const int fsgid = get_fsgid(proc_pid_status);
    if (fsgid < 0)
        error_msg_and_die(""Can't parse 'Gid: line' in /proc/%lu/status"", (long)pid);

    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
            fsuid = tmp_fsuid;
        else
        {
            g_user_core_flags = O_EXCL;
            g_need_nonrelative = 1;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    int user_core_fd = -1;
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, fsgid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *signame = NULL;
    if (!signal_is_fatal(signal_no, &signame))
        return create_user_core(user_core_fd, pid, ulimit_c); // not a signal we care about

    const int abrtd_running = daemon_is_ok();
    if (!setting_StandaloneHook && !abrtd_running)
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    if (setting_StandaloneHook)
        ensure_writable_dir(g_settings_dump_location, DEFAULT_DUMP_LOCATION_MODE, ""abrt"");

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        if (g_settings_debug_level == 0)
        {
            log_warning(""Ignoring crash of %s (SIG%s)."",
                        executable, signame ? signame : signal_str);
            goto cleanup_and_exit;
        }

        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
//flaw_line_below:
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
//fix_flaw_line_below:
//        unlink(path);
//fix_flaw_line_below:
//        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        err = 0;
        goto cleanup_and_exit;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* If you don't want to have fs owner as root then:
     *
     * - use fsuid instead of uid for fs owner, so we don't expose any
     *   sensitive information of suided app in /var/(tmp|spool)/abrt
     *
     * - use dd_create_skeleton() and dd_reset_ownership(), when you finish
     *   creating the new dump directory, to prevent the real owner to write to
     *   the directory until the hook is done (avoid race conditions and defend
     *   hard and symbolic link attacs)
     */
    dd = dd_create(path, /*fs owner*/0, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/root"", (long)pid);
        source_base_ofs -= strlen(""root"");

        /* What's wrong on using /proc/[pid]/root every time ?*/
        /* It creates os_info_in_root_dir for all crashes. */
        char *rootdir = process_has_own_root(pid) ? get_rootdir(pid) : NULL;

        /* Reading data from an arbitrary root directory is not secure. */
        if (g_settings_explorechroots)
        {
            /* Yes, test 'rootdir' but use 'source_filename' because 'rootdir' can
             * be '/' for a process with own namespace. 'source_filename' is /proc/[pid]/root. */
            dd_create_basic_files(dd, fsuid, (rootdir != NULL) ? source_filename : NULL);
        }
        else
        {
            dd_create_basic_files(dd, fsuid, NULL);
        }

        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;

        // Disabled for now: /proc/PID/smaps tends to be BIG,
        // and not much more informative than /proc/PID/maps:
        // dd_copy_file(dd, FILENAME_SMAPS, source_filename);

        strcpy(source_filename + source_base_ofs, ""maps"");
        dd_copy_file(dd, FILENAME_MAPS, source_filename);

        strcpy(source_filename + source_base_ofs, ""limits"");
        dd_copy_file(dd, FILENAME_LIMITS, source_filename);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        dd_copy_file(dd, FILENAME_CGROUP, source_filename);

        strcpy(source_filename + source_base_ofs, ""mountinfo"");
        dd_copy_file(dd, FILENAME_MOUNTINFO, source_filename);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        strcpy(source_filename + source_base_ofs, ""fd"");
        dump_fd_info_ext(dest_filename, source_filename, dd->dd_uid, dd->dd_gid);

        strcpy(dest_base, FILENAME_NAMESPACES);
        dump_namespace_diff_ext(dest_filename, 1, pid, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        char *tmp = NULL;
        get_env_variable(pid, ""container"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER, tmp);
            free(tmp);
            tmp = NULL;
        }

        get_env_variable(pid, ""container_uuid"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER_UUID, tmp);
            free(tmp);
        }

        /* There's no need to compare mount namespaces and search for '/' in
         * mountifo.  Comparison of inodes of '/proc/[pid]/root' and '/' works
         * fine. If those inodes do not equal each other, we have to verify
         * that '/proc/[pid]/root' is not a symlink to a chroot.
         */
        const int containerized = (rootdir != NULL && strcmp(rootdir, ""/"") == 0);
        if (containerized)
        {
            log_debug(""Process %d is considered to be containerized"", pid);
            pid_t container_pid;
            if (get_pid_of_container(pid, &container_pid) == 0)
            {
                char *container_cmdline = get_cmdline(container_pid);
                dd_save_text(dd, FILENAME_CONTAINER_CMDLINE, container_cmdline);
                free(container_cmdline);
            }
        }

        dd_save_text(dd, FILENAME_ANALYZER, ""abrt-ccpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_GLOBAL_PID, global_pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (tid_str)
            dd_save_text(dd, FILENAME_TID, tid_str);

        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }
        free(rootdir);

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        /* In case of errors, treat the process as if it has locked memory */
        long unsigned lck_bytes = ULONG_MAX;
        const char *vmlck = strstr(proc_pid_status, ""VmLck:"");
        if (vmlck == NULL)
            error_msg(""/proc/%s/status does not contain 'VmLck:' line"", pid_str);
        else if (1 != sscanf(vmlck + 6, ""%lu kB\n"", &lck_bytes))
            error_msg(""Failed to parse 'VmLck:' line in /proc/%s/status"", pid_str);

        if (lck_bytes)
        {
            log_notice(""Process %s of user %lu has locked memory"",
                        pid_str, (long unsigned)uid);

            dd_mark_as_notreportable(dd, ""The process had locked memory ""
                    ""which usually indicates efforts to protect sensitive ""
                    ""data (passwords) from being written to disk.\n""
                    ""In order to avoid sensitive information leakages, ""
                    ""ABRT will not allow you to report this problem to ""
                    ""bug tracking tools"");
        }

        if (setting_SaveBinaryImage)
        {
            if (save_crashing_binary(pid, dd))
            {
                error_msg(""Error saving '%s'"", path);

                goto cleanup_and_exit;
            }
        }

        off_t core_size = 0;
        if (setting_SaveFullCore)
        {
            strcpy(path + path_len, ""/""FILENAME_COREDUMP);
            int abrt_core_fd = create_or_die(path, user_core_fd);

            /* We write both coredumps at once.
             * We can't write user coredump first, since it might be truncated
             * and thus can't be copied and used as abrt coredump;
             * and if we write abrt coredump first and then copy it as user one,
             * then we have a race when process exits but coredump does not exist yet:
             * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
             * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
             * 21631 Segmentation fault (core dumped) ./test
             * ls: cannot access core*: No such file or directory <=== BAD
             */
            core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
            close_user_core(user_core_fd, core_size);
            if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
            {
                unlink(path);

                /* copyfd_sparse logs the error including errno string,
                 * but it does not log file name */
                error_msg(""Error writing '%s'"", path);

                goto cleanup_and_exit;
            }
        }
        else
        {
            /* User core is created even if WriteFullCore is off. */
            create_user_core(user_core_fd, pid, ulimit_c);
        }

        /* User core is either written or closed */
        user_core_fd = -1;

        /*
         * ! No other errors should cause removal of the user core !
         */

/* Because of #1211835 and #1126850 */
#if 0
        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path, user_core_fd);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    error_msg(""Error saving '%s'"", path);

                    goto cleanup_and_exit;
                }
                close(src_fd);
            }
        }
#endif

        /* Perform crash-time unwind of the guilty thread. */
        if (tid > 0 && setting_CreateCoreBacktrace)
            create_core_backtrace(tid, executable, signal_no, dd);

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        dd = NULL;

        path[path_len] = '\0'; /* path now contains only directory name */

        if (abrtd_running && setting_SaveContainerizedPackageData && containerized)
        {   /* Do we really need to run rpm from core_pattern hook? */
            sprintf(source_filename, ""/proc/%lu/root"", (long)pid);

            const char *cmd_args[6];
            cmd_args[0] = BIN_DIR""/abrt-action-save-package-data"";
            cmd_args[1] = ""-d"";
            cmd_args[2] = path;
            cmd_args[3] = ""-r"";
            cmd_args[4] = source_filename;
            cmd_args[5] = NULL;

            pid_t pid = fork_execv_on_steroids(0, (char **)cmd_args, NULL, NULL, path, 0);
            int stat;
            safe_waitpid(pid, &stat, 0);
        }

        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        if (core_size > 0)
            log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"",
                       (long)pid, executable, path, (long long)core_size);

        if (abrtd_running)
            notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        err = 0;
    }
    else
    {
        /* We didn't create abrt dump, but may need to create compat coredump */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

cleanup_and_exit:
    if (dd)
        dd_delete(dd);

    if (user_core_fd >= 0)
        unlinkat(dirfd(proc_cwd), core_basename, /*only files*/0);

    if (proc_cwd != NULL)
        closedir(proc_cwd);

    return err;
}
"
2045,179781,,Local,Not required,Partial,CVE-2015-5273,https://www.cvedetails.com/cve/CVE-2015-5273/,CWE-59,Low,,Partial,,2015-12-07,3.6,The abrt-action-install-debuginfo-to-abrt-cache help program in Automatic Bug Reporting Tool (ABRT) before 2.7.1 allows local users to write to arbitrary files via a symlink attack on unpacked.cpio in a pre-created directory with a predictable name in /var/tmp.,2016-12-07,,37,https://github.com/abrt/abrt/commit/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e,50ee8130fb4cd4ef1af7682a2c85dd99cb99424e,"a-a-i-d-to-abrt-cache: make own random temporary directory

The set-user-ID wrapper must use own new temporary directory in order to
avoid security issues with unpacking specially crafted debuginfo
packages that might be used to create files or symlinks anywhere on the
file system as the abrt user.

Withot the forking code the temporary directory would remain on the
filesystem in the case where all debuginfo data are already available.
This is caused by the fact that the underlying libreport functionality
accepts path to a desired temporary directory and creates it only if
necessary. Otherwise, the directory is not touched at all.

This commit addresses CVE-2015-5273

Signed-off-by: Jakub Filak <jfilak@redhat.com>",4,src/plugins/abrt-action-install-debuginfo-to-abrt-cache.c,"{""sha"": ""005cc9da147fc0adcfc85b82f6805bb399d28284"", ""filename"": ""src/plugins/Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/abrt/abrt/blob/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e/src/plugins/Makefile.am"", ""raw_url"": ""https://github.com/abrt/abrt/raw/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e/src/plugins/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/abrt/abrt/contents/src/plugins/Makefile.am?ref=50ee8130fb4cd4ef1af7682a2c85dd99cb99424e"", ""patch"": ""@@ -371,6 +371,7 @@ abrt_action_install_debuginfo_to_abrt_cache_CPPFLAGS = \\\n     -D_GNU_SOURCE \\\n     -DBIN_DIR=\\\""$(bindir)\\\"" \\\n     -DSBIN_DIR=\\\""$(sbindir)\\\"" \\\n+    -DLARGE_DATA_TMP_DIR=\\\""$(LARGE_DATA_TMP_DIR)\\\"" \\\n     $(LIBREPORT_CFLAGS) \\\n     -Wall -Wwrite-strings \\\n     -fPIE""}<_**next**_>{""sha"": ""52d00de6291968a4bd5c72f18ca27ddd7a1a7f77"", ""filename"": ""src/plugins/abrt-action-install-debuginfo-to-abrt-cache.c"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 4, ""changes"": 41, ""blob_url"": ""https://github.com/abrt/abrt/blob/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e/src/plugins/abrt-action-install-debuginfo-to-abrt-cache.c"", ""raw_url"": ""https://github.com/abrt/abrt/raw/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e/src/plugins/abrt-action-install-debuginfo-to-abrt-cache.c"", ""contents_url"": ""https://api.github.com/repos/abrt/abrt/contents/src/plugins/abrt-action-install-debuginfo-to-abrt-cache.c?ref=50ee8130fb4cd4ef1af7682a2c85dd99cb99424e"", ""patch"": ""@@ -108,8 +108,14 @@ int main(int argc, char **argv)\n         build_ids_self_fd = xasprintf(\""/proc/self/fd/%d\"", build_ids_fd);\n     }\n \n-    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */\n-    const char *args[11];\n+    char tmp_directory[] = LARGE_DATA_TMP_DIR\""/abrt-tmp-debuginfo.XXXXXX\"";\n+    if (mkdtemp(tmp_directory) == NULL)\n+        perror_msg_and_die(\""Failed to create working directory\"");\n+\n+    log_info(\""Created working directory: %s\"", tmp_directory);\n+\n+    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */\n+    const char *args[13];\n     {\n         const char *verbs[] = { \""\"", \""-v\"", \""-vv\"", \""-vvv\"" };\n         unsigned i = 0;\n@@ -130,6 +136,8 @@ int main(int argc, char **argv)\n             args[i++] = \""--repo\"";\n             args[i++] = repo;\n         }\n+        args[i++] = \""--tmpdir\"";\n+        args[i++] = tmp_directory;\n         args[i++] = \""--\"";\n         args[i] = NULL;\n     }\n@@ -204,6 +212,31 @@ int main(int argc, char **argv)\n         umask(0022);\n     }\n \n-    execvp(EXECUTABLE, (char **)args);\n-    error_msg_and_die(\""Can't execute %s\"", EXECUTABLE);\n+    pid_t pid = fork();\n+    if (pid < 0)\n+        perror_msg_and_die(\""fork\"");\n+\n+    if (pid == 0)\n+    {\n+        execvp(EXECUTABLE, (char **)args);\n+        error_msg_and_die(\""Can't execute %s\"", EXECUTABLE);\n+    }\n+\n+    int status;\n+    if (safe_waitpid(pid, &status, 0) < 0)\n+        perror_msg_and_die(\""waitpid\"");\n+\n+    if (rmdir(tmp_directory) >= 0)\n+        log_info(\""Removed working directory: %s\"", tmp_directory);\n+    else if (errno != ENOENT)\n+        perror_msg(\""Failed to remove working directory\"");\n+\n+    /* Normal execution should exit here. */\n+    if (WIFEXITED(status))\n+        return WEXITSTATUS(status);\n+\n+    if (WIFSIGNALED(status))\n+        error_msg_and_die(\""Child terminated with signal %d\"", WTERMSIG(status));\n+\n+    error_msg_and_die(\""Child exit failed\"");\n }""}","int main(int argc, char **argv)
{
    /* I18n */
    setlocale(LC_ALL, """");
#if ENABLE_NLS
    bindtextdomain(PACKAGE, LOCALEDIR);
    textdomain(PACKAGE);
#endif

    abrt_init(argv);

    /* Can't keep these strings/structs static: _() doesn't support that */
    const char *program_usage_string = _(
        ""& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\n""
        ""\t[-r REPO]\n""
        ""\n""
        ""Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\n""
        ""ABRT system cache.""
    );

    enum {
        OPT_v = 1 << 0,
        OPT_y = 1 << 1,
        OPT_i = 1 << 2,
        OPT_e = 1 << 3,
        OPT_r = 1 << 4,
        OPT_s = 1 << 5,
    };

    const char *build_ids = ""build_ids"";
    const char *exact = NULL;
    const char *repo = NULL;
    const char *size_mb = NULL;

    struct options program_options[] = {
        OPT__VERBOSE(&g_verbose),
        OPT_BOOL  ('y', ""yes"",         NULL,                   _(""Noninteractive, assume 'Yes' to all questions"")),
        OPT_STRING('i', ""ids"",   &build_ids, ""BUILD_IDS_FILE"", _(""- means STDIN, default: build_ids"")),
        OPT_STRING('e', ""exact"",     &exact, ""EXACT"",          _(""Download only specified files"")),
        OPT_STRING('r', ""repo"",       &repo, ""REPO"",           _(""Pattern to use when searching for repos, default: *debug*"")),
        OPT_STRING('s', ""size_mb"", &size_mb, ""SIZE_MB"",        _(""Ignored option"")),
        OPT_END()
    };
    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);

    const gid_t egid = getegid();
    const gid_t rgid = getgid();
    const uid_t euid = geteuid();
    const gid_t ruid = getuid();

    /* We need to open the build ids file under the caller's UID/GID to avoid
     * information disclosures when reading files with changed UID.
     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses
     * STDIN to communicate with the caller. So, the following code opens a
     * dummy file descriptor to the build ids file and passes the new fd's proc
     * path to the wrapped program in the ids argument.
     * The new fd remains opened, the OS will close it for us. */
    char *build_ids_self_fd = NULL;
    if (strcmp(""-"", build_ids) != 0)
    {
        if (setregid(egid, rgid) < 0)
            perror_msg_and_die(""setregid(egid, rgid)"");

        if (setreuid(euid, ruid) < 0)
            perror_msg_and_die(""setreuid(euid, ruid)"");

        const int build_ids_fd = open(build_ids, O_RDONLY);

        if (setregid(rgid, egid) < 0)
            perror_msg_and_die(""setregid(rgid, egid)"");

        if (setreuid(ruid, euid) < 0 )
            perror_msg_and_die(""setreuid(ruid, euid)"");

        if (build_ids_fd < 0)
            perror_msg_and_die(""Failed to open file '%s'"", build_ids);

        /* We are not going to free this memory. There is no place to do so. */
         build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd);
     }
 
    char tmp_directory[] = LARGE_DATA_TMP_DIR""/abrt-tmp-debuginfo.XXXXXX"";
    if (mkdtemp(tmp_directory) == NULL)
        perror_msg_and_die(""Failed to create working directory"");

    log_info(""Created working directory: %s"", tmp_directory);

    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */
    const char *args[13];
     {
         const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" };
         unsigned i = 0;
        args[i++] = EXECUTABLE;
        args[i++] = ""--ids"";
        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : ""-"";
        if (g_verbose > 0)
            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];
        if ((opts & OPT_y))
            args[i++] = ""-y"";
        if ((opts & OPT_e))
        {
            args[i++] = ""--exact"";
            args[i++] = exact;
        }
        if ((opts & OPT_r))
        {
             args[i++] = ""--repo"";
             args[i++] = repo;
         }
        args[i++] = ""--tmpdir"";
        args[i++] = tmp_directory;
         args[i++] = ""--"";
         args[i] = NULL;
     }

    /* Switch real user/group to effective ones.
     * Otherwise yum library gets confused - gets EPERM (why??).
     */
    /* do setregid only if we have to, to not upset selinux needlessly */
    if (egid != rgid)
        IGNORE_RESULT(setregid(egid, egid));
    if (euid != ruid)
    {
        IGNORE_RESULT(setreuid(euid, euid));
        /* We are suid'ed! */
        /* Prevent malicious user from messing up with suid'ed process: */
#if 1

        static const char *whitelist[] = {
            ""REPORT_CLIENT_SLAVE"", //  Check if the app is being run as a slave
            ""LANG"",
        };
        const size_t wlsize = sizeof(whitelist)/sizeof(char*);
        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };
        char *p = NULL;
        for (size_t i = 0; i < wlsize; i++)
            if ((p = getenv(whitelist[i])) != NULL)
                setlist[i] = xstrdup(p);

        clearenv();

        for (size_t i = 0; i < wlsize; i++)
            if (setlist[i] != NULL)
            {
                xsetenv(whitelist[i], setlist[i]);
                free(setlist[i]);
            }
#else
        /* Clear dangerous stuff from env */
        static const char forbid[] =
            ""LD_LIBRARY_PATH"" ""\0""
            ""LD_PRELOAD"" ""\0""
            ""LD_TRACE_LOADED_OBJECTS"" ""\0""
            ""LD_BIND_NOW"" ""\0""
            ""LD_AOUT_LIBRARY_PATH"" ""\0""
            ""LD_AOUT_PRELOAD"" ""\0""
            ""LD_NOWARN"" ""\0""
            ""LD_KEEPDIR"" ""\0""
        ;
        const char *p = forbid;
        do {
            unsetenv(p);
            p += strlen(p) + 1;
        } while (*p);
#endif
        /* Set safe PATH */
        char path_env[] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:""BIN_DIR"":""SBIN_DIR;
        if (euid != 0)
            strcpy(path_env, ""PATH=/usr/bin:/bin:""BIN_DIR);
        putenv(path_env);

        /* Use safe umask */
         umask(0022);
     }
 
    pid_t pid = fork();
    if (pid < 0)
        perror_msg_and_die(""fork"");

    if (pid == 0)
    {
        execvp(EXECUTABLE, (char **)args);
        error_msg_and_die(""Can't execute %s"", EXECUTABLE);
    }

    int status;
    if (safe_waitpid(pid, &status, 0) < 0)
        perror_msg_and_die(""waitpid"");

    if (rmdir(tmp_directory) >= 0)
        log_info(""Removed working directory: %s"", tmp_directory);
    else if (errno != ENOENT)
        perror_msg(""Failed to remove working directory"");

    /* Normal execution should exit here. */
    if (WIFEXITED(status))
        return WEXITSTATUS(status);

    if (WIFSIGNALED(status))
        error_msg_and_die(""Child terminated with signal %d"", WTERMSIG(status));

    error_msg_and_die(""Child exit failed"");
 }
","int main(int argc, char **argv)
{
    /* I18n */
    setlocale(LC_ALL, """");
#if ENABLE_NLS
    bindtextdomain(PACKAGE, LOCALEDIR);
    textdomain(PACKAGE);
#endif

    abrt_init(argv);

    /* Can't keep these strings/structs static: _() doesn't support that */
    const char *program_usage_string = _(
        ""& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\n""
        ""\t[-r REPO]\n""
        ""\n""
        ""Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\n""
        ""ABRT system cache.""
    );

    enum {
        OPT_v = 1 << 0,
        OPT_y = 1 << 1,
        OPT_i = 1 << 2,
        OPT_e = 1 << 3,
        OPT_r = 1 << 4,
        OPT_s = 1 << 5,
    };

    const char *build_ids = ""build_ids"";
    const char *exact = NULL;
    const char *repo = NULL;
    const char *size_mb = NULL;

    struct options program_options[] = {
        OPT__VERBOSE(&g_verbose),
        OPT_BOOL  ('y', ""yes"",         NULL,                   _(""Noninteractive, assume 'Yes' to all questions"")),
        OPT_STRING('i', ""ids"",   &build_ids, ""BUILD_IDS_FILE"", _(""- means STDIN, default: build_ids"")),
        OPT_STRING('e', ""exact"",     &exact, ""EXACT"",          _(""Download only specified files"")),
        OPT_STRING('r', ""repo"",       &repo, ""REPO"",           _(""Pattern to use when searching for repos, default: *debug*"")),
        OPT_STRING('s', ""size_mb"", &size_mb, ""SIZE_MB"",        _(""Ignored option"")),
        OPT_END()
    };
    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);

    const gid_t egid = getegid();
    const gid_t rgid = getgid();
    const uid_t euid = geteuid();
    const gid_t ruid = getuid();

    /* We need to open the build ids file under the caller's UID/GID to avoid
     * information disclosures when reading files with changed UID.
     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses
     * STDIN to communicate with the caller. So, the following code opens a
     * dummy file descriptor to the build ids file and passes the new fd's proc
     * path to the wrapped program in the ids argument.
     * The new fd remains opened, the OS will close it for us. */
    char *build_ids_self_fd = NULL;
    if (strcmp(""-"", build_ids) != 0)
    {
        if (setregid(egid, rgid) < 0)
            perror_msg_and_die(""setregid(egid, rgid)"");

        if (setreuid(euid, ruid) < 0)
            perror_msg_and_die(""setreuid(euid, ruid)"");

        const int build_ids_fd = open(build_ids, O_RDONLY);

        if (setregid(rgid, egid) < 0)
            perror_msg_and_die(""setregid(rgid, egid)"");

        if (setreuid(ruid, euid) < 0 )
            perror_msg_and_die(""setreuid(ruid, euid)"");

        if (build_ids_fd < 0)
            perror_msg_and_die(""Failed to open file '%s'"", build_ids);

        /* We are not going to free this memory. There is no place to do so. */
         build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd);
     }
 
    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */
    const char *args[11];
     {
         const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" };
         unsigned i = 0;
        args[i++] = EXECUTABLE;
        args[i++] = ""--ids"";
        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : ""-"";
        if (g_verbose > 0)
            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];
        if ((opts & OPT_y))
            args[i++] = ""-y"";
        if ((opts & OPT_e))
        {
            args[i++] = ""--exact"";
            args[i++] = exact;
        }
        if ((opts & OPT_r))
        {
             args[i++] = ""--repo"";
             args[i++] = repo;
         }
         args[i++] = ""--"";
         args[i] = NULL;
     }

    /* Switch real user/group to effective ones.
     * Otherwise yum library gets confused - gets EPERM (why??).
     */
    /* do setregid only if we have to, to not upset selinux needlessly */
    if (egid != rgid)
        IGNORE_RESULT(setregid(egid, egid));
    if (euid != ruid)
    {
        IGNORE_RESULT(setreuid(euid, euid));
        /* We are suid'ed! */
        /* Prevent malicious user from messing up with suid'ed process: */
#if 1

        static const char *whitelist[] = {
            ""REPORT_CLIENT_SLAVE"", //  Check if the app is being run as a slave
            ""LANG"",
        };
        const size_t wlsize = sizeof(whitelist)/sizeof(char*);
        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };
        char *p = NULL;
        for (size_t i = 0; i < wlsize; i++)
            if ((p = getenv(whitelist[i])) != NULL)
                setlist[i] = xstrdup(p);

        clearenv();

        for (size_t i = 0; i < wlsize; i++)
            if (setlist[i] != NULL)
            {
                xsetenv(whitelist[i], setlist[i]);
                free(setlist[i]);
            }
#else
        /* Clear dangerous stuff from env */
        static const char forbid[] =
            ""LD_LIBRARY_PATH"" ""\0""
            ""LD_PRELOAD"" ""\0""
            ""LD_TRACE_LOADED_OBJECTS"" ""\0""
            ""LD_BIND_NOW"" ""\0""
            ""LD_AOUT_LIBRARY_PATH"" ""\0""
            ""LD_AOUT_PRELOAD"" ""\0""
            ""LD_NOWARN"" ""\0""
            ""LD_KEEPDIR"" ""\0""
        ;
        const char *p = forbid;
        do {
            unsetenv(p);
            p += strlen(p) + 1;
        } while (*p);
#endif
        /* Set safe PATH */
        char path_env[] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:""BIN_DIR"":""SBIN_DIR;
        if (euid != 0)
            strcpy(path_env, ""PATH=/usr/bin:/bin:""BIN_DIR);
        putenv(path_env);

        /* Use safe umask */
         umask(0022);
     }
 
    execvp(EXECUTABLE, (char **)args);
    error_msg_and_die(""Can't execute %s"", EXECUTABLE);
 }
",C,"    char tmp_directory[] = LARGE_DATA_TMP_DIR""/abrt-tmp-debuginfo.XXXXXX"";
    if (mkdtemp(tmp_directory) == NULL)
        perror_msg_and_die(""Failed to create working directory"");

    log_info(""Created working directory: %s"", tmp_directory);

    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */
    const char *args[13];
        args[i++] = ""--tmpdir"";
        args[i++] = tmp_directory;
    pid_t pid = fork();
    if (pid < 0)
        perror_msg_and_die(""fork"");

    if (pid == 0)
    {
        execvp(EXECUTABLE, (char **)args);
        error_msg_and_die(""Can't execute %s"", EXECUTABLE);
    }

    int status;
    if (safe_waitpid(pid, &status, 0) < 0)
        perror_msg_and_die(""waitpid"");

    if (rmdir(tmp_directory) >= 0)
        log_info(""Removed working directory: %s"", tmp_directory);
    else if (errno != ENOENT)
        perror_msg(""Failed to remove working directory"");

    /* Normal execution should exit here. */
    if (WIFEXITED(status))
        return WEXITSTATUS(status);

    if (WIFSIGNALED(status))
        error_msg_and_die(""Child terminated with signal %d"", WTERMSIG(status));

    error_msg_and_die(""Child exit failed"");
","    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */
    const char *args[11];
    execvp(EXECUTABLE, (char **)args);
    error_msg_and_die(""Can't execute %s"", EXECUTABLE);
",,"@@ -108,8 +108,14 @@ int main(int argc, char **argv)
         build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd);
     }
 
-    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */
-    const char *args[11];
+    char tmp_directory[] = LARGE_DATA_TMP_DIR""/abrt-tmp-debuginfo.XXXXXX"";
+    if (mkdtemp(tmp_directory) == NULL)
+        perror_msg_and_die(""Failed to create working directory"");
+
+    log_info(""Created working directory: %s"", tmp_directory);
+
+    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */
+    const char *args[13];
     {
         const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" };
         unsigned i = 0;
@@ -130,6 +136,8 @@ int main(int argc, char **argv)
             args[i++] = ""--repo"";
             args[i++] = repo;
         }
+        args[i++] = ""--tmpdir"";
+        args[i++] = tmp_directory;
         args[i++] = ""--"";
         args[i] = NULL;
     }
@@ -204,6 +212,31 @@ int main(int argc, char **argv)
         umask(0022);
     }
 
-    execvp(EXECUTABLE, (char **)args);
-    error_msg_and_die(""Can't execute %s"", EXECUTABLE);
+    pid_t pid = fork();
+    if (pid < 0)
+        perror_msg_and_die(""fork"");
+
+    if (pid == 0)
+    {
+        execvp(EXECUTABLE, (char **)args);
+        error_msg_and_die(""Can't execute %s"", EXECUTABLE);
+    }
+
+    int status;
+    if (safe_waitpid(pid, &status, 0) < 0)
+        perror_msg_and_die(""waitpid"");
+
+    if (rmdir(tmp_directory) >= 0)
+        log_info(""Removed working directory: %s"", tmp_directory);
+    else if (errno != ENOENT)
+        perror_msg(""Failed to remove working directory"");
+
+    /* Normal execution should exit here. */
+    if (WIFEXITED(status))
+        return WEXITSTATUS(status);
+
+    if (WIFSIGNALED(status))
+        error_msg_and_die(""Child terminated with signal %d"", WTERMSIG(status));
+
+    error_msg_and_die(""Child exit failed"");
 }",abrt,50ee8130fb4cd4ef1af7682a2c85dd99cb99424e,bfd3a454cd0a10e8384f8ce421e752867259c874,1,"int main(int argc, char **argv)
{
    /* I18n */
    setlocale(LC_ALL, """");
#if ENABLE_NLS
    bindtextdomain(PACKAGE, LOCALEDIR);
    textdomain(PACKAGE);
#endif

    abrt_init(argv);

    /* Can't keep these strings/structs static: _() doesn't support that */
    const char *program_usage_string = _(
        ""& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\n""
        ""\t[-r REPO]\n""
        ""\n""
        ""Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\n""
        ""ABRT system cache.""
    );

    enum {
        OPT_v = 1 << 0,
        OPT_y = 1 << 1,
        OPT_i = 1 << 2,
        OPT_e = 1 << 3,
        OPT_r = 1 << 4,
        OPT_s = 1 << 5,
    };

    const char *build_ids = ""build_ids"";
    const char *exact = NULL;
    const char *repo = NULL;
    const char *size_mb = NULL;

    struct options program_options[] = {
        OPT__VERBOSE(&g_verbose),
        OPT_BOOL  ('y', ""yes"",         NULL,                   _(""Noninteractive, assume 'Yes' to all questions"")),
        OPT_STRING('i', ""ids"",   &build_ids, ""BUILD_IDS_FILE"", _(""- means STDIN, default: build_ids"")),
        OPT_STRING('e', ""exact"",     &exact, ""EXACT"",          _(""Download only specified files"")),
        OPT_STRING('r', ""repo"",       &repo, ""REPO"",           _(""Pattern to use when searching for repos, default: *debug*"")),
        OPT_STRING('s', ""size_mb"", &size_mb, ""SIZE_MB"",        _(""Ignored option"")),
        OPT_END()
    };
    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);

    const gid_t egid = getegid();
    const gid_t rgid = getgid();
    const uid_t euid = geteuid();
    const gid_t ruid = getuid();

    /* We need to open the build ids file under the caller's UID/GID to avoid
     * information disclosures when reading files with changed UID.
     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses
     * STDIN to communicate with the caller. So, the following code opens a
     * dummy file descriptor to the build ids file and passes the new fd's proc
     * path to the wrapped program in the ids argument.
     * The new fd remains opened, the OS will close it for us. */
    char *build_ids_self_fd = NULL;
    if (strcmp(""-"", build_ids) != 0)
    {
        if (setregid(egid, rgid) < 0)
            perror_msg_and_die(""setregid(egid, rgid)"");

        if (setreuid(euid, ruid) < 0)
            perror_msg_and_die(""setreuid(euid, ruid)"");

        const int build_ids_fd = open(build_ids, O_RDONLY);

        if (setregid(rgid, egid) < 0)
            perror_msg_and_die(""setregid(rgid, egid)"");

        if (setreuid(ruid, euid) < 0 )
            perror_msg_and_die(""setreuid(ruid, euid)"");

        if (build_ids_fd < 0)
            perror_msg_and_die(""Failed to open file '%s'"", build_ids);

        /* We are not going to free this memory. There is no place to do so. */
         build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd);
     }
 
//flaw_line_below:
    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */
//flaw_line_below:
    const char *args[11];
//fix_flaw_line_below:
//    char tmp_directory[] = LARGE_DATA_TMP_DIR""/abrt-tmp-debuginfo.XXXXXX"";
//fix_flaw_line_below:
//    if (mkdtemp(tmp_directory) == NULL)
//fix_flaw_line_below:
//        perror_msg_and_die(""Failed to create working directory"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    log_info(""Created working directory: %s"", tmp_directory);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */
//fix_flaw_line_below:
//    const char *args[13];
     {
         const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" };
         unsigned i = 0;
        args[i++] = EXECUTABLE;
        args[i++] = ""--ids"";
        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : ""-"";
        if (g_verbose > 0)
            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];
        if ((opts & OPT_y))
            args[i++] = ""-y"";
        if ((opts & OPT_e))
        {
            args[i++] = ""--exact"";
            args[i++] = exact;
        }
        if ((opts & OPT_r))
        {
             args[i++] = ""--repo"";
             args[i++] = repo;
         }
//fix_flaw_line_below:
//        args[i++] = ""--tmpdir"";
//fix_flaw_line_below:
//        args[i++] = tmp_directory;
         args[i++] = ""--"";
         args[i] = NULL;
     }

    /* Switch real user/group to effective ones.
     * Otherwise yum library gets confused - gets EPERM (why??).
     */
    /* do setregid only if we have to, to not upset selinux needlessly */
    if (egid != rgid)
        IGNORE_RESULT(setregid(egid, egid));
    if (euid != ruid)
    {
        IGNORE_RESULT(setreuid(euid, euid));
        /* We are suid'ed! */
        /* Prevent malicious user from messing up with suid'ed process: */
#if 1
// We forgot to sanitize PYTHONPATH. And who knows what else we forgot
// (especially considering *future* new variables of this kind).
// We switched to clearing entire environment instead:

        // However since we communicate through environment variables
        // we have to keep a whitelist of variables to keep.
        static const char *whitelist[] = {
            ""REPORT_CLIENT_SLAVE"", //  Check if the app is being run as a slave
            ""LANG"",
        };
        const size_t wlsize = sizeof(whitelist)/sizeof(char*);
        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };
        char *p = NULL;
        for (size_t i = 0; i < wlsize; i++)
            if ((p = getenv(whitelist[i])) != NULL)
                setlist[i] = xstrdup(p);

        // Now we can clear the environment
        clearenv();

        // And once again set whitelisted variables
        for (size_t i = 0; i < wlsize; i++)
            if (setlist[i] != NULL)
            {
                xsetenv(whitelist[i], setlist[i]);
                free(setlist[i]);
            }
#else
        /* Clear dangerous stuff from env */
        static const char forbid[] =
            ""LD_LIBRARY_PATH"" ""\0""
            ""LD_PRELOAD"" ""\0""
            ""LD_TRACE_LOADED_OBJECTS"" ""\0""
            ""LD_BIND_NOW"" ""\0""
            ""LD_AOUT_LIBRARY_PATH"" ""\0""
            ""LD_AOUT_PRELOAD"" ""\0""
            ""LD_NOWARN"" ""\0""
            ""LD_KEEPDIR"" ""\0""
        ;
        const char *p = forbid;
        do {
            unsetenv(p);
            p += strlen(p) + 1;
        } while (*p);
#endif
        /* Set safe PATH */
        // Adding configure --bindir and --sbindir to the PATH so that
        // abrt-action-install-debuginfo doesn't fail when spawning
        // abrt-action-trim-files
        char path_env[] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:""BIN_DIR"":""SBIN_DIR;
        if (euid != 0)
            strcpy(path_env, ""PATH=/usr/bin:/bin:""BIN_DIR);
        putenv(path_env);

        /* Use safe umask */
         umask(0022);
     }
 
//flaw_line_below:
    execvp(EXECUTABLE, (char **)args);
//flaw_line_below:
    error_msg_and_die(""Can't execute %s"", EXECUTABLE);
//fix_flaw_line_below:
//    pid_t pid = fork();
//fix_flaw_line_below:
//    if (pid < 0)
//fix_flaw_line_below:
//        perror_msg_and_die(""fork"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (pid == 0)
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//        execvp(EXECUTABLE, (char **)args);
//fix_flaw_line_below:
//        error_msg_and_die(""Can't execute %s"", EXECUTABLE);
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    int status;
//fix_flaw_line_below:
//    if (safe_waitpid(pid, &status, 0) < 0)
//fix_flaw_line_below:
//        perror_msg_and_die(""waitpid"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (rmdir(tmp_directory) >= 0)
//fix_flaw_line_below:
//        log_info(""Removed working directory: %s"", tmp_directory);
//fix_flaw_line_below:
//    else if (errno != ENOENT)
//fix_flaw_line_below:
//        perror_msg(""Failed to remove working directory"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    /* Normal execution should exit here. */
//fix_flaw_line_below:
//    if (WIFEXITED(status))
//fix_flaw_line_below:
//        return WEXITSTATUS(status);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (WIFSIGNALED(status))
//fix_flaw_line_below:
//        error_msg_and_die(""Child terminated with signal %d"", WTERMSIG(status));
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    error_msg_and_die(""Child exit failed"");
 }
"
2145,179881,,Local,Not required,Complete,CVE-2015-1335,https://www.cvedetails.com/cve/CVE-2015-1335/,CWE-59,Low,Complete,Complete,,2015-10-01,7.2,lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.,2019-05-31,,4,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,592fd47a6245508b79fe6ac819fe6d3b2c1289be,"CVE-2015-1335: Protect container mounts against symlinks

When a container starts up, lxc sets up the container's inital fstree
by doing a bunch of mounting, guided by the container configuration
file.  The container config is owned by the admin or user on the host,
so we do not try to guard against bad entries.  However, since the
mount target is in the container, it's possible that the container admin
could divert the mount with symbolic links.  This could bypass proper
container startup (i.e. confinement of a root-owned container by the
restrictive apparmor policy, by diverting the required write to
/proc/self/attr/current), or bypass the (path-based) apparmor policy
by diverting, say, /proc to /mnt in the container.

To prevent this,

1. do not allow mounts to paths containing symbolic links

2. do not allow bind mounts from relative paths containing symbolic
links.

Details:

Define safe_mount which ensures that the container has not inserted any
symbolic links into any mount targets for mounts to be done during
container setup.

The host's mount path may contain symbolic links.  As it is under the
control of the administrator, that's ok.  So safe_mount begins the check
for symbolic links after the rootfs->mount, by opening that directory.

It opens each directory along the path using openat() relative to the
parent directory using O_NOFOLLOW.  When the target is reached, it
mounts onto /proc/self/fd/<targetfd>.

Use safe_mount() in mount_entry(), when mounting container proc,
and when needed.  In particular, safe_mount() need not be used in
any case where:

1. the mount is done in the container's namespace
2. the mount is for the container's rootfs
3. the mount is relative to a tmpfs or proc/sysfs which we have
   just safe_mount()ed ourselves

Since we were using proc/net as a temporary placeholder for /proc/sys/net
during container startup, and proc/net is a symbolic link, use proc/tty
instead.

Update the lxc.container.conf manpage with details about the new
restrictions.

Finally, add a testcase to test some symbolic link possibilities.

Reported-by: Roman Fiedler
Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Acked-by: Stphane Graber <stgraber@ubuntu.com>",1,src/lxc/cgfs.c,"{""sha"": ""eb3241f795d2f3e0f1fb762516983b74e99af52f"", ""filename"": ""doc/lxc.container.conf.sgml.in"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/doc/lxc.container.conf.sgml.in?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -760,6 +760,18 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n         container. This is useful to mount /etc, /var or /home for\n         examples.\n       </para>\n+      <para>\n+\tNOTE - LXC will generally ensure that mount targets and relative\n+\tbind-mount sources are properly confined under the container\n+\troot, to avoid attacks involving over-mounting host directories\n+\tand files.  (Symbolic links in absolute mount sources are ignored)\n+\tHowever, if the container configuration first mounts a directory which\n+\tis under the control of the container user, such as /home/joe, into\n+        the container at some <filename>path</filename>, and then mounts\n+        under <filename>path</filename>, then a TOCTTOU attack would be\n+        possible where the container user modifies a symbolic link under\n+        his home directory at just the right time.\n+      </para>\n       <variablelist>\n         <varlistentry>\n           <term>""}<_**next**_>{""sha"": ""df2e6b2333bc81f94bf7583087475fd8d62605a1"", ""filename"": ""src/lxc/cgfs.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgfs.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1363,7 +1363,10 @@ static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \""%s/sys/fs/cgroup\"", root);\n-\tr = mount(\""cgroup_root\"", path, \""tmpfs\"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \""size=10240k,mode=755\"");\n+\tr = safe_mount(\""cgroup_root\"", path, \""tmpfs\"",\n+\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n+\t\t\t\""size=10240k,mode=755\"",\n+\t\t\troot);\n \tif (r < 0) {\n \t\tSYSERROR(\""could not mount tmpfs to /sys/fs/cgroup in the container\"");\n \t\treturn false;""}<_**next**_>{""sha"": ""a677c22c768eccccaa3af386c662c43dad8412cf"", ""filename"": ""src/lxc/cgmanager.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgmanager.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1477,7 +1477,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t}\n \n \t/* mount a tmpfs there so we can create subdirs */\n-\tif (mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"")) {\n+\tif (safe_mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"", root)) {\n \t\tSYSERROR(\""Failed to mount tmpfs at %s\"", cgpath);\n \t\treturn false;\n \t}\n@@ -1488,7 +1488,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t\treturn false;\n \t}\n \n-\tif (mount(dirname, cgpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(dirname, cgpath, \""none\"", MS_BIND, 0, root)) {\n \t\tSYSERROR(\""Failed to bind mount %s to %s\"", dirname, cgpath);\n \t\treturn false;\n \t}""}<_**next**_>{""sha"": ""bb4c19f82e2c806b07125cbfd9ed3220df07be38"", ""filename"": ""src/lxc/conf.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 16, ""changes"": 35, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/conf.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t * 2.6.32...\n \t\t */\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/net\"",                  NULL,       MS_BIND,                        NULL },\n+\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/tty\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys\"",                                       \""%r/proc/sys\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sys\"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/net\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/tty\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sysrq-trigger\"",                             \""%r/proc/sysrq-trigger\"",        NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sysrq-trigger\"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t\t}\n \t\t\tmflags = add_required_remount_flags(source, destination,\n \t\t\t\t\tdefault_mounts[i].flags);\n-\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n+\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n \t\t\tsaved_errno = errno;\n \t\t\tif (r < 0 && errno == ENOENT) {\n \t\t\t\tINFO(\""Mount source or target for %s on %s doesn't exist. Skipping.\"", source, destination);\n@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons\n \t\treturn 0;\n \t}\n \n-\tif (mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"")) {\n+\tif (safe_mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"",\n+\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n \t\tSYSERROR(\""Failed mounting tmpfs onto %s\\n\"", path);\n \t\treturn false;\n \t}\n@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tfclose(pathfile);\n-\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n+\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n+\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n \t\t\t\tSYSERROR(\""Failed bind mounting device %s from host into container\"",\n \t\t\t\t\td->name);\n \t\t\t\treturn -1;\n@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,\n \t\treturn -1;\n \t}\n \n-\tif (mount(console->name, path, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, path, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, path);\n \t\treturn -1;\n \t}\n@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n \t\treturn 0;\n \t}\n \n-\tif (mount(console->name, lxcpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, lxcpath, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, lxcpath);\n \t\treturn -1;\n \t}\n@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)\n \n static int mount_entry(const char *fsname, const char *target,\n \t\t       const char *fstype, unsigned long mountflags,\n-\t\t       const char *data, int optional)\n+\t\t       const char *data, int optional, const char *rootfs)\n {\n #ifdef HAVE_STATVFS\n \tstruct statvfs sb;\n #endif\n \n-\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n+\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n \t\tif (optional) {\n \t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"", fsname,\n \t\t\t     target, strerror(errno));\n@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,\n #endif\n \n \t\tif (mount(fsname, target, fstype,\n-\t\t\t  mountflags | MS_REMOUNT, data)) {\n+\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n \t\t\tif (optional) {\n \t\t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"",\n \t\t\t\t\t fsname, target, strerror(errno));\n@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,\n }\n \n static inline int mount_entry_on_generic(struct mntent *mntent,\n-                 const char* path)\n+                 const char* path, const char *rootfs)\n {\n \tunsigned long mntflags;\n \tchar *mntdata;\n@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \t}\n \n \tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n-\t\t\t  mntflags, mntdata, optional);\n+\t\t\t  mntflags, mntdata, optional, rootfs);\n \n \tfree(mntdata);\n \n@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \n static inline int mount_entry_on_systemfs(struct mntent *mntent)\n {\n-  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n }\n \n static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n }\n \n static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs);\n }\n \n static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \""none\"", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \""none\"", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\""Failed to bind lxc.init.static into container\"");\n \tINFO(\""lxc.init.static bound into container at %s\"", path);""}<_**next**_>{""sha"": ""788cbe136302bb46a559c36dc45a895f8c584574"", ""filename"": ""src/lxc/utils.c"", ""status"": ""modified"", ""additions"": 234, ""deletions"": 1, ""changes"": 235, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1404,6 +1404,239 @@ int setproctitle(char *title)\n \treturn ret;\n }\n \n+/*\n+ * @path:    a pathname where / replaced with '\\0'.\n+ * @offsetp: pointer to int showing which path segment was last seen.\n+ *           Updated on return to reflect the next segment.\n+ * @fulllen: full original path length.\n+ * Returns a pointer to the next path segment, or NULL if done.\n+ */\n+static char *get_nextpath(char *path, int *offsetp, int fulllen)\n+{\n+\tint offset = *offsetp;\n+\n+\tif (offset >= fulllen)\n+\t\treturn NULL;\n+\n+\twhile (path[offset] != '\\0' && offset < fulllen)\n+\t\toffset++;\n+\twhile (path[offset] == '\\0' && offset < fulllen)\n+\t\toffset++;\n+\n+\t*offsetp = offset;\n+\treturn (offset < fulllen) ? &path[offset] : NULL;\n+}\n+\n+/*\n+ * Check that @subdir is a subdir of @dir.  @len is the length of\n+ * @dir (to avoid having to recalculate it).\n+ */\n+static bool is_subdir(const char *subdir, const char *dir, size_t len)\n+{\n+\tsize_t subdirlen = strlen(subdir);\n+\n+\tif (subdirlen < len)\n+\t\treturn false;\n+\tif (strncmp(subdir, dir, len) != 0)\n+\t\treturn false;\n+\tif (dir[len-1] == '/')\n+\t\treturn true;\n+\tif (subdir[len] == '/' || subdirlen == len)\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+/*\n+ * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return\n+ * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.\n+ */\n+static int check_symlink(int fd)\n+{\n+\tstruct stat sb;\n+\tint ret = fstat(fd, &sb);\n+\tif (ret < 0)\n+\t\treturn -ENOENT;\n+\tif (S_ISLNK(sb.st_mode))\n+\t\treturn -ELOOP;\n+\treturn 0;\n+}\n+\n+/*\n+ * Open a file or directory, provided that it contains no symlinks.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+static int open_if_safe(int dirfd, const char *nextpath)\n+{\n+\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n+\tif (newfd >= 0) // was not a symlink, all good\n+\t\treturn newfd;\n+\n+\tif (errno == ELOOP)\n+\t\treturn newfd;\n+\n+\tif (errno == EPERM || errno == EACCES) {\n+\t\t/* we're not root (cause we got EPERM) so\n+\t\t   try opening with O_PATH */\n+\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n+\t\tif (newfd >= 0) {\n+\t\t\t/* O_PATH will return an fd for symlinks.  We know\n+\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n+\t\t\t * is now a link, then something * fishy is going on\n+\t\t\t */\n+\t\t\tint ret = check_symlink(newfd);\n+\t\t\tif (ret < 0) {\n+\t\t\t\tclose(newfd);\n+\t\t\t\tnewfd = ret;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newfd;\n+}\n+\n+/*\n+ * Open a path intending for mounting, ensuring that the final path\n+ * is inside the container's rootfs.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ *\n+ * @target: path to be opened\n+ * @prefix_skip: a part of @target in which to ignore symbolic links.  This\n+ * would be the container's rootfs.\n+ *\n+ * Return an open fd for the path, or <0 on error.\n+ */\n+static int open_without_symlink(const char *target, const char *prefix_skip)\n+{\n+\tint curlen = 0, dirfd, fulllen, i;\n+\tchar *dup = NULL;\n+\n+\tfulllen = strlen(target);\n+\n+\t/* make sure prefix-skip makes sense */\n+\tif (prefix_skip) {\n+\t\tcurlen = strlen(prefix_skip);\n+\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n+\t\t\tERROR(\""WHOA there - target '%s' didn't start with prefix '%s'\"",\n+\t\t\t\ttarget, prefix_skip);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\t/*\n+\t\t * get_nextpath() expects the curlen argument to be\n+\t\t * on a  (turned into \\0) / or before it, so decrement\n+\t\t * curlen to make sure that happens\n+\t\t */\n+\t\tif (curlen)\n+\t\t\tcurlen--;\n+\t} else {\n+\t\tprefix_skip = \""/\"";\n+\t\tcurlen = 0;\n+\t}\n+\n+\t/* Make a copy of target which we can hack up, and tokenize it */\n+\tif ((dup = strdup(target)) == NULL) {\n+\t\tSYSERROR(\""Out of memory checking for symbolic link\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\tfor (i = 0; i < fulllen; i++) {\n+\t\tif (dup[i] == '/')\n+\t\t\tdup[i] = '\\0';\n+\t}\n+\n+\tdirfd = open(prefix_skip, O_RDONLY);\n+\tif (dirfd < 0)\n+\t\tgoto out;\n+\twhile (1) {\n+\t\tint newfd, saved_errno;\n+\t\tchar *nextpath;\n+\n+\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n+\t\t\tgoto out;\n+\t\tnewfd = open_if_safe(dirfd, nextpath);\n+\t\tsaved_errno = errno;\n+\t\tclose(dirfd);\n+\t\tdirfd = newfd;\n+\t\tif (newfd < 0) {\n+\t\t\terrno = saved_errno;\n+\t\t\tif (errno == ELOOP)\n+\t\t\t\tSYSERROR(\""%s in %s was a symbolic link!\"", nextpath, target);\n+\t\t\telse\n+\t\t\t\tSYSERROR(\""Error examining %s in %s\"", nextpath, target);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+out:\n+\tfree(dup);\n+\treturn dirfd;\n+}\n+\n+/*\n+ * Safely mount a path into a container, ensuring that the mount target\n+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container\n+ * uses the host's /)\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs)\n+{\n+\tint srcfd = -1, destfd, ret, saved_errno;\n+\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n+\tconst char *mntsrc = src;\n+\n+\tif (!rootfs)\n+\t\trootfs = \""\"";\n+\n+\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n+\tif (flags & MS_BIND && src && src[0] != '/') {\n+\t\tINFO(\""this is a relative bind mount\"");\n+\t\tsrcfd = open_without_symlink(src, NULL);\n+\t\tif (srcfd < 0)\n+\t\t\treturn srcfd;\n+\t\tret = snprintf(srcbuf, 50, \""/proc/self/fd/%d\"", srcfd);\n+\t\tif (ret < 0 || ret > 50) {\n+\t\t\tclose(srcfd);\n+\t\t\tERROR(\""Out of memory\"");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tmntsrc = srcbuf;\n+\t}\n+\n+\tdestfd = open_without_symlink(dest, rootfs);\n+\tif (destfd < 0) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\treturn destfd;\n+\t}\n+\n+\tret = snprintf(destbuf, 50, \""/proc/self/fd/%d\"", destfd);\n+\tif (ret < 0 || ret > 50) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\tclose(destfd);\n+\t\tERROR(\""Out of memory\"");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tret = mount(mntsrc, destbuf, fstype, flags, data);\n+\tsaved_errno = errno;\n+\tif (srcfd != -1)\n+\t\tclose(srcfd);\n+\tclose(destfd);\n+\tif (ret < 0) {\n+\t\terrno = saved_errno;\n+\t\tSYSERROR(\""Failed to mount %s onto %s\"", src, dest);\n+\t\treturn ret;\n+\t}\n+\n+\treturn 0;\n+}\n+\n /*\n  * Mount a proc under @rootfs if proc self points to a pid other than\n  * my own.  This is needed to have a known-good proc mount for setting\n@@ -1446,7 +1679,7 @@ int mount_proc_if_needed(const char *rootfs)\n \treturn 0;\n \n domount:\n-\tif (mount(\""proc\"", path, \""proc\"", 0, NULL))\n+\tif (safe_mount(\""proc\"", path, \""proc\"", 0, NULL, rootfs) < 0)\n \t\treturn -1;\n \tINFO(\""Mounted /proc in container for security transition\"");\n \treturn 1;""}<_**next**_>{""sha"": ""059026f0154b1713854c84674d12954a09469506"", ""filename"": ""src/lxc/utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.h?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -279,6 +279,8 @@ bool switch_to_ns(pid_t pid, const char *ns);\n int is_dir(const char *path);\n char *get_template_path(const char *t);\n int setproctitle(char *title);\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs);\n int mount_proc_if_needed(const char *rootfs);\n int null_stdfds(void);\n #endif /* __LXC_UTILS_H */""}<_**next**_>{""sha"": ""462d4f27882715442c3183b9db6620430b767455"", ""filename"": ""src/tests/Makefile.am"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/Makefile.am?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -55,6 +55,7 @@ bin_SCRIPTS += \\\n \tlxc-test-apparmor-mount \\\n \tlxc-test-checkpoint-restore \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tlxc-test-usernic\n@@ -82,6 +83,7 @@ EXTRA_DIST = \\\n \tlxc-test-cloneconfig \\\n \tlxc-test-createconfig \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tmay_control.c \\""}<_**next**_>{""sha"": ""37320f0dfd96b262d52bc99e314b7fe3cb026bb1"", ""filename"": ""src/tests/lxc-test-symlink"", ""status"": ""added"", ""additions"": 88, ""deletions"": 0, ""changes"": 88, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/lxc-test-symlink?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -0,0 +1,88 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+# lxc: linux Container library\n+\n+# Authors:\n+# Serge Hallyn <serge.hallyn@ubuntu.com>\n+#\n+# This is a regression test for symbolic links\n+\n+dirname=`mktemp -d`\n+fname=`mktemp`\n+fname2=`mktemp`\n+\n+lxcpath=/var/lib/lxcsym1\n+\n+cleanup() {\n+\tlxc-destroy -P $lxcpath -f -n symtest1 || true\n+\trm -f $lxcpath\n+\trmdir $dirname || true\n+\trm -f $fname || true\n+\trm -f $fname2 || true\n+}\n+\n+trap cleanup EXIT SIGHUP SIGINT SIGTERM\n+\n+testrun() {\n+\texpected=$1\n+\trun=$2\n+\tpass=\""pass\""\n+\tlxc-start -P $lxcpath -n symtest1 -l trace -o $lxcpath/log || pass=\""fail\""\n+\t[ $pass = \""pass\"" ] && lxc-wait -P $lxcpath -n symtest1 -t 10 -s RUNNING || pass=\""fail\""\n+\tif [ \""$pass\"" != \""$expected\"" ]; then\n+\t\techo \""Test $run: expected $expected but container did not.  Start log:\""\n+\t\tcat $lxcpath/log\n+\t\techo \""FAIL: Test $run: expected $expected but container did not.\""\n+\t\tfalse\n+\tfi\n+\tlxc-stop -P $lxcpath -n symtest1 -k || true\n+}\n+\n+# make lxcpath a symlink - this should NOT cause failure\n+ln -s /var/lib/lxc $lxcpath\n+\n+lxc-destroy -P $lxcpath -f -n symtest1 || true\n+lxc-create -P $lxcpath -t busybox -n symtest1\n+\n+cat >> /var/lib/lxc/symtest1/config << EOF\n+lxc.mount.entry = $dirname opt/xxx/dir none bind,create=dir\n+lxc.mount.entry = $fname opt/xxx/file none bind,create=file\n+lxc.mount.entry = $fname2 opt/xxx/file2 none bind\n+EOF\n+\n+# Regular - should succeed\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun pass 1\n+\n+# symlink - should fail\n+rm -rf /var/lib/lxc/symtest1/rootfs/opt/xxx\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx2\n+ln -s /var/lib/lxc/symtest1/rootfs/opt/xxx2 /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun fail 2\n+\n+# final final symlink - should fail\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx/dir\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2src\n+ln -s $lxcpath/symtest1/rootfs/opt/xxx/file2src $lxcpath/symtest1/rootfs/opt/xxx/file2\n+testrun fail 3\n+\n+# Ideally we'd also try a loop device, but that won't work in nested containers\n+# anyway - TODO\n+\n+# what about /proc itself\n+\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2\n+mv $lxcpath/symtest1/rootfs/proc $lxcpath/symtest1/rootfs/proc1\n+ln -s $lxcpath/symtest1/rootfs/proc1 $lxcpath/symtest1/rootfs/proc\n+testrun fail 4\n+\n+echo \""all tests passed\""""}","static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)
{
	size_t bufsz = strlen(root) + sizeof(""/sys/fs/cgroup"");
	char *path = NULL;
	char **parts = NULL;
	char *dirname = NULL;
	char *abs_path = NULL;
	char *abs_path2 = NULL;
	struct cgfs_data *cgfs_d;
	struct cgroup_process_info *info, *base_info;
	int r, saved_errno = 0;

	cgfs_d = hdata;
	if (!cgfs_d)
		return false;
	base_info = cgfs_d->info;

	/* If we get passed the _NOSPEC types, we default to _MIXED, since we don't
	 * have access to the lxc_conf object at this point. It really should be up
	 * to the caller to fix this, but this doesn't really hurt.
	 */
	if (type == LXC_AUTO_CGROUP_FULL_NOSPEC)
		type = LXC_AUTO_CGROUP_FULL_MIXED;
	else if (type == LXC_AUTO_CGROUP_NOSPEC)
		type = LXC_AUTO_CGROUP_MIXED;

	if (type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED) {
		ERROR(""could not mount cgroups into container: invalid type specified internally"");
		errno = EINVAL;
		return false;
	}

	path = calloc(1, bufsz);
 	if (!path)
 		return false;
 	snprintf(path, bufsz, ""%s/sys/fs/cgroup"", root);
	r = safe_mount(""cgroup_root"", path, ""tmpfs"",
			MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,
			""size=10240k,mode=755"",
			root);
 	if (r < 0) {
 		SYSERROR(""could not mount tmpfs to /sys/fs/cgroup in the container"");
 		return false;
	}

	/* now mount all the hierarchies we care about */
	for (info = base_info; info; info = info->next) {
		size_t subsystem_count, i;
		struct cgroup_mount_point *mp = info->designated_mount_point;
		if (!mp)
			mp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);
		if (!mp) {
			SYSERROR(""could not find original mount point for cgroup hierarchy while trying to mount cgroup filesystem"");
			goto out_error;
		}

		subsystem_count = lxc_array_len((void **)info->hierarchy->subsystems);
		parts = calloc(subsystem_count + 1, sizeof(char *));
		if (!parts)
			goto out_error;

		for (i = 0; i < subsystem_count; i++) {
			if (!strncmp(info->hierarchy->subsystems[i], ""name="", 5))
				parts[i] = info->hierarchy->subsystems[i] + 5;
			else
				parts[i] = info->hierarchy->subsystems[i];
		}
		dirname = lxc_string_join("","", (const char **)parts, false);
		if (!dirname)
			goto out_error;

		/* create subsystem directory */
		abs_path = lxc_append_paths(path, dirname);
		if (!abs_path)
			goto out_error;
		r = mkdir_p(abs_path, 0755);
		if (r < 0 && errno != EEXIST) {
			SYSERROR(""could not create cgroup subsystem directory /sys/fs/cgroup/%s"", dirname);
			goto out_error;
		}

		abs_path2 = lxc_append_paths(abs_path, info->cgroup_path);
		if (!abs_path2)
			goto out_error;

		if (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED) {
			/* bind-mount the cgroup entire filesystem there */
			if (strcmp(mp->mount_prefix, ""/"") != 0) {
				/* FIXME: maybe we should just try to remount the entire hierarchy
				 *        with a regular mount command? may that works? */
				ERROR(""could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup"", dirname);
				goto out_error;
			}
			r = mount(mp->mount_point, abs_path, ""none"", MS_BIND, 0);
			if (r < 0) {
				SYSERROR(""error bind-mounting %s to %s"", mp->mount_point, abs_path);
				goto out_error;
			}
			/* main cgroup path should be read-only */
			if (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_MIXED) {
				r = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);
				if (r < 0) {
					SYSERROR(""error re-mounting %s readonly"", abs_path);
					goto out_error;
				}
			}
			/* own cgroup should be read-write */
			if (type == LXC_AUTO_CGROUP_FULL_MIXED) {
				r = mount(abs_path2, abs_path2, NULL, MS_BIND, NULL);
				if (r < 0) {
					SYSERROR(""error bind-mounting %s onto itself"", abs_path2);
					goto out_error;
				}
				r = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND, NULL);
				if (r < 0) {
					SYSERROR(""error re-mounting %s readwrite"", abs_path2);
					goto out_error;
				}
			}
		} else {
			/* create path for container's cgroup */
			r = mkdir_p(abs_path2, 0755);
			if (r < 0 && errno != EEXIST) {
				SYSERROR(""could not create cgroup directory /sys/fs/cgroup/%s%s"", dirname, info->cgroup_path);
				goto out_error;
			}

			/* for read-only and mixed cases, we have to bind-mount the tmpfs directory
			 * that points to the hierarchy itself (i.e. /sys/fs/cgroup/cpu etc.) onto
			 * itself and then bind-mount it read-only, since we keep the tmpfs itself
			 * read-write (see comment below)
			 */
			if (type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO) {
				r = mount(abs_path, abs_path, NULL, MS_BIND, NULL);
				if (r < 0) {
					SYSERROR(""error bind-mounting %s onto itself"", abs_path);
					goto out_error;
				}
				r = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);
				if (r < 0) {
					SYSERROR(""error re-mounting %s readonly"", abs_path);
					goto out_error;
				}
			}

			free(abs_path);
			abs_path = NULL;

			/* bind-mount container's cgroup to that directory */
			abs_path = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);
			if (!abs_path)
				goto out_error;
			r = mount(abs_path, abs_path2, ""none"", MS_BIND, 0);
			if (r < 0) {
				SYSERROR(""error bind-mounting %s to %s"", abs_path, abs_path2);
				goto out_error;
			}
			if (type == LXC_AUTO_CGROUP_RO) {
				r = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);
				if (r < 0) {
					SYSERROR(""error re-mounting %s readonly"", abs_path2);
					goto out_error;
				}
			}
		}

		free(abs_path);
		free(abs_path2);
		abs_path = NULL;
		abs_path2 = NULL;

		/* add symlinks for every single subsystem */
		if (subsystem_count > 1) {
			for (i = 0; i < subsystem_count; i++) {
				abs_path = lxc_append_paths(path, parts[i]);
				if (!abs_path)
					goto out_error;
				r = symlink(dirname, abs_path);
				if (r < 0)
					WARN(""could not create symlink %s -> %s in /sys/fs/cgroup of container"", parts[i], dirname);
				free(abs_path);
				abs_path = NULL;
			}
		}
		free(dirname);
		free(parts);
		dirname = NULL;
		parts = NULL;
	}

	/* We used to remount the entire tmpfs readonly if any :ro or
	 * :mixed mode was specified. However, Ubuntu's mountall has the
	 * unfortunate behavior to block bootup if /sys/fs/cgroup is
	 * mounted read-only and cannot be remounted read-write.
	 * (mountall reads /lib/init/fstab and tries to (re-)mount all of
	 * these if they are not already mounted with the right options;
	 * it contains an entry for /sys/fs/cgroup. In case it can't do
	 * that, it prompts for the user to either manually fix it or
	 * boot anyway. But without user input, booting of the container
	 * hangs.)
	 *
	 * Instead of remounting the entire tmpfs readonly, we only
	 * remount the paths readonly that are part of the cgroup
	 * hierarchy.
	 */

	free(path);

	return true;

out_error:
	saved_errno = errno;
	free(path);
	free(dirname);
	free(parts);
	free(abs_path);
	free(abs_path2);
	errno = saved_errno;
	return false;
}
","static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)
{
	size_t bufsz = strlen(root) + sizeof(""/sys/fs/cgroup"");
	char *path = NULL;
	char **parts = NULL;
	char *dirname = NULL;
	char *abs_path = NULL;
	char *abs_path2 = NULL;
	struct cgfs_data *cgfs_d;
	struct cgroup_process_info *info, *base_info;
	int r, saved_errno = 0;

	cgfs_d = hdata;
	if (!cgfs_d)
		return false;
	base_info = cgfs_d->info;

	/* If we get passed the _NOSPEC types, we default to _MIXED, since we don't
	 * have access to the lxc_conf object at this point. It really should be up
	 * to the caller to fix this, but this doesn't really hurt.
	 */
	if (type == LXC_AUTO_CGROUP_FULL_NOSPEC)
		type = LXC_AUTO_CGROUP_FULL_MIXED;
	else if (type == LXC_AUTO_CGROUP_NOSPEC)
		type = LXC_AUTO_CGROUP_MIXED;

	if (type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED) {
		ERROR(""could not mount cgroups into container: invalid type specified internally"");
		errno = EINVAL;
		return false;
	}

	path = calloc(1, bufsz);
 	if (!path)
 		return false;
 	snprintf(path, bufsz, ""%s/sys/fs/cgroup"", root);
	r = mount(""cgroup_root"", path, ""tmpfs"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, ""size=10240k,mode=755"");
 	if (r < 0) {
 		SYSERROR(""could not mount tmpfs to /sys/fs/cgroup in the container"");
 		return false;
	}

	/* now mount all the hierarchies we care about */
	for (info = base_info; info; info = info->next) {
		size_t subsystem_count, i;
		struct cgroup_mount_point *mp = info->designated_mount_point;
		if (!mp)
			mp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);
		if (!mp) {
			SYSERROR(""could not find original mount point for cgroup hierarchy while trying to mount cgroup filesystem"");
			goto out_error;
		}

		subsystem_count = lxc_array_len((void **)info->hierarchy->subsystems);
		parts = calloc(subsystem_count + 1, sizeof(char *));
		if (!parts)
			goto out_error;

		for (i = 0; i < subsystem_count; i++) {
			if (!strncmp(info->hierarchy->subsystems[i], ""name="", 5))
				parts[i] = info->hierarchy->subsystems[i] + 5;
			else
				parts[i] = info->hierarchy->subsystems[i];
		}
		dirname = lxc_string_join("","", (const char **)parts, false);
		if (!dirname)
			goto out_error;

		/* create subsystem directory */
		abs_path = lxc_append_paths(path, dirname);
		if (!abs_path)
			goto out_error;
		r = mkdir_p(abs_path, 0755);
		if (r < 0 && errno != EEXIST) {
			SYSERROR(""could not create cgroup subsystem directory /sys/fs/cgroup/%s"", dirname);
			goto out_error;
		}

		abs_path2 = lxc_append_paths(abs_path, info->cgroup_path);
		if (!abs_path2)
			goto out_error;

		if (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED) {
			/* bind-mount the cgroup entire filesystem there */
			if (strcmp(mp->mount_prefix, ""/"") != 0) {
				/* FIXME: maybe we should just try to remount the entire hierarchy
				 *        with a regular mount command? may that works? */
				ERROR(""could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup"", dirname);
				goto out_error;
			}
			r = mount(mp->mount_point, abs_path, ""none"", MS_BIND, 0);
			if (r < 0) {
				SYSERROR(""error bind-mounting %s to %s"", mp->mount_point, abs_path);
				goto out_error;
			}
			/* main cgroup path should be read-only */
			if (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_MIXED) {
				r = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);
				if (r < 0) {
					SYSERROR(""error re-mounting %s readonly"", abs_path);
					goto out_error;
				}
			}
			/* own cgroup should be read-write */
			if (type == LXC_AUTO_CGROUP_FULL_MIXED) {
				r = mount(abs_path2, abs_path2, NULL, MS_BIND, NULL);
				if (r < 0) {
					SYSERROR(""error bind-mounting %s onto itself"", abs_path2);
					goto out_error;
				}
				r = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND, NULL);
				if (r < 0) {
					SYSERROR(""error re-mounting %s readwrite"", abs_path2);
					goto out_error;
				}
			}
		} else {
			/* create path for container's cgroup */
			r = mkdir_p(abs_path2, 0755);
			if (r < 0 && errno != EEXIST) {
				SYSERROR(""could not create cgroup directory /sys/fs/cgroup/%s%s"", dirname, info->cgroup_path);
				goto out_error;
			}

			/* for read-only and mixed cases, we have to bind-mount the tmpfs directory
			 * that points to the hierarchy itself (i.e. /sys/fs/cgroup/cpu etc.) onto
			 * itself and then bind-mount it read-only, since we keep the tmpfs itself
			 * read-write (see comment below)
			 */
			if (type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO) {
				r = mount(abs_path, abs_path, NULL, MS_BIND, NULL);
				if (r < 0) {
					SYSERROR(""error bind-mounting %s onto itself"", abs_path);
					goto out_error;
				}
				r = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);
				if (r < 0) {
					SYSERROR(""error re-mounting %s readonly"", abs_path);
					goto out_error;
				}
			}

			free(abs_path);
			abs_path = NULL;

			/* bind-mount container's cgroup to that directory */
			abs_path = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);
			if (!abs_path)
				goto out_error;
			r = mount(abs_path, abs_path2, ""none"", MS_BIND, 0);
			if (r < 0) {
				SYSERROR(""error bind-mounting %s to %s"", abs_path, abs_path2);
				goto out_error;
			}
			if (type == LXC_AUTO_CGROUP_RO) {
				r = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);
				if (r < 0) {
					SYSERROR(""error re-mounting %s readonly"", abs_path2);
					goto out_error;
				}
			}
		}

		free(abs_path);
		free(abs_path2);
		abs_path = NULL;
		abs_path2 = NULL;

		/* add symlinks for every single subsystem */
		if (subsystem_count > 1) {
			for (i = 0; i < subsystem_count; i++) {
				abs_path = lxc_append_paths(path, parts[i]);
				if (!abs_path)
					goto out_error;
				r = symlink(dirname, abs_path);
				if (r < 0)
					WARN(""could not create symlink %s -> %s in /sys/fs/cgroup of container"", parts[i], dirname);
				free(abs_path);
				abs_path = NULL;
			}
		}
		free(dirname);
		free(parts);
		dirname = NULL;
		parts = NULL;
	}

	/* We used to remount the entire tmpfs readonly if any :ro or
	 * :mixed mode was specified. However, Ubuntu's mountall has the
	 * unfortunate behavior to block bootup if /sys/fs/cgroup is
	 * mounted read-only and cannot be remounted read-write.
	 * (mountall reads /lib/init/fstab and tries to (re-)mount all of
	 * these if they are not already mounted with the right options;
	 * it contains an entry for /sys/fs/cgroup. In case it can't do
	 * that, it prompts for the user to either manually fix it or
	 * boot anyway. But without user input, booting of the container
	 * hangs.)
	 *
	 * Instead of remounting the entire tmpfs readonly, we only
	 * remount the paths readonly that are part of the cgroup
	 * hierarchy.
	 */

	free(path);

	return true;

out_error:
	saved_errno = errno;
	free(path);
	free(dirname);
	free(parts);
	free(abs_path);
	free(abs_path2);
	errno = saved_errno;
	return false;
}
",C,"	r = safe_mount(""cgroup_root"", path, ""tmpfs"",
			MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,
			""size=10240k,mode=755"",
			root);
","	r = mount(""cgroup_root"", path, ""tmpfs"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, ""size=10240k,mode=755"");
",,"@@ -1363,7 +1363,10 @@ static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)
 	if (!path)
 		return false;
 	snprintf(path, bufsz, ""%s/sys/fs/cgroup"", root);
-	r = mount(""cgroup_root"", path, ""tmpfs"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, ""size=10240k,mode=755"");
+	r = safe_mount(""cgroup_root"", path, ""tmpfs"",
+			MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,
+			""size=10240k,mode=755"",
+			root);
 	if (r < 0) {
 		SYSERROR(""could not mount tmpfs to /sys/fs/cgroup in the container"");
 		return false;",lxc,592fd47a6245508b79fe6ac819fe6d3b2c1289be,f2e4dddd71d427f9cacbab4016ffe18b0e4a4a0a,1,"static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)
{
	size_t bufsz = strlen(root) + sizeof(""/sys/fs/cgroup"");
	char *path = NULL;
	char **parts = NULL;
	char *dirname = NULL;
	char *abs_path = NULL;
	char *abs_path2 = NULL;
	struct cgfs_data *cgfs_d;
	struct cgroup_process_info *info, *base_info;
	int r, saved_errno = 0;

	cgfs_d = hdata;
	if (!cgfs_d)
		return false;
	base_info = cgfs_d->info;

	/* If we get passed the _NOSPEC types, we default to _MIXED, since we don't
	 * have access to the lxc_conf object at this point. It really should be up
	 * to the caller to fix this, but this doesn't really hurt.
	 */
	if (type == LXC_AUTO_CGROUP_FULL_NOSPEC)
		type = LXC_AUTO_CGROUP_FULL_MIXED;
	else if (type == LXC_AUTO_CGROUP_NOSPEC)
		type = LXC_AUTO_CGROUP_MIXED;

	if (type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED) {
		ERROR(""could not mount cgroups into container: invalid type specified internally"");
		errno = EINVAL;
		return false;
	}

	path = calloc(1, bufsz);
 	if (!path)
 		return false;
 	snprintf(path, bufsz, ""%s/sys/fs/cgroup"", root);
//flaw_line_below:
	r = mount(""cgroup_root"", path, ""tmpfs"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, ""size=10240k,mode=755"");
//fix_flaw_line_below:
//	r = safe_mount(""cgroup_root"", path, ""tmpfs"",
//fix_flaw_line_below:
//			MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,
//fix_flaw_line_below:
//			""size=10240k,mode=755"",
//fix_flaw_line_below:
//			root);
 	if (r < 0) {
 		SYSERROR(""could not mount tmpfs to /sys/fs/cgroup in the container"");
 		return false;
	}

	/* now mount all the hierarchies we care about */
	for (info = base_info; info; info = info->next) {
		size_t subsystem_count, i;
		struct cgroup_mount_point *mp = info->designated_mount_point;
		if (!mp)
			mp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);
		if (!mp) {
			SYSERROR(""could not find original mount point for cgroup hierarchy while trying to mount cgroup filesystem"");
			goto out_error;
		}

		subsystem_count = lxc_array_len((void **)info->hierarchy->subsystems);
		parts = calloc(subsystem_count + 1, sizeof(char *));
		if (!parts)
			goto out_error;

		for (i = 0; i < subsystem_count; i++) {
			if (!strncmp(info->hierarchy->subsystems[i], ""name="", 5))
				parts[i] = info->hierarchy->subsystems[i] + 5;
			else
				parts[i] = info->hierarchy->subsystems[i];
		}
		dirname = lxc_string_join("","", (const char **)parts, false);
		if (!dirname)
			goto out_error;

		/* create subsystem directory */
		abs_path = lxc_append_paths(path, dirname);
		if (!abs_path)
			goto out_error;
		r = mkdir_p(abs_path, 0755);
		if (r < 0 && errno != EEXIST) {
			SYSERROR(""could not create cgroup subsystem directory /sys/fs/cgroup/%s"", dirname);
			goto out_error;
		}

		abs_path2 = lxc_append_paths(abs_path, info->cgroup_path);
		if (!abs_path2)
			goto out_error;

		if (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED) {
			/* bind-mount the cgroup entire filesystem there */
			if (strcmp(mp->mount_prefix, ""/"") != 0) {
				/* FIXME: maybe we should just try to remount the entire hierarchy
				 *        with a regular mount command? may that works? */
				ERROR(""could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup"", dirname);
				goto out_error;
			}
			r = mount(mp->mount_point, abs_path, ""none"", MS_BIND, 0);
			if (r < 0) {
				SYSERROR(""error bind-mounting %s to %s"", mp->mount_point, abs_path);
				goto out_error;
			}
			/* main cgroup path should be read-only */
			if (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_MIXED) {
				r = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);
				if (r < 0) {
					SYSERROR(""error re-mounting %s readonly"", abs_path);
					goto out_error;
				}
			}
			/* own cgroup should be read-write */
			if (type == LXC_AUTO_CGROUP_FULL_MIXED) {
				r = mount(abs_path2, abs_path2, NULL, MS_BIND, NULL);
				if (r < 0) {
					SYSERROR(""error bind-mounting %s onto itself"", abs_path2);
					goto out_error;
				}
				r = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND, NULL);
				if (r < 0) {
					SYSERROR(""error re-mounting %s readwrite"", abs_path2);
					goto out_error;
				}
			}
		} else {
			/* create path for container's cgroup */
			r = mkdir_p(abs_path2, 0755);
			if (r < 0 && errno != EEXIST) {
				SYSERROR(""could not create cgroup directory /sys/fs/cgroup/%s%s"", dirname, info->cgroup_path);
				goto out_error;
			}

			/* for read-only and mixed cases, we have to bind-mount the tmpfs directory
			 * that points to the hierarchy itself (i.e. /sys/fs/cgroup/cpu etc.) onto
			 * itself and then bind-mount it read-only, since we keep the tmpfs itself
			 * read-write (see comment below)
			 */
			if (type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO) {
				r = mount(abs_path, abs_path, NULL, MS_BIND, NULL);
				if (r < 0) {
					SYSERROR(""error bind-mounting %s onto itself"", abs_path);
					goto out_error;
				}
				r = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);
				if (r < 0) {
					SYSERROR(""error re-mounting %s readonly"", abs_path);
					goto out_error;
				}
			}

			free(abs_path);
			abs_path = NULL;

			/* bind-mount container's cgroup to that directory */
			abs_path = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);
			if (!abs_path)
				goto out_error;
			r = mount(abs_path, abs_path2, ""none"", MS_BIND, 0);
			if (r < 0) {
				SYSERROR(""error bind-mounting %s to %s"", abs_path, abs_path2);
				goto out_error;
			}
			if (type == LXC_AUTO_CGROUP_RO) {
				r = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);
				if (r < 0) {
					SYSERROR(""error re-mounting %s readonly"", abs_path2);
					goto out_error;
				}
			}
		}

		free(abs_path);
		free(abs_path2);
		abs_path = NULL;
		abs_path2 = NULL;

		/* add symlinks for every single subsystem */
		if (subsystem_count > 1) {
			for (i = 0; i < subsystem_count; i++) {
				abs_path = lxc_append_paths(path, parts[i]);
				if (!abs_path)
					goto out_error;
				r = symlink(dirname, abs_path);
				if (r < 0)
					WARN(""could not create symlink %s -> %s in /sys/fs/cgroup of container"", parts[i], dirname);
				free(abs_path);
				abs_path = NULL;
			}
		}
		free(dirname);
		free(parts);
		dirname = NULL;
		parts = NULL;
	}

	/* We used to remount the entire tmpfs readonly if any :ro or
	 * :mixed mode was specified. However, Ubuntu's mountall has the
	 * unfortunate behavior to block bootup if /sys/fs/cgroup is
	 * mounted read-only and cannot be remounted read-write.
	 * (mountall reads /lib/init/fstab and tries to (re-)mount all of
	 * these if they are not already mounted with the right options;
	 * it contains an entry for /sys/fs/cgroup. In case it can't do
	 * that, it prompts for the user to either manually fix it or
	 * boot anyway. But without user input, booting of the container
	 * hangs.)
	 *
	 * Instead of remounting the entire tmpfs readonly, we only
	 * remount the paths readonly that are part of the cgroup
	 * hierarchy.
	 */

	free(path);

	return true;

out_error:
	saved_errno = errno;
	free(path);
	free(dirname);
	free(parts);
	free(abs_path);
	free(abs_path2);
	errno = saved_errno;
	return false;
}
"
2146,179882,,Local,Not required,Complete,CVE-2015-1335,https://www.cvedetails.com/cve/CVE-2015-1335/,CWE-59,Low,Complete,Complete,,2015-10-01,7.2,lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.,2019-05-31,,2,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,592fd47a6245508b79fe6ac819fe6d3b2c1289be,"CVE-2015-1335: Protect container mounts against symlinks

When a container starts up, lxc sets up the container's inital fstree
by doing a bunch of mounting, guided by the container configuration
file.  The container config is owned by the admin or user on the host,
so we do not try to guard against bad entries.  However, since the
mount target is in the container, it's possible that the container admin
could divert the mount with symbolic links.  This could bypass proper
container startup (i.e. confinement of a root-owned container by the
restrictive apparmor policy, by diverting the required write to
/proc/self/attr/current), or bypass the (path-based) apparmor policy
by diverting, say, /proc to /mnt in the container.

To prevent this,

1. do not allow mounts to paths containing symbolic links

2. do not allow bind mounts from relative paths containing symbolic
links.

Details:

Define safe_mount which ensures that the container has not inserted any
symbolic links into any mount targets for mounts to be done during
container setup.

The host's mount path may contain symbolic links.  As it is under the
control of the administrator, that's ok.  So safe_mount begins the check
for symbolic links after the rootfs->mount, by opening that directory.

It opens each directory along the path using openat() relative to the
parent directory using O_NOFOLLOW.  When the target is reached, it
mounts onto /proc/self/fd/<targetfd>.

Use safe_mount() in mount_entry(), when mounting container proc,
and when needed.  In particular, safe_mount() need not be used in
any case where:

1. the mount is done in the container's namespace
2. the mount is for the container's rootfs
3. the mount is relative to a tmpfs or proc/sysfs which we have
   just safe_mount()ed ourselves

Since we were using proc/net as a temporary placeholder for /proc/sys/net
during container startup, and proc/net is a symbolic link, use proc/tty
instead.

Update the lxc.container.conf manpage with details about the new
restrictions.

Finally, add a testcase to test some symbolic link possibilities.

Reported-by: Roman Fiedler
Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Acked-by: Stphane Graber <stgraber@ubuntu.com>",2,src/lxc/cgmanager.c,"{""sha"": ""eb3241f795d2f3e0f1fb762516983b74e99af52f"", ""filename"": ""doc/lxc.container.conf.sgml.in"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/doc/lxc.container.conf.sgml.in?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -760,6 +760,18 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n         container. This is useful to mount /etc, /var or /home for\n         examples.\n       </para>\n+      <para>\n+\tNOTE - LXC will generally ensure that mount targets and relative\n+\tbind-mount sources are properly confined under the container\n+\troot, to avoid attacks involving over-mounting host directories\n+\tand files.  (Symbolic links in absolute mount sources are ignored)\n+\tHowever, if the container configuration first mounts a directory which\n+\tis under the control of the container user, such as /home/joe, into\n+        the container at some <filename>path</filename>, and then mounts\n+        under <filename>path</filename>, then a TOCTTOU attack would be\n+        possible where the container user modifies a symbolic link under\n+        his home directory at just the right time.\n+      </para>\n       <variablelist>\n         <varlistentry>\n           <term>""}<_**next**_>{""sha"": ""df2e6b2333bc81f94bf7583087475fd8d62605a1"", ""filename"": ""src/lxc/cgfs.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgfs.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1363,7 +1363,10 @@ static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \""%s/sys/fs/cgroup\"", root);\n-\tr = mount(\""cgroup_root\"", path, \""tmpfs\"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \""size=10240k,mode=755\"");\n+\tr = safe_mount(\""cgroup_root\"", path, \""tmpfs\"",\n+\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n+\t\t\t\""size=10240k,mode=755\"",\n+\t\t\troot);\n \tif (r < 0) {\n \t\tSYSERROR(\""could not mount tmpfs to /sys/fs/cgroup in the container\"");\n \t\treturn false;""}<_**next**_>{""sha"": ""a677c22c768eccccaa3af386c662c43dad8412cf"", ""filename"": ""src/lxc/cgmanager.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgmanager.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1477,7 +1477,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t}\n \n \t/* mount a tmpfs there so we can create subdirs */\n-\tif (mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"")) {\n+\tif (safe_mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"", root)) {\n \t\tSYSERROR(\""Failed to mount tmpfs at %s\"", cgpath);\n \t\treturn false;\n \t}\n@@ -1488,7 +1488,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t\treturn false;\n \t}\n \n-\tif (mount(dirname, cgpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(dirname, cgpath, \""none\"", MS_BIND, 0, root)) {\n \t\tSYSERROR(\""Failed to bind mount %s to %s\"", dirname, cgpath);\n \t\treturn false;\n \t}""}<_**next**_>{""sha"": ""bb4c19f82e2c806b07125cbfd9ed3220df07be38"", ""filename"": ""src/lxc/conf.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 16, ""changes"": 35, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/conf.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t * 2.6.32...\n \t\t */\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/net\"",                  NULL,       MS_BIND,                        NULL },\n+\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/tty\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys\"",                                       \""%r/proc/sys\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sys\"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/net\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/tty\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sysrq-trigger\"",                             \""%r/proc/sysrq-trigger\"",        NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sysrq-trigger\"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t\t}\n \t\t\tmflags = add_required_remount_flags(source, destination,\n \t\t\t\t\tdefault_mounts[i].flags);\n-\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n+\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n \t\t\tsaved_errno = errno;\n \t\t\tif (r < 0 && errno == ENOENT) {\n \t\t\t\tINFO(\""Mount source or target for %s on %s doesn't exist. Skipping.\"", source, destination);\n@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons\n \t\treturn 0;\n \t}\n \n-\tif (mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"")) {\n+\tif (safe_mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"",\n+\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n \t\tSYSERROR(\""Failed mounting tmpfs onto %s\\n\"", path);\n \t\treturn false;\n \t}\n@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tfclose(pathfile);\n-\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n+\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n+\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n \t\t\t\tSYSERROR(\""Failed bind mounting device %s from host into container\"",\n \t\t\t\t\td->name);\n \t\t\t\treturn -1;\n@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,\n \t\treturn -1;\n \t}\n \n-\tif (mount(console->name, path, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, path, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, path);\n \t\treturn -1;\n \t}\n@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n \t\treturn 0;\n \t}\n \n-\tif (mount(console->name, lxcpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, lxcpath, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, lxcpath);\n \t\treturn -1;\n \t}\n@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)\n \n static int mount_entry(const char *fsname, const char *target,\n \t\t       const char *fstype, unsigned long mountflags,\n-\t\t       const char *data, int optional)\n+\t\t       const char *data, int optional, const char *rootfs)\n {\n #ifdef HAVE_STATVFS\n \tstruct statvfs sb;\n #endif\n \n-\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n+\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n \t\tif (optional) {\n \t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"", fsname,\n \t\t\t     target, strerror(errno));\n@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,\n #endif\n \n \t\tif (mount(fsname, target, fstype,\n-\t\t\t  mountflags | MS_REMOUNT, data)) {\n+\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n \t\t\tif (optional) {\n \t\t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"",\n \t\t\t\t\t fsname, target, strerror(errno));\n@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,\n }\n \n static inline int mount_entry_on_generic(struct mntent *mntent,\n-                 const char* path)\n+                 const char* path, const char *rootfs)\n {\n \tunsigned long mntflags;\n \tchar *mntdata;\n@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \t}\n \n \tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n-\t\t\t  mntflags, mntdata, optional);\n+\t\t\t  mntflags, mntdata, optional, rootfs);\n \n \tfree(mntdata);\n \n@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \n static inline int mount_entry_on_systemfs(struct mntent *mntent)\n {\n-  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n }\n \n static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n }\n \n static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs);\n }\n \n static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \""none\"", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \""none\"", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\""Failed to bind lxc.init.static into container\"");\n \tINFO(\""lxc.init.static bound into container at %s\"", path);""}<_**next**_>{""sha"": ""788cbe136302bb46a559c36dc45a895f8c584574"", ""filename"": ""src/lxc/utils.c"", ""status"": ""modified"", ""additions"": 234, ""deletions"": 1, ""changes"": 235, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1404,6 +1404,239 @@ int setproctitle(char *title)\n \treturn ret;\n }\n \n+/*\n+ * @path:    a pathname where / replaced with '\\0'.\n+ * @offsetp: pointer to int showing which path segment was last seen.\n+ *           Updated on return to reflect the next segment.\n+ * @fulllen: full original path length.\n+ * Returns a pointer to the next path segment, or NULL if done.\n+ */\n+static char *get_nextpath(char *path, int *offsetp, int fulllen)\n+{\n+\tint offset = *offsetp;\n+\n+\tif (offset >= fulllen)\n+\t\treturn NULL;\n+\n+\twhile (path[offset] != '\\0' && offset < fulllen)\n+\t\toffset++;\n+\twhile (path[offset] == '\\0' && offset < fulllen)\n+\t\toffset++;\n+\n+\t*offsetp = offset;\n+\treturn (offset < fulllen) ? &path[offset] : NULL;\n+}\n+\n+/*\n+ * Check that @subdir is a subdir of @dir.  @len is the length of\n+ * @dir (to avoid having to recalculate it).\n+ */\n+static bool is_subdir(const char *subdir, const char *dir, size_t len)\n+{\n+\tsize_t subdirlen = strlen(subdir);\n+\n+\tif (subdirlen < len)\n+\t\treturn false;\n+\tif (strncmp(subdir, dir, len) != 0)\n+\t\treturn false;\n+\tif (dir[len-1] == '/')\n+\t\treturn true;\n+\tif (subdir[len] == '/' || subdirlen == len)\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+/*\n+ * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return\n+ * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.\n+ */\n+static int check_symlink(int fd)\n+{\n+\tstruct stat sb;\n+\tint ret = fstat(fd, &sb);\n+\tif (ret < 0)\n+\t\treturn -ENOENT;\n+\tif (S_ISLNK(sb.st_mode))\n+\t\treturn -ELOOP;\n+\treturn 0;\n+}\n+\n+/*\n+ * Open a file or directory, provided that it contains no symlinks.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+static int open_if_safe(int dirfd, const char *nextpath)\n+{\n+\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n+\tif (newfd >= 0) // was not a symlink, all good\n+\t\treturn newfd;\n+\n+\tif (errno == ELOOP)\n+\t\treturn newfd;\n+\n+\tif (errno == EPERM || errno == EACCES) {\n+\t\t/* we're not root (cause we got EPERM) so\n+\t\t   try opening with O_PATH */\n+\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n+\t\tif (newfd >= 0) {\n+\t\t\t/* O_PATH will return an fd for symlinks.  We know\n+\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n+\t\t\t * is now a link, then something * fishy is going on\n+\t\t\t */\n+\t\t\tint ret = check_symlink(newfd);\n+\t\t\tif (ret < 0) {\n+\t\t\t\tclose(newfd);\n+\t\t\t\tnewfd = ret;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newfd;\n+}\n+\n+/*\n+ * Open a path intending for mounting, ensuring that the final path\n+ * is inside the container's rootfs.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ *\n+ * @target: path to be opened\n+ * @prefix_skip: a part of @target in which to ignore symbolic links.  This\n+ * would be the container's rootfs.\n+ *\n+ * Return an open fd for the path, or <0 on error.\n+ */\n+static int open_without_symlink(const char *target, const char *prefix_skip)\n+{\n+\tint curlen = 0, dirfd, fulllen, i;\n+\tchar *dup = NULL;\n+\n+\tfulllen = strlen(target);\n+\n+\t/* make sure prefix-skip makes sense */\n+\tif (prefix_skip) {\n+\t\tcurlen = strlen(prefix_skip);\n+\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n+\t\t\tERROR(\""WHOA there - target '%s' didn't start with prefix '%s'\"",\n+\t\t\t\ttarget, prefix_skip);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\t/*\n+\t\t * get_nextpath() expects the curlen argument to be\n+\t\t * on a  (turned into \\0) / or before it, so decrement\n+\t\t * curlen to make sure that happens\n+\t\t */\n+\t\tif (curlen)\n+\t\t\tcurlen--;\n+\t} else {\n+\t\tprefix_skip = \""/\"";\n+\t\tcurlen = 0;\n+\t}\n+\n+\t/* Make a copy of target which we can hack up, and tokenize it */\n+\tif ((dup = strdup(target)) == NULL) {\n+\t\tSYSERROR(\""Out of memory checking for symbolic link\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\tfor (i = 0; i < fulllen; i++) {\n+\t\tif (dup[i] == '/')\n+\t\t\tdup[i] = '\\0';\n+\t}\n+\n+\tdirfd = open(prefix_skip, O_RDONLY);\n+\tif (dirfd < 0)\n+\t\tgoto out;\n+\twhile (1) {\n+\t\tint newfd, saved_errno;\n+\t\tchar *nextpath;\n+\n+\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n+\t\t\tgoto out;\n+\t\tnewfd = open_if_safe(dirfd, nextpath);\n+\t\tsaved_errno = errno;\n+\t\tclose(dirfd);\n+\t\tdirfd = newfd;\n+\t\tif (newfd < 0) {\n+\t\t\terrno = saved_errno;\n+\t\t\tif (errno == ELOOP)\n+\t\t\t\tSYSERROR(\""%s in %s was a symbolic link!\"", nextpath, target);\n+\t\t\telse\n+\t\t\t\tSYSERROR(\""Error examining %s in %s\"", nextpath, target);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+out:\n+\tfree(dup);\n+\treturn dirfd;\n+}\n+\n+/*\n+ * Safely mount a path into a container, ensuring that the mount target\n+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container\n+ * uses the host's /)\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs)\n+{\n+\tint srcfd = -1, destfd, ret, saved_errno;\n+\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n+\tconst char *mntsrc = src;\n+\n+\tif (!rootfs)\n+\t\trootfs = \""\"";\n+\n+\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n+\tif (flags & MS_BIND && src && src[0] != '/') {\n+\t\tINFO(\""this is a relative bind mount\"");\n+\t\tsrcfd = open_without_symlink(src, NULL);\n+\t\tif (srcfd < 0)\n+\t\t\treturn srcfd;\n+\t\tret = snprintf(srcbuf, 50, \""/proc/self/fd/%d\"", srcfd);\n+\t\tif (ret < 0 || ret > 50) {\n+\t\t\tclose(srcfd);\n+\t\t\tERROR(\""Out of memory\"");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tmntsrc = srcbuf;\n+\t}\n+\n+\tdestfd = open_without_symlink(dest, rootfs);\n+\tif (destfd < 0) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\treturn destfd;\n+\t}\n+\n+\tret = snprintf(destbuf, 50, \""/proc/self/fd/%d\"", destfd);\n+\tif (ret < 0 || ret > 50) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\tclose(destfd);\n+\t\tERROR(\""Out of memory\"");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tret = mount(mntsrc, destbuf, fstype, flags, data);\n+\tsaved_errno = errno;\n+\tif (srcfd != -1)\n+\t\tclose(srcfd);\n+\tclose(destfd);\n+\tif (ret < 0) {\n+\t\terrno = saved_errno;\n+\t\tSYSERROR(\""Failed to mount %s onto %s\"", src, dest);\n+\t\treturn ret;\n+\t}\n+\n+\treturn 0;\n+}\n+\n /*\n  * Mount a proc under @rootfs if proc self points to a pid other than\n  * my own.  This is needed to have a known-good proc mount for setting\n@@ -1446,7 +1679,7 @@ int mount_proc_if_needed(const char *rootfs)\n \treturn 0;\n \n domount:\n-\tif (mount(\""proc\"", path, \""proc\"", 0, NULL))\n+\tif (safe_mount(\""proc\"", path, \""proc\"", 0, NULL, rootfs) < 0)\n \t\treturn -1;\n \tINFO(\""Mounted /proc in container for security transition\"");\n \treturn 1;""}<_**next**_>{""sha"": ""059026f0154b1713854c84674d12954a09469506"", ""filename"": ""src/lxc/utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.h?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -279,6 +279,8 @@ bool switch_to_ns(pid_t pid, const char *ns);\n int is_dir(const char *path);\n char *get_template_path(const char *t);\n int setproctitle(char *title);\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs);\n int mount_proc_if_needed(const char *rootfs);\n int null_stdfds(void);\n #endif /* __LXC_UTILS_H */""}<_**next**_>{""sha"": ""462d4f27882715442c3183b9db6620430b767455"", ""filename"": ""src/tests/Makefile.am"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/Makefile.am?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -55,6 +55,7 @@ bin_SCRIPTS += \\\n \tlxc-test-apparmor-mount \\\n \tlxc-test-checkpoint-restore \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tlxc-test-usernic\n@@ -82,6 +83,7 @@ EXTRA_DIST = \\\n \tlxc-test-cloneconfig \\\n \tlxc-test-createconfig \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tmay_control.c \\""}<_**next**_>{""sha"": ""37320f0dfd96b262d52bc99e314b7fe3cb026bb1"", ""filename"": ""src/tests/lxc-test-symlink"", ""status"": ""added"", ""additions"": 88, ""deletions"": 0, ""changes"": 88, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/lxc-test-symlink?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -0,0 +1,88 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+# lxc: linux Container library\n+\n+# Authors:\n+# Serge Hallyn <serge.hallyn@ubuntu.com>\n+#\n+# This is a regression test for symbolic links\n+\n+dirname=`mktemp -d`\n+fname=`mktemp`\n+fname2=`mktemp`\n+\n+lxcpath=/var/lib/lxcsym1\n+\n+cleanup() {\n+\tlxc-destroy -P $lxcpath -f -n symtest1 || true\n+\trm -f $lxcpath\n+\trmdir $dirname || true\n+\trm -f $fname || true\n+\trm -f $fname2 || true\n+}\n+\n+trap cleanup EXIT SIGHUP SIGINT SIGTERM\n+\n+testrun() {\n+\texpected=$1\n+\trun=$2\n+\tpass=\""pass\""\n+\tlxc-start -P $lxcpath -n symtest1 -l trace -o $lxcpath/log || pass=\""fail\""\n+\t[ $pass = \""pass\"" ] && lxc-wait -P $lxcpath -n symtest1 -t 10 -s RUNNING || pass=\""fail\""\n+\tif [ \""$pass\"" != \""$expected\"" ]; then\n+\t\techo \""Test $run: expected $expected but container did not.  Start log:\""\n+\t\tcat $lxcpath/log\n+\t\techo \""FAIL: Test $run: expected $expected but container did not.\""\n+\t\tfalse\n+\tfi\n+\tlxc-stop -P $lxcpath -n symtest1 -k || true\n+}\n+\n+# make lxcpath a symlink - this should NOT cause failure\n+ln -s /var/lib/lxc $lxcpath\n+\n+lxc-destroy -P $lxcpath -f -n symtest1 || true\n+lxc-create -P $lxcpath -t busybox -n symtest1\n+\n+cat >> /var/lib/lxc/symtest1/config << EOF\n+lxc.mount.entry = $dirname opt/xxx/dir none bind,create=dir\n+lxc.mount.entry = $fname opt/xxx/file none bind,create=file\n+lxc.mount.entry = $fname2 opt/xxx/file2 none bind\n+EOF\n+\n+# Regular - should succeed\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun pass 1\n+\n+# symlink - should fail\n+rm -rf /var/lib/lxc/symtest1/rootfs/opt/xxx\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx2\n+ln -s /var/lib/lxc/symtest1/rootfs/opt/xxx2 /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun fail 2\n+\n+# final final symlink - should fail\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx/dir\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2src\n+ln -s $lxcpath/symtest1/rootfs/opt/xxx/file2src $lxcpath/symtest1/rootfs/opt/xxx/file2\n+testrun fail 3\n+\n+# Ideally we'd also try a loop device, but that won't work in nested containers\n+# anyway - TODO\n+\n+# what about /proc itself\n+\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2\n+mv $lxcpath/symtest1/rootfs/proc $lxcpath/symtest1/rootfs/proc1\n+ln -s $lxcpath/symtest1/rootfs/proc1 $lxcpath/symtest1/rootfs/proc\n+testrun fail 4\n+\n+echo \""all tests passed\""""}","static bool cgm_bind_dir(const char *root, const char *dirname)
{
	nih_local char *cgpath = NULL;

	/* /sys should have been mounted by now */
	cgpath = NIH_MUST( nih_strdup(NULL, root) );
	NIH_MUST( nih_strcat(&cgpath, NULL, ""/sys/fs/cgroup"") );

	if (!dir_exists(cgpath)) {
		ERROR(""%s does not exist"", cgpath);
		return false;
 	}
 
 	/* mount a tmpfs there so we can create subdirs */
	if (safe_mount(""cgroup"", cgpath, ""tmpfs"", 0, ""size=10000,mode=755"", root)) {
 		SYSERROR(""Failed to mount tmpfs at %s"", cgpath);
 		return false;
 	}
	NIH_MUST( nih_strcat(&cgpath, NULL, ""/cgmanager"") );

	if (mkdir(cgpath, 0755) < 0) {
		SYSERROR(""Failed to create %s"", cgpath);
 		return false;
 	}
 
	if (safe_mount(dirname, cgpath, ""none"", MS_BIND, 0, root)) {
 		SYSERROR(""Failed to bind mount %s to %s"", dirname, cgpath);
 		return false;
 	}

	return true;
}
","static bool cgm_bind_dir(const char *root, const char *dirname)
{
	nih_local char *cgpath = NULL;

	/* /sys should have been mounted by now */
	cgpath = NIH_MUST( nih_strdup(NULL, root) );
	NIH_MUST( nih_strcat(&cgpath, NULL, ""/sys/fs/cgroup"") );

	if (!dir_exists(cgpath)) {
		ERROR(""%s does not exist"", cgpath);
		return false;
 	}
 
 	/* mount a tmpfs there so we can create subdirs */
	if (mount(""cgroup"", cgpath, ""tmpfs"", 0, ""size=10000,mode=755"")) {
 		SYSERROR(""Failed to mount tmpfs at %s"", cgpath);
 		return false;
 	}
	NIH_MUST( nih_strcat(&cgpath, NULL, ""/cgmanager"") );

	if (mkdir(cgpath, 0755) < 0) {
		SYSERROR(""Failed to create %s"", cgpath);
 		return false;
 	}
 
	if (mount(dirname, cgpath, ""none"", MS_BIND, 0)) {
 		SYSERROR(""Failed to bind mount %s to %s"", dirname, cgpath);
 		return false;
 	}

	return true;
}
",C,"	if (safe_mount(""cgroup"", cgpath, ""tmpfs"", 0, ""size=10000,mode=755"", root)) {
	if (safe_mount(dirname, cgpath, ""none"", MS_BIND, 0, root)) {
","	if (mount(""cgroup"", cgpath, ""tmpfs"", 0, ""size=10000,mode=755"")) {
	if (mount(dirname, cgpath, ""none"", MS_BIND, 0)) {
",,"@@ -1477,7 +1477,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)
 	}
 
 	/* mount a tmpfs there so we can create subdirs */
-	if (mount(""cgroup"", cgpath, ""tmpfs"", 0, ""size=10000,mode=755"")) {
+	if (safe_mount(""cgroup"", cgpath, ""tmpfs"", 0, ""size=10000,mode=755"", root)) {
 		SYSERROR(""Failed to mount tmpfs at %s"", cgpath);
 		return false;
 	}
@@ -1488,7 +1488,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)
 		return false;
 	}
 
-	if (mount(dirname, cgpath, ""none"", MS_BIND, 0)) {
+	if (safe_mount(dirname, cgpath, ""none"", MS_BIND, 0, root)) {
 		SYSERROR(""Failed to bind mount %s to %s"", dirname, cgpath);
 		return false;
 	}",lxc,592fd47a6245508b79fe6ac819fe6d3b2c1289be,f2e4dddd71d427f9cacbab4016ffe18b0e4a4a0a,1,"static bool cgm_bind_dir(const char *root, const char *dirname)
{
	nih_local char *cgpath = NULL;

	/* /sys should have been mounted by now */
	cgpath = NIH_MUST( nih_strdup(NULL, root) );
	NIH_MUST( nih_strcat(&cgpath, NULL, ""/sys/fs/cgroup"") );

	if (!dir_exists(cgpath)) {
		ERROR(""%s does not exist"", cgpath);
		return false;
 	}
 
 	/* mount a tmpfs there so we can create subdirs */
//flaw_line_below:
	if (mount(""cgroup"", cgpath, ""tmpfs"", 0, ""size=10000,mode=755"")) {
//fix_flaw_line_below:
//	if (safe_mount(""cgroup"", cgpath, ""tmpfs"", 0, ""size=10000,mode=755"", root)) {
 		SYSERROR(""Failed to mount tmpfs at %s"", cgpath);
 		return false;
 	}
	NIH_MUST( nih_strcat(&cgpath, NULL, ""/cgmanager"") );

	if (mkdir(cgpath, 0755) < 0) {
		SYSERROR(""Failed to create %s"", cgpath);
 		return false;
 	}
 
//flaw_line_below:
	if (mount(dirname, cgpath, ""none"", MS_BIND, 0)) {
//fix_flaw_line_below:
//	if (safe_mount(dirname, cgpath, ""none"", MS_BIND, 0, root)) {
 		SYSERROR(""Failed to bind mount %s to %s"", dirname, cgpath);
 		return false;
 	}

	return true;
}
"
2147,179883,,Local,Not required,Complete,CVE-2015-1335,https://www.cvedetails.com/cve/CVE-2015-1335/,CWE-59,Low,Complete,Complete,,2015-10-01,7.2,lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.,2019-05-31,,2,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,592fd47a6245508b79fe6ac819fe6d3b2c1289be,"CVE-2015-1335: Protect container mounts against symlinks

When a container starts up, lxc sets up the container's inital fstree
by doing a bunch of mounting, guided by the container configuration
file.  The container config is owned by the admin or user on the host,
so we do not try to guard against bad entries.  However, since the
mount target is in the container, it's possible that the container admin
could divert the mount with symbolic links.  This could bypass proper
container startup (i.e. confinement of a root-owned container by the
restrictive apparmor policy, by diverting the required write to
/proc/self/attr/current), or bypass the (path-based) apparmor policy
by diverting, say, /proc to /mnt in the container.

To prevent this,

1. do not allow mounts to paths containing symbolic links

2. do not allow bind mounts from relative paths containing symbolic
links.

Details:

Define safe_mount which ensures that the container has not inserted any
symbolic links into any mount targets for mounts to be done during
container setup.

The host's mount path may contain symbolic links.  As it is under the
control of the administrator, that's ok.  So safe_mount begins the check
for symbolic links after the rootfs->mount, by opening that directory.

It opens each directory along the path using openat() relative to the
parent directory using O_NOFOLLOW.  When the target is reached, it
mounts onto /proc/self/fd/<targetfd>.

Use safe_mount() in mount_entry(), when mounting container proc,
and when needed.  In particular, safe_mount() need not be used in
any case where:

1. the mount is done in the container's namespace
2. the mount is for the container's rootfs
3. the mount is relative to a tmpfs or proc/sysfs which we have
   just safe_mount()ed ourselves

Since we were using proc/net as a temporary placeholder for /proc/sys/net
during container startup, and proc/net is a symbolic link, use proc/tty
instead.

Update the lxc.container.conf manpage with details about the new
restrictions.

Finally, add a testcase to test some symbolic link possibilities.

Reported-by: Roman Fiedler
Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Acked-by: Stphane Graber <stgraber@ubuntu.com>",1,src/lxc/conf.c,"{""sha"": ""eb3241f795d2f3e0f1fb762516983b74e99af52f"", ""filename"": ""doc/lxc.container.conf.sgml.in"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/doc/lxc.container.conf.sgml.in?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -760,6 +760,18 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n         container. This is useful to mount /etc, /var or /home for\n         examples.\n       </para>\n+      <para>\n+\tNOTE - LXC will generally ensure that mount targets and relative\n+\tbind-mount sources are properly confined under the container\n+\troot, to avoid attacks involving over-mounting host directories\n+\tand files.  (Symbolic links in absolute mount sources are ignored)\n+\tHowever, if the container configuration first mounts a directory which\n+\tis under the control of the container user, such as /home/joe, into\n+        the container at some <filename>path</filename>, and then mounts\n+        under <filename>path</filename>, then a TOCTTOU attack would be\n+        possible where the container user modifies a symbolic link under\n+        his home directory at just the right time.\n+      </para>\n       <variablelist>\n         <varlistentry>\n           <term>""}<_**next**_>{""sha"": ""df2e6b2333bc81f94bf7583087475fd8d62605a1"", ""filename"": ""src/lxc/cgfs.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgfs.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1363,7 +1363,10 @@ static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \""%s/sys/fs/cgroup\"", root);\n-\tr = mount(\""cgroup_root\"", path, \""tmpfs\"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \""size=10240k,mode=755\"");\n+\tr = safe_mount(\""cgroup_root\"", path, \""tmpfs\"",\n+\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n+\t\t\t\""size=10240k,mode=755\"",\n+\t\t\troot);\n \tif (r < 0) {\n \t\tSYSERROR(\""could not mount tmpfs to /sys/fs/cgroup in the container\"");\n \t\treturn false;""}<_**next**_>{""sha"": ""a677c22c768eccccaa3af386c662c43dad8412cf"", ""filename"": ""src/lxc/cgmanager.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgmanager.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1477,7 +1477,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t}\n \n \t/* mount a tmpfs there so we can create subdirs */\n-\tif (mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"")) {\n+\tif (safe_mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"", root)) {\n \t\tSYSERROR(\""Failed to mount tmpfs at %s\"", cgpath);\n \t\treturn false;\n \t}\n@@ -1488,7 +1488,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t\treturn false;\n \t}\n \n-\tif (mount(dirname, cgpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(dirname, cgpath, \""none\"", MS_BIND, 0, root)) {\n \t\tSYSERROR(\""Failed to bind mount %s to %s\"", dirname, cgpath);\n \t\treturn false;\n \t}""}<_**next**_>{""sha"": ""bb4c19f82e2c806b07125cbfd9ed3220df07be38"", ""filename"": ""src/lxc/conf.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 16, ""changes"": 35, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/conf.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t * 2.6.32...\n \t\t */\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/net\"",                  NULL,       MS_BIND,                        NULL },\n+\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/tty\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys\"",                                       \""%r/proc/sys\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sys\"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/net\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/tty\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sysrq-trigger\"",                             \""%r/proc/sysrq-trigger\"",        NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sysrq-trigger\"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t\t}\n \t\t\tmflags = add_required_remount_flags(source, destination,\n \t\t\t\t\tdefault_mounts[i].flags);\n-\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n+\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n \t\t\tsaved_errno = errno;\n \t\t\tif (r < 0 && errno == ENOENT) {\n \t\t\t\tINFO(\""Mount source or target for %s on %s doesn't exist. Skipping.\"", source, destination);\n@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons\n \t\treturn 0;\n \t}\n \n-\tif (mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"")) {\n+\tif (safe_mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"",\n+\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n \t\tSYSERROR(\""Failed mounting tmpfs onto %s\\n\"", path);\n \t\treturn false;\n \t}\n@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tfclose(pathfile);\n-\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n+\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n+\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n \t\t\t\tSYSERROR(\""Failed bind mounting device %s from host into container\"",\n \t\t\t\t\td->name);\n \t\t\t\treturn -1;\n@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,\n \t\treturn -1;\n \t}\n \n-\tif (mount(console->name, path, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, path, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, path);\n \t\treturn -1;\n \t}\n@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n \t\treturn 0;\n \t}\n \n-\tif (mount(console->name, lxcpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, lxcpath, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, lxcpath);\n \t\treturn -1;\n \t}\n@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)\n \n static int mount_entry(const char *fsname, const char *target,\n \t\t       const char *fstype, unsigned long mountflags,\n-\t\t       const char *data, int optional)\n+\t\t       const char *data, int optional, const char *rootfs)\n {\n #ifdef HAVE_STATVFS\n \tstruct statvfs sb;\n #endif\n \n-\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n+\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n \t\tif (optional) {\n \t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"", fsname,\n \t\t\t     target, strerror(errno));\n@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,\n #endif\n \n \t\tif (mount(fsname, target, fstype,\n-\t\t\t  mountflags | MS_REMOUNT, data)) {\n+\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n \t\t\tif (optional) {\n \t\t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"",\n \t\t\t\t\t fsname, target, strerror(errno));\n@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,\n }\n \n static inline int mount_entry_on_generic(struct mntent *mntent,\n-                 const char* path)\n+                 const char* path, const char *rootfs)\n {\n \tunsigned long mntflags;\n \tchar *mntdata;\n@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \t}\n \n \tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n-\t\t\t  mntflags, mntdata, optional);\n+\t\t\t  mntflags, mntdata, optional, rootfs);\n \n \tfree(mntdata);\n \n@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \n static inline int mount_entry_on_systemfs(struct mntent *mntent)\n {\n-  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n }\n \n static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n }\n \n static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs);\n }\n \n static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \""none\"", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \""none\"", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\""Failed to bind lxc.init.static into container\"");\n \tINFO(\""lxc.init.static bound into container at %s\"", path);""}<_**next**_>{""sha"": ""788cbe136302bb46a559c36dc45a895f8c584574"", ""filename"": ""src/lxc/utils.c"", ""status"": ""modified"", ""additions"": 234, ""deletions"": 1, ""changes"": 235, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1404,6 +1404,239 @@ int setproctitle(char *title)\n \treturn ret;\n }\n \n+/*\n+ * @path:    a pathname where / replaced with '\\0'.\n+ * @offsetp: pointer to int showing which path segment was last seen.\n+ *           Updated on return to reflect the next segment.\n+ * @fulllen: full original path length.\n+ * Returns a pointer to the next path segment, or NULL if done.\n+ */\n+static char *get_nextpath(char *path, int *offsetp, int fulllen)\n+{\n+\tint offset = *offsetp;\n+\n+\tif (offset >= fulllen)\n+\t\treturn NULL;\n+\n+\twhile (path[offset] != '\\0' && offset < fulllen)\n+\t\toffset++;\n+\twhile (path[offset] == '\\0' && offset < fulllen)\n+\t\toffset++;\n+\n+\t*offsetp = offset;\n+\treturn (offset < fulllen) ? &path[offset] : NULL;\n+}\n+\n+/*\n+ * Check that @subdir is a subdir of @dir.  @len is the length of\n+ * @dir (to avoid having to recalculate it).\n+ */\n+static bool is_subdir(const char *subdir, const char *dir, size_t len)\n+{\n+\tsize_t subdirlen = strlen(subdir);\n+\n+\tif (subdirlen < len)\n+\t\treturn false;\n+\tif (strncmp(subdir, dir, len) != 0)\n+\t\treturn false;\n+\tif (dir[len-1] == '/')\n+\t\treturn true;\n+\tif (subdir[len] == '/' || subdirlen == len)\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+/*\n+ * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return\n+ * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.\n+ */\n+static int check_symlink(int fd)\n+{\n+\tstruct stat sb;\n+\tint ret = fstat(fd, &sb);\n+\tif (ret < 0)\n+\t\treturn -ENOENT;\n+\tif (S_ISLNK(sb.st_mode))\n+\t\treturn -ELOOP;\n+\treturn 0;\n+}\n+\n+/*\n+ * Open a file or directory, provided that it contains no symlinks.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+static int open_if_safe(int dirfd, const char *nextpath)\n+{\n+\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n+\tif (newfd >= 0) // was not a symlink, all good\n+\t\treturn newfd;\n+\n+\tif (errno == ELOOP)\n+\t\treturn newfd;\n+\n+\tif (errno == EPERM || errno == EACCES) {\n+\t\t/* we're not root (cause we got EPERM) so\n+\t\t   try opening with O_PATH */\n+\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n+\t\tif (newfd >= 0) {\n+\t\t\t/* O_PATH will return an fd for symlinks.  We know\n+\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n+\t\t\t * is now a link, then something * fishy is going on\n+\t\t\t */\n+\t\t\tint ret = check_symlink(newfd);\n+\t\t\tif (ret < 0) {\n+\t\t\t\tclose(newfd);\n+\t\t\t\tnewfd = ret;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newfd;\n+}\n+\n+/*\n+ * Open a path intending for mounting, ensuring that the final path\n+ * is inside the container's rootfs.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ *\n+ * @target: path to be opened\n+ * @prefix_skip: a part of @target in which to ignore symbolic links.  This\n+ * would be the container's rootfs.\n+ *\n+ * Return an open fd for the path, or <0 on error.\n+ */\n+static int open_without_symlink(const char *target, const char *prefix_skip)\n+{\n+\tint curlen = 0, dirfd, fulllen, i;\n+\tchar *dup = NULL;\n+\n+\tfulllen = strlen(target);\n+\n+\t/* make sure prefix-skip makes sense */\n+\tif (prefix_skip) {\n+\t\tcurlen = strlen(prefix_skip);\n+\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n+\t\t\tERROR(\""WHOA there - target '%s' didn't start with prefix '%s'\"",\n+\t\t\t\ttarget, prefix_skip);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\t/*\n+\t\t * get_nextpath() expects the curlen argument to be\n+\t\t * on a  (turned into \\0) / or before it, so decrement\n+\t\t * curlen to make sure that happens\n+\t\t */\n+\t\tif (curlen)\n+\t\t\tcurlen--;\n+\t} else {\n+\t\tprefix_skip = \""/\"";\n+\t\tcurlen = 0;\n+\t}\n+\n+\t/* Make a copy of target which we can hack up, and tokenize it */\n+\tif ((dup = strdup(target)) == NULL) {\n+\t\tSYSERROR(\""Out of memory checking for symbolic link\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\tfor (i = 0; i < fulllen; i++) {\n+\t\tif (dup[i] == '/')\n+\t\t\tdup[i] = '\\0';\n+\t}\n+\n+\tdirfd = open(prefix_skip, O_RDONLY);\n+\tif (dirfd < 0)\n+\t\tgoto out;\n+\twhile (1) {\n+\t\tint newfd, saved_errno;\n+\t\tchar *nextpath;\n+\n+\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n+\t\t\tgoto out;\n+\t\tnewfd = open_if_safe(dirfd, nextpath);\n+\t\tsaved_errno = errno;\n+\t\tclose(dirfd);\n+\t\tdirfd = newfd;\n+\t\tif (newfd < 0) {\n+\t\t\terrno = saved_errno;\n+\t\t\tif (errno == ELOOP)\n+\t\t\t\tSYSERROR(\""%s in %s was a symbolic link!\"", nextpath, target);\n+\t\t\telse\n+\t\t\t\tSYSERROR(\""Error examining %s in %s\"", nextpath, target);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+out:\n+\tfree(dup);\n+\treturn dirfd;\n+}\n+\n+/*\n+ * Safely mount a path into a container, ensuring that the mount target\n+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container\n+ * uses the host's /)\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs)\n+{\n+\tint srcfd = -1, destfd, ret, saved_errno;\n+\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n+\tconst char *mntsrc = src;\n+\n+\tif (!rootfs)\n+\t\trootfs = \""\"";\n+\n+\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n+\tif (flags & MS_BIND && src && src[0] != '/') {\n+\t\tINFO(\""this is a relative bind mount\"");\n+\t\tsrcfd = open_without_symlink(src, NULL);\n+\t\tif (srcfd < 0)\n+\t\t\treturn srcfd;\n+\t\tret = snprintf(srcbuf, 50, \""/proc/self/fd/%d\"", srcfd);\n+\t\tif (ret < 0 || ret > 50) {\n+\t\t\tclose(srcfd);\n+\t\t\tERROR(\""Out of memory\"");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tmntsrc = srcbuf;\n+\t}\n+\n+\tdestfd = open_without_symlink(dest, rootfs);\n+\tif (destfd < 0) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\treturn destfd;\n+\t}\n+\n+\tret = snprintf(destbuf, 50, \""/proc/self/fd/%d\"", destfd);\n+\tif (ret < 0 || ret > 50) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\tclose(destfd);\n+\t\tERROR(\""Out of memory\"");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tret = mount(mntsrc, destbuf, fstype, flags, data);\n+\tsaved_errno = errno;\n+\tif (srcfd != -1)\n+\t\tclose(srcfd);\n+\tclose(destfd);\n+\tif (ret < 0) {\n+\t\terrno = saved_errno;\n+\t\tSYSERROR(\""Failed to mount %s onto %s\"", src, dest);\n+\t\treturn ret;\n+\t}\n+\n+\treturn 0;\n+}\n+\n /*\n  * Mount a proc under @rootfs if proc self points to a pid other than\n  * my own.  This is needed to have a known-good proc mount for setting\n@@ -1446,7 +1679,7 @@ int mount_proc_if_needed(const char *rootfs)\n \treturn 0;\n \n domount:\n-\tif (mount(\""proc\"", path, \""proc\"", 0, NULL))\n+\tif (safe_mount(\""proc\"", path, \""proc\"", 0, NULL, rootfs) < 0)\n \t\treturn -1;\n \tINFO(\""Mounted /proc in container for security transition\"");\n \treturn 1;""}<_**next**_>{""sha"": ""059026f0154b1713854c84674d12954a09469506"", ""filename"": ""src/lxc/utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.h?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -279,6 +279,8 @@ bool switch_to_ns(pid_t pid, const char *ns);\n int is_dir(const char *path);\n char *get_template_path(const char *t);\n int setproctitle(char *title);\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs);\n int mount_proc_if_needed(const char *rootfs);\n int null_stdfds(void);\n #endif /* __LXC_UTILS_H */""}<_**next**_>{""sha"": ""462d4f27882715442c3183b9db6620430b767455"", ""filename"": ""src/tests/Makefile.am"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/Makefile.am?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -55,6 +55,7 @@ bin_SCRIPTS += \\\n \tlxc-test-apparmor-mount \\\n \tlxc-test-checkpoint-restore \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tlxc-test-usernic\n@@ -82,6 +83,7 @@ EXTRA_DIST = \\\n \tlxc-test-cloneconfig \\\n \tlxc-test-createconfig \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tmay_control.c \\""}<_**next**_>{""sha"": ""37320f0dfd96b262d52bc99e314b7fe3cb026bb1"", ""filename"": ""src/tests/lxc-test-symlink"", ""status"": ""added"", ""additions"": 88, ""deletions"": 0, ""changes"": 88, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/lxc-test-symlink?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -0,0 +1,88 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+# lxc: linux Container library\n+\n+# Authors:\n+# Serge Hallyn <serge.hallyn@ubuntu.com>\n+#\n+# This is a regression test for symbolic links\n+\n+dirname=`mktemp -d`\n+fname=`mktemp`\n+fname2=`mktemp`\n+\n+lxcpath=/var/lib/lxcsym1\n+\n+cleanup() {\n+\tlxc-destroy -P $lxcpath -f -n symtest1 || true\n+\trm -f $lxcpath\n+\trmdir $dirname || true\n+\trm -f $fname || true\n+\trm -f $fname2 || true\n+}\n+\n+trap cleanup EXIT SIGHUP SIGINT SIGTERM\n+\n+testrun() {\n+\texpected=$1\n+\trun=$2\n+\tpass=\""pass\""\n+\tlxc-start -P $lxcpath -n symtest1 -l trace -o $lxcpath/log || pass=\""fail\""\n+\t[ $pass = \""pass\"" ] && lxc-wait -P $lxcpath -n symtest1 -t 10 -s RUNNING || pass=\""fail\""\n+\tif [ \""$pass\"" != \""$expected\"" ]; then\n+\t\techo \""Test $run: expected $expected but container did not.  Start log:\""\n+\t\tcat $lxcpath/log\n+\t\techo \""FAIL: Test $run: expected $expected but container did not.\""\n+\t\tfalse\n+\tfi\n+\tlxc-stop -P $lxcpath -n symtest1 -k || true\n+}\n+\n+# make lxcpath a symlink - this should NOT cause failure\n+ln -s /var/lib/lxc $lxcpath\n+\n+lxc-destroy -P $lxcpath -f -n symtest1 || true\n+lxc-create -P $lxcpath -t busybox -n symtest1\n+\n+cat >> /var/lib/lxc/symtest1/config << EOF\n+lxc.mount.entry = $dirname opt/xxx/dir none bind,create=dir\n+lxc.mount.entry = $fname opt/xxx/file none bind,create=file\n+lxc.mount.entry = $fname2 opt/xxx/file2 none bind\n+EOF\n+\n+# Regular - should succeed\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun pass 1\n+\n+# symlink - should fail\n+rm -rf /var/lib/lxc/symtest1/rootfs/opt/xxx\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx2\n+ln -s /var/lib/lxc/symtest1/rootfs/opt/xxx2 /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun fail 2\n+\n+# final final symlink - should fail\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx/dir\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2src\n+ln -s $lxcpath/symtest1/rootfs/opt/xxx/file2src $lxcpath/symtest1/rootfs/opt/xxx/file2\n+testrun fail 3\n+\n+# Ideally we'd also try a loop device, but that won't work in nested containers\n+# anyway - TODO\n+\n+# what about /proc itself\n+\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2\n+mv $lxcpath/symtest1/rootfs/proc $lxcpath/symtest1/rootfs/proc1\n+ln -s $lxcpath/symtest1/rootfs/proc1 $lxcpath/symtest1/rootfs/proc\n+testrun fail 4\n+\n+echo \""all tests passed\""""}","static int fill_autodev(const struct lxc_rootfs *rootfs)
{
	int ret;
	char path[MAXPATHLEN];
	int i;
	mode_t cmask;

	INFO(""Creating initial consoles under container /dev"");

	ret = snprintf(path, MAXPATHLEN, ""%s/dev"", rootfs->path ? rootfs->mount : """");
	if (ret < 0 || ret >= MAXPATHLEN) {
		ERROR(""Error calculating container /dev location"");
		return -1;
	}

	if (!dir_exists(path))  // ignore, just don't try to fill in
		return 0;

	INFO(""Populating container /dev"");
	cmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);
	for (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {
		const struct lxc_devs *d = &lxc_devs[i];
		ret = snprintf(path, MAXPATHLEN, ""%s/dev/%s"", rootfs->path ? rootfs->mount : """", d->name);
		if (ret < 0 || ret >= MAXPATHLEN)
			return -1;
		ret = mknod(path, d->mode, makedev(d->maj, d->min));
		if (ret && errno != EEXIST) {
			char hostpath[MAXPATHLEN];
			FILE *pathfile;

			ret = snprintf(hostpath, MAXPATHLEN, ""/dev/%s"", d->name);
			if (ret < 0 || ret >= MAXPATHLEN)
				return -1;
			pathfile = fopen(path, ""wb"");
			if (!pathfile) {
				SYSERROR(""Failed to create device mount target '%s'"", path);
 				return -1;
 			}
 			fclose(pathfile);
			if (safe_mount(hostpath, path, 0, MS_BIND, NULL,
						rootfs->path ? rootfs->mount : NULL) != 0) {
 				SYSERROR(""Failed bind mounting device %s from host into container"",
 					d->name);
 				return -1;
			}
		}
	}
	umask(cmask);

	INFO(""Populated container /dev"");
	return 0;
}
","static int fill_autodev(const struct lxc_rootfs *rootfs)
{
	int ret;
	char path[MAXPATHLEN];
	int i;
	mode_t cmask;

	INFO(""Creating initial consoles under container /dev"");

	ret = snprintf(path, MAXPATHLEN, ""%s/dev"", rootfs->path ? rootfs->mount : """");
	if (ret < 0 || ret >= MAXPATHLEN) {
		ERROR(""Error calculating container /dev location"");
		return -1;
	}

	if (!dir_exists(path))  // ignore, just don't try to fill in
		return 0;

	INFO(""Populating container /dev"");
	cmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);
	for (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {
		const struct lxc_devs *d = &lxc_devs[i];
		ret = snprintf(path, MAXPATHLEN, ""%s/dev/%s"", rootfs->path ? rootfs->mount : """", d->name);
		if (ret < 0 || ret >= MAXPATHLEN)
			return -1;
		ret = mknod(path, d->mode, makedev(d->maj, d->min));
		if (ret && errno != EEXIST) {
			char hostpath[MAXPATHLEN];
			FILE *pathfile;

			ret = snprintf(hostpath, MAXPATHLEN, ""/dev/%s"", d->name);
			if (ret < 0 || ret >= MAXPATHLEN)
				return -1;
			pathfile = fopen(path, ""wb"");
			if (!pathfile) {
				SYSERROR(""Failed to create device mount target '%s'"", path);
 				return -1;
 			}
 			fclose(pathfile);
			if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {
 				SYSERROR(""Failed bind mounting device %s from host into container"",
 					d->name);
 				return -1;
			}
		}
	}
	umask(cmask);

	INFO(""Populated container /dev"");
	return 0;
}
",C,"			if (safe_mount(hostpath, path, 0, MS_BIND, NULL,
						rootfs->path ? rootfs->mount : NULL) != 0) {
","			if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {
",,"@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 		 * 2.6.32...
 		 */
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/net"",                  NULL,       MS_BIND,                        NULL },
+		/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/tty"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys"",                                       ""%r/proc/sys"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sys"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/net"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/tty"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sysrq-trigger"",                             ""%r/proc/sysrq-trigger"",        NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sysrq-trigger"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 			}
 			mflags = add_required_remount_flags(source, destination,
 					default_mounts[i].flags);
-			r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);
+			r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);
 			saved_errno = errno;
 			if (r < 0 && errno == ENOENT) {
 				INFO(""Mount source or target for %s on %s doesn't exist. Skipping."", source, destination);
@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons
 		return 0;
 	}
 
-	if (mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"")) {
+	if (safe_mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"",
+				rootfs->path ? rootfs->mount : NULL)) {
 		SYSERROR(""Failed mounting tmpfs onto %s\n"", path);
 		return false;
 	}
@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)
 				return -1;
 			}
 			fclose(pathfile);
-			if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {
+			if (safe_mount(hostpath, path, 0, MS_BIND, NULL,
+						rootfs->path ? rootfs->mount : NULL) != 0) {
 				SYSERROR(""Failed bind mounting device %s from host into container"",
 					d->name);
 				return -1;
@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,
 		return -1;
 	}
 
-	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, path, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}
@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,
 		return 0;
 	}
 
-	if (mount(console->name, lxcpath, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, lxcpath, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, lxcpath);
 		return -1;
 	}
@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)
 
 static int mount_entry(const char *fsname, const char *target,
 		       const char *fstype, unsigned long mountflags,
-		       const char *data, int optional)
+		       const char *data, int optional, const char *rootfs)
 {
 #ifdef HAVE_STATVFS
 	struct statvfs sb;
 #endif
 
-	if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {
+	if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {
 		if (optional) {
 			INFO(""failed to mount '%s' on '%s' (optional): %s"", fsname,
 			     target, strerror(errno));
@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,
 #endif
 
 		if (mount(fsname, target, fstype,
-			  mountflags | MS_REMOUNT, data)) {
+			  mountflags | MS_REMOUNT, data) < 0) {
 			if (optional) {
 				INFO(""failed to mount '%s' on '%s' (optional): %s"",
 					 fsname, target, strerror(errno));
@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,
 }
 
 static inline int mount_entry_on_generic(struct mntent *mntent,
-                 const char* path)
+                 const char* path, const char *rootfs)
 {
 	unsigned long mntflags;
 	char *mntdata;
@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 	}
 
 	ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,
-			  mntflags, mntdata, optional);
+			  mntflags, mntdata, optional, rootfs);
 
 	free(mntdata);
 
@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 
 static inline int mount_entry_on_systemfs(struct mntent *mntent)
 {
-  return mount_entry_on_generic(mntent, mntent->mnt_dir);
+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);
 }
 
 static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs->mount);
 }
 
 static int mount_entry_on_relative_rootfs(struct mntent *mntent,
@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs);
 }
 
 static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,
@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)
 		fclose(pathfile);
 	}
 
-	ret = mount(path, destpath, ""none"", MS_BIND, NULL);
+	ret = safe_mount(path, destpath, ""none"", MS_BIND, NULL, conf->rootfs.mount);
 	if (ret < 0)
 		SYSERROR(""Failed to bind lxc.init.static into container"");
 	INFO(""lxc.init.static bound into container at %s"", path);",lxc,592fd47a6245508b79fe6ac819fe6d3b2c1289be,f2e4dddd71d427f9cacbab4016ffe18b0e4a4a0a,1,"static int fill_autodev(const struct lxc_rootfs *rootfs)
{
	int ret;
	char path[MAXPATHLEN];
	int i;
	mode_t cmask;

	INFO(""Creating initial consoles under container /dev"");

	ret = snprintf(path, MAXPATHLEN, ""%s/dev"", rootfs->path ? rootfs->mount : """");
	if (ret < 0 || ret >= MAXPATHLEN) {
		ERROR(""Error calculating container /dev location"");
		return -1;
	}

	if (!dir_exists(path))  // ignore, just don't try to fill in
		return 0;

	INFO(""Populating container /dev"");
	cmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);
	for (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {
		const struct lxc_devs *d = &lxc_devs[i];
		ret = snprintf(path, MAXPATHLEN, ""%s/dev/%s"", rootfs->path ? rootfs->mount : """", d->name);
		if (ret < 0 || ret >= MAXPATHLEN)
			return -1;
		ret = mknod(path, d->mode, makedev(d->maj, d->min));
		if (ret && errno != EEXIST) {
			char hostpath[MAXPATHLEN];
			FILE *pathfile;

			// Unprivileged containers cannot create devices, so
			// bind mount the device from the host
			ret = snprintf(hostpath, MAXPATHLEN, ""/dev/%s"", d->name);
			if (ret < 0 || ret >= MAXPATHLEN)
				return -1;
			pathfile = fopen(path, ""wb"");
			if (!pathfile) {
				SYSERROR(""Failed to create device mount target '%s'"", path);
 				return -1;
 			}
 			fclose(pathfile);
//flaw_line_below:
			if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {
//fix_flaw_line_below:
//			if (safe_mount(hostpath, path, 0, MS_BIND, NULL,
//fix_flaw_line_below:
//						rootfs->path ? rootfs->mount : NULL) != 0) {
 				SYSERROR(""Failed bind mounting device %s from host into container"",
 					d->name);
 				return -1;
			}
		}
	}
	umask(cmask);

	INFO(""Populated container /dev"");
	return 0;
}
"
2148,179884,,Local,Not required,Complete,CVE-2015-1335,https://www.cvedetails.com/cve/CVE-2015-1335/,CWE-59,Low,Complete,Complete,,2015-10-01,7.2,lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.,2019-05-31,,1,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,592fd47a6245508b79fe6ac819fe6d3b2c1289be,"CVE-2015-1335: Protect container mounts against symlinks

When a container starts up, lxc sets up the container's inital fstree
by doing a bunch of mounting, guided by the container configuration
file.  The container config is owned by the admin or user on the host,
so we do not try to guard against bad entries.  However, since the
mount target is in the container, it's possible that the container admin
could divert the mount with symbolic links.  This could bypass proper
container startup (i.e. confinement of a root-owned container by the
restrictive apparmor policy, by diverting the required write to
/proc/self/attr/current), or bypass the (path-based) apparmor policy
by diverting, say, /proc to /mnt in the container.

To prevent this,

1. do not allow mounts to paths containing symbolic links

2. do not allow bind mounts from relative paths containing symbolic
links.

Details:

Define safe_mount which ensures that the container has not inserted any
symbolic links into any mount targets for mounts to be done during
container setup.

The host's mount path may contain symbolic links.  As it is under the
control of the administrator, that's ok.  So safe_mount begins the check
for symbolic links after the rootfs->mount, by opening that directory.

It opens each directory along the path using openat() relative to the
parent directory using O_NOFOLLOW.  When the target is reached, it
mounts onto /proc/self/fd/<targetfd>.

Use safe_mount() in mount_entry(), when mounting container proc,
and when needed.  In particular, safe_mount() need not be used in
any case where:

1. the mount is done in the container's namespace
2. the mount is for the container's rootfs
3. the mount is relative to a tmpfs or proc/sysfs which we have
   just safe_mount()ed ourselves

Since we were using proc/net as a temporary placeholder for /proc/sys/net
during container startup, and proc/net is a symbolic link, use proc/tty
instead.

Update the lxc.container.conf manpage with details about the new
restrictions.

Finally, add a testcase to test some symbolic link possibilities.

Reported-by: Roman Fiedler
Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Acked-by: Stphane Graber <stgraber@ubuntu.com>",1,src/lxc/conf.c,"{""sha"": ""eb3241f795d2f3e0f1fb762516983b74e99af52f"", ""filename"": ""doc/lxc.container.conf.sgml.in"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/doc/lxc.container.conf.sgml.in?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -760,6 +760,18 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n         container. This is useful to mount /etc, /var or /home for\n         examples.\n       </para>\n+      <para>\n+\tNOTE - LXC will generally ensure that mount targets and relative\n+\tbind-mount sources are properly confined under the container\n+\troot, to avoid attacks involving over-mounting host directories\n+\tand files.  (Symbolic links in absolute mount sources are ignored)\n+\tHowever, if the container configuration first mounts a directory which\n+\tis under the control of the container user, such as /home/joe, into\n+        the container at some <filename>path</filename>, and then mounts\n+        under <filename>path</filename>, then a TOCTTOU attack would be\n+        possible where the container user modifies a symbolic link under\n+        his home directory at just the right time.\n+      </para>\n       <variablelist>\n         <varlistentry>\n           <term>""}<_**next**_>{""sha"": ""df2e6b2333bc81f94bf7583087475fd8d62605a1"", ""filename"": ""src/lxc/cgfs.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgfs.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1363,7 +1363,10 @@ static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \""%s/sys/fs/cgroup\"", root);\n-\tr = mount(\""cgroup_root\"", path, \""tmpfs\"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \""size=10240k,mode=755\"");\n+\tr = safe_mount(\""cgroup_root\"", path, \""tmpfs\"",\n+\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n+\t\t\t\""size=10240k,mode=755\"",\n+\t\t\troot);\n \tif (r < 0) {\n \t\tSYSERROR(\""could not mount tmpfs to /sys/fs/cgroup in the container\"");\n \t\treturn false;""}<_**next**_>{""sha"": ""a677c22c768eccccaa3af386c662c43dad8412cf"", ""filename"": ""src/lxc/cgmanager.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgmanager.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1477,7 +1477,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t}\n \n \t/* mount a tmpfs there so we can create subdirs */\n-\tif (mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"")) {\n+\tif (safe_mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"", root)) {\n \t\tSYSERROR(\""Failed to mount tmpfs at %s\"", cgpath);\n \t\treturn false;\n \t}\n@@ -1488,7 +1488,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t\treturn false;\n \t}\n \n-\tif (mount(dirname, cgpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(dirname, cgpath, \""none\"", MS_BIND, 0, root)) {\n \t\tSYSERROR(\""Failed to bind mount %s to %s\"", dirname, cgpath);\n \t\treturn false;\n \t}""}<_**next**_>{""sha"": ""bb4c19f82e2c806b07125cbfd9ed3220df07be38"", ""filename"": ""src/lxc/conf.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 16, ""changes"": 35, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/conf.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t * 2.6.32...\n \t\t */\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/net\"",                  NULL,       MS_BIND,                        NULL },\n+\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/tty\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys\"",                                       \""%r/proc/sys\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sys\"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/net\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/tty\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sysrq-trigger\"",                             \""%r/proc/sysrq-trigger\"",        NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sysrq-trigger\"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t\t}\n \t\t\tmflags = add_required_remount_flags(source, destination,\n \t\t\t\t\tdefault_mounts[i].flags);\n-\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n+\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n \t\t\tsaved_errno = errno;\n \t\t\tif (r < 0 && errno == ENOENT) {\n \t\t\t\tINFO(\""Mount source or target for %s on %s doesn't exist. Skipping.\"", source, destination);\n@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons\n \t\treturn 0;\n \t}\n \n-\tif (mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"")) {\n+\tif (safe_mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"",\n+\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n \t\tSYSERROR(\""Failed mounting tmpfs onto %s\\n\"", path);\n \t\treturn false;\n \t}\n@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tfclose(pathfile);\n-\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n+\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n+\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n \t\t\t\tSYSERROR(\""Failed bind mounting device %s from host into container\"",\n \t\t\t\t\td->name);\n \t\t\t\treturn -1;\n@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,\n \t\treturn -1;\n \t}\n \n-\tif (mount(console->name, path, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, path, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, path);\n \t\treturn -1;\n \t}\n@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n \t\treturn 0;\n \t}\n \n-\tif (mount(console->name, lxcpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, lxcpath, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, lxcpath);\n \t\treturn -1;\n \t}\n@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)\n \n static int mount_entry(const char *fsname, const char *target,\n \t\t       const char *fstype, unsigned long mountflags,\n-\t\t       const char *data, int optional)\n+\t\t       const char *data, int optional, const char *rootfs)\n {\n #ifdef HAVE_STATVFS\n \tstruct statvfs sb;\n #endif\n \n-\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n+\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n \t\tif (optional) {\n \t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"", fsname,\n \t\t\t     target, strerror(errno));\n@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,\n #endif\n \n \t\tif (mount(fsname, target, fstype,\n-\t\t\t  mountflags | MS_REMOUNT, data)) {\n+\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n \t\t\tif (optional) {\n \t\t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"",\n \t\t\t\t\t fsname, target, strerror(errno));\n@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,\n }\n \n static inline int mount_entry_on_generic(struct mntent *mntent,\n-                 const char* path)\n+                 const char* path, const char *rootfs)\n {\n \tunsigned long mntflags;\n \tchar *mntdata;\n@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \t}\n \n \tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n-\t\t\t  mntflags, mntdata, optional);\n+\t\t\t  mntflags, mntdata, optional, rootfs);\n \n \tfree(mntdata);\n \n@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \n static inline int mount_entry_on_systemfs(struct mntent *mntent)\n {\n-  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n }\n \n static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n }\n \n static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs);\n }\n \n static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \""none\"", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \""none\"", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\""Failed to bind lxc.init.static into container\"");\n \tINFO(\""lxc.init.static bound into container at %s\"", path);""}<_**next**_>{""sha"": ""788cbe136302bb46a559c36dc45a895f8c584574"", ""filename"": ""src/lxc/utils.c"", ""status"": ""modified"", ""additions"": 234, ""deletions"": 1, ""changes"": 235, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1404,6 +1404,239 @@ int setproctitle(char *title)\n \treturn ret;\n }\n \n+/*\n+ * @path:    a pathname where / replaced with '\\0'.\n+ * @offsetp: pointer to int showing which path segment was last seen.\n+ *           Updated on return to reflect the next segment.\n+ * @fulllen: full original path length.\n+ * Returns a pointer to the next path segment, or NULL if done.\n+ */\n+static char *get_nextpath(char *path, int *offsetp, int fulllen)\n+{\n+\tint offset = *offsetp;\n+\n+\tif (offset >= fulllen)\n+\t\treturn NULL;\n+\n+\twhile (path[offset] != '\\0' && offset < fulllen)\n+\t\toffset++;\n+\twhile (path[offset] == '\\0' && offset < fulllen)\n+\t\toffset++;\n+\n+\t*offsetp = offset;\n+\treturn (offset < fulllen) ? &path[offset] : NULL;\n+}\n+\n+/*\n+ * Check that @subdir is a subdir of @dir.  @len is the length of\n+ * @dir (to avoid having to recalculate it).\n+ */\n+static bool is_subdir(const char *subdir, const char *dir, size_t len)\n+{\n+\tsize_t subdirlen = strlen(subdir);\n+\n+\tif (subdirlen < len)\n+\t\treturn false;\n+\tif (strncmp(subdir, dir, len) != 0)\n+\t\treturn false;\n+\tif (dir[len-1] == '/')\n+\t\treturn true;\n+\tif (subdir[len] == '/' || subdirlen == len)\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+/*\n+ * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return\n+ * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.\n+ */\n+static int check_symlink(int fd)\n+{\n+\tstruct stat sb;\n+\tint ret = fstat(fd, &sb);\n+\tif (ret < 0)\n+\t\treturn -ENOENT;\n+\tif (S_ISLNK(sb.st_mode))\n+\t\treturn -ELOOP;\n+\treturn 0;\n+}\n+\n+/*\n+ * Open a file or directory, provided that it contains no symlinks.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+static int open_if_safe(int dirfd, const char *nextpath)\n+{\n+\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n+\tif (newfd >= 0) // was not a symlink, all good\n+\t\treturn newfd;\n+\n+\tif (errno == ELOOP)\n+\t\treturn newfd;\n+\n+\tif (errno == EPERM || errno == EACCES) {\n+\t\t/* we're not root (cause we got EPERM) so\n+\t\t   try opening with O_PATH */\n+\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n+\t\tif (newfd >= 0) {\n+\t\t\t/* O_PATH will return an fd for symlinks.  We know\n+\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n+\t\t\t * is now a link, then something * fishy is going on\n+\t\t\t */\n+\t\t\tint ret = check_symlink(newfd);\n+\t\t\tif (ret < 0) {\n+\t\t\t\tclose(newfd);\n+\t\t\t\tnewfd = ret;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newfd;\n+}\n+\n+/*\n+ * Open a path intending for mounting, ensuring that the final path\n+ * is inside the container's rootfs.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ *\n+ * @target: path to be opened\n+ * @prefix_skip: a part of @target in which to ignore symbolic links.  This\n+ * would be the container's rootfs.\n+ *\n+ * Return an open fd for the path, or <0 on error.\n+ */\n+static int open_without_symlink(const char *target, const char *prefix_skip)\n+{\n+\tint curlen = 0, dirfd, fulllen, i;\n+\tchar *dup = NULL;\n+\n+\tfulllen = strlen(target);\n+\n+\t/* make sure prefix-skip makes sense */\n+\tif (prefix_skip) {\n+\t\tcurlen = strlen(prefix_skip);\n+\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n+\t\t\tERROR(\""WHOA there - target '%s' didn't start with prefix '%s'\"",\n+\t\t\t\ttarget, prefix_skip);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\t/*\n+\t\t * get_nextpath() expects the curlen argument to be\n+\t\t * on a  (turned into \\0) / or before it, so decrement\n+\t\t * curlen to make sure that happens\n+\t\t */\n+\t\tif (curlen)\n+\t\t\tcurlen--;\n+\t} else {\n+\t\tprefix_skip = \""/\"";\n+\t\tcurlen = 0;\n+\t}\n+\n+\t/* Make a copy of target which we can hack up, and tokenize it */\n+\tif ((dup = strdup(target)) == NULL) {\n+\t\tSYSERROR(\""Out of memory checking for symbolic link\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\tfor (i = 0; i < fulllen; i++) {\n+\t\tif (dup[i] == '/')\n+\t\t\tdup[i] = '\\0';\n+\t}\n+\n+\tdirfd = open(prefix_skip, O_RDONLY);\n+\tif (dirfd < 0)\n+\t\tgoto out;\n+\twhile (1) {\n+\t\tint newfd, saved_errno;\n+\t\tchar *nextpath;\n+\n+\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n+\t\t\tgoto out;\n+\t\tnewfd = open_if_safe(dirfd, nextpath);\n+\t\tsaved_errno = errno;\n+\t\tclose(dirfd);\n+\t\tdirfd = newfd;\n+\t\tif (newfd < 0) {\n+\t\t\terrno = saved_errno;\n+\t\t\tif (errno == ELOOP)\n+\t\t\t\tSYSERROR(\""%s in %s was a symbolic link!\"", nextpath, target);\n+\t\t\telse\n+\t\t\t\tSYSERROR(\""Error examining %s in %s\"", nextpath, target);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+out:\n+\tfree(dup);\n+\treturn dirfd;\n+}\n+\n+/*\n+ * Safely mount a path into a container, ensuring that the mount target\n+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container\n+ * uses the host's /)\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs)\n+{\n+\tint srcfd = -1, destfd, ret, saved_errno;\n+\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n+\tconst char *mntsrc = src;\n+\n+\tif (!rootfs)\n+\t\trootfs = \""\"";\n+\n+\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n+\tif (flags & MS_BIND && src && src[0] != '/') {\n+\t\tINFO(\""this is a relative bind mount\"");\n+\t\tsrcfd = open_without_symlink(src, NULL);\n+\t\tif (srcfd < 0)\n+\t\t\treturn srcfd;\n+\t\tret = snprintf(srcbuf, 50, \""/proc/self/fd/%d\"", srcfd);\n+\t\tif (ret < 0 || ret > 50) {\n+\t\t\tclose(srcfd);\n+\t\t\tERROR(\""Out of memory\"");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tmntsrc = srcbuf;\n+\t}\n+\n+\tdestfd = open_without_symlink(dest, rootfs);\n+\tif (destfd < 0) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\treturn destfd;\n+\t}\n+\n+\tret = snprintf(destbuf, 50, \""/proc/self/fd/%d\"", destfd);\n+\tif (ret < 0 || ret > 50) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\tclose(destfd);\n+\t\tERROR(\""Out of memory\"");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tret = mount(mntsrc, destbuf, fstype, flags, data);\n+\tsaved_errno = errno;\n+\tif (srcfd != -1)\n+\t\tclose(srcfd);\n+\tclose(destfd);\n+\tif (ret < 0) {\n+\t\terrno = saved_errno;\n+\t\tSYSERROR(\""Failed to mount %s onto %s\"", src, dest);\n+\t\treturn ret;\n+\t}\n+\n+\treturn 0;\n+}\n+\n /*\n  * Mount a proc under @rootfs if proc self points to a pid other than\n  * my own.  This is needed to have a known-good proc mount for setting\n@@ -1446,7 +1679,7 @@ int mount_proc_if_needed(const char *rootfs)\n \treturn 0;\n \n domount:\n-\tif (mount(\""proc\"", path, \""proc\"", 0, NULL))\n+\tif (safe_mount(\""proc\"", path, \""proc\"", 0, NULL, rootfs) < 0)\n \t\treturn -1;\n \tINFO(\""Mounted /proc in container for security transition\"");\n \treturn 1;""}<_**next**_>{""sha"": ""059026f0154b1713854c84674d12954a09469506"", ""filename"": ""src/lxc/utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.h?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -279,6 +279,8 @@ bool switch_to_ns(pid_t pid, const char *ns);\n int is_dir(const char *path);\n char *get_template_path(const char *t);\n int setproctitle(char *title);\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs);\n int mount_proc_if_needed(const char *rootfs);\n int null_stdfds(void);\n #endif /* __LXC_UTILS_H */""}<_**next**_>{""sha"": ""462d4f27882715442c3183b9db6620430b767455"", ""filename"": ""src/tests/Makefile.am"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/Makefile.am?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -55,6 +55,7 @@ bin_SCRIPTS += \\\n \tlxc-test-apparmor-mount \\\n \tlxc-test-checkpoint-restore \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tlxc-test-usernic\n@@ -82,6 +83,7 @@ EXTRA_DIST = \\\n \tlxc-test-cloneconfig \\\n \tlxc-test-createconfig \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tmay_control.c \\""}<_**next**_>{""sha"": ""37320f0dfd96b262d52bc99e314b7fe3cb026bb1"", ""filename"": ""src/tests/lxc-test-symlink"", ""status"": ""added"", ""additions"": 88, ""deletions"": 0, ""changes"": 88, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/lxc-test-symlink?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -0,0 +1,88 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+# lxc: linux Container library\n+\n+# Authors:\n+# Serge Hallyn <serge.hallyn@ubuntu.com>\n+#\n+# This is a regression test for symbolic links\n+\n+dirname=`mktemp -d`\n+fname=`mktemp`\n+fname2=`mktemp`\n+\n+lxcpath=/var/lib/lxcsym1\n+\n+cleanup() {\n+\tlxc-destroy -P $lxcpath -f -n symtest1 || true\n+\trm -f $lxcpath\n+\trmdir $dirname || true\n+\trm -f $fname || true\n+\trm -f $fname2 || true\n+}\n+\n+trap cleanup EXIT SIGHUP SIGINT SIGTERM\n+\n+testrun() {\n+\texpected=$1\n+\trun=$2\n+\tpass=\""pass\""\n+\tlxc-start -P $lxcpath -n symtest1 -l trace -o $lxcpath/log || pass=\""fail\""\n+\t[ $pass = \""pass\"" ] && lxc-wait -P $lxcpath -n symtest1 -t 10 -s RUNNING || pass=\""fail\""\n+\tif [ \""$pass\"" != \""$expected\"" ]; then\n+\t\techo \""Test $run: expected $expected but container did not.  Start log:\""\n+\t\tcat $lxcpath/log\n+\t\techo \""FAIL: Test $run: expected $expected but container did not.\""\n+\t\tfalse\n+\tfi\n+\tlxc-stop -P $lxcpath -n symtest1 -k || true\n+}\n+\n+# make lxcpath a symlink - this should NOT cause failure\n+ln -s /var/lib/lxc $lxcpath\n+\n+lxc-destroy -P $lxcpath -f -n symtest1 || true\n+lxc-create -P $lxcpath -t busybox -n symtest1\n+\n+cat >> /var/lib/lxc/symtest1/config << EOF\n+lxc.mount.entry = $dirname opt/xxx/dir none bind,create=dir\n+lxc.mount.entry = $fname opt/xxx/file none bind,create=file\n+lxc.mount.entry = $fname2 opt/xxx/file2 none bind\n+EOF\n+\n+# Regular - should succeed\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun pass 1\n+\n+# symlink - should fail\n+rm -rf /var/lib/lxc/symtest1/rootfs/opt/xxx\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx2\n+ln -s /var/lib/lxc/symtest1/rootfs/opt/xxx2 /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun fail 2\n+\n+# final final symlink - should fail\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx/dir\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2src\n+ln -s $lxcpath/symtest1/rootfs/opt/xxx/file2src $lxcpath/symtest1/rootfs/opt/xxx/file2\n+testrun fail 3\n+\n+# Ideally we'd also try a loop device, but that won't work in nested containers\n+# anyway - TODO\n+\n+# what about /proc itself\n+\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2\n+mv $lxcpath/symtest1/rootfs/proc $lxcpath/symtest1/rootfs/proc1\n+ln -s $lxcpath/symtest1/rootfs/proc1 $lxcpath/symtest1/rootfs/proc\n+testrun fail 4\n+\n+echo \""all tests passed\""""}","void lxc_execute_bind_init(struct lxc_conf *conf)
{
	int ret;
	char path[PATH_MAX], destpath[PATH_MAX], *p;

	/* If init exists in the container, don't bind mount a static one */
	p = choose_init(conf->rootfs.mount);
	if (p) {
		free(p);
		return;
	}

	ret = snprintf(path, PATH_MAX, SBINDIR ""/init.lxc.static"");
	if (ret < 0 || ret >= PATH_MAX) {
		WARN(""Path name too long searching for lxc.init.static"");
		return;
	}

	if (!file_exists(path)) {
		INFO(""%s does not exist on host"", path);
		return;
	}

	ret = snprintf(destpath, PATH_MAX, ""%s%s"", conf->rootfs.mount, ""/init.lxc.static"");
	if (ret < 0 || ret >= PATH_MAX) {
		WARN(""Path name too long for container's lxc.init.static"");
		return;
	}

	if (!file_exists(destpath)) {
		FILE * pathfile = fopen(destpath, ""wb"");
		if (!pathfile) {
			SYSERROR(""Failed to create mount target '%s'"", destpath);
			return;
		}
 		fclose(pathfile);
 	}
 
	ret = safe_mount(path, destpath, ""none"", MS_BIND, NULL, conf->rootfs.mount);
 	if (ret < 0)
 		SYSERROR(""Failed to bind lxc.init.static into container"");
 	INFO(""lxc.init.static bound into container at %s"", path);
}
","void lxc_execute_bind_init(struct lxc_conf *conf)
{
	int ret;
	char path[PATH_MAX], destpath[PATH_MAX], *p;

	/* If init exists in the container, don't bind mount a static one */
	p = choose_init(conf->rootfs.mount);
	if (p) {
		free(p);
		return;
	}

	ret = snprintf(path, PATH_MAX, SBINDIR ""/init.lxc.static"");
	if (ret < 0 || ret >= PATH_MAX) {
		WARN(""Path name too long searching for lxc.init.static"");
		return;
	}

	if (!file_exists(path)) {
		INFO(""%s does not exist on host"", path);
		return;
	}

	ret = snprintf(destpath, PATH_MAX, ""%s%s"", conf->rootfs.mount, ""/init.lxc.static"");
	if (ret < 0 || ret >= PATH_MAX) {
		WARN(""Path name too long for container's lxc.init.static"");
		return;
	}

	if (!file_exists(destpath)) {
		FILE * pathfile = fopen(destpath, ""wb"");
		if (!pathfile) {
			SYSERROR(""Failed to create mount target '%s'"", destpath);
			return;
		}
 		fclose(pathfile);
 	}
 
	ret = mount(path, destpath, ""none"", MS_BIND, NULL);
 	if (ret < 0)
 		SYSERROR(""Failed to bind lxc.init.static into container"");
 	INFO(""lxc.init.static bound into container at %s"", path);
}
",C,"	ret = safe_mount(path, destpath, ""none"", MS_BIND, NULL, conf->rootfs.mount);
","	ret = mount(path, destpath, ""none"", MS_BIND, NULL);
",,"@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 		 * 2.6.32...
 		 */
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/net"",                  NULL,       MS_BIND,                        NULL },
+		/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/tty"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys"",                                       ""%r/proc/sys"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sys"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/net"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/tty"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sysrq-trigger"",                             ""%r/proc/sysrq-trigger"",        NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sysrq-trigger"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 			}
 			mflags = add_required_remount_flags(source, destination,
 					default_mounts[i].flags);
-			r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);
+			r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);
 			saved_errno = errno;
 			if (r < 0 && errno == ENOENT) {
 				INFO(""Mount source or target for %s on %s doesn't exist. Skipping."", source, destination);
@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons
 		return 0;
 	}
 
-	if (mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"")) {
+	if (safe_mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"",
+				rootfs->path ? rootfs->mount : NULL)) {
 		SYSERROR(""Failed mounting tmpfs onto %s\n"", path);
 		return false;
 	}
@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)
 				return -1;
 			}
 			fclose(pathfile);
-			if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {
+			if (safe_mount(hostpath, path, 0, MS_BIND, NULL,
+						rootfs->path ? rootfs->mount : NULL) != 0) {
 				SYSERROR(""Failed bind mounting device %s from host into container"",
 					d->name);
 				return -1;
@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,
 		return -1;
 	}
 
-	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, path, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}
@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,
 		return 0;
 	}
 
-	if (mount(console->name, lxcpath, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, lxcpath, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, lxcpath);
 		return -1;
 	}
@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)
 
 static int mount_entry(const char *fsname, const char *target,
 		       const char *fstype, unsigned long mountflags,
-		       const char *data, int optional)
+		       const char *data, int optional, const char *rootfs)
 {
 #ifdef HAVE_STATVFS
 	struct statvfs sb;
 #endif
 
-	if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {
+	if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {
 		if (optional) {
 			INFO(""failed to mount '%s' on '%s' (optional): %s"", fsname,
 			     target, strerror(errno));
@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,
 #endif
 
 		if (mount(fsname, target, fstype,
-			  mountflags | MS_REMOUNT, data)) {
+			  mountflags | MS_REMOUNT, data) < 0) {
 			if (optional) {
 				INFO(""failed to mount '%s' on '%s' (optional): %s"",
 					 fsname, target, strerror(errno));
@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,
 }
 
 static inline int mount_entry_on_generic(struct mntent *mntent,
-                 const char* path)
+                 const char* path, const char *rootfs)
 {
 	unsigned long mntflags;
 	char *mntdata;
@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 	}
 
 	ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,
-			  mntflags, mntdata, optional);
+			  mntflags, mntdata, optional, rootfs);
 
 	free(mntdata);
 
@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 
 static inline int mount_entry_on_systemfs(struct mntent *mntent)
 {
-  return mount_entry_on_generic(mntent, mntent->mnt_dir);
+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);
 }
 
 static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs->mount);
 }
 
 static int mount_entry_on_relative_rootfs(struct mntent *mntent,
@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs);
 }
 
 static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,
@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)
 		fclose(pathfile);
 	}
 
-	ret = mount(path, destpath, ""none"", MS_BIND, NULL);
+	ret = safe_mount(path, destpath, ""none"", MS_BIND, NULL, conf->rootfs.mount);
 	if (ret < 0)
 		SYSERROR(""Failed to bind lxc.init.static into container"");
 	INFO(""lxc.init.static bound into container at %s"", path);",lxc,592fd47a6245508b79fe6ac819fe6d3b2c1289be,f2e4dddd71d427f9cacbab4016ffe18b0e4a4a0a,1,"void lxc_execute_bind_init(struct lxc_conf *conf)
{
	int ret;
	char path[PATH_MAX], destpath[PATH_MAX], *p;

	/* If init exists in the container, don't bind mount a static one */
	p = choose_init(conf->rootfs.mount);
	if (p) {
		free(p);
		return;
	}

	ret = snprintf(path, PATH_MAX, SBINDIR ""/init.lxc.static"");
	if (ret < 0 || ret >= PATH_MAX) {
		WARN(""Path name too long searching for lxc.init.static"");
		return;
	}

	if (!file_exists(path)) {
		INFO(""%s does not exist on host"", path);
		return;
	}

	ret = snprintf(destpath, PATH_MAX, ""%s%s"", conf->rootfs.mount, ""/init.lxc.static"");
	if (ret < 0 || ret >= PATH_MAX) {
		WARN(""Path name too long for container's lxc.init.static"");
		return;
	}

	if (!file_exists(destpath)) {
		FILE * pathfile = fopen(destpath, ""wb"");
		if (!pathfile) {
			SYSERROR(""Failed to create mount target '%s'"", destpath);
			return;
		}
 		fclose(pathfile);
 	}
 
//flaw_line_below:
	ret = mount(path, destpath, ""none"", MS_BIND, NULL);
//fix_flaw_line_below:
//	ret = safe_mount(path, destpath, ""none"", MS_BIND, NULL, conf->rootfs.mount);
 	if (ret < 0)
 		SYSERROR(""Failed to bind lxc.init.static into container"");
 	INFO(""lxc.init.static bound into container at %s"", path);
}
"
2149,179885,,Local,Not required,Complete,CVE-2015-1335,https://www.cvedetails.com/cve/CVE-2015-1335/,CWE-59,Low,Complete,Complete,,2015-10-01,7.2,lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.,2019-05-31,,4,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,592fd47a6245508b79fe6ac819fe6d3b2c1289be,"CVE-2015-1335: Protect container mounts against symlinks

When a container starts up, lxc sets up the container's inital fstree
by doing a bunch of mounting, guided by the container configuration
file.  The container config is owned by the admin or user on the host,
so we do not try to guard against bad entries.  However, since the
mount target is in the container, it's possible that the container admin
could divert the mount with symbolic links.  This could bypass proper
container startup (i.e. confinement of a root-owned container by the
restrictive apparmor policy, by diverting the required write to
/proc/self/attr/current), or bypass the (path-based) apparmor policy
by diverting, say, /proc to /mnt in the container.

To prevent this,

1. do not allow mounts to paths containing symbolic links

2. do not allow bind mounts from relative paths containing symbolic
links.

Details:

Define safe_mount which ensures that the container has not inserted any
symbolic links into any mount targets for mounts to be done during
container setup.

The host's mount path may contain symbolic links.  As it is under the
control of the administrator, that's ok.  So safe_mount begins the check
for symbolic links after the rootfs->mount, by opening that directory.

It opens each directory along the path using openat() relative to the
parent directory using O_NOFOLLOW.  When the target is reached, it
mounts onto /proc/self/fd/<targetfd>.

Use safe_mount() in mount_entry(), when mounting container proc,
and when needed.  In particular, safe_mount() need not be used in
any case where:

1. the mount is done in the container's namespace
2. the mount is for the container's rootfs
3. the mount is relative to a tmpfs or proc/sysfs which we have
   just safe_mount()ed ourselves

Since we were using proc/net as a temporary placeholder for /proc/sys/net
during container startup, and proc/net is a symbolic link, use proc/tty
instead.

Update the lxc.container.conf manpage with details about the new
restrictions.

Finally, add a testcase to test some symbolic link possibilities.

Reported-by: Roman Fiedler
Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Acked-by: Stphane Graber <stgraber@ubuntu.com>",3,src/lxc/conf.c,"{""sha"": ""eb3241f795d2f3e0f1fb762516983b74e99af52f"", ""filename"": ""doc/lxc.container.conf.sgml.in"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/doc/lxc.container.conf.sgml.in?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -760,6 +760,18 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n         container. This is useful to mount /etc, /var or /home for\n         examples.\n       </para>\n+      <para>\n+\tNOTE - LXC will generally ensure that mount targets and relative\n+\tbind-mount sources are properly confined under the container\n+\troot, to avoid attacks involving over-mounting host directories\n+\tand files.  (Symbolic links in absolute mount sources are ignored)\n+\tHowever, if the container configuration first mounts a directory which\n+\tis under the control of the container user, such as /home/joe, into\n+        the container at some <filename>path</filename>, and then mounts\n+        under <filename>path</filename>, then a TOCTTOU attack would be\n+        possible where the container user modifies a symbolic link under\n+        his home directory at just the right time.\n+      </para>\n       <variablelist>\n         <varlistentry>\n           <term>""}<_**next**_>{""sha"": ""df2e6b2333bc81f94bf7583087475fd8d62605a1"", ""filename"": ""src/lxc/cgfs.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgfs.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1363,7 +1363,10 @@ static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \""%s/sys/fs/cgroup\"", root);\n-\tr = mount(\""cgroup_root\"", path, \""tmpfs\"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \""size=10240k,mode=755\"");\n+\tr = safe_mount(\""cgroup_root\"", path, \""tmpfs\"",\n+\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n+\t\t\t\""size=10240k,mode=755\"",\n+\t\t\troot);\n \tif (r < 0) {\n \t\tSYSERROR(\""could not mount tmpfs to /sys/fs/cgroup in the container\"");\n \t\treturn false;""}<_**next**_>{""sha"": ""a677c22c768eccccaa3af386c662c43dad8412cf"", ""filename"": ""src/lxc/cgmanager.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgmanager.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1477,7 +1477,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t}\n \n \t/* mount a tmpfs there so we can create subdirs */\n-\tif (mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"")) {\n+\tif (safe_mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"", root)) {\n \t\tSYSERROR(\""Failed to mount tmpfs at %s\"", cgpath);\n \t\treturn false;\n \t}\n@@ -1488,7 +1488,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t\treturn false;\n \t}\n \n-\tif (mount(dirname, cgpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(dirname, cgpath, \""none\"", MS_BIND, 0, root)) {\n \t\tSYSERROR(\""Failed to bind mount %s to %s\"", dirname, cgpath);\n \t\treturn false;\n \t}""}<_**next**_>{""sha"": ""bb4c19f82e2c806b07125cbfd9ed3220df07be38"", ""filename"": ""src/lxc/conf.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 16, ""changes"": 35, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/conf.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t * 2.6.32...\n \t\t */\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/net\"",                  NULL,       MS_BIND,                        NULL },\n+\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/tty\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys\"",                                       \""%r/proc/sys\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sys\"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/net\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/tty\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sysrq-trigger\"",                             \""%r/proc/sysrq-trigger\"",        NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sysrq-trigger\"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t\t}\n \t\t\tmflags = add_required_remount_flags(source, destination,\n \t\t\t\t\tdefault_mounts[i].flags);\n-\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n+\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n \t\t\tsaved_errno = errno;\n \t\t\tif (r < 0 && errno == ENOENT) {\n \t\t\t\tINFO(\""Mount source or target for %s on %s doesn't exist. Skipping.\"", source, destination);\n@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons\n \t\treturn 0;\n \t}\n \n-\tif (mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"")) {\n+\tif (safe_mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"",\n+\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n \t\tSYSERROR(\""Failed mounting tmpfs onto %s\\n\"", path);\n \t\treturn false;\n \t}\n@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tfclose(pathfile);\n-\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n+\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n+\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n \t\t\t\tSYSERROR(\""Failed bind mounting device %s from host into container\"",\n \t\t\t\t\td->name);\n \t\t\t\treturn -1;\n@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,\n \t\treturn -1;\n \t}\n \n-\tif (mount(console->name, path, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, path, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, path);\n \t\treturn -1;\n \t}\n@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n \t\treturn 0;\n \t}\n \n-\tif (mount(console->name, lxcpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, lxcpath, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, lxcpath);\n \t\treturn -1;\n \t}\n@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)\n \n static int mount_entry(const char *fsname, const char *target,\n \t\t       const char *fstype, unsigned long mountflags,\n-\t\t       const char *data, int optional)\n+\t\t       const char *data, int optional, const char *rootfs)\n {\n #ifdef HAVE_STATVFS\n \tstruct statvfs sb;\n #endif\n \n-\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n+\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n \t\tif (optional) {\n \t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"", fsname,\n \t\t\t     target, strerror(errno));\n@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,\n #endif\n \n \t\tif (mount(fsname, target, fstype,\n-\t\t\t  mountflags | MS_REMOUNT, data)) {\n+\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n \t\t\tif (optional) {\n \t\t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"",\n \t\t\t\t\t fsname, target, strerror(errno));\n@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,\n }\n \n static inline int mount_entry_on_generic(struct mntent *mntent,\n-                 const char* path)\n+                 const char* path, const char *rootfs)\n {\n \tunsigned long mntflags;\n \tchar *mntdata;\n@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \t}\n \n \tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n-\t\t\t  mntflags, mntdata, optional);\n+\t\t\t  mntflags, mntdata, optional, rootfs);\n \n \tfree(mntdata);\n \n@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \n static inline int mount_entry_on_systemfs(struct mntent *mntent)\n {\n-  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n }\n \n static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n }\n \n static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs);\n }\n \n static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \""none\"", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \""none\"", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\""Failed to bind lxc.init.static into container\"");\n \tINFO(\""lxc.init.static bound into container at %s\"", path);""}<_**next**_>{""sha"": ""788cbe136302bb46a559c36dc45a895f8c584574"", ""filename"": ""src/lxc/utils.c"", ""status"": ""modified"", ""additions"": 234, ""deletions"": 1, ""changes"": 235, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1404,6 +1404,239 @@ int setproctitle(char *title)\n \treturn ret;\n }\n \n+/*\n+ * @path:    a pathname where / replaced with '\\0'.\n+ * @offsetp: pointer to int showing which path segment was last seen.\n+ *           Updated on return to reflect the next segment.\n+ * @fulllen: full original path length.\n+ * Returns a pointer to the next path segment, or NULL if done.\n+ */\n+static char *get_nextpath(char *path, int *offsetp, int fulllen)\n+{\n+\tint offset = *offsetp;\n+\n+\tif (offset >= fulllen)\n+\t\treturn NULL;\n+\n+\twhile (path[offset] != '\\0' && offset < fulllen)\n+\t\toffset++;\n+\twhile (path[offset] == '\\0' && offset < fulllen)\n+\t\toffset++;\n+\n+\t*offsetp = offset;\n+\treturn (offset < fulllen) ? &path[offset] : NULL;\n+}\n+\n+/*\n+ * Check that @subdir is a subdir of @dir.  @len is the length of\n+ * @dir (to avoid having to recalculate it).\n+ */\n+static bool is_subdir(const char *subdir, const char *dir, size_t len)\n+{\n+\tsize_t subdirlen = strlen(subdir);\n+\n+\tif (subdirlen < len)\n+\t\treturn false;\n+\tif (strncmp(subdir, dir, len) != 0)\n+\t\treturn false;\n+\tif (dir[len-1] == '/')\n+\t\treturn true;\n+\tif (subdir[len] == '/' || subdirlen == len)\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+/*\n+ * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return\n+ * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.\n+ */\n+static int check_symlink(int fd)\n+{\n+\tstruct stat sb;\n+\tint ret = fstat(fd, &sb);\n+\tif (ret < 0)\n+\t\treturn -ENOENT;\n+\tif (S_ISLNK(sb.st_mode))\n+\t\treturn -ELOOP;\n+\treturn 0;\n+}\n+\n+/*\n+ * Open a file or directory, provided that it contains no symlinks.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+static int open_if_safe(int dirfd, const char *nextpath)\n+{\n+\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n+\tif (newfd >= 0) // was not a symlink, all good\n+\t\treturn newfd;\n+\n+\tif (errno == ELOOP)\n+\t\treturn newfd;\n+\n+\tif (errno == EPERM || errno == EACCES) {\n+\t\t/* we're not root (cause we got EPERM) so\n+\t\t   try opening with O_PATH */\n+\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n+\t\tif (newfd >= 0) {\n+\t\t\t/* O_PATH will return an fd for symlinks.  We know\n+\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n+\t\t\t * is now a link, then something * fishy is going on\n+\t\t\t */\n+\t\t\tint ret = check_symlink(newfd);\n+\t\t\tif (ret < 0) {\n+\t\t\t\tclose(newfd);\n+\t\t\t\tnewfd = ret;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newfd;\n+}\n+\n+/*\n+ * Open a path intending for mounting, ensuring that the final path\n+ * is inside the container's rootfs.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ *\n+ * @target: path to be opened\n+ * @prefix_skip: a part of @target in which to ignore symbolic links.  This\n+ * would be the container's rootfs.\n+ *\n+ * Return an open fd for the path, or <0 on error.\n+ */\n+static int open_without_symlink(const char *target, const char *prefix_skip)\n+{\n+\tint curlen = 0, dirfd, fulllen, i;\n+\tchar *dup = NULL;\n+\n+\tfulllen = strlen(target);\n+\n+\t/* make sure prefix-skip makes sense */\n+\tif (prefix_skip) {\n+\t\tcurlen = strlen(prefix_skip);\n+\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n+\t\t\tERROR(\""WHOA there - target '%s' didn't start with prefix '%s'\"",\n+\t\t\t\ttarget, prefix_skip);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\t/*\n+\t\t * get_nextpath() expects the curlen argument to be\n+\t\t * on a  (turned into \\0) / or before it, so decrement\n+\t\t * curlen to make sure that happens\n+\t\t */\n+\t\tif (curlen)\n+\t\t\tcurlen--;\n+\t} else {\n+\t\tprefix_skip = \""/\"";\n+\t\tcurlen = 0;\n+\t}\n+\n+\t/* Make a copy of target which we can hack up, and tokenize it */\n+\tif ((dup = strdup(target)) == NULL) {\n+\t\tSYSERROR(\""Out of memory checking for symbolic link\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\tfor (i = 0; i < fulllen; i++) {\n+\t\tif (dup[i] == '/')\n+\t\t\tdup[i] = '\\0';\n+\t}\n+\n+\tdirfd = open(prefix_skip, O_RDONLY);\n+\tif (dirfd < 0)\n+\t\tgoto out;\n+\twhile (1) {\n+\t\tint newfd, saved_errno;\n+\t\tchar *nextpath;\n+\n+\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n+\t\t\tgoto out;\n+\t\tnewfd = open_if_safe(dirfd, nextpath);\n+\t\tsaved_errno = errno;\n+\t\tclose(dirfd);\n+\t\tdirfd = newfd;\n+\t\tif (newfd < 0) {\n+\t\t\terrno = saved_errno;\n+\t\t\tif (errno == ELOOP)\n+\t\t\t\tSYSERROR(\""%s in %s was a symbolic link!\"", nextpath, target);\n+\t\t\telse\n+\t\t\t\tSYSERROR(\""Error examining %s in %s\"", nextpath, target);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+out:\n+\tfree(dup);\n+\treturn dirfd;\n+}\n+\n+/*\n+ * Safely mount a path into a container, ensuring that the mount target\n+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container\n+ * uses the host's /)\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs)\n+{\n+\tint srcfd = -1, destfd, ret, saved_errno;\n+\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n+\tconst char *mntsrc = src;\n+\n+\tif (!rootfs)\n+\t\trootfs = \""\"";\n+\n+\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n+\tif (flags & MS_BIND && src && src[0] != '/') {\n+\t\tINFO(\""this is a relative bind mount\"");\n+\t\tsrcfd = open_without_symlink(src, NULL);\n+\t\tif (srcfd < 0)\n+\t\t\treturn srcfd;\n+\t\tret = snprintf(srcbuf, 50, \""/proc/self/fd/%d\"", srcfd);\n+\t\tif (ret < 0 || ret > 50) {\n+\t\t\tclose(srcfd);\n+\t\t\tERROR(\""Out of memory\"");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tmntsrc = srcbuf;\n+\t}\n+\n+\tdestfd = open_without_symlink(dest, rootfs);\n+\tif (destfd < 0) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\treturn destfd;\n+\t}\n+\n+\tret = snprintf(destbuf, 50, \""/proc/self/fd/%d\"", destfd);\n+\tif (ret < 0 || ret > 50) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\tclose(destfd);\n+\t\tERROR(\""Out of memory\"");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tret = mount(mntsrc, destbuf, fstype, flags, data);\n+\tsaved_errno = errno;\n+\tif (srcfd != -1)\n+\t\tclose(srcfd);\n+\tclose(destfd);\n+\tif (ret < 0) {\n+\t\terrno = saved_errno;\n+\t\tSYSERROR(\""Failed to mount %s onto %s\"", src, dest);\n+\t\treturn ret;\n+\t}\n+\n+\treturn 0;\n+}\n+\n /*\n  * Mount a proc under @rootfs if proc self points to a pid other than\n  * my own.  This is needed to have a known-good proc mount for setting\n@@ -1446,7 +1679,7 @@ int mount_proc_if_needed(const char *rootfs)\n \treturn 0;\n \n domount:\n-\tif (mount(\""proc\"", path, \""proc\"", 0, NULL))\n+\tif (safe_mount(\""proc\"", path, \""proc\"", 0, NULL, rootfs) < 0)\n \t\treturn -1;\n \tINFO(\""Mounted /proc in container for security transition\"");\n \treturn 1;""}<_**next**_>{""sha"": ""059026f0154b1713854c84674d12954a09469506"", ""filename"": ""src/lxc/utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.h?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -279,6 +279,8 @@ bool switch_to_ns(pid_t pid, const char *ns);\n int is_dir(const char *path);\n char *get_template_path(const char *t);\n int setproctitle(char *title);\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs);\n int mount_proc_if_needed(const char *rootfs);\n int null_stdfds(void);\n #endif /* __LXC_UTILS_H */""}<_**next**_>{""sha"": ""462d4f27882715442c3183b9db6620430b767455"", ""filename"": ""src/tests/Makefile.am"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/Makefile.am?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -55,6 +55,7 @@ bin_SCRIPTS += \\\n \tlxc-test-apparmor-mount \\\n \tlxc-test-checkpoint-restore \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tlxc-test-usernic\n@@ -82,6 +83,7 @@ EXTRA_DIST = \\\n \tlxc-test-cloneconfig \\\n \tlxc-test-createconfig \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tmay_control.c \\""}<_**next**_>{""sha"": ""37320f0dfd96b262d52bc99e314b7fe3cb026bb1"", ""filename"": ""src/tests/lxc-test-symlink"", ""status"": ""added"", ""additions"": 88, ""deletions"": 0, ""changes"": 88, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/lxc-test-symlink?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -0,0 +1,88 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+# lxc: linux Container library\n+\n+# Authors:\n+# Serge Hallyn <serge.hallyn@ubuntu.com>\n+#\n+# This is a regression test for symbolic links\n+\n+dirname=`mktemp -d`\n+fname=`mktemp`\n+fname2=`mktemp`\n+\n+lxcpath=/var/lib/lxcsym1\n+\n+cleanup() {\n+\tlxc-destroy -P $lxcpath -f -n symtest1 || true\n+\trm -f $lxcpath\n+\trmdir $dirname || true\n+\trm -f $fname || true\n+\trm -f $fname2 || true\n+}\n+\n+trap cleanup EXIT SIGHUP SIGINT SIGTERM\n+\n+testrun() {\n+\texpected=$1\n+\trun=$2\n+\tpass=\""pass\""\n+\tlxc-start -P $lxcpath -n symtest1 -l trace -o $lxcpath/log || pass=\""fail\""\n+\t[ $pass = \""pass\"" ] && lxc-wait -P $lxcpath -n symtest1 -t 10 -s RUNNING || pass=\""fail\""\n+\tif [ \""$pass\"" != \""$expected\"" ]; then\n+\t\techo \""Test $run: expected $expected but container did not.  Start log:\""\n+\t\tcat $lxcpath/log\n+\t\techo \""FAIL: Test $run: expected $expected but container did not.\""\n+\t\tfalse\n+\tfi\n+\tlxc-stop -P $lxcpath -n symtest1 -k || true\n+}\n+\n+# make lxcpath a symlink - this should NOT cause failure\n+ln -s /var/lib/lxc $lxcpath\n+\n+lxc-destroy -P $lxcpath -f -n symtest1 || true\n+lxc-create -P $lxcpath -t busybox -n symtest1\n+\n+cat >> /var/lib/lxc/symtest1/config << EOF\n+lxc.mount.entry = $dirname opt/xxx/dir none bind,create=dir\n+lxc.mount.entry = $fname opt/xxx/file none bind,create=file\n+lxc.mount.entry = $fname2 opt/xxx/file2 none bind\n+EOF\n+\n+# Regular - should succeed\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun pass 1\n+\n+# symlink - should fail\n+rm -rf /var/lib/lxc/symtest1/rootfs/opt/xxx\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx2\n+ln -s /var/lib/lxc/symtest1/rootfs/opt/xxx2 /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun fail 2\n+\n+# final final symlink - should fail\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx/dir\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2src\n+ln -s $lxcpath/symtest1/rootfs/opt/xxx/file2src $lxcpath/symtest1/rootfs/opt/xxx/file2\n+testrun fail 3\n+\n+# Ideally we'd also try a loop device, but that won't work in nested containers\n+# anyway - TODO\n+\n+# what about /proc itself\n+\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2\n+mv $lxcpath/symtest1/rootfs/proc $lxcpath/symtest1/rootfs/proc1\n+ln -s $lxcpath/symtest1/rootfs/proc1 $lxcpath/symtest1/rootfs/proc\n+testrun fail 4\n+\n+echo \""all tests passed\""""}","static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_handler *handler)
{
	int r;
	size_t i;
	static struct {
		int match_mask;
		int match_flag;
		const char *source;
		const char *destination;
		const char *fstype;
		unsigned long flags;
		const char *options;
	} default_mounts[] = {
		/* Read-only bind-mounting... In older kernels, doing that required
		 * to do one MS_BIND mount and then MS_REMOUNT|MS_RDONLY the same
		 * one. According to mount(2) manpage, MS_BIND honors MS_RDONLY from
		 * kernel 2.6.26 onwards. However, this apparently does not work on
		 * kernel 3.8. Unfortunately, on that very same kernel, doing the
		 * same trick as above doesn't seem to work either, there one needs
		 * to ALSO specify MS_BIND for the remount, otherwise the entire
		 * fs is remounted read-only or the mount fails because it's busy...
		 * MS_REMOUNT|MS_BIND|MS_RDONLY seems to work for kernels as low as
 		 * 2.6.32...
 		 */
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
		/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */
		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/tty"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys"",                                       ""%r/proc/sys"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sys"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/tty"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sysrq-trigger"",                             ""%r/proc/sysrq-trigger"",        NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sysrq-trigger"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RW,     ""sysfs"",                                             ""%r/sys"",                       ""sysfs"",    0,                              NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RO,     ""sysfs"",                                             ""%r/sys"",                       ""sysfs"",    MS_RDONLY,                      NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  ""sysfs"",                                             ""%r/sys"",                       ""sysfs"",    MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  ""%r/sys"",                                            ""%r/sys"",                       NULL,       MS_BIND,                        NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                ""%r/sys"",                       NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  ""sysfs"",                                             ""%r/sys/devices/virtual/net"",   ""sysfs"",    0,                              NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  ""%r/sys/devices/virtual/net/devices/virtual/net"",    ""%r/sys/devices/virtual/net"",   NULL,       MS_BIND,                        NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                ""%r/sys/devices/virtual/net"",   NULL,       MS_REMOUNT|MS_BIND|MS_NOSUID|MS_NODEV|MS_NOEXEC,   NULL },
		{ 0,                  0,                   NULL,                                                NULL,                           NULL,       0,                              NULL }
	};

	for (i = 0; default_mounts[i].match_mask; i++) {
		if ((flags & default_mounts[i].match_mask) == default_mounts[i].match_flag) {
			char *source = NULL;
			char *destination = NULL;
			int saved_errno;
			unsigned long mflags;

			if (default_mounts[i].source) {
				/* will act like strdup if %r is not present */
				source = lxc_string_replace(""%r"", conf->rootfs.path ? conf->rootfs.mount : """", default_mounts[i].source);
				if (!source) {
					SYSERROR(""memory allocation error"");
					return -1;
				}
			}
			if (default_mounts[i].destination) {
				/* will act like strdup if %r is not present */
				destination = lxc_string_replace(""%r"", conf->rootfs.path ? conf->rootfs.mount : """", default_mounts[i].destination);
				if (!destination) {
					saved_errno = errno;
					SYSERROR(""memory allocation error"");
					free(source);
					errno = saved_errno;
					return -1;
				}
 			}
 			mflags = add_required_remount_flags(source, destination,
 					default_mounts[i].flags);
			r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);
 			saved_errno = errno;
 			if (r < 0 && errno == ENOENT) {
 				INFO(""Mount source or target for %s on %s doesn't exist. Skipping."", source, destination);
				r = 0;
			}
			else if (r < 0)
				SYSERROR(""error mounting %s on %s flags %lu"", source, destination, mflags);

			free(source);
			free(destination);
			if (r < 0) {
				errno = saved_errno;
				return -1;
			}
		}
	}

	if (flags & LXC_AUTO_CGROUP_MASK) {
		int cg_flags;

		cg_flags = flags & LXC_AUTO_CGROUP_MASK;
		/* If the type of cgroup mount was not specified, it depends on the
		 * container's capabilities as to what makes sense: if we have
		 * CAP_SYS_ADMIN, the read-only part can be remounted read-write
		 * anyway, so we may as well default to read-write; then the admin
		 * will not be given a false sense of security. (And if they really
		 * want mixed r/o r/w, then they can explicitly specify :mixed.)
		 * OTOH, if the container lacks CAP_SYS_ADMIN, do only default to
		 * :mixed, because then the container can't remount it read-write. */
		if (cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC) {
			int has_sys_admin = 0;
			if (!lxc_list_empty(&conf->keepcaps)) {
				has_sys_admin = in_caplist(CAP_SYS_ADMIN, &conf->keepcaps);
			} else {
				has_sys_admin = !in_caplist(CAP_SYS_ADMIN, &conf->caps);
			}
			if (cg_flags == LXC_AUTO_CGROUP_NOSPEC) {
				cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED;
			} else {
				cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED;
			}
		}

		if (!cgroup_mount(conf->rootfs.path ? conf->rootfs.mount : """", handler, cg_flags)) {
			SYSERROR(""error mounting /sys/fs/cgroup"");
			return -1;
		}
	}

	return 0;
}
","static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_handler *handler)
{
	int r;
	size_t i;
	static struct {
		int match_mask;
		int match_flag;
		const char *source;
		const char *destination;
		const char *fstype;
		unsigned long flags;
		const char *options;
	} default_mounts[] = {
		/* Read-only bind-mounting... In older kernels, doing that required
		 * to do one MS_BIND mount and then MS_REMOUNT|MS_RDONLY the same
		 * one. According to mount(2) manpage, MS_BIND honors MS_RDONLY from
		 * kernel 2.6.26 onwards. However, this apparently does not work on
		 * kernel 3.8. Unfortunately, on that very same kernel, doing the
		 * same trick as above doesn't seem to work either, there one needs
		 * to ALSO specify MS_BIND for the remount, otherwise the entire
		 * fs is remounted read-only or the mount fails because it's busy...
		 * MS_REMOUNT|MS_BIND|MS_RDONLY seems to work for kernels as low as
 		 * 2.6.32...
 		 */
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/net"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys"",                                       ""%r/proc/sys"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sys"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/net"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sysrq-trigger"",                             ""%r/proc/sysrq-trigger"",        NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sysrq-trigger"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RW,     ""sysfs"",                                             ""%r/sys"",                       ""sysfs"",    0,                              NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RO,     ""sysfs"",                                             ""%r/sys"",                       ""sysfs"",    MS_RDONLY,                      NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  ""sysfs"",                                             ""%r/sys"",                       ""sysfs"",    MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  ""%r/sys"",                                            ""%r/sys"",                       NULL,       MS_BIND,                        NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                ""%r/sys"",                       NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  ""sysfs"",                                             ""%r/sys/devices/virtual/net"",   ""sysfs"",    0,                              NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  ""%r/sys/devices/virtual/net/devices/virtual/net"",    ""%r/sys/devices/virtual/net"",   NULL,       MS_BIND,                        NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                ""%r/sys/devices/virtual/net"",   NULL,       MS_REMOUNT|MS_BIND|MS_NOSUID|MS_NODEV|MS_NOEXEC,   NULL },
		{ 0,                  0,                   NULL,                                                NULL,                           NULL,       0,                              NULL }
	};

	for (i = 0; default_mounts[i].match_mask; i++) {
		if ((flags & default_mounts[i].match_mask) == default_mounts[i].match_flag) {
			char *source = NULL;
			char *destination = NULL;
			int saved_errno;
			unsigned long mflags;

			if (default_mounts[i].source) {
				/* will act like strdup if %r is not present */
				source = lxc_string_replace(""%r"", conf->rootfs.path ? conf->rootfs.mount : """", default_mounts[i].source);
				if (!source) {
					SYSERROR(""memory allocation error"");
					return -1;
				}
			}
			if (default_mounts[i].destination) {
				/* will act like strdup if %r is not present */
				destination = lxc_string_replace(""%r"", conf->rootfs.path ? conf->rootfs.mount : """", default_mounts[i].destination);
				if (!destination) {
					saved_errno = errno;
					SYSERROR(""memory allocation error"");
					free(source);
					errno = saved_errno;
					return -1;
				}
 			}
 			mflags = add_required_remount_flags(source, destination,
 					default_mounts[i].flags);
			r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);
 			saved_errno = errno;
 			if (r < 0 && errno == ENOENT) {
 				INFO(""Mount source or target for %s on %s doesn't exist. Skipping."", source, destination);
				r = 0;
			}
			else if (r < 0)
				SYSERROR(""error mounting %s on %s flags %lu"", source, destination, mflags);

			free(source);
			free(destination);
			if (r < 0) {
				errno = saved_errno;
				return -1;
			}
		}
	}

	if (flags & LXC_AUTO_CGROUP_MASK) {
		int cg_flags;

		cg_flags = flags & LXC_AUTO_CGROUP_MASK;
		/* If the type of cgroup mount was not specified, it depends on the
		 * container's capabilities as to what makes sense: if we have
		 * CAP_SYS_ADMIN, the read-only part can be remounted read-write
		 * anyway, so we may as well default to read-write; then the admin
		 * will not be given a false sense of security. (And if they really
		 * want mixed r/o r/w, then they can explicitly specify :mixed.)
		 * OTOH, if the container lacks CAP_SYS_ADMIN, do only default to
		 * :mixed, because then the container can't remount it read-write. */
		if (cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC) {
			int has_sys_admin = 0;
			if (!lxc_list_empty(&conf->keepcaps)) {
				has_sys_admin = in_caplist(CAP_SYS_ADMIN, &conf->keepcaps);
			} else {
				has_sys_admin = !in_caplist(CAP_SYS_ADMIN, &conf->caps);
			}
			if (cg_flags == LXC_AUTO_CGROUP_NOSPEC) {
				cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED;
			} else {
				cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED;
			}
		}

		if (!cgroup_mount(conf->rootfs.path ? conf->rootfs.mount : """", handler, cg_flags)) {
			SYSERROR(""error mounting /sys/fs/cgroup"");
			return -1;
		}
	}

	return 0;
}
",C,"		/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */
		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/tty"",                  NULL,       MS_BIND,                        NULL },
		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/tty"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
			r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);
","		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/net"",                  NULL,       MS_BIND,                        NULL },
		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/net"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
			r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);
",,"@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 		 * 2.6.32...
 		 */
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/net"",                  NULL,       MS_BIND,                        NULL },
+		/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/tty"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys"",                                       ""%r/proc/sys"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sys"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/net"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/tty"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sysrq-trigger"",                             ""%r/proc/sysrq-trigger"",        NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sysrq-trigger"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 			}
 			mflags = add_required_remount_flags(source, destination,
 					default_mounts[i].flags);
-			r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);
+			r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);
 			saved_errno = errno;
 			if (r < 0 && errno == ENOENT) {
 				INFO(""Mount source or target for %s on %s doesn't exist. Skipping."", source, destination);
@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons
 		return 0;
 	}
 
-	if (mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"")) {
+	if (safe_mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"",
+				rootfs->path ? rootfs->mount : NULL)) {
 		SYSERROR(""Failed mounting tmpfs onto %s\n"", path);
 		return false;
 	}
@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)
 				return -1;
 			}
 			fclose(pathfile);
-			if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {
+			if (safe_mount(hostpath, path, 0, MS_BIND, NULL,
+						rootfs->path ? rootfs->mount : NULL) != 0) {
 				SYSERROR(""Failed bind mounting device %s from host into container"",
 					d->name);
 				return -1;
@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,
 		return -1;
 	}
 
-	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, path, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}
@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,
 		return 0;
 	}
 
-	if (mount(console->name, lxcpath, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, lxcpath, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, lxcpath);
 		return -1;
 	}
@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)
 
 static int mount_entry(const char *fsname, const char *target,
 		       const char *fstype, unsigned long mountflags,
-		       const char *data, int optional)
+		       const char *data, int optional, const char *rootfs)
 {
 #ifdef HAVE_STATVFS
 	struct statvfs sb;
 #endif
 
-	if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {
+	if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {
 		if (optional) {
 			INFO(""failed to mount '%s' on '%s' (optional): %s"", fsname,
 			     target, strerror(errno));
@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,
 #endif
 
 		if (mount(fsname, target, fstype,
-			  mountflags | MS_REMOUNT, data)) {
+			  mountflags | MS_REMOUNT, data) < 0) {
 			if (optional) {
 				INFO(""failed to mount '%s' on '%s' (optional): %s"",
 					 fsname, target, strerror(errno));
@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,
 }
 
 static inline int mount_entry_on_generic(struct mntent *mntent,
-                 const char* path)
+                 const char* path, const char *rootfs)
 {
 	unsigned long mntflags;
 	char *mntdata;
@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 	}
 
 	ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,
-			  mntflags, mntdata, optional);
+			  mntflags, mntdata, optional, rootfs);
 
 	free(mntdata);
 
@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 
 static inline int mount_entry_on_systemfs(struct mntent *mntent)
 {
-  return mount_entry_on_generic(mntent, mntent->mnt_dir);
+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);
 }
 
 static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs->mount);
 }
 
 static int mount_entry_on_relative_rootfs(struct mntent *mntent,
@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs);
 }
 
 static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,
@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)
 		fclose(pathfile);
 	}
 
-	ret = mount(path, destpath, ""none"", MS_BIND, NULL);
+	ret = safe_mount(path, destpath, ""none"", MS_BIND, NULL, conf->rootfs.mount);
 	if (ret < 0)
 		SYSERROR(""Failed to bind lxc.init.static into container"");
 	INFO(""lxc.init.static bound into container at %s"", path);",lxc,592fd47a6245508b79fe6ac819fe6d3b2c1289be,f2e4dddd71d427f9cacbab4016ffe18b0e4a4a0a,1,"static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_handler *handler)
{
	int r;
	size_t i;
	static struct {
		int match_mask;
		int match_flag;
		const char *source;
		const char *destination;
		const char *fstype;
		unsigned long flags;
		const char *options;
	} default_mounts[] = {
		/* Read-only bind-mounting... In older kernels, doing that required
		 * to do one MS_BIND mount and then MS_REMOUNT|MS_RDONLY the same
		 * one. According to mount(2) manpage, MS_BIND honors MS_RDONLY from
		 * kernel 2.6.26 onwards. However, this apparently does not work on
		 * kernel 3.8. Unfortunately, on that very same kernel, doing the
		 * same trick as above doesn't seem to work either, there one needs
		 * to ALSO specify MS_BIND for the remount, otherwise the entire
		 * fs is remounted read-only or the mount fails because it's busy...
		 * MS_REMOUNT|MS_BIND|MS_RDONLY seems to work for kernels as low as
 		 * 2.6.32...
 		 */
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
//flaw_line_below:
		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/net"",                  NULL,       MS_BIND,                        NULL },
//fix_flaw_line_below:
//		/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */
//fix_flaw_line_below:
//		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/tty"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys"",                                       ""%r/proc/sys"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sys"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
//flaw_line_below:
		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/net"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
//fix_flaw_line_below:
//		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/tty"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sysrq-trigger"",                             ""%r/proc/sysrq-trigger"",        NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sysrq-trigger"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RW,     ""sysfs"",                                             ""%r/sys"",                       ""sysfs"",    0,                              NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RO,     ""sysfs"",                                             ""%r/sys"",                       ""sysfs"",    MS_RDONLY,                      NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  ""sysfs"",                                             ""%r/sys"",                       ""sysfs"",    MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  ""%r/sys"",                                            ""%r/sys"",                       NULL,       MS_BIND,                        NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                ""%r/sys"",                       NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  ""sysfs"",                                             ""%r/sys/devices/virtual/net"",   ""sysfs"",    0,                              NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  ""%r/sys/devices/virtual/net/devices/virtual/net"",    ""%r/sys/devices/virtual/net"",   NULL,       MS_BIND,                        NULL },
		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                ""%r/sys/devices/virtual/net"",   NULL,       MS_REMOUNT|MS_BIND|MS_NOSUID|MS_NODEV|MS_NOEXEC,   NULL },
		{ 0,                  0,                   NULL,                                                NULL,                           NULL,       0,                              NULL }
	};

	for (i = 0; default_mounts[i].match_mask; i++) {
		if ((flags & default_mounts[i].match_mask) == default_mounts[i].match_flag) {
			char *source = NULL;
			char *destination = NULL;
			int saved_errno;
			unsigned long mflags;

			if (default_mounts[i].source) {
				/* will act like strdup if %r is not present */
				source = lxc_string_replace(""%r"", conf->rootfs.path ? conf->rootfs.mount : """", default_mounts[i].source);
				if (!source) {
					SYSERROR(""memory allocation error"");
					return -1;
				}
			}
			if (default_mounts[i].destination) {
				/* will act like strdup if %r is not present */
				destination = lxc_string_replace(""%r"", conf->rootfs.path ? conf->rootfs.mount : """", default_mounts[i].destination);
				if (!destination) {
					saved_errno = errno;
					SYSERROR(""memory allocation error"");
					free(source);
					errno = saved_errno;
					return -1;
				}
 			}
 			mflags = add_required_remount_flags(source, destination,
 					default_mounts[i].flags);
//flaw_line_below:
			r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);
//fix_flaw_line_below:
//			r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);
 			saved_errno = errno;
 			if (r < 0 && errno == ENOENT) {
 				INFO(""Mount source or target for %s on %s doesn't exist. Skipping."", source, destination);
				r = 0;
			}
			else if (r < 0)
				SYSERROR(""error mounting %s on %s flags %lu"", source, destination, mflags);

			free(source);
			free(destination);
			if (r < 0) {
				errno = saved_errno;
				return -1;
			}
		}
	}

	if (flags & LXC_AUTO_CGROUP_MASK) {
		int cg_flags;

		cg_flags = flags & LXC_AUTO_CGROUP_MASK;
		/* If the type of cgroup mount was not specified, it depends on the
		 * container's capabilities as to what makes sense: if we have
		 * CAP_SYS_ADMIN, the read-only part can be remounted read-write
		 * anyway, so we may as well default to read-write; then the admin
		 * will not be given a false sense of security. (And if they really
		 * want mixed r/o r/w, then they can explicitly specify :mixed.)
		 * OTOH, if the container lacks CAP_SYS_ADMIN, do only default to
		 * :mixed, because then the container can't remount it read-write. */
		if (cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC) {
			int has_sys_admin = 0;
			if (!lxc_list_empty(&conf->keepcaps)) {
				has_sys_admin = in_caplist(CAP_SYS_ADMIN, &conf->keepcaps);
			} else {
				has_sys_admin = !in_caplist(CAP_SYS_ADMIN, &conf->caps);
			}
			if (cg_flags == LXC_AUTO_CGROUP_NOSPEC) {
				cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED;
			} else {
				cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED;
			}
		}

		if (!cgroup_mount(conf->rootfs.path ? conf->rootfs.mount : """", handler, cg_flags)) {
			SYSERROR(""error mounting /sys/fs/cgroup"");
			return -1;
		}
	}

	return 0;
}
"
2150,179886,,Local,Not required,Complete,CVE-2015-1335,https://www.cvedetails.com/cve/CVE-2015-1335/,CWE-59,Low,Complete,Complete,,2015-10-01,7.2,lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.,2019-05-31,,2,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,592fd47a6245508b79fe6ac819fe6d3b2c1289be,"CVE-2015-1335: Protect container mounts against symlinks

When a container starts up, lxc sets up the container's inital fstree
by doing a bunch of mounting, guided by the container configuration
file.  The container config is owned by the admin or user on the host,
so we do not try to guard against bad entries.  However, since the
mount target is in the container, it's possible that the container admin
could divert the mount with symbolic links.  This could bypass proper
container startup (i.e. confinement of a root-owned container by the
restrictive apparmor policy, by diverting the required write to
/proc/self/attr/current), or bypass the (path-based) apparmor policy
by diverting, say, /proc to /mnt in the container.

To prevent this,

1. do not allow mounts to paths containing symbolic links

2. do not allow bind mounts from relative paths containing symbolic
links.

Details:

Define safe_mount which ensures that the container has not inserted any
symbolic links into any mount targets for mounts to be done during
container setup.

The host's mount path may contain symbolic links.  As it is under the
control of the administrator, that's ok.  So safe_mount begins the check
for symbolic links after the rootfs->mount, by opening that directory.

It opens each directory along the path using openat() relative to the
parent directory using O_NOFOLLOW.  When the target is reached, it
mounts onto /proc/self/fd/<targetfd>.

Use safe_mount() in mount_entry(), when mounting container proc,
and when needed.  In particular, safe_mount() need not be used in
any case where:

1. the mount is done in the container's namespace
2. the mount is for the container's rootfs
3. the mount is relative to a tmpfs or proc/sysfs which we have
   just safe_mount()ed ourselves

Since we were using proc/net as a temporary placeholder for /proc/sys/net
during container startup, and proc/net is a symbolic link, use proc/tty
instead.

Update the lxc.container.conf manpage with details about the new
restrictions.

Finally, add a testcase to test some symbolic link possibilities.

Reported-by: Roman Fiedler
Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Acked-by: Stphane Graber <stgraber@ubuntu.com>",1,src/lxc/conf.c,"{""sha"": ""eb3241f795d2f3e0f1fb762516983b74e99af52f"", ""filename"": ""doc/lxc.container.conf.sgml.in"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/doc/lxc.container.conf.sgml.in?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -760,6 +760,18 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n         container. This is useful to mount /etc, /var or /home for\n         examples.\n       </para>\n+      <para>\n+\tNOTE - LXC will generally ensure that mount targets and relative\n+\tbind-mount sources are properly confined under the container\n+\troot, to avoid attacks involving over-mounting host directories\n+\tand files.  (Symbolic links in absolute mount sources are ignored)\n+\tHowever, if the container configuration first mounts a directory which\n+\tis under the control of the container user, such as /home/joe, into\n+        the container at some <filename>path</filename>, and then mounts\n+        under <filename>path</filename>, then a TOCTTOU attack would be\n+        possible where the container user modifies a symbolic link under\n+        his home directory at just the right time.\n+      </para>\n       <variablelist>\n         <varlistentry>\n           <term>""}<_**next**_>{""sha"": ""df2e6b2333bc81f94bf7583087475fd8d62605a1"", ""filename"": ""src/lxc/cgfs.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgfs.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1363,7 +1363,10 @@ static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \""%s/sys/fs/cgroup\"", root);\n-\tr = mount(\""cgroup_root\"", path, \""tmpfs\"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \""size=10240k,mode=755\"");\n+\tr = safe_mount(\""cgroup_root\"", path, \""tmpfs\"",\n+\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n+\t\t\t\""size=10240k,mode=755\"",\n+\t\t\troot);\n \tif (r < 0) {\n \t\tSYSERROR(\""could not mount tmpfs to /sys/fs/cgroup in the container\"");\n \t\treturn false;""}<_**next**_>{""sha"": ""a677c22c768eccccaa3af386c662c43dad8412cf"", ""filename"": ""src/lxc/cgmanager.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgmanager.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1477,7 +1477,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t}\n \n \t/* mount a tmpfs there so we can create subdirs */\n-\tif (mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"")) {\n+\tif (safe_mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"", root)) {\n \t\tSYSERROR(\""Failed to mount tmpfs at %s\"", cgpath);\n \t\treturn false;\n \t}\n@@ -1488,7 +1488,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t\treturn false;\n \t}\n \n-\tif (mount(dirname, cgpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(dirname, cgpath, \""none\"", MS_BIND, 0, root)) {\n \t\tSYSERROR(\""Failed to bind mount %s to %s\"", dirname, cgpath);\n \t\treturn false;\n \t}""}<_**next**_>{""sha"": ""bb4c19f82e2c806b07125cbfd9ed3220df07be38"", ""filename"": ""src/lxc/conf.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 16, ""changes"": 35, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/conf.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t * 2.6.32...\n \t\t */\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/net\"",                  NULL,       MS_BIND,                        NULL },\n+\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/tty\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys\"",                                       \""%r/proc/sys\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sys\"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/net\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/tty\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sysrq-trigger\"",                             \""%r/proc/sysrq-trigger\"",        NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sysrq-trigger\"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t\t}\n \t\t\tmflags = add_required_remount_flags(source, destination,\n \t\t\t\t\tdefault_mounts[i].flags);\n-\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n+\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n \t\t\tsaved_errno = errno;\n \t\t\tif (r < 0 && errno == ENOENT) {\n \t\t\t\tINFO(\""Mount source or target for %s on %s doesn't exist. Skipping.\"", source, destination);\n@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons\n \t\treturn 0;\n \t}\n \n-\tif (mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"")) {\n+\tif (safe_mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"",\n+\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n \t\tSYSERROR(\""Failed mounting tmpfs onto %s\\n\"", path);\n \t\treturn false;\n \t}\n@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tfclose(pathfile);\n-\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n+\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n+\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n \t\t\t\tSYSERROR(\""Failed bind mounting device %s from host into container\"",\n \t\t\t\t\td->name);\n \t\t\t\treturn -1;\n@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,\n \t\treturn -1;\n \t}\n \n-\tif (mount(console->name, path, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, path, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, path);\n \t\treturn -1;\n \t}\n@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n \t\treturn 0;\n \t}\n \n-\tif (mount(console->name, lxcpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, lxcpath, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, lxcpath);\n \t\treturn -1;\n \t}\n@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)\n \n static int mount_entry(const char *fsname, const char *target,\n \t\t       const char *fstype, unsigned long mountflags,\n-\t\t       const char *data, int optional)\n+\t\t       const char *data, int optional, const char *rootfs)\n {\n #ifdef HAVE_STATVFS\n \tstruct statvfs sb;\n #endif\n \n-\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n+\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n \t\tif (optional) {\n \t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"", fsname,\n \t\t\t     target, strerror(errno));\n@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,\n #endif\n \n \t\tif (mount(fsname, target, fstype,\n-\t\t\t  mountflags | MS_REMOUNT, data)) {\n+\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n \t\t\tif (optional) {\n \t\t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"",\n \t\t\t\t\t fsname, target, strerror(errno));\n@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,\n }\n \n static inline int mount_entry_on_generic(struct mntent *mntent,\n-                 const char* path)\n+                 const char* path, const char *rootfs)\n {\n \tunsigned long mntflags;\n \tchar *mntdata;\n@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \t}\n \n \tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n-\t\t\t  mntflags, mntdata, optional);\n+\t\t\t  mntflags, mntdata, optional, rootfs);\n \n \tfree(mntdata);\n \n@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \n static inline int mount_entry_on_systemfs(struct mntent *mntent)\n {\n-  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n }\n \n static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n }\n \n static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs);\n }\n \n static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \""none\"", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \""none\"", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\""Failed to bind lxc.init.static into container\"");\n \tINFO(\""lxc.init.static bound into container at %s\"", path);""}<_**next**_>{""sha"": ""788cbe136302bb46a559c36dc45a895f8c584574"", ""filename"": ""src/lxc/utils.c"", ""status"": ""modified"", ""additions"": 234, ""deletions"": 1, ""changes"": 235, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1404,6 +1404,239 @@ int setproctitle(char *title)\n \treturn ret;\n }\n \n+/*\n+ * @path:    a pathname where / replaced with '\\0'.\n+ * @offsetp: pointer to int showing which path segment was last seen.\n+ *           Updated on return to reflect the next segment.\n+ * @fulllen: full original path length.\n+ * Returns a pointer to the next path segment, or NULL if done.\n+ */\n+static char *get_nextpath(char *path, int *offsetp, int fulllen)\n+{\n+\tint offset = *offsetp;\n+\n+\tif (offset >= fulllen)\n+\t\treturn NULL;\n+\n+\twhile (path[offset] != '\\0' && offset < fulllen)\n+\t\toffset++;\n+\twhile (path[offset] == '\\0' && offset < fulllen)\n+\t\toffset++;\n+\n+\t*offsetp = offset;\n+\treturn (offset < fulllen) ? &path[offset] : NULL;\n+}\n+\n+/*\n+ * Check that @subdir is a subdir of @dir.  @len is the length of\n+ * @dir (to avoid having to recalculate it).\n+ */\n+static bool is_subdir(const char *subdir, const char *dir, size_t len)\n+{\n+\tsize_t subdirlen = strlen(subdir);\n+\n+\tif (subdirlen < len)\n+\t\treturn false;\n+\tif (strncmp(subdir, dir, len) != 0)\n+\t\treturn false;\n+\tif (dir[len-1] == '/')\n+\t\treturn true;\n+\tif (subdir[len] == '/' || subdirlen == len)\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+/*\n+ * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return\n+ * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.\n+ */\n+static int check_symlink(int fd)\n+{\n+\tstruct stat sb;\n+\tint ret = fstat(fd, &sb);\n+\tif (ret < 0)\n+\t\treturn -ENOENT;\n+\tif (S_ISLNK(sb.st_mode))\n+\t\treturn -ELOOP;\n+\treturn 0;\n+}\n+\n+/*\n+ * Open a file or directory, provided that it contains no symlinks.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+static int open_if_safe(int dirfd, const char *nextpath)\n+{\n+\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n+\tif (newfd >= 0) // was not a symlink, all good\n+\t\treturn newfd;\n+\n+\tif (errno == ELOOP)\n+\t\treturn newfd;\n+\n+\tif (errno == EPERM || errno == EACCES) {\n+\t\t/* we're not root (cause we got EPERM) so\n+\t\t   try opening with O_PATH */\n+\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n+\t\tif (newfd >= 0) {\n+\t\t\t/* O_PATH will return an fd for symlinks.  We know\n+\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n+\t\t\t * is now a link, then something * fishy is going on\n+\t\t\t */\n+\t\t\tint ret = check_symlink(newfd);\n+\t\t\tif (ret < 0) {\n+\t\t\t\tclose(newfd);\n+\t\t\t\tnewfd = ret;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newfd;\n+}\n+\n+/*\n+ * Open a path intending for mounting, ensuring that the final path\n+ * is inside the container's rootfs.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ *\n+ * @target: path to be opened\n+ * @prefix_skip: a part of @target in which to ignore symbolic links.  This\n+ * would be the container's rootfs.\n+ *\n+ * Return an open fd for the path, or <0 on error.\n+ */\n+static int open_without_symlink(const char *target, const char *prefix_skip)\n+{\n+\tint curlen = 0, dirfd, fulllen, i;\n+\tchar *dup = NULL;\n+\n+\tfulllen = strlen(target);\n+\n+\t/* make sure prefix-skip makes sense */\n+\tif (prefix_skip) {\n+\t\tcurlen = strlen(prefix_skip);\n+\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n+\t\t\tERROR(\""WHOA there - target '%s' didn't start with prefix '%s'\"",\n+\t\t\t\ttarget, prefix_skip);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\t/*\n+\t\t * get_nextpath() expects the curlen argument to be\n+\t\t * on a  (turned into \\0) / or before it, so decrement\n+\t\t * curlen to make sure that happens\n+\t\t */\n+\t\tif (curlen)\n+\t\t\tcurlen--;\n+\t} else {\n+\t\tprefix_skip = \""/\"";\n+\t\tcurlen = 0;\n+\t}\n+\n+\t/* Make a copy of target which we can hack up, and tokenize it */\n+\tif ((dup = strdup(target)) == NULL) {\n+\t\tSYSERROR(\""Out of memory checking for symbolic link\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\tfor (i = 0; i < fulllen; i++) {\n+\t\tif (dup[i] == '/')\n+\t\t\tdup[i] = '\\0';\n+\t}\n+\n+\tdirfd = open(prefix_skip, O_RDONLY);\n+\tif (dirfd < 0)\n+\t\tgoto out;\n+\twhile (1) {\n+\t\tint newfd, saved_errno;\n+\t\tchar *nextpath;\n+\n+\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n+\t\t\tgoto out;\n+\t\tnewfd = open_if_safe(dirfd, nextpath);\n+\t\tsaved_errno = errno;\n+\t\tclose(dirfd);\n+\t\tdirfd = newfd;\n+\t\tif (newfd < 0) {\n+\t\t\terrno = saved_errno;\n+\t\t\tif (errno == ELOOP)\n+\t\t\t\tSYSERROR(\""%s in %s was a symbolic link!\"", nextpath, target);\n+\t\t\telse\n+\t\t\t\tSYSERROR(\""Error examining %s in %s\"", nextpath, target);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+out:\n+\tfree(dup);\n+\treturn dirfd;\n+}\n+\n+/*\n+ * Safely mount a path into a container, ensuring that the mount target\n+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container\n+ * uses the host's /)\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs)\n+{\n+\tint srcfd = -1, destfd, ret, saved_errno;\n+\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n+\tconst char *mntsrc = src;\n+\n+\tif (!rootfs)\n+\t\trootfs = \""\"";\n+\n+\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n+\tif (flags & MS_BIND && src && src[0] != '/') {\n+\t\tINFO(\""this is a relative bind mount\"");\n+\t\tsrcfd = open_without_symlink(src, NULL);\n+\t\tif (srcfd < 0)\n+\t\t\treturn srcfd;\n+\t\tret = snprintf(srcbuf, 50, \""/proc/self/fd/%d\"", srcfd);\n+\t\tif (ret < 0 || ret > 50) {\n+\t\t\tclose(srcfd);\n+\t\t\tERROR(\""Out of memory\"");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tmntsrc = srcbuf;\n+\t}\n+\n+\tdestfd = open_without_symlink(dest, rootfs);\n+\tif (destfd < 0) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\treturn destfd;\n+\t}\n+\n+\tret = snprintf(destbuf, 50, \""/proc/self/fd/%d\"", destfd);\n+\tif (ret < 0 || ret > 50) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\tclose(destfd);\n+\t\tERROR(\""Out of memory\"");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tret = mount(mntsrc, destbuf, fstype, flags, data);\n+\tsaved_errno = errno;\n+\tif (srcfd != -1)\n+\t\tclose(srcfd);\n+\tclose(destfd);\n+\tif (ret < 0) {\n+\t\terrno = saved_errno;\n+\t\tSYSERROR(\""Failed to mount %s onto %s\"", src, dest);\n+\t\treturn ret;\n+\t}\n+\n+\treturn 0;\n+}\n+\n /*\n  * Mount a proc under @rootfs if proc self points to a pid other than\n  * my own.  This is needed to have a known-good proc mount for setting\n@@ -1446,7 +1679,7 @@ int mount_proc_if_needed(const char *rootfs)\n \treturn 0;\n \n domount:\n-\tif (mount(\""proc\"", path, \""proc\"", 0, NULL))\n+\tif (safe_mount(\""proc\"", path, \""proc\"", 0, NULL, rootfs) < 0)\n \t\treturn -1;\n \tINFO(\""Mounted /proc in container for security transition\"");\n \treturn 1;""}<_**next**_>{""sha"": ""059026f0154b1713854c84674d12954a09469506"", ""filename"": ""src/lxc/utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.h?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -279,6 +279,8 @@ bool switch_to_ns(pid_t pid, const char *ns);\n int is_dir(const char *path);\n char *get_template_path(const char *t);\n int setproctitle(char *title);\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs);\n int mount_proc_if_needed(const char *rootfs);\n int null_stdfds(void);\n #endif /* __LXC_UTILS_H */""}<_**next**_>{""sha"": ""462d4f27882715442c3183b9db6620430b767455"", ""filename"": ""src/tests/Makefile.am"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/Makefile.am?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -55,6 +55,7 @@ bin_SCRIPTS += \\\n \tlxc-test-apparmor-mount \\\n \tlxc-test-checkpoint-restore \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tlxc-test-usernic\n@@ -82,6 +83,7 @@ EXTRA_DIST = \\\n \tlxc-test-cloneconfig \\\n \tlxc-test-createconfig \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tmay_control.c \\""}<_**next**_>{""sha"": ""37320f0dfd96b262d52bc99e314b7fe3cb026bb1"", ""filename"": ""src/tests/lxc-test-symlink"", ""status"": ""added"", ""additions"": 88, ""deletions"": 0, ""changes"": 88, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/lxc-test-symlink?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -0,0 +1,88 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+# lxc: linux Container library\n+\n+# Authors:\n+# Serge Hallyn <serge.hallyn@ubuntu.com>\n+#\n+# This is a regression test for symbolic links\n+\n+dirname=`mktemp -d`\n+fname=`mktemp`\n+fname2=`mktemp`\n+\n+lxcpath=/var/lib/lxcsym1\n+\n+cleanup() {\n+\tlxc-destroy -P $lxcpath -f -n symtest1 || true\n+\trm -f $lxcpath\n+\trmdir $dirname || true\n+\trm -f $fname || true\n+\trm -f $fname2 || true\n+}\n+\n+trap cleanup EXIT SIGHUP SIGINT SIGTERM\n+\n+testrun() {\n+\texpected=$1\n+\trun=$2\n+\tpass=\""pass\""\n+\tlxc-start -P $lxcpath -n symtest1 -l trace -o $lxcpath/log || pass=\""fail\""\n+\t[ $pass = \""pass\"" ] && lxc-wait -P $lxcpath -n symtest1 -t 10 -s RUNNING || pass=\""fail\""\n+\tif [ \""$pass\"" != \""$expected\"" ]; then\n+\t\techo \""Test $run: expected $expected but container did not.  Start log:\""\n+\t\tcat $lxcpath/log\n+\t\techo \""FAIL: Test $run: expected $expected but container did not.\""\n+\t\tfalse\n+\tfi\n+\tlxc-stop -P $lxcpath -n symtest1 -k || true\n+}\n+\n+# make lxcpath a symlink - this should NOT cause failure\n+ln -s /var/lib/lxc $lxcpath\n+\n+lxc-destroy -P $lxcpath -f -n symtest1 || true\n+lxc-create -P $lxcpath -t busybox -n symtest1\n+\n+cat >> /var/lib/lxc/symtest1/config << EOF\n+lxc.mount.entry = $dirname opt/xxx/dir none bind,create=dir\n+lxc.mount.entry = $fname opt/xxx/file none bind,create=file\n+lxc.mount.entry = $fname2 opt/xxx/file2 none bind\n+EOF\n+\n+# Regular - should succeed\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun pass 1\n+\n+# symlink - should fail\n+rm -rf /var/lib/lxc/symtest1/rootfs/opt/xxx\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx2\n+ln -s /var/lib/lxc/symtest1/rootfs/opt/xxx2 /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun fail 2\n+\n+# final final symlink - should fail\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx/dir\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2src\n+ln -s $lxcpath/symtest1/rootfs/opt/xxx/file2src $lxcpath/symtest1/rootfs/opt/xxx/file2\n+testrun fail 3\n+\n+# Ideally we'd also try a loop device, but that won't work in nested containers\n+# anyway - TODO\n+\n+# what about /proc itself\n+\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2\n+mv $lxcpath/symtest1/rootfs/proc $lxcpath/symtest1/rootfs/proc1\n+ln -s $lxcpath/symtest1/rootfs/proc1 $lxcpath/symtest1/rootfs/proc\n+testrun fail 4\n+\n+echo \""all tests passed\""""}","static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)
{
	int ret;
	size_t clen;
	char *path;

	INFO(""Mounting container /dev"");

	/* $(rootfs->mount) + ""/dev/pts"" + '\0' */
	clen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;
	path = alloca(clen);

	ret = snprintf(path, clen, ""%s/dev"", rootfs->path ? rootfs->mount : """");
	if (ret < 0 || ret >= clen)
		return -1;

	if (!dir_exists(path)) {
		WARN(""No /dev in container."");
		WARN(""Proceeding without autodev setup"");
 		return 0;
 	}
 
	if (safe_mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"",
				rootfs->path ? rootfs->mount : NULL)) {
 		SYSERROR(""Failed mounting tmpfs onto %s\n"", path);
 		return false;
 	}

	INFO(""Mounted tmpfs onto %s"",  path);

	ret = snprintf(path, clen, ""%s/dev/pts"", rootfs->path ? rootfs->mount : """");
	if (ret < 0 || ret >= clen)
		return -1;

	/*
	 * If we are running on a devtmpfs mapping, dev/pts may already exist.
	 * If not, then create it and exit if that fails...
	 */
	if (!dir_exists(path)) {
		ret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
		if (ret) {
			SYSERROR(""Failed to create /dev/pts in container"");
			return -1;
		}
	}

	INFO(""Mounted container /dev"");
	return 0;
}
","static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)
{
	int ret;
	size_t clen;
	char *path;

	INFO(""Mounting container /dev"");

	/* $(rootfs->mount) + ""/dev/pts"" + '\0' */
	clen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;
	path = alloca(clen);

	ret = snprintf(path, clen, ""%s/dev"", rootfs->path ? rootfs->mount : """");
	if (ret < 0 || ret >= clen)
		return -1;

	if (!dir_exists(path)) {
		WARN(""No /dev in container."");
		WARN(""Proceeding without autodev setup"");
 		return 0;
 	}
 
	if (mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"")) {
 		SYSERROR(""Failed mounting tmpfs onto %s\n"", path);
 		return false;
 	}

	INFO(""Mounted tmpfs onto %s"",  path);

	ret = snprintf(path, clen, ""%s/dev/pts"", rootfs->path ? rootfs->mount : """");
	if (ret < 0 || ret >= clen)
		return -1;

	/*
	 * If we are running on a devtmpfs mapping, dev/pts may already exist.
	 * If not, then create it and exit if that fails...
	 */
	if (!dir_exists(path)) {
		ret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
		if (ret) {
			SYSERROR(""Failed to create /dev/pts in container"");
			return -1;
		}
	}

	INFO(""Mounted container /dev"");
	return 0;
}
",C,"	if (safe_mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"",
				rootfs->path ? rootfs->mount : NULL)) {
","	if (mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"")) {
",,"@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 		 * 2.6.32...
 		 */
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/net"",                  NULL,       MS_BIND,                        NULL },
+		/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/tty"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys"",                                       ""%r/proc/sys"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sys"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/net"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/tty"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sysrq-trigger"",                             ""%r/proc/sysrq-trigger"",        NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sysrq-trigger"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 			}
 			mflags = add_required_remount_flags(source, destination,
 					default_mounts[i].flags);
-			r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);
+			r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);
 			saved_errno = errno;
 			if (r < 0 && errno == ENOENT) {
 				INFO(""Mount source or target for %s on %s doesn't exist. Skipping."", source, destination);
@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons
 		return 0;
 	}
 
-	if (mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"")) {
+	if (safe_mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"",
+				rootfs->path ? rootfs->mount : NULL)) {
 		SYSERROR(""Failed mounting tmpfs onto %s\n"", path);
 		return false;
 	}
@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)
 				return -1;
 			}
 			fclose(pathfile);
-			if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {
+			if (safe_mount(hostpath, path, 0, MS_BIND, NULL,
+						rootfs->path ? rootfs->mount : NULL) != 0) {
 				SYSERROR(""Failed bind mounting device %s from host into container"",
 					d->name);
 				return -1;
@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,
 		return -1;
 	}
 
-	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, path, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}
@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,
 		return 0;
 	}
 
-	if (mount(console->name, lxcpath, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, lxcpath, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, lxcpath);
 		return -1;
 	}
@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)
 
 static int mount_entry(const char *fsname, const char *target,
 		       const char *fstype, unsigned long mountflags,
-		       const char *data, int optional)
+		       const char *data, int optional, const char *rootfs)
 {
 #ifdef HAVE_STATVFS
 	struct statvfs sb;
 #endif
 
-	if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {
+	if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {
 		if (optional) {
 			INFO(""failed to mount '%s' on '%s' (optional): %s"", fsname,
 			     target, strerror(errno));
@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,
 #endif
 
 		if (mount(fsname, target, fstype,
-			  mountflags | MS_REMOUNT, data)) {
+			  mountflags | MS_REMOUNT, data) < 0) {
 			if (optional) {
 				INFO(""failed to mount '%s' on '%s' (optional): %s"",
 					 fsname, target, strerror(errno));
@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,
 }
 
 static inline int mount_entry_on_generic(struct mntent *mntent,
-                 const char* path)
+                 const char* path, const char *rootfs)
 {
 	unsigned long mntflags;
 	char *mntdata;
@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 	}
 
 	ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,
-			  mntflags, mntdata, optional);
+			  mntflags, mntdata, optional, rootfs);
 
 	free(mntdata);
 
@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 
 static inline int mount_entry_on_systemfs(struct mntent *mntent)
 {
-  return mount_entry_on_generic(mntent, mntent->mnt_dir);
+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);
 }
 
 static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs->mount);
 }
 
 static int mount_entry_on_relative_rootfs(struct mntent *mntent,
@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs);
 }
 
 static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,
@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)
 		fclose(pathfile);
 	}
 
-	ret = mount(path, destpath, ""none"", MS_BIND, NULL);
+	ret = safe_mount(path, destpath, ""none"", MS_BIND, NULL, conf->rootfs.mount);
 	if (ret < 0)
 		SYSERROR(""Failed to bind lxc.init.static into container"");
 	INFO(""lxc.init.static bound into container at %s"", path);",lxc,592fd47a6245508b79fe6ac819fe6d3b2c1289be,f2e4dddd71d427f9cacbab4016ffe18b0e4a4a0a,1,"static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)
{
	int ret;
	size_t clen;
	char *path;

	INFO(""Mounting container /dev"");

	/* $(rootfs->mount) + ""/dev/pts"" + '\0' */
	clen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;
	path = alloca(clen);

	ret = snprintf(path, clen, ""%s/dev"", rootfs->path ? rootfs->mount : """");
	if (ret < 0 || ret >= clen)
		return -1;

	if (!dir_exists(path)) {
		WARN(""No /dev in container."");
		WARN(""Proceeding without autodev setup"");
 		return 0;
 	}
 
//flaw_line_below:
	if (mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"")) {
//fix_flaw_line_below:
//	if (safe_mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"",
//fix_flaw_line_below:
//				rootfs->path ? rootfs->mount : NULL)) {
 		SYSERROR(""Failed mounting tmpfs onto %s\n"", path);
 		return false;
 	}

	INFO(""Mounted tmpfs onto %s"",  path);

	ret = snprintf(path, clen, ""%s/dev/pts"", rootfs->path ? rootfs->mount : """");
	if (ret < 0 || ret >= clen)
		return -1;

	/*
	 * If we are running on a devtmpfs mapping, dev/pts may already exist.
	 * If not, then create it and exit if that fails...
	 */
	if (!dir_exists(path)) {
		ret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
		if (ret) {
			SYSERROR(""Failed to create /dev/pts in container"");
			return -1;
		}
	}

	INFO(""Mounted container /dev"");
	return 0;
}
"
2151,179887,,Local,Not required,Complete,CVE-2015-1335,https://www.cvedetails.com/cve/CVE-2015-1335/,CWE-59,Low,Complete,Complete,,2015-10-01,7.2,lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.,2019-05-31,,3,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,592fd47a6245508b79fe6ac819fe6d3b2c1289be,"CVE-2015-1335: Protect container mounts against symlinks

When a container starts up, lxc sets up the container's inital fstree
by doing a bunch of mounting, guided by the container configuration
file.  The container config is owned by the admin or user on the host,
so we do not try to guard against bad entries.  However, since the
mount target is in the container, it's possible that the container admin
could divert the mount with symbolic links.  This could bypass proper
container startup (i.e. confinement of a root-owned container by the
restrictive apparmor policy, by diverting the required write to
/proc/self/attr/current), or bypass the (path-based) apparmor policy
by diverting, say, /proc to /mnt in the container.

To prevent this,

1. do not allow mounts to paths containing symbolic links

2. do not allow bind mounts from relative paths containing symbolic
links.

Details:

Define safe_mount which ensures that the container has not inserted any
symbolic links into any mount targets for mounts to be done during
container setup.

The host's mount path may contain symbolic links.  As it is under the
control of the administrator, that's ok.  So safe_mount begins the check
for symbolic links after the rootfs->mount, by opening that directory.

It opens each directory along the path using openat() relative to the
parent directory using O_NOFOLLOW.  When the target is reached, it
mounts onto /proc/self/fd/<targetfd>.

Use safe_mount() in mount_entry(), when mounting container proc,
and when needed.  In particular, safe_mount() need not be used in
any case where:

1. the mount is done in the container's namespace
2. the mount is for the container's rootfs
3. the mount is relative to a tmpfs or proc/sysfs which we have
   just safe_mount()ed ourselves

Since we were using proc/net as a temporary placeholder for /proc/sys/net
during container startup, and proc/net is a symbolic link, use proc/tty
instead.

Update the lxc.container.conf manpage with details about the new
restrictions.

Finally, add a testcase to test some symbolic link possibilities.

Reported-by: Roman Fiedler
Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Acked-by: Stphane Graber <stgraber@ubuntu.com>",3,src/lxc/conf.c,"{""sha"": ""eb3241f795d2f3e0f1fb762516983b74e99af52f"", ""filename"": ""doc/lxc.container.conf.sgml.in"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/doc/lxc.container.conf.sgml.in?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -760,6 +760,18 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n         container. This is useful to mount /etc, /var or /home for\n         examples.\n       </para>\n+      <para>\n+\tNOTE - LXC will generally ensure that mount targets and relative\n+\tbind-mount sources are properly confined under the container\n+\troot, to avoid attacks involving over-mounting host directories\n+\tand files.  (Symbolic links in absolute mount sources are ignored)\n+\tHowever, if the container configuration first mounts a directory which\n+\tis under the control of the container user, such as /home/joe, into\n+        the container at some <filename>path</filename>, and then mounts\n+        under <filename>path</filename>, then a TOCTTOU attack would be\n+        possible where the container user modifies a symbolic link under\n+        his home directory at just the right time.\n+      </para>\n       <variablelist>\n         <varlistentry>\n           <term>""}<_**next**_>{""sha"": ""df2e6b2333bc81f94bf7583087475fd8d62605a1"", ""filename"": ""src/lxc/cgfs.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgfs.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1363,7 +1363,10 @@ static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \""%s/sys/fs/cgroup\"", root);\n-\tr = mount(\""cgroup_root\"", path, \""tmpfs\"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \""size=10240k,mode=755\"");\n+\tr = safe_mount(\""cgroup_root\"", path, \""tmpfs\"",\n+\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n+\t\t\t\""size=10240k,mode=755\"",\n+\t\t\troot);\n \tif (r < 0) {\n \t\tSYSERROR(\""could not mount tmpfs to /sys/fs/cgroup in the container\"");\n \t\treturn false;""}<_**next**_>{""sha"": ""a677c22c768eccccaa3af386c662c43dad8412cf"", ""filename"": ""src/lxc/cgmanager.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgmanager.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1477,7 +1477,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t}\n \n \t/* mount a tmpfs there so we can create subdirs */\n-\tif (mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"")) {\n+\tif (safe_mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"", root)) {\n \t\tSYSERROR(\""Failed to mount tmpfs at %s\"", cgpath);\n \t\treturn false;\n \t}\n@@ -1488,7 +1488,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t\treturn false;\n \t}\n \n-\tif (mount(dirname, cgpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(dirname, cgpath, \""none\"", MS_BIND, 0, root)) {\n \t\tSYSERROR(\""Failed to bind mount %s to %s\"", dirname, cgpath);\n \t\treturn false;\n \t}""}<_**next**_>{""sha"": ""bb4c19f82e2c806b07125cbfd9ed3220df07be38"", ""filename"": ""src/lxc/conf.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 16, ""changes"": 35, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/conf.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t * 2.6.32...\n \t\t */\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/net\"",                  NULL,       MS_BIND,                        NULL },\n+\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/tty\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys\"",                                       \""%r/proc/sys\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sys\"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/net\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/tty\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sysrq-trigger\"",                             \""%r/proc/sysrq-trigger\"",        NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sysrq-trigger\"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t\t}\n \t\t\tmflags = add_required_remount_flags(source, destination,\n \t\t\t\t\tdefault_mounts[i].flags);\n-\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n+\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n \t\t\tsaved_errno = errno;\n \t\t\tif (r < 0 && errno == ENOENT) {\n \t\t\t\tINFO(\""Mount source or target for %s on %s doesn't exist. Skipping.\"", source, destination);\n@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons\n \t\treturn 0;\n \t}\n \n-\tif (mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"")) {\n+\tif (safe_mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"",\n+\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n \t\tSYSERROR(\""Failed mounting tmpfs onto %s\\n\"", path);\n \t\treturn false;\n \t}\n@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tfclose(pathfile);\n-\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n+\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n+\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n \t\t\t\tSYSERROR(\""Failed bind mounting device %s from host into container\"",\n \t\t\t\t\td->name);\n \t\t\t\treturn -1;\n@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,\n \t\treturn -1;\n \t}\n \n-\tif (mount(console->name, path, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, path, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, path);\n \t\treturn -1;\n \t}\n@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n \t\treturn 0;\n \t}\n \n-\tif (mount(console->name, lxcpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, lxcpath, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, lxcpath);\n \t\treturn -1;\n \t}\n@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)\n \n static int mount_entry(const char *fsname, const char *target,\n \t\t       const char *fstype, unsigned long mountflags,\n-\t\t       const char *data, int optional)\n+\t\t       const char *data, int optional, const char *rootfs)\n {\n #ifdef HAVE_STATVFS\n \tstruct statvfs sb;\n #endif\n \n-\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n+\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n \t\tif (optional) {\n \t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"", fsname,\n \t\t\t     target, strerror(errno));\n@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,\n #endif\n \n \t\tif (mount(fsname, target, fstype,\n-\t\t\t  mountflags | MS_REMOUNT, data)) {\n+\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n \t\t\tif (optional) {\n \t\t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"",\n \t\t\t\t\t fsname, target, strerror(errno));\n@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,\n }\n \n static inline int mount_entry_on_generic(struct mntent *mntent,\n-                 const char* path)\n+                 const char* path, const char *rootfs)\n {\n \tunsigned long mntflags;\n \tchar *mntdata;\n@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \t}\n \n \tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n-\t\t\t  mntflags, mntdata, optional);\n+\t\t\t  mntflags, mntdata, optional, rootfs);\n \n \tfree(mntdata);\n \n@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \n static inline int mount_entry_on_systemfs(struct mntent *mntent)\n {\n-  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n }\n \n static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n }\n \n static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs);\n }\n \n static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \""none\"", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \""none\"", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\""Failed to bind lxc.init.static into container\"");\n \tINFO(\""lxc.init.static bound into container at %s\"", path);""}<_**next**_>{""sha"": ""788cbe136302bb46a559c36dc45a895f8c584574"", ""filename"": ""src/lxc/utils.c"", ""status"": ""modified"", ""additions"": 234, ""deletions"": 1, ""changes"": 235, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1404,6 +1404,239 @@ int setproctitle(char *title)\n \treturn ret;\n }\n \n+/*\n+ * @path:    a pathname where / replaced with '\\0'.\n+ * @offsetp: pointer to int showing which path segment was last seen.\n+ *           Updated on return to reflect the next segment.\n+ * @fulllen: full original path length.\n+ * Returns a pointer to the next path segment, or NULL if done.\n+ */\n+static char *get_nextpath(char *path, int *offsetp, int fulllen)\n+{\n+\tint offset = *offsetp;\n+\n+\tif (offset >= fulllen)\n+\t\treturn NULL;\n+\n+\twhile (path[offset] != '\\0' && offset < fulllen)\n+\t\toffset++;\n+\twhile (path[offset] == '\\0' && offset < fulllen)\n+\t\toffset++;\n+\n+\t*offsetp = offset;\n+\treturn (offset < fulllen) ? &path[offset] : NULL;\n+}\n+\n+/*\n+ * Check that @subdir is a subdir of @dir.  @len is the length of\n+ * @dir (to avoid having to recalculate it).\n+ */\n+static bool is_subdir(const char *subdir, const char *dir, size_t len)\n+{\n+\tsize_t subdirlen = strlen(subdir);\n+\n+\tif (subdirlen < len)\n+\t\treturn false;\n+\tif (strncmp(subdir, dir, len) != 0)\n+\t\treturn false;\n+\tif (dir[len-1] == '/')\n+\t\treturn true;\n+\tif (subdir[len] == '/' || subdirlen == len)\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+/*\n+ * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return\n+ * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.\n+ */\n+static int check_symlink(int fd)\n+{\n+\tstruct stat sb;\n+\tint ret = fstat(fd, &sb);\n+\tif (ret < 0)\n+\t\treturn -ENOENT;\n+\tif (S_ISLNK(sb.st_mode))\n+\t\treturn -ELOOP;\n+\treturn 0;\n+}\n+\n+/*\n+ * Open a file or directory, provided that it contains no symlinks.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+static int open_if_safe(int dirfd, const char *nextpath)\n+{\n+\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n+\tif (newfd >= 0) // was not a symlink, all good\n+\t\treturn newfd;\n+\n+\tif (errno == ELOOP)\n+\t\treturn newfd;\n+\n+\tif (errno == EPERM || errno == EACCES) {\n+\t\t/* we're not root (cause we got EPERM) so\n+\t\t   try opening with O_PATH */\n+\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n+\t\tif (newfd >= 0) {\n+\t\t\t/* O_PATH will return an fd for symlinks.  We know\n+\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n+\t\t\t * is now a link, then something * fishy is going on\n+\t\t\t */\n+\t\t\tint ret = check_symlink(newfd);\n+\t\t\tif (ret < 0) {\n+\t\t\t\tclose(newfd);\n+\t\t\t\tnewfd = ret;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newfd;\n+}\n+\n+/*\n+ * Open a path intending for mounting, ensuring that the final path\n+ * is inside the container's rootfs.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ *\n+ * @target: path to be opened\n+ * @prefix_skip: a part of @target in which to ignore symbolic links.  This\n+ * would be the container's rootfs.\n+ *\n+ * Return an open fd for the path, or <0 on error.\n+ */\n+static int open_without_symlink(const char *target, const char *prefix_skip)\n+{\n+\tint curlen = 0, dirfd, fulllen, i;\n+\tchar *dup = NULL;\n+\n+\tfulllen = strlen(target);\n+\n+\t/* make sure prefix-skip makes sense */\n+\tif (prefix_skip) {\n+\t\tcurlen = strlen(prefix_skip);\n+\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n+\t\t\tERROR(\""WHOA there - target '%s' didn't start with prefix '%s'\"",\n+\t\t\t\ttarget, prefix_skip);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\t/*\n+\t\t * get_nextpath() expects the curlen argument to be\n+\t\t * on a  (turned into \\0) / or before it, so decrement\n+\t\t * curlen to make sure that happens\n+\t\t */\n+\t\tif (curlen)\n+\t\t\tcurlen--;\n+\t} else {\n+\t\tprefix_skip = \""/\"";\n+\t\tcurlen = 0;\n+\t}\n+\n+\t/* Make a copy of target which we can hack up, and tokenize it */\n+\tif ((dup = strdup(target)) == NULL) {\n+\t\tSYSERROR(\""Out of memory checking for symbolic link\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\tfor (i = 0; i < fulllen; i++) {\n+\t\tif (dup[i] == '/')\n+\t\t\tdup[i] = '\\0';\n+\t}\n+\n+\tdirfd = open(prefix_skip, O_RDONLY);\n+\tif (dirfd < 0)\n+\t\tgoto out;\n+\twhile (1) {\n+\t\tint newfd, saved_errno;\n+\t\tchar *nextpath;\n+\n+\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n+\t\t\tgoto out;\n+\t\tnewfd = open_if_safe(dirfd, nextpath);\n+\t\tsaved_errno = errno;\n+\t\tclose(dirfd);\n+\t\tdirfd = newfd;\n+\t\tif (newfd < 0) {\n+\t\t\terrno = saved_errno;\n+\t\t\tif (errno == ELOOP)\n+\t\t\t\tSYSERROR(\""%s in %s was a symbolic link!\"", nextpath, target);\n+\t\t\telse\n+\t\t\t\tSYSERROR(\""Error examining %s in %s\"", nextpath, target);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+out:\n+\tfree(dup);\n+\treturn dirfd;\n+}\n+\n+/*\n+ * Safely mount a path into a container, ensuring that the mount target\n+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container\n+ * uses the host's /)\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs)\n+{\n+\tint srcfd = -1, destfd, ret, saved_errno;\n+\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n+\tconst char *mntsrc = src;\n+\n+\tif (!rootfs)\n+\t\trootfs = \""\"";\n+\n+\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n+\tif (flags & MS_BIND && src && src[0] != '/') {\n+\t\tINFO(\""this is a relative bind mount\"");\n+\t\tsrcfd = open_without_symlink(src, NULL);\n+\t\tif (srcfd < 0)\n+\t\t\treturn srcfd;\n+\t\tret = snprintf(srcbuf, 50, \""/proc/self/fd/%d\"", srcfd);\n+\t\tif (ret < 0 || ret > 50) {\n+\t\t\tclose(srcfd);\n+\t\t\tERROR(\""Out of memory\"");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tmntsrc = srcbuf;\n+\t}\n+\n+\tdestfd = open_without_symlink(dest, rootfs);\n+\tif (destfd < 0) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\treturn destfd;\n+\t}\n+\n+\tret = snprintf(destbuf, 50, \""/proc/self/fd/%d\"", destfd);\n+\tif (ret < 0 || ret > 50) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\tclose(destfd);\n+\t\tERROR(\""Out of memory\"");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tret = mount(mntsrc, destbuf, fstype, flags, data);\n+\tsaved_errno = errno;\n+\tif (srcfd != -1)\n+\t\tclose(srcfd);\n+\tclose(destfd);\n+\tif (ret < 0) {\n+\t\terrno = saved_errno;\n+\t\tSYSERROR(\""Failed to mount %s onto %s\"", src, dest);\n+\t\treturn ret;\n+\t}\n+\n+\treturn 0;\n+}\n+\n /*\n  * Mount a proc under @rootfs if proc self points to a pid other than\n  * my own.  This is needed to have a known-good proc mount for setting\n@@ -1446,7 +1679,7 @@ int mount_proc_if_needed(const char *rootfs)\n \treturn 0;\n \n domount:\n-\tif (mount(\""proc\"", path, \""proc\"", 0, NULL))\n+\tif (safe_mount(\""proc\"", path, \""proc\"", 0, NULL, rootfs) < 0)\n \t\treturn -1;\n \tINFO(\""Mounted /proc in container for security transition\"");\n \treturn 1;""}<_**next**_>{""sha"": ""059026f0154b1713854c84674d12954a09469506"", ""filename"": ""src/lxc/utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.h?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -279,6 +279,8 @@ bool switch_to_ns(pid_t pid, const char *ns);\n int is_dir(const char *path);\n char *get_template_path(const char *t);\n int setproctitle(char *title);\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs);\n int mount_proc_if_needed(const char *rootfs);\n int null_stdfds(void);\n #endif /* __LXC_UTILS_H */""}<_**next**_>{""sha"": ""462d4f27882715442c3183b9db6620430b767455"", ""filename"": ""src/tests/Makefile.am"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/Makefile.am?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -55,6 +55,7 @@ bin_SCRIPTS += \\\n \tlxc-test-apparmor-mount \\\n \tlxc-test-checkpoint-restore \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tlxc-test-usernic\n@@ -82,6 +83,7 @@ EXTRA_DIST = \\\n \tlxc-test-cloneconfig \\\n \tlxc-test-createconfig \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tmay_control.c \\""}<_**next**_>{""sha"": ""37320f0dfd96b262d52bc99e314b7fe3cb026bb1"", ""filename"": ""src/tests/lxc-test-symlink"", ""status"": ""added"", ""additions"": 88, ""deletions"": 0, ""changes"": 88, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/lxc-test-symlink?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -0,0 +1,88 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+# lxc: linux Container library\n+\n+# Authors:\n+# Serge Hallyn <serge.hallyn@ubuntu.com>\n+#\n+# This is a regression test for symbolic links\n+\n+dirname=`mktemp -d`\n+fname=`mktemp`\n+fname2=`mktemp`\n+\n+lxcpath=/var/lib/lxcsym1\n+\n+cleanup() {\n+\tlxc-destroy -P $lxcpath -f -n symtest1 || true\n+\trm -f $lxcpath\n+\trmdir $dirname || true\n+\trm -f $fname || true\n+\trm -f $fname2 || true\n+}\n+\n+trap cleanup EXIT SIGHUP SIGINT SIGTERM\n+\n+testrun() {\n+\texpected=$1\n+\trun=$2\n+\tpass=\""pass\""\n+\tlxc-start -P $lxcpath -n symtest1 -l trace -o $lxcpath/log || pass=\""fail\""\n+\t[ $pass = \""pass\"" ] && lxc-wait -P $lxcpath -n symtest1 -t 10 -s RUNNING || pass=\""fail\""\n+\tif [ \""$pass\"" != \""$expected\"" ]; then\n+\t\techo \""Test $run: expected $expected but container did not.  Start log:\""\n+\t\tcat $lxcpath/log\n+\t\techo \""FAIL: Test $run: expected $expected but container did not.\""\n+\t\tfalse\n+\tfi\n+\tlxc-stop -P $lxcpath -n symtest1 -k || true\n+}\n+\n+# make lxcpath a symlink - this should NOT cause failure\n+ln -s /var/lib/lxc $lxcpath\n+\n+lxc-destroy -P $lxcpath -f -n symtest1 || true\n+lxc-create -P $lxcpath -t busybox -n symtest1\n+\n+cat >> /var/lib/lxc/symtest1/config << EOF\n+lxc.mount.entry = $dirname opt/xxx/dir none bind,create=dir\n+lxc.mount.entry = $fname opt/xxx/file none bind,create=file\n+lxc.mount.entry = $fname2 opt/xxx/file2 none bind\n+EOF\n+\n+# Regular - should succeed\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun pass 1\n+\n+# symlink - should fail\n+rm -rf /var/lib/lxc/symtest1/rootfs/opt/xxx\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx2\n+ln -s /var/lib/lxc/symtest1/rootfs/opt/xxx2 /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun fail 2\n+\n+# final final symlink - should fail\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx/dir\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2src\n+ln -s $lxcpath/symtest1/rootfs/opt/xxx/file2src $lxcpath/symtest1/rootfs/opt/xxx/file2\n+testrun fail 3\n+\n+# Ideally we'd also try a loop device, but that won't work in nested containers\n+# anyway - TODO\n+\n+# what about /proc itself\n+\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2\n+mv $lxcpath/symtest1/rootfs/proc $lxcpath/symtest1/rootfs/proc1\n+ln -s $lxcpath/symtest1/rootfs/proc1 $lxcpath/symtest1/rootfs/proc\n+testrun fail 4\n+\n+echo \""all tests passed\""""}"," static int mount_entry(const char *fsname, const char *target,
 		       const char *fstype, unsigned long mountflags,
		       const char *data, int optional, const char *rootfs)
 {
 #ifdef HAVE_STATVFS
 	struct statvfs sb;
 #endif
 
	if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {
 		if (optional) {
 			INFO(""failed to mount '%s' on '%s' (optional): %s"", fsname,
 			     target, strerror(errno));
			return 0;
		}
		else {
			SYSERROR(""failed to mount '%s' on '%s'"", fsname, target);
			return -1;
		}
	}

	if ((mountflags & MS_REMOUNT) || (mountflags & MS_BIND)) {
		DEBUG(""remounting %s on %s to respect bind or remount options"",
		      fsname ? fsname : ""(none)"", target ? target : ""(none)"");
		unsigned long rqd_flags = 0;
		if (mountflags & MS_RDONLY)
			rqd_flags |= MS_RDONLY;
#ifdef HAVE_STATVFS
		if (statvfs(fsname, &sb) == 0) {
			unsigned long required_flags = rqd_flags;
			if (sb.f_flag & MS_NOSUID)
				required_flags |= MS_NOSUID;
			if (sb.f_flag & MS_NODEV)
				required_flags |= MS_NODEV;
			if (sb.f_flag & MS_RDONLY)
				required_flags |= MS_RDONLY;
			if (sb.f_flag & MS_NOEXEC)
				required_flags |= MS_NOEXEC;
			DEBUG(""(at remount) flags for %s was %lu, required extra flags are %lu"", fsname, sb.f_flag, required_flags);
			/*
			 * If this was a bind mount request, and required_flags
			 * does not have any flags which are not already in
			 * mountflags, then skip the remount
			 */
			if (!(mountflags & MS_REMOUNT)) {
				if (!(required_flags & ~mountflags) && rqd_flags == 0) {
					DEBUG(""mountflags already was %lu, skipping remount"",
						mountflags);
					goto skipremount;
				}
			}
			mountflags |= required_flags;
		}
 #endif
 
 		if (mount(fsname, target, fstype,
			  mountflags | MS_REMOUNT, data) < 0) {
 			if (optional) {
 				INFO(""failed to mount '%s' on '%s' (optional): %s"",
 					 fsname, target, strerror(errno));
				return 0;
			}
			else {
				SYSERROR(""failed to mount '%s' on '%s'"",
					 fsname, target);
				return -1;
			}
		}
	}

#ifdef HAVE_STATVFS
skipremount:
#endif
	DEBUG(""mounted '%s' on '%s', type '%s'"", fsname, target, fstype);

	return 0;
}
"," static int mount_entry(const char *fsname, const char *target,
 		       const char *fstype, unsigned long mountflags,
		       const char *data, int optional)
 {
 #ifdef HAVE_STATVFS
 	struct statvfs sb;
 #endif
 
	if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {
 		if (optional) {
 			INFO(""failed to mount '%s' on '%s' (optional): %s"", fsname,
 			     target, strerror(errno));
			return 0;
		}
		else {
			SYSERROR(""failed to mount '%s' on '%s'"", fsname, target);
			return -1;
		}
	}

	if ((mountflags & MS_REMOUNT) || (mountflags & MS_BIND)) {
		DEBUG(""remounting %s on %s to respect bind or remount options"",
		      fsname ? fsname : ""(none)"", target ? target : ""(none)"");
		unsigned long rqd_flags = 0;
		if (mountflags & MS_RDONLY)
			rqd_flags |= MS_RDONLY;
#ifdef HAVE_STATVFS
		if (statvfs(fsname, &sb) == 0) {
			unsigned long required_flags = rqd_flags;
			if (sb.f_flag & MS_NOSUID)
				required_flags |= MS_NOSUID;
			if (sb.f_flag & MS_NODEV)
				required_flags |= MS_NODEV;
			if (sb.f_flag & MS_RDONLY)
				required_flags |= MS_RDONLY;
			if (sb.f_flag & MS_NOEXEC)
				required_flags |= MS_NOEXEC;
			DEBUG(""(at remount) flags for %s was %lu, required extra flags are %lu"", fsname, sb.f_flag, required_flags);
			/*
			 * If this was a bind mount request, and required_flags
			 * does not have any flags which are not already in
			 * mountflags, then skip the remount
			 */
			if (!(mountflags & MS_REMOUNT)) {
				if (!(required_flags & ~mountflags) && rqd_flags == 0) {
					DEBUG(""mountflags already was %lu, skipping remount"",
						mountflags);
					goto skipremount;
				}
			}
			mountflags |= required_flags;
		}
 #endif
 
 		if (mount(fsname, target, fstype,
			  mountflags | MS_REMOUNT, data)) {
 			if (optional) {
 				INFO(""failed to mount '%s' on '%s' (optional): %s"",
 					 fsname, target, strerror(errno));
				return 0;
			}
			else {
				SYSERROR(""failed to mount '%s' on '%s'"",
					 fsname, target);
				return -1;
			}
		}
	}

#ifdef HAVE_STATVFS
skipremount:
#endif
	DEBUG(""mounted '%s' on '%s', type '%s'"", fsname, target, fstype);

	return 0;
}
",C,"		       const char *data, int optional, const char *rootfs)
	if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {
			  mountflags | MS_REMOUNT, data) < 0) {
","		       const char *data, int optional)
	if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {
			  mountflags | MS_REMOUNT, data)) {
",,"@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 		 * 2.6.32...
 		 */
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/net"",                  NULL,       MS_BIND,                        NULL },
+		/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/tty"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys"",                                       ""%r/proc/sys"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sys"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/net"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/tty"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sysrq-trigger"",                             ""%r/proc/sysrq-trigger"",        NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sysrq-trigger"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 			}
 			mflags = add_required_remount_flags(source, destination,
 					default_mounts[i].flags);
-			r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);
+			r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);
 			saved_errno = errno;
 			if (r < 0 && errno == ENOENT) {
 				INFO(""Mount source or target for %s on %s doesn't exist. Skipping."", source, destination);
@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons
 		return 0;
 	}
 
-	if (mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"")) {
+	if (safe_mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"",
+				rootfs->path ? rootfs->mount : NULL)) {
 		SYSERROR(""Failed mounting tmpfs onto %s\n"", path);
 		return false;
 	}
@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)
 				return -1;
 			}
 			fclose(pathfile);
-			if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {
+			if (safe_mount(hostpath, path, 0, MS_BIND, NULL,
+						rootfs->path ? rootfs->mount : NULL) != 0) {
 				SYSERROR(""Failed bind mounting device %s from host into container"",
 					d->name);
 				return -1;
@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,
 		return -1;
 	}
 
-	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, path, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}
@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,
 		return 0;
 	}
 
-	if (mount(console->name, lxcpath, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, lxcpath, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, lxcpath);
 		return -1;
 	}
@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)
 
 static int mount_entry(const char *fsname, const char *target,
 		       const char *fstype, unsigned long mountflags,
-		       const char *data, int optional)
+		       const char *data, int optional, const char *rootfs)
 {
 #ifdef HAVE_STATVFS
 	struct statvfs sb;
 #endif
 
-	if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {
+	if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {
 		if (optional) {
 			INFO(""failed to mount '%s' on '%s' (optional): %s"", fsname,
 			     target, strerror(errno));
@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,
 #endif
 
 		if (mount(fsname, target, fstype,
-			  mountflags | MS_REMOUNT, data)) {
+			  mountflags | MS_REMOUNT, data) < 0) {
 			if (optional) {
 				INFO(""failed to mount '%s' on '%s' (optional): %s"",
 					 fsname, target, strerror(errno));
@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,
 }
 
 static inline int mount_entry_on_generic(struct mntent *mntent,
-                 const char* path)
+                 const char* path, const char *rootfs)
 {
 	unsigned long mntflags;
 	char *mntdata;
@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 	}
 
 	ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,
-			  mntflags, mntdata, optional);
+			  mntflags, mntdata, optional, rootfs);
 
 	free(mntdata);
 
@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 
 static inline int mount_entry_on_systemfs(struct mntent *mntent)
 {
-  return mount_entry_on_generic(mntent, mntent->mnt_dir);
+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);
 }
 
 static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs->mount);
 }
 
 static int mount_entry_on_relative_rootfs(struct mntent *mntent,
@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs);
 }
 
 static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,
@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)
 		fclose(pathfile);
 	}
 
-	ret = mount(path, destpath, ""none"", MS_BIND, NULL);
+	ret = safe_mount(path, destpath, ""none"", MS_BIND, NULL, conf->rootfs.mount);
 	if (ret < 0)
 		SYSERROR(""Failed to bind lxc.init.static into container"");
 	INFO(""lxc.init.static bound into container at %s"", path);",lxc,592fd47a6245508b79fe6ac819fe6d3b2c1289be,f2e4dddd71d427f9cacbab4016ffe18b0e4a4a0a,1," static int mount_entry(const char *fsname, const char *target,
 		       const char *fstype, unsigned long mountflags,
//flaw_line_below:
		       const char *data, int optional)
//fix_flaw_line_below:
//		       const char *data, int optional, const char *rootfs)
 {
 #ifdef HAVE_STATVFS
 	struct statvfs sb;
 #endif
 
//flaw_line_below:
	if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {
//fix_flaw_line_below:
//	if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {
 		if (optional) {
 			INFO(""failed to mount '%s' on '%s' (optional): %s"", fsname,
 			     target, strerror(errno));
			return 0;
		}
		else {
			SYSERROR(""failed to mount '%s' on '%s'"", fsname, target);
			return -1;
		}
	}

	if ((mountflags & MS_REMOUNT) || (mountflags & MS_BIND)) {
		DEBUG(""remounting %s on %s to respect bind or remount options"",
		      fsname ? fsname : ""(none)"", target ? target : ""(none)"");
		unsigned long rqd_flags = 0;
		if (mountflags & MS_RDONLY)
			rqd_flags |= MS_RDONLY;
#ifdef HAVE_STATVFS
		if (statvfs(fsname, &sb) == 0) {
			unsigned long required_flags = rqd_flags;
			if (sb.f_flag & MS_NOSUID)
				required_flags |= MS_NOSUID;
			if (sb.f_flag & MS_NODEV)
				required_flags |= MS_NODEV;
			if (sb.f_flag & MS_RDONLY)
				required_flags |= MS_RDONLY;
			if (sb.f_flag & MS_NOEXEC)
				required_flags |= MS_NOEXEC;
			DEBUG(""(at remount) flags for %s was %lu, required extra flags are %lu"", fsname, sb.f_flag, required_flags);
			/*
			 * If this was a bind mount request, and required_flags
			 * does not have any flags which are not already in
			 * mountflags, then skip the remount
			 */
			if (!(mountflags & MS_REMOUNT)) {
				if (!(required_flags & ~mountflags) && rqd_flags == 0) {
					DEBUG(""mountflags already was %lu, skipping remount"",
						mountflags);
					goto skipremount;
				}
			}
			mountflags |= required_flags;
		}
 #endif
 
 		if (mount(fsname, target, fstype,
//flaw_line_below:
			  mountflags | MS_REMOUNT, data)) {
//fix_flaw_line_below:
//			  mountflags | MS_REMOUNT, data) < 0) {
 			if (optional) {
 				INFO(""failed to mount '%s' on '%s' (optional): %s"",
 					 fsname, target, strerror(errno));
				return 0;
			}
			else {
				SYSERROR(""failed to mount '%s' on '%s'"",
					 fsname, target);
				return -1;
			}
		}
	}

#ifdef HAVE_STATVFS
skipremount:
#endif
	DEBUG(""mounted '%s' on '%s', type '%s'"", fsname, target, fstype);

	return 0;
}
"
2152,179888,,Local,Not required,Complete,CVE-2015-1335,https://www.cvedetails.com/cve/CVE-2015-1335/,CWE-59,Low,Complete,Complete,,2015-10-01,7.2,lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.,2019-05-31,,1,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,592fd47a6245508b79fe6ac819fe6d3b2c1289be,"CVE-2015-1335: Protect container mounts against symlinks

When a container starts up, lxc sets up the container's inital fstree
by doing a bunch of mounting, guided by the container configuration
file.  The container config is owned by the admin or user on the host,
so we do not try to guard against bad entries.  However, since the
mount target is in the container, it's possible that the container admin
could divert the mount with symbolic links.  This could bypass proper
container startup (i.e. confinement of a root-owned container by the
restrictive apparmor policy, by diverting the required write to
/proc/self/attr/current), or bypass the (path-based) apparmor policy
by diverting, say, /proc to /mnt in the container.

To prevent this,

1. do not allow mounts to paths containing symbolic links

2. do not allow bind mounts from relative paths containing symbolic
links.

Details:

Define safe_mount which ensures that the container has not inserted any
symbolic links into any mount targets for mounts to be done during
container setup.

The host's mount path may contain symbolic links.  As it is under the
control of the administrator, that's ok.  So safe_mount begins the check
for symbolic links after the rootfs->mount, by opening that directory.

It opens each directory along the path using openat() relative to the
parent directory using O_NOFOLLOW.  When the target is reached, it
mounts onto /proc/self/fd/<targetfd>.

Use safe_mount() in mount_entry(), when mounting container proc,
and when needed.  In particular, safe_mount() need not be used in
any case where:

1. the mount is done in the container's namespace
2. the mount is for the container's rootfs
3. the mount is relative to a tmpfs or proc/sysfs which we have
   just safe_mount()ed ourselves

Since we were using proc/net as a temporary placeholder for /proc/sys/net
during container startup, and proc/net is a symbolic link, use proc/tty
instead.

Update the lxc.container.conf manpage with details about the new
restrictions.

Finally, add a testcase to test some symbolic link possibilities.

Reported-by: Roman Fiedler
Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Acked-by: Stphane Graber <stgraber@ubuntu.com>",1,src/lxc/conf.c,"{""sha"": ""eb3241f795d2f3e0f1fb762516983b74e99af52f"", ""filename"": ""doc/lxc.container.conf.sgml.in"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/doc/lxc.container.conf.sgml.in?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -760,6 +760,18 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n         container. This is useful to mount /etc, /var or /home for\n         examples.\n       </para>\n+      <para>\n+\tNOTE - LXC will generally ensure that mount targets and relative\n+\tbind-mount sources are properly confined under the container\n+\troot, to avoid attacks involving over-mounting host directories\n+\tand files.  (Symbolic links in absolute mount sources are ignored)\n+\tHowever, if the container configuration first mounts a directory which\n+\tis under the control of the container user, such as /home/joe, into\n+        the container at some <filename>path</filename>, and then mounts\n+        under <filename>path</filename>, then a TOCTTOU attack would be\n+        possible where the container user modifies a symbolic link under\n+        his home directory at just the right time.\n+      </para>\n       <variablelist>\n         <varlistentry>\n           <term>""}<_**next**_>{""sha"": ""df2e6b2333bc81f94bf7583087475fd8d62605a1"", ""filename"": ""src/lxc/cgfs.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgfs.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1363,7 +1363,10 @@ static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \""%s/sys/fs/cgroup\"", root);\n-\tr = mount(\""cgroup_root\"", path, \""tmpfs\"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \""size=10240k,mode=755\"");\n+\tr = safe_mount(\""cgroup_root\"", path, \""tmpfs\"",\n+\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n+\t\t\t\""size=10240k,mode=755\"",\n+\t\t\troot);\n \tif (r < 0) {\n \t\tSYSERROR(\""could not mount tmpfs to /sys/fs/cgroup in the container\"");\n \t\treturn false;""}<_**next**_>{""sha"": ""a677c22c768eccccaa3af386c662c43dad8412cf"", ""filename"": ""src/lxc/cgmanager.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgmanager.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1477,7 +1477,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t}\n \n \t/* mount a tmpfs there so we can create subdirs */\n-\tif (mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"")) {\n+\tif (safe_mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"", root)) {\n \t\tSYSERROR(\""Failed to mount tmpfs at %s\"", cgpath);\n \t\treturn false;\n \t}\n@@ -1488,7 +1488,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t\treturn false;\n \t}\n \n-\tif (mount(dirname, cgpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(dirname, cgpath, \""none\"", MS_BIND, 0, root)) {\n \t\tSYSERROR(\""Failed to bind mount %s to %s\"", dirname, cgpath);\n \t\treturn false;\n \t}""}<_**next**_>{""sha"": ""bb4c19f82e2c806b07125cbfd9ed3220df07be38"", ""filename"": ""src/lxc/conf.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 16, ""changes"": 35, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/conf.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t * 2.6.32...\n \t\t */\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/net\"",                  NULL,       MS_BIND,                        NULL },\n+\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/tty\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys\"",                                       \""%r/proc/sys\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sys\"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/net\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/tty\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sysrq-trigger\"",                             \""%r/proc/sysrq-trigger\"",        NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sysrq-trigger\"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t\t}\n \t\t\tmflags = add_required_remount_flags(source, destination,\n \t\t\t\t\tdefault_mounts[i].flags);\n-\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n+\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n \t\t\tsaved_errno = errno;\n \t\t\tif (r < 0 && errno == ENOENT) {\n \t\t\t\tINFO(\""Mount source or target for %s on %s doesn't exist. Skipping.\"", source, destination);\n@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons\n \t\treturn 0;\n \t}\n \n-\tif (mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"")) {\n+\tif (safe_mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"",\n+\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n \t\tSYSERROR(\""Failed mounting tmpfs onto %s\\n\"", path);\n \t\treturn false;\n \t}\n@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tfclose(pathfile);\n-\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n+\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n+\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n \t\t\t\tSYSERROR(\""Failed bind mounting device %s from host into container\"",\n \t\t\t\t\td->name);\n \t\t\t\treturn -1;\n@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,\n \t\treturn -1;\n \t}\n \n-\tif (mount(console->name, path, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, path, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, path);\n \t\treturn -1;\n \t}\n@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n \t\treturn 0;\n \t}\n \n-\tif (mount(console->name, lxcpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, lxcpath, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, lxcpath);\n \t\treturn -1;\n \t}\n@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)\n \n static int mount_entry(const char *fsname, const char *target,\n \t\t       const char *fstype, unsigned long mountflags,\n-\t\t       const char *data, int optional)\n+\t\t       const char *data, int optional, const char *rootfs)\n {\n #ifdef HAVE_STATVFS\n \tstruct statvfs sb;\n #endif\n \n-\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n+\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n \t\tif (optional) {\n \t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"", fsname,\n \t\t\t     target, strerror(errno));\n@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,\n #endif\n \n \t\tif (mount(fsname, target, fstype,\n-\t\t\t  mountflags | MS_REMOUNT, data)) {\n+\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n \t\t\tif (optional) {\n \t\t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"",\n \t\t\t\t\t fsname, target, strerror(errno));\n@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,\n }\n \n static inline int mount_entry_on_generic(struct mntent *mntent,\n-                 const char* path)\n+                 const char* path, const char *rootfs)\n {\n \tunsigned long mntflags;\n \tchar *mntdata;\n@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \t}\n \n \tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n-\t\t\t  mntflags, mntdata, optional);\n+\t\t\t  mntflags, mntdata, optional, rootfs);\n \n \tfree(mntdata);\n \n@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \n static inline int mount_entry_on_systemfs(struct mntent *mntent)\n {\n-  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n }\n \n static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n }\n \n static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs);\n }\n \n static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \""none\"", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \""none\"", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\""Failed to bind lxc.init.static into container\"");\n \tINFO(\""lxc.init.static bound into container at %s\"", path);""}<_**next**_>{""sha"": ""788cbe136302bb46a559c36dc45a895f8c584574"", ""filename"": ""src/lxc/utils.c"", ""status"": ""modified"", ""additions"": 234, ""deletions"": 1, ""changes"": 235, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1404,6 +1404,239 @@ int setproctitle(char *title)\n \treturn ret;\n }\n \n+/*\n+ * @path:    a pathname where / replaced with '\\0'.\n+ * @offsetp: pointer to int showing which path segment was last seen.\n+ *           Updated on return to reflect the next segment.\n+ * @fulllen: full original path length.\n+ * Returns a pointer to the next path segment, or NULL if done.\n+ */\n+static char *get_nextpath(char *path, int *offsetp, int fulllen)\n+{\n+\tint offset = *offsetp;\n+\n+\tif (offset >= fulllen)\n+\t\treturn NULL;\n+\n+\twhile (path[offset] != '\\0' && offset < fulllen)\n+\t\toffset++;\n+\twhile (path[offset] == '\\0' && offset < fulllen)\n+\t\toffset++;\n+\n+\t*offsetp = offset;\n+\treturn (offset < fulllen) ? &path[offset] : NULL;\n+}\n+\n+/*\n+ * Check that @subdir is a subdir of @dir.  @len is the length of\n+ * @dir (to avoid having to recalculate it).\n+ */\n+static bool is_subdir(const char *subdir, const char *dir, size_t len)\n+{\n+\tsize_t subdirlen = strlen(subdir);\n+\n+\tif (subdirlen < len)\n+\t\treturn false;\n+\tif (strncmp(subdir, dir, len) != 0)\n+\t\treturn false;\n+\tif (dir[len-1] == '/')\n+\t\treturn true;\n+\tif (subdir[len] == '/' || subdirlen == len)\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+/*\n+ * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return\n+ * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.\n+ */\n+static int check_symlink(int fd)\n+{\n+\tstruct stat sb;\n+\tint ret = fstat(fd, &sb);\n+\tif (ret < 0)\n+\t\treturn -ENOENT;\n+\tif (S_ISLNK(sb.st_mode))\n+\t\treturn -ELOOP;\n+\treturn 0;\n+}\n+\n+/*\n+ * Open a file or directory, provided that it contains no symlinks.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+static int open_if_safe(int dirfd, const char *nextpath)\n+{\n+\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n+\tif (newfd >= 0) // was not a symlink, all good\n+\t\treturn newfd;\n+\n+\tif (errno == ELOOP)\n+\t\treturn newfd;\n+\n+\tif (errno == EPERM || errno == EACCES) {\n+\t\t/* we're not root (cause we got EPERM) so\n+\t\t   try opening with O_PATH */\n+\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n+\t\tif (newfd >= 0) {\n+\t\t\t/* O_PATH will return an fd for symlinks.  We know\n+\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n+\t\t\t * is now a link, then something * fishy is going on\n+\t\t\t */\n+\t\t\tint ret = check_symlink(newfd);\n+\t\t\tif (ret < 0) {\n+\t\t\t\tclose(newfd);\n+\t\t\t\tnewfd = ret;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newfd;\n+}\n+\n+/*\n+ * Open a path intending for mounting, ensuring that the final path\n+ * is inside the container's rootfs.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ *\n+ * @target: path to be opened\n+ * @prefix_skip: a part of @target in which to ignore symbolic links.  This\n+ * would be the container's rootfs.\n+ *\n+ * Return an open fd for the path, or <0 on error.\n+ */\n+static int open_without_symlink(const char *target, const char *prefix_skip)\n+{\n+\tint curlen = 0, dirfd, fulllen, i;\n+\tchar *dup = NULL;\n+\n+\tfulllen = strlen(target);\n+\n+\t/* make sure prefix-skip makes sense */\n+\tif (prefix_skip) {\n+\t\tcurlen = strlen(prefix_skip);\n+\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n+\t\t\tERROR(\""WHOA there - target '%s' didn't start with prefix '%s'\"",\n+\t\t\t\ttarget, prefix_skip);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\t/*\n+\t\t * get_nextpath() expects the curlen argument to be\n+\t\t * on a  (turned into \\0) / or before it, so decrement\n+\t\t * curlen to make sure that happens\n+\t\t */\n+\t\tif (curlen)\n+\t\t\tcurlen--;\n+\t} else {\n+\t\tprefix_skip = \""/\"";\n+\t\tcurlen = 0;\n+\t}\n+\n+\t/* Make a copy of target which we can hack up, and tokenize it */\n+\tif ((dup = strdup(target)) == NULL) {\n+\t\tSYSERROR(\""Out of memory checking for symbolic link\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\tfor (i = 0; i < fulllen; i++) {\n+\t\tif (dup[i] == '/')\n+\t\t\tdup[i] = '\\0';\n+\t}\n+\n+\tdirfd = open(prefix_skip, O_RDONLY);\n+\tif (dirfd < 0)\n+\t\tgoto out;\n+\twhile (1) {\n+\t\tint newfd, saved_errno;\n+\t\tchar *nextpath;\n+\n+\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n+\t\t\tgoto out;\n+\t\tnewfd = open_if_safe(dirfd, nextpath);\n+\t\tsaved_errno = errno;\n+\t\tclose(dirfd);\n+\t\tdirfd = newfd;\n+\t\tif (newfd < 0) {\n+\t\t\terrno = saved_errno;\n+\t\t\tif (errno == ELOOP)\n+\t\t\t\tSYSERROR(\""%s in %s was a symbolic link!\"", nextpath, target);\n+\t\t\telse\n+\t\t\t\tSYSERROR(\""Error examining %s in %s\"", nextpath, target);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+out:\n+\tfree(dup);\n+\treturn dirfd;\n+}\n+\n+/*\n+ * Safely mount a path into a container, ensuring that the mount target\n+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container\n+ * uses the host's /)\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs)\n+{\n+\tint srcfd = -1, destfd, ret, saved_errno;\n+\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n+\tconst char *mntsrc = src;\n+\n+\tif (!rootfs)\n+\t\trootfs = \""\"";\n+\n+\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n+\tif (flags & MS_BIND && src && src[0] != '/') {\n+\t\tINFO(\""this is a relative bind mount\"");\n+\t\tsrcfd = open_without_symlink(src, NULL);\n+\t\tif (srcfd < 0)\n+\t\t\treturn srcfd;\n+\t\tret = snprintf(srcbuf, 50, \""/proc/self/fd/%d\"", srcfd);\n+\t\tif (ret < 0 || ret > 50) {\n+\t\t\tclose(srcfd);\n+\t\t\tERROR(\""Out of memory\"");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tmntsrc = srcbuf;\n+\t}\n+\n+\tdestfd = open_without_symlink(dest, rootfs);\n+\tif (destfd < 0) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\treturn destfd;\n+\t}\n+\n+\tret = snprintf(destbuf, 50, \""/proc/self/fd/%d\"", destfd);\n+\tif (ret < 0 || ret > 50) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\tclose(destfd);\n+\t\tERROR(\""Out of memory\"");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tret = mount(mntsrc, destbuf, fstype, flags, data);\n+\tsaved_errno = errno;\n+\tif (srcfd != -1)\n+\t\tclose(srcfd);\n+\tclose(destfd);\n+\tif (ret < 0) {\n+\t\terrno = saved_errno;\n+\t\tSYSERROR(\""Failed to mount %s onto %s\"", src, dest);\n+\t\treturn ret;\n+\t}\n+\n+\treturn 0;\n+}\n+\n /*\n  * Mount a proc under @rootfs if proc self points to a pid other than\n  * my own.  This is needed to have a known-good proc mount for setting\n@@ -1446,7 +1679,7 @@ int mount_proc_if_needed(const char *rootfs)\n \treturn 0;\n \n domount:\n-\tif (mount(\""proc\"", path, \""proc\"", 0, NULL))\n+\tif (safe_mount(\""proc\"", path, \""proc\"", 0, NULL, rootfs) < 0)\n \t\treturn -1;\n \tINFO(\""Mounted /proc in container for security transition\"");\n \treturn 1;""}<_**next**_>{""sha"": ""059026f0154b1713854c84674d12954a09469506"", ""filename"": ""src/lxc/utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.h?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -279,6 +279,8 @@ bool switch_to_ns(pid_t pid, const char *ns);\n int is_dir(const char *path);\n char *get_template_path(const char *t);\n int setproctitle(char *title);\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs);\n int mount_proc_if_needed(const char *rootfs);\n int null_stdfds(void);\n #endif /* __LXC_UTILS_H */""}<_**next**_>{""sha"": ""462d4f27882715442c3183b9db6620430b767455"", ""filename"": ""src/tests/Makefile.am"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/Makefile.am?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -55,6 +55,7 @@ bin_SCRIPTS += \\\n \tlxc-test-apparmor-mount \\\n \tlxc-test-checkpoint-restore \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tlxc-test-usernic\n@@ -82,6 +83,7 @@ EXTRA_DIST = \\\n \tlxc-test-cloneconfig \\\n \tlxc-test-createconfig \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tmay_control.c \\""}<_**next**_>{""sha"": ""37320f0dfd96b262d52bc99e314b7fe3cb026bb1"", ""filename"": ""src/tests/lxc-test-symlink"", ""status"": ""added"", ""additions"": 88, ""deletions"": 0, ""changes"": 88, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/lxc-test-symlink?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -0,0 +1,88 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+# lxc: linux Container library\n+\n+# Authors:\n+# Serge Hallyn <serge.hallyn@ubuntu.com>\n+#\n+# This is a regression test for symbolic links\n+\n+dirname=`mktemp -d`\n+fname=`mktemp`\n+fname2=`mktemp`\n+\n+lxcpath=/var/lib/lxcsym1\n+\n+cleanup() {\n+\tlxc-destroy -P $lxcpath -f -n symtest1 || true\n+\trm -f $lxcpath\n+\trmdir $dirname || true\n+\trm -f $fname || true\n+\trm -f $fname2 || true\n+}\n+\n+trap cleanup EXIT SIGHUP SIGINT SIGTERM\n+\n+testrun() {\n+\texpected=$1\n+\trun=$2\n+\tpass=\""pass\""\n+\tlxc-start -P $lxcpath -n symtest1 -l trace -o $lxcpath/log || pass=\""fail\""\n+\t[ $pass = \""pass\"" ] && lxc-wait -P $lxcpath -n symtest1 -t 10 -s RUNNING || pass=\""fail\""\n+\tif [ \""$pass\"" != \""$expected\"" ]; then\n+\t\techo \""Test $run: expected $expected but container did not.  Start log:\""\n+\t\tcat $lxcpath/log\n+\t\techo \""FAIL: Test $run: expected $expected but container did not.\""\n+\t\tfalse\n+\tfi\n+\tlxc-stop -P $lxcpath -n symtest1 -k || true\n+}\n+\n+# make lxcpath a symlink - this should NOT cause failure\n+ln -s /var/lib/lxc $lxcpath\n+\n+lxc-destroy -P $lxcpath -f -n symtest1 || true\n+lxc-create -P $lxcpath -t busybox -n symtest1\n+\n+cat >> /var/lib/lxc/symtest1/config << EOF\n+lxc.mount.entry = $dirname opt/xxx/dir none bind,create=dir\n+lxc.mount.entry = $fname opt/xxx/file none bind,create=file\n+lxc.mount.entry = $fname2 opt/xxx/file2 none bind\n+EOF\n+\n+# Regular - should succeed\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun pass 1\n+\n+# symlink - should fail\n+rm -rf /var/lib/lxc/symtest1/rootfs/opt/xxx\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx2\n+ln -s /var/lib/lxc/symtest1/rootfs/opt/xxx2 /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun fail 2\n+\n+# final final symlink - should fail\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx/dir\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2src\n+ln -s $lxcpath/symtest1/rootfs/opt/xxx/file2src $lxcpath/symtest1/rootfs/opt/xxx/file2\n+testrun fail 3\n+\n+# Ideally we'd also try a loop device, but that won't work in nested containers\n+# anyway - TODO\n+\n+# what about /proc itself\n+\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2\n+mv $lxcpath/symtest1/rootfs/proc $lxcpath/symtest1/rootfs/proc1\n+ln -s $lxcpath/symtest1/rootfs/proc1 $lxcpath/symtest1/rootfs/proc\n+testrun fail 4\n+\n+echo \""all tests passed\""""}"," static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
					  const struct lxc_rootfs *rootfs,
					  const char *lxc_name)
{
	char *aux;
	char path[MAXPATHLEN];
	int r, ret = 0, offset;
	const char *lxcpath;

	lxcpath = lxc_global_config_value(""lxc.lxcpath"");
	if (!lxcpath) {
		ERROR(""Out of memory"");
		return -1;
	}

	/* if rootfs->path is a blockdev path, allow container fstab to
	 * use $lxcpath/CN/rootfs as the target prefix */
	r = snprintf(path, MAXPATHLEN, ""%s/%s/rootfs"", lxcpath, lxc_name);
	if (r < 0 || r >= MAXPATHLEN)
		goto skipvarlib;

	aux = strstr(mntent->mnt_dir, path);
	if (aux) {
		offset = strlen(path);
		goto skipabs;
	}

skipvarlib:
	aux = strstr(mntent->mnt_dir, rootfs->path);
	if (!aux) {
		WARN(""ignoring mount point '%s'"", mntent->mnt_dir);
		return ret;
	}
	offset = strlen(rootfs->path);

skipabs:

	r = snprintf(path, MAXPATHLEN, ""%s/%s"", rootfs->mount,
		 aux + offset);
	if (r < 0 || r >= MAXPATHLEN) {
		WARN(""pathnme too long for '%s'"", mntent->mnt_dir);
 		return -1;
 	}
 
	return mount_entry_on_generic(mntent, path, rootfs->mount);
 }
"," static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
					  const struct lxc_rootfs *rootfs,
					  const char *lxc_name)
{
	char *aux;
	char path[MAXPATHLEN];
	int r, ret = 0, offset;
	const char *lxcpath;

	lxcpath = lxc_global_config_value(""lxc.lxcpath"");
	if (!lxcpath) {
		ERROR(""Out of memory"");
		return -1;
	}

	/* if rootfs->path is a blockdev path, allow container fstab to
	 * use $lxcpath/CN/rootfs as the target prefix */
	r = snprintf(path, MAXPATHLEN, ""%s/%s/rootfs"", lxcpath, lxc_name);
	if (r < 0 || r >= MAXPATHLEN)
		goto skipvarlib;

	aux = strstr(mntent->mnt_dir, path);
	if (aux) {
		offset = strlen(path);
		goto skipabs;
	}

skipvarlib:
	aux = strstr(mntent->mnt_dir, rootfs->path);
	if (!aux) {
		WARN(""ignoring mount point '%s'"", mntent->mnt_dir);
		return ret;
	}
	offset = strlen(rootfs->path);

skipabs:

	r = snprintf(path, MAXPATHLEN, ""%s/%s"", rootfs->mount,
		 aux + offset);
	if (r < 0 || r >= MAXPATHLEN) {
		WARN(""pathnme too long for '%s'"", mntent->mnt_dir);
 		return -1;
 	}
 
	return mount_entry_on_generic(mntent, path);
 }
",C,"	return mount_entry_on_generic(mntent, path, rootfs->mount);
","	return mount_entry_on_generic(mntent, path);
",,"@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 		 * 2.6.32...
 		 */
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/net"",                  NULL,       MS_BIND,                        NULL },
+		/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/tty"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys"",                                       ""%r/proc/sys"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sys"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/net"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/tty"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sysrq-trigger"",                             ""%r/proc/sysrq-trigger"",        NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sysrq-trigger"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 			}
 			mflags = add_required_remount_flags(source, destination,
 					default_mounts[i].flags);
-			r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);
+			r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);
 			saved_errno = errno;
 			if (r < 0 && errno == ENOENT) {
 				INFO(""Mount source or target for %s on %s doesn't exist. Skipping."", source, destination);
@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons
 		return 0;
 	}
 
-	if (mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"")) {
+	if (safe_mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"",
+				rootfs->path ? rootfs->mount : NULL)) {
 		SYSERROR(""Failed mounting tmpfs onto %s\n"", path);
 		return false;
 	}
@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)
 				return -1;
 			}
 			fclose(pathfile);
-			if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {
+			if (safe_mount(hostpath, path, 0, MS_BIND, NULL,
+						rootfs->path ? rootfs->mount : NULL) != 0) {
 				SYSERROR(""Failed bind mounting device %s from host into container"",
 					d->name);
 				return -1;
@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,
 		return -1;
 	}
 
-	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, path, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}
@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,
 		return 0;
 	}
 
-	if (mount(console->name, lxcpath, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, lxcpath, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, lxcpath);
 		return -1;
 	}
@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)
 
 static int mount_entry(const char *fsname, const char *target,
 		       const char *fstype, unsigned long mountflags,
-		       const char *data, int optional)
+		       const char *data, int optional, const char *rootfs)
 {
 #ifdef HAVE_STATVFS
 	struct statvfs sb;
 #endif
 
-	if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {
+	if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {
 		if (optional) {
 			INFO(""failed to mount '%s' on '%s' (optional): %s"", fsname,
 			     target, strerror(errno));
@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,
 #endif
 
 		if (mount(fsname, target, fstype,
-			  mountflags | MS_REMOUNT, data)) {
+			  mountflags | MS_REMOUNT, data) < 0) {
 			if (optional) {
 				INFO(""failed to mount '%s' on '%s' (optional): %s"",
 					 fsname, target, strerror(errno));
@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,
 }
 
 static inline int mount_entry_on_generic(struct mntent *mntent,
-                 const char* path)
+                 const char* path, const char *rootfs)
 {
 	unsigned long mntflags;
 	char *mntdata;
@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 	}
 
 	ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,
-			  mntflags, mntdata, optional);
+			  mntflags, mntdata, optional, rootfs);
 
 	free(mntdata);
 
@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 
 static inline int mount_entry_on_systemfs(struct mntent *mntent)
 {
-  return mount_entry_on_generic(mntent, mntent->mnt_dir);
+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);
 }
 
 static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs->mount);
 }
 
 static int mount_entry_on_relative_rootfs(struct mntent *mntent,
@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs);
 }
 
 static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,
@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)
 		fclose(pathfile);
 	}
 
-	ret = mount(path, destpath, ""none"", MS_BIND, NULL);
+	ret = safe_mount(path, destpath, ""none"", MS_BIND, NULL, conf->rootfs.mount);
 	if (ret < 0)
 		SYSERROR(""Failed to bind lxc.init.static into container"");
 	INFO(""lxc.init.static bound into container at %s"", path);",lxc,592fd47a6245508b79fe6ac819fe6d3b2c1289be,f2e4dddd71d427f9cacbab4016ffe18b0e4a4a0a,1," static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
					  const struct lxc_rootfs *rootfs,
					  const char *lxc_name)
{
	char *aux;
	char path[MAXPATHLEN];
	int r, ret = 0, offset;
	const char *lxcpath;

	lxcpath = lxc_global_config_value(""lxc.lxcpath"");
	if (!lxcpath) {
		ERROR(""Out of memory"");
		return -1;
	}

	/* if rootfs->path is a blockdev path, allow container fstab to
	 * use $lxcpath/CN/rootfs as the target prefix */
	r = snprintf(path, MAXPATHLEN, ""%s/%s/rootfs"", lxcpath, lxc_name);
	if (r < 0 || r >= MAXPATHLEN)
		goto skipvarlib;

	aux = strstr(mntent->mnt_dir, path);
	if (aux) {
		offset = strlen(path);
		goto skipabs;
	}

skipvarlib:
	aux = strstr(mntent->mnt_dir, rootfs->path);
	if (!aux) {
		WARN(""ignoring mount point '%s'"", mntent->mnt_dir);
		return ret;
	}
	offset = strlen(rootfs->path);

skipabs:

	r = snprintf(path, MAXPATHLEN, ""%s/%s"", rootfs->mount,
		 aux + offset);
	if (r < 0 || r >= MAXPATHLEN) {
		WARN(""pathnme too long for '%s'"", mntent->mnt_dir);
 		return -1;
 	}
 
//flaw_line_below:
	return mount_entry_on_generic(mntent, path);
//fix_flaw_line_below:
//	return mount_entry_on_generic(mntent, path, rootfs->mount);
 }
"
2153,179889,,Local,Not required,Complete,CVE-2015-1335,https://www.cvedetails.com/cve/CVE-2015-1335/,CWE-59,Low,Complete,Complete,,2015-10-01,7.2,lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.,2019-05-31,,2,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,592fd47a6245508b79fe6ac819fe6d3b2c1289be,"CVE-2015-1335: Protect container mounts against symlinks

When a container starts up, lxc sets up the container's inital fstree
by doing a bunch of mounting, guided by the container configuration
file.  The container config is owned by the admin or user on the host,
so we do not try to guard against bad entries.  However, since the
mount target is in the container, it's possible that the container admin
could divert the mount with symbolic links.  This could bypass proper
container startup (i.e. confinement of a root-owned container by the
restrictive apparmor policy, by diverting the required write to
/proc/self/attr/current), or bypass the (path-based) apparmor policy
by diverting, say, /proc to /mnt in the container.

To prevent this,

1. do not allow mounts to paths containing symbolic links

2. do not allow bind mounts from relative paths containing symbolic
links.

Details:

Define safe_mount which ensures that the container has not inserted any
symbolic links into any mount targets for mounts to be done during
container setup.

The host's mount path may contain symbolic links.  As it is under the
control of the administrator, that's ok.  So safe_mount begins the check
for symbolic links after the rootfs->mount, by opening that directory.

It opens each directory along the path using openat() relative to the
parent directory using O_NOFOLLOW.  When the target is reached, it
mounts onto /proc/self/fd/<targetfd>.

Use safe_mount() in mount_entry(), when mounting container proc,
and when needed.  In particular, safe_mount() need not be used in
any case where:

1. the mount is done in the container's namespace
2. the mount is for the container's rootfs
3. the mount is relative to a tmpfs or proc/sysfs which we have
   just safe_mount()ed ourselves

Since we were using proc/net as a temporary placeholder for /proc/sys/net
during container startup, and proc/net is a symbolic link, use proc/tty
instead.

Update the lxc.container.conf manpage with details about the new
restrictions.

Finally, add a testcase to test some symbolic link possibilities.

Reported-by: Roman Fiedler
Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Acked-by: Stphane Graber <stgraber@ubuntu.com>",2,src/lxc/conf.c,"{""sha"": ""eb3241f795d2f3e0f1fb762516983b74e99af52f"", ""filename"": ""doc/lxc.container.conf.sgml.in"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/doc/lxc.container.conf.sgml.in?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -760,6 +760,18 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n         container. This is useful to mount /etc, /var or /home for\n         examples.\n       </para>\n+      <para>\n+\tNOTE - LXC will generally ensure that mount targets and relative\n+\tbind-mount sources are properly confined under the container\n+\troot, to avoid attacks involving over-mounting host directories\n+\tand files.  (Symbolic links in absolute mount sources are ignored)\n+\tHowever, if the container configuration first mounts a directory which\n+\tis under the control of the container user, such as /home/joe, into\n+        the container at some <filename>path</filename>, and then mounts\n+        under <filename>path</filename>, then a TOCTTOU attack would be\n+        possible where the container user modifies a symbolic link under\n+        his home directory at just the right time.\n+      </para>\n       <variablelist>\n         <varlistentry>\n           <term>""}<_**next**_>{""sha"": ""df2e6b2333bc81f94bf7583087475fd8d62605a1"", ""filename"": ""src/lxc/cgfs.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgfs.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1363,7 +1363,10 @@ static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \""%s/sys/fs/cgroup\"", root);\n-\tr = mount(\""cgroup_root\"", path, \""tmpfs\"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \""size=10240k,mode=755\"");\n+\tr = safe_mount(\""cgroup_root\"", path, \""tmpfs\"",\n+\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n+\t\t\t\""size=10240k,mode=755\"",\n+\t\t\troot);\n \tif (r < 0) {\n \t\tSYSERROR(\""could not mount tmpfs to /sys/fs/cgroup in the container\"");\n \t\treturn false;""}<_**next**_>{""sha"": ""a677c22c768eccccaa3af386c662c43dad8412cf"", ""filename"": ""src/lxc/cgmanager.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgmanager.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1477,7 +1477,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t}\n \n \t/* mount a tmpfs there so we can create subdirs */\n-\tif (mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"")) {\n+\tif (safe_mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"", root)) {\n \t\tSYSERROR(\""Failed to mount tmpfs at %s\"", cgpath);\n \t\treturn false;\n \t}\n@@ -1488,7 +1488,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t\treturn false;\n \t}\n \n-\tif (mount(dirname, cgpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(dirname, cgpath, \""none\"", MS_BIND, 0, root)) {\n \t\tSYSERROR(\""Failed to bind mount %s to %s\"", dirname, cgpath);\n \t\treturn false;\n \t}""}<_**next**_>{""sha"": ""bb4c19f82e2c806b07125cbfd9ed3220df07be38"", ""filename"": ""src/lxc/conf.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 16, ""changes"": 35, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/conf.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t * 2.6.32...\n \t\t */\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/net\"",                  NULL,       MS_BIND,                        NULL },\n+\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/tty\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys\"",                                       \""%r/proc/sys\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sys\"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/net\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/tty\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sysrq-trigger\"",                             \""%r/proc/sysrq-trigger\"",        NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sysrq-trigger\"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t\t}\n \t\t\tmflags = add_required_remount_flags(source, destination,\n \t\t\t\t\tdefault_mounts[i].flags);\n-\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n+\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n \t\t\tsaved_errno = errno;\n \t\t\tif (r < 0 && errno == ENOENT) {\n \t\t\t\tINFO(\""Mount source or target for %s on %s doesn't exist. Skipping.\"", source, destination);\n@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons\n \t\treturn 0;\n \t}\n \n-\tif (mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"")) {\n+\tif (safe_mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"",\n+\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n \t\tSYSERROR(\""Failed mounting tmpfs onto %s\\n\"", path);\n \t\treturn false;\n \t}\n@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tfclose(pathfile);\n-\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n+\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n+\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n \t\t\t\tSYSERROR(\""Failed bind mounting device %s from host into container\"",\n \t\t\t\t\td->name);\n \t\t\t\treturn -1;\n@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,\n \t\treturn -1;\n \t}\n \n-\tif (mount(console->name, path, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, path, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, path);\n \t\treturn -1;\n \t}\n@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n \t\treturn 0;\n \t}\n \n-\tif (mount(console->name, lxcpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, lxcpath, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, lxcpath);\n \t\treturn -1;\n \t}\n@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)\n \n static int mount_entry(const char *fsname, const char *target,\n \t\t       const char *fstype, unsigned long mountflags,\n-\t\t       const char *data, int optional)\n+\t\t       const char *data, int optional, const char *rootfs)\n {\n #ifdef HAVE_STATVFS\n \tstruct statvfs sb;\n #endif\n \n-\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n+\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n \t\tif (optional) {\n \t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"", fsname,\n \t\t\t     target, strerror(errno));\n@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,\n #endif\n \n \t\tif (mount(fsname, target, fstype,\n-\t\t\t  mountflags | MS_REMOUNT, data)) {\n+\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n \t\t\tif (optional) {\n \t\t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"",\n \t\t\t\t\t fsname, target, strerror(errno));\n@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,\n }\n \n static inline int mount_entry_on_generic(struct mntent *mntent,\n-                 const char* path)\n+                 const char* path, const char *rootfs)\n {\n \tunsigned long mntflags;\n \tchar *mntdata;\n@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \t}\n \n \tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n-\t\t\t  mntflags, mntdata, optional);\n+\t\t\t  mntflags, mntdata, optional, rootfs);\n \n \tfree(mntdata);\n \n@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \n static inline int mount_entry_on_systemfs(struct mntent *mntent)\n {\n-  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n }\n \n static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n }\n \n static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs);\n }\n \n static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \""none\"", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \""none\"", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\""Failed to bind lxc.init.static into container\"");\n \tINFO(\""lxc.init.static bound into container at %s\"", path);""}<_**next**_>{""sha"": ""788cbe136302bb46a559c36dc45a895f8c584574"", ""filename"": ""src/lxc/utils.c"", ""status"": ""modified"", ""additions"": 234, ""deletions"": 1, ""changes"": 235, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1404,6 +1404,239 @@ int setproctitle(char *title)\n \treturn ret;\n }\n \n+/*\n+ * @path:    a pathname where / replaced with '\\0'.\n+ * @offsetp: pointer to int showing which path segment was last seen.\n+ *           Updated on return to reflect the next segment.\n+ * @fulllen: full original path length.\n+ * Returns a pointer to the next path segment, or NULL if done.\n+ */\n+static char *get_nextpath(char *path, int *offsetp, int fulllen)\n+{\n+\tint offset = *offsetp;\n+\n+\tif (offset >= fulllen)\n+\t\treturn NULL;\n+\n+\twhile (path[offset] != '\\0' && offset < fulllen)\n+\t\toffset++;\n+\twhile (path[offset] == '\\0' && offset < fulllen)\n+\t\toffset++;\n+\n+\t*offsetp = offset;\n+\treturn (offset < fulllen) ? &path[offset] : NULL;\n+}\n+\n+/*\n+ * Check that @subdir is a subdir of @dir.  @len is the length of\n+ * @dir (to avoid having to recalculate it).\n+ */\n+static bool is_subdir(const char *subdir, const char *dir, size_t len)\n+{\n+\tsize_t subdirlen = strlen(subdir);\n+\n+\tif (subdirlen < len)\n+\t\treturn false;\n+\tif (strncmp(subdir, dir, len) != 0)\n+\t\treturn false;\n+\tif (dir[len-1] == '/')\n+\t\treturn true;\n+\tif (subdir[len] == '/' || subdirlen == len)\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+/*\n+ * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return\n+ * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.\n+ */\n+static int check_symlink(int fd)\n+{\n+\tstruct stat sb;\n+\tint ret = fstat(fd, &sb);\n+\tif (ret < 0)\n+\t\treturn -ENOENT;\n+\tif (S_ISLNK(sb.st_mode))\n+\t\treturn -ELOOP;\n+\treturn 0;\n+}\n+\n+/*\n+ * Open a file or directory, provided that it contains no symlinks.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+static int open_if_safe(int dirfd, const char *nextpath)\n+{\n+\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n+\tif (newfd >= 0) // was not a symlink, all good\n+\t\treturn newfd;\n+\n+\tif (errno == ELOOP)\n+\t\treturn newfd;\n+\n+\tif (errno == EPERM || errno == EACCES) {\n+\t\t/* we're not root (cause we got EPERM) so\n+\t\t   try opening with O_PATH */\n+\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n+\t\tif (newfd >= 0) {\n+\t\t\t/* O_PATH will return an fd for symlinks.  We know\n+\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n+\t\t\t * is now a link, then something * fishy is going on\n+\t\t\t */\n+\t\t\tint ret = check_symlink(newfd);\n+\t\t\tif (ret < 0) {\n+\t\t\t\tclose(newfd);\n+\t\t\t\tnewfd = ret;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newfd;\n+}\n+\n+/*\n+ * Open a path intending for mounting, ensuring that the final path\n+ * is inside the container's rootfs.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ *\n+ * @target: path to be opened\n+ * @prefix_skip: a part of @target in which to ignore symbolic links.  This\n+ * would be the container's rootfs.\n+ *\n+ * Return an open fd for the path, or <0 on error.\n+ */\n+static int open_without_symlink(const char *target, const char *prefix_skip)\n+{\n+\tint curlen = 0, dirfd, fulllen, i;\n+\tchar *dup = NULL;\n+\n+\tfulllen = strlen(target);\n+\n+\t/* make sure prefix-skip makes sense */\n+\tif (prefix_skip) {\n+\t\tcurlen = strlen(prefix_skip);\n+\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n+\t\t\tERROR(\""WHOA there - target '%s' didn't start with prefix '%s'\"",\n+\t\t\t\ttarget, prefix_skip);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\t/*\n+\t\t * get_nextpath() expects the curlen argument to be\n+\t\t * on a  (turned into \\0) / or before it, so decrement\n+\t\t * curlen to make sure that happens\n+\t\t */\n+\t\tif (curlen)\n+\t\t\tcurlen--;\n+\t} else {\n+\t\tprefix_skip = \""/\"";\n+\t\tcurlen = 0;\n+\t}\n+\n+\t/* Make a copy of target which we can hack up, and tokenize it */\n+\tif ((dup = strdup(target)) == NULL) {\n+\t\tSYSERROR(\""Out of memory checking for symbolic link\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\tfor (i = 0; i < fulllen; i++) {\n+\t\tif (dup[i] == '/')\n+\t\t\tdup[i] = '\\0';\n+\t}\n+\n+\tdirfd = open(prefix_skip, O_RDONLY);\n+\tif (dirfd < 0)\n+\t\tgoto out;\n+\twhile (1) {\n+\t\tint newfd, saved_errno;\n+\t\tchar *nextpath;\n+\n+\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n+\t\t\tgoto out;\n+\t\tnewfd = open_if_safe(dirfd, nextpath);\n+\t\tsaved_errno = errno;\n+\t\tclose(dirfd);\n+\t\tdirfd = newfd;\n+\t\tif (newfd < 0) {\n+\t\t\terrno = saved_errno;\n+\t\t\tif (errno == ELOOP)\n+\t\t\t\tSYSERROR(\""%s in %s was a symbolic link!\"", nextpath, target);\n+\t\t\telse\n+\t\t\t\tSYSERROR(\""Error examining %s in %s\"", nextpath, target);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+out:\n+\tfree(dup);\n+\treturn dirfd;\n+}\n+\n+/*\n+ * Safely mount a path into a container, ensuring that the mount target\n+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container\n+ * uses the host's /)\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs)\n+{\n+\tint srcfd = -1, destfd, ret, saved_errno;\n+\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n+\tconst char *mntsrc = src;\n+\n+\tif (!rootfs)\n+\t\trootfs = \""\"";\n+\n+\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n+\tif (flags & MS_BIND && src && src[0] != '/') {\n+\t\tINFO(\""this is a relative bind mount\"");\n+\t\tsrcfd = open_without_symlink(src, NULL);\n+\t\tif (srcfd < 0)\n+\t\t\treturn srcfd;\n+\t\tret = snprintf(srcbuf, 50, \""/proc/self/fd/%d\"", srcfd);\n+\t\tif (ret < 0 || ret > 50) {\n+\t\t\tclose(srcfd);\n+\t\t\tERROR(\""Out of memory\"");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tmntsrc = srcbuf;\n+\t}\n+\n+\tdestfd = open_without_symlink(dest, rootfs);\n+\tif (destfd < 0) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\treturn destfd;\n+\t}\n+\n+\tret = snprintf(destbuf, 50, \""/proc/self/fd/%d\"", destfd);\n+\tif (ret < 0 || ret > 50) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\tclose(destfd);\n+\t\tERROR(\""Out of memory\"");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tret = mount(mntsrc, destbuf, fstype, flags, data);\n+\tsaved_errno = errno;\n+\tif (srcfd != -1)\n+\t\tclose(srcfd);\n+\tclose(destfd);\n+\tif (ret < 0) {\n+\t\terrno = saved_errno;\n+\t\tSYSERROR(\""Failed to mount %s onto %s\"", src, dest);\n+\t\treturn ret;\n+\t}\n+\n+\treturn 0;\n+}\n+\n /*\n  * Mount a proc under @rootfs if proc self points to a pid other than\n  * my own.  This is needed to have a known-good proc mount for setting\n@@ -1446,7 +1679,7 @@ int mount_proc_if_needed(const char *rootfs)\n \treturn 0;\n \n domount:\n-\tif (mount(\""proc\"", path, \""proc\"", 0, NULL))\n+\tif (safe_mount(\""proc\"", path, \""proc\"", 0, NULL, rootfs) < 0)\n \t\treturn -1;\n \tINFO(\""Mounted /proc in container for security transition\"");\n \treturn 1;""}<_**next**_>{""sha"": ""059026f0154b1713854c84674d12954a09469506"", ""filename"": ""src/lxc/utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.h?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -279,6 +279,8 @@ bool switch_to_ns(pid_t pid, const char *ns);\n int is_dir(const char *path);\n char *get_template_path(const char *t);\n int setproctitle(char *title);\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs);\n int mount_proc_if_needed(const char *rootfs);\n int null_stdfds(void);\n #endif /* __LXC_UTILS_H */""}<_**next**_>{""sha"": ""462d4f27882715442c3183b9db6620430b767455"", ""filename"": ""src/tests/Makefile.am"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/Makefile.am?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -55,6 +55,7 @@ bin_SCRIPTS += \\\n \tlxc-test-apparmor-mount \\\n \tlxc-test-checkpoint-restore \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tlxc-test-usernic\n@@ -82,6 +83,7 @@ EXTRA_DIST = \\\n \tlxc-test-cloneconfig \\\n \tlxc-test-createconfig \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tmay_control.c \\""}<_**next**_>{""sha"": ""37320f0dfd96b262d52bc99e314b7fe3cb026bb1"", ""filename"": ""src/tests/lxc-test-symlink"", ""status"": ""added"", ""additions"": 88, ""deletions"": 0, ""changes"": 88, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/lxc-test-symlink?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -0,0 +1,88 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+# lxc: linux Container library\n+\n+# Authors:\n+# Serge Hallyn <serge.hallyn@ubuntu.com>\n+#\n+# This is a regression test for symbolic links\n+\n+dirname=`mktemp -d`\n+fname=`mktemp`\n+fname2=`mktemp`\n+\n+lxcpath=/var/lib/lxcsym1\n+\n+cleanup() {\n+\tlxc-destroy -P $lxcpath -f -n symtest1 || true\n+\trm -f $lxcpath\n+\trmdir $dirname || true\n+\trm -f $fname || true\n+\trm -f $fname2 || true\n+}\n+\n+trap cleanup EXIT SIGHUP SIGINT SIGTERM\n+\n+testrun() {\n+\texpected=$1\n+\trun=$2\n+\tpass=\""pass\""\n+\tlxc-start -P $lxcpath -n symtest1 -l trace -o $lxcpath/log || pass=\""fail\""\n+\t[ $pass = \""pass\"" ] && lxc-wait -P $lxcpath -n symtest1 -t 10 -s RUNNING || pass=\""fail\""\n+\tif [ \""$pass\"" != \""$expected\"" ]; then\n+\t\techo \""Test $run: expected $expected but container did not.  Start log:\""\n+\t\tcat $lxcpath/log\n+\t\techo \""FAIL: Test $run: expected $expected but container did not.\""\n+\t\tfalse\n+\tfi\n+\tlxc-stop -P $lxcpath -n symtest1 -k || true\n+}\n+\n+# make lxcpath a symlink - this should NOT cause failure\n+ln -s /var/lib/lxc $lxcpath\n+\n+lxc-destroy -P $lxcpath -f -n symtest1 || true\n+lxc-create -P $lxcpath -t busybox -n symtest1\n+\n+cat >> /var/lib/lxc/symtest1/config << EOF\n+lxc.mount.entry = $dirname opt/xxx/dir none bind,create=dir\n+lxc.mount.entry = $fname opt/xxx/file none bind,create=file\n+lxc.mount.entry = $fname2 opt/xxx/file2 none bind\n+EOF\n+\n+# Regular - should succeed\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun pass 1\n+\n+# symlink - should fail\n+rm -rf /var/lib/lxc/symtest1/rootfs/opt/xxx\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx2\n+ln -s /var/lib/lxc/symtest1/rootfs/opt/xxx2 /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun fail 2\n+\n+# final final symlink - should fail\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx/dir\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2src\n+ln -s $lxcpath/symtest1/rootfs/opt/xxx/file2src $lxcpath/symtest1/rootfs/opt/xxx/file2\n+testrun fail 3\n+\n+# Ideally we'd also try a loop device, but that won't work in nested containers\n+# anyway - TODO\n+\n+# what about /proc itself\n+\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2\n+mv $lxcpath/symtest1/rootfs/proc $lxcpath/symtest1/rootfs/proc1\n+ln -s $lxcpath/symtest1/rootfs/proc1 $lxcpath/symtest1/rootfs/proc\n+testrun fail 4\n+\n+echo \""all tests passed\""""}"," static inline int mount_entry_on_generic(struct mntent *mntent,
                 const char* path, const char *rootfs)
 {
 	unsigned long mntflags;
 	char *mntdata;
	int ret;
	bool optional = hasmntopt(mntent, ""optional"") != NULL;

	ret = mount_entry_create_dir_file(mntent, path);

	if (ret < 0)
		return optional ? 0 : -1;

	cull_mntent_opt(mntent);

	if (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {
		free(mntdata);
		return -1;
 	}
 
 	ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,
			  mntflags, mntdata, optional, rootfs);
 
 	free(mntdata);
 
	return ret;
}
"," static inline int mount_entry_on_generic(struct mntent *mntent,
                 const char* path)
 {
 	unsigned long mntflags;
 	char *mntdata;
	int ret;
	bool optional = hasmntopt(mntent, ""optional"") != NULL;

	ret = mount_entry_create_dir_file(mntent, path);

	if (ret < 0)
		return optional ? 0 : -1;

	cull_mntent_opt(mntent);

	if (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {
		free(mntdata);
		return -1;
 	}
 
 	ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,
			  mntflags, mntdata, optional);
 
 	free(mntdata);
 
	return ret;
}
",C,"                 const char* path, const char *rootfs)
			  mntflags, mntdata, optional, rootfs);
","                 const char* path)
			  mntflags, mntdata, optional);
",,"@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 		 * 2.6.32...
 		 */
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/net"",                  NULL,       MS_BIND,                        NULL },
+		/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/tty"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys"",                                       ""%r/proc/sys"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sys"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/net"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/tty"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sysrq-trigger"",                             ""%r/proc/sysrq-trigger"",        NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sysrq-trigger"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 			}
 			mflags = add_required_remount_flags(source, destination,
 					default_mounts[i].flags);
-			r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);
+			r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);
 			saved_errno = errno;
 			if (r < 0 && errno == ENOENT) {
 				INFO(""Mount source or target for %s on %s doesn't exist. Skipping."", source, destination);
@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons
 		return 0;
 	}
 
-	if (mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"")) {
+	if (safe_mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"",
+				rootfs->path ? rootfs->mount : NULL)) {
 		SYSERROR(""Failed mounting tmpfs onto %s\n"", path);
 		return false;
 	}
@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)
 				return -1;
 			}
 			fclose(pathfile);
-			if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {
+			if (safe_mount(hostpath, path, 0, MS_BIND, NULL,
+						rootfs->path ? rootfs->mount : NULL) != 0) {
 				SYSERROR(""Failed bind mounting device %s from host into container"",
 					d->name);
 				return -1;
@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,
 		return -1;
 	}
 
-	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, path, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}
@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,
 		return 0;
 	}
 
-	if (mount(console->name, lxcpath, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, lxcpath, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, lxcpath);
 		return -1;
 	}
@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)
 
 static int mount_entry(const char *fsname, const char *target,
 		       const char *fstype, unsigned long mountflags,
-		       const char *data, int optional)
+		       const char *data, int optional, const char *rootfs)
 {
 #ifdef HAVE_STATVFS
 	struct statvfs sb;
 #endif
 
-	if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {
+	if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {
 		if (optional) {
 			INFO(""failed to mount '%s' on '%s' (optional): %s"", fsname,
 			     target, strerror(errno));
@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,
 #endif
 
 		if (mount(fsname, target, fstype,
-			  mountflags | MS_REMOUNT, data)) {
+			  mountflags | MS_REMOUNT, data) < 0) {
 			if (optional) {
 				INFO(""failed to mount '%s' on '%s' (optional): %s"",
 					 fsname, target, strerror(errno));
@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,
 }
 
 static inline int mount_entry_on_generic(struct mntent *mntent,
-                 const char* path)
+                 const char* path, const char *rootfs)
 {
 	unsigned long mntflags;
 	char *mntdata;
@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 	}
 
 	ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,
-			  mntflags, mntdata, optional);
+			  mntflags, mntdata, optional, rootfs);
 
 	free(mntdata);
 
@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 
 static inline int mount_entry_on_systemfs(struct mntent *mntent)
 {
-  return mount_entry_on_generic(mntent, mntent->mnt_dir);
+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);
 }
 
 static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs->mount);
 }
 
 static int mount_entry_on_relative_rootfs(struct mntent *mntent,
@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs);
 }
 
 static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,
@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)
 		fclose(pathfile);
 	}
 
-	ret = mount(path, destpath, ""none"", MS_BIND, NULL);
+	ret = safe_mount(path, destpath, ""none"", MS_BIND, NULL, conf->rootfs.mount);
 	if (ret < 0)
 		SYSERROR(""Failed to bind lxc.init.static into container"");
 	INFO(""lxc.init.static bound into container at %s"", path);",lxc,592fd47a6245508b79fe6ac819fe6d3b2c1289be,f2e4dddd71d427f9cacbab4016ffe18b0e4a4a0a,1," static inline int mount_entry_on_generic(struct mntent *mntent,
//flaw_line_below:
                 const char* path)
//fix_flaw_line_below:
//                 const char* path, const char *rootfs)
 {
 	unsigned long mntflags;
 	char *mntdata;
	int ret;
	bool optional = hasmntopt(mntent, ""optional"") != NULL;

	ret = mount_entry_create_dir_file(mntent, path);

	if (ret < 0)
		return optional ? 0 : -1;

	cull_mntent_opt(mntent);

	if (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {
		free(mntdata);
		return -1;
 	}
 
 	ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,
//flaw_line_below:
			  mntflags, mntdata, optional);
//fix_flaw_line_below:
//			  mntflags, mntdata, optional, rootfs);
 
 	free(mntdata);
 
	return ret;
}
"
2154,179890,,Local,Not required,Complete,CVE-2015-1335,https://www.cvedetails.com/cve/CVE-2015-1335/,CWE-59,Low,Complete,Complete,,2015-10-01,7.2,lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.,2019-05-31,,1,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,592fd47a6245508b79fe6ac819fe6d3b2c1289be,"CVE-2015-1335: Protect container mounts against symlinks

When a container starts up, lxc sets up the container's inital fstree
by doing a bunch of mounting, guided by the container configuration
file.  The container config is owned by the admin or user on the host,
so we do not try to guard against bad entries.  However, since the
mount target is in the container, it's possible that the container admin
could divert the mount with symbolic links.  This could bypass proper
container startup (i.e. confinement of a root-owned container by the
restrictive apparmor policy, by diverting the required write to
/proc/self/attr/current), or bypass the (path-based) apparmor policy
by diverting, say, /proc to /mnt in the container.

To prevent this,

1. do not allow mounts to paths containing symbolic links

2. do not allow bind mounts from relative paths containing symbolic
links.

Details:

Define safe_mount which ensures that the container has not inserted any
symbolic links into any mount targets for mounts to be done during
container setup.

The host's mount path may contain symbolic links.  As it is under the
control of the administrator, that's ok.  So safe_mount begins the check
for symbolic links after the rootfs->mount, by opening that directory.

It opens each directory along the path using openat() relative to the
parent directory using O_NOFOLLOW.  When the target is reached, it
mounts onto /proc/self/fd/<targetfd>.

Use safe_mount() in mount_entry(), when mounting container proc,
and when needed.  In particular, safe_mount() need not be used in
any case where:

1. the mount is done in the container's namespace
2. the mount is for the container's rootfs
3. the mount is relative to a tmpfs or proc/sysfs which we have
   just safe_mount()ed ourselves

Since we were using proc/net as a temporary placeholder for /proc/sys/net
during container startup, and proc/net is a symbolic link, use proc/tty
instead.

Update the lxc.container.conf manpage with details about the new
restrictions.

Finally, add a testcase to test some symbolic link possibilities.

Reported-by: Roman Fiedler
Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Acked-by: Stphane Graber <stgraber@ubuntu.com>",1,src/lxc/conf.c,"{""sha"": ""eb3241f795d2f3e0f1fb762516983b74e99af52f"", ""filename"": ""doc/lxc.container.conf.sgml.in"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/doc/lxc.container.conf.sgml.in?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -760,6 +760,18 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n         container. This is useful to mount /etc, /var or /home for\n         examples.\n       </para>\n+      <para>\n+\tNOTE - LXC will generally ensure that mount targets and relative\n+\tbind-mount sources are properly confined under the container\n+\troot, to avoid attacks involving over-mounting host directories\n+\tand files.  (Symbolic links in absolute mount sources are ignored)\n+\tHowever, if the container configuration first mounts a directory which\n+\tis under the control of the container user, such as /home/joe, into\n+        the container at some <filename>path</filename>, and then mounts\n+        under <filename>path</filename>, then a TOCTTOU attack would be\n+        possible where the container user modifies a symbolic link under\n+        his home directory at just the right time.\n+      </para>\n       <variablelist>\n         <varlistentry>\n           <term>""}<_**next**_>{""sha"": ""df2e6b2333bc81f94bf7583087475fd8d62605a1"", ""filename"": ""src/lxc/cgfs.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgfs.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1363,7 +1363,10 @@ static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \""%s/sys/fs/cgroup\"", root);\n-\tr = mount(\""cgroup_root\"", path, \""tmpfs\"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \""size=10240k,mode=755\"");\n+\tr = safe_mount(\""cgroup_root\"", path, \""tmpfs\"",\n+\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n+\t\t\t\""size=10240k,mode=755\"",\n+\t\t\troot);\n \tif (r < 0) {\n \t\tSYSERROR(\""could not mount tmpfs to /sys/fs/cgroup in the container\"");\n \t\treturn false;""}<_**next**_>{""sha"": ""a677c22c768eccccaa3af386c662c43dad8412cf"", ""filename"": ""src/lxc/cgmanager.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgmanager.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1477,7 +1477,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t}\n \n \t/* mount a tmpfs there so we can create subdirs */\n-\tif (mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"")) {\n+\tif (safe_mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"", root)) {\n \t\tSYSERROR(\""Failed to mount tmpfs at %s\"", cgpath);\n \t\treturn false;\n \t}\n@@ -1488,7 +1488,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t\treturn false;\n \t}\n \n-\tif (mount(dirname, cgpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(dirname, cgpath, \""none\"", MS_BIND, 0, root)) {\n \t\tSYSERROR(\""Failed to bind mount %s to %s\"", dirname, cgpath);\n \t\treturn false;\n \t}""}<_**next**_>{""sha"": ""bb4c19f82e2c806b07125cbfd9ed3220df07be38"", ""filename"": ""src/lxc/conf.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 16, ""changes"": 35, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/conf.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t * 2.6.32...\n \t\t */\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/net\"",                  NULL,       MS_BIND,                        NULL },\n+\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/tty\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys\"",                                       \""%r/proc/sys\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sys\"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/net\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/tty\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sysrq-trigger\"",                             \""%r/proc/sysrq-trigger\"",        NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sysrq-trigger\"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t\t}\n \t\t\tmflags = add_required_remount_flags(source, destination,\n \t\t\t\t\tdefault_mounts[i].flags);\n-\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n+\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n \t\t\tsaved_errno = errno;\n \t\t\tif (r < 0 && errno == ENOENT) {\n \t\t\t\tINFO(\""Mount source or target for %s on %s doesn't exist. Skipping.\"", source, destination);\n@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons\n \t\treturn 0;\n \t}\n \n-\tif (mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"")) {\n+\tif (safe_mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"",\n+\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n \t\tSYSERROR(\""Failed mounting tmpfs onto %s\\n\"", path);\n \t\treturn false;\n \t}\n@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tfclose(pathfile);\n-\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n+\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n+\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n \t\t\t\tSYSERROR(\""Failed bind mounting device %s from host into container\"",\n \t\t\t\t\td->name);\n \t\t\t\treturn -1;\n@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,\n \t\treturn -1;\n \t}\n \n-\tif (mount(console->name, path, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, path, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, path);\n \t\treturn -1;\n \t}\n@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n \t\treturn 0;\n \t}\n \n-\tif (mount(console->name, lxcpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, lxcpath, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, lxcpath);\n \t\treturn -1;\n \t}\n@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)\n \n static int mount_entry(const char *fsname, const char *target,\n \t\t       const char *fstype, unsigned long mountflags,\n-\t\t       const char *data, int optional)\n+\t\t       const char *data, int optional, const char *rootfs)\n {\n #ifdef HAVE_STATVFS\n \tstruct statvfs sb;\n #endif\n \n-\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n+\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n \t\tif (optional) {\n \t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"", fsname,\n \t\t\t     target, strerror(errno));\n@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,\n #endif\n \n \t\tif (mount(fsname, target, fstype,\n-\t\t\t  mountflags | MS_REMOUNT, data)) {\n+\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n \t\t\tif (optional) {\n \t\t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"",\n \t\t\t\t\t fsname, target, strerror(errno));\n@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,\n }\n \n static inline int mount_entry_on_generic(struct mntent *mntent,\n-                 const char* path)\n+                 const char* path, const char *rootfs)\n {\n \tunsigned long mntflags;\n \tchar *mntdata;\n@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \t}\n \n \tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n-\t\t\t  mntflags, mntdata, optional);\n+\t\t\t  mntflags, mntdata, optional, rootfs);\n \n \tfree(mntdata);\n \n@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \n static inline int mount_entry_on_systemfs(struct mntent *mntent)\n {\n-  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n }\n \n static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n }\n \n static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs);\n }\n \n static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \""none\"", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \""none\"", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\""Failed to bind lxc.init.static into container\"");\n \tINFO(\""lxc.init.static bound into container at %s\"", path);""}<_**next**_>{""sha"": ""788cbe136302bb46a559c36dc45a895f8c584574"", ""filename"": ""src/lxc/utils.c"", ""status"": ""modified"", ""additions"": 234, ""deletions"": 1, ""changes"": 235, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1404,6 +1404,239 @@ int setproctitle(char *title)\n \treturn ret;\n }\n \n+/*\n+ * @path:    a pathname where / replaced with '\\0'.\n+ * @offsetp: pointer to int showing which path segment was last seen.\n+ *           Updated on return to reflect the next segment.\n+ * @fulllen: full original path length.\n+ * Returns a pointer to the next path segment, or NULL if done.\n+ */\n+static char *get_nextpath(char *path, int *offsetp, int fulllen)\n+{\n+\tint offset = *offsetp;\n+\n+\tif (offset >= fulllen)\n+\t\treturn NULL;\n+\n+\twhile (path[offset] != '\\0' && offset < fulllen)\n+\t\toffset++;\n+\twhile (path[offset] == '\\0' && offset < fulllen)\n+\t\toffset++;\n+\n+\t*offsetp = offset;\n+\treturn (offset < fulllen) ? &path[offset] : NULL;\n+}\n+\n+/*\n+ * Check that @subdir is a subdir of @dir.  @len is the length of\n+ * @dir (to avoid having to recalculate it).\n+ */\n+static bool is_subdir(const char *subdir, const char *dir, size_t len)\n+{\n+\tsize_t subdirlen = strlen(subdir);\n+\n+\tif (subdirlen < len)\n+\t\treturn false;\n+\tif (strncmp(subdir, dir, len) != 0)\n+\t\treturn false;\n+\tif (dir[len-1] == '/')\n+\t\treturn true;\n+\tif (subdir[len] == '/' || subdirlen == len)\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+/*\n+ * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return\n+ * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.\n+ */\n+static int check_symlink(int fd)\n+{\n+\tstruct stat sb;\n+\tint ret = fstat(fd, &sb);\n+\tif (ret < 0)\n+\t\treturn -ENOENT;\n+\tif (S_ISLNK(sb.st_mode))\n+\t\treturn -ELOOP;\n+\treturn 0;\n+}\n+\n+/*\n+ * Open a file or directory, provided that it contains no symlinks.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+static int open_if_safe(int dirfd, const char *nextpath)\n+{\n+\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n+\tif (newfd >= 0) // was not a symlink, all good\n+\t\treturn newfd;\n+\n+\tif (errno == ELOOP)\n+\t\treturn newfd;\n+\n+\tif (errno == EPERM || errno == EACCES) {\n+\t\t/* we're not root (cause we got EPERM) so\n+\t\t   try opening with O_PATH */\n+\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n+\t\tif (newfd >= 0) {\n+\t\t\t/* O_PATH will return an fd for symlinks.  We know\n+\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n+\t\t\t * is now a link, then something * fishy is going on\n+\t\t\t */\n+\t\t\tint ret = check_symlink(newfd);\n+\t\t\tif (ret < 0) {\n+\t\t\t\tclose(newfd);\n+\t\t\t\tnewfd = ret;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newfd;\n+}\n+\n+/*\n+ * Open a path intending for mounting, ensuring that the final path\n+ * is inside the container's rootfs.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ *\n+ * @target: path to be opened\n+ * @prefix_skip: a part of @target in which to ignore symbolic links.  This\n+ * would be the container's rootfs.\n+ *\n+ * Return an open fd for the path, or <0 on error.\n+ */\n+static int open_without_symlink(const char *target, const char *prefix_skip)\n+{\n+\tint curlen = 0, dirfd, fulllen, i;\n+\tchar *dup = NULL;\n+\n+\tfulllen = strlen(target);\n+\n+\t/* make sure prefix-skip makes sense */\n+\tif (prefix_skip) {\n+\t\tcurlen = strlen(prefix_skip);\n+\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n+\t\t\tERROR(\""WHOA there - target '%s' didn't start with prefix '%s'\"",\n+\t\t\t\ttarget, prefix_skip);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\t/*\n+\t\t * get_nextpath() expects the curlen argument to be\n+\t\t * on a  (turned into \\0) / or before it, so decrement\n+\t\t * curlen to make sure that happens\n+\t\t */\n+\t\tif (curlen)\n+\t\t\tcurlen--;\n+\t} else {\n+\t\tprefix_skip = \""/\"";\n+\t\tcurlen = 0;\n+\t}\n+\n+\t/* Make a copy of target which we can hack up, and tokenize it */\n+\tif ((dup = strdup(target)) == NULL) {\n+\t\tSYSERROR(\""Out of memory checking for symbolic link\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\tfor (i = 0; i < fulllen; i++) {\n+\t\tif (dup[i] == '/')\n+\t\t\tdup[i] = '\\0';\n+\t}\n+\n+\tdirfd = open(prefix_skip, O_RDONLY);\n+\tif (dirfd < 0)\n+\t\tgoto out;\n+\twhile (1) {\n+\t\tint newfd, saved_errno;\n+\t\tchar *nextpath;\n+\n+\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n+\t\t\tgoto out;\n+\t\tnewfd = open_if_safe(dirfd, nextpath);\n+\t\tsaved_errno = errno;\n+\t\tclose(dirfd);\n+\t\tdirfd = newfd;\n+\t\tif (newfd < 0) {\n+\t\t\terrno = saved_errno;\n+\t\t\tif (errno == ELOOP)\n+\t\t\t\tSYSERROR(\""%s in %s was a symbolic link!\"", nextpath, target);\n+\t\t\telse\n+\t\t\t\tSYSERROR(\""Error examining %s in %s\"", nextpath, target);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+out:\n+\tfree(dup);\n+\treturn dirfd;\n+}\n+\n+/*\n+ * Safely mount a path into a container, ensuring that the mount target\n+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container\n+ * uses the host's /)\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs)\n+{\n+\tint srcfd = -1, destfd, ret, saved_errno;\n+\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n+\tconst char *mntsrc = src;\n+\n+\tif (!rootfs)\n+\t\trootfs = \""\"";\n+\n+\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n+\tif (flags & MS_BIND && src && src[0] != '/') {\n+\t\tINFO(\""this is a relative bind mount\"");\n+\t\tsrcfd = open_without_symlink(src, NULL);\n+\t\tif (srcfd < 0)\n+\t\t\treturn srcfd;\n+\t\tret = snprintf(srcbuf, 50, \""/proc/self/fd/%d\"", srcfd);\n+\t\tif (ret < 0 || ret > 50) {\n+\t\t\tclose(srcfd);\n+\t\t\tERROR(\""Out of memory\"");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tmntsrc = srcbuf;\n+\t}\n+\n+\tdestfd = open_without_symlink(dest, rootfs);\n+\tif (destfd < 0) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\treturn destfd;\n+\t}\n+\n+\tret = snprintf(destbuf, 50, \""/proc/self/fd/%d\"", destfd);\n+\tif (ret < 0 || ret > 50) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\tclose(destfd);\n+\t\tERROR(\""Out of memory\"");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tret = mount(mntsrc, destbuf, fstype, flags, data);\n+\tsaved_errno = errno;\n+\tif (srcfd != -1)\n+\t\tclose(srcfd);\n+\tclose(destfd);\n+\tif (ret < 0) {\n+\t\terrno = saved_errno;\n+\t\tSYSERROR(\""Failed to mount %s onto %s\"", src, dest);\n+\t\treturn ret;\n+\t}\n+\n+\treturn 0;\n+}\n+\n /*\n  * Mount a proc under @rootfs if proc self points to a pid other than\n  * my own.  This is needed to have a known-good proc mount for setting\n@@ -1446,7 +1679,7 @@ int mount_proc_if_needed(const char *rootfs)\n \treturn 0;\n \n domount:\n-\tif (mount(\""proc\"", path, \""proc\"", 0, NULL))\n+\tif (safe_mount(\""proc\"", path, \""proc\"", 0, NULL, rootfs) < 0)\n \t\treturn -1;\n \tINFO(\""Mounted /proc in container for security transition\"");\n \treturn 1;""}<_**next**_>{""sha"": ""059026f0154b1713854c84674d12954a09469506"", ""filename"": ""src/lxc/utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.h?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -279,6 +279,8 @@ bool switch_to_ns(pid_t pid, const char *ns);\n int is_dir(const char *path);\n char *get_template_path(const char *t);\n int setproctitle(char *title);\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs);\n int mount_proc_if_needed(const char *rootfs);\n int null_stdfds(void);\n #endif /* __LXC_UTILS_H */""}<_**next**_>{""sha"": ""462d4f27882715442c3183b9db6620430b767455"", ""filename"": ""src/tests/Makefile.am"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/Makefile.am?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -55,6 +55,7 @@ bin_SCRIPTS += \\\n \tlxc-test-apparmor-mount \\\n \tlxc-test-checkpoint-restore \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tlxc-test-usernic\n@@ -82,6 +83,7 @@ EXTRA_DIST = \\\n \tlxc-test-cloneconfig \\\n \tlxc-test-createconfig \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tmay_control.c \\""}<_**next**_>{""sha"": ""37320f0dfd96b262d52bc99e314b7fe3cb026bb1"", ""filename"": ""src/tests/lxc-test-symlink"", ""status"": ""added"", ""additions"": 88, ""deletions"": 0, ""changes"": 88, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/lxc-test-symlink?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -0,0 +1,88 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+# lxc: linux Container library\n+\n+# Authors:\n+# Serge Hallyn <serge.hallyn@ubuntu.com>\n+#\n+# This is a regression test for symbolic links\n+\n+dirname=`mktemp -d`\n+fname=`mktemp`\n+fname2=`mktemp`\n+\n+lxcpath=/var/lib/lxcsym1\n+\n+cleanup() {\n+\tlxc-destroy -P $lxcpath -f -n symtest1 || true\n+\trm -f $lxcpath\n+\trmdir $dirname || true\n+\trm -f $fname || true\n+\trm -f $fname2 || true\n+}\n+\n+trap cleanup EXIT SIGHUP SIGINT SIGTERM\n+\n+testrun() {\n+\texpected=$1\n+\trun=$2\n+\tpass=\""pass\""\n+\tlxc-start -P $lxcpath -n symtest1 -l trace -o $lxcpath/log || pass=\""fail\""\n+\t[ $pass = \""pass\"" ] && lxc-wait -P $lxcpath -n symtest1 -t 10 -s RUNNING || pass=\""fail\""\n+\tif [ \""$pass\"" != \""$expected\"" ]; then\n+\t\techo \""Test $run: expected $expected but container did not.  Start log:\""\n+\t\tcat $lxcpath/log\n+\t\techo \""FAIL: Test $run: expected $expected but container did not.\""\n+\t\tfalse\n+\tfi\n+\tlxc-stop -P $lxcpath -n symtest1 -k || true\n+}\n+\n+# make lxcpath a symlink - this should NOT cause failure\n+ln -s /var/lib/lxc $lxcpath\n+\n+lxc-destroy -P $lxcpath -f -n symtest1 || true\n+lxc-create -P $lxcpath -t busybox -n symtest1\n+\n+cat >> /var/lib/lxc/symtest1/config << EOF\n+lxc.mount.entry = $dirname opt/xxx/dir none bind,create=dir\n+lxc.mount.entry = $fname opt/xxx/file none bind,create=file\n+lxc.mount.entry = $fname2 opt/xxx/file2 none bind\n+EOF\n+\n+# Regular - should succeed\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun pass 1\n+\n+# symlink - should fail\n+rm -rf /var/lib/lxc/symtest1/rootfs/opt/xxx\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx2\n+ln -s /var/lib/lxc/symtest1/rootfs/opt/xxx2 /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun fail 2\n+\n+# final final symlink - should fail\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx/dir\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2src\n+ln -s $lxcpath/symtest1/rootfs/opt/xxx/file2src $lxcpath/symtest1/rootfs/opt/xxx/file2\n+testrun fail 3\n+\n+# Ideally we'd also try a loop device, but that won't work in nested containers\n+# anyway - TODO\n+\n+# what about /proc itself\n+\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2\n+mv $lxcpath/symtest1/rootfs/proc $lxcpath/symtest1/rootfs/proc1\n+ln -s $lxcpath/symtest1/rootfs/proc1 $lxcpath/symtest1/rootfs/proc\n+testrun fail 4\n+\n+echo \""all tests passed\""""}"," static int mount_entry_on_relative_rootfs(struct mntent *mntent,
					  const char *rootfs)
{
	char path[MAXPATHLEN];
	int ret;

	/* relative to root mount point */
	ret = snprintf(path, sizeof(path), ""%s/%s"", rootfs, mntent->mnt_dir);
	if (ret >= sizeof(path)) {
		ERROR(""path name too long"");
 		return -1;
 	}
 
	return mount_entry_on_generic(mntent, path, rootfs);
 }
"," static int mount_entry_on_relative_rootfs(struct mntent *mntent,
					  const char *rootfs)
{
	char path[MAXPATHLEN];
	int ret;

	/* relative to root mount point */
	ret = snprintf(path, sizeof(path), ""%s/%s"", rootfs, mntent->mnt_dir);
	if (ret >= sizeof(path)) {
		ERROR(""path name too long"");
 		return -1;
 	}
 
	return mount_entry_on_generic(mntent, path);
 }
",C,"	return mount_entry_on_generic(mntent, path, rootfs);
","	return mount_entry_on_generic(mntent, path);
",,"@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 		 * 2.6.32...
 		 */
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/net"",                  NULL,       MS_BIND,                        NULL },
+		/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/tty"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys"",                                       ""%r/proc/sys"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sys"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/net"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/tty"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sysrq-trigger"",                             ""%r/proc/sysrq-trigger"",        NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sysrq-trigger"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 			}
 			mflags = add_required_remount_flags(source, destination,
 					default_mounts[i].flags);
-			r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);
+			r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);
 			saved_errno = errno;
 			if (r < 0 && errno == ENOENT) {
 				INFO(""Mount source or target for %s on %s doesn't exist. Skipping."", source, destination);
@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons
 		return 0;
 	}
 
-	if (mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"")) {
+	if (safe_mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"",
+				rootfs->path ? rootfs->mount : NULL)) {
 		SYSERROR(""Failed mounting tmpfs onto %s\n"", path);
 		return false;
 	}
@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)
 				return -1;
 			}
 			fclose(pathfile);
-			if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {
+			if (safe_mount(hostpath, path, 0, MS_BIND, NULL,
+						rootfs->path ? rootfs->mount : NULL) != 0) {
 				SYSERROR(""Failed bind mounting device %s from host into container"",
 					d->name);
 				return -1;
@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,
 		return -1;
 	}
 
-	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, path, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}
@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,
 		return 0;
 	}
 
-	if (mount(console->name, lxcpath, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, lxcpath, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, lxcpath);
 		return -1;
 	}
@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)
 
 static int mount_entry(const char *fsname, const char *target,
 		       const char *fstype, unsigned long mountflags,
-		       const char *data, int optional)
+		       const char *data, int optional, const char *rootfs)
 {
 #ifdef HAVE_STATVFS
 	struct statvfs sb;
 #endif
 
-	if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {
+	if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {
 		if (optional) {
 			INFO(""failed to mount '%s' on '%s' (optional): %s"", fsname,
 			     target, strerror(errno));
@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,
 #endif
 
 		if (mount(fsname, target, fstype,
-			  mountflags | MS_REMOUNT, data)) {
+			  mountflags | MS_REMOUNT, data) < 0) {
 			if (optional) {
 				INFO(""failed to mount '%s' on '%s' (optional): %s"",
 					 fsname, target, strerror(errno));
@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,
 }
 
 static inline int mount_entry_on_generic(struct mntent *mntent,
-                 const char* path)
+                 const char* path, const char *rootfs)
 {
 	unsigned long mntflags;
 	char *mntdata;
@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 	}
 
 	ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,
-			  mntflags, mntdata, optional);
+			  mntflags, mntdata, optional, rootfs);
 
 	free(mntdata);
 
@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 
 static inline int mount_entry_on_systemfs(struct mntent *mntent)
 {
-  return mount_entry_on_generic(mntent, mntent->mnt_dir);
+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);
 }
 
 static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs->mount);
 }
 
 static int mount_entry_on_relative_rootfs(struct mntent *mntent,
@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs);
 }
 
 static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,
@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)
 		fclose(pathfile);
 	}
 
-	ret = mount(path, destpath, ""none"", MS_BIND, NULL);
+	ret = safe_mount(path, destpath, ""none"", MS_BIND, NULL, conf->rootfs.mount);
 	if (ret < 0)
 		SYSERROR(""Failed to bind lxc.init.static into container"");
 	INFO(""lxc.init.static bound into container at %s"", path);",lxc,592fd47a6245508b79fe6ac819fe6d3b2c1289be,f2e4dddd71d427f9cacbab4016ffe18b0e4a4a0a,1," static int mount_entry_on_relative_rootfs(struct mntent *mntent,
					  const char *rootfs)
{
	char path[MAXPATHLEN];
	int ret;

	/* relative to root mount point */
	ret = snprintf(path, sizeof(path), ""%s/%s"", rootfs, mntent->mnt_dir);
	if (ret >= sizeof(path)) {
		ERROR(""path name too long"");
 		return -1;
 	}
 
//flaw_line_below:
	return mount_entry_on_generic(mntent, path);
//fix_flaw_line_below:
//	return mount_entry_on_generic(mntent, path, rootfs);
 }
"
2155,179891,,Local,Not required,Complete,CVE-2015-1335,https://www.cvedetails.com/cve/CVE-2015-1335/,CWE-59,Low,Complete,Complete,,2015-10-01,7.2,lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.,2019-05-31,,1,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,592fd47a6245508b79fe6ac819fe6d3b2c1289be,"CVE-2015-1335: Protect container mounts against symlinks

When a container starts up, lxc sets up the container's inital fstree
by doing a bunch of mounting, guided by the container configuration
file.  The container config is owned by the admin or user on the host,
so we do not try to guard against bad entries.  However, since the
mount target is in the container, it's possible that the container admin
could divert the mount with symbolic links.  This could bypass proper
container startup (i.e. confinement of a root-owned container by the
restrictive apparmor policy, by diverting the required write to
/proc/self/attr/current), or bypass the (path-based) apparmor policy
by diverting, say, /proc to /mnt in the container.

To prevent this,

1. do not allow mounts to paths containing symbolic links

2. do not allow bind mounts from relative paths containing symbolic
links.

Details:

Define safe_mount which ensures that the container has not inserted any
symbolic links into any mount targets for mounts to be done during
container setup.

The host's mount path may contain symbolic links.  As it is under the
control of the administrator, that's ok.  So safe_mount begins the check
for symbolic links after the rootfs->mount, by opening that directory.

It opens each directory along the path using openat() relative to the
parent directory using O_NOFOLLOW.  When the target is reached, it
mounts onto /proc/self/fd/<targetfd>.

Use safe_mount() in mount_entry(), when mounting container proc,
and when needed.  In particular, safe_mount() need not be used in
any case where:

1. the mount is done in the container's namespace
2. the mount is for the container's rootfs
3. the mount is relative to a tmpfs or proc/sysfs which we have
   just safe_mount()ed ourselves

Since we were using proc/net as a temporary placeholder for /proc/sys/net
during container startup, and proc/net is a symbolic link, use proc/tty
instead.

Update the lxc.container.conf manpage with details about the new
restrictions.

Finally, add a testcase to test some symbolic link possibilities.

Reported-by: Roman Fiedler
Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Acked-by: Stphane Graber <stgraber@ubuntu.com>",1,src/lxc/conf.c,"{""sha"": ""eb3241f795d2f3e0f1fb762516983b74e99af52f"", ""filename"": ""doc/lxc.container.conf.sgml.in"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/doc/lxc.container.conf.sgml.in?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -760,6 +760,18 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n         container. This is useful to mount /etc, /var or /home for\n         examples.\n       </para>\n+      <para>\n+\tNOTE - LXC will generally ensure that mount targets and relative\n+\tbind-mount sources are properly confined under the container\n+\troot, to avoid attacks involving over-mounting host directories\n+\tand files.  (Symbolic links in absolute mount sources are ignored)\n+\tHowever, if the container configuration first mounts a directory which\n+\tis under the control of the container user, such as /home/joe, into\n+        the container at some <filename>path</filename>, and then mounts\n+        under <filename>path</filename>, then a TOCTTOU attack would be\n+        possible where the container user modifies a symbolic link under\n+        his home directory at just the right time.\n+      </para>\n       <variablelist>\n         <varlistentry>\n           <term>""}<_**next**_>{""sha"": ""df2e6b2333bc81f94bf7583087475fd8d62605a1"", ""filename"": ""src/lxc/cgfs.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgfs.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1363,7 +1363,10 @@ static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \""%s/sys/fs/cgroup\"", root);\n-\tr = mount(\""cgroup_root\"", path, \""tmpfs\"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \""size=10240k,mode=755\"");\n+\tr = safe_mount(\""cgroup_root\"", path, \""tmpfs\"",\n+\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n+\t\t\t\""size=10240k,mode=755\"",\n+\t\t\troot);\n \tif (r < 0) {\n \t\tSYSERROR(\""could not mount tmpfs to /sys/fs/cgroup in the container\"");\n \t\treturn false;""}<_**next**_>{""sha"": ""a677c22c768eccccaa3af386c662c43dad8412cf"", ""filename"": ""src/lxc/cgmanager.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgmanager.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1477,7 +1477,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t}\n \n \t/* mount a tmpfs there so we can create subdirs */\n-\tif (mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"")) {\n+\tif (safe_mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"", root)) {\n \t\tSYSERROR(\""Failed to mount tmpfs at %s\"", cgpath);\n \t\treturn false;\n \t}\n@@ -1488,7 +1488,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t\treturn false;\n \t}\n \n-\tif (mount(dirname, cgpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(dirname, cgpath, \""none\"", MS_BIND, 0, root)) {\n \t\tSYSERROR(\""Failed to bind mount %s to %s\"", dirname, cgpath);\n \t\treturn false;\n \t}""}<_**next**_>{""sha"": ""bb4c19f82e2c806b07125cbfd9ed3220df07be38"", ""filename"": ""src/lxc/conf.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 16, ""changes"": 35, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/conf.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t * 2.6.32...\n \t\t */\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/net\"",                  NULL,       MS_BIND,                        NULL },\n+\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/tty\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys\"",                                       \""%r/proc/sys\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sys\"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/net\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/tty\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sysrq-trigger\"",                             \""%r/proc/sysrq-trigger\"",        NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sysrq-trigger\"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t\t}\n \t\t\tmflags = add_required_remount_flags(source, destination,\n \t\t\t\t\tdefault_mounts[i].flags);\n-\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n+\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n \t\t\tsaved_errno = errno;\n \t\t\tif (r < 0 && errno == ENOENT) {\n \t\t\t\tINFO(\""Mount source or target for %s on %s doesn't exist. Skipping.\"", source, destination);\n@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons\n \t\treturn 0;\n \t}\n \n-\tif (mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"")) {\n+\tif (safe_mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"",\n+\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n \t\tSYSERROR(\""Failed mounting tmpfs onto %s\\n\"", path);\n \t\treturn false;\n \t}\n@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tfclose(pathfile);\n-\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n+\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n+\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n \t\t\t\tSYSERROR(\""Failed bind mounting device %s from host into container\"",\n \t\t\t\t\td->name);\n \t\t\t\treturn -1;\n@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,\n \t\treturn -1;\n \t}\n \n-\tif (mount(console->name, path, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, path, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, path);\n \t\treturn -1;\n \t}\n@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n \t\treturn 0;\n \t}\n \n-\tif (mount(console->name, lxcpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, lxcpath, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, lxcpath);\n \t\treturn -1;\n \t}\n@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)\n \n static int mount_entry(const char *fsname, const char *target,\n \t\t       const char *fstype, unsigned long mountflags,\n-\t\t       const char *data, int optional)\n+\t\t       const char *data, int optional, const char *rootfs)\n {\n #ifdef HAVE_STATVFS\n \tstruct statvfs sb;\n #endif\n \n-\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n+\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n \t\tif (optional) {\n \t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"", fsname,\n \t\t\t     target, strerror(errno));\n@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,\n #endif\n \n \t\tif (mount(fsname, target, fstype,\n-\t\t\t  mountflags | MS_REMOUNT, data)) {\n+\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n \t\t\tif (optional) {\n \t\t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"",\n \t\t\t\t\t fsname, target, strerror(errno));\n@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,\n }\n \n static inline int mount_entry_on_generic(struct mntent *mntent,\n-                 const char* path)\n+                 const char* path, const char *rootfs)\n {\n \tunsigned long mntflags;\n \tchar *mntdata;\n@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \t}\n \n \tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n-\t\t\t  mntflags, mntdata, optional);\n+\t\t\t  mntflags, mntdata, optional, rootfs);\n \n \tfree(mntdata);\n \n@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \n static inline int mount_entry_on_systemfs(struct mntent *mntent)\n {\n-  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n }\n \n static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n }\n \n static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs);\n }\n \n static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \""none\"", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \""none\"", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\""Failed to bind lxc.init.static into container\"");\n \tINFO(\""lxc.init.static bound into container at %s\"", path);""}<_**next**_>{""sha"": ""788cbe136302bb46a559c36dc45a895f8c584574"", ""filename"": ""src/lxc/utils.c"", ""status"": ""modified"", ""additions"": 234, ""deletions"": 1, ""changes"": 235, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1404,6 +1404,239 @@ int setproctitle(char *title)\n \treturn ret;\n }\n \n+/*\n+ * @path:    a pathname where / replaced with '\\0'.\n+ * @offsetp: pointer to int showing which path segment was last seen.\n+ *           Updated on return to reflect the next segment.\n+ * @fulllen: full original path length.\n+ * Returns a pointer to the next path segment, or NULL if done.\n+ */\n+static char *get_nextpath(char *path, int *offsetp, int fulllen)\n+{\n+\tint offset = *offsetp;\n+\n+\tif (offset >= fulllen)\n+\t\treturn NULL;\n+\n+\twhile (path[offset] != '\\0' && offset < fulllen)\n+\t\toffset++;\n+\twhile (path[offset] == '\\0' && offset < fulllen)\n+\t\toffset++;\n+\n+\t*offsetp = offset;\n+\treturn (offset < fulllen) ? &path[offset] : NULL;\n+}\n+\n+/*\n+ * Check that @subdir is a subdir of @dir.  @len is the length of\n+ * @dir (to avoid having to recalculate it).\n+ */\n+static bool is_subdir(const char *subdir, const char *dir, size_t len)\n+{\n+\tsize_t subdirlen = strlen(subdir);\n+\n+\tif (subdirlen < len)\n+\t\treturn false;\n+\tif (strncmp(subdir, dir, len) != 0)\n+\t\treturn false;\n+\tif (dir[len-1] == '/')\n+\t\treturn true;\n+\tif (subdir[len] == '/' || subdirlen == len)\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+/*\n+ * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return\n+ * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.\n+ */\n+static int check_symlink(int fd)\n+{\n+\tstruct stat sb;\n+\tint ret = fstat(fd, &sb);\n+\tif (ret < 0)\n+\t\treturn -ENOENT;\n+\tif (S_ISLNK(sb.st_mode))\n+\t\treturn -ELOOP;\n+\treturn 0;\n+}\n+\n+/*\n+ * Open a file or directory, provided that it contains no symlinks.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+static int open_if_safe(int dirfd, const char *nextpath)\n+{\n+\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n+\tif (newfd >= 0) // was not a symlink, all good\n+\t\treturn newfd;\n+\n+\tif (errno == ELOOP)\n+\t\treturn newfd;\n+\n+\tif (errno == EPERM || errno == EACCES) {\n+\t\t/* we're not root (cause we got EPERM) so\n+\t\t   try opening with O_PATH */\n+\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n+\t\tif (newfd >= 0) {\n+\t\t\t/* O_PATH will return an fd for symlinks.  We know\n+\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n+\t\t\t * is now a link, then something * fishy is going on\n+\t\t\t */\n+\t\t\tint ret = check_symlink(newfd);\n+\t\t\tif (ret < 0) {\n+\t\t\t\tclose(newfd);\n+\t\t\t\tnewfd = ret;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newfd;\n+}\n+\n+/*\n+ * Open a path intending for mounting, ensuring that the final path\n+ * is inside the container's rootfs.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ *\n+ * @target: path to be opened\n+ * @prefix_skip: a part of @target in which to ignore symbolic links.  This\n+ * would be the container's rootfs.\n+ *\n+ * Return an open fd for the path, or <0 on error.\n+ */\n+static int open_without_symlink(const char *target, const char *prefix_skip)\n+{\n+\tint curlen = 0, dirfd, fulllen, i;\n+\tchar *dup = NULL;\n+\n+\tfulllen = strlen(target);\n+\n+\t/* make sure prefix-skip makes sense */\n+\tif (prefix_skip) {\n+\t\tcurlen = strlen(prefix_skip);\n+\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n+\t\t\tERROR(\""WHOA there - target '%s' didn't start with prefix '%s'\"",\n+\t\t\t\ttarget, prefix_skip);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\t/*\n+\t\t * get_nextpath() expects the curlen argument to be\n+\t\t * on a  (turned into \\0) / or before it, so decrement\n+\t\t * curlen to make sure that happens\n+\t\t */\n+\t\tif (curlen)\n+\t\t\tcurlen--;\n+\t} else {\n+\t\tprefix_skip = \""/\"";\n+\t\tcurlen = 0;\n+\t}\n+\n+\t/* Make a copy of target which we can hack up, and tokenize it */\n+\tif ((dup = strdup(target)) == NULL) {\n+\t\tSYSERROR(\""Out of memory checking for symbolic link\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\tfor (i = 0; i < fulllen; i++) {\n+\t\tif (dup[i] == '/')\n+\t\t\tdup[i] = '\\0';\n+\t}\n+\n+\tdirfd = open(prefix_skip, O_RDONLY);\n+\tif (dirfd < 0)\n+\t\tgoto out;\n+\twhile (1) {\n+\t\tint newfd, saved_errno;\n+\t\tchar *nextpath;\n+\n+\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n+\t\t\tgoto out;\n+\t\tnewfd = open_if_safe(dirfd, nextpath);\n+\t\tsaved_errno = errno;\n+\t\tclose(dirfd);\n+\t\tdirfd = newfd;\n+\t\tif (newfd < 0) {\n+\t\t\terrno = saved_errno;\n+\t\t\tif (errno == ELOOP)\n+\t\t\t\tSYSERROR(\""%s in %s was a symbolic link!\"", nextpath, target);\n+\t\t\telse\n+\t\t\t\tSYSERROR(\""Error examining %s in %s\"", nextpath, target);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+out:\n+\tfree(dup);\n+\treturn dirfd;\n+}\n+\n+/*\n+ * Safely mount a path into a container, ensuring that the mount target\n+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container\n+ * uses the host's /)\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs)\n+{\n+\tint srcfd = -1, destfd, ret, saved_errno;\n+\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n+\tconst char *mntsrc = src;\n+\n+\tif (!rootfs)\n+\t\trootfs = \""\"";\n+\n+\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n+\tif (flags & MS_BIND && src && src[0] != '/') {\n+\t\tINFO(\""this is a relative bind mount\"");\n+\t\tsrcfd = open_without_symlink(src, NULL);\n+\t\tif (srcfd < 0)\n+\t\t\treturn srcfd;\n+\t\tret = snprintf(srcbuf, 50, \""/proc/self/fd/%d\"", srcfd);\n+\t\tif (ret < 0 || ret > 50) {\n+\t\t\tclose(srcfd);\n+\t\t\tERROR(\""Out of memory\"");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tmntsrc = srcbuf;\n+\t}\n+\n+\tdestfd = open_without_symlink(dest, rootfs);\n+\tif (destfd < 0) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\treturn destfd;\n+\t}\n+\n+\tret = snprintf(destbuf, 50, \""/proc/self/fd/%d\"", destfd);\n+\tif (ret < 0 || ret > 50) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\tclose(destfd);\n+\t\tERROR(\""Out of memory\"");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tret = mount(mntsrc, destbuf, fstype, flags, data);\n+\tsaved_errno = errno;\n+\tif (srcfd != -1)\n+\t\tclose(srcfd);\n+\tclose(destfd);\n+\tif (ret < 0) {\n+\t\terrno = saved_errno;\n+\t\tSYSERROR(\""Failed to mount %s onto %s\"", src, dest);\n+\t\treturn ret;\n+\t}\n+\n+\treturn 0;\n+}\n+\n /*\n  * Mount a proc under @rootfs if proc self points to a pid other than\n  * my own.  This is needed to have a known-good proc mount for setting\n@@ -1446,7 +1679,7 @@ int mount_proc_if_needed(const char *rootfs)\n \treturn 0;\n \n domount:\n-\tif (mount(\""proc\"", path, \""proc\"", 0, NULL))\n+\tif (safe_mount(\""proc\"", path, \""proc\"", 0, NULL, rootfs) < 0)\n \t\treturn -1;\n \tINFO(\""Mounted /proc in container for security transition\"");\n \treturn 1;""}<_**next**_>{""sha"": ""059026f0154b1713854c84674d12954a09469506"", ""filename"": ""src/lxc/utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.h?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -279,6 +279,8 @@ bool switch_to_ns(pid_t pid, const char *ns);\n int is_dir(const char *path);\n char *get_template_path(const char *t);\n int setproctitle(char *title);\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs);\n int mount_proc_if_needed(const char *rootfs);\n int null_stdfds(void);\n #endif /* __LXC_UTILS_H */""}<_**next**_>{""sha"": ""462d4f27882715442c3183b9db6620430b767455"", ""filename"": ""src/tests/Makefile.am"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/Makefile.am?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -55,6 +55,7 @@ bin_SCRIPTS += \\\n \tlxc-test-apparmor-mount \\\n \tlxc-test-checkpoint-restore \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tlxc-test-usernic\n@@ -82,6 +83,7 @@ EXTRA_DIST = \\\n \tlxc-test-cloneconfig \\\n \tlxc-test-createconfig \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tmay_control.c \\""}<_**next**_>{""sha"": ""37320f0dfd96b262d52bc99e314b7fe3cb026bb1"", ""filename"": ""src/tests/lxc-test-symlink"", ""status"": ""added"", ""additions"": 88, ""deletions"": 0, ""changes"": 88, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/lxc-test-symlink?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -0,0 +1,88 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+# lxc: linux Container library\n+\n+# Authors:\n+# Serge Hallyn <serge.hallyn@ubuntu.com>\n+#\n+# This is a regression test for symbolic links\n+\n+dirname=`mktemp -d`\n+fname=`mktemp`\n+fname2=`mktemp`\n+\n+lxcpath=/var/lib/lxcsym1\n+\n+cleanup() {\n+\tlxc-destroy -P $lxcpath -f -n symtest1 || true\n+\trm -f $lxcpath\n+\trmdir $dirname || true\n+\trm -f $fname || true\n+\trm -f $fname2 || true\n+}\n+\n+trap cleanup EXIT SIGHUP SIGINT SIGTERM\n+\n+testrun() {\n+\texpected=$1\n+\trun=$2\n+\tpass=\""pass\""\n+\tlxc-start -P $lxcpath -n symtest1 -l trace -o $lxcpath/log || pass=\""fail\""\n+\t[ $pass = \""pass\"" ] && lxc-wait -P $lxcpath -n symtest1 -t 10 -s RUNNING || pass=\""fail\""\n+\tif [ \""$pass\"" != \""$expected\"" ]; then\n+\t\techo \""Test $run: expected $expected but container did not.  Start log:\""\n+\t\tcat $lxcpath/log\n+\t\techo \""FAIL: Test $run: expected $expected but container did not.\""\n+\t\tfalse\n+\tfi\n+\tlxc-stop -P $lxcpath -n symtest1 -k || true\n+}\n+\n+# make lxcpath a symlink - this should NOT cause failure\n+ln -s /var/lib/lxc $lxcpath\n+\n+lxc-destroy -P $lxcpath -f -n symtest1 || true\n+lxc-create -P $lxcpath -t busybox -n symtest1\n+\n+cat >> /var/lib/lxc/symtest1/config << EOF\n+lxc.mount.entry = $dirname opt/xxx/dir none bind,create=dir\n+lxc.mount.entry = $fname opt/xxx/file none bind,create=file\n+lxc.mount.entry = $fname2 opt/xxx/file2 none bind\n+EOF\n+\n+# Regular - should succeed\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun pass 1\n+\n+# symlink - should fail\n+rm -rf /var/lib/lxc/symtest1/rootfs/opt/xxx\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx2\n+ln -s /var/lib/lxc/symtest1/rootfs/opt/xxx2 /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun fail 2\n+\n+# final final symlink - should fail\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx/dir\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2src\n+ln -s $lxcpath/symtest1/rootfs/opt/xxx/file2src $lxcpath/symtest1/rootfs/opt/xxx/file2\n+testrun fail 3\n+\n+# Ideally we'd also try a loop device, but that won't work in nested containers\n+# anyway - TODO\n+\n+# what about /proc itself\n+\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2\n+mv $lxcpath/symtest1/rootfs/proc $lxcpath/symtest1/rootfs/proc1\n+ln -s $lxcpath/symtest1/rootfs/proc1 $lxcpath/symtest1/rootfs/proc\n+testrun fail 4\n+\n+echo \""all tests passed\""""}"," static inline int mount_entry_on_systemfs(struct mntent *mntent)
 {
  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);
 }
"," static inline int mount_entry_on_systemfs(struct mntent *mntent)
 {
  return mount_entry_on_generic(mntent, mntent->mnt_dir);
 }
",C,"  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);
","  return mount_entry_on_generic(mntent, mntent->mnt_dir);
",,"@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 		 * 2.6.32...
 		 */
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/net"",                  NULL,       MS_BIND,                        NULL },
+		/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/tty"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys"",                                       ""%r/proc/sys"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sys"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/net"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/tty"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sysrq-trigger"",                             ""%r/proc/sysrq-trigger"",        NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sysrq-trigger"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 			}
 			mflags = add_required_remount_flags(source, destination,
 					default_mounts[i].flags);
-			r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);
+			r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);
 			saved_errno = errno;
 			if (r < 0 && errno == ENOENT) {
 				INFO(""Mount source or target for %s on %s doesn't exist. Skipping."", source, destination);
@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons
 		return 0;
 	}
 
-	if (mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"")) {
+	if (safe_mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"",
+				rootfs->path ? rootfs->mount : NULL)) {
 		SYSERROR(""Failed mounting tmpfs onto %s\n"", path);
 		return false;
 	}
@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)
 				return -1;
 			}
 			fclose(pathfile);
-			if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {
+			if (safe_mount(hostpath, path, 0, MS_BIND, NULL,
+						rootfs->path ? rootfs->mount : NULL) != 0) {
 				SYSERROR(""Failed bind mounting device %s from host into container"",
 					d->name);
 				return -1;
@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,
 		return -1;
 	}
 
-	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, path, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}
@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,
 		return 0;
 	}
 
-	if (mount(console->name, lxcpath, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, lxcpath, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, lxcpath);
 		return -1;
 	}
@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)
 
 static int mount_entry(const char *fsname, const char *target,
 		       const char *fstype, unsigned long mountflags,
-		       const char *data, int optional)
+		       const char *data, int optional, const char *rootfs)
 {
 #ifdef HAVE_STATVFS
 	struct statvfs sb;
 #endif
 
-	if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {
+	if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {
 		if (optional) {
 			INFO(""failed to mount '%s' on '%s' (optional): %s"", fsname,
 			     target, strerror(errno));
@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,
 #endif
 
 		if (mount(fsname, target, fstype,
-			  mountflags | MS_REMOUNT, data)) {
+			  mountflags | MS_REMOUNT, data) < 0) {
 			if (optional) {
 				INFO(""failed to mount '%s' on '%s' (optional): %s"",
 					 fsname, target, strerror(errno));
@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,
 }
 
 static inline int mount_entry_on_generic(struct mntent *mntent,
-                 const char* path)
+                 const char* path, const char *rootfs)
 {
 	unsigned long mntflags;
 	char *mntdata;
@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 	}
 
 	ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,
-			  mntflags, mntdata, optional);
+			  mntflags, mntdata, optional, rootfs);
 
 	free(mntdata);
 
@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 
 static inline int mount_entry_on_systemfs(struct mntent *mntent)
 {
-  return mount_entry_on_generic(mntent, mntent->mnt_dir);
+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);
 }
 
 static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs->mount);
 }
 
 static int mount_entry_on_relative_rootfs(struct mntent *mntent,
@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs);
 }
 
 static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,
@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)
 		fclose(pathfile);
 	}
 
-	ret = mount(path, destpath, ""none"", MS_BIND, NULL);
+	ret = safe_mount(path, destpath, ""none"", MS_BIND, NULL, conf->rootfs.mount);
 	if (ret < 0)
 		SYSERROR(""Failed to bind lxc.init.static into container"");
 	INFO(""lxc.init.static bound into container at %s"", path);",lxc,592fd47a6245508b79fe6ac819fe6d3b2c1289be,f2e4dddd71d427f9cacbab4016ffe18b0e4a4a0a,1," static inline int mount_entry_on_systemfs(struct mntent *mntent)
 {
//flaw_line_below:
  return mount_entry_on_generic(mntent, mntent->mnt_dir);
//fix_flaw_line_below:
//  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);
 }
"
2156,179892,,Local,Not required,Complete,CVE-2015-1335,https://www.cvedetails.com/cve/CVE-2015-1335/,CWE-59,Low,Complete,Complete,,2015-10-01,7.2,lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.,2019-05-31,,1,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,592fd47a6245508b79fe6ac819fe6d3b2c1289be,"CVE-2015-1335: Protect container mounts against symlinks

When a container starts up, lxc sets up the container's inital fstree
by doing a bunch of mounting, guided by the container configuration
file.  The container config is owned by the admin or user on the host,
so we do not try to guard against bad entries.  However, since the
mount target is in the container, it's possible that the container admin
could divert the mount with symbolic links.  This could bypass proper
container startup (i.e. confinement of a root-owned container by the
restrictive apparmor policy, by diverting the required write to
/proc/self/attr/current), or bypass the (path-based) apparmor policy
by diverting, say, /proc to /mnt in the container.

To prevent this,

1. do not allow mounts to paths containing symbolic links

2. do not allow bind mounts from relative paths containing symbolic
links.

Details:

Define safe_mount which ensures that the container has not inserted any
symbolic links into any mount targets for mounts to be done during
container setup.

The host's mount path may contain symbolic links.  As it is under the
control of the administrator, that's ok.  So safe_mount begins the check
for symbolic links after the rootfs->mount, by opening that directory.

It opens each directory along the path using openat() relative to the
parent directory using O_NOFOLLOW.  When the target is reached, it
mounts onto /proc/self/fd/<targetfd>.

Use safe_mount() in mount_entry(), when mounting container proc,
and when needed.  In particular, safe_mount() need not be used in
any case where:

1. the mount is done in the container's namespace
2. the mount is for the container's rootfs
3. the mount is relative to a tmpfs or proc/sysfs which we have
   just safe_mount()ed ourselves

Since we were using proc/net as a temporary placeholder for /proc/sys/net
during container startup, and proc/net is a symbolic link, use proc/tty
instead.

Update the lxc.container.conf manpage with details about the new
restrictions.

Finally, add a testcase to test some symbolic link possibilities.

Reported-by: Roman Fiedler
Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Acked-by: Stphane Graber <stgraber@ubuntu.com>",1,src/lxc/conf.c,"{""sha"": ""eb3241f795d2f3e0f1fb762516983b74e99af52f"", ""filename"": ""doc/lxc.container.conf.sgml.in"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/doc/lxc.container.conf.sgml.in?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -760,6 +760,18 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n         container. This is useful to mount /etc, /var or /home for\n         examples.\n       </para>\n+      <para>\n+\tNOTE - LXC will generally ensure that mount targets and relative\n+\tbind-mount sources are properly confined under the container\n+\troot, to avoid attacks involving over-mounting host directories\n+\tand files.  (Symbolic links in absolute mount sources are ignored)\n+\tHowever, if the container configuration first mounts a directory which\n+\tis under the control of the container user, such as /home/joe, into\n+        the container at some <filename>path</filename>, and then mounts\n+        under <filename>path</filename>, then a TOCTTOU attack would be\n+        possible where the container user modifies a symbolic link under\n+        his home directory at just the right time.\n+      </para>\n       <variablelist>\n         <varlistentry>\n           <term>""}<_**next**_>{""sha"": ""df2e6b2333bc81f94bf7583087475fd8d62605a1"", ""filename"": ""src/lxc/cgfs.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgfs.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1363,7 +1363,10 @@ static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \""%s/sys/fs/cgroup\"", root);\n-\tr = mount(\""cgroup_root\"", path, \""tmpfs\"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \""size=10240k,mode=755\"");\n+\tr = safe_mount(\""cgroup_root\"", path, \""tmpfs\"",\n+\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n+\t\t\t\""size=10240k,mode=755\"",\n+\t\t\troot);\n \tif (r < 0) {\n \t\tSYSERROR(\""could not mount tmpfs to /sys/fs/cgroup in the container\"");\n \t\treturn false;""}<_**next**_>{""sha"": ""a677c22c768eccccaa3af386c662c43dad8412cf"", ""filename"": ""src/lxc/cgmanager.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgmanager.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1477,7 +1477,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t}\n \n \t/* mount a tmpfs there so we can create subdirs */\n-\tif (mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"")) {\n+\tif (safe_mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"", root)) {\n \t\tSYSERROR(\""Failed to mount tmpfs at %s\"", cgpath);\n \t\treturn false;\n \t}\n@@ -1488,7 +1488,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t\treturn false;\n \t}\n \n-\tif (mount(dirname, cgpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(dirname, cgpath, \""none\"", MS_BIND, 0, root)) {\n \t\tSYSERROR(\""Failed to bind mount %s to %s\"", dirname, cgpath);\n \t\treturn false;\n \t}""}<_**next**_>{""sha"": ""bb4c19f82e2c806b07125cbfd9ed3220df07be38"", ""filename"": ""src/lxc/conf.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 16, ""changes"": 35, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/conf.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t * 2.6.32...\n \t\t */\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/net\"",                  NULL,       MS_BIND,                        NULL },\n+\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/tty\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys\"",                                       \""%r/proc/sys\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sys\"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/net\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/tty\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sysrq-trigger\"",                             \""%r/proc/sysrq-trigger\"",        NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sysrq-trigger\"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t\t}\n \t\t\tmflags = add_required_remount_flags(source, destination,\n \t\t\t\t\tdefault_mounts[i].flags);\n-\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n+\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n \t\t\tsaved_errno = errno;\n \t\t\tif (r < 0 && errno == ENOENT) {\n \t\t\t\tINFO(\""Mount source or target for %s on %s doesn't exist. Skipping.\"", source, destination);\n@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons\n \t\treturn 0;\n \t}\n \n-\tif (mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"")) {\n+\tif (safe_mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"",\n+\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n \t\tSYSERROR(\""Failed mounting tmpfs onto %s\\n\"", path);\n \t\treturn false;\n \t}\n@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tfclose(pathfile);\n-\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n+\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n+\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n \t\t\t\tSYSERROR(\""Failed bind mounting device %s from host into container\"",\n \t\t\t\t\td->name);\n \t\t\t\treturn -1;\n@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,\n \t\treturn -1;\n \t}\n \n-\tif (mount(console->name, path, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, path, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, path);\n \t\treturn -1;\n \t}\n@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n \t\treturn 0;\n \t}\n \n-\tif (mount(console->name, lxcpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, lxcpath, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, lxcpath);\n \t\treturn -1;\n \t}\n@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)\n \n static int mount_entry(const char *fsname, const char *target,\n \t\t       const char *fstype, unsigned long mountflags,\n-\t\t       const char *data, int optional)\n+\t\t       const char *data, int optional, const char *rootfs)\n {\n #ifdef HAVE_STATVFS\n \tstruct statvfs sb;\n #endif\n \n-\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n+\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n \t\tif (optional) {\n \t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"", fsname,\n \t\t\t     target, strerror(errno));\n@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,\n #endif\n \n \t\tif (mount(fsname, target, fstype,\n-\t\t\t  mountflags | MS_REMOUNT, data)) {\n+\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n \t\t\tif (optional) {\n \t\t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"",\n \t\t\t\t\t fsname, target, strerror(errno));\n@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,\n }\n \n static inline int mount_entry_on_generic(struct mntent *mntent,\n-                 const char* path)\n+                 const char* path, const char *rootfs)\n {\n \tunsigned long mntflags;\n \tchar *mntdata;\n@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \t}\n \n \tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n-\t\t\t  mntflags, mntdata, optional);\n+\t\t\t  mntflags, mntdata, optional, rootfs);\n \n \tfree(mntdata);\n \n@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \n static inline int mount_entry_on_systemfs(struct mntent *mntent)\n {\n-  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n }\n \n static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n }\n \n static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs);\n }\n \n static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \""none\"", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \""none\"", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\""Failed to bind lxc.init.static into container\"");\n \tINFO(\""lxc.init.static bound into container at %s\"", path);""}<_**next**_>{""sha"": ""788cbe136302bb46a559c36dc45a895f8c584574"", ""filename"": ""src/lxc/utils.c"", ""status"": ""modified"", ""additions"": 234, ""deletions"": 1, ""changes"": 235, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1404,6 +1404,239 @@ int setproctitle(char *title)\n \treturn ret;\n }\n \n+/*\n+ * @path:    a pathname where / replaced with '\\0'.\n+ * @offsetp: pointer to int showing which path segment was last seen.\n+ *           Updated on return to reflect the next segment.\n+ * @fulllen: full original path length.\n+ * Returns a pointer to the next path segment, or NULL if done.\n+ */\n+static char *get_nextpath(char *path, int *offsetp, int fulllen)\n+{\n+\tint offset = *offsetp;\n+\n+\tif (offset >= fulllen)\n+\t\treturn NULL;\n+\n+\twhile (path[offset] != '\\0' && offset < fulllen)\n+\t\toffset++;\n+\twhile (path[offset] == '\\0' && offset < fulllen)\n+\t\toffset++;\n+\n+\t*offsetp = offset;\n+\treturn (offset < fulllen) ? &path[offset] : NULL;\n+}\n+\n+/*\n+ * Check that @subdir is a subdir of @dir.  @len is the length of\n+ * @dir (to avoid having to recalculate it).\n+ */\n+static bool is_subdir(const char *subdir, const char *dir, size_t len)\n+{\n+\tsize_t subdirlen = strlen(subdir);\n+\n+\tif (subdirlen < len)\n+\t\treturn false;\n+\tif (strncmp(subdir, dir, len) != 0)\n+\t\treturn false;\n+\tif (dir[len-1] == '/')\n+\t\treturn true;\n+\tif (subdir[len] == '/' || subdirlen == len)\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+/*\n+ * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return\n+ * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.\n+ */\n+static int check_symlink(int fd)\n+{\n+\tstruct stat sb;\n+\tint ret = fstat(fd, &sb);\n+\tif (ret < 0)\n+\t\treturn -ENOENT;\n+\tif (S_ISLNK(sb.st_mode))\n+\t\treturn -ELOOP;\n+\treturn 0;\n+}\n+\n+/*\n+ * Open a file or directory, provided that it contains no symlinks.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+static int open_if_safe(int dirfd, const char *nextpath)\n+{\n+\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n+\tif (newfd >= 0) // was not a symlink, all good\n+\t\treturn newfd;\n+\n+\tif (errno == ELOOP)\n+\t\treturn newfd;\n+\n+\tif (errno == EPERM || errno == EACCES) {\n+\t\t/* we're not root (cause we got EPERM) so\n+\t\t   try opening with O_PATH */\n+\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n+\t\tif (newfd >= 0) {\n+\t\t\t/* O_PATH will return an fd for symlinks.  We know\n+\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n+\t\t\t * is now a link, then something * fishy is going on\n+\t\t\t */\n+\t\t\tint ret = check_symlink(newfd);\n+\t\t\tif (ret < 0) {\n+\t\t\t\tclose(newfd);\n+\t\t\t\tnewfd = ret;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newfd;\n+}\n+\n+/*\n+ * Open a path intending for mounting, ensuring that the final path\n+ * is inside the container's rootfs.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ *\n+ * @target: path to be opened\n+ * @prefix_skip: a part of @target in which to ignore symbolic links.  This\n+ * would be the container's rootfs.\n+ *\n+ * Return an open fd for the path, or <0 on error.\n+ */\n+static int open_without_symlink(const char *target, const char *prefix_skip)\n+{\n+\tint curlen = 0, dirfd, fulllen, i;\n+\tchar *dup = NULL;\n+\n+\tfulllen = strlen(target);\n+\n+\t/* make sure prefix-skip makes sense */\n+\tif (prefix_skip) {\n+\t\tcurlen = strlen(prefix_skip);\n+\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n+\t\t\tERROR(\""WHOA there - target '%s' didn't start with prefix '%s'\"",\n+\t\t\t\ttarget, prefix_skip);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\t/*\n+\t\t * get_nextpath() expects the curlen argument to be\n+\t\t * on a  (turned into \\0) / or before it, so decrement\n+\t\t * curlen to make sure that happens\n+\t\t */\n+\t\tif (curlen)\n+\t\t\tcurlen--;\n+\t} else {\n+\t\tprefix_skip = \""/\"";\n+\t\tcurlen = 0;\n+\t}\n+\n+\t/* Make a copy of target which we can hack up, and tokenize it */\n+\tif ((dup = strdup(target)) == NULL) {\n+\t\tSYSERROR(\""Out of memory checking for symbolic link\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\tfor (i = 0; i < fulllen; i++) {\n+\t\tif (dup[i] == '/')\n+\t\t\tdup[i] = '\\0';\n+\t}\n+\n+\tdirfd = open(prefix_skip, O_RDONLY);\n+\tif (dirfd < 0)\n+\t\tgoto out;\n+\twhile (1) {\n+\t\tint newfd, saved_errno;\n+\t\tchar *nextpath;\n+\n+\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n+\t\t\tgoto out;\n+\t\tnewfd = open_if_safe(dirfd, nextpath);\n+\t\tsaved_errno = errno;\n+\t\tclose(dirfd);\n+\t\tdirfd = newfd;\n+\t\tif (newfd < 0) {\n+\t\t\terrno = saved_errno;\n+\t\t\tif (errno == ELOOP)\n+\t\t\t\tSYSERROR(\""%s in %s was a symbolic link!\"", nextpath, target);\n+\t\t\telse\n+\t\t\t\tSYSERROR(\""Error examining %s in %s\"", nextpath, target);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+out:\n+\tfree(dup);\n+\treturn dirfd;\n+}\n+\n+/*\n+ * Safely mount a path into a container, ensuring that the mount target\n+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container\n+ * uses the host's /)\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs)\n+{\n+\tint srcfd = -1, destfd, ret, saved_errno;\n+\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n+\tconst char *mntsrc = src;\n+\n+\tif (!rootfs)\n+\t\trootfs = \""\"";\n+\n+\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n+\tif (flags & MS_BIND && src && src[0] != '/') {\n+\t\tINFO(\""this is a relative bind mount\"");\n+\t\tsrcfd = open_without_symlink(src, NULL);\n+\t\tif (srcfd < 0)\n+\t\t\treturn srcfd;\n+\t\tret = snprintf(srcbuf, 50, \""/proc/self/fd/%d\"", srcfd);\n+\t\tif (ret < 0 || ret > 50) {\n+\t\t\tclose(srcfd);\n+\t\t\tERROR(\""Out of memory\"");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tmntsrc = srcbuf;\n+\t}\n+\n+\tdestfd = open_without_symlink(dest, rootfs);\n+\tif (destfd < 0) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\treturn destfd;\n+\t}\n+\n+\tret = snprintf(destbuf, 50, \""/proc/self/fd/%d\"", destfd);\n+\tif (ret < 0 || ret > 50) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\tclose(destfd);\n+\t\tERROR(\""Out of memory\"");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tret = mount(mntsrc, destbuf, fstype, flags, data);\n+\tsaved_errno = errno;\n+\tif (srcfd != -1)\n+\t\tclose(srcfd);\n+\tclose(destfd);\n+\tif (ret < 0) {\n+\t\terrno = saved_errno;\n+\t\tSYSERROR(\""Failed to mount %s onto %s\"", src, dest);\n+\t\treturn ret;\n+\t}\n+\n+\treturn 0;\n+}\n+\n /*\n  * Mount a proc under @rootfs if proc self points to a pid other than\n  * my own.  This is needed to have a known-good proc mount for setting\n@@ -1446,7 +1679,7 @@ int mount_proc_if_needed(const char *rootfs)\n \treturn 0;\n \n domount:\n-\tif (mount(\""proc\"", path, \""proc\"", 0, NULL))\n+\tif (safe_mount(\""proc\"", path, \""proc\"", 0, NULL, rootfs) < 0)\n \t\treturn -1;\n \tINFO(\""Mounted /proc in container for security transition\"");\n \treturn 1;""}<_**next**_>{""sha"": ""059026f0154b1713854c84674d12954a09469506"", ""filename"": ""src/lxc/utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.h?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -279,6 +279,8 @@ bool switch_to_ns(pid_t pid, const char *ns);\n int is_dir(const char *path);\n char *get_template_path(const char *t);\n int setproctitle(char *title);\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs);\n int mount_proc_if_needed(const char *rootfs);\n int null_stdfds(void);\n #endif /* __LXC_UTILS_H */""}<_**next**_>{""sha"": ""462d4f27882715442c3183b9db6620430b767455"", ""filename"": ""src/tests/Makefile.am"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/Makefile.am?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -55,6 +55,7 @@ bin_SCRIPTS += \\\n \tlxc-test-apparmor-mount \\\n \tlxc-test-checkpoint-restore \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tlxc-test-usernic\n@@ -82,6 +83,7 @@ EXTRA_DIST = \\\n \tlxc-test-cloneconfig \\\n \tlxc-test-createconfig \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tmay_control.c \\""}<_**next**_>{""sha"": ""37320f0dfd96b262d52bc99e314b7fe3cb026bb1"", ""filename"": ""src/tests/lxc-test-symlink"", ""status"": ""added"", ""additions"": 88, ""deletions"": 0, ""changes"": 88, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/lxc-test-symlink?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -0,0 +1,88 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+# lxc: linux Container library\n+\n+# Authors:\n+# Serge Hallyn <serge.hallyn@ubuntu.com>\n+#\n+# This is a regression test for symbolic links\n+\n+dirname=`mktemp -d`\n+fname=`mktemp`\n+fname2=`mktemp`\n+\n+lxcpath=/var/lib/lxcsym1\n+\n+cleanup() {\n+\tlxc-destroy -P $lxcpath -f -n symtest1 || true\n+\trm -f $lxcpath\n+\trmdir $dirname || true\n+\trm -f $fname || true\n+\trm -f $fname2 || true\n+}\n+\n+trap cleanup EXIT SIGHUP SIGINT SIGTERM\n+\n+testrun() {\n+\texpected=$1\n+\trun=$2\n+\tpass=\""pass\""\n+\tlxc-start -P $lxcpath -n symtest1 -l trace -o $lxcpath/log || pass=\""fail\""\n+\t[ $pass = \""pass\"" ] && lxc-wait -P $lxcpath -n symtest1 -t 10 -s RUNNING || pass=\""fail\""\n+\tif [ \""$pass\"" != \""$expected\"" ]; then\n+\t\techo \""Test $run: expected $expected but container did not.  Start log:\""\n+\t\tcat $lxcpath/log\n+\t\techo \""FAIL: Test $run: expected $expected but container did not.\""\n+\t\tfalse\n+\tfi\n+\tlxc-stop -P $lxcpath -n symtest1 -k || true\n+}\n+\n+# make lxcpath a symlink - this should NOT cause failure\n+ln -s /var/lib/lxc $lxcpath\n+\n+lxc-destroy -P $lxcpath -f -n symtest1 || true\n+lxc-create -P $lxcpath -t busybox -n symtest1\n+\n+cat >> /var/lib/lxc/symtest1/config << EOF\n+lxc.mount.entry = $dirname opt/xxx/dir none bind,create=dir\n+lxc.mount.entry = $fname opt/xxx/file none bind,create=file\n+lxc.mount.entry = $fname2 opt/xxx/file2 none bind\n+EOF\n+\n+# Regular - should succeed\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun pass 1\n+\n+# symlink - should fail\n+rm -rf /var/lib/lxc/symtest1/rootfs/opt/xxx\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx2\n+ln -s /var/lib/lxc/symtest1/rootfs/opt/xxx2 /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun fail 2\n+\n+# final final symlink - should fail\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx/dir\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2src\n+ln -s $lxcpath/symtest1/rootfs/opt/xxx/file2src $lxcpath/symtest1/rootfs/opt/xxx/file2\n+testrun fail 3\n+\n+# Ideally we'd also try a loop device, but that won't work in nested containers\n+# anyway - TODO\n+\n+# what about /proc itself\n+\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2\n+mv $lxcpath/symtest1/rootfs/proc $lxcpath/symtest1/rootfs/proc1\n+ln -s $lxcpath/symtest1/rootfs/proc1 $lxcpath/symtest1/rootfs/proc\n+testrun fail 4\n+\n+echo \""all tests passed\""""}","static int setup_dev_console(const struct lxc_rootfs *rootfs,
			 const struct lxc_console *console)
{
	char path[MAXPATHLEN];
	struct stat s;
	int ret;

	ret = snprintf(path, sizeof(path), ""%s/dev/console"", rootfs->mount);
	if (ret >= sizeof(path)) {
		ERROR(""console path too long"");
		return -1;
	}

	if (access(path, F_OK)) {
		WARN(""rootfs specified but no console found at '%s'"", path);
		return 0;
	}

	if (console->master < 0) {
		INFO(""no console"");
		return 0;
	}

	if (stat(path, &s)) {
		SYSERROR(""failed to stat '%s'"", path);
		return -1;
	}

	if (chmod(console->name, s.st_mode)) {
		SYSERROR(""failed to set mode '0%o' to '%s'"",
			 s.st_mode, console->name);
 		return -1;
 	}
 
	if (safe_mount(console->name, path, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}

	INFO(""console has been setup"");
	return 0;
}
","static int setup_dev_console(const struct lxc_rootfs *rootfs,
			 const struct lxc_console *console)
{
	char path[MAXPATHLEN];
	struct stat s;
	int ret;

	ret = snprintf(path, sizeof(path), ""%s/dev/console"", rootfs->mount);
	if (ret >= sizeof(path)) {
		ERROR(""console path too long"");
		return -1;
	}

	if (access(path, F_OK)) {
		WARN(""rootfs specified but no console found at '%s'"", path);
		return 0;
	}

	if (console->master < 0) {
		INFO(""no console"");
		return 0;
	}

	if (stat(path, &s)) {
		SYSERROR(""failed to stat '%s'"", path);
		return -1;
	}

	if (chmod(console->name, s.st_mode)) {
		SYSERROR(""failed to set mode '0%o' to '%s'"",
			 s.st_mode, console->name);
 		return -1;
 	}
 
	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}

	INFO(""console has been setup"");
	return 0;
}
",C,"	if (safe_mount(console->name, path, ""none"", MS_BIND, 0, rootfs->mount)) {
","	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
",,"@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 		 * 2.6.32...
 		 */
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/net"",                  NULL,       MS_BIND,                        NULL },
+		/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/tty"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys"",                                       ""%r/proc/sys"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sys"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/net"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/tty"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sysrq-trigger"",                             ""%r/proc/sysrq-trigger"",        NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sysrq-trigger"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 			}
 			mflags = add_required_remount_flags(source, destination,
 					default_mounts[i].flags);
-			r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);
+			r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);
 			saved_errno = errno;
 			if (r < 0 && errno == ENOENT) {
 				INFO(""Mount source or target for %s on %s doesn't exist. Skipping."", source, destination);
@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons
 		return 0;
 	}
 
-	if (mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"")) {
+	if (safe_mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"",
+				rootfs->path ? rootfs->mount : NULL)) {
 		SYSERROR(""Failed mounting tmpfs onto %s\n"", path);
 		return false;
 	}
@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)
 				return -1;
 			}
 			fclose(pathfile);
-			if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {
+			if (safe_mount(hostpath, path, 0, MS_BIND, NULL,
+						rootfs->path ? rootfs->mount : NULL) != 0) {
 				SYSERROR(""Failed bind mounting device %s from host into container"",
 					d->name);
 				return -1;
@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,
 		return -1;
 	}
 
-	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, path, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}
@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,
 		return 0;
 	}
 
-	if (mount(console->name, lxcpath, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, lxcpath, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, lxcpath);
 		return -1;
 	}
@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)
 
 static int mount_entry(const char *fsname, const char *target,
 		       const char *fstype, unsigned long mountflags,
-		       const char *data, int optional)
+		       const char *data, int optional, const char *rootfs)
 {
 #ifdef HAVE_STATVFS
 	struct statvfs sb;
 #endif
 
-	if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {
+	if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {
 		if (optional) {
 			INFO(""failed to mount '%s' on '%s' (optional): %s"", fsname,
 			     target, strerror(errno));
@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,
 #endif
 
 		if (mount(fsname, target, fstype,
-			  mountflags | MS_REMOUNT, data)) {
+			  mountflags | MS_REMOUNT, data) < 0) {
 			if (optional) {
 				INFO(""failed to mount '%s' on '%s' (optional): %s"",
 					 fsname, target, strerror(errno));
@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,
 }
 
 static inline int mount_entry_on_generic(struct mntent *mntent,
-                 const char* path)
+                 const char* path, const char *rootfs)
 {
 	unsigned long mntflags;
 	char *mntdata;
@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 	}
 
 	ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,
-			  mntflags, mntdata, optional);
+			  mntflags, mntdata, optional, rootfs);
 
 	free(mntdata);
 
@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 
 static inline int mount_entry_on_systemfs(struct mntent *mntent)
 {
-  return mount_entry_on_generic(mntent, mntent->mnt_dir);
+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);
 }
 
 static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs->mount);
 }
 
 static int mount_entry_on_relative_rootfs(struct mntent *mntent,
@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs);
 }
 
 static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,
@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)
 		fclose(pathfile);
 	}
 
-	ret = mount(path, destpath, ""none"", MS_BIND, NULL);
+	ret = safe_mount(path, destpath, ""none"", MS_BIND, NULL, conf->rootfs.mount);
 	if (ret < 0)
 		SYSERROR(""Failed to bind lxc.init.static into container"");
 	INFO(""lxc.init.static bound into container at %s"", path);",lxc,592fd47a6245508b79fe6ac819fe6d3b2c1289be,f2e4dddd71d427f9cacbab4016ffe18b0e4a4a0a,1,"static int setup_dev_console(const struct lxc_rootfs *rootfs,
			 const struct lxc_console *console)
{
	char path[MAXPATHLEN];
	struct stat s;
	int ret;

	ret = snprintf(path, sizeof(path), ""%s/dev/console"", rootfs->mount);
	if (ret >= sizeof(path)) {
		ERROR(""console path too long"");
		return -1;
	}

	if (access(path, F_OK)) {
		WARN(""rootfs specified but no console found at '%s'"", path);
		return 0;
	}

	if (console->master < 0) {
		INFO(""no console"");
		return 0;
	}

	if (stat(path, &s)) {
		SYSERROR(""failed to stat '%s'"", path);
		return -1;
	}

	if (chmod(console->name, s.st_mode)) {
		SYSERROR(""failed to set mode '0%o' to '%s'"",
			 s.st_mode, console->name);
 		return -1;
 	}
 
//flaw_line_below:
	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
//fix_flaw_line_below:
//	if (safe_mount(console->name, path, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}

	INFO(""console has been setup"");
	return 0;
}
"
2157,179893,,Local,Not required,Complete,CVE-2015-1335,https://www.cvedetails.com/cve/CVE-2015-1335/,CWE-59,Low,Complete,Complete,,2015-10-01,7.2,lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.,2019-05-31,,1,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,592fd47a6245508b79fe6ac819fe6d3b2c1289be,"CVE-2015-1335: Protect container mounts against symlinks

When a container starts up, lxc sets up the container's inital fstree
by doing a bunch of mounting, guided by the container configuration
file.  The container config is owned by the admin or user on the host,
so we do not try to guard against bad entries.  However, since the
mount target is in the container, it's possible that the container admin
could divert the mount with symbolic links.  This could bypass proper
container startup (i.e. confinement of a root-owned container by the
restrictive apparmor policy, by diverting the required write to
/proc/self/attr/current), or bypass the (path-based) apparmor policy
by diverting, say, /proc to /mnt in the container.

To prevent this,

1. do not allow mounts to paths containing symbolic links

2. do not allow bind mounts from relative paths containing symbolic
links.

Details:

Define safe_mount which ensures that the container has not inserted any
symbolic links into any mount targets for mounts to be done during
container setup.

The host's mount path may contain symbolic links.  As it is under the
control of the administrator, that's ok.  So safe_mount begins the check
for symbolic links after the rootfs->mount, by opening that directory.

It opens each directory along the path using openat() relative to the
parent directory using O_NOFOLLOW.  When the target is reached, it
mounts onto /proc/self/fd/<targetfd>.

Use safe_mount() in mount_entry(), when mounting container proc,
and when needed.  In particular, safe_mount() need not be used in
any case where:

1. the mount is done in the container's namespace
2. the mount is for the container's rootfs
3. the mount is relative to a tmpfs or proc/sysfs which we have
   just safe_mount()ed ourselves

Since we were using proc/net as a temporary placeholder for /proc/sys/net
during container startup, and proc/net is a symbolic link, use proc/tty
instead.

Update the lxc.container.conf manpage with details about the new
restrictions.

Finally, add a testcase to test some symbolic link possibilities.

Reported-by: Roman Fiedler
Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Acked-by: Stphane Graber <stgraber@ubuntu.com>",1,src/lxc/conf.c,"{""sha"": ""eb3241f795d2f3e0f1fb762516983b74e99af52f"", ""filename"": ""doc/lxc.container.conf.sgml.in"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/doc/lxc.container.conf.sgml.in?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -760,6 +760,18 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n         container. This is useful to mount /etc, /var or /home for\n         examples.\n       </para>\n+      <para>\n+\tNOTE - LXC will generally ensure that mount targets and relative\n+\tbind-mount sources are properly confined under the container\n+\troot, to avoid attacks involving over-mounting host directories\n+\tand files.  (Symbolic links in absolute mount sources are ignored)\n+\tHowever, if the container configuration first mounts a directory which\n+\tis under the control of the container user, such as /home/joe, into\n+        the container at some <filename>path</filename>, and then mounts\n+        under <filename>path</filename>, then a TOCTTOU attack would be\n+        possible where the container user modifies a symbolic link under\n+        his home directory at just the right time.\n+      </para>\n       <variablelist>\n         <varlistentry>\n           <term>""}<_**next**_>{""sha"": ""df2e6b2333bc81f94bf7583087475fd8d62605a1"", ""filename"": ""src/lxc/cgfs.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgfs.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1363,7 +1363,10 @@ static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \""%s/sys/fs/cgroup\"", root);\n-\tr = mount(\""cgroup_root\"", path, \""tmpfs\"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \""size=10240k,mode=755\"");\n+\tr = safe_mount(\""cgroup_root\"", path, \""tmpfs\"",\n+\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n+\t\t\t\""size=10240k,mode=755\"",\n+\t\t\troot);\n \tif (r < 0) {\n \t\tSYSERROR(\""could not mount tmpfs to /sys/fs/cgroup in the container\"");\n \t\treturn false;""}<_**next**_>{""sha"": ""a677c22c768eccccaa3af386c662c43dad8412cf"", ""filename"": ""src/lxc/cgmanager.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgmanager.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1477,7 +1477,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t}\n \n \t/* mount a tmpfs there so we can create subdirs */\n-\tif (mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"")) {\n+\tif (safe_mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"", root)) {\n \t\tSYSERROR(\""Failed to mount tmpfs at %s\"", cgpath);\n \t\treturn false;\n \t}\n@@ -1488,7 +1488,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t\treturn false;\n \t}\n \n-\tif (mount(dirname, cgpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(dirname, cgpath, \""none\"", MS_BIND, 0, root)) {\n \t\tSYSERROR(\""Failed to bind mount %s to %s\"", dirname, cgpath);\n \t\treturn false;\n \t}""}<_**next**_>{""sha"": ""bb4c19f82e2c806b07125cbfd9ed3220df07be38"", ""filename"": ""src/lxc/conf.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 16, ""changes"": 35, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/conf.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t * 2.6.32...\n \t\t */\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/net\"",                  NULL,       MS_BIND,                        NULL },\n+\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/tty\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys\"",                                       \""%r/proc/sys\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sys\"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/net\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/tty\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sysrq-trigger\"",                             \""%r/proc/sysrq-trigger\"",        NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sysrq-trigger\"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t\t}\n \t\t\tmflags = add_required_remount_flags(source, destination,\n \t\t\t\t\tdefault_mounts[i].flags);\n-\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n+\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n \t\t\tsaved_errno = errno;\n \t\t\tif (r < 0 && errno == ENOENT) {\n \t\t\t\tINFO(\""Mount source or target for %s on %s doesn't exist. Skipping.\"", source, destination);\n@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons\n \t\treturn 0;\n \t}\n \n-\tif (mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"")) {\n+\tif (safe_mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"",\n+\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n \t\tSYSERROR(\""Failed mounting tmpfs onto %s\\n\"", path);\n \t\treturn false;\n \t}\n@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tfclose(pathfile);\n-\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n+\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n+\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n \t\t\t\tSYSERROR(\""Failed bind mounting device %s from host into container\"",\n \t\t\t\t\td->name);\n \t\t\t\treturn -1;\n@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,\n \t\treturn -1;\n \t}\n \n-\tif (mount(console->name, path, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, path, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, path);\n \t\treturn -1;\n \t}\n@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n \t\treturn 0;\n \t}\n \n-\tif (mount(console->name, lxcpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, lxcpath, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, lxcpath);\n \t\treturn -1;\n \t}\n@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)\n \n static int mount_entry(const char *fsname, const char *target,\n \t\t       const char *fstype, unsigned long mountflags,\n-\t\t       const char *data, int optional)\n+\t\t       const char *data, int optional, const char *rootfs)\n {\n #ifdef HAVE_STATVFS\n \tstruct statvfs sb;\n #endif\n \n-\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n+\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n \t\tif (optional) {\n \t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"", fsname,\n \t\t\t     target, strerror(errno));\n@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,\n #endif\n \n \t\tif (mount(fsname, target, fstype,\n-\t\t\t  mountflags | MS_REMOUNT, data)) {\n+\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n \t\t\tif (optional) {\n \t\t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"",\n \t\t\t\t\t fsname, target, strerror(errno));\n@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,\n }\n \n static inline int mount_entry_on_generic(struct mntent *mntent,\n-                 const char* path)\n+                 const char* path, const char *rootfs)\n {\n \tunsigned long mntflags;\n \tchar *mntdata;\n@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \t}\n \n \tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n-\t\t\t  mntflags, mntdata, optional);\n+\t\t\t  mntflags, mntdata, optional, rootfs);\n \n \tfree(mntdata);\n \n@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \n static inline int mount_entry_on_systemfs(struct mntent *mntent)\n {\n-  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n }\n \n static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n }\n \n static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs);\n }\n \n static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \""none\"", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \""none\"", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\""Failed to bind lxc.init.static into container\"");\n \tINFO(\""lxc.init.static bound into container at %s\"", path);""}<_**next**_>{""sha"": ""788cbe136302bb46a559c36dc45a895f8c584574"", ""filename"": ""src/lxc/utils.c"", ""status"": ""modified"", ""additions"": 234, ""deletions"": 1, ""changes"": 235, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1404,6 +1404,239 @@ int setproctitle(char *title)\n \treturn ret;\n }\n \n+/*\n+ * @path:    a pathname where / replaced with '\\0'.\n+ * @offsetp: pointer to int showing which path segment was last seen.\n+ *           Updated on return to reflect the next segment.\n+ * @fulllen: full original path length.\n+ * Returns a pointer to the next path segment, or NULL if done.\n+ */\n+static char *get_nextpath(char *path, int *offsetp, int fulllen)\n+{\n+\tint offset = *offsetp;\n+\n+\tif (offset >= fulllen)\n+\t\treturn NULL;\n+\n+\twhile (path[offset] != '\\0' && offset < fulllen)\n+\t\toffset++;\n+\twhile (path[offset] == '\\0' && offset < fulllen)\n+\t\toffset++;\n+\n+\t*offsetp = offset;\n+\treturn (offset < fulllen) ? &path[offset] : NULL;\n+}\n+\n+/*\n+ * Check that @subdir is a subdir of @dir.  @len is the length of\n+ * @dir (to avoid having to recalculate it).\n+ */\n+static bool is_subdir(const char *subdir, const char *dir, size_t len)\n+{\n+\tsize_t subdirlen = strlen(subdir);\n+\n+\tif (subdirlen < len)\n+\t\treturn false;\n+\tif (strncmp(subdir, dir, len) != 0)\n+\t\treturn false;\n+\tif (dir[len-1] == '/')\n+\t\treturn true;\n+\tif (subdir[len] == '/' || subdirlen == len)\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+/*\n+ * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return\n+ * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.\n+ */\n+static int check_symlink(int fd)\n+{\n+\tstruct stat sb;\n+\tint ret = fstat(fd, &sb);\n+\tif (ret < 0)\n+\t\treturn -ENOENT;\n+\tif (S_ISLNK(sb.st_mode))\n+\t\treturn -ELOOP;\n+\treturn 0;\n+}\n+\n+/*\n+ * Open a file or directory, provided that it contains no symlinks.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+static int open_if_safe(int dirfd, const char *nextpath)\n+{\n+\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n+\tif (newfd >= 0) // was not a symlink, all good\n+\t\treturn newfd;\n+\n+\tif (errno == ELOOP)\n+\t\treturn newfd;\n+\n+\tif (errno == EPERM || errno == EACCES) {\n+\t\t/* we're not root (cause we got EPERM) so\n+\t\t   try opening with O_PATH */\n+\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n+\t\tif (newfd >= 0) {\n+\t\t\t/* O_PATH will return an fd for symlinks.  We know\n+\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n+\t\t\t * is now a link, then something * fishy is going on\n+\t\t\t */\n+\t\t\tint ret = check_symlink(newfd);\n+\t\t\tif (ret < 0) {\n+\t\t\t\tclose(newfd);\n+\t\t\t\tnewfd = ret;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newfd;\n+}\n+\n+/*\n+ * Open a path intending for mounting, ensuring that the final path\n+ * is inside the container's rootfs.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ *\n+ * @target: path to be opened\n+ * @prefix_skip: a part of @target in which to ignore symbolic links.  This\n+ * would be the container's rootfs.\n+ *\n+ * Return an open fd for the path, or <0 on error.\n+ */\n+static int open_without_symlink(const char *target, const char *prefix_skip)\n+{\n+\tint curlen = 0, dirfd, fulllen, i;\n+\tchar *dup = NULL;\n+\n+\tfulllen = strlen(target);\n+\n+\t/* make sure prefix-skip makes sense */\n+\tif (prefix_skip) {\n+\t\tcurlen = strlen(prefix_skip);\n+\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n+\t\t\tERROR(\""WHOA there - target '%s' didn't start with prefix '%s'\"",\n+\t\t\t\ttarget, prefix_skip);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\t/*\n+\t\t * get_nextpath() expects the curlen argument to be\n+\t\t * on a  (turned into \\0) / or before it, so decrement\n+\t\t * curlen to make sure that happens\n+\t\t */\n+\t\tif (curlen)\n+\t\t\tcurlen--;\n+\t} else {\n+\t\tprefix_skip = \""/\"";\n+\t\tcurlen = 0;\n+\t}\n+\n+\t/* Make a copy of target which we can hack up, and tokenize it */\n+\tif ((dup = strdup(target)) == NULL) {\n+\t\tSYSERROR(\""Out of memory checking for symbolic link\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\tfor (i = 0; i < fulllen; i++) {\n+\t\tif (dup[i] == '/')\n+\t\t\tdup[i] = '\\0';\n+\t}\n+\n+\tdirfd = open(prefix_skip, O_RDONLY);\n+\tif (dirfd < 0)\n+\t\tgoto out;\n+\twhile (1) {\n+\t\tint newfd, saved_errno;\n+\t\tchar *nextpath;\n+\n+\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n+\t\t\tgoto out;\n+\t\tnewfd = open_if_safe(dirfd, nextpath);\n+\t\tsaved_errno = errno;\n+\t\tclose(dirfd);\n+\t\tdirfd = newfd;\n+\t\tif (newfd < 0) {\n+\t\t\terrno = saved_errno;\n+\t\t\tif (errno == ELOOP)\n+\t\t\t\tSYSERROR(\""%s in %s was a symbolic link!\"", nextpath, target);\n+\t\t\telse\n+\t\t\t\tSYSERROR(\""Error examining %s in %s\"", nextpath, target);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+out:\n+\tfree(dup);\n+\treturn dirfd;\n+}\n+\n+/*\n+ * Safely mount a path into a container, ensuring that the mount target\n+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container\n+ * uses the host's /)\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs)\n+{\n+\tint srcfd = -1, destfd, ret, saved_errno;\n+\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n+\tconst char *mntsrc = src;\n+\n+\tif (!rootfs)\n+\t\trootfs = \""\"";\n+\n+\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n+\tif (flags & MS_BIND && src && src[0] != '/') {\n+\t\tINFO(\""this is a relative bind mount\"");\n+\t\tsrcfd = open_without_symlink(src, NULL);\n+\t\tif (srcfd < 0)\n+\t\t\treturn srcfd;\n+\t\tret = snprintf(srcbuf, 50, \""/proc/self/fd/%d\"", srcfd);\n+\t\tif (ret < 0 || ret > 50) {\n+\t\t\tclose(srcfd);\n+\t\t\tERROR(\""Out of memory\"");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tmntsrc = srcbuf;\n+\t}\n+\n+\tdestfd = open_without_symlink(dest, rootfs);\n+\tif (destfd < 0) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\treturn destfd;\n+\t}\n+\n+\tret = snprintf(destbuf, 50, \""/proc/self/fd/%d\"", destfd);\n+\tif (ret < 0 || ret > 50) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\tclose(destfd);\n+\t\tERROR(\""Out of memory\"");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tret = mount(mntsrc, destbuf, fstype, flags, data);\n+\tsaved_errno = errno;\n+\tif (srcfd != -1)\n+\t\tclose(srcfd);\n+\tclose(destfd);\n+\tif (ret < 0) {\n+\t\terrno = saved_errno;\n+\t\tSYSERROR(\""Failed to mount %s onto %s\"", src, dest);\n+\t\treturn ret;\n+\t}\n+\n+\treturn 0;\n+}\n+\n /*\n  * Mount a proc under @rootfs if proc self points to a pid other than\n  * my own.  This is needed to have a known-good proc mount for setting\n@@ -1446,7 +1679,7 @@ int mount_proc_if_needed(const char *rootfs)\n \treturn 0;\n \n domount:\n-\tif (mount(\""proc\"", path, \""proc\"", 0, NULL))\n+\tif (safe_mount(\""proc\"", path, \""proc\"", 0, NULL, rootfs) < 0)\n \t\treturn -1;\n \tINFO(\""Mounted /proc in container for security transition\"");\n \treturn 1;""}<_**next**_>{""sha"": ""059026f0154b1713854c84674d12954a09469506"", ""filename"": ""src/lxc/utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.h?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -279,6 +279,8 @@ bool switch_to_ns(pid_t pid, const char *ns);\n int is_dir(const char *path);\n char *get_template_path(const char *t);\n int setproctitle(char *title);\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs);\n int mount_proc_if_needed(const char *rootfs);\n int null_stdfds(void);\n #endif /* __LXC_UTILS_H */""}<_**next**_>{""sha"": ""462d4f27882715442c3183b9db6620430b767455"", ""filename"": ""src/tests/Makefile.am"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/Makefile.am?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -55,6 +55,7 @@ bin_SCRIPTS += \\\n \tlxc-test-apparmor-mount \\\n \tlxc-test-checkpoint-restore \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tlxc-test-usernic\n@@ -82,6 +83,7 @@ EXTRA_DIST = \\\n \tlxc-test-cloneconfig \\\n \tlxc-test-createconfig \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tmay_control.c \\""}<_**next**_>{""sha"": ""37320f0dfd96b262d52bc99e314b7fe3cb026bb1"", ""filename"": ""src/tests/lxc-test-symlink"", ""status"": ""added"", ""additions"": 88, ""deletions"": 0, ""changes"": 88, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/lxc-test-symlink?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -0,0 +1,88 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+# lxc: linux Container library\n+\n+# Authors:\n+# Serge Hallyn <serge.hallyn@ubuntu.com>\n+#\n+# This is a regression test for symbolic links\n+\n+dirname=`mktemp -d`\n+fname=`mktemp`\n+fname2=`mktemp`\n+\n+lxcpath=/var/lib/lxcsym1\n+\n+cleanup() {\n+\tlxc-destroy -P $lxcpath -f -n symtest1 || true\n+\trm -f $lxcpath\n+\trmdir $dirname || true\n+\trm -f $fname || true\n+\trm -f $fname2 || true\n+}\n+\n+trap cleanup EXIT SIGHUP SIGINT SIGTERM\n+\n+testrun() {\n+\texpected=$1\n+\trun=$2\n+\tpass=\""pass\""\n+\tlxc-start -P $lxcpath -n symtest1 -l trace -o $lxcpath/log || pass=\""fail\""\n+\t[ $pass = \""pass\"" ] && lxc-wait -P $lxcpath -n symtest1 -t 10 -s RUNNING || pass=\""fail\""\n+\tif [ \""$pass\"" != \""$expected\"" ]; then\n+\t\techo \""Test $run: expected $expected but container did not.  Start log:\""\n+\t\tcat $lxcpath/log\n+\t\techo \""FAIL: Test $run: expected $expected but container did not.\""\n+\t\tfalse\n+\tfi\n+\tlxc-stop -P $lxcpath -n symtest1 -k || true\n+}\n+\n+# make lxcpath a symlink - this should NOT cause failure\n+ln -s /var/lib/lxc $lxcpath\n+\n+lxc-destroy -P $lxcpath -f -n symtest1 || true\n+lxc-create -P $lxcpath -t busybox -n symtest1\n+\n+cat >> /var/lib/lxc/symtest1/config << EOF\n+lxc.mount.entry = $dirname opt/xxx/dir none bind,create=dir\n+lxc.mount.entry = $fname opt/xxx/file none bind,create=file\n+lxc.mount.entry = $fname2 opt/xxx/file2 none bind\n+EOF\n+\n+# Regular - should succeed\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun pass 1\n+\n+# symlink - should fail\n+rm -rf /var/lib/lxc/symtest1/rootfs/opt/xxx\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx2\n+ln -s /var/lib/lxc/symtest1/rootfs/opt/xxx2 /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun fail 2\n+\n+# final final symlink - should fail\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx/dir\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2src\n+ln -s $lxcpath/symtest1/rootfs/opt/xxx/file2src $lxcpath/symtest1/rootfs/opt/xxx/file2\n+testrun fail 3\n+\n+# Ideally we'd also try a loop device, but that won't work in nested containers\n+# anyway - TODO\n+\n+# what about /proc itself\n+\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2\n+mv $lxcpath/symtest1/rootfs/proc $lxcpath/symtest1/rootfs/proc1\n+ln -s $lxcpath/symtest1/rootfs/proc1 $lxcpath/symtest1/rootfs/proc\n+testrun fail 4\n+\n+echo \""all tests passed\""""}","static int setup_ttydir_console(const struct lxc_rootfs *rootfs,
			 const struct lxc_console *console,
			 char *ttydir)
{
	char path[MAXPATHLEN], lxcpath[MAXPATHLEN];
	int ret;

	/* create rootfs/dev/<ttydir> directory */
	ret = snprintf(path, sizeof(path), ""%s/dev/%s"", rootfs->mount,
		       ttydir);
	if (ret >= sizeof(path))
		return -1;
	ret = mkdir(path, 0755);
	if (ret && errno != EEXIST) {
		SYSERROR(""failed with errno %d to create %s"", errno, path);
		return -1;
	}
	INFO(""created %s"", path);

	ret = snprintf(lxcpath, sizeof(lxcpath), ""%s/dev/%s/console"",
		       rootfs->mount, ttydir);
	if (ret >= sizeof(lxcpath)) {
		ERROR(""console path too long"");
		return -1;
	}

	snprintf(path, sizeof(path), ""%s/dev/console"", rootfs->mount);
	ret = unlink(path);
	if (ret && errno != ENOENT) {
		SYSERROR(""error unlinking %s"", path);
		return -1;
	}

	ret = creat(lxcpath, 0660);
	if (ret==-1 && errno != EEXIST) {
		SYSERROR(""error %d creating %s"", errno, lxcpath);
		return -1;
	}
	if (ret >= 0)
		close(ret);

	if (console->master < 0) {
		INFO(""no console"");
 		return 0;
 	}
 
	if (safe_mount(console->name, lxcpath, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, lxcpath);
 		return -1;
 	}

	/* create symlink from rootfs/dev/console to 'lxc/console' */
	ret = snprintf(lxcpath, sizeof(lxcpath), ""%s/console"", ttydir);
	if (ret >= sizeof(lxcpath)) {
		ERROR(""lxc/console path too long"");
		return -1;
	}
	ret = symlink(lxcpath, path);
	if (ret) {
		SYSERROR(""failed to create symlink for console"");
		return -1;
	}

	INFO(""console has been setup on %s"", lxcpath);

	return 0;
}
","static int setup_ttydir_console(const struct lxc_rootfs *rootfs,
			 const struct lxc_console *console,
			 char *ttydir)
{
	char path[MAXPATHLEN], lxcpath[MAXPATHLEN];
	int ret;

	/* create rootfs/dev/<ttydir> directory */
	ret = snprintf(path, sizeof(path), ""%s/dev/%s"", rootfs->mount,
		       ttydir);
	if (ret >= sizeof(path))
		return -1;
	ret = mkdir(path, 0755);
	if (ret && errno != EEXIST) {
		SYSERROR(""failed with errno %d to create %s"", errno, path);
		return -1;
	}
	INFO(""created %s"", path);

	ret = snprintf(lxcpath, sizeof(lxcpath), ""%s/dev/%s/console"",
		       rootfs->mount, ttydir);
	if (ret >= sizeof(lxcpath)) {
		ERROR(""console path too long"");
		return -1;
	}

	snprintf(path, sizeof(path), ""%s/dev/console"", rootfs->mount);
	ret = unlink(path);
	if (ret && errno != ENOENT) {
		SYSERROR(""error unlinking %s"", path);
		return -1;
	}

	ret = creat(lxcpath, 0660);
	if (ret==-1 && errno != EEXIST) {
		SYSERROR(""error %d creating %s"", errno, lxcpath);
		return -1;
	}
	if (ret >= 0)
		close(ret);

	if (console->master < 0) {
		INFO(""no console"");
 		return 0;
 	}
 
	if (mount(console->name, lxcpath, ""none"", MS_BIND, 0)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, lxcpath);
 		return -1;
 	}

	/* create symlink from rootfs/dev/console to 'lxc/console' */
	ret = snprintf(lxcpath, sizeof(lxcpath), ""%s/console"", ttydir);
	if (ret >= sizeof(lxcpath)) {
		ERROR(""lxc/console path too long"");
		return -1;
	}
	ret = symlink(lxcpath, path);
	if (ret) {
		SYSERROR(""failed to create symlink for console"");
		return -1;
	}

	INFO(""console has been setup on %s"", lxcpath);

	return 0;
}
",C,"	if (safe_mount(console->name, lxcpath, ""none"", MS_BIND, 0, rootfs->mount)) {
","	if (mount(console->name, lxcpath, ""none"", MS_BIND, 0)) {
",,"@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 		 * 2.6.32...
 		 */
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/net"",                  NULL,       MS_BIND,                        NULL },
+		/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/tty"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys"",                                       ""%r/proc/sys"",                  NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sys"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
-		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/net"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
+		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/tty"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sysrq-trigger"",                             ""%r/proc/sysrq-trigger"",        NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sysrq-trigger"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha
 			}
 			mflags = add_required_remount_flags(source, destination,
 					default_mounts[i].flags);
-			r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);
+			r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);
 			saved_errno = errno;
 			if (r < 0 && errno == ENOENT) {
 				INFO(""Mount source or target for %s on %s doesn't exist. Skipping."", source, destination);
@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons
 		return 0;
 	}
 
-	if (mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"")) {
+	if (safe_mount(""none"", path, ""tmpfs"", 0, ""size=100000,mode=755"",
+				rootfs->path ? rootfs->mount : NULL)) {
 		SYSERROR(""Failed mounting tmpfs onto %s\n"", path);
 		return false;
 	}
@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)
 				return -1;
 			}
 			fclose(pathfile);
-			if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {
+			if (safe_mount(hostpath, path, 0, MS_BIND, NULL,
+						rootfs->path ? rootfs->mount : NULL) != 0) {
 				SYSERROR(""Failed bind mounting device %s from host into container"",
 					d->name);
 				return -1;
@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,
 		return -1;
 	}
 
-	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, path, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}
@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,
 		return 0;
 	}
 
-	if (mount(console->name, lxcpath, ""none"", MS_BIND, 0)) {
+	if (safe_mount(console->name, lxcpath, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, lxcpath);
 		return -1;
 	}
@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)
 
 static int mount_entry(const char *fsname, const char *target,
 		       const char *fstype, unsigned long mountflags,
-		       const char *data, int optional)
+		       const char *data, int optional, const char *rootfs)
 {
 #ifdef HAVE_STATVFS
 	struct statvfs sb;
 #endif
 
-	if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {
+	if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {
 		if (optional) {
 			INFO(""failed to mount '%s' on '%s' (optional): %s"", fsname,
 			     target, strerror(errno));
@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,
 #endif
 
 		if (mount(fsname, target, fstype,
-			  mountflags | MS_REMOUNT, data)) {
+			  mountflags | MS_REMOUNT, data) < 0) {
 			if (optional) {
 				INFO(""failed to mount '%s' on '%s' (optional): %s"",
 					 fsname, target, strerror(errno));
@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,
 }
 
 static inline int mount_entry_on_generic(struct mntent *mntent,
-                 const char* path)
+                 const char* path, const char *rootfs)
 {
 	unsigned long mntflags;
 	char *mntdata;
@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 	}
 
 	ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,
-			  mntflags, mntdata, optional);
+			  mntflags, mntdata, optional, rootfs);
 
 	free(mntdata);
 
@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,
 
 static inline int mount_entry_on_systemfs(struct mntent *mntent)
 {
-  return mount_entry_on_generic(mntent, mntent->mnt_dir);
+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);
 }
 
 static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs->mount);
 }
 
 static int mount_entry_on_relative_rootfs(struct mntent *mntent,
@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,
 		return -1;
 	}
 
-	return mount_entry_on_generic(mntent, path);
+	return mount_entry_on_generic(mntent, path, rootfs);
 }
 
 static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,
@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)
 		fclose(pathfile);
 	}
 
-	ret = mount(path, destpath, ""none"", MS_BIND, NULL);
+	ret = safe_mount(path, destpath, ""none"", MS_BIND, NULL, conf->rootfs.mount);
 	if (ret < 0)
 		SYSERROR(""Failed to bind lxc.init.static into container"");
 	INFO(""lxc.init.static bound into container at %s"", path);",lxc,592fd47a6245508b79fe6ac819fe6d3b2c1289be,f2e4dddd71d427f9cacbab4016ffe18b0e4a4a0a,1,"static int setup_ttydir_console(const struct lxc_rootfs *rootfs,
			 const struct lxc_console *console,
			 char *ttydir)
{
	char path[MAXPATHLEN], lxcpath[MAXPATHLEN];
	int ret;

	/* create rootfs/dev/<ttydir> directory */
	ret = snprintf(path, sizeof(path), ""%s/dev/%s"", rootfs->mount,
		       ttydir);
	if (ret >= sizeof(path))
		return -1;
	ret = mkdir(path, 0755);
	if (ret && errno != EEXIST) {
		SYSERROR(""failed with errno %d to create %s"", errno, path);
		return -1;
	}
	INFO(""created %s"", path);

	ret = snprintf(lxcpath, sizeof(lxcpath), ""%s/dev/%s/console"",
		       rootfs->mount, ttydir);
	if (ret >= sizeof(lxcpath)) {
		ERROR(""console path too long"");
		return -1;
	}

	snprintf(path, sizeof(path), ""%s/dev/console"", rootfs->mount);
	ret = unlink(path);
	if (ret && errno != ENOENT) {
		SYSERROR(""error unlinking %s"", path);
		return -1;
	}

	ret = creat(lxcpath, 0660);
	if (ret==-1 && errno != EEXIST) {
		SYSERROR(""error %d creating %s"", errno, lxcpath);
		return -1;
	}
	if (ret >= 0)
		close(ret);

	if (console->master < 0) {
		INFO(""no console"");
 		return 0;
 	}
 
//flaw_line_below:
	if (mount(console->name, lxcpath, ""none"", MS_BIND, 0)) {
//fix_flaw_line_below:
//	if (safe_mount(console->name, lxcpath, ""none"", MS_BIND, 0, rootfs->mount)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, lxcpath);
 		return -1;
 	}

	/* create symlink from rootfs/dev/console to 'lxc/console' */
	ret = snprintf(lxcpath, sizeof(lxcpath), ""%s/console"", ttydir);
	if (ret >= sizeof(lxcpath)) {
		ERROR(""lxc/console path too long"");
		return -1;
	}
	ret = symlink(lxcpath, path);
	if (ret) {
		SYSERROR(""failed to create symlink for console"");
		return -1;
	}

	INFO(""console has been setup on %s"", lxcpath);

	return 0;
}
"
2158,179894,,Local,Not required,Complete,CVE-2015-1335,https://www.cvedetails.com/cve/CVE-2015-1335/,CWE-59,Low,Complete,Complete,,2015-10-01,7.2,lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.,2019-05-31,,1,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,592fd47a6245508b79fe6ac819fe6d3b2c1289be,"CVE-2015-1335: Protect container mounts against symlinks

When a container starts up, lxc sets up the container's inital fstree
by doing a bunch of mounting, guided by the container configuration
file.  The container config is owned by the admin or user on the host,
so we do not try to guard against bad entries.  However, since the
mount target is in the container, it's possible that the container admin
could divert the mount with symbolic links.  This could bypass proper
container startup (i.e. confinement of a root-owned container by the
restrictive apparmor policy, by diverting the required write to
/proc/self/attr/current), or bypass the (path-based) apparmor policy
by diverting, say, /proc to /mnt in the container.

To prevent this,

1. do not allow mounts to paths containing symbolic links

2. do not allow bind mounts from relative paths containing symbolic
links.

Details:

Define safe_mount which ensures that the container has not inserted any
symbolic links into any mount targets for mounts to be done during
container setup.

The host's mount path may contain symbolic links.  As it is under the
control of the administrator, that's ok.  So safe_mount begins the check
for symbolic links after the rootfs->mount, by opening that directory.

It opens each directory along the path using openat() relative to the
parent directory using O_NOFOLLOW.  When the target is reached, it
mounts onto /proc/self/fd/<targetfd>.

Use safe_mount() in mount_entry(), when mounting container proc,
and when needed.  In particular, safe_mount() need not be used in
any case where:

1. the mount is done in the container's namespace
2. the mount is for the container's rootfs
3. the mount is relative to a tmpfs or proc/sysfs which we have
   just safe_mount()ed ourselves

Since we were using proc/net as a temporary placeholder for /proc/sys/net
during container startup, and proc/net is a symbolic link, use proc/tty
instead.

Update the lxc.container.conf manpage with details about the new
restrictions.

Finally, add a testcase to test some symbolic link possibilities.

Reported-by: Roman Fiedler
Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Acked-by: Stphane Graber <stgraber@ubuntu.com>",1,src/lxc/utils.c,"{""sha"": ""eb3241f795d2f3e0f1fb762516983b74e99af52f"", ""filename"": ""doc/lxc.container.conf.sgml.in"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/doc/lxc.container.conf.sgml.in"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/doc/lxc.container.conf.sgml.in?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -760,6 +760,18 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n         container. This is useful to mount /etc, /var or /home for\n         examples.\n       </para>\n+      <para>\n+\tNOTE - LXC will generally ensure that mount targets and relative\n+\tbind-mount sources are properly confined under the container\n+\troot, to avoid attacks involving over-mounting host directories\n+\tand files.  (Symbolic links in absolute mount sources are ignored)\n+\tHowever, if the container configuration first mounts a directory which\n+\tis under the control of the container user, such as /home/joe, into\n+        the container at some <filename>path</filename>, and then mounts\n+        under <filename>path</filename>, then a TOCTTOU attack would be\n+        possible where the container user modifies a symbolic link under\n+        his home directory at just the right time.\n+      </para>\n       <variablelist>\n         <varlistentry>\n           <term>""}<_**next**_>{""sha"": ""df2e6b2333bc81f94bf7583087475fd8d62605a1"", ""filename"": ""src/lxc/cgfs.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgfs.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgfs.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1363,7 +1363,10 @@ static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \""%s/sys/fs/cgroup\"", root);\n-\tr = mount(\""cgroup_root\"", path, \""tmpfs\"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \""size=10240k,mode=755\"");\n+\tr = safe_mount(\""cgroup_root\"", path, \""tmpfs\"",\n+\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n+\t\t\t\""size=10240k,mode=755\"",\n+\t\t\troot);\n \tif (r < 0) {\n \t\tSYSERROR(\""could not mount tmpfs to /sys/fs/cgroup in the container\"");\n \t\treturn false;""}<_**next**_>{""sha"": ""a677c22c768eccccaa3af386c662c43dad8412cf"", ""filename"": ""src/lxc/cgmanager.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/cgmanager.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/cgmanager.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1477,7 +1477,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t}\n \n \t/* mount a tmpfs there so we can create subdirs */\n-\tif (mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"")) {\n+\tif (safe_mount(\""cgroup\"", cgpath, \""tmpfs\"", 0, \""size=10000,mode=755\"", root)) {\n \t\tSYSERROR(\""Failed to mount tmpfs at %s\"", cgpath);\n \t\treturn false;\n \t}\n@@ -1488,7 +1488,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t\treturn false;\n \t}\n \n-\tif (mount(dirname, cgpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(dirname, cgpath, \""none\"", MS_BIND, 0, root)) {\n \t\tSYSERROR(\""Failed to bind mount %s to %s\"", dirname, cgpath);\n \t\treturn false;\n \t}""}<_**next**_>{""sha"": ""bb4c19f82e2c806b07125cbfd9ed3220df07be38"", ""filename"": ""src/lxc/conf.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 16, ""changes"": 35, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/conf.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/conf.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t * 2.6.32...\n \t\t */\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/net\"",                  NULL,       MS_BIND,                        NULL },\n+\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys/net\"",                                   \""%r/proc/tty\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sys\"",                                       \""%r/proc/sys\"",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sys\"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/net\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/tty\"",                                       \""%r/proc/sys/net\"",              NULL,       MS_MOVE,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \""%r/proc/sysrq-trigger\"",                             \""%r/proc/sysrq-trigger\"",        NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \""%r/proc/sysrq-trigger\"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \""proc\"",                                              \""%r/proc\"",                      \""proc\"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t\t}\n \t\t\tmflags = add_required_remount_flags(source, destination,\n \t\t\t\t\tdefault_mounts[i].flags);\n-\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n+\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n \t\t\tsaved_errno = errno;\n \t\t\tif (r < 0 && errno == ENOENT) {\n \t\t\t\tINFO(\""Mount source or target for %s on %s doesn't exist. Skipping.\"", source, destination);\n@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons\n \t\treturn 0;\n \t}\n \n-\tif (mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"")) {\n+\tif (safe_mount(\""none\"", path, \""tmpfs\"", 0, \""size=100000,mode=755\"",\n+\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n \t\tSYSERROR(\""Failed mounting tmpfs onto %s\\n\"", path);\n \t\treturn false;\n \t}\n@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tfclose(pathfile);\n-\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n+\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n+\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n \t\t\t\tSYSERROR(\""Failed bind mounting device %s from host into container\"",\n \t\t\t\t\td->name);\n \t\t\t\treturn -1;\n@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,\n \t\treturn -1;\n \t}\n \n-\tif (mount(console->name, path, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, path, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, path);\n \t\treturn -1;\n \t}\n@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n \t\treturn 0;\n \t}\n \n-\tif (mount(console->name, lxcpath, \""none\"", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, lxcpath, \""none\"", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\""failed to mount '%s' on '%s'\"", console->name, lxcpath);\n \t\treturn -1;\n \t}\n@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)\n \n static int mount_entry(const char *fsname, const char *target,\n \t\t       const char *fstype, unsigned long mountflags,\n-\t\t       const char *data, int optional)\n+\t\t       const char *data, int optional, const char *rootfs)\n {\n #ifdef HAVE_STATVFS\n \tstruct statvfs sb;\n #endif\n \n-\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n+\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n \t\tif (optional) {\n \t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"", fsname,\n \t\t\t     target, strerror(errno));\n@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,\n #endif\n \n \t\tif (mount(fsname, target, fstype,\n-\t\t\t  mountflags | MS_REMOUNT, data)) {\n+\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n \t\t\tif (optional) {\n \t\t\t\tINFO(\""failed to mount '%s' on '%s' (optional): %s\"",\n \t\t\t\t\t fsname, target, strerror(errno));\n@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,\n }\n \n static inline int mount_entry_on_generic(struct mntent *mntent,\n-                 const char* path)\n+                 const char* path, const char *rootfs)\n {\n \tunsigned long mntflags;\n \tchar *mntdata;\n@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \t}\n \n \tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n-\t\t\t  mntflags, mntdata, optional);\n+\t\t\t  mntflags, mntdata, optional, rootfs);\n \n \tfree(mntdata);\n \n@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \n static inline int mount_entry_on_systemfs(struct mntent *mntent)\n {\n-  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n }\n \n static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n }\n \n static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs);\n }\n \n static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \""none\"", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \""none\"", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\""Failed to bind lxc.init.static into container\"");\n \tINFO(\""lxc.init.static bound into container at %s\"", path);""}<_**next**_>{""sha"": ""788cbe136302bb46a559c36dc45a895f8c584574"", ""filename"": ""src/lxc/utils.c"", ""status"": ""modified"", ""additions"": 234, ""deletions"": 1, ""changes"": 235, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.c?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -1404,6 +1404,239 @@ int setproctitle(char *title)\n \treturn ret;\n }\n \n+/*\n+ * @path:    a pathname where / replaced with '\\0'.\n+ * @offsetp: pointer to int showing which path segment was last seen.\n+ *           Updated on return to reflect the next segment.\n+ * @fulllen: full original path length.\n+ * Returns a pointer to the next path segment, or NULL if done.\n+ */\n+static char *get_nextpath(char *path, int *offsetp, int fulllen)\n+{\n+\tint offset = *offsetp;\n+\n+\tif (offset >= fulllen)\n+\t\treturn NULL;\n+\n+\twhile (path[offset] != '\\0' && offset < fulllen)\n+\t\toffset++;\n+\twhile (path[offset] == '\\0' && offset < fulllen)\n+\t\toffset++;\n+\n+\t*offsetp = offset;\n+\treturn (offset < fulllen) ? &path[offset] : NULL;\n+}\n+\n+/*\n+ * Check that @subdir is a subdir of @dir.  @len is the length of\n+ * @dir (to avoid having to recalculate it).\n+ */\n+static bool is_subdir(const char *subdir, const char *dir, size_t len)\n+{\n+\tsize_t subdirlen = strlen(subdir);\n+\n+\tif (subdirlen < len)\n+\t\treturn false;\n+\tif (strncmp(subdir, dir, len) != 0)\n+\t\treturn false;\n+\tif (dir[len-1] == '/')\n+\t\treturn true;\n+\tif (subdir[len] == '/' || subdirlen == len)\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+/*\n+ * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return\n+ * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.\n+ */\n+static int check_symlink(int fd)\n+{\n+\tstruct stat sb;\n+\tint ret = fstat(fd, &sb);\n+\tif (ret < 0)\n+\t\treturn -ENOENT;\n+\tif (S_ISLNK(sb.st_mode))\n+\t\treturn -ELOOP;\n+\treturn 0;\n+}\n+\n+/*\n+ * Open a file or directory, provided that it contains no symlinks.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+static int open_if_safe(int dirfd, const char *nextpath)\n+{\n+\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n+\tif (newfd >= 0) // was not a symlink, all good\n+\t\treturn newfd;\n+\n+\tif (errno == ELOOP)\n+\t\treturn newfd;\n+\n+\tif (errno == EPERM || errno == EACCES) {\n+\t\t/* we're not root (cause we got EPERM) so\n+\t\t   try opening with O_PATH */\n+\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n+\t\tif (newfd >= 0) {\n+\t\t\t/* O_PATH will return an fd for symlinks.  We know\n+\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n+\t\t\t * is now a link, then something * fishy is going on\n+\t\t\t */\n+\t\t\tint ret = check_symlink(newfd);\n+\t\t\tif (ret < 0) {\n+\t\t\t\tclose(newfd);\n+\t\t\t\tnewfd = ret;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newfd;\n+}\n+\n+/*\n+ * Open a path intending for mounting, ensuring that the final path\n+ * is inside the container's rootfs.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ *\n+ * @target: path to be opened\n+ * @prefix_skip: a part of @target in which to ignore symbolic links.  This\n+ * would be the container's rootfs.\n+ *\n+ * Return an open fd for the path, or <0 on error.\n+ */\n+static int open_without_symlink(const char *target, const char *prefix_skip)\n+{\n+\tint curlen = 0, dirfd, fulllen, i;\n+\tchar *dup = NULL;\n+\n+\tfulllen = strlen(target);\n+\n+\t/* make sure prefix-skip makes sense */\n+\tif (prefix_skip) {\n+\t\tcurlen = strlen(prefix_skip);\n+\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n+\t\t\tERROR(\""WHOA there - target '%s' didn't start with prefix '%s'\"",\n+\t\t\t\ttarget, prefix_skip);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\t/*\n+\t\t * get_nextpath() expects the curlen argument to be\n+\t\t * on a  (turned into \\0) / or before it, so decrement\n+\t\t * curlen to make sure that happens\n+\t\t */\n+\t\tif (curlen)\n+\t\t\tcurlen--;\n+\t} else {\n+\t\tprefix_skip = \""/\"";\n+\t\tcurlen = 0;\n+\t}\n+\n+\t/* Make a copy of target which we can hack up, and tokenize it */\n+\tif ((dup = strdup(target)) == NULL) {\n+\t\tSYSERROR(\""Out of memory checking for symbolic link\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\tfor (i = 0; i < fulllen; i++) {\n+\t\tif (dup[i] == '/')\n+\t\t\tdup[i] = '\\0';\n+\t}\n+\n+\tdirfd = open(prefix_skip, O_RDONLY);\n+\tif (dirfd < 0)\n+\t\tgoto out;\n+\twhile (1) {\n+\t\tint newfd, saved_errno;\n+\t\tchar *nextpath;\n+\n+\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n+\t\t\tgoto out;\n+\t\tnewfd = open_if_safe(dirfd, nextpath);\n+\t\tsaved_errno = errno;\n+\t\tclose(dirfd);\n+\t\tdirfd = newfd;\n+\t\tif (newfd < 0) {\n+\t\t\terrno = saved_errno;\n+\t\t\tif (errno == ELOOP)\n+\t\t\t\tSYSERROR(\""%s in %s was a symbolic link!\"", nextpath, target);\n+\t\t\telse\n+\t\t\t\tSYSERROR(\""Error examining %s in %s\"", nextpath, target);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+out:\n+\tfree(dup);\n+\treturn dirfd;\n+}\n+\n+/*\n+ * Safely mount a path into a container, ensuring that the mount target\n+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container\n+ * uses the host's /)\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs)\n+{\n+\tint srcfd = -1, destfd, ret, saved_errno;\n+\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n+\tconst char *mntsrc = src;\n+\n+\tif (!rootfs)\n+\t\trootfs = \""\"";\n+\n+\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n+\tif (flags & MS_BIND && src && src[0] != '/') {\n+\t\tINFO(\""this is a relative bind mount\"");\n+\t\tsrcfd = open_without_symlink(src, NULL);\n+\t\tif (srcfd < 0)\n+\t\t\treturn srcfd;\n+\t\tret = snprintf(srcbuf, 50, \""/proc/self/fd/%d\"", srcfd);\n+\t\tif (ret < 0 || ret > 50) {\n+\t\t\tclose(srcfd);\n+\t\t\tERROR(\""Out of memory\"");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tmntsrc = srcbuf;\n+\t}\n+\n+\tdestfd = open_without_symlink(dest, rootfs);\n+\tif (destfd < 0) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\treturn destfd;\n+\t}\n+\n+\tret = snprintf(destbuf, 50, \""/proc/self/fd/%d\"", destfd);\n+\tif (ret < 0 || ret > 50) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\tclose(destfd);\n+\t\tERROR(\""Out of memory\"");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tret = mount(mntsrc, destbuf, fstype, flags, data);\n+\tsaved_errno = errno;\n+\tif (srcfd != -1)\n+\t\tclose(srcfd);\n+\tclose(destfd);\n+\tif (ret < 0) {\n+\t\terrno = saved_errno;\n+\t\tSYSERROR(\""Failed to mount %s onto %s\"", src, dest);\n+\t\treturn ret;\n+\t}\n+\n+\treturn 0;\n+}\n+\n /*\n  * Mount a proc under @rootfs if proc self points to a pid other than\n  * my own.  This is needed to have a known-good proc mount for setting\n@@ -1446,7 +1679,7 @@ int mount_proc_if_needed(const char *rootfs)\n \treturn 0;\n \n domount:\n-\tif (mount(\""proc\"", path, \""proc\"", 0, NULL))\n+\tif (safe_mount(\""proc\"", path, \""proc\"", 0, NULL, rootfs) < 0)\n \t\treturn -1;\n \tINFO(\""Mounted /proc in container for security transition\"");\n \treturn 1;""}<_**next**_>{""sha"": ""059026f0154b1713854c84674d12954a09469506"", ""filename"": ""src/lxc/utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/lxc/utils.h"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/utils.h?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -279,6 +279,8 @@ bool switch_to_ns(pid_t pid, const char *ns);\n int is_dir(const char *path);\n char *get_template_path(const char *t);\n int setproctitle(char *title);\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs);\n int mount_proc_if_needed(const char *rootfs);\n int null_stdfds(void);\n #endif /* __LXC_UTILS_H */""}<_**next**_>{""sha"": ""462d4f27882715442c3183b9db6620430b767455"", ""filename"": ""src/tests/Makefile.am"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/Makefile.am?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -55,6 +55,7 @@ bin_SCRIPTS += \\\n \tlxc-test-apparmor-mount \\\n \tlxc-test-checkpoint-restore \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tlxc-test-usernic\n@@ -82,6 +83,7 @@ EXTRA_DIST = \\\n \tlxc-test-cloneconfig \\\n \tlxc-test-createconfig \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tmay_control.c \\""}<_**next**_>{""sha"": ""37320f0dfd96b262d52bc99e314b7fe3cb026bb1"", ""filename"": ""src/tests/lxc-test-symlink"", ""status"": ""added"", ""additions"": 88, ""deletions"": 0, ""changes"": 88, ""blob_url"": ""https://github.com/lxc/lxc/blob/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""raw_url"": ""https://github.com/lxc/lxc/raw/592fd47a6245508b79fe6ac819fe6d3b2c1289be/src/tests/lxc-test-symlink"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/lxc-test-symlink?ref=592fd47a6245508b79fe6ac819fe6d3b2c1289be"", ""patch"": ""@@ -0,0 +1,88 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+# lxc: linux Container library\n+\n+# Authors:\n+# Serge Hallyn <serge.hallyn@ubuntu.com>\n+#\n+# This is a regression test for symbolic links\n+\n+dirname=`mktemp -d`\n+fname=`mktemp`\n+fname2=`mktemp`\n+\n+lxcpath=/var/lib/lxcsym1\n+\n+cleanup() {\n+\tlxc-destroy -P $lxcpath -f -n symtest1 || true\n+\trm -f $lxcpath\n+\trmdir $dirname || true\n+\trm -f $fname || true\n+\trm -f $fname2 || true\n+}\n+\n+trap cleanup EXIT SIGHUP SIGINT SIGTERM\n+\n+testrun() {\n+\texpected=$1\n+\trun=$2\n+\tpass=\""pass\""\n+\tlxc-start -P $lxcpath -n symtest1 -l trace -o $lxcpath/log || pass=\""fail\""\n+\t[ $pass = \""pass\"" ] && lxc-wait -P $lxcpath -n symtest1 -t 10 -s RUNNING || pass=\""fail\""\n+\tif [ \""$pass\"" != \""$expected\"" ]; then\n+\t\techo \""Test $run: expected $expected but container did not.  Start log:\""\n+\t\tcat $lxcpath/log\n+\t\techo \""FAIL: Test $run: expected $expected but container did not.\""\n+\t\tfalse\n+\tfi\n+\tlxc-stop -P $lxcpath -n symtest1 -k || true\n+}\n+\n+# make lxcpath a symlink - this should NOT cause failure\n+ln -s /var/lib/lxc $lxcpath\n+\n+lxc-destroy -P $lxcpath -f -n symtest1 || true\n+lxc-create -P $lxcpath -t busybox -n symtest1\n+\n+cat >> /var/lib/lxc/symtest1/config << EOF\n+lxc.mount.entry = $dirname opt/xxx/dir none bind,create=dir\n+lxc.mount.entry = $fname opt/xxx/file none bind,create=file\n+lxc.mount.entry = $fname2 opt/xxx/file2 none bind\n+EOF\n+\n+# Regular - should succeed\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun pass 1\n+\n+# symlink - should fail\n+rm -rf /var/lib/lxc/symtest1/rootfs/opt/xxx\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx2\n+ln -s /var/lib/lxc/symtest1/rootfs/opt/xxx2 /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun fail 2\n+\n+# final final symlink - should fail\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx/dir\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2src\n+ln -s $lxcpath/symtest1/rootfs/opt/xxx/file2src $lxcpath/symtest1/rootfs/opt/xxx/file2\n+testrun fail 3\n+\n+# Ideally we'd also try a loop device, but that won't work in nested containers\n+# anyway - TODO\n+\n+# what about /proc itself\n+\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2\n+mv $lxcpath/symtest1/rootfs/proc $lxcpath/symtest1/rootfs/proc1\n+ln -s $lxcpath/symtest1/rootfs/proc1 $lxcpath/symtest1/rootfs/proc\n+testrun fail 4\n+\n+echo \""all tests passed\""""}","int mount_proc_if_needed(const char *rootfs)
{
	char path[MAXPATHLEN];
	char link[20];
	int linklen, ret;
	int mypid;

	ret = snprintf(path, MAXPATHLEN, ""%s/proc/self"", rootfs);
	if (ret < 0 || ret >= MAXPATHLEN) {
		SYSERROR(""proc path name too long"");
		return -1;
	}
	memset(link, 0, 20);
	linklen = readlink(path, link, 20);
	mypid = (int)getpid();
	INFO(""I am %d, /proc/self points to '%s'"", mypid, link);
	ret = snprintf(path, MAXPATHLEN, ""%s/proc"", rootfs);
	if (ret < 0 || ret >= MAXPATHLEN) {
		SYSERROR(""proc path name too long"");
		return -1;
	}
	if (linklen < 0) /* /proc not mounted */
		goto domount;
	if (atoi(link) != mypid) {
		/* wrong /procs mounted */
		umount2(path, MNT_DETACH); /* ignore failure */
		goto domount;
	}
	/* the right proc is already mounted */
 	return 0;
 
 domount:
	if (safe_mount(""proc"", path, ""proc"", 0, NULL, rootfs) < 0)
 		return -1;
 	INFO(""Mounted /proc in container for security transition"");
 	return 1;
}
","int mount_proc_if_needed(const char *rootfs)
{
	char path[MAXPATHLEN];
	char link[20];
	int linklen, ret;
	int mypid;

	ret = snprintf(path, MAXPATHLEN, ""%s/proc/self"", rootfs);
	if (ret < 0 || ret >= MAXPATHLEN) {
		SYSERROR(""proc path name too long"");
		return -1;
	}
	memset(link, 0, 20);
	linklen = readlink(path, link, 20);
	mypid = (int)getpid();
	INFO(""I am %d, /proc/self points to '%s'"", mypid, link);
	ret = snprintf(path, MAXPATHLEN, ""%s/proc"", rootfs);
	if (ret < 0 || ret >= MAXPATHLEN) {
		SYSERROR(""proc path name too long"");
		return -1;
	}
	if (linklen < 0) /* /proc not mounted */
		goto domount;
	if (atoi(link) != mypid) {
		/* wrong /procs mounted */
		umount2(path, MNT_DETACH); /* ignore failure */
		goto domount;
	}
	/* the right proc is already mounted */
 	return 0;
 
 domount:
	if (mount(""proc"", path, ""proc"", 0, NULL))
 		return -1;
 	INFO(""Mounted /proc in container for security transition"");
 	return 1;
}
",C,"	if (safe_mount(""proc"", path, ""proc"", 0, NULL, rootfs) < 0)
","	if (mount(""proc"", path, ""proc"", 0, NULL))
",,"@@ -1404,6 +1404,239 @@ int setproctitle(char *title)
 	return ret;
 }
 
+/*
+ * @path:    a pathname where / replaced with '\0'.
+ * @offsetp: pointer to int showing which path segment was last seen.
+ *           Updated on return to reflect the next segment.
+ * @fulllen: full original path length.
+ * Returns a pointer to the next path segment, or NULL if done.
+ */
+static char *get_nextpath(char *path, int *offsetp, int fulllen)
+{
+	int offset = *offsetp;
+
+	if (offset >= fulllen)
+		return NULL;
+
+	while (path[offset] != '\0' && offset < fulllen)
+		offset++;
+	while (path[offset] == '\0' && offset < fulllen)
+		offset++;
+
+	*offsetp = offset;
+	return (offset < fulllen) ? &path[offset] : NULL;
+}
+
+/*
+ * Check that @subdir is a subdir of @dir.  @len is the length of
+ * @dir (to avoid having to recalculate it).
+ */
+static bool is_subdir(const char *subdir, const char *dir, size_t len)
+{
+	size_t subdirlen = strlen(subdir);
+
+	if (subdirlen < len)
+		return false;
+	if (strncmp(subdir, dir, len) != 0)
+		return false;
+	if (dir[len-1] == '/')
+		return true;
+	if (subdir[len] == '/' || subdirlen == len)
+		return true;
+	return false;
+}
+
+/*
+ * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return
+ * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.
+ */
+static int check_symlink(int fd)
+{
+	struct stat sb;
+	int ret = fstat(fd, &sb);
+	if (ret < 0)
+		return -ENOENT;
+	if (S_ISLNK(sb.st_mode))
+		return -ELOOP;
+	return 0;
+}
+
+/*
+ * Open a file or directory, provided that it contains no symlinks.
+ *
+ * CAVEAT: This function must not be used for other purposes than container
+ * setup before executing the container's init
+ */
+static int open_if_safe(int dirfd, const char *nextpath)
+{
+	int newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);
+	if (newfd >= 0) // was not a symlink, all good
+		return newfd;
+
+	if (errno == ELOOP)
+		return newfd;
+
+	if (errno == EPERM || errno == EACCES) {
+		/* we're not root (cause we got EPERM) so
+		   try opening with O_PATH */
+		newfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);
+		if (newfd >= 0) {
+			/* O_PATH will return an fd for symlinks.  We know
+			 * nextpath wasn't a symlink at last openat, so if fd
+			 * is now a link, then something * fishy is going on
+			 */
+			int ret = check_symlink(newfd);
+			if (ret < 0) {
+				close(newfd);
+				newfd = ret;
+			}
+		}
+	}
+
+	return newfd;
+}
+
+/*
+ * Open a path intending for mounting, ensuring that the final path
+ * is inside the container's rootfs.
+ *
+ * CAVEAT: This function must not be used for other purposes than container
+ * setup before executing the container's init
+ *
+ * @target: path to be opened
+ * @prefix_skip: a part of @target in which to ignore symbolic links.  This
+ * would be the container's rootfs.
+ *
+ * Return an open fd for the path, or <0 on error.
+ */
+static int open_without_symlink(const char *target, const char *prefix_skip)
+{
+	int curlen = 0, dirfd, fulllen, i;
+	char *dup = NULL;
+
+	fulllen = strlen(target);
+
+	/* make sure prefix-skip makes sense */
+	if (prefix_skip) {
+		curlen = strlen(prefix_skip);
+		if (!is_subdir(target, prefix_skip, curlen)) {
+			ERROR(""WHOA there - target '%s' didn't start with prefix '%s'"",
+				target, prefix_skip);
+			return -EINVAL;
+		}
+		/*
+		 * get_nextpath() expects the curlen argument to be
+		 * on a  (turned into \0) / or before it, so decrement
+		 * curlen to make sure that happens
+		 */
+		if (curlen)
+			curlen--;
+	} else {
+		prefix_skip = ""/"";
+		curlen = 0;
+	}
+
+	/* Make a copy of target which we can hack up, and tokenize it */
+	if ((dup = strdup(target)) == NULL) {
+		SYSERROR(""Out of memory checking for symbolic link"");
+		return -ENOMEM;
+	}
+	for (i = 0; i < fulllen; i++) {
+		if (dup[i] == '/')
+			dup[i] = '\0';
+	}
+
+	dirfd = open(prefix_skip, O_RDONLY);
+	if (dirfd < 0)
+		goto out;
+	while (1) {
+		int newfd, saved_errno;
+		char *nextpath;
+
+		if ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)
+			goto out;
+		newfd = open_if_safe(dirfd, nextpath);
+		saved_errno = errno;
+		close(dirfd);
+		dirfd = newfd;
+		if (newfd < 0) {
+			errno = saved_errno;
+			if (errno == ELOOP)
+				SYSERROR(""%s in %s was a symbolic link!"", nextpath, target);
+			else
+				SYSERROR(""Error examining %s in %s"", nextpath, target);
+			goto out;
+		}
+	}
+
+out:
+	free(dup);
+	return dirfd;
+}
+
+/*
+ * Safely mount a path into a container, ensuring that the mount target
+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container
+ * uses the host's /)
+ *
+ * CAVEAT: This function must not be used for other purposes than container
+ * setup before executing the container's init
+ */
+int safe_mount(const char *src, const char *dest, const char *fstype,
+		unsigned long flags, const void *data, const char *rootfs)
+{
+	int srcfd = -1, destfd, ret, saved_errno;
+	char srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>
+	const char *mntsrc = src;
+
+	if (!rootfs)
+		rootfs = """";
+
+	/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */
+	if (flags & MS_BIND && src && src[0] != '/') {
+		INFO(""this is a relative bind mount"");
+		srcfd = open_without_symlink(src, NULL);
+		if (srcfd < 0)
+			return srcfd;
+		ret = snprintf(srcbuf, 50, ""/proc/self/fd/%d"", srcfd);
+		if (ret < 0 || ret > 50) {
+			close(srcfd);
+			ERROR(""Out of memory"");
+			return -EINVAL;
+		}
+		mntsrc = srcbuf;
+	}
+
+	destfd = open_without_symlink(dest, rootfs);
+	if (destfd < 0) {
+		if (srcfd != -1)
+			close(srcfd);
+		return destfd;
+	}
+
+	ret = snprintf(destbuf, 50, ""/proc/self/fd/%d"", destfd);
+	if (ret < 0 || ret > 50) {
+		if (srcfd != -1)
+			close(srcfd);
+		close(destfd);
+		ERROR(""Out of memory"");
+		return -EINVAL;
+	}
+
+	ret = mount(mntsrc, destbuf, fstype, flags, data);
+	saved_errno = errno;
+	if (srcfd != -1)
+		close(srcfd);
+	close(destfd);
+	if (ret < 0) {
+		errno = saved_errno;
+		SYSERROR(""Failed to mount %s onto %s"", src, dest);
+		return ret;
+	}
+
+	return 0;
+}
+
 /*
  * Mount a proc under @rootfs if proc self points to a pid other than
  * my own.  This is needed to have a known-good proc mount for setting
@@ -1446,7 +1679,7 @@ int mount_proc_if_needed(const char *rootfs)
 	return 0;
 
 domount:
-	if (mount(""proc"", path, ""proc"", 0, NULL))
+	if (safe_mount(""proc"", path, ""proc"", 0, NULL, rootfs) < 0)
 		return -1;
 	INFO(""Mounted /proc in container for security transition"");
 	return 1;",lxc,592fd47a6245508b79fe6ac819fe6d3b2c1289be,f2e4dddd71d427f9cacbab4016ffe18b0e4a4a0a,1,"int mount_proc_if_needed(const char *rootfs)
{
	char path[MAXPATHLEN];
	char link[20];
	int linklen, ret;
	int mypid;

	ret = snprintf(path, MAXPATHLEN, ""%s/proc/self"", rootfs);
	if (ret < 0 || ret >= MAXPATHLEN) {
		SYSERROR(""proc path name too long"");
		return -1;
	}
	memset(link, 0, 20);
	linklen = readlink(path, link, 20);
	mypid = (int)getpid();
	INFO(""I am %d, /proc/self points to '%s'"", mypid, link);
	ret = snprintf(path, MAXPATHLEN, ""%s/proc"", rootfs);
	if (ret < 0 || ret >= MAXPATHLEN) {
		SYSERROR(""proc path name too long"");
		return -1;
	}
	if (linklen < 0) /* /proc not mounted */
		goto domount;
	if (atoi(link) != mypid) {
		/* wrong /procs mounted */
		umount2(path, MNT_DETACH); /* ignore failure */
		goto domount;
	}
	/* the right proc is already mounted */
 	return 0;
 
 domount:
//flaw_line_below:
	if (mount(""proc"", path, ""proc"", 0, NULL))
//fix_flaw_line_below:
//	if (safe_mount(""proc"", path, ""proc"", 0, NULL, rootfs) < 0)
 		return -1;
 	INFO(""Mounted /proc in container for security transition"");
 	return 1;
}
"
2161,179897,,Local,Not required,,CVE-2015-1331,https://www.cvedetails.com/cve/CVE-2015-1331/,CWE-59,Low,,Complete,,2015-08-12,4.9,lxclock.c in LXC 1.1.2 and earlier allows local users to create arbitrary files via a symlink attack on /run/lock/lxc/*.,2019-05-31,,10,https://github.com/lxc/lxc/commit/72cf81f6a3404e35028567db2c99a90406e9c6e6,72cf81f6a3404e35028567db2c99a90406e9c6e6,"CVE-2015-1331: lxclock: use /run/lxc/lock rather than /run/lock/lxc

This prevents an unprivileged user to use LXC to create arbitrary file
on the filesystem.

Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
Acked-by: Stphane Graber <stgraber@ubuntu.com>",36,src/lxc/lxclock.c,"{""sha"": ""e9e95f7a01d924f824c9a127cd624802c6ed5265"", ""filename"": ""src/lxc/lxclock.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 37, ""changes"": 47, ""blob_url"": ""https://github.com/lxc/lxc/blob/72cf81f6a3404e35028567db2c99a90406e9c6e6/src/lxc/lxclock.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/72cf81f6a3404e35028567db2c99a90406e9c6e6/src/lxc/lxclock.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/lxclock.c?ref=72cf81f6a3404e35028567db2c99a90406e9c6e6"", ""patch"": ""@@ -103,13 +103,13 @@ static char *lxclock_name(const char *p, const char *n)\n \tchar *rundir;\n \n \t/* lockfile will be:\n-\t * \""/run\"" + \""/lock/lxc/$lxcpath/$lxcname + '\\0' if root\n+\t * \""/run\"" + \""/lxc/lock/$lxcpath/$lxcname + '\\0' if root\n \t * or\n-\t * $XDG_RUNTIME_DIR + \""/lock/lxc/$lxcpath/$lxcname + '\\0' if non-root\n+\t * $XDG_RUNTIME_DIR + \""/lxc/lock/$lxcpath/$lxcname + '\\0' if non-root\n \t */\n \n-\t/* length of \""/lock/lxc/\"" + $lxcpath + \""/\"" + \"".\"" + $lxcname + '\\0' */\n-\tlen = strlen(\""/lock/lxc/\"") + strlen(n) + strlen(p) + 3;\n+\t/* length of \""/lxc/lock/\"" + $lxcpath + \""/\"" + \"".\"" + $lxcname + '\\0' */\n+\tlen = strlen(\""/lxc/lock/\"") + strlen(n) + strlen(p) + 3;\n \trundir = get_rundir();\n \tif (!rundir)\n \t\treturn NULL;\n@@ -120,48 +120,21 @@ static char *lxclock_name(const char *p, const char *n)\n \t\treturn NULL;\n \t}\n \n-\tret = snprintf(dest, len, \""%s/lock/lxc/%s\"", rundir, p);\n+\tret = snprintf(dest, len, \""%s/lxc/lock/%s\"", rundir, p);\n \tif (ret < 0 || ret >= len) {\n \t\tfree(dest);\n \t\tfree(rundir);\n \t\treturn NULL;\n \t}\n \tret = mkdir_p(dest, 0755);\n \tif (ret < 0) {\n-\t\t/* fall back to \""/tmp/\"" + $(id -u) + \""/lxc\"" + $lxcpath + \""/\"" + \"".\"" + $lxcname + '\\0'\n-\t\t * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)\n-\t\t * * lxcpath always starts with '/'\n-\t\t */\n-\t\tint l2 = 22 + strlen(n) + strlen(p);\n-\t\tif (l2 > len) {\n-\t\t\tchar *d;\n-\t\t\td = realloc(dest, l2);\n-\t\t\tif (!d) {\n-\t\t\t\tfree(dest);\n-\t\t\t\tfree(rundir);\n-\t\t\t\treturn NULL;\n-\t\t\t}\n-\t\t\tlen = l2;\n-\t\t\tdest = d;\n-\t\t}\n-\t\tret = snprintf(dest, len, \""/tmp/%d/lxc%s\"", geteuid(), p);\n-\t\tif (ret < 0 || ret >= len) {\n-\t\t\tfree(dest);\n-\t\t\tfree(rundir);\n-\t\t\treturn NULL;\n-\t\t}\n-\t\tret = mkdir_p(dest, 0755);\n-\t\tif (ret < 0) {\n-\t\t\tfree(dest);\n-\t\t\tfree(rundir);\n-\t\t\treturn NULL;\n-\t\t}\n-\t\tret = snprintf(dest, len, \""/tmp/%d/lxc%s/.%s\"", geteuid(), p, n);\n-\t} else\n-\t\tret = snprintf(dest, len, \""%s/lock/lxc/%s/.%s\"", rundir, p, n);\n+\t\tfree(dest);\n+\t\tfree(rundir);\n+\t\treturn NULL;\n+\t}\n \n+\tret = snprintf(dest, len, \""%s/lxc/lock/%s/.%s\"", rundir, p, n);\n \tfree(rundir);\n-\n \tif (ret < 0 || ret >= len) {\n \t\tfree(dest);\n \t\treturn NULL;""}<_**next**_>{""sha"": ""233ca127c6dec567e775abbbb0ef9ce0ed417e43"", ""filename"": ""src/tests/locktests.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/72cf81f6a3404e35028567db2c99a90406e9c6e6/src/tests/locktests.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/72cf81f6a3404e35028567db2c99a90406e9c6e6/src/tests/locktests.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/locktests.c?ref=72cf81f6a3404e35028567db2c99a90406e9c6e6"", ""patch"": ""@@ -122,7 +122,7 @@ int main(int argc, char *argv[])\n \t\texit(1);\n \t}\n \tstruct stat sb;\n-\tchar *pathname = RUNTIME_PATH \""/lock/lxc/var/lib/lxc/\"";\n+\tchar *pathname = RUNTIME_PATH \""/lxc/lock/var/lib/lxc/\"";\n \tret = stat(pathname, &sb);\n \tif (ret != 0) {\n \t\tfprintf(stderr, \""%d: filename %s not created\\n\"", __LINE__,""}","static char *lxclock_name(const char *p, const char *n)
{
	int ret;
	int len;
	char *dest;
 	char *rundir;
 
 	/* lockfile will be:
	 * ""/run"" + ""/lxc/lock/$lxcpath/$lxcname + '\0' if root
 	 * or
	 * $XDG_RUNTIME_DIR + ""/lxc/lock/$lxcpath/$lxcname + '\0' if non-root
 	 */
 
	/* length of ""/lxc/lock/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
	len += strlen(rundir);

	if ((dest = malloc(len)) == NULL) {
		free(rundir);
 		return NULL;
 	}
 
	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
		free(dest);
		free(rundir);
		return NULL;
	}
 
	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
 	free(rundir);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;
	}
	return dest;
}
","static char *lxclock_name(const char *p, const char *n)
{
	int ret;
	int len;
	char *dest;
 	char *rundir;
 
 	/* lockfile will be:
	 * ""/run"" + ""/lock/lxc/$lxcpath/$lxcname + '\0' if root
 	 * or
	 * $XDG_RUNTIME_DIR + ""/lock/lxc/$lxcpath/$lxcname + '\0' if non-root
 	 */
 
	/* length of ""/lock/lxc/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
	len = strlen(""/lock/lxc/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
	len += strlen(rundir);

	if ((dest = malloc(len)) == NULL) {
		free(rundir);
 		return NULL;
 	}
 
	ret = snprintf(dest, len, ""%s/lock/lxc/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
		/* fall back to ""/tmp/"" + $(id -u) + ""/lxc"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0'
		 * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)
		 * * lxcpath always starts with '/'
		 */
		int l2 = 22 + strlen(n) + strlen(p);
		if (l2 > len) {
			char *d;
			d = realloc(dest, l2);
			if (!d) {
				free(dest);
				free(rundir);
				return NULL;
			}
			len = l2;
			dest = d;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s"", geteuid(), p);
		if (ret < 0 || ret >= len) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = mkdir_p(dest, 0755);
		if (ret < 0) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s/.%s"", geteuid(), p, n);
	} else
		ret = snprintf(dest, len, ""%s/lock/lxc/%s/.%s"", rundir, p, n);
 
 	free(rundir);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;
	}
	return dest;
}
",C,"	 * ""/run"" + ""/lxc/lock/$lxcpath/$lxcname + '\0' if root
	 * $XDG_RUNTIME_DIR + ""/lxc/lock/$lxcpath/$lxcname + '\0' if non-root
	/* length of ""/lxc/lock/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
		free(dest);
		free(rundir);
		return NULL;
	}
	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
","	 * ""/run"" + ""/lock/lxc/$lxcpath/$lxcname + '\0' if root
	 * $XDG_RUNTIME_DIR + ""/lock/lxc/$lxcpath/$lxcname + '\0' if non-root
	/* length of ""/lock/lxc/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
	len = strlen(""/lock/lxc/"") + strlen(n) + strlen(p) + 3;
	ret = snprintf(dest, len, ""%s/lock/lxc/%s"", rundir, p);
		/* fall back to ""/tmp/"" + $(id -u) + ""/lxc"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0'
		 * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)
		 * * lxcpath always starts with '/'
		 */
		int l2 = 22 + strlen(n) + strlen(p);
		if (l2 > len) {
			char *d;
			d = realloc(dest, l2);
			if (!d) {
				free(dest);
				free(rundir);
				return NULL;
			}
			len = l2;
			dest = d;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s"", geteuid(), p);
		if (ret < 0 || ret >= len) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = mkdir_p(dest, 0755);
		if (ret < 0) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s/.%s"", geteuid(), p, n);
	} else
		ret = snprintf(dest, len, ""%s/lock/lxc/%s/.%s"", rundir, p, n);
",,"@@ -103,13 +103,13 @@ static char *lxclock_name(const char *p, const char *n)
 	char *rundir;
 
 	/* lockfile will be:
-	 * ""/run"" + ""/lock/lxc/$lxcpath/$lxcname + '\0' if root
+	 * ""/run"" + ""/lxc/lock/$lxcpath/$lxcname + '\0' if root
 	 * or
-	 * $XDG_RUNTIME_DIR + ""/lock/lxc/$lxcpath/$lxcname + '\0' if non-root
+	 * $XDG_RUNTIME_DIR + ""/lxc/lock/$lxcpath/$lxcname + '\0' if non-root
 	 */
 
-	/* length of ""/lock/lxc/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
-	len = strlen(""/lock/lxc/"") + strlen(n) + strlen(p) + 3;
+	/* length of ""/lxc/lock/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
+	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
@@ -120,48 +120,21 @@ static char *lxclock_name(const char *p, const char *n)
 		return NULL;
 	}
 
-	ret = snprintf(dest, len, ""%s/lock/lxc/%s"", rundir, p);
+	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
-		/* fall back to ""/tmp/"" + $(id -u) + ""/lxc"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0'
-		 * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)
-		 * * lxcpath always starts with '/'
-		 */
-		int l2 = 22 + strlen(n) + strlen(p);
-		if (l2 > len) {
-			char *d;
-			d = realloc(dest, l2);
-			if (!d) {
-				free(dest);
-				free(rundir);
-				return NULL;
-			}
-			len = l2;
-			dest = d;
-		}
-		ret = snprintf(dest, len, ""/tmp/%d/lxc%s"", geteuid(), p);
-		if (ret < 0 || ret >= len) {
-			free(dest);
-			free(rundir);
-			return NULL;
-		}
-		ret = mkdir_p(dest, 0755);
-		if (ret < 0) {
-			free(dest);
-			free(rundir);
-			return NULL;
-		}
-		ret = snprintf(dest, len, ""/tmp/%d/lxc%s/.%s"", geteuid(), p, n);
-	} else
-		ret = snprintf(dest, len, ""%s/lock/lxc/%s/.%s"", rundir, p, n);
+		free(dest);
+		free(rundir);
+		return NULL;
+	}
 
+	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
 	free(rundir);
-
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;",lxc,72cf81f6a3404e35028567db2c99a90406e9c6e6,f52c0d2677e365289e921cfd38033c0c987cefd5,1,"static char *lxclock_name(const char *p, const char *n)
{
	int ret;
	int len;
	char *dest;
 	char *rundir;
 
 	/* lockfile will be:
//flaw_line_below:
	 * ""/run"" + ""/lock/lxc/$lxcpath/$lxcname + '\0' if root
//fix_flaw_line_below:
//	 * ""/run"" + ""/lxc/lock/$lxcpath/$lxcname + '\0' if root
 	 * or
//flaw_line_below:
	 * $XDG_RUNTIME_DIR + ""/lock/lxc/$lxcpath/$lxcname + '\0' if non-root
//fix_flaw_line_below:
//	 * $XDG_RUNTIME_DIR + ""/lxc/lock/$lxcpath/$lxcname + '\0' if non-root
 	 */
 
//flaw_line_below:
	/* length of ""/lock/lxc/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
//flaw_line_below:
	len = strlen(""/lock/lxc/"") + strlen(n) + strlen(p) + 3;
//fix_flaw_line_below:
//	/* length of ""/lxc/lock/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
//fix_flaw_line_below:
//	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
	len += strlen(rundir);

	if ((dest = malloc(len)) == NULL) {
		free(rundir);
 		return NULL;
 	}
 
//flaw_line_below:
	ret = snprintf(dest, len, ""%s/lock/lxc/%s"", rundir, p);
//fix_flaw_line_below:
//	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
//flaw_line_below:
		/* fall back to ""/tmp/"" + $(id -u) + ""/lxc"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0'
//flaw_line_below:
		 * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)
//flaw_line_below:
		 * * lxcpath always starts with '/'
//flaw_line_below:
		 */
//flaw_line_below:
		int l2 = 22 + strlen(n) + strlen(p);
//flaw_line_below:
		if (l2 > len) {
//flaw_line_below:
			char *d;
//flaw_line_below:
			d = realloc(dest, l2);
//flaw_line_below:
			if (!d) {
//flaw_line_below:
				free(dest);
//flaw_line_below:
				free(rundir);
//flaw_line_below:
				return NULL;
//flaw_line_below:
			}
//flaw_line_below:
			len = l2;
//flaw_line_below:
			dest = d;
//flaw_line_below:
		}
//flaw_line_below:
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s"", geteuid(), p);
//flaw_line_below:
		if (ret < 0 || ret >= len) {
//flaw_line_below:
			free(dest);
//flaw_line_below:
			free(rundir);
//flaw_line_below:
			return NULL;
//flaw_line_below:
		}
//flaw_line_below:
		ret = mkdir_p(dest, 0755);
//flaw_line_below:
		if (ret < 0) {
//flaw_line_below:
			free(dest);
//flaw_line_below:
			free(rundir);
//flaw_line_below:
			return NULL;
//flaw_line_below:
		}
//flaw_line_below:
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s/.%s"", geteuid(), p, n);
//flaw_line_below:
	} else
//flaw_line_below:
		ret = snprintf(dest, len, ""%s/lock/lxc/%s/.%s"", rundir, p, n);
//fix_flaw_line_below:
//		free(dest);
//fix_flaw_line_below:
//		free(rundir);
//fix_flaw_line_below:
//		return NULL;
//fix_flaw_line_below:
//	}
 
//fix_flaw_line_below:
//	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
 	free(rundir);
//flaw_line_below:

 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;
	}
	return dest;
}
"
2162,179898,,Local,Not required,,CVE-2015-1331,https://www.cvedetails.com/cve/CVE-2015-1331/,CWE-59,Low,,Complete,,2015-08-12,4.9,lxclock.c in LXC 1.1.2 and earlier allows local users to create arbitrary files via a symlink attack on /run/lock/lxc/*.,2019-05-31,,1,https://github.com/lxc/lxc/commit/72cf81f6a3404e35028567db2c99a90406e9c6e6,72cf81f6a3404e35028567db2c99a90406e9c6e6,"CVE-2015-1331: lxclock: use /run/lxc/lock rather than /run/lock/lxc

This prevents an unprivileged user to use LXC to create arbitrary file
on the filesystem.

Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
Acked-by: Stphane Graber <stgraber@ubuntu.com>",1,src/tests/locktests.c,"{""sha"": ""e9e95f7a01d924f824c9a127cd624802c6ed5265"", ""filename"": ""src/lxc/lxclock.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 37, ""changes"": 47, ""blob_url"": ""https://github.com/lxc/lxc/blob/72cf81f6a3404e35028567db2c99a90406e9c6e6/src/lxc/lxclock.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/72cf81f6a3404e35028567db2c99a90406e9c6e6/src/lxc/lxclock.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/lxclock.c?ref=72cf81f6a3404e35028567db2c99a90406e9c6e6"", ""patch"": ""@@ -103,13 +103,13 @@ static char *lxclock_name(const char *p, const char *n)\n \tchar *rundir;\n \n \t/* lockfile will be:\n-\t * \""/run\"" + \""/lock/lxc/$lxcpath/$lxcname + '\\0' if root\n+\t * \""/run\"" + \""/lxc/lock/$lxcpath/$lxcname + '\\0' if root\n \t * or\n-\t * $XDG_RUNTIME_DIR + \""/lock/lxc/$lxcpath/$lxcname + '\\0' if non-root\n+\t * $XDG_RUNTIME_DIR + \""/lxc/lock/$lxcpath/$lxcname + '\\0' if non-root\n \t */\n \n-\t/* length of \""/lock/lxc/\"" + $lxcpath + \""/\"" + \"".\"" + $lxcname + '\\0' */\n-\tlen = strlen(\""/lock/lxc/\"") + strlen(n) + strlen(p) + 3;\n+\t/* length of \""/lxc/lock/\"" + $lxcpath + \""/\"" + \"".\"" + $lxcname + '\\0' */\n+\tlen = strlen(\""/lxc/lock/\"") + strlen(n) + strlen(p) + 3;\n \trundir = get_rundir();\n \tif (!rundir)\n \t\treturn NULL;\n@@ -120,48 +120,21 @@ static char *lxclock_name(const char *p, const char *n)\n \t\treturn NULL;\n \t}\n \n-\tret = snprintf(dest, len, \""%s/lock/lxc/%s\"", rundir, p);\n+\tret = snprintf(dest, len, \""%s/lxc/lock/%s\"", rundir, p);\n \tif (ret < 0 || ret >= len) {\n \t\tfree(dest);\n \t\tfree(rundir);\n \t\treturn NULL;\n \t}\n \tret = mkdir_p(dest, 0755);\n \tif (ret < 0) {\n-\t\t/* fall back to \""/tmp/\"" + $(id -u) + \""/lxc\"" + $lxcpath + \""/\"" + \"".\"" + $lxcname + '\\0'\n-\t\t * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)\n-\t\t * * lxcpath always starts with '/'\n-\t\t */\n-\t\tint l2 = 22 + strlen(n) + strlen(p);\n-\t\tif (l2 > len) {\n-\t\t\tchar *d;\n-\t\t\td = realloc(dest, l2);\n-\t\t\tif (!d) {\n-\t\t\t\tfree(dest);\n-\t\t\t\tfree(rundir);\n-\t\t\t\treturn NULL;\n-\t\t\t}\n-\t\t\tlen = l2;\n-\t\t\tdest = d;\n-\t\t}\n-\t\tret = snprintf(dest, len, \""/tmp/%d/lxc%s\"", geteuid(), p);\n-\t\tif (ret < 0 || ret >= len) {\n-\t\t\tfree(dest);\n-\t\t\tfree(rundir);\n-\t\t\treturn NULL;\n-\t\t}\n-\t\tret = mkdir_p(dest, 0755);\n-\t\tif (ret < 0) {\n-\t\t\tfree(dest);\n-\t\t\tfree(rundir);\n-\t\t\treturn NULL;\n-\t\t}\n-\t\tret = snprintf(dest, len, \""/tmp/%d/lxc%s/.%s\"", geteuid(), p, n);\n-\t} else\n-\t\tret = snprintf(dest, len, \""%s/lock/lxc/%s/.%s\"", rundir, p, n);\n+\t\tfree(dest);\n+\t\tfree(rundir);\n+\t\treturn NULL;\n+\t}\n \n+\tret = snprintf(dest, len, \""%s/lxc/lock/%s/.%s\"", rundir, p, n);\n \tfree(rundir);\n-\n \tif (ret < 0 || ret >= len) {\n \t\tfree(dest);\n \t\treturn NULL;""}<_**next**_>{""sha"": ""233ca127c6dec567e775abbbb0ef9ce0ed417e43"", ""filename"": ""src/tests/locktests.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/72cf81f6a3404e35028567db2c99a90406e9c6e6/src/tests/locktests.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/72cf81f6a3404e35028567db2c99a90406e9c6e6/src/tests/locktests.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/locktests.c?ref=72cf81f6a3404e35028567db2c99a90406e9c6e6"", ""patch"": ""@@ -122,7 +122,7 @@ int main(int argc, char *argv[])\n \t\texit(1);\n \t}\n \tstruct stat sb;\n-\tchar *pathname = RUNTIME_PATH \""/lock/lxc/var/lib/lxc/\"";\n+\tchar *pathname = RUNTIME_PATH \""/lxc/lock/var/lib/lxc/\"";\n \tret = stat(pathname, &sb);\n \tif (ret != 0) {\n \t\tfprintf(stderr, \""%d: filename %s not created\\n\"", __LINE__,""}","int main(int argc, char *argv[])
{
	int ret;
	struct lxc_lock *lock;

	lock = lxc_newlock(NULL, NULL);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get unnamed lock\n"", __LINE__);
		exit(1);
	}
	ret = lxclock(lock, 0);
	if (ret) {
		fprintf(stderr, ""%d: failed to take unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}

	ret = lxcunlock(lock);
	if (ret) {
		fprintf(stderr, ""%d: failed to put unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}
	lxc_putlock(lock);

	lock = lxc_newlock(""/var/lib/lxc"", mycontainername);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get lock\n"", __LINE__);
 		exit(1);
 	}
 	struct stat sb;
	char *pathname = RUNTIME_PATH ""/lxc/lock/var/lib/lxc/"";
 	ret = stat(pathname, &sb);
 	if (ret != 0) {
 		fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,
			pathname);
		exit(1);
	}
	lxc_putlock(lock);

	test_two_locks();

	fprintf(stderr, ""all tests passed\n"");

	exit(ret);
}
","int main(int argc, char *argv[])
{
	int ret;
	struct lxc_lock *lock;

	lock = lxc_newlock(NULL, NULL);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get unnamed lock\n"", __LINE__);
		exit(1);
	}
	ret = lxclock(lock, 0);
	if (ret) {
		fprintf(stderr, ""%d: failed to take unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}

	ret = lxcunlock(lock);
	if (ret) {
		fprintf(stderr, ""%d: failed to put unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}
	lxc_putlock(lock);

	lock = lxc_newlock(""/var/lib/lxc"", mycontainername);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get lock\n"", __LINE__);
 		exit(1);
 	}
 	struct stat sb;
	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
 	ret = stat(pathname, &sb);
 	if (ret != 0) {
 		fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,
			pathname);
		exit(1);
	}
	lxc_putlock(lock);

	test_two_locks();

	fprintf(stderr, ""all tests passed\n"");

	exit(ret);
}
",C,"	char *pathname = RUNTIME_PATH ""/lxc/lock/var/lib/lxc/"";
","	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
",,"@@ -122,7 +122,7 @@ int main(int argc, char *argv[])
 		exit(1);
 	}
 	struct stat sb;
-	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
+	char *pathname = RUNTIME_PATH ""/lxc/lock/var/lib/lxc/"";
 	ret = stat(pathname, &sb);
 	if (ret != 0) {
 		fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,",lxc,72cf81f6a3404e35028567db2c99a90406e9c6e6,f52c0d2677e365289e921cfd38033c0c987cefd5,1,"int main(int argc, char *argv[])
{
	int ret;
	struct lxc_lock *lock;

	lock = lxc_newlock(NULL, NULL);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get unnamed lock\n"", __LINE__);
		exit(1);
	}
	ret = lxclock(lock, 0);
	if (ret) {
		fprintf(stderr, ""%d: failed to take unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}

	ret = lxcunlock(lock);
	if (ret) {
		fprintf(stderr, ""%d: failed to put unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}
	lxc_putlock(lock);

	lock = lxc_newlock(""/var/lib/lxc"", mycontainername);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get lock\n"", __LINE__);
 		exit(1);
 	}
 	struct stat sb;
//flaw_line_below:
	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
//fix_flaw_line_below:
//	char *pathname = RUNTIME_PATH ""/lxc/lock/var/lib/lxc/"";
 	ret = stat(pathname, &sb);
 	if (ret != 0) {
 		fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,
			pathname);
		exit(1);
	}
	lxc_putlock(lock);

	test_two_locks();

	fprintf(stderr, ""all tests passed\n"");

	exit(ret);
}
"
3703,181439,,Local,Not required,Partial,CVE-2017-7501,https://www.cvedetails.com/cve/CVE-2017-7501/,CWE-59,Low,Partial,Partial,,2017-11-22,4.6,"It was found that versions of rpm before 4.13.0.2 use temporary files with predictable names when installing an RPM. An attacker with ability to write in a directory where files will be installed could create symbolic links to an arbitrary location and modify content, and possibly permissions to arbitrary files, which could be used for denial of service or possibly privilege escalation.",2018-11-29,DoS ,8,https://github.com/rpm-software-management/rpm/commit/404ef011c300207cdb1e531670384564aae04bdc,404ef011c300207cdb1e531670384564aae04bdc,"Don't follow symlinks on file creation (CVE-2017-7501)

Open newly created files with O_EXCL to prevent symlink tricks.
When reopening hardlinks for writing the actual content, use append
mode instead. This is compatible with the write-only permissions but
is not destructive in case we got redirected to somebody elses file,
verify the target before actually writing anything.

As these are files with the temporary suffix, errors mean a local
user with sufficient privileges to break the installation of the package
anyway is trying to goof us on purpose, don't bother trying to mend it
(we couldn't fix the hardlink case anyhow) but just bail out.

Based on a patch by Florian Festi.",1,lib/fsm.c,"{""sha"": ""e0e9d03a18cfab0161d49ab6cceaeb7c7ed1ff76"", ""filename"": ""lib/fsm.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/rpm-software-management/rpm/blob/404ef011c300207cdb1e531670384564aae04bdc/lib/fsm.c"", ""raw_url"": ""https://github.com/rpm-software-management/rpm/raw/404ef011c300207cdb1e531670384564aae04bdc/lib/fsm.c"", ""contents_url"": ""https://api.github.com/repos/rpm-software-management/rpm/contents/lib/fsm.c?ref=404ef011c300207cdb1e531670384564aae04bdc"", ""patch"": ""@@ -206,20 +206,37 @@ static int fsmSetFCaps(const char *path, const char *captxt)\n     return rc;\n }\n \n+/* Check dest is the same, empty and regular file with writeonly permissions */\n+static int linkSane(FD_t wfd, const char *dest)\n+{\n+    struct stat sb, lsb;\n+\n+    return (fstat(Fileno(wfd), &sb) == 0 && sb.st_size == 0 &&\n+\t    (sb.st_mode & ~S_IFMT) == S_IWUSR &&\n+\t    lstat(dest, &lsb) == 0 && S_ISREG(lsb.st_mode) &&\n+\t    sb.st_dev == lsb.st_dev && sb.st_ino == lsb.st_ino);\n+}\n+\n /** \\ingroup payload\n  * Create file from payload stream.\n  * @return\t\t0 on success\n  */\n-static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)\n+static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int exclusive, int nodigest, int nocontent)\n {\n     FD_t wfd = NULL;\n     int rc = 0;\n \n     /* Create the file with 0200 permissions (write by owner). */\n     {\n \tmode_t old_umask = umask(0577);\n-\twfd = Fopen(dest, \""w.ufdio\"");\n+\twfd = Fopen(dest, exclusive ? \""wx.ufdio\"" : \""a.ufdio\"");\n \tumask(old_umask);\n+\n+\t/* If reopening, make sure the file is what we expect */\n+\tif (!exclusive && wfd != NULL && !linkSane(wfd, dest)) {\n+\t    rc = RPMERR_OPEN_FAILED;\n+\t    goto exit;\n+\t}\n     }\n     if (Ferror(wfd)) {\n \trc = RPMERR_OPEN_FAILED;\n@@ -248,7 +265,7 @@ static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n \t/* Create first hardlinked file empty */\n \tif (*firsthardlink < 0) {\n \t    *firsthardlink = rpmfiFX(fi);\n-\t    rc = expandRegular(fi, dest, psm, nodigest, 1);\n+\t    rc = expandRegular(fi, dest, psm, 1, nodigest, 1);\n \t} else {\n \t    /* Create hard links for others */\n \t    char *fn = rpmfilesFN(files, *firsthardlink);\n@@ -263,10 +280,10 @@ static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n        existing) file with content */\n     if (numHardlinks<=1) {\n \tif (!rc)\n-\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n+\t    rc = expandRegular(fi, dest, psm, 1, nodigest, 0);\n     } else if (rpmfiArchiveHasContent(fi)) {\n \tif (!rc)\n-\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n+\t    rc = expandRegular(fi, dest, psm, 0, nodigest, 0);\n \t*firsthardlink = -1;\n     } else {\n \t*setmeta = 0;\n@@ -939,7 +956,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n \t    /* we skip the hard linked file containing the content */\n \t    /* write the content to the first used instead */\n \t    char *fn = rpmfilesFN(files, firsthardlink);\n-\t    rc = expandRegular(fi, fn, psm, nodigest, 0);\n+\t    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);\n \t    firsthardlink = -1;\n \t    free(fn);\n \t}""}","static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)
static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int exclusive, int nodigest, int nocontent)
 {
     FD_t wfd = NULL;
     int rc = 0;
 
     /* Create the file with 0200 permissions (write by owner). */
     {
 	mode_t old_umask = umask(0577);
	wfd = Fopen(dest, exclusive ? ""wx.ufdio"" : ""a.ufdio"");
 	umask(old_umask);

	/* If reopening, make sure the file is what we expect */
	if (!exclusive && wfd != NULL && !linkSane(wfd, dest)) {
	    rc = RPMERR_OPEN_FAILED;
	    goto exit;
	}
     }
     if (Ferror(wfd)) {
 	rc = RPMERR_OPEN_FAILED;
	goto exit;
    }

    if (!nocontent)
	rc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);
exit:
    if (wfd) {
	int myerrno = errno;
	Fclose(wfd);
	errno = myerrno;
    }
    return rc;
}
","static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)
 {
     FD_t wfd = NULL;
     int rc = 0;
 
     /* Create the file with 0200 permissions (write by owner). */
     {
 	mode_t old_umask = umask(0577);
	wfd = Fopen(dest, ""w.ufdio"");
 	umask(old_umask);
     }
     if (Ferror(wfd)) {
 	rc = RPMERR_OPEN_FAILED;
	goto exit;
    }

    if (!nocontent)
	rc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);
exit:
    if (wfd) {
	int myerrno = errno;
	Fclose(wfd);
	errno = myerrno;
    }
    return rc;
}
",C,"static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int exclusive, int nodigest, int nocontent)
	wfd = Fopen(dest, exclusive ? ""wx.ufdio"" : ""a.ufdio"");

	/* If reopening, make sure the file is what we expect */
	if (!exclusive && wfd != NULL && !linkSane(wfd, dest)) {
	    rc = RPMERR_OPEN_FAILED;
	    goto exit;
	}
","	wfd = Fopen(dest, ""w.ufdio"");
",,"@@ -206,20 +206,37 @@ static int fsmSetFCaps(const char *path, const char *captxt)
     return rc;
 }
 
+/* Check dest is the same, empty and regular file with writeonly permissions */
+static int linkSane(FD_t wfd, const char *dest)
+{
+    struct stat sb, lsb;
+
+    return (fstat(Fileno(wfd), &sb) == 0 && sb.st_size == 0 &&
+	    (sb.st_mode & ~S_IFMT) == S_IWUSR &&
+	    lstat(dest, &lsb) == 0 && S_ISREG(lsb.st_mode) &&
+	    sb.st_dev == lsb.st_dev && sb.st_ino == lsb.st_ino);
+}
+
 /** \ingroup payload
  * Create file from payload stream.
  * @return		0 on success
  */
-static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)
+static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int exclusive, int nodigest, int nocontent)
 {
     FD_t wfd = NULL;
     int rc = 0;
 
     /* Create the file with 0200 permissions (write by owner). */
     {
 	mode_t old_umask = umask(0577);
-	wfd = Fopen(dest, ""w.ufdio"");
+	wfd = Fopen(dest, exclusive ? ""wx.ufdio"" : ""a.ufdio"");
 	umask(old_umask);
+
+	/* If reopening, make sure the file is what we expect */
+	if (!exclusive && wfd != NULL && !linkSane(wfd, dest)) {
+	    rc = RPMERR_OPEN_FAILED;
+	    goto exit;
+	}
     }
     if (Ferror(wfd)) {
 	rc = RPMERR_OPEN_FAILED;
@@ -248,7 +265,7 @@ static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,
 	/* Create first hardlinked file empty */
 	if (*firsthardlink < 0) {
 	    *firsthardlink = rpmfiFX(fi);
-	    rc = expandRegular(fi, dest, psm, nodigest, 1);
+	    rc = expandRegular(fi, dest, psm, 1, nodigest, 1);
 	} else {
 	    /* Create hard links for others */
 	    char *fn = rpmfilesFN(files, *firsthardlink);
@@ -263,10 +280,10 @@ static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,
        existing) file with content */
     if (numHardlinks<=1) {
 	if (!rc)
-	    rc = expandRegular(fi, dest, psm, nodigest, 0);
+	    rc = expandRegular(fi, dest, psm, 1, nodigest, 0);
     } else if (rpmfiArchiveHasContent(fi)) {
 	if (!rc)
-	    rc = expandRegular(fi, dest, psm, nodigest, 0);
+	    rc = expandRegular(fi, dest, psm, 0, nodigest, 0);
 	*firsthardlink = -1;
     } else {
 	*setmeta = 0;
@@ -939,7 +956,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	    /* we skip the hard linked file containing the content */
 	    /* write the content to the first used instead */
 	    char *fn = rpmfilesFN(files, firsthardlink);
-	    rc = expandRegular(fi, fn, psm, nodigest, 0);
+	    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);
 	    firsthardlink = -1;
 	    free(fn);
 	}",rpm,404ef011c300207cdb1e531670384564aae04bdc,cfa106ee08189b6f706327ad8c701e43fc656f1b,1,"static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)
//fix_flaw_line_below:
//static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int exclusive, int nodigest, int nocontent)
 {
     FD_t wfd = NULL;
     int rc = 0;
 
     /* Create the file with 0200 permissions (write by owner). */
     {
 	mode_t old_umask = umask(0577);
//flaw_line_below:
	wfd = Fopen(dest, ""w.ufdio"");
//fix_flaw_line_below:
//	wfd = Fopen(dest, exclusive ? ""wx.ufdio"" : ""a.ufdio"");
 	umask(old_umask);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* If reopening, make sure the file is what we expect */
//fix_flaw_line_below:
//	if (!exclusive && wfd != NULL && !linkSane(wfd, dest)) {
//fix_flaw_line_below:
//	    rc = RPMERR_OPEN_FAILED;
//fix_flaw_line_below:
//	    goto exit;
//fix_flaw_line_below:
//	}
     }
     if (Ferror(wfd)) {
 	rc = RPMERR_OPEN_FAILED;
	goto exit;
    }

    if (!nocontent)
	rc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);
exit:
    if (wfd) {
	int myerrno = errno;
	Fclose(wfd);
	errno = myerrno;
    }
    return rc;
}
"
3704,181440,,Local,Not required,Partial,CVE-2017-7501,https://www.cvedetails.com/cve/CVE-2017-7501/,CWE-59,Low,Partial,Partial,,2017-11-22,4.6,"It was found that versions of rpm before 4.13.0.2 use temporary files with predictable names when installing an RPM. An attacker with ability to write in a directory where files will be installed could create symbolic links to an arbitrary location and modify content, and possibly permissions to arbitrary files, which could be used for denial of service or possibly privilege escalation.",2018-11-29,DoS ,3,https://github.com/rpm-software-management/rpm/commit/404ef011c300207cdb1e531670384564aae04bdc,404ef011c300207cdb1e531670384564aae04bdc,"Don't follow symlinks on file creation (CVE-2017-7501)

Open newly created files with O_EXCL to prevent symlink tricks.
When reopening hardlinks for writing the actual content, use append
mode instead. This is compatible with the write-only permissions but
is not destructive in case we got redirected to somebody elses file,
verify the target before actually writing anything.

As these are files with the temporary suffix, errors mean a local
user with sufficient privileges to break the installation of the package
anyway is trying to goof us on purpose, don't bother trying to mend it
(we couldn't fix the hardlink case anyhow) but just bail out.

Based on a patch by Florian Festi.",3,lib/fsm.c,"{""sha"": ""e0e9d03a18cfab0161d49ab6cceaeb7c7ed1ff76"", ""filename"": ""lib/fsm.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/rpm-software-management/rpm/blob/404ef011c300207cdb1e531670384564aae04bdc/lib/fsm.c"", ""raw_url"": ""https://github.com/rpm-software-management/rpm/raw/404ef011c300207cdb1e531670384564aae04bdc/lib/fsm.c"", ""contents_url"": ""https://api.github.com/repos/rpm-software-management/rpm/contents/lib/fsm.c?ref=404ef011c300207cdb1e531670384564aae04bdc"", ""patch"": ""@@ -206,20 +206,37 @@ static int fsmSetFCaps(const char *path, const char *captxt)\n     return rc;\n }\n \n+/* Check dest is the same, empty and regular file with writeonly permissions */\n+static int linkSane(FD_t wfd, const char *dest)\n+{\n+    struct stat sb, lsb;\n+\n+    return (fstat(Fileno(wfd), &sb) == 0 && sb.st_size == 0 &&\n+\t    (sb.st_mode & ~S_IFMT) == S_IWUSR &&\n+\t    lstat(dest, &lsb) == 0 && S_ISREG(lsb.st_mode) &&\n+\t    sb.st_dev == lsb.st_dev && sb.st_ino == lsb.st_ino);\n+}\n+\n /** \\ingroup payload\n  * Create file from payload stream.\n  * @return\t\t0 on success\n  */\n-static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)\n+static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int exclusive, int nodigest, int nocontent)\n {\n     FD_t wfd = NULL;\n     int rc = 0;\n \n     /* Create the file with 0200 permissions (write by owner). */\n     {\n \tmode_t old_umask = umask(0577);\n-\twfd = Fopen(dest, \""w.ufdio\"");\n+\twfd = Fopen(dest, exclusive ? \""wx.ufdio\"" : \""a.ufdio\"");\n \tumask(old_umask);\n+\n+\t/* If reopening, make sure the file is what we expect */\n+\tif (!exclusive && wfd != NULL && !linkSane(wfd, dest)) {\n+\t    rc = RPMERR_OPEN_FAILED;\n+\t    goto exit;\n+\t}\n     }\n     if (Ferror(wfd)) {\n \trc = RPMERR_OPEN_FAILED;\n@@ -248,7 +265,7 @@ static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n \t/* Create first hardlinked file empty */\n \tif (*firsthardlink < 0) {\n \t    *firsthardlink = rpmfiFX(fi);\n-\t    rc = expandRegular(fi, dest, psm, nodigest, 1);\n+\t    rc = expandRegular(fi, dest, psm, 1, nodigest, 1);\n \t} else {\n \t    /* Create hard links for others */\n \t    char *fn = rpmfilesFN(files, *firsthardlink);\n@@ -263,10 +280,10 @@ static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n        existing) file with content */\n     if (numHardlinks<=1) {\n \tif (!rc)\n-\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n+\t    rc = expandRegular(fi, dest, psm, 1, nodigest, 0);\n     } else if (rpmfiArchiveHasContent(fi)) {\n \tif (!rc)\n-\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n+\t    rc = expandRegular(fi, dest, psm, 0, nodigest, 0);\n \t*firsthardlink = -1;\n     } else {\n \t*setmeta = 0;\n@@ -939,7 +956,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n \t    /* we skip the hard linked file containing the content */\n \t    /* write the content to the first used instead */\n \t    char *fn = rpmfilesFN(files, firsthardlink);\n-\t    rc = expandRegular(fi, fn, psm, nodigest, 0);\n+\t    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);\n \t    firsthardlink = -1;\n \t    free(fn);\n \t}""}","static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,
		     rpmpsm psm, int nodigest, int *setmeta,
		     int * firsthardlink)
{
    int rc = 0;
    int numHardlinks = rpmfiFNlink(fi);

    if (numHardlinks > 1) {
 	/* Create first hardlinked file empty */
 	if (*firsthardlink < 0) {
 	    *firsthardlink = rpmfiFX(fi);
	    rc = expandRegular(fi, dest, psm, 1, nodigest, 1);
 	} else {
 	    /* Create hard links for others */
 	    char *fn = rpmfilesFN(files, *firsthardlink);
	    rc = link(fn, dest);
	    if (rc < 0) {
		rc = RPMERR_LINK_FAILED;
	    }
	    free(fn);
	}
    }
    /* Write normal files or fill the last hardlinked (already
        existing) file with content */
     if (numHardlinks<=1) {
 	if (!rc)
	    rc = expandRegular(fi, dest, psm, 1, nodigest, 0);
     } else if (rpmfiArchiveHasContent(fi)) {
 	if (!rc)
	    rc = expandRegular(fi, dest, psm, 0, nodigest, 0);
 	*firsthardlink = -1;
     } else {
 	*setmeta = 0;
    }

    return rc;
}
","static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,
		     rpmpsm psm, int nodigest, int *setmeta,
		     int * firsthardlink)
{
    int rc = 0;
    int numHardlinks = rpmfiFNlink(fi);

    if (numHardlinks > 1) {
 	/* Create first hardlinked file empty */
 	if (*firsthardlink < 0) {
 	    *firsthardlink = rpmfiFX(fi);
	    rc = expandRegular(fi, dest, psm, nodigest, 1);
 	} else {
 	    /* Create hard links for others */
 	    char *fn = rpmfilesFN(files, *firsthardlink);
	    rc = link(fn, dest);
	    if (rc < 0) {
		rc = RPMERR_LINK_FAILED;
	    }
	    free(fn);
	}
    }
    /* Write normal files or fill the last hardlinked (already
        existing) file with content */
     if (numHardlinks<=1) {
 	if (!rc)
	    rc = expandRegular(fi, dest, psm, nodigest, 0);
     } else if (rpmfiArchiveHasContent(fi)) {
 	if (!rc)
	    rc = expandRegular(fi, dest, psm, nodigest, 0);
 	*firsthardlink = -1;
     } else {
 	*setmeta = 0;
    }

    return rc;
}
",C,"	    rc = expandRegular(fi, dest, psm, 1, nodigest, 1);
	    rc = expandRegular(fi, dest, psm, 1, nodigest, 0);
	    rc = expandRegular(fi, dest, psm, 0, nodigest, 0);
","	    rc = expandRegular(fi, dest, psm, nodigest, 1);
	    rc = expandRegular(fi, dest, psm, nodigest, 0);
	    rc = expandRegular(fi, dest, psm, nodigest, 0);
",,"@@ -206,20 +206,37 @@ static int fsmSetFCaps(const char *path, const char *captxt)
     return rc;
 }
 
+/* Check dest is the same, empty and regular file with writeonly permissions */
+static int linkSane(FD_t wfd, const char *dest)
+{
+    struct stat sb, lsb;
+
+    return (fstat(Fileno(wfd), &sb) == 0 && sb.st_size == 0 &&
+	    (sb.st_mode & ~S_IFMT) == S_IWUSR &&
+	    lstat(dest, &lsb) == 0 && S_ISREG(lsb.st_mode) &&
+	    sb.st_dev == lsb.st_dev && sb.st_ino == lsb.st_ino);
+}
+
 /** \ingroup payload
  * Create file from payload stream.
  * @return		0 on success
  */
-static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)
+static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int exclusive, int nodigest, int nocontent)
 {
     FD_t wfd = NULL;
     int rc = 0;
 
     /* Create the file with 0200 permissions (write by owner). */
     {
 	mode_t old_umask = umask(0577);
-	wfd = Fopen(dest, ""w.ufdio"");
+	wfd = Fopen(dest, exclusive ? ""wx.ufdio"" : ""a.ufdio"");
 	umask(old_umask);
+
+	/* If reopening, make sure the file is what we expect */
+	if (!exclusive && wfd != NULL && !linkSane(wfd, dest)) {
+	    rc = RPMERR_OPEN_FAILED;
+	    goto exit;
+	}
     }
     if (Ferror(wfd)) {
 	rc = RPMERR_OPEN_FAILED;
@@ -248,7 +265,7 @@ static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,
 	/* Create first hardlinked file empty */
 	if (*firsthardlink < 0) {
 	    *firsthardlink = rpmfiFX(fi);
-	    rc = expandRegular(fi, dest, psm, nodigest, 1);
+	    rc = expandRegular(fi, dest, psm, 1, nodigest, 1);
 	} else {
 	    /* Create hard links for others */
 	    char *fn = rpmfilesFN(files, *firsthardlink);
@@ -263,10 +280,10 @@ static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,
        existing) file with content */
     if (numHardlinks<=1) {
 	if (!rc)
-	    rc = expandRegular(fi, dest, psm, nodigest, 0);
+	    rc = expandRegular(fi, dest, psm, 1, nodigest, 0);
     } else if (rpmfiArchiveHasContent(fi)) {
 	if (!rc)
-	    rc = expandRegular(fi, dest, psm, nodigest, 0);
+	    rc = expandRegular(fi, dest, psm, 0, nodigest, 0);
 	*firsthardlink = -1;
     } else {
 	*setmeta = 0;
@@ -939,7 +956,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	    /* we skip the hard linked file containing the content */
 	    /* write the content to the first used instead */
 	    char *fn = rpmfilesFN(files, firsthardlink);
-	    rc = expandRegular(fi, fn, psm, nodigest, 0);
+	    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);
 	    firsthardlink = -1;
 	    free(fn);
 	}",rpm,404ef011c300207cdb1e531670384564aae04bdc,cfa106ee08189b6f706327ad8c701e43fc656f1b,1,"static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,
		     rpmpsm psm, int nodigest, int *setmeta,
		     int * firsthardlink)
{
    int rc = 0;
    int numHardlinks = rpmfiFNlink(fi);

    if (numHardlinks > 1) {
 	/* Create first hardlinked file empty */
 	if (*firsthardlink < 0) {
 	    *firsthardlink = rpmfiFX(fi);
//flaw_line_below:
	    rc = expandRegular(fi, dest, psm, nodigest, 1);
//fix_flaw_line_below:
//	    rc = expandRegular(fi, dest, psm, 1, nodigest, 1);
 	} else {
 	    /* Create hard links for others */
 	    char *fn = rpmfilesFN(files, *firsthardlink);
	    rc = link(fn, dest);
	    if (rc < 0) {
		rc = RPMERR_LINK_FAILED;
	    }
	    free(fn);
	}
    }
    /* Write normal files or fill the last hardlinked (already
        existing) file with content */
     if (numHardlinks<=1) {
 	if (!rc)
//flaw_line_below:
	    rc = expandRegular(fi, dest, psm, nodigest, 0);
//fix_flaw_line_below:
//	    rc = expandRegular(fi, dest, psm, 1, nodigest, 0);
     } else if (rpmfiArchiveHasContent(fi)) {
 	if (!rc)
//flaw_line_below:
	    rc = expandRegular(fi, dest, psm, nodigest, 0);
//fix_flaw_line_below:
//	    rc = expandRegular(fi, dest, psm, 0, nodigest, 0);
 	*firsthardlink = -1;
     } else {
 	*setmeta = 0;
    }

    return rc;
}
"
3705,181441,,Local,Not required,Partial,CVE-2017-7501,https://www.cvedetails.com/cve/CVE-2017-7501/,CWE-59,Low,Partial,Partial,,2017-11-22,4.6,"It was found that versions of rpm before 4.13.0.2 use temporary files with predictable names when installing an RPM. An attacker with ability to write in a directory where files will be installed could create symbolic links to an arbitrary location and modify content, and possibly permissions to arbitrary files, which could be used for denial of service or possibly privilege escalation.",2018-11-29,DoS ,1,https://github.com/rpm-software-management/rpm/commit/404ef011c300207cdb1e531670384564aae04bdc,404ef011c300207cdb1e531670384564aae04bdc,"Don't follow symlinks on file creation (CVE-2017-7501)

Open newly created files with O_EXCL to prevent symlink tricks.
When reopening hardlinks for writing the actual content, use append
mode instead. This is compatible with the write-only permissions but
is not destructive in case we got redirected to somebody elses file,
verify the target before actually writing anything.

As these are files with the temporary suffix, errors mean a local
user with sufficient privileges to break the installation of the package
anyway is trying to goof us on purpose, don't bother trying to mend it
(we couldn't fix the hardlink case anyhow) but just bail out.

Based on a patch by Florian Festi.",1,lib/fsm.c,"{""sha"": ""e0e9d03a18cfab0161d49ab6cceaeb7c7ed1ff76"", ""filename"": ""lib/fsm.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/rpm-software-management/rpm/blob/404ef011c300207cdb1e531670384564aae04bdc/lib/fsm.c"", ""raw_url"": ""https://github.com/rpm-software-management/rpm/raw/404ef011c300207cdb1e531670384564aae04bdc/lib/fsm.c"", ""contents_url"": ""https://api.github.com/repos/rpm-software-management/rpm/contents/lib/fsm.c?ref=404ef011c300207cdb1e531670384564aae04bdc"", ""patch"": ""@@ -206,20 +206,37 @@ static int fsmSetFCaps(const char *path, const char *captxt)\n     return rc;\n }\n \n+/* Check dest is the same, empty and regular file with writeonly permissions */\n+static int linkSane(FD_t wfd, const char *dest)\n+{\n+    struct stat sb, lsb;\n+\n+    return (fstat(Fileno(wfd), &sb) == 0 && sb.st_size == 0 &&\n+\t    (sb.st_mode & ~S_IFMT) == S_IWUSR &&\n+\t    lstat(dest, &lsb) == 0 && S_ISREG(lsb.st_mode) &&\n+\t    sb.st_dev == lsb.st_dev && sb.st_ino == lsb.st_ino);\n+}\n+\n /** \\ingroup payload\n  * Create file from payload stream.\n  * @return\t\t0 on success\n  */\n-static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)\n+static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int exclusive, int nodigest, int nocontent)\n {\n     FD_t wfd = NULL;\n     int rc = 0;\n \n     /* Create the file with 0200 permissions (write by owner). */\n     {\n \tmode_t old_umask = umask(0577);\n-\twfd = Fopen(dest, \""w.ufdio\"");\n+\twfd = Fopen(dest, exclusive ? \""wx.ufdio\"" : \""a.ufdio\"");\n \tumask(old_umask);\n+\n+\t/* If reopening, make sure the file is what we expect */\n+\tif (!exclusive && wfd != NULL && !linkSane(wfd, dest)) {\n+\t    rc = RPMERR_OPEN_FAILED;\n+\t    goto exit;\n+\t}\n     }\n     if (Ferror(wfd)) {\n \trc = RPMERR_OPEN_FAILED;\n@@ -248,7 +265,7 @@ static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n \t/* Create first hardlinked file empty */\n \tif (*firsthardlink < 0) {\n \t    *firsthardlink = rpmfiFX(fi);\n-\t    rc = expandRegular(fi, dest, psm, nodigest, 1);\n+\t    rc = expandRegular(fi, dest, psm, 1, nodigest, 1);\n \t} else {\n \t    /* Create hard links for others */\n \t    char *fn = rpmfilesFN(files, *firsthardlink);\n@@ -263,10 +280,10 @@ static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n        existing) file with content */\n     if (numHardlinks<=1) {\n \tif (!rc)\n-\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n+\t    rc = expandRegular(fi, dest, psm, 1, nodigest, 0);\n     } else if (rpmfiArchiveHasContent(fi)) {\n \tif (!rc)\n-\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n+\t    rc = expandRegular(fi, dest, psm, 0, nodigest, 0);\n \t*firsthardlink = -1;\n     } else {\n \t*setmeta = 0;\n@@ -939,7 +956,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n \t    /* we skip the hard linked file containing the content */\n \t    /* write the content to the first used instead */\n \t    char *fn = rpmfilesFN(files, firsthardlink);\n-\t    rc = expandRegular(fi, fn, psm, nodigest, 0);\n+\t    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);\n \t    firsthardlink = -1;\n \t    free(fn);\n \t}""}","int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
              rpmpsm psm, char ** failedFile)
{
    FD_t payload = rpmtePayload(te);
    rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);
    rpmfs fs = rpmteGetFileStates(te);
    rpmPlugins plugins = rpmtsPlugins(ts);
    struct stat sb;
    int saveerrno = errno;
    int rc = 0;
    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;
    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;
    int firsthardlink = -1;
    int skip;
    rpmFileAction action;
    char *tid = NULL;
    const char *suffix;
    char *fpath = NULL;

    if (fi == NULL) {
	rc = RPMERR_BAD_MAGIC;
	goto exit;
    }

    /* transaction id used for temporary path suffix while installing */
    rasprintf(&tid, "";%08x"", (unsigned)rpmtsGetTid(ts));

    /* Detect and create directories not explicitly in package. */
    rc = fsmMkdirs(files, fs, plugins);

    while (!rc) {
	/* Read next payload header. */
	rc = rpmfiNext(fi);

	if (rc < 0) {
	    if (rc == RPMERR_ITER_END)
		rc = 0;
	    break;
	}

	action = rpmfsGetAction(fs, rpmfiFX(fi));
	skip = XFA_SKIPPING(action);
	suffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;
	if (action != FA_TOUCH) {
	    fpath = fsmFsPath(fi, suffix);
	} else {
	    fpath = fsmFsPath(fi, """");
	}

	/* Remap file perms, owner, and group. */
	rc = rpmfiStat(fi, 1, &sb);

	fsmDebug(fpath, action, &sb);

        /* Exit on error. */
        if (rc)
            break;

	/* Run fsm file pre hook for all plugins */
	rc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,
				      sb.st_mode, action);
	if (rc) {
	    skip = 1;
	} else {
	    setFileState(fs, rpmfiFX(fi));
	}

        if (!skip) {
	    int setmeta = 1;

	    /* Directories replacing something need early backup */
	    if (!suffix) {
		rc = fsmBackup(fi, action);
	    }
	    /* Assume file does't exist when tmp suffix is in use */
	    if (!suffix) {
		rc = fsmVerify(fpath, fi);
	    } else {
		rc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;
	    }

            if (S_ISREG(sb.st_mode)) {
		if (rc == RPMERR_ENOENT) {
		    rc = fsmMkfile(fi, fpath, files, psm, nodigest,
				   &setmeta, &firsthardlink);
		}
            } else if (S_ISDIR(sb.st_mode)) {
                if (rc == RPMERR_ENOENT) {
                    mode_t mode = sb.st_mode;
                    mode &= ~07777;
                    mode |=  00700;
                    rc = fsmMkdir(fpath, mode);
                }
            } else if (S_ISLNK(sb.st_mode)) {
		if (rc == RPMERR_ENOENT) {
		    rc = fsmSymlink(rpmfiFLink(fi), fpath);
		}
            } else if (S_ISFIFO(sb.st_mode)) {
                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */
                if (rc == RPMERR_ENOENT) {
                    rc = fsmMkfifo(fpath, 0000);
                }
            } else if (S_ISCHR(sb.st_mode) ||
                       S_ISBLK(sb.st_mode) ||
                       S_ISSOCK(sb.st_mode))
            {
                if (rc == RPMERR_ENOENT) {
                    rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev);
                }
            } else {
                /* XXX Special case /dev/log, which shouldn't be packaged anyways */
                if (!IS_DEV_LOG(fpath))
                    rc = RPMERR_UNKNOWN_FILETYPE;
            }
	    /* Set permissions, timestamps etc for non-hardlink entries */
	    if (!rc && setmeta) {
		rc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps);
	    }
        } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) {
 	    /* we skip the hard linked file containing the content */
 	    /* write the content to the first used instead */
 	    char *fn = rpmfilesFN(files, firsthardlink);
	    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);
 	    firsthardlink = -1;
 	    free(fn);
 	}

        if (rc) {
            if (!skip) {
                /* XXX only erase if temp fn w suffix is in use */
                if (suffix && (action != FA_TOUCH)) {
		    (void) fsmRemove(fpath, sb.st_mode);
                }
                errno = saveerrno;
            }
        } else {
	    /* Notify on success. */
	    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));

	    if (!skip) {
		/* Backup file if needed. Directories are handled earlier */
		if (suffix)
		    rc = fsmBackup(fi, action);

		if (!rc)
		    rc = fsmCommit(&fpath, fi, action, suffix);
	    }
	}

	if (rc)
	    *failedFile = xstrdup(fpath);

	/* Run fsm file post hook for all plugins */
	rpmpluginsCallFsmFilePost(plugins, fi, fpath,
				  sb.st_mode, action, rc);
	fpath = _free(fpath);
    }

    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));
    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));

exit:

    /* No need to bother with close errors on read */
    rpmfiArchiveClose(fi);
    rpmfiFree(fi);
    Fclose(payload);
    free(tid);
    free(fpath);

    return rc;
}
","int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
              rpmpsm psm, char ** failedFile)
{
    FD_t payload = rpmtePayload(te);
    rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);
    rpmfs fs = rpmteGetFileStates(te);
    rpmPlugins plugins = rpmtsPlugins(ts);
    struct stat sb;
    int saveerrno = errno;
    int rc = 0;
    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;
    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;
    int firsthardlink = -1;
    int skip;
    rpmFileAction action;
    char *tid = NULL;
    const char *suffix;
    char *fpath = NULL;

    if (fi == NULL) {
	rc = RPMERR_BAD_MAGIC;
	goto exit;
    }

    /* transaction id used for temporary path suffix while installing */
    rasprintf(&tid, "";%08x"", (unsigned)rpmtsGetTid(ts));

    /* Detect and create directories not explicitly in package. */
    rc = fsmMkdirs(files, fs, plugins);

    while (!rc) {
	/* Read next payload header. */
	rc = rpmfiNext(fi);

	if (rc < 0) {
	    if (rc == RPMERR_ITER_END)
		rc = 0;
	    break;
	}

	action = rpmfsGetAction(fs, rpmfiFX(fi));
	skip = XFA_SKIPPING(action);
	suffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;
	if (action != FA_TOUCH) {
	    fpath = fsmFsPath(fi, suffix);
	} else {
	    fpath = fsmFsPath(fi, """");
	}

	/* Remap file perms, owner, and group. */
	rc = rpmfiStat(fi, 1, &sb);

	fsmDebug(fpath, action, &sb);

        /* Exit on error. */
        if (rc)
            break;

	/* Run fsm file pre hook for all plugins */
	rc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,
				      sb.st_mode, action);
	if (rc) {
	    skip = 1;
	} else {
	    setFileState(fs, rpmfiFX(fi));
	}

        if (!skip) {
	    int setmeta = 1;

	    /* Directories replacing something need early backup */
	    if (!suffix) {
		rc = fsmBackup(fi, action);
	    }
	    /* Assume file does't exist when tmp suffix is in use */
	    if (!suffix) {
		rc = fsmVerify(fpath, fi);
	    } else {
		rc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;
	    }

            if (S_ISREG(sb.st_mode)) {
		if (rc == RPMERR_ENOENT) {
		    rc = fsmMkfile(fi, fpath, files, psm, nodigest,
				   &setmeta, &firsthardlink);
		}
            } else if (S_ISDIR(sb.st_mode)) {
                if (rc == RPMERR_ENOENT) {
                    mode_t mode = sb.st_mode;
                    mode &= ~07777;
                    mode |=  00700;
                    rc = fsmMkdir(fpath, mode);
                }
            } else if (S_ISLNK(sb.st_mode)) {
		if (rc == RPMERR_ENOENT) {
		    rc = fsmSymlink(rpmfiFLink(fi), fpath);
		}
            } else if (S_ISFIFO(sb.st_mode)) {
                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */
                if (rc == RPMERR_ENOENT) {
                    rc = fsmMkfifo(fpath, 0000);
                }
            } else if (S_ISCHR(sb.st_mode) ||
                       S_ISBLK(sb.st_mode) ||
                       S_ISSOCK(sb.st_mode))
            {
                if (rc == RPMERR_ENOENT) {
                    rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev);
                }
            } else {
                /* XXX Special case /dev/log, which shouldn't be packaged anyways */
                if (!IS_DEV_LOG(fpath))
                    rc = RPMERR_UNKNOWN_FILETYPE;
            }
	    /* Set permissions, timestamps etc for non-hardlink entries */
	    if (!rc && setmeta) {
		rc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps);
	    }
        } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) {
 	    /* we skip the hard linked file containing the content */
 	    /* write the content to the first used instead */
 	    char *fn = rpmfilesFN(files, firsthardlink);
	    rc = expandRegular(fi, fn, psm, nodigest, 0);
 	    firsthardlink = -1;
 	    free(fn);
 	}

        if (rc) {
            if (!skip) {
                /* XXX only erase if temp fn w suffix is in use */
                if (suffix && (action != FA_TOUCH)) {
		    (void) fsmRemove(fpath, sb.st_mode);
                }
                errno = saveerrno;
            }
        } else {
	    /* Notify on success. */
	    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));

	    if (!skip) {
		/* Backup file if needed. Directories are handled earlier */
		if (suffix)
		    rc = fsmBackup(fi, action);

		if (!rc)
		    rc = fsmCommit(&fpath, fi, action, suffix);
	    }
	}

	if (rc)
	    *failedFile = xstrdup(fpath);

	/* Run fsm file post hook for all plugins */
	rpmpluginsCallFsmFilePost(plugins, fi, fpath,
				  sb.st_mode, action, rc);
	fpath = _free(fpath);
    }

    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));
    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));

exit:

    /* No need to bother with close errors on read */
    rpmfiArchiveClose(fi);
    rpmfiFree(fi);
    Fclose(payload);
    free(tid);
    free(fpath);

    return rc;
}
",C,"	    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);
","	    rc = expandRegular(fi, fn, psm, nodigest, 0);
",,"@@ -206,20 +206,37 @@ static int fsmSetFCaps(const char *path, const char *captxt)
     return rc;
 }
 
+/* Check dest is the same, empty and regular file with writeonly permissions */
+static int linkSane(FD_t wfd, const char *dest)
+{
+    struct stat sb, lsb;
+
+    return (fstat(Fileno(wfd), &sb) == 0 && sb.st_size == 0 &&
+	    (sb.st_mode & ~S_IFMT) == S_IWUSR &&
+	    lstat(dest, &lsb) == 0 && S_ISREG(lsb.st_mode) &&
+	    sb.st_dev == lsb.st_dev && sb.st_ino == lsb.st_ino);
+}
+
 /** \ingroup payload
  * Create file from payload stream.
  * @return		0 on success
  */
-static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)
+static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int exclusive, int nodigest, int nocontent)
 {
     FD_t wfd = NULL;
     int rc = 0;
 
     /* Create the file with 0200 permissions (write by owner). */
     {
 	mode_t old_umask = umask(0577);
-	wfd = Fopen(dest, ""w.ufdio"");
+	wfd = Fopen(dest, exclusive ? ""wx.ufdio"" : ""a.ufdio"");
 	umask(old_umask);
+
+	/* If reopening, make sure the file is what we expect */
+	if (!exclusive && wfd != NULL && !linkSane(wfd, dest)) {
+	    rc = RPMERR_OPEN_FAILED;
+	    goto exit;
+	}
     }
     if (Ferror(wfd)) {
 	rc = RPMERR_OPEN_FAILED;
@@ -248,7 +265,7 @@ static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,
 	/* Create first hardlinked file empty */
 	if (*firsthardlink < 0) {
 	    *firsthardlink = rpmfiFX(fi);
-	    rc = expandRegular(fi, dest, psm, nodigest, 1);
+	    rc = expandRegular(fi, dest, psm, 1, nodigest, 1);
 	} else {
 	    /* Create hard links for others */
 	    char *fn = rpmfilesFN(files, *firsthardlink);
@@ -263,10 +280,10 @@ static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,
        existing) file with content */
     if (numHardlinks<=1) {
 	if (!rc)
-	    rc = expandRegular(fi, dest, psm, nodigest, 0);
+	    rc = expandRegular(fi, dest, psm, 1, nodigest, 0);
     } else if (rpmfiArchiveHasContent(fi)) {
 	if (!rc)
-	    rc = expandRegular(fi, dest, psm, nodigest, 0);
+	    rc = expandRegular(fi, dest, psm, 0, nodigest, 0);
 	*firsthardlink = -1;
     } else {
 	*setmeta = 0;
@@ -939,7 +956,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	    /* we skip the hard linked file containing the content */
 	    /* write the content to the first used instead */
 	    char *fn = rpmfilesFN(files, firsthardlink);
-	    rc = expandRegular(fi, fn, psm, nodigest, 0);
+	    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);
 	    firsthardlink = -1;
 	    free(fn);
 	}",rpm,404ef011c300207cdb1e531670384564aae04bdc,cfa106ee08189b6f706327ad8c701e43fc656f1b,1,"int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
              rpmpsm psm, char ** failedFile)
{
    FD_t payload = rpmtePayload(te);
    rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);
    rpmfs fs = rpmteGetFileStates(te);
    rpmPlugins plugins = rpmtsPlugins(ts);
    struct stat sb;
    int saveerrno = errno;
    int rc = 0;
    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;
    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;
    int firsthardlink = -1;
    int skip;
    rpmFileAction action;
    char *tid = NULL;
    const char *suffix;
    char *fpath = NULL;

    if (fi == NULL) {
	rc = RPMERR_BAD_MAGIC;
	goto exit;
    }

    /* transaction id used for temporary path suffix while installing */
    rasprintf(&tid, "";%08x"", (unsigned)rpmtsGetTid(ts));

    /* Detect and create directories not explicitly in package. */
    rc = fsmMkdirs(files, fs, plugins);

    while (!rc) {
	/* Read next payload header. */
	rc = rpmfiNext(fi);

	if (rc < 0) {
	    if (rc == RPMERR_ITER_END)
		rc = 0;
	    break;
	}

	action = rpmfsGetAction(fs, rpmfiFX(fi));
	skip = XFA_SKIPPING(action);
	suffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;
	if (action != FA_TOUCH) {
	    fpath = fsmFsPath(fi, suffix);
	} else {
	    fpath = fsmFsPath(fi, """");
	}

	/* Remap file perms, owner, and group. */
	rc = rpmfiStat(fi, 1, &sb);

	fsmDebug(fpath, action, &sb);

        /* Exit on error. */
        if (rc)
            break;

	/* Run fsm file pre hook for all plugins */
	rc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,
				      sb.st_mode, action);
	if (rc) {
	    skip = 1;
	} else {
	    setFileState(fs, rpmfiFX(fi));
	}

        if (!skip) {
	    int setmeta = 1;

	    /* Directories replacing something need early backup */
	    if (!suffix) {
		rc = fsmBackup(fi, action);
	    }
	    /* Assume file does't exist when tmp suffix is in use */
	    if (!suffix) {
		rc = fsmVerify(fpath, fi);
	    } else {
		rc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;
	    }

            if (S_ISREG(sb.st_mode)) {
		if (rc == RPMERR_ENOENT) {
		    rc = fsmMkfile(fi, fpath, files, psm, nodigest,
				   &setmeta, &firsthardlink);
		}
            } else if (S_ISDIR(sb.st_mode)) {
                if (rc == RPMERR_ENOENT) {
                    mode_t mode = sb.st_mode;
                    mode &= ~07777;
                    mode |=  00700;
                    rc = fsmMkdir(fpath, mode);
                }
            } else if (S_ISLNK(sb.st_mode)) {
		if (rc == RPMERR_ENOENT) {
		    rc = fsmSymlink(rpmfiFLink(fi), fpath);
		}
            } else if (S_ISFIFO(sb.st_mode)) {
                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */
                if (rc == RPMERR_ENOENT) {
                    rc = fsmMkfifo(fpath, 0000);
                }
            } else if (S_ISCHR(sb.st_mode) ||
                       S_ISBLK(sb.st_mode) ||
                       S_ISSOCK(sb.st_mode))
            {
                if (rc == RPMERR_ENOENT) {
                    rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev);
                }
            } else {
                /* XXX Special case /dev/log, which shouldn't be packaged anyways */
                if (!IS_DEV_LOG(fpath))
                    rc = RPMERR_UNKNOWN_FILETYPE;
            }
	    /* Set permissions, timestamps etc for non-hardlink entries */
	    if (!rc && setmeta) {
		rc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps);
	    }
        } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) {
 	    /* we skip the hard linked file containing the content */
 	    /* write the content to the first used instead */
 	    char *fn = rpmfilesFN(files, firsthardlink);
//flaw_line_below:
	    rc = expandRegular(fi, fn, psm, nodigest, 0);
//fix_flaw_line_below:
//	    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);
 	    firsthardlink = -1;
 	    free(fn);
 	}

        if (rc) {
            if (!skip) {
                /* XXX only erase if temp fn w suffix is in use */
                if (suffix && (action != FA_TOUCH)) {
		    (void) fsmRemove(fpath, sb.st_mode);
                }
                errno = saveerrno;
            }
        } else {
	    /* Notify on success. */
	    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));

	    if (!skip) {
		/* Backup file if needed. Directories are handled earlier */
		if (suffix)
		    rc = fsmBackup(fi, action);

		if (!rc)
		    rc = fsmCommit(&fpath, fi, action, suffix);
	    }
	}

	if (rc)
	    *failedFile = xstrdup(fpath);

	/* Run fsm file post hook for all plugins */
	rpmpluginsCallFsmFilePost(plugins, fi, fpath,
				  sb.st_mode, action, rc);
	fpath = _free(fpath);
    }

    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));
    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));

exit:

    /* No need to bother with close errors on read */
    rpmfiArchiveClose(fi);
    rpmfiFree(fi);
    Fclose(payload);
    free(tid);
    free(fpath);

    return rc;
}
"
3714,181450,,Local,Not required,,CVE-2017-7418,https://www.cvedetails.com/cve/CVE-2017-7418/,CWE-59,Low,,Partial,,2017-04-04,2.1,"ProFTPD before 1.3.5e and 1.3.6 before 1.3.6rc5 controls whether the home directory of a user could contain a symbolic link through the AllowChrootSymlinks configuration option, but checks only the last path component when enforcing AllowChrootSymlinks. Attackers with local access could bypass the AllowChrootSymlinks control by replacing a path component (other than the last one) with a symbolic link. The threat model includes an attacker who is not granted full filesystem access by a hosting provider, but can reconfigure the home directory of an FTP user.",2019-08-08,Bypass ,5,https://github.com/proftpd/proftpd/pull/444/commits/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8,349addc3be4fcdad9bd4ec01ad1ccd916c898ed8,"Walk the entire DefaultRoot path, checking for symlinks of any component,
when AllowChrootSymlinks is disabled.",13,modules/mod_auth.c,"{""sha"": ""6e535bbb7a66d5babfc08807099ecd7a6d80a5da"", ""filename"": ""modules/mod_auth.c"", ""status"": ""modified"", ""additions"": 58, ""deletions"": 15, ""changes"": 73, ""blob_url"": ""https://github.com/proftpd/proftpd/blob/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/modules/mod_auth.c"", ""raw_url"": ""https://github.com/proftpd/proftpd/raw/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/modules/mod_auth.c"", ""contents_url"": ""https://api.github.com/repos/proftpd/proftpd/contents/modules/mod_auth.c?ref=349addc3be4fcdad9bd4ec01ad1ccd916c898ed8"", ""patch"": ""@@ -804,6 +804,59 @@ static const char *get_default_chdir(pool *p, xaset_t *conf) {\n   return dir;\n }\n \n+static int is_symlink_path(pool *p, const char *path, size_t pathlen) {\n+  int res, xerrno = 0;\n+  struct stat st;\n+  char *ptr;\n+\n+  if (pathlen == 0) {\n+    return 0;\n+  }\n+\n+  pr_fs_clear_cache2(path);\n+  res = pr_fsio_lstat(path, &st);\n+  if (res < 0) {\n+    xerrno = errno;\n+\n+    pr_log_pri(PR_LOG_WARNING, \""error: unable to check %s: %s\"", path,\n+      strerror(xerrno));\n+\n+    errno = xerrno;\n+    return -1;\n+  }\n+\n+  if (S_ISLNK(st.st_mode)) {\n+    errno = EPERM;\n+    return -1;\n+  }\n+\n+  /* To handle the case where a component further up the path might be a\n+   * symlink (which lstat(2) will NOT handle), we walk the path backwards,\n+   * calling ourselves recursively.\n+   */\n+\n+  ptr = strrchr(path, '/');\n+  if (ptr != NULL) {\n+    char *new_path;\n+    size_t new_pathlen;\n+\n+    pr_signals_handle();\n+\n+    new_pathlen = ptr - path;\n+    new_path = pstrndup(p, path, new_pathlen);\n+\n+    pr_log_debug(DEBUG10,\n+      \""AllowChrootSymlink: path '%s' not a symlink, checking '%s'\"", path,\n+      new_path);\n+    res = is_symlink_path(p, new_path, new_pathlen);\n+    if (res < 0) {\n+      return -1;\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n /* Determine if the user (non-anon) needs a default root dir other than /. */\n static int get_default_root(pool *p, int allow_symlinks, const char **root) {\n   config_rec *c = NULL;\n@@ -847,7 +900,6 @@ static int get_default_root(pool *p, int allow_symlinks, const char **root) {\n \n       if (allow_symlinks == FALSE) {\n         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n-        struct stat st;\n         size_t pathlen;\n \n         /* First, deal with any possible interpolation.  dir_realpath() will\n@@ -878,22 +930,13 @@ static int get_default_root(pool *p, int allow_symlinks, const char **root) {\n           path[pathlen-1] = '\\0';\n         }\n \n-        pr_fs_clear_cache2(path);\n-        res = pr_fsio_lstat(path, &st);\n+        res = is_symlink_path(p, path, pathlen);\n         if (res < 0) {\n-          xerrno = errno;\n-\n-          pr_log_pri(PR_LOG_WARNING, \""error: unable to check %s: %s\"", path,\n-            strerror(xerrno));\n-\n-          errno = xerrno;\n-          return -1;\n-        }\n+          if (errno == EPERM) {\n+            pr_log_pri(PR_LOG_WARNING, \""error: DefaultRoot %s is a symlink \""\n+              \""(denied by AllowChrootSymlinks config)\"", path);\n+          }\n \n-        if (S_ISLNK(st.st_mode)) {\n-          pr_log_pri(PR_LOG_WARNING,\n-            \""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \""\n-            \""config)\"", path);\n           errno = EPERM;\n           return -1;\n         }""}<_**next**_>{""sha"": ""8872231db18a970369799ece823cc1d8325aafde"", ""filename"": ""tests/t/lib/ProFTPD/TestSuite/Utils.pm"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 9, ""changes"": 23, ""blob_url"": ""https://github.com/proftpd/proftpd/blob/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/tests/t/lib/ProFTPD/TestSuite/Utils.pm"", ""raw_url"": ""https://github.com/proftpd/proftpd/raw/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/tests/t/lib/ProFTPD/TestSuite/Utils.pm"", ""contents_url"": ""https://api.github.com/repos/proftpd/proftpd/contents/tests/t/lib/ProFTPD/TestSuite/Utils.pm?ref=349addc3be4fcdad9bd4ec01ad1ccd916c898ed8"", ""patch"": ""@@ -1198,6 +1198,7 @@ sub test_setup {\n   $uid = 500 unless defined($uid);\n   my $gid = shift;\n   $gid = 500 unless defined($gid);\n+  my $home_dir = shift;\n \n   my $config_file = \""$tmpdir/$name.conf\"";\n   my $pid_file = File::Spec->rel2abs(\""$tmpdir/$name.pid\"");\n@@ -1206,17 +1207,21 @@ sub test_setup {\n   my $auth_user_file = File::Spec->rel2abs(\""$tmpdir/$name.passwd\"");\n   my $auth_group_file = File::Spec->rel2abs(\""$tmpdir/$name.group\"");\n \n-  my $home_dir = File::Spec->rel2abs($tmpdir);\n+  # If the caller provides the home directory, it is ASSUMED that they will\n+  # have created it.\n+  unless (defined($home_dir)) {\n+    $home_dir = File::Spec->rel2abs($tmpdir);\n \n-  # Make sure that, if we're running as root, that the home directory has\n-  # permissions/privs set for the account we create\n-  if ($< == 0) {\n-    unless (chmod(0755, $home_dir)) {\n-      croak(\""Can't set perms on $home_dir to 0755: $!\"");\n-    }\n+    # Make sure that, if we're running as root, that the home directory has\n+    # permissions/privs set for the account we create\n+    if ($< == 0) {\n+      unless (chmod(0755, $home_dir)) {\n+        croak(\""Can't set perms on $home_dir to 0755: $!\"");\n+      }\n \n-    unless (chown($uid, $gid, $home_dir)) {\n-      croak(\""Can't set owner of $home_dir to $uid/$gid: $!\"");\n+      unless (chown($uid, $gid, $home_dir)) {\n+        croak(\""Can't set owner of $home_dir to $uid/$gid: $!\"");\n+      }\n     }\n   }\n ""}<_**next**_>{""sha"": ""88486c3a774b144b863f3ba8bd209c64abb8d0ea"", ""filename"": ""tests/t/lib/ProFTPD/Tests/Config/DefaultRoot.pm"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 55, ""changes"": 76, ""blob_url"": ""https://github.com/proftpd/proftpd/blob/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/tests/t/lib/ProFTPD/Tests/Config/DefaultRoot.pm"", ""raw_url"": ""https://github.com/proftpd/proftpd/raw/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/tests/t/lib/ProFTPD/Tests/Config/DefaultRoot.pm"", ""contents_url"": ""https://api.github.com/repos/proftpd/proftpd/contents/tests/t/lib/ProFTPD/Tests/Config/DefaultRoot.pm?ref=349addc3be4fcdad9bd4ec01ad1ccd916c898ed8"", ""patch"": ""@@ -621,65 +621,39 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n   my $self = shift;\n   my $tmpdir = $self->{tmpdir};\n \n-  my $config_file = \""$tmpdir/config.conf\"";\n-  my $pid_file = File::Spec->rel2abs(\""$tmpdir/config.pid\"");\n-  my $scoreboard_file = File::Spec->rel2abs(\""$tmpdir/config.scoreboard\"");\n-\n-  my $log_file = test_get_logfile();\n-\n-  my $auth_user_file = File::Spec->rel2abs(\""$tmpdir/config.passwd\"");\n-  my $auth_group_file = File::Spec->rel2abs(\""$tmpdir/config.group\"");\n-\n   my $user = 'proftpd';\n-  my $passwd = 'test';\n-  my $group = 'ftpd';\n   my $home_dir = File::Spec->rel2abs(\""$tmpdir/home.d/symlinks/$user\"");\n   my $uid = 500;\n   my $gid = 500;\n \n-  my $intermed_dir = File::Spec->rel2abs(\""$tmpdir/home.d/symlinks\"");\n-  mkpath($intermed_dir);\n-\n-  my $symlink_dst = File::Spec->rel2abs(\""$tmpdir/real/$user\"");\n-  mkpath($symlink_dst);\n+  my $symlink_dst = File::Spec->rel2abs(\""$tmpdir/real\"");\n \n   my $cwd = getcwd();\n \n-  unless (chdir($intermed_dir)) {\n-    die(\""Can't chdir to $intermed_dir: $!\"");\n+  unless (chdir($tmpdir)) {\n+    die(\""Can't chdir to $tmpdir: $!\"");\n   }\n \n-  unless (symlink(\""../../real/$user\"", \""./$user\"")) {\n-    die(\""Can't symlink '../../real/$user' to './$user': $!\"");\n+  unless (symlink(\""./real\"", \""./home.d\"")) {\n+    die(\""Can't symlink './real' to './home.d': $!\"");\n   }\n \n   unless (chdir($cwd)) {\n     die(\""Can't chdir to $cwd: $!\"");\n   }\n \n-  # Make sure that, if we're running as root, that the home directory has\n-  # permissions/privs set for the account we create\n-  if ($< == 0) {\n-    unless (chmod(0755, $symlink_dst)) {\n-      die(\""Can't set perms on $symlink_dst to 0755: $!\"");\n-    }\n+  mkpath(File::Spec->rel2abs(\""$tmpdir/real/symlinks/$user\""));\n \n-    unless (chown($uid, $gid, $symlink_dst)) {\n-      die(\""Can't set owner of $symlink_dst to $uid/$gid: $!\"");\n-    }\n-  }\n-\n-  auth_user_write($auth_user_file, $user, $passwd, $uid, $gid, $home_dir,\n-    '/bin/bash');\n-  auth_group_write($auth_group_file, $group, $gid, $user);\n+  my $setup = test_setup($tmpdir, 'config', $user, undef, undef, $uid, $gid,\n+    $home_dir);\n \n   my $config = {\n-    PidFile => $pid_file,\n-    ScoreboardFile => $scoreboard_file,\n-    SystemLog => $log_file,\n+    PidFile => $setup->{pid_file},\n+    ScoreboardFile => $setup->{scoreboard_file},\n+    SystemLog => $setup->{log_file},\n \n-    AuthUserFile => $auth_user_file,\n-    AuthGroupFile => $auth_group_file,\n+    AuthUserFile => $setup->{auth_user_file},\n+    AuthGroupFile => $setup->{auth_group_file},\n \n     AllowChrootSymlinks => 'off',\n     DefaultRoot => '~',\n@@ -691,7 +665,8 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n     },\n   };\n \n-  my ($port, $config_user, $config_group) = config_write($config_file, $config);\n+  my ($port, $config_user, $config_group) = config_write($setup->{config_file},\n+    $config);\n \n   # Open pipes, for use between the parent and child processes.  Specifically,\n   # the child will indicate when it's done with its test by writing a message\n@@ -709,7 +684,7 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n   if ($pid) {\n     eval {\n       my $client = ProFTPD::TestSuite::FTP->new('127.0.0.1', $port);\n-      eval { $client->login($user, $passwd) };\n+      eval { $client->login($user, $setup->{passwd}) };\n       unless ($@) {\n         die(\""Login succeeded unexpectedly\"");\n       }\n@@ -721,13 +696,12 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n \n       $expected = 530;\n       $self->assert($expected == $resp_code,\n-        test_msg(\""Expected response code $expected, got $resp_code\""));\n+        \""Expected response code $expected, got $resp_code\"");\n \n       $expected = \""Login incorrect.\"";\n       $self->assert($expected eq $resp_msg,\n-        test_msg(\""Expected response message '$expected', got '$resp_msg'\""));\n+        \""Expected response message '$expected', got '$resp_msg'\"");\n     };\n-\n     if ($@) {\n       $ex = $@;\n     }\n@@ -736,7 +710,7 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n     $wfh->flush();\n \n   } else {\n-    eval { server_wait($config_file, $rfh) };\n+    eval { server_wait($setup->{config_file}, $rfh) };\n     if ($@) {\n       warn($@);\n       exit 1;\n@@ -746,18 +720,10 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n   }\n \n   # Stop server\n-  server_stop($pid_file);\n-\n+  server_stop($setup->{pid_file});\n   $self->assert_child_ok($pid);\n \n-  if ($ex) {\n-    test_append_logfile($log_file, $ex);\n-    unlink($log_file);\n-\n-    die($ex);\n-  }\n-\n-  unlink($log_file);\n+  test_cleanup($setup->{log_file}, $ex);\n }\n \n 1;""}"," static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
  const char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c != NULL) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir != NULL) {
    const char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = pstrdup(p, dir);
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
 
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      pr_fs_clear_cache2(dir);

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
"," static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
  const char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c != NULL) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir != NULL) {
    const char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = pstrdup(p, dir);
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        pr_fs_clear_cache2(path);
        res = pr_fsio_lstat(path, &st);
         if (res < 0) {
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
 
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      pr_fs_clear_cache2(dir);

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
",C,"        res = is_symlink_path(p, path, pathlen);
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
","        struct stat st;
        pr_fs_clear_cache2(path);
        res = pr_fsio_lstat(path, &st);
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
",,"@@ -804,6 +804,59 @@ static const char *get_default_chdir(pool *p, xaset_t *conf) {
   return dir;
 }
 
+static int is_symlink_path(pool *p, const char *path, size_t pathlen) {
+  int res, xerrno = 0;
+  struct stat st;
+  char *ptr;
+
+  if (pathlen == 0) {
+    return 0;
+  }
+
+  pr_fs_clear_cache2(path);
+  res = pr_fsio_lstat(path, &st);
+  if (res < 0) {
+    xerrno = errno;
+
+    pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
+      strerror(xerrno));
+
+    errno = xerrno;
+    return -1;
+  }
+
+  if (S_ISLNK(st.st_mode)) {
+    errno = EPERM;
+    return -1;
+  }
+
+  /* To handle the case where a component further up the path might be a
+   * symlink (which lstat(2) will NOT handle), we walk the path backwards,
+   * calling ourselves recursively.
+   */
+
+  ptr = strrchr(path, '/');
+  if (ptr != NULL) {
+    char *new_path;
+    size_t new_pathlen;
+
+    pr_signals_handle();
+
+    new_pathlen = ptr - path;
+    new_path = pstrndup(p, path, new_pathlen);
+
+    pr_log_debug(DEBUG10,
+      ""AllowChrootSymlink: path '%s' not a symlink, checking '%s'"", path,
+      new_path);
+    res = is_symlink_path(p, new_path, new_pathlen);
+    if (res < 0) {
+      return -1;
+    }
+  }
+
+  return 0;
+}
+
 /* Determine if the user (non-anon) needs a default root dir other than /. */
 static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
@@ -847,7 +900,6 @@ static int get_default_root(pool *p, int allow_symlinks, const char **root) {
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
-        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
@@ -878,22 +930,13 @@ static int get_default_root(pool *p, int allow_symlinks, const char **root) {
           path[pathlen-1] = '\0';
         }
 
-        pr_fs_clear_cache2(path);
-        res = pr_fsio_lstat(path, &st);
+        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
-          xerrno = errno;
-
-          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
-            strerror(xerrno));
-
-          errno = xerrno;
-          return -1;
-        }
+          if (errno == EPERM) {
+            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
+              ""(denied by AllowChrootSymlinks config)"", path);
+          }
 
-        if (S_ISLNK(st.st_mode)) {
-          pr_log_pri(PR_LOG_WARNING,
-            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
-            ""config)"", path);
           errno = EPERM;
           return -1;
         }",proftpd,349addc3be4fcdad9bd4ec01ad1ccd916c898ed8,31ce8400c18c3ac46cbe3f17f3e7f0cc4e712dfc,1," static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
  const char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c != NULL) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir != NULL) {
    const char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
//flaw_line_below:
        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = pstrdup(p, dir);
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
//flaw_line_below:
        pr_fs_clear_cache2(path);
//flaw_line_below:
        res = pr_fsio_lstat(path, &st);
//fix_flaw_line_below:
//        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
//flaw_line_below:
          xerrno = errno;
//flaw_line_below:

//flaw_line_below:
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
//flaw_line_below:
            strerror(xerrno));
//flaw_line_below:

//flaw_line_below:
          errno = xerrno;
//flaw_line_below:
          return -1;
//flaw_line_below:
        }
//fix_flaw_line_below:
//          if (errno == EPERM) {
//fix_flaw_line_below:
//            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
//fix_flaw_line_below:
//              ""(denied by AllowChrootSymlinks config)"", path);
//fix_flaw_line_below:
//          }
 
//flaw_line_below:
        if (S_ISLNK(st.st_mode)) {
//flaw_line_below:
          pr_log_pri(PR_LOG_WARNING,
//flaw_line_below:
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
//flaw_line_below:
            ""config)"", path);
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      pr_fs_clear_cache2(dir);

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
"
4322,182058,,Local,Not required,Complete,CVE-2015-3315,https://www.cvedetails.com/cve/CVE-2015-3315/,CWE-59,Low,Complete,Complete,,2017-06-26,7.2,"Automatic Bug Reporting Tool (ABRT) allows local users to read, change the ownership of, or have other unspecified impact on arbitrary files via a symlink attack on (1) /var/tmp/abrt/*/maps, (2) /tmp/jvm-*/hs_error.log, (3) /proc/*/exe, (4) /etc/os-release in a chroot, or (5) an unspecified root directory related to librpm.",2018-02-18,,3,https://github.com/abrt/abrt/commit/17cb66b13997b0159b4253b3f5722db79f476d68,17cb66b13997b0159b4253b3f5722db79f476d68,"ccpp: stop reading hs_error.log from /tmp

The file might contain anything and there is no way to verify its
contents.

Related: #1211835

Signed-off-by: Jakub Filak <jfilak@redhat.com>",0,src/hooks/abrt-hook-ccpp.c,"{""sha"": ""5694f848ae7cec6354de9aaf07fb72880e15606a"", ""filename"": ""src/hooks/abrt-hook-ccpp.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/abrt/abrt/blob/17cb66b13997b0159b4253b3f5722db79f476d68/src/hooks/abrt-hook-ccpp.c"", ""raw_url"": ""https://github.com/abrt/abrt/raw/17cb66b13997b0159b4253b3f5722db79f476d68/src/hooks/abrt-hook-ccpp.c"", ""contents_url"": ""https://api.github.com/repos/abrt/abrt/contents/src/hooks/abrt-hook-ccpp.c?ref=17cb66b13997b0159b4253b3f5722db79f476d68"", ""patch"": ""@@ -795,6 +795,8 @@ int main(int argc, char** argv)\n             unlink(core_basename);\n         }\n \n+/* Because of #1211835 and #1126850 */\n+#if 0\n         /* Save JVM crash log if it exists. (JVM's coredump per se\n          * is nearly useless for JVM developers)\n          */\n@@ -827,6 +829,7 @@ int main(int argc, char** argv)\n                 close(src_fd);\n             }\n         }\n+#endif\n \n         /* We close dumpdir before we start catering for crash storm case.\n          * Otherwise, delete_dump_dir's from other concurrent""}","int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
	fd = xdup(fd);
    if (fd > 2)
	close(fd);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %h */
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME [HOSTNAME]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }

    struct utsname uts;
    if (!argv[8]) /* no HOSTNAME? */
    {
        uname(&uts);
        argv[8] = uts.nodename;
    }

    char path[PATH_MAX];

    int src_fd_binary = -1;
    char *executable = get_executable(pid, setting_SaveBinaryImage ? &src_fd_binary : NULL);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid();
    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
        {
            fsuid = tmp_fsuid;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        goto create_user_core;
    }

    const char *signame = NULL;
    switch (signal_no)
    {
        case SIGILL : signame = ""ILL"" ; break;
        case SIGFPE : signame = ""FPE"" ; break;
        case SIGSEGV: signame = ""SEGV""; break;
        case SIGBUS : signame = ""BUS"" ; break; //Bus error (bad memory access)
        case SIGABRT: signame = ""ABRT""; break; //usually when abort() was called
        case SIGTRAP: signame = ""TRAP""; break; //Trace/breakpoint trap
        default: goto create_user_core; // not a signal we care about
    }

    if (!daemon_is_ok())
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        goto create_user_core;
    }

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            goto create_user_core;
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        goto create_user_core;
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
        snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
        if (core_size < 0 || fsync(abrt_core_fd) != 0)
        {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        return 0;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        goto create_user_core;
    }

    /* use fsuid instead of uid, so we don't expose any sensitive
     * information of suided app in /var/tmp/abrt
     */
    dd = dd_create(path, fsuid, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char *rootdir = get_rootdir(pid);

        dd_create_basic_files(dd, fsuid, (rootdir && strcmp(rootdir, ""/"") != 0) ? rootdir : NULL);

        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/smaps"", (long)pid);
        source_base_ofs -= strlen(""smaps"");
        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;


        strcpy(source_filename + source_base_ofs, ""maps"");
        strcpy(dest_base, FILENAME_MAPS);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(source_filename + source_base_ofs, ""limits"");
        strcpy(dest_base, FILENAME_LIMITS);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        strcpy(dest_base, FILENAME_CGROUP);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        dd_save_text(dd, FILENAME_ANALYZER, ""CCpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        if (src_fd_binary > 0)
        {
            strcpy(path + path_len, ""/""FILENAME_BINARY);
            int dst_fd = create_or_die(path);
            off_t sz = copyfd_eof(src_fd_binary, dst_fd, COPYFD_SPARSE);
            if (fsync(dst_fd) != 0 || close(dst_fd) != 0 || sz < 0)
            {
                dd_delete(dd);
                error_msg_and_die(""Error saving '%s'"", path);
            }
            close(src_fd_binary);
        }

        strcpy(path + path_len, ""/""FILENAME_COREDUMP);
        int abrt_core_fd = create_or_die(path);

        /* We write both coredumps at once.
         * We can't write user coredump first, since it might be truncated
         * and thus can't be copied and used as abrt coredump;
         * and if we write abrt coredump first and then copy it as user one,
         * then we have a race when process exits but coredump does not exist yet:
         * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
         * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
         * 21631 Segmentation fault (core dumped) ./test
         * ls: cannot access core*: No such file or directory <=== BAD
         */
        off_t core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
        if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
        {
            unlink(path);
            dd_delete(dd);
            if (user_core_fd >= 0)
            {
                xchdir(user_pwd);
                unlink(core_basename);
            }
            /* copyfd_sparse logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error writing '%s'"", path);
        }
        if (user_core_fd >= 0
            /* error writing user coredump? */
         && (fsync(user_core_fd) != 0 || close(user_core_fd) != 0
            /* user coredump is too big? */
            || (ulimit_c == 0 /* paranoia */ || core_size > ulimit_c)
            )
        ) {
            /* nuke it (silently) */
            xchdir(user_pwd);
             unlink(core_basename);
         }
 
/* Because of #1211835 and #1126850 */
#if 0
         /* Save JVM crash log if it exists. (JVM's coredump per se
          * is nearly useless for JVM developers)
          */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    dd_delete(dd);
                    error_msg_and_die(""Error saving '%s'"", path);
                }
                 close(src_fd);
             }
         }
#endif
 
         /* We close dumpdir before we start catering for crash storm case.
          * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        path[path_len] = '\0'; /* path now contains only directory name */
        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);

        notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        free(rootdir);
        return 0;
    }

    /* We didn't create abrt dump, but may need to create compat coredump */
 create_user_core:
    if (user_core_fd >= 0)
    {
        off_t core_size = copyfd_size(STDIN_FILENO, user_core_fd, ulimit_c, COPYFD_SPARSE);
        if (fsync(user_core_fd) != 0 || close(user_core_fd) != 0 || core_size < 0)
        {
            /* perror first, otherwise unlink may trash errno */
            perror_msg(""Error writing '%s'"", full_core_basename);
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        if (ulimit_c == 0 || core_size > ulimit_c)
        {
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        log(""Saved core dump of pid %lu to %s (%llu bytes)"", (long)pid, full_core_basename, (long long)core_size);
    }

    return 0;
}
","int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
	fd = xdup(fd);
    if (fd > 2)
	close(fd);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %h */
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME [HOSTNAME]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }

    struct utsname uts;
    if (!argv[8]) /* no HOSTNAME? */
    {
        uname(&uts);
        argv[8] = uts.nodename;
    }

    char path[PATH_MAX];

    int src_fd_binary = -1;
    char *executable = get_executable(pid, setting_SaveBinaryImage ? &src_fd_binary : NULL);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid();
    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
        {
            fsuid = tmp_fsuid;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        goto create_user_core;
    }

    const char *signame = NULL;
    switch (signal_no)
    {
        case SIGILL : signame = ""ILL"" ; break;
        case SIGFPE : signame = ""FPE"" ; break;
        case SIGSEGV: signame = ""SEGV""; break;
        case SIGBUS : signame = ""BUS"" ; break; //Bus error (bad memory access)
        case SIGABRT: signame = ""ABRT""; break; //usually when abort() was called
        case SIGTRAP: signame = ""TRAP""; break; //Trace/breakpoint trap
        default: goto create_user_core; // not a signal we care about
    }

    if (!daemon_is_ok())
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        goto create_user_core;
    }

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            goto create_user_core;
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        goto create_user_core;
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
        snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
        if (core_size < 0 || fsync(abrt_core_fd) != 0)
        {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        return 0;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        goto create_user_core;
    }

    /* use fsuid instead of uid, so we don't expose any sensitive
     * information of suided app in /var/tmp/abrt
     */
    dd = dd_create(path, fsuid, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char *rootdir = get_rootdir(pid);

        dd_create_basic_files(dd, fsuid, (rootdir && strcmp(rootdir, ""/"") != 0) ? rootdir : NULL);

        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/smaps"", (long)pid);
        source_base_ofs -= strlen(""smaps"");
        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;


        strcpy(source_filename + source_base_ofs, ""maps"");
        strcpy(dest_base, FILENAME_MAPS);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(source_filename + source_base_ofs, ""limits"");
        strcpy(dest_base, FILENAME_LIMITS);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        strcpy(dest_base, FILENAME_CGROUP);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        dd_save_text(dd, FILENAME_ANALYZER, ""CCpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        if (src_fd_binary > 0)
        {
            strcpy(path + path_len, ""/""FILENAME_BINARY);
            int dst_fd = create_or_die(path);
            off_t sz = copyfd_eof(src_fd_binary, dst_fd, COPYFD_SPARSE);
            if (fsync(dst_fd) != 0 || close(dst_fd) != 0 || sz < 0)
            {
                dd_delete(dd);
                error_msg_and_die(""Error saving '%s'"", path);
            }
            close(src_fd_binary);
        }

        strcpy(path + path_len, ""/""FILENAME_COREDUMP);
        int abrt_core_fd = create_or_die(path);

        /* We write both coredumps at once.
         * We can't write user coredump first, since it might be truncated
         * and thus can't be copied and used as abrt coredump;
         * and if we write abrt coredump first and then copy it as user one,
         * then we have a race when process exits but coredump does not exist yet:
         * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
         * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
         * 21631 Segmentation fault (core dumped) ./test
         * ls: cannot access core*: No such file or directory <=== BAD
         */
        off_t core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
        if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
        {
            unlink(path);
            dd_delete(dd);
            if (user_core_fd >= 0)
            {
                xchdir(user_pwd);
                unlink(core_basename);
            }
            /* copyfd_sparse logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error writing '%s'"", path);
        }
        if (user_core_fd >= 0
            /* error writing user coredump? */
         && (fsync(user_core_fd) != 0 || close(user_core_fd) != 0
            /* user coredump is too big? */
            || (ulimit_c == 0 /* paranoia */ || core_size > ulimit_c)
            )
        ) {
            /* nuke it (silently) */
            xchdir(user_pwd);
             unlink(core_basename);
         }
 
         /* Save JVM crash log if it exists. (JVM's coredump per se
          * is nearly useless for JVM developers)
          */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    dd_delete(dd);
                    error_msg_and_die(""Error saving '%s'"", path);
                }
                 close(src_fd);
             }
         }
 
         /* We close dumpdir before we start catering for crash storm case.
          * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        path[path_len] = '\0'; /* path now contains only directory name */
        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);

        notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        free(rootdir);
        return 0;
    }

    /* We didn't create abrt dump, but may need to create compat coredump */
 create_user_core:
    if (user_core_fd >= 0)
    {
        off_t core_size = copyfd_size(STDIN_FILENO, user_core_fd, ulimit_c, COPYFD_SPARSE);
        if (fsync(user_core_fd) != 0 || close(user_core_fd) != 0 || core_size < 0)
        {
            /* perror first, otherwise unlink may trash errno */
            perror_msg(""Error writing '%s'"", full_core_basename);
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        if (ulimit_c == 0 || core_size > ulimit_c)
        {
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        log(""Saved core dump of pid %lu to %s (%llu bytes)"", (long)pid, full_core_basename, (long long)core_size);
    }

    return 0;
}
",C,"/* Because of #1211835 and #1126850 */
#if 0
#endif
",,,"@@ -795,6 +795,8 @@ int main(int argc, char** argv)
             unlink(core_basename);
         }
 
+/* Because of #1211835 and #1126850 */
+#if 0
         /* Save JVM crash log if it exists. (JVM's coredump per se
          * is nearly useless for JVM developers)
          */
@@ -827,6 +829,7 @@ int main(int argc, char** argv)
                 close(src_fd);
             }
         }
+#endif
 
         /* We close dumpdir before we start catering for crash storm case.
          * Otherwise, delete_dump_dir's from other concurrent",abrt,17cb66b13997b0159b4253b3f5722db79f476d68,80408e9e24a1c10f85fd969e1853e0f192157f92,1,"int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
	fd = xdup(fd);
    if (fd > 2)
	close(fd);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %h */
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME [HOSTNAME]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }

    struct utsname uts;
    if (!argv[8]) /* no HOSTNAME? */
    {
        uname(&uts);
        argv[8] = uts.nodename;
    }

    char path[PATH_MAX];

    int src_fd_binary = -1;
    char *executable = get_executable(pid, setting_SaveBinaryImage ? &src_fd_binary : NULL);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid();
    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
        {
            fsuid = tmp_fsuid;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        goto create_user_core;
    }

    const char *signame = NULL;
    switch (signal_no)
    {
        case SIGILL : signame = ""ILL"" ; break;
        case SIGFPE : signame = ""FPE"" ; break;
        case SIGSEGV: signame = ""SEGV""; break;
        case SIGBUS : signame = ""BUS"" ; break; //Bus error (bad memory access)
        case SIGABRT: signame = ""ABRT""; break; //usually when abort() was called
    // We have real-world reports from users who see buggy programs
    // dying with SIGTRAP, uncommented it too:
        case SIGTRAP: signame = ""TRAP""; break; //Trace/breakpoint trap
    // These usually aren't caused by bugs:
      //case SIGQUIT: signame = ""QUIT""; break; //Quit from keyboard
      //case SIGSYS : signame = ""SYS"" ; break; //Bad argument to routine (SVr4)
      //case SIGXCPU: signame = ""XCPU""; break; //CPU time limit exceeded (4.2BSD)
      //case SIGXFSZ: signame = ""XFSZ""; break; //File size limit exceeded (4.2BSD)
        default: goto create_user_core; // not a signal we care about
    }

    if (!daemon_is_ok())
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        goto create_user_core;
    }

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            goto create_user_core;
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        goto create_user_core;
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
        snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
        if (core_size < 0 || fsync(abrt_core_fd) != 0)
        {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        return 0;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        goto create_user_core;
    }

    /* use fsuid instead of uid, so we don't expose any sensitive
     * information of suided app in /var/tmp/abrt
     */
    dd = dd_create(path, fsuid, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char *rootdir = get_rootdir(pid);

        dd_create_basic_files(dd, fsuid, (rootdir && strcmp(rootdir, ""/"") != 0) ? rootdir : NULL);

        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/smaps"", (long)pid);
        source_base_ofs -= strlen(""smaps"");
        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;

        // Disabled for now: /proc/PID/smaps tends to be BIG,
        // and not much more informative than /proc/PID/maps:
        //copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(source_filename + source_base_ofs, ""maps"");
        strcpy(dest_base, FILENAME_MAPS);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(source_filename + source_base_ofs, ""limits"");
        strcpy(dest_base, FILENAME_LIMITS);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        strcpy(dest_base, FILENAME_CGROUP);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        dd_save_text(dd, FILENAME_ANALYZER, ""CCpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        if (src_fd_binary > 0)
        {
            strcpy(path + path_len, ""/""FILENAME_BINARY);
            int dst_fd = create_or_die(path);
            off_t sz = copyfd_eof(src_fd_binary, dst_fd, COPYFD_SPARSE);
            if (fsync(dst_fd) != 0 || close(dst_fd) != 0 || sz < 0)
            {
                dd_delete(dd);
                error_msg_and_die(""Error saving '%s'"", path);
            }
            close(src_fd_binary);
        }

        strcpy(path + path_len, ""/""FILENAME_COREDUMP);
        int abrt_core_fd = create_or_die(path);

        /* We write both coredumps at once.
         * We can't write user coredump first, since it might be truncated
         * and thus can't be copied and used as abrt coredump;
         * and if we write abrt coredump first and then copy it as user one,
         * then we have a race when process exits but coredump does not exist yet:
         * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
         * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
         * 21631 Segmentation fault (core dumped) ./test
         * ls: cannot access core*: No such file or directory <=== BAD
         */
        off_t core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
        if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
        {
            unlink(path);
            dd_delete(dd);
            if (user_core_fd >= 0)
            {
                xchdir(user_pwd);
                unlink(core_basename);
            }
            /* copyfd_sparse logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error writing '%s'"", path);
        }
        if (user_core_fd >= 0
            /* error writing user coredump? */
         && (fsync(user_core_fd) != 0 || close(user_core_fd) != 0
            /* user coredump is too big? */
            || (ulimit_c == 0 /* paranoia */ || core_size > ulimit_c)
            )
        ) {
            /* nuke it (silently) */
            xchdir(user_pwd);
             unlink(core_basename);
         }
 
//fix_flaw_line_below:
///* Because of #1211835 and #1126850 */
//fix_flaw_line_below:
//#if 0
         /* Save JVM crash log if it exists. (JVM's coredump per se
          * is nearly useless for JVM developers)
          */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    dd_delete(dd);
                    error_msg_and_die(""Error saving '%s'"", path);
                }
                 close(src_fd);
             }
         }
//fix_flaw_line_below:
//#endif
 
         /* We close dumpdir before we start catering for crash storm case.
          * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        path[path_len] = '\0'; /* path now contains only directory name */
        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);

        notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        free(rootdir);
        return 0;
    }

    /* We didn't create abrt dump, but may need to create compat coredump */
 create_user_core:
    if (user_core_fd >= 0)
    {
        off_t core_size = copyfd_size(STDIN_FILENO, user_core_fd, ulimit_c, COPYFD_SPARSE);
        if (fsync(user_core_fd) != 0 || close(user_core_fd) != 0 || core_size < 0)
        {
            /* perror first, otherwise unlink may trash errno */
            perror_msg(""Error writing '%s'"", full_core_basename);
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        if (ulimit_c == 0 || core_size > ulimit_c)
        {
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        log(""Saved core dump of pid %lu to %s (%llu bytes)"", (long)pid, full_core_basename, (long long)core_size);
    }

    return 0;
}
"
4350,182086,,Local,Not required,Partial,CVE-2014-4978,https://www.cvedetails.com/cve/CVE-2014-4978/,CWE-59,Low,,Partial,,2017-12-29,3.6,The rs_filter_graph function in librawstudio/rs-filter.c in rawstudio might allow local users to truncate arbitrary files via a symlink attack on (1) /tmp/rs-filter-graph.png or (2) /tmp/rs-filter-graph.,2018-01-10,,18,https://github.com/rawstudio/rawstudio/commit/9c2cd3c93c05d009a91d84eedbb85873b0cb505d,9c2cd3c93c05d009a91d84eedbb85873b0cb505d,Fixes insecure use of temporary file (CVE-2014-4978).,3,librawstudio/rs-filter.c,"{""sha"": ""352b23c51a00b32c4993732b1534ff5a988ee763"", ""filename"": ""librawstudio/rs-filter.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 3, ""changes"": 21, ""blob_url"": ""https://github.com/rawstudio/rawstudio/blob/9c2cd3c93c05d009a91d84eedbb85873b0cb505d/librawstudio/rs-filter.c"", ""raw_url"": ""https://github.com/rawstudio/rawstudio/raw/9c2cd3c93c05d009a91d84eedbb85873b0cb505d/librawstudio/rs-filter.c"", ""contents_url"": ""https://api.github.com/repos/rawstudio/rawstudio/contents/librawstudio/rs-filter.c?ref=9c2cd3c93c05d009a91d84eedbb85873b0cb505d"", ""patch"": ""@@ -772,17 +772,32 @@ void\n rs_filter_graph(RSFilter *filter)\n {\n \tg_return_if_fail(RS_IS_FILTER(filter));\n+\tgchar *dot_filename;\n+\tgchar *png_filename;\n+\tgchar *command_line;\n \tGString *str = g_string_new(\""digraph G {\\n\"");\n \n \trs_filter_graph_helper(str, filter);\n \n \tg_string_append_printf(str, \""}\\n\"");\n-\tg_file_set_contents(\""/tmp/rs-filter-graph\"", str->str, str->len, NULL);\n \n-\tif (0 != system(\""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\""))\n+\t/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */\n+\tdot_filename = g_strdup_printf(\""/tmp/rs-filter-graph.%u\"", g_random_int());\n+\tpng_filename = g_strdup_printf(\""%s.%u.png\"", dot_filename, g_random_int());\n+\n+\tg_file_set_contents(dot_filename, str->str, str->len, NULL);\n+\n+\tcommand_line = g_strdup_printf(\""dot -Tpng >%s <%s\"", png_filename, dot_filename);\n+\tif (0 != system(command_line))\n \t\tg_warning(\""Calling dot failed\"");\n-\tif (0 != system(\""gnome-open /tmp/rs-filter-graph.png\""))\n+\tg_free(command_line);\n+\n+\tcommand_line = g_strdup_printf(\""gnome-open %s\"", png_filename);\n+\tif (0 != system(command_line))\n \t\tg_warning(\""Calling gnome-open failed.\"");\n+\tg_free(command_line);\n \n+\tg_free(dot_filename);\n+\tg_free(png_filename);\n \tg_string_free(str, TRUE);\n }""}"," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
	gchar *dot_filename;
	gchar *png_filename;
	gchar *command_line;
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
 
	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());

	g_file_set_contents(dot_filename, str->str, str->len, NULL);

	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
	if (0 != system(command_line))
 		g_warning(""Calling dot failed"");
	g_free(command_line);

	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
	if (0 != system(command_line))
 		g_warning(""Calling gnome-open failed."");
	g_free(command_line);
 
	g_free(dot_filename);
	g_free(png_filename);
 	g_string_free(str, TRUE);
 }
"," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 
 	g_string_free(str, TRUE);
 }
",C,"	gchar *dot_filename;
	gchar *png_filename;
	gchar *command_line;
	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());

	g_file_set_contents(dot_filename, str->str, str->len, NULL);

	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
	if (0 != system(command_line))
	g_free(command_line);

	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
	if (0 != system(command_line))
	g_free(command_line);
	g_free(dot_filename);
	g_free(png_filename);
","	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
",,"@@ -772,17 +772,32 @@ void
 rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
+	gchar *dot_filename;
+	gchar *png_filename;
+	gchar *command_line;
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
-	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
-	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
+	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
+	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
+	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());
+
+	g_file_set_contents(dot_filename, str->str, str->len, NULL);
+
+	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
+	if (0 != system(command_line))
 		g_warning(""Calling dot failed"");
-	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
+	g_free(command_line);
+
+	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
+	if (0 != system(command_line))
 		g_warning(""Calling gnome-open failed."");
+	g_free(command_line);
 
+	g_free(dot_filename);
+	g_free(png_filename);
 	g_string_free(str, TRUE);
 }",rawstudio,9c2cd3c93c05d009a91d84eedbb85873b0cb505d,70f2da78b575ea1105eae865c7e49465b838bdfd,1," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
//fix_flaw_line_below:
//	gchar *dot_filename;
//fix_flaw_line_below:
//	gchar *png_filename;
//fix_flaw_line_below:
//	gchar *command_line;
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
//flaw_line_below:
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
//flaw_line_below:
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
//fix_flaw_line_below:
//	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
//fix_flaw_line_below:
//	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
//fix_flaw_line_below:
//	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	g_file_set_contents(dot_filename, str->str, str->len, NULL);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
//fix_flaw_line_below:
//	if (0 != system(command_line))
 		g_warning(""Calling dot failed"");
//flaw_line_below:
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
//fix_flaw_line_below:
//	g_free(command_line);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
//fix_flaw_line_below:
//	if (0 != system(command_line))
 		g_warning(""Calling gnome-open failed."");
//fix_flaw_line_below:
//	g_free(command_line);
 
//fix_flaw_line_below:
//	g_free(dot_filename);
//fix_flaw_line_below:
//	g_free(png_filename);
 	g_string_free(str, TRUE);
 }
"
4421,182157,,Local,Not required,Partial,CVE-2018-19044,https://www.cvedetails.com/cve/CVE-2018-19044/,CWE-59,Medium,,Partial,,2018-11-08,3.3,"keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",2019-08-06,,1,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,04f2d32871bb3b11d7dc024039952f2fe2750306,"When opening files for write, ensure they aren't symbolic links

Issue #1048 identified that if, for example, a non privileged user
created a symbolic link from /etc/keepalvied.data to /etc/passwd,
writing to /etc/keepalived.data (which could be invoked via DBus)
would cause /etc/passwd to be overwritten.

This commit stops keepalived writing to pathnames where the ultimate
component is a symbolic link, by setting O_NOFOLLOW whenever opening
a file for writing.

This might break some setups, where, for example, /etc/keepalived.data
was a symbolic link to /home/fred/keepalived.data. If this was the case,
instead create a symbolic link from /home/fred/keepalived.data to
/tmp/keepalived.data, so that the file is still accessible via
/home/fred/keepalived.data.

There doesn't appear to be a way around this backward incompatibility,
since even checking if the pathname is a symbolic link prior to opening
for writing would create a race condition.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",1,keepalived/core/main.c,"{""sha"": ""e494976f50b4eddbab13a2704287a14541c9043b"", ""filename"": ""keepalived/core/main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/main.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \""Unable to open config-test log file %s\\n\"", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);""}<_**next**_>{""sha"": ""83f6f2fa4c1f3f7e1704c4e32b7cb9f6aafb766e"", ""filename"": ""keepalived/core/pidfile.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/pidfile.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -60,7 +60,7 @@ int\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \""w\"");\n ""}<_**next**_>{""sha"": ""d16ef3d9a6e624e724b34e6c58c7cc8878c0da5a"", ""filename"": ""keepalived/core/smtp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/smtp.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\""/tmp/smtp-alert.log\"", \""a\"");\n+\tFILE *fp = fopen_safe(\""/tmp/smtp-alert.log\"", \""a\"");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];""}<_**next**_>{""sha"": ""4cfb16366fa244d607b85bfe2ecf613495c74eb3"", ""filename"": ""keepalived/vrrp/vrrp_dbus.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_dbus.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -594,7 +594,7 @@ read_file(gchar* filepath)\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \""rb\"");\n+\tf = fopen(filepath, \""r\"");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);""}<_**next**_>{""sha"": ""1a6ea873a250f9958d52e649399ef1398f7a2087"", ""filename"": ""keepalived/vrrp/vrrp_json.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_json.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""vrrp_iprule.h\""\n #include \""logger.h\""\n #include \""timer.h\""\n+#include \""utils.h\""\n \n static inline double\n timeval_to_double(const timeval_t *t)\n@@ -55,7 +56,7 @@ vrrp_print_json(void)\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\""/tmp/keepalived.json\"",\""w\"");\n+\tfile = fopen_safe(\""/tmp/keepalived.json\"", \""w\"");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open /tmp/keepalived.json (%d: %s)\"",\n \t\t\terrno, strerror(errno));""}<_**next**_>{""sha"": ""84704b415db95999319d3ecfe3ef8c650f20e083"", ""filename"": ""keepalived/vrrp/vrrp_parser.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \""w\""))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \""w\""))) {\n \t\t\tfprintf(tf, \""%d\\n\"", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}""}<_**next**_>{""sha"": ""aeb74bcbf5dca2f2f71faa32cf1ca91ffebed75b"", ""filename"": ""keepalived/vrrp/vrrp_print.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 10, ""changes"": 17, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_print.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -32,14 +32,15 @@\n #include \""vrrp.h\""\n #include \""vrrp_data.h\""\n #include \""vrrp_print.h\""\n+#include \""utils.h\""\n \n static const char *dump_file = \""/tmp/keepalived.data\"";\n static const char *stats_file = \""/tmp/keepalived.stats\"";\n \n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \""w\"");\n+\tFILE *file = fopen_safe(dump_file, \""w\"");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n@@ -55,28 +56,24 @@ vrrp_print_data(void)\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \""w\"");\n+\tFILE *file = fopen_safe(stats_file, \""w\"");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n \t\t\tstats_file, errno, strerror(errno));\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \""VRRP Instance: %s\\n\"", vrrp->iname);\n \t\tfprintf(file, \""  Advertisements:\\n\"");\n \t\tfprintf(file, \""    Received: %\"" PRIu64 \""\\n\"", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \""    Sent: %d\\n\"", vrrp->stats->advert_sent);\n \t\tfprintf(file, \""  Became master: %d\\n\"", vrrp->stats->become_master);\n-\t\tfprintf(file, \""  Released master: %d\\n\"",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \""  Released master: %d\\n\"", vrrp->stats->release_master);\n \t\tfprintf(file, \""  Packet Errors:\\n\"");\n \t\tfprintf(file, \""    Length: %\"" PRIu64 \""\\n\"", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \""    TTL: %\"" PRIu64 \""\\n\"", vrrp->stats->ip_ttl_err);""}<_**next**_>{""sha"": ""59217c6303694449716ba3308169b6a09539e821"", ""filename"": ""keepalived/vrrp/vrrp_scheduler.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_scheduler.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1134,7 +1134,7 @@ dump_threads(void)\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \""a\"");\n+\tfp = fopen_safe(file_name, \""a\"");\n \tFREE(file_name);\n \n \tset_time_now();""}<_**next**_>{""sha"": ""20153c800f219bb6f9c512f6970caf537e1ce5f0"", ""filename"": ""lib/logger.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/logger.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \""a\"");\n+\tlog_file = fopen_safe(file_name, \""a\"");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));""}<_**next**_>{""sha"": ""3001f3ebdcd9a411edb91ee8352f4f910b54e900"", ""filename"": ""lib/memory.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/memory.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)\n \t}\n \n \tsnprintf(log_name, log_name_len, \""/tmp/%s_mem.%d.log\"", prog_name, getpid());\n-\tlog_op = fopen(log_name, \""a\"");\n+\tlog_op = fopen_safe(log_name, \""a\"");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \""Unable to open %s for appending\"", log_name);\n \t\tlog_op = stderr;""}<_**next**_>{""sha"": ""3a8c0662a4e7a61bcbdf175f0f35c704d8e7e446"", ""filename"": ""lib/notify.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/notify.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \""Unable to open %snotify fifo %s - errno %d\"", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);""}<_**next**_>{""sha"": ""1d53595c0e876c459f5677f01ffeca9c99403e84"", ""filename"": ""lib/parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \""/tmp/keywords.%d\"", getpid());\n-\t\tfp = fopen(file_name, \""w\"");\n+\t\tfp = fopen_safe(file_name, \""w\"");\n \t\tif (!fp)\n \t\t\treturn;\n \t}""}<_**next**_>{""sha"": ""4aac594454bb3fddec3b72bbe4b8b099638ef5c8"", ""filename"": ""lib/utils.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 1, ""changes"": 43, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -123,7 +123,7 @@ write_stacktrace(const char *file_name, const char *str)\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \""%s\\n\"", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n@@ -788,6 +788,47 @@ string_equal(const char *str1, const char *str2)\n \treturn !strcmp(str1, str2);\n }\n \n+/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n+ * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\n+FILE *fopen_safe(const char *path, const char *mode)\n+{\n+\tint fd;\n+\tFILE *file;\n+\tint flags = O_NOFOLLOW | O_CREAT;\n+\n+\tif (mode[0] == 'r')\n+\t\treturn fopen(path, mode);\n+\n+\tif (mode[0] != 'a' && mode[0] != 'w')\n+\t\treturn NULL;\n+\n+\tif (mode[1] &&\n+\t    (mode[1] != '+' || mode[2]))\n+\t\treturn NULL;\n+\n+\tif (mode[0] == 'w')\n+\t\tflags |= O_TRUNC;\n+\telse\n+\t\tflags |= O_APPEND;\n+\n+\tif (mode[1])\n+\t\tflags |= O_RDWR;\n+\telse\n+\t\tflags |= O_WRONLY;\n+\n+\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n+\tif (fd == -1)\n+\t\treturn NULL;\n+\n+\tfile = fdopen (fd, \""w\"");\n+\tif (!file) {\n+\t\tclose(fd);\n+\t\treturn NULL;\n+\t}\n+\n+\treturn file;\n+}\n+\n void\n set_std_fd(bool force)\n {""}<_**next**_>{""sha"": ""19682d02546d7329c410a77ad1c9569a144b5434"", ""filename"": ""lib/utils.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.h?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -182,6 +182,7 @@ extern int inet_inaddrcmp(int, const void *, const void *);\n extern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\n extern char *get_local_name(void);\n extern bool string_equal(const char *, const char *);\n+extern FILE *fopen_safe(const char *, const char *);\n extern void set_std_fd(bool);\n extern void close_std_fd(void);\n #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_""}","parse_cmdline(int argc, char **argv)
{
	int c;
	bool reopen_log = false;
	int signum;
	struct utsname uname_buf;
	int longindex;
	int curind;
	bool bad_option = false;
	unsigned facility;
	mode_t new_umask_val;

	struct option long_options[] = {
		{""use-file"",		required_argument,	NULL, 'f'},
#if defined _WITH_VRRP_ && defined _WITH_LVS_
		{""vrrp"",		no_argument,		NULL, 'P'},
		{""check"",		no_argument,		NULL, 'C'},
#endif
#ifdef _WITH_BFD_
		{""no_bfd"",		no_argument,		NULL, 'B'},
#endif
		{""all"",			no_argument,		NULL,  3 },
		{""log-console"",		no_argument,		NULL, 'l'},
		{""log-detail"",		no_argument,		NULL, 'D'},
		{""log-facility"",	required_argument,	NULL, 'S'},
		{""log-file"",		optional_argument,	NULL, 'g'},
		{""flush-log-file"",	no_argument,		NULL,  2 },
		{""no-syslog"",		no_argument,		NULL, 'G'},
		{""umask"",		required_argument,	NULL, 'u'},
#ifdef _WITH_VRRP_
		{""release-vips"",	no_argument,		NULL, 'X'},
		{""dont-release-vrrp"",	no_argument,		NULL, 'V'},
#endif
#ifdef _WITH_LVS_
		{""dont-release-ipvs"",	no_argument,		NULL, 'I'},
#endif
		{""dont-respawn"",	no_argument,		NULL, 'R'},
		{""dont-fork"",		no_argument,		NULL, 'n'},
		{""dump-conf"",		no_argument,		NULL, 'd'},
		{""pid"",			required_argument,	NULL, 'p'},
#ifdef _WITH_VRRP_
		{""vrrp_pid"",		required_argument,	NULL, 'r'},
#endif
#ifdef _WITH_LVS_
		{""checkers_pid"",	required_argument,	NULL, 'c'},
		{""address-monitoring"",	no_argument,		NULL, 'a'},
#endif
#ifdef _WITH_BFD_
		{""bfd_pid"",		required_argument,	NULL, 'b'},
#endif
#ifdef _WITH_SNMP_
		{""snmp"",		no_argument,		NULL, 'x'},
		{""snmp-agent-socket"",	required_argument,	NULL, 'A'},
#endif
		{""core-dump"",		no_argument,		NULL, 'm'},
		{""core-dump-pattern"",	optional_argument,	NULL, 'M'},
#ifdef _MEM_CHECK_LOG_
		{""mem-check-log"",	no_argument,		NULL, 'L'},
#endif
#if HAVE_DECL_CLONE_NEWNET
		{""namespace"",		required_argument,	NULL, 's'},
#endif
		{""config-id"",		required_argument,	NULL, 'i'},
		{""signum"",		required_argument,	NULL,  4 },
		{""config-test"",		optional_argument,	NULL, 't'},
#ifdef _WITH_PERF_
		{""perf"",		optional_argument,	NULL,  5 },
#endif
#ifdef WITH_DEBUG_OPTIONS
		{""debug"",		optional_argument,	NULL,  6 },
#endif
		{""version"",		no_argument,		NULL, 'v'},
		{""help"",		no_argument,		NULL, 'h'},

		{NULL,			0,			NULL,  0 }
	};

	/* Unfortunately, if a short option is used, getopt_long() doesn't change the value
	 * of longindex, so we need to ensure that before calling getopt_long(), longindex
	 * is set to a known invalid value */
	curind = optind;
	while (longindex = -1, (c = getopt_long(argc, argv, "":vhlndu:DRS:f:p:i:mM::g::Gt::""
#if defined _WITH_VRRP_ && defined _WITH_LVS_
					    ""PC""
#endif
#ifdef _WITH_VRRP_
					    ""r:VX""
#endif
#ifdef _WITH_LVS_
					    ""ac:I""
#endif
#ifdef _WITH_BFD_
					    ""Bb:""
#endif
#ifdef _WITH_SNMP_
					    ""xA:""
#endif
#ifdef _MEM_CHECK_LOG_
					    ""L""
#endif
#if HAVE_DECL_CLONE_NEWNET
					    ""s:""
#endif
				, long_options, &longindex)) != -1) {

		/* Check for an empty option argument. For example --use-file= returns
		 * a 0 length option, which we don't want */
		if (longindex >= 0 && long_options[longindex].has_arg == required_argument && optarg && !optarg[0]) {
			c = ':';
			optarg = NULL;
		}

		switch (c) {
		case 'v':
			fprintf(stderr, ""%s"", version_string);
#ifdef GIT_COMMIT
			fprintf(stderr, "", git commit %s"", GIT_COMMIT);
#endif
			fprintf(stderr, ""\n\n%s\n\n"", COPYRIGHT_STRING);
			fprintf(stderr, ""Built with kernel headers for Linux %d.%d.%d\n"",
						(LINUX_VERSION_CODE >> 16) & 0xff,
						(LINUX_VERSION_CODE >>  8) & 0xff,
						(LINUX_VERSION_CODE      ) & 0xff);
			uname(&uname_buf);
			fprintf(stderr, ""Running on %s %s %s\n\n"", uname_buf.sysname, uname_buf.release, uname_buf.version);
			fprintf(stderr, ""configure options: %s\n\n"", KEEPALIVED_CONFIGURE_OPTIONS);
			fprintf(stderr, ""Config options: %s\n\n"", CONFIGURATION_OPTIONS);
			fprintf(stderr, ""System options: %s\n"", SYSTEM_OPTIONS);
			exit(0);
			break;
		case 'h':
			usage(argv[0]);
			exit(0);
			break;
		case 'l':
			__set_bit(LOG_CONSOLE_BIT, &debug);
			reopen_log = true;
			break;
		case 'n':
			__set_bit(DONT_FORK_BIT, &debug);
			break;
		case 'd':
			__set_bit(DUMP_CONF_BIT, &debug);
			break;
#ifdef _WITH_VRRP_
		case 'V':
			__set_bit(DONT_RELEASE_VRRP_BIT, &debug);
			break;
#endif
#ifdef _WITH_LVS_
		case 'I':
			__set_bit(DONT_RELEASE_IPVS_BIT, &debug);
			break;
#endif
		case 'D':
			if (__test_bit(LOG_DETAIL_BIT, &debug))
				__set_bit(LOG_EXTRA_DETAIL_BIT, &debug);
			else
				__set_bit(LOG_DETAIL_BIT, &debug);
			break;
		case 'R':
			__set_bit(DONT_RESPAWN_BIT, &debug);
			break;
#ifdef _WITH_VRRP_
		case 'X':
			__set_bit(RELEASE_VIPS_BIT, &debug);
			break;
#endif
		case 'S':
			if (!read_unsigned(optarg, &facility, 0, LOG_FACILITY_MAX, false))
				fprintf(stderr, ""Invalid log facility '%s'\n"", optarg);
			else {
				log_facility = LOG_FACILITY[facility].facility;
				reopen_log = true;
			}
			break;
		case 'g':
			if (optarg && optarg[0])
				log_file_name = optarg;
			else
				log_file_name = ""/tmp/keepalived.log"";
			open_log_file(log_file_name, NULL, NULL, NULL);
			break;
		case 'G':
			__set_bit(NO_SYSLOG_BIT, &debug);
			reopen_log = true;
			break;
		case 'u':
			new_umask_val = set_umask(optarg);
			if (umask_cmdline)
				umask_val = new_umask_val;
			break;
		case 't':
			__set_bit(CONFIG_TEST_BIT, &debug);
			__set_bit(DONT_RESPAWN_BIT, &debug);
 			__set_bit(DONT_FORK_BIT, &debug);
 			__set_bit(NO_SYSLOG_BIT, &debug);
 			if (optarg && optarg[0]) {
				int fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 				if (fd == -1) {
 					fprintf(stderr, ""Unable to open config-test log file %s\n"", optarg);
 					exit(EXIT_FAILURE);
				}
				dup2(fd, STDERR_FILENO);
				close(fd);
			}
			break;
		case 'f':
			conf_file = optarg;
			break;
		case 2:		/* --flush-log-file */
			set_flush_log_file();
			break;
#if defined _WITH_VRRP_ && defined _WITH_LVS_
		case 'P':
			__clear_bit(DAEMON_CHECKERS, &daemon_mode);
			break;
		case 'C':
			__clear_bit(DAEMON_VRRP, &daemon_mode);
			break;
#endif
#ifdef _WITH_BFD_
		case 'B':
			__clear_bit(DAEMON_BFD, &daemon_mode);
			break;
#endif
		case 'p':
			main_pidfile = optarg;
			break;
#ifdef _WITH_LVS_
		case 'c':
			checkers_pidfile = optarg;
			break;
		case 'a':
			__set_bit(LOG_ADDRESS_CHANGES, &debug);
			break;
#endif
#ifdef _WITH_VRRP_
		case 'r':
			vrrp_pidfile = optarg;
			break;
#endif
#ifdef _WITH_BFD_
		case 'b':
			bfd_pidfile = optarg;
			break;
#endif
#ifdef _WITH_SNMP_
		case 'x':
			snmp = 1;
			break;
		case 'A':
			snmp_socket = optarg;
			break;
#endif
		case 'M':
			set_core_dump_pattern = true;
			if (optarg && optarg[0])
				core_dump_pattern = optarg;
			/* ... falls through ... */
		case 'm':
			create_core_dump = true;
			break;
#ifdef _MEM_CHECK_LOG_
		case 'L':
			__set_bit(MEM_CHECK_LOG_BIT, &debug);
			break;
#endif
#if HAVE_DECL_CLONE_NEWNET
		case 's':
			override_namespace = MALLOC(strlen(optarg) + 1);
			strcpy(override_namespace, optarg);
			break;
#endif
		case 'i':
			FREE_PTR(config_id);
			config_id = MALLOC(strlen(optarg) + 1);
			strcpy(config_id, optarg);
			break;
		case 4:			/* --signum */
			signum = get_signum(optarg);
			if (signum == -1) {
				fprintf(stderr, ""Unknown sigfunc %s\n"", optarg);
				exit(1);
			}

			printf(""%d\n"", signum);
			exit(0);
			break;
		case 3:			/* --all */
			__set_bit(RUN_ALL_CHILDREN, &daemon_mode);
#ifdef _WITH_VRRP_
			__set_bit(DAEMON_VRRP, &daemon_mode);
#endif
#ifdef _WITH_LVS_
			__set_bit(DAEMON_CHECKERS, &daemon_mode);
#endif
#ifdef _WITH_BFD_
			__set_bit(DAEMON_BFD, &daemon_mode);
#endif
			break;
#ifdef _WITH_PERF_
		case 5:
			if (optarg && optarg[0]) {
				if (!strcmp(optarg, ""run""))
					perf_run = PERF_RUN;
				else if (!strcmp(optarg, ""all""))
					perf_run = PERF_ALL;
				else if (!strcmp(optarg, ""end""))
					perf_run = PERF_END;
				else
					log_message(LOG_INFO, ""Unknown perf start point %s"", optarg);
			}
			else
				perf_run = PERF_RUN;

			break;
#endif
#ifdef WITH_DEBUG_OPTIONS
		case 6:
			set_debug_options(optarg && optarg[0] ? optarg : NULL);
			break;
#endif
		case '?':
			if (optopt && argv[curind][1] != '-')
				fprintf(stderr, ""Unknown option -%c\n"", optopt);
			else
				fprintf(stderr, ""Unknown option %s\n"", argv[curind]);
			bad_option = true;
			break;
		case ':':
			if (optopt && argv[curind][1] != '-')
				fprintf(stderr, ""Missing parameter for option -%c\n"", optopt);
			else
				fprintf(stderr, ""Missing parameter for option --%s\n"", long_options[longindex].name);
			bad_option = true;
			break;
		default:
			exit(1);
			break;
		}
		curind = optind;
	}

	if (optind < argc) {
		printf(""Unexpected argument(s): "");
		while (optind < argc)
			printf(""%s "", argv[optind++]);
		printf(""\n"");
	}

	if (bad_option)
		exit(1);

	return reopen_log;
}
","parse_cmdline(int argc, char **argv)
{
	int c;
	bool reopen_log = false;
	int signum;
	struct utsname uname_buf;
	int longindex;
	int curind;
	bool bad_option = false;
	unsigned facility;
	mode_t new_umask_val;

	struct option long_options[] = {
		{""use-file"",		required_argument,	NULL, 'f'},
#if defined _WITH_VRRP_ && defined _WITH_LVS_
		{""vrrp"",		no_argument,		NULL, 'P'},
		{""check"",		no_argument,		NULL, 'C'},
#endif
#ifdef _WITH_BFD_
		{""no_bfd"",		no_argument,		NULL, 'B'},
#endif
		{""all"",			no_argument,		NULL,  3 },
		{""log-console"",		no_argument,		NULL, 'l'},
		{""log-detail"",		no_argument,		NULL, 'D'},
		{""log-facility"",	required_argument,	NULL, 'S'},
		{""log-file"",		optional_argument,	NULL, 'g'},
		{""flush-log-file"",	no_argument,		NULL,  2 },
		{""no-syslog"",		no_argument,		NULL, 'G'},
		{""umask"",		required_argument,	NULL, 'u'},
#ifdef _WITH_VRRP_
		{""release-vips"",	no_argument,		NULL, 'X'},
		{""dont-release-vrrp"",	no_argument,		NULL, 'V'},
#endif
#ifdef _WITH_LVS_
		{""dont-release-ipvs"",	no_argument,		NULL, 'I'},
#endif
		{""dont-respawn"",	no_argument,		NULL, 'R'},
		{""dont-fork"",		no_argument,		NULL, 'n'},
		{""dump-conf"",		no_argument,		NULL, 'd'},
		{""pid"",			required_argument,	NULL, 'p'},
#ifdef _WITH_VRRP_
		{""vrrp_pid"",		required_argument,	NULL, 'r'},
#endif
#ifdef _WITH_LVS_
		{""checkers_pid"",	required_argument,	NULL, 'c'},
		{""address-monitoring"",	no_argument,		NULL, 'a'},
#endif
#ifdef _WITH_BFD_
		{""bfd_pid"",		required_argument,	NULL, 'b'},
#endif
#ifdef _WITH_SNMP_
		{""snmp"",		no_argument,		NULL, 'x'},
		{""snmp-agent-socket"",	required_argument,	NULL, 'A'},
#endif
		{""core-dump"",		no_argument,		NULL, 'm'},
		{""core-dump-pattern"",	optional_argument,	NULL, 'M'},
#ifdef _MEM_CHECK_LOG_
		{""mem-check-log"",	no_argument,		NULL, 'L'},
#endif
#if HAVE_DECL_CLONE_NEWNET
		{""namespace"",		required_argument,	NULL, 's'},
#endif
		{""config-id"",		required_argument,	NULL, 'i'},
		{""signum"",		required_argument,	NULL,  4 },
		{""config-test"",		optional_argument,	NULL, 't'},
#ifdef _WITH_PERF_
		{""perf"",		optional_argument,	NULL,  5 },
#endif
#ifdef WITH_DEBUG_OPTIONS
		{""debug"",		optional_argument,	NULL,  6 },
#endif
		{""version"",		no_argument,		NULL, 'v'},
		{""help"",		no_argument,		NULL, 'h'},

		{NULL,			0,			NULL,  0 }
	};

	/* Unfortunately, if a short option is used, getopt_long() doesn't change the value
	 * of longindex, so we need to ensure that before calling getopt_long(), longindex
	 * is set to a known invalid value */
	curind = optind;
	while (longindex = -1, (c = getopt_long(argc, argv, "":vhlndu:DRS:f:p:i:mM::g::Gt::""
#if defined _WITH_VRRP_ && defined _WITH_LVS_
					    ""PC""
#endif
#ifdef _WITH_VRRP_
					    ""r:VX""
#endif
#ifdef _WITH_LVS_
					    ""ac:I""
#endif
#ifdef _WITH_BFD_
					    ""Bb:""
#endif
#ifdef _WITH_SNMP_
					    ""xA:""
#endif
#ifdef _MEM_CHECK_LOG_
					    ""L""
#endif
#if HAVE_DECL_CLONE_NEWNET
					    ""s:""
#endif
				, long_options, &longindex)) != -1) {

		/* Check for an empty option argument. For example --use-file= returns
		 * a 0 length option, which we don't want */
		if (longindex >= 0 && long_options[longindex].has_arg == required_argument && optarg && !optarg[0]) {
			c = ':';
			optarg = NULL;
		}

		switch (c) {
		case 'v':
			fprintf(stderr, ""%s"", version_string);
#ifdef GIT_COMMIT
			fprintf(stderr, "", git commit %s"", GIT_COMMIT);
#endif
			fprintf(stderr, ""\n\n%s\n\n"", COPYRIGHT_STRING);
			fprintf(stderr, ""Built with kernel headers for Linux %d.%d.%d\n"",
						(LINUX_VERSION_CODE >> 16) & 0xff,
						(LINUX_VERSION_CODE >>  8) & 0xff,
						(LINUX_VERSION_CODE      ) & 0xff);
			uname(&uname_buf);
			fprintf(stderr, ""Running on %s %s %s\n\n"", uname_buf.sysname, uname_buf.release, uname_buf.version);
			fprintf(stderr, ""configure options: %s\n\n"", KEEPALIVED_CONFIGURE_OPTIONS);
			fprintf(stderr, ""Config options: %s\n\n"", CONFIGURATION_OPTIONS);
			fprintf(stderr, ""System options: %s\n"", SYSTEM_OPTIONS);
			exit(0);
			break;
		case 'h':
			usage(argv[0]);
			exit(0);
			break;
		case 'l':
			__set_bit(LOG_CONSOLE_BIT, &debug);
			reopen_log = true;
			break;
		case 'n':
			__set_bit(DONT_FORK_BIT, &debug);
			break;
		case 'd':
			__set_bit(DUMP_CONF_BIT, &debug);
			break;
#ifdef _WITH_VRRP_
		case 'V':
			__set_bit(DONT_RELEASE_VRRP_BIT, &debug);
			break;
#endif
#ifdef _WITH_LVS_
		case 'I':
			__set_bit(DONT_RELEASE_IPVS_BIT, &debug);
			break;
#endif
		case 'D':
			if (__test_bit(LOG_DETAIL_BIT, &debug))
				__set_bit(LOG_EXTRA_DETAIL_BIT, &debug);
			else
				__set_bit(LOG_DETAIL_BIT, &debug);
			break;
		case 'R':
			__set_bit(DONT_RESPAWN_BIT, &debug);
			break;
#ifdef _WITH_VRRP_
		case 'X':
			__set_bit(RELEASE_VIPS_BIT, &debug);
			break;
#endif
		case 'S':
			if (!read_unsigned(optarg, &facility, 0, LOG_FACILITY_MAX, false))
				fprintf(stderr, ""Invalid log facility '%s'\n"", optarg);
			else {
				log_facility = LOG_FACILITY[facility].facility;
				reopen_log = true;
			}
			break;
		case 'g':
			if (optarg && optarg[0])
				log_file_name = optarg;
			else
				log_file_name = ""/tmp/keepalived.log"";
			open_log_file(log_file_name, NULL, NULL, NULL);
			break;
		case 'G':
			__set_bit(NO_SYSLOG_BIT, &debug);
			reopen_log = true;
			break;
		case 'u':
			new_umask_val = set_umask(optarg);
			if (umask_cmdline)
				umask_val = new_umask_val;
			break;
		case 't':
			__set_bit(CONFIG_TEST_BIT, &debug);
			__set_bit(DONT_RESPAWN_BIT, &debug);
 			__set_bit(DONT_FORK_BIT, &debug);
 			__set_bit(NO_SYSLOG_BIT, &debug);
 			if (optarg && optarg[0]) {
				int fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 				if (fd == -1) {
 					fprintf(stderr, ""Unable to open config-test log file %s\n"", optarg);
 					exit(EXIT_FAILURE);
				}
				dup2(fd, STDERR_FILENO);
				close(fd);
			}
			break;
		case 'f':
			conf_file = optarg;
			break;
		case 2:		/* --flush-log-file */
			set_flush_log_file();
			break;
#if defined _WITH_VRRP_ && defined _WITH_LVS_
		case 'P':
			__clear_bit(DAEMON_CHECKERS, &daemon_mode);
			break;
		case 'C':
			__clear_bit(DAEMON_VRRP, &daemon_mode);
			break;
#endif
#ifdef _WITH_BFD_
		case 'B':
			__clear_bit(DAEMON_BFD, &daemon_mode);
			break;
#endif
		case 'p':
			main_pidfile = optarg;
			break;
#ifdef _WITH_LVS_
		case 'c':
			checkers_pidfile = optarg;
			break;
		case 'a':
			__set_bit(LOG_ADDRESS_CHANGES, &debug);
			break;
#endif
#ifdef _WITH_VRRP_
		case 'r':
			vrrp_pidfile = optarg;
			break;
#endif
#ifdef _WITH_BFD_
		case 'b':
			bfd_pidfile = optarg;
			break;
#endif
#ifdef _WITH_SNMP_
		case 'x':
			snmp = 1;
			break;
		case 'A':
			snmp_socket = optarg;
			break;
#endif
		case 'M':
			set_core_dump_pattern = true;
			if (optarg && optarg[0])
				core_dump_pattern = optarg;
			/* ... falls through ... */
		case 'm':
			create_core_dump = true;
			break;
#ifdef _MEM_CHECK_LOG_
		case 'L':
			__set_bit(MEM_CHECK_LOG_BIT, &debug);
			break;
#endif
#if HAVE_DECL_CLONE_NEWNET
		case 's':
			override_namespace = MALLOC(strlen(optarg) + 1);
			strcpy(override_namespace, optarg);
			break;
#endif
		case 'i':
			FREE_PTR(config_id);
			config_id = MALLOC(strlen(optarg) + 1);
			strcpy(config_id, optarg);
			break;
		case 4:			/* --signum */
			signum = get_signum(optarg);
			if (signum == -1) {
				fprintf(stderr, ""Unknown sigfunc %s\n"", optarg);
				exit(1);
			}

			printf(""%d\n"", signum);
			exit(0);
			break;
		case 3:			/* --all */
			__set_bit(RUN_ALL_CHILDREN, &daemon_mode);
#ifdef _WITH_VRRP_
			__set_bit(DAEMON_VRRP, &daemon_mode);
#endif
#ifdef _WITH_LVS_
			__set_bit(DAEMON_CHECKERS, &daemon_mode);
#endif
#ifdef _WITH_BFD_
			__set_bit(DAEMON_BFD, &daemon_mode);
#endif
			break;
#ifdef _WITH_PERF_
		case 5:
			if (optarg && optarg[0]) {
				if (!strcmp(optarg, ""run""))
					perf_run = PERF_RUN;
				else if (!strcmp(optarg, ""all""))
					perf_run = PERF_ALL;
				else if (!strcmp(optarg, ""end""))
					perf_run = PERF_END;
				else
					log_message(LOG_INFO, ""Unknown perf start point %s"", optarg);
			}
			else
				perf_run = PERF_RUN;

			break;
#endif
#ifdef WITH_DEBUG_OPTIONS
		case 6:
			set_debug_options(optarg && optarg[0] ? optarg : NULL);
			break;
#endif
		case '?':
			if (optopt && argv[curind][1] != '-')
				fprintf(stderr, ""Unknown option -%c\n"", optopt);
			else
				fprintf(stderr, ""Unknown option %s\n"", argv[curind]);
			bad_option = true;
			break;
		case ':':
			if (optopt && argv[curind][1] != '-')
				fprintf(stderr, ""Missing parameter for option -%c\n"", optopt);
			else
				fprintf(stderr, ""Missing parameter for option --%s\n"", long_options[longindex].name);
			bad_option = true;
			break;
		default:
			exit(1);
			break;
		}
		curind = optind;
	}

	if (optind < argc) {
		printf(""Unexpected argument(s): "");
		while (optind < argc)
			printf(""%s "", argv[optind++]);
		printf(""\n"");
	}

	if (bad_option)
		exit(1);

	return reopen_log;
}
",C,"				int fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
","				int fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
",,"@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)
 			__set_bit(DONT_FORK_BIT, &debug);
 			__set_bit(NO_SYSLOG_BIT, &debug);
 			if (optarg && optarg[0]) {
-				int fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+				int fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 				if (fd == -1) {
 					fprintf(stderr, ""Unable to open config-test log file %s\n"", optarg);
 					exit(EXIT_FAILURE);",keepalived,04f2d32871bb3b11d7dc024039952f2fe2750306,5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,1,"parse_cmdline(int argc, char **argv)
{
	int c;
	bool reopen_log = false;
	int signum;
	struct utsname uname_buf;
	int longindex;
	int curind;
	bool bad_option = false;
	unsigned facility;
	mode_t new_umask_val;

	struct option long_options[] = {
		{""use-file"",		required_argument,	NULL, 'f'},
#if defined _WITH_VRRP_ && defined _WITH_LVS_
		{""vrrp"",		no_argument,		NULL, 'P'},
		{""check"",		no_argument,		NULL, 'C'},
#endif
#ifdef _WITH_BFD_
		{""no_bfd"",		no_argument,		NULL, 'B'},
#endif
		{""all"",			no_argument,		NULL,  3 },
		{""log-console"",		no_argument,		NULL, 'l'},
		{""log-detail"",		no_argument,		NULL, 'D'},
		{""log-facility"",	required_argument,	NULL, 'S'},
		{""log-file"",		optional_argument,	NULL, 'g'},
		{""flush-log-file"",	no_argument,		NULL,  2 },
		{""no-syslog"",		no_argument,		NULL, 'G'},
		{""umask"",		required_argument,	NULL, 'u'},
#ifdef _WITH_VRRP_
		{""release-vips"",	no_argument,		NULL, 'X'},
		{""dont-release-vrrp"",	no_argument,		NULL, 'V'},
#endif
#ifdef _WITH_LVS_
		{""dont-release-ipvs"",	no_argument,		NULL, 'I'},
#endif
		{""dont-respawn"",	no_argument,		NULL, 'R'},
		{""dont-fork"",		no_argument,		NULL, 'n'},
		{""dump-conf"",		no_argument,		NULL, 'd'},
		{""pid"",			required_argument,	NULL, 'p'},
#ifdef _WITH_VRRP_
		{""vrrp_pid"",		required_argument,	NULL, 'r'},
#endif
#ifdef _WITH_LVS_
		{""checkers_pid"",	required_argument,	NULL, 'c'},
		{""address-monitoring"",	no_argument,		NULL, 'a'},
#endif
#ifdef _WITH_BFD_
		{""bfd_pid"",		required_argument,	NULL, 'b'},
#endif
#ifdef _WITH_SNMP_
		{""snmp"",		no_argument,		NULL, 'x'},
		{""snmp-agent-socket"",	required_argument,	NULL, 'A'},
#endif
		{""core-dump"",		no_argument,		NULL, 'm'},
		{""core-dump-pattern"",	optional_argument,	NULL, 'M'},
#ifdef _MEM_CHECK_LOG_
		{""mem-check-log"",	no_argument,		NULL, 'L'},
#endif
#if HAVE_DECL_CLONE_NEWNET
		{""namespace"",		required_argument,	NULL, 's'},
#endif
		{""config-id"",		required_argument,	NULL, 'i'},
		{""signum"",		required_argument,	NULL,  4 },
		{""config-test"",		optional_argument,	NULL, 't'},
#ifdef _WITH_PERF_
		{""perf"",		optional_argument,	NULL,  5 },
#endif
#ifdef WITH_DEBUG_OPTIONS
		{""debug"",		optional_argument,	NULL,  6 },
#endif
		{""version"",		no_argument,		NULL, 'v'},
		{""help"",		no_argument,		NULL, 'h'},

		{NULL,			0,			NULL,  0 }
	};

	/* Unfortunately, if a short option is used, getopt_long() doesn't change the value
	 * of longindex, so we need to ensure that before calling getopt_long(), longindex
	 * is set to a known invalid value */
	curind = optind;
	while (longindex = -1, (c = getopt_long(argc, argv, "":vhlndu:DRS:f:p:i:mM::g::Gt::""
#if defined _WITH_VRRP_ && defined _WITH_LVS_
					    ""PC""
#endif
#ifdef _WITH_VRRP_
					    ""r:VX""
#endif
#ifdef _WITH_LVS_
					    ""ac:I""
#endif
#ifdef _WITH_BFD_
					    ""Bb:""
#endif
#ifdef _WITH_SNMP_
					    ""xA:""
#endif
#ifdef _MEM_CHECK_LOG_
					    ""L""
#endif
#if HAVE_DECL_CLONE_NEWNET
					    ""s:""
#endif
				, long_options, &longindex)) != -1) {

		/* Check for an empty option argument. For example --use-file= returns
		 * a 0 length option, which we don't want */
		if (longindex >= 0 && long_options[longindex].has_arg == required_argument && optarg && !optarg[0]) {
			c = ':';
			optarg = NULL;
		}

		switch (c) {
		case 'v':
			fprintf(stderr, ""%s"", version_string);
#ifdef GIT_COMMIT
			fprintf(stderr, "", git commit %s"", GIT_COMMIT);
#endif
			fprintf(stderr, ""\n\n%s\n\n"", COPYRIGHT_STRING);
			fprintf(stderr, ""Built with kernel headers for Linux %d.%d.%d\n"",
						(LINUX_VERSION_CODE >> 16) & 0xff,
						(LINUX_VERSION_CODE >>  8) & 0xff,
						(LINUX_VERSION_CODE      ) & 0xff);
			uname(&uname_buf);
			fprintf(stderr, ""Running on %s %s %s\n\n"", uname_buf.sysname, uname_buf.release, uname_buf.version);
			fprintf(stderr, ""configure options: %s\n\n"", KEEPALIVED_CONFIGURE_OPTIONS);
			fprintf(stderr, ""Config options: %s\n\n"", CONFIGURATION_OPTIONS);
			fprintf(stderr, ""System options: %s\n"", SYSTEM_OPTIONS);
			exit(0);
			break;
		case 'h':
			usage(argv[0]);
			exit(0);
			break;
		case 'l':
			__set_bit(LOG_CONSOLE_BIT, &debug);
			reopen_log = true;
			break;
		case 'n':
			__set_bit(DONT_FORK_BIT, &debug);
			break;
		case 'd':
			__set_bit(DUMP_CONF_BIT, &debug);
			break;
#ifdef _WITH_VRRP_
		case 'V':
			__set_bit(DONT_RELEASE_VRRP_BIT, &debug);
			break;
#endif
#ifdef _WITH_LVS_
		case 'I':
			__set_bit(DONT_RELEASE_IPVS_BIT, &debug);
			break;
#endif
		case 'D':
			if (__test_bit(LOG_DETAIL_BIT, &debug))
				__set_bit(LOG_EXTRA_DETAIL_BIT, &debug);
			else
				__set_bit(LOG_DETAIL_BIT, &debug);
			break;
		case 'R':
			__set_bit(DONT_RESPAWN_BIT, &debug);
			break;
#ifdef _WITH_VRRP_
		case 'X':
			__set_bit(RELEASE_VIPS_BIT, &debug);
			break;
#endif
		case 'S':
			if (!read_unsigned(optarg, &facility, 0, LOG_FACILITY_MAX, false))
				fprintf(stderr, ""Invalid log facility '%s'\n"", optarg);
			else {
				log_facility = LOG_FACILITY[facility].facility;
				reopen_log = true;
			}
			break;
		case 'g':
			if (optarg && optarg[0])
				log_file_name = optarg;
			else
				log_file_name = ""/tmp/keepalived.log"";
			open_log_file(log_file_name, NULL, NULL, NULL);
			break;
		case 'G':
			__set_bit(NO_SYSLOG_BIT, &debug);
			reopen_log = true;
			break;
		case 'u':
			new_umask_val = set_umask(optarg);
			if (umask_cmdline)
				umask_val = new_umask_val;
			break;
		case 't':
			__set_bit(CONFIG_TEST_BIT, &debug);
			__set_bit(DONT_RESPAWN_BIT, &debug);
 			__set_bit(DONT_FORK_BIT, &debug);
 			__set_bit(NO_SYSLOG_BIT, &debug);
 			if (optarg && optarg[0]) {
//flaw_line_below:
				int fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
//fix_flaw_line_below:
//				int fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 				if (fd == -1) {
 					fprintf(stderr, ""Unable to open config-test log file %s\n"", optarg);
 					exit(EXIT_FAILURE);
				}
				dup2(fd, STDERR_FILENO);
				close(fd);
			}
			break;
		case 'f':
			conf_file = optarg;
			break;
		case 2:		/* --flush-log-file */
			set_flush_log_file();
			break;
#if defined _WITH_VRRP_ && defined _WITH_LVS_
		case 'P':
			__clear_bit(DAEMON_CHECKERS, &daemon_mode);
			break;
		case 'C':
			__clear_bit(DAEMON_VRRP, &daemon_mode);
			break;
#endif
#ifdef _WITH_BFD_
		case 'B':
			__clear_bit(DAEMON_BFD, &daemon_mode);
			break;
#endif
		case 'p':
			main_pidfile = optarg;
			break;
#ifdef _WITH_LVS_
		case 'c':
			checkers_pidfile = optarg;
			break;
		case 'a':
			__set_bit(LOG_ADDRESS_CHANGES, &debug);
			break;
#endif
#ifdef _WITH_VRRP_
		case 'r':
			vrrp_pidfile = optarg;
			break;
#endif
#ifdef _WITH_BFD_
		case 'b':
			bfd_pidfile = optarg;
			break;
#endif
#ifdef _WITH_SNMP_
		case 'x':
			snmp = 1;
			break;
		case 'A':
			snmp_socket = optarg;
			break;
#endif
		case 'M':
			set_core_dump_pattern = true;
			if (optarg && optarg[0])
				core_dump_pattern = optarg;
			/* ... falls through ... */
		case 'm':
			create_core_dump = true;
			break;
#ifdef _MEM_CHECK_LOG_
		case 'L':
			__set_bit(MEM_CHECK_LOG_BIT, &debug);
			break;
#endif
#if HAVE_DECL_CLONE_NEWNET
		case 's':
			override_namespace = MALLOC(strlen(optarg) + 1);
			strcpy(override_namespace, optarg);
			break;
#endif
		case 'i':
			FREE_PTR(config_id);
			config_id = MALLOC(strlen(optarg) + 1);
			strcpy(config_id, optarg);
			break;
		case 4:			/* --signum */
			signum = get_signum(optarg);
			if (signum == -1) {
				fprintf(stderr, ""Unknown sigfunc %s\n"", optarg);
				exit(1);
			}

			printf(""%d\n"", signum);
			exit(0);
			break;
		case 3:			/* --all */
			__set_bit(RUN_ALL_CHILDREN, &daemon_mode);
#ifdef _WITH_VRRP_
			__set_bit(DAEMON_VRRP, &daemon_mode);
#endif
#ifdef _WITH_LVS_
			__set_bit(DAEMON_CHECKERS, &daemon_mode);
#endif
#ifdef _WITH_BFD_
			__set_bit(DAEMON_BFD, &daemon_mode);
#endif
			break;
#ifdef _WITH_PERF_
		case 5:
			if (optarg && optarg[0]) {
				if (!strcmp(optarg, ""run""))
					perf_run = PERF_RUN;
				else if (!strcmp(optarg, ""all""))
					perf_run = PERF_ALL;
				else if (!strcmp(optarg, ""end""))
					perf_run = PERF_END;
				else
					log_message(LOG_INFO, ""Unknown perf start point %s"", optarg);
			}
			else
				perf_run = PERF_RUN;

			break;
#endif
#ifdef WITH_DEBUG_OPTIONS
		case 6:
			set_debug_options(optarg && optarg[0] ? optarg : NULL);
			break;
#endif
		case '?':
			if (optopt && argv[curind][1] != '-')
				fprintf(stderr, ""Unknown option -%c\n"", optopt);
			else
				fprintf(stderr, ""Unknown option %s\n"", argv[curind]);
			bad_option = true;
			break;
		case ':':
			if (optopt && argv[curind][1] != '-')
				fprintf(stderr, ""Missing parameter for option -%c\n"", optopt);
			else
				fprintf(stderr, ""Missing parameter for option --%s\n"", long_options[longindex].name);
			bad_option = true;
			break;
		default:
			exit(1);
			break;
		}
		curind = optind;
	}

	if (optind < argc) {
		printf(""Unexpected argument(s): "");
		while (optind < argc)
			printf(""%s "", argv[optind++]);
		printf(""\n"");
	}

	if (bad_option)
		exit(1);

	return reopen_log;
}
"
4422,182158,,Local,Not required,Partial,CVE-2018-19044,https://www.cvedetails.com/cve/CVE-2018-19044/,CWE-59,Medium,,Partial,,2018-11-08,3.3,"keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",2019-08-06,,1,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,04f2d32871bb3b11d7dc024039952f2fe2750306,"When opening files for write, ensure they aren't symbolic links

Issue #1048 identified that if, for example, a non privileged user
created a symbolic link from /etc/keepalvied.data to /etc/passwd,
writing to /etc/keepalived.data (which could be invoked via DBus)
would cause /etc/passwd to be overwritten.

This commit stops keepalived writing to pathnames where the ultimate
component is a symbolic link, by setting O_NOFOLLOW whenever opening
a file for writing.

This might break some setups, where, for example, /etc/keepalived.data
was a symbolic link to /home/fred/keepalived.data. If this was the case,
instead create a symbolic link from /home/fred/keepalived.data to
/tmp/keepalived.data, so that the file is still accessible via
/home/fred/keepalived.data.

There doesn't appear to be a way around this backward incompatibility,
since even checking if the pathname is a symbolic link prior to opening
for writing would create a race condition.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",1,keepalived/core/pidfile.c,"{""sha"": ""e494976f50b4eddbab13a2704287a14541c9043b"", ""filename"": ""keepalived/core/main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/main.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \""Unable to open config-test log file %s\\n\"", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);""}<_**next**_>{""sha"": ""83f6f2fa4c1f3f7e1704c4e32b7cb9f6aafb766e"", ""filename"": ""keepalived/core/pidfile.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/pidfile.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -60,7 +60,7 @@ int\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \""w\"");\n ""}<_**next**_>{""sha"": ""d16ef3d9a6e624e724b34e6c58c7cc8878c0da5a"", ""filename"": ""keepalived/core/smtp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/smtp.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\""/tmp/smtp-alert.log\"", \""a\"");\n+\tFILE *fp = fopen_safe(\""/tmp/smtp-alert.log\"", \""a\"");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];""}<_**next**_>{""sha"": ""4cfb16366fa244d607b85bfe2ecf613495c74eb3"", ""filename"": ""keepalived/vrrp/vrrp_dbus.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_dbus.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -594,7 +594,7 @@ read_file(gchar* filepath)\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \""rb\"");\n+\tf = fopen(filepath, \""r\"");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);""}<_**next**_>{""sha"": ""1a6ea873a250f9958d52e649399ef1398f7a2087"", ""filename"": ""keepalived/vrrp/vrrp_json.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_json.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""vrrp_iprule.h\""\n #include \""logger.h\""\n #include \""timer.h\""\n+#include \""utils.h\""\n \n static inline double\n timeval_to_double(const timeval_t *t)\n@@ -55,7 +56,7 @@ vrrp_print_json(void)\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\""/tmp/keepalived.json\"",\""w\"");\n+\tfile = fopen_safe(\""/tmp/keepalived.json\"", \""w\"");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open /tmp/keepalived.json (%d: %s)\"",\n \t\t\terrno, strerror(errno));""}<_**next**_>{""sha"": ""84704b415db95999319d3ecfe3ef8c650f20e083"", ""filename"": ""keepalived/vrrp/vrrp_parser.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \""w\""))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \""w\""))) {\n \t\t\tfprintf(tf, \""%d\\n\"", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}""}<_**next**_>{""sha"": ""aeb74bcbf5dca2f2f71faa32cf1ca91ffebed75b"", ""filename"": ""keepalived/vrrp/vrrp_print.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 10, ""changes"": 17, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_print.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -32,14 +32,15 @@\n #include \""vrrp.h\""\n #include \""vrrp_data.h\""\n #include \""vrrp_print.h\""\n+#include \""utils.h\""\n \n static const char *dump_file = \""/tmp/keepalived.data\"";\n static const char *stats_file = \""/tmp/keepalived.stats\"";\n \n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \""w\"");\n+\tFILE *file = fopen_safe(dump_file, \""w\"");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n@@ -55,28 +56,24 @@ vrrp_print_data(void)\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \""w\"");\n+\tFILE *file = fopen_safe(stats_file, \""w\"");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n \t\t\tstats_file, errno, strerror(errno));\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \""VRRP Instance: %s\\n\"", vrrp->iname);\n \t\tfprintf(file, \""  Advertisements:\\n\"");\n \t\tfprintf(file, \""    Received: %\"" PRIu64 \""\\n\"", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \""    Sent: %d\\n\"", vrrp->stats->advert_sent);\n \t\tfprintf(file, \""  Became master: %d\\n\"", vrrp->stats->become_master);\n-\t\tfprintf(file, \""  Released master: %d\\n\"",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \""  Released master: %d\\n\"", vrrp->stats->release_master);\n \t\tfprintf(file, \""  Packet Errors:\\n\"");\n \t\tfprintf(file, \""    Length: %\"" PRIu64 \""\\n\"", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \""    TTL: %\"" PRIu64 \""\\n\"", vrrp->stats->ip_ttl_err);""}<_**next**_>{""sha"": ""59217c6303694449716ba3308169b6a09539e821"", ""filename"": ""keepalived/vrrp/vrrp_scheduler.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_scheduler.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1134,7 +1134,7 @@ dump_threads(void)\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \""a\"");\n+\tfp = fopen_safe(file_name, \""a\"");\n \tFREE(file_name);\n \n \tset_time_now();""}<_**next**_>{""sha"": ""20153c800f219bb6f9c512f6970caf537e1ce5f0"", ""filename"": ""lib/logger.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/logger.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \""a\"");\n+\tlog_file = fopen_safe(file_name, \""a\"");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));""}<_**next**_>{""sha"": ""3001f3ebdcd9a411edb91ee8352f4f910b54e900"", ""filename"": ""lib/memory.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/memory.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)\n \t}\n \n \tsnprintf(log_name, log_name_len, \""/tmp/%s_mem.%d.log\"", prog_name, getpid());\n-\tlog_op = fopen(log_name, \""a\"");\n+\tlog_op = fopen_safe(log_name, \""a\"");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \""Unable to open %s for appending\"", log_name);\n \t\tlog_op = stderr;""}<_**next**_>{""sha"": ""3a8c0662a4e7a61bcbdf175f0f35c704d8e7e446"", ""filename"": ""lib/notify.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/notify.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \""Unable to open %snotify fifo %s - errno %d\"", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);""}<_**next**_>{""sha"": ""1d53595c0e876c459f5677f01ffeca9c99403e84"", ""filename"": ""lib/parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \""/tmp/keywords.%d\"", getpid());\n-\t\tfp = fopen(file_name, \""w\"");\n+\t\tfp = fopen_safe(file_name, \""w\"");\n \t\tif (!fp)\n \t\t\treturn;\n \t}""}<_**next**_>{""sha"": ""4aac594454bb3fddec3b72bbe4b8b099638ef5c8"", ""filename"": ""lib/utils.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 1, ""changes"": 43, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -123,7 +123,7 @@ write_stacktrace(const char *file_name, const char *str)\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \""%s\\n\"", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n@@ -788,6 +788,47 @@ string_equal(const char *str1, const char *str2)\n \treturn !strcmp(str1, str2);\n }\n \n+/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n+ * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\n+FILE *fopen_safe(const char *path, const char *mode)\n+{\n+\tint fd;\n+\tFILE *file;\n+\tint flags = O_NOFOLLOW | O_CREAT;\n+\n+\tif (mode[0] == 'r')\n+\t\treturn fopen(path, mode);\n+\n+\tif (mode[0] != 'a' && mode[0] != 'w')\n+\t\treturn NULL;\n+\n+\tif (mode[1] &&\n+\t    (mode[1] != '+' || mode[2]))\n+\t\treturn NULL;\n+\n+\tif (mode[0] == 'w')\n+\t\tflags |= O_TRUNC;\n+\telse\n+\t\tflags |= O_APPEND;\n+\n+\tif (mode[1])\n+\t\tflags |= O_RDWR;\n+\telse\n+\t\tflags |= O_WRONLY;\n+\n+\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n+\tif (fd == -1)\n+\t\treturn NULL;\n+\n+\tfile = fdopen (fd, \""w\"");\n+\tif (!file) {\n+\t\tclose(fd);\n+\t\treturn NULL;\n+\t}\n+\n+\treturn file;\n+}\n+\n void\n set_std_fd(bool force)\n {""}<_**next**_>{""sha"": ""19682d02546d7329c410a77ad1c9569a144b5434"", ""filename"": ""lib/utils.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.h?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -182,6 +182,7 @@ extern int inet_inaddrcmp(int, const void *, const void *);\n extern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\n extern char *get_local_name(void);\n extern bool string_equal(const char *, const char *);\n+extern FILE *fopen_safe(const char *, const char *);\n extern void set_std_fd(bool);\n extern void close_std_fd(void);\n #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_""}"," pidfile_write(const char *pid_file, int pid)
 {
 	FILE *pidfile = NULL;
	int pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 
 	if (pidfd != -1) pidfile = fdopen(pidfd, ""w"");
 
	if (!pidfile) {
		log_message(LOG_INFO, ""pidfile_write : Cannot open %s pidfile"",
		       pid_file);
		return 0;
	}
	fprintf(pidfile, ""%d\n"", pid);
	fclose(pidfile);
	return 1;
}
"," pidfile_write(const char *pid_file, int pid)
 {
 	FILE *pidfile = NULL;
	int pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 
 	if (pidfd != -1) pidfile = fdopen(pidfd, ""w"");
 
	if (!pidfile) {
		log_message(LOG_INFO, ""pidfile_write : Cannot open %s pidfile"",
		       pid_file);
		return 0;
	}
	fprintf(pidfile, ""%d\n"", pid);
	fclose(pidfile);
	return 1;
}
",C,"	int pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
","	int pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
",,"@@ -60,7 +60,7 @@ int
 pidfile_write(const char *pid_file, int pid)
 {
 	FILE *pidfile = NULL;
-	int pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+	int pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 
 	if (pidfd != -1) pidfile = fdopen(pidfd, ""w"");
 ",keepalived,04f2d32871bb3b11d7dc024039952f2fe2750306,5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,1," pidfile_write(const char *pid_file, int pid)
 {
 	FILE *pidfile = NULL;
//flaw_line_below:
	int pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
//fix_flaw_line_below:
//	int pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 
 	if (pidfd != -1) pidfile = fdopen(pidfd, ""w"");
 
	if (!pidfile) {
		log_message(LOG_INFO, ""pidfile_write : Cannot open %s pidfile"",
		       pid_file);
		return 0;
	}
	fprintf(pidfile, ""%d\n"", pid);
	fclose(pidfile);
	return 1;
}
"
4423,182159,,Local,Not required,Partial,CVE-2018-19044,https://www.cvedetails.com/cve/CVE-2018-19044/,CWE-59,Medium,,Partial,,2018-11-08,3.3,"keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",2019-08-06,,1,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,04f2d32871bb3b11d7dc024039952f2fe2750306,"When opening files for write, ensure they aren't symbolic links

Issue #1048 identified that if, for example, a non privileged user
created a symbolic link from /etc/keepalvied.data to /etc/passwd,
writing to /etc/keepalived.data (which could be invoked via DBus)
would cause /etc/passwd to be overwritten.

This commit stops keepalived writing to pathnames where the ultimate
component is a symbolic link, by setting O_NOFOLLOW whenever opening
a file for writing.

This might break some setups, where, for example, /etc/keepalived.data
was a symbolic link to /home/fred/keepalived.data. If this was the case,
instead create a symbolic link from /home/fred/keepalived.data to
/tmp/keepalived.data, so that the file is still accessible via
/home/fred/keepalived.data.

There doesn't appear to be a way around this backward incompatibility,
since even checking if the pathname is a symbolic link prior to opening
for writing would create a race condition.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",1,keepalived/core/smtp.c,"{""sha"": ""e494976f50b4eddbab13a2704287a14541c9043b"", ""filename"": ""keepalived/core/main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/main.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \""Unable to open config-test log file %s\\n\"", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);""}<_**next**_>{""sha"": ""83f6f2fa4c1f3f7e1704c4e32b7cb9f6aafb766e"", ""filename"": ""keepalived/core/pidfile.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/pidfile.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -60,7 +60,7 @@ int\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \""w\"");\n ""}<_**next**_>{""sha"": ""d16ef3d9a6e624e724b34e6c58c7cc8878c0da5a"", ""filename"": ""keepalived/core/smtp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/smtp.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\""/tmp/smtp-alert.log\"", \""a\"");\n+\tFILE *fp = fopen_safe(\""/tmp/smtp-alert.log\"", \""a\"");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];""}<_**next**_>{""sha"": ""4cfb16366fa244d607b85bfe2ecf613495c74eb3"", ""filename"": ""keepalived/vrrp/vrrp_dbus.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_dbus.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -594,7 +594,7 @@ read_file(gchar* filepath)\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \""rb\"");\n+\tf = fopen(filepath, \""r\"");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);""}<_**next**_>{""sha"": ""1a6ea873a250f9958d52e649399ef1398f7a2087"", ""filename"": ""keepalived/vrrp/vrrp_json.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_json.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""vrrp_iprule.h\""\n #include \""logger.h\""\n #include \""timer.h\""\n+#include \""utils.h\""\n \n static inline double\n timeval_to_double(const timeval_t *t)\n@@ -55,7 +56,7 @@ vrrp_print_json(void)\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\""/tmp/keepalived.json\"",\""w\"");\n+\tfile = fopen_safe(\""/tmp/keepalived.json\"", \""w\"");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open /tmp/keepalived.json (%d: %s)\"",\n \t\t\terrno, strerror(errno));""}<_**next**_>{""sha"": ""84704b415db95999319d3ecfe3ef8c650f20e083"", ""filename"": ""keepalived/vrrp/vrrp_parser.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \""w\""))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \""w\""))) {\n \t\t\tfprintf(tf, \""%d\\n\"", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}""}<_**next**_>{""sha"": ""aeb74bcbf5dca2f2f71faa32cf1ca91ffebed75b"", ""filename"": ""keepalived/vrrp/vrrp_print.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 10, ""changes"": 17, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_print.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -32,14 +32,15 @@\n #include \""vrrp.h\""\n #include \""vrrp_data.h\""\n #include \""vrrp_print.h\""\n+#include \""utils.h\""\n \n static const char *dump_file = \""/tmp/keepalived.data\"";\n static const char *stats_file = \""/tmp/keepalived.stats\"";\n \n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \""w\"");\n+\tFILE *file = fopen_safe(dump_file, \""w\"");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n@@ -55,28 +56,24 @@ vrrp_print_data(void)\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \""w\"");\n+\tFILE *file = fopen_safe(stats_file, \""w\"");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n \t\t\tstats_file, errno, strerror(errno));\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \""VRRP Instance: %s\\n\"", vrrp->iname);\n \t\tfprintf(file, \""  Advertisements:\\n\"");\n \t\tfprintf(file, \""    Received: %\"" PRIu64 \""\\n\"", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \""    Sent: %d\\n\"", vrrp->stats->advert_sent);\n \t\tfprintf(file, \""  Became master: %d\\n\"", vrrp->stats->become_master);\n-\t\tfprintf(file, \""  Released master: %d\\n\"",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \""  Released master: %d\\n\"", vrrp->stats->release_master);\n \t\tfprintf(file, \""  Packet Errors:\\n\"");\n \t\tfprintf(file, \""    Length: %\"" PRIu64 \""\\n\"", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \""    TTL: %\"" PRIu64 \""\\n\"", vrrp->stats->ip_ttl_err);""}<_**next**_>{""sha"": ""59217c6303694449716ba3308169b6a09539e821"", ""filename"": ""keepalived/vrrp/vrrp_scheduler.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_scheduler.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1134,7 +1134,7 @@ dump_threads(void)\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \""a\"");\n+\tfp = fopen_safe(file_name, \""a\"");\n \tFREE(file_name);\n \n \tset_time_now();""}<_**next**_>{""sha"": ""20153c800f219bb6f9c512f6970caf537e1ce5f0"", ""filename"": ""lib/logger.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/logger.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \""a\"");\n+\tlog_file = fopen_safe(file_name, \""a\"");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));""}<_**next**_>{""sha"": ""3001f3ebdcd9a411edb91ee8352f4f910b54e900"", ""filename"": ""lib/memory.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/memory.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)\n \t}\n \n \tsnprintf(log_name, log_name_len, \""/tmp/%s_mem.%d.log\"", prog_name, getpid());\n-\tlog_op = fopen(log_name, \""a\"");\n+\tlog_op = fopen_safe(log_name, \""a\"");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \""Unable to open %s for appending\"", log_name);\n \t\tlog_op = stderr;""}<_**next**_>{""sha"": ""3a8c0662a4e7a61bcbdf175f0f35c704d8e7e446"", ""filename"": ""lib/notify.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/notify.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \""Unable to open %snotify fifo %s - errno %d\"", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);""}<_**next**_>{""sha"": ""1d53595c0e876c459f5677f01ffeca9c99403e84"", ""filename"": ""lib/parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \""/tmp/keywords.%d\"", getpid());\n-\t\tfp = fopen(file_name, \""w\"");\n+\t\tfp = fopen_safe(file_name, \""w\"");\n \t\tif (!fp)\n \t\t\treturn;\n \t}""}<_**next**_>{""sha"": ""4aac594454bb3fddec3b72bbe4b8b099638ef5c8"", ""filename"": ""lib/utils.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 1, ""changes"": 43, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -123,7 +123,7 @@ write_stacktrace(const char *file_name, const char *str)\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \""%s\\n\"", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n@@ -788,6 +788,47 @@ string_equal(const char *str1, const char *str2)\n \treturn !strcmp(str1, str2);\n }\n \n+/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n+ * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\n+FILE *fopen_safe(const char *path, const char *mode)\n+{\n+\tint fd;\n+\tFILE *file;\n+\tint flags = O_NOFOLLOW | O_CREAT;\n+\n+\tif (mode[0] == 'r')\n+\t\treturn fopen(path, mode);\n+\n+\tif (mode[0] != 'a' && mode[0] != 'w')\n+\t\treturn NULL;\n+\n+\tif (mode[1] &&\n+\t    (mode[1] != '+' || mode[2]))\n+\t\treturn NULL;\n+\n+\tif (mode[0] == 'w')\n+\t\tflags |= O_TRUNC;\n+\telse\n+\t\tflags |= O_APPEND;\n+\n+\tif (mode[1])\n+\t\tflags |= O_RDWR;\n+\telse\n+\t\tflags |= O_WRONLY;\n+\n+\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n+\tif (fd == -1)\n+\t\treturn NULL;\n+\n+\tfile = fdopen (fd, \""w\"");\n+\tif (!file) {\n+\t\tclose(fd);\n+\t\treturn NULL;\n+\t}\n+\n+\treturn file;\n+}\n+\n void\n set_std_fd(bool force)\n {""}<_**next**_>{""sha"": ""19682d02546d7329c410a77ad1c9569a144b5434"", ""filename"": ""lib/utils.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.h?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -182,6 +182,7 @@ extern int inet_inaddrcmp(int, const void *, const void *);\n extern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\n extern char *get_local_name(void);\n extern bool string_equal(const char *, const char *);\n+extern FILE *fopen_safe(const char *, const char *);\n extern void set_std_fd(bool);\n extern void close_std_fd(void);\n #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_""}"," smtp_log_to_file(smtp_t *smtp)
 {
	FILE *fp = fopen_safe(""/tmp/smtp-alert.log"", ""a"");
 	time_t now;
 	struct tm tm;
 	char time_buf[25];
	int time_buf_len;

	time(&now);
	localtime_r(&now, &tm);
	time_buf_len = strftime(time_buf, sizeof time_buf, ""%a %b %e %X %Y"", &tm);

	fprintf(fp, ""%s: %s -> %s\n""
		    ""%*sSubject: %s\n""
		    ""%*sBody:    %s\n\n"",
		    time_buf, global_data->email_from, smtp->email_to,
		    time_buf_len - 7, """", smtp->subject,
		    time_buf_len - 7, """", smtp->body);

	fclose(fp);

	free_smtp_all(smtp);
}
"," smtp_log_to_file(smtp_t *smtp)
 {
	FILE *fp = fopen(""/tmp/smtp-alert.log"", ""a"");
 	time_t now;
 	struct tm tm;
 	char time_buf[25];
	int time_buf_len;

	time(&now);
	localtime_r(&now, &tm);
	time_buf_len = strftime(time_buf, sizeof time_buf, ""%a %b %e %X %Y"", &tm);

	fprintf(fp, ""%s: %s -> %s\n""
		    ""%*sSubject: %s\n""
		    ""%*sBody:    %s\n\n"",
		    time_buf, global_data->email_from, smtp->email_to,
		    time_buf_len - 7, """", smtp->subject,
		    time_buf_len - 7, """", smtp->body);

	fclose(fp);

	free_smtp_all(smtp);
}
",C,"	FILE *fp = fopen_safe(""/tmp/smtp-alert.log"", ""a"");
","	FILE *fp = fopen(""/tmp/smtp-alert.log"", ""a"");
",,"@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)
 static void
 smtp_log_to_file(smtp_t *smtp)
 {
-	FILE *fp = fopen(""/tmp/smtp-alert.log"", ""a"");
+	FILE *fp = fopen_safe(""/tmp/smtp-alert.log"", ""a"");
 	time_t now;
 	struct tm tm;
 	char time_buf[25];",keepalived,04f2d32871bb3b11d7dc024039952f2fe2750306,5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,1," smtp_log_to_file(smtp_t *smtp)
 {
//flaw_line_below:
	FILE *fp = fopen(""/tmp/smtp-alert.log"", ""a"");
//fix_flaw_line_below:
//	FILE *fp = fopen_safe(""/tmp/smtp-alert.log"", ""a"");
 	time_t now;
 	struct tm tm;
 	char time_buf[25];
	int time_buf_len;

	time(&now);
	localtime_r(&now, &tm);
	time_buf_len = strftime(time_buf, sizeof time_buf, ""%a %b %e %X %Y"", &tm);

	fprintf(fp, ""%s: %s -> %s\n""
		    ""%*sSubject: %s\n""
		    ""%*sBody:    %s\n\n"",
		    time_buf, global_data->email_from, smtp->email_to,
		    time_buf_len - 7, """", smtp->subject,
		    time_buf_len - 7, """", smtp->body);

	fclose(fp);

	free_smtp_all(smtp);
}
"
4424,182160,,Local,Not required,Partial,CVE-2018-19044,https://www.cvedetails.com/cve/CVE-2018-19044/,CWE-59,Medium,,Partial,,2018-11-08,3.3,"keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",2019-08-06,,1,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,04f2d32871bb3b11d7dc024039952f2fe2750306,"When opening files for write, ensure they aren't symbolic links

Issue #1048 identified that if, for example, a non privileged user
created a symbolic link from /etc/keepalvied.data to /etc/passwd,
writing to /etc/keepalived.data (which could be invoked via DBus)
would cause /etc/passwd to be overwritten.

This commit stops keepalived writing to pathnames where the ultimate
component is a symbolic link, by setting O_NOFOLLOW whenever opening
a file for writing.

This might break some setups, where, for example, /etc/keepalived.data
was a symbolic link to /home/fred/keepalived.data. If this was the case,
instead create a symbolic link from /home/fred/keepalived.data to
/tmp/keepalived.data, so that the file is still accessible via
/home/fred/keepalived.data.

There doesn't appear to be a way around this backward incompatibility,
since even checking if the pathname is a symbolic link prior to opening
for writing would create a race condition.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",1,keepalived/vrrp/vrrp_dbus.c,"{""sha"": ""e494976f50b4eddbab13a2704287a14541c9043b"", ""filename"": ""keepalived/core/main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/main.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \""Unable to open config-test log file %s\\n\"", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);""}<_**next**_>{""sha"": ""83f6f2fa4c1f3f7e1704c4e32b7cb9f6aafb766e"", ""filename"": ""keepalived/core/pidfile.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/pidfile.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -60,7 +60,7 @@ int\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \""w\"");\n ""}<_**next**_>{""sha"": ""d16ef3d9a6e624e724b34e6c58c7cc8878c0da5a"", ""filename"": ""keepalived/core/smtp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/smtp.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\""/tmp/smtp-alert.log\"", \""a\"");\n+\tFILE *fp = fopen_safe(\""/tmp/smtp-alert.log\"", \""a\"");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];""}<_**next**_>{""sha"": ""4cfb16366fa244d607b85bfe2ecf613495c74eb3"", ""filename"": ""keepalived/vrrp/vrrp_dbus.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_dbus.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -594,7 +594,7 @@ read_file(gchar* filepath)\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \""rb\"");\n+\tf = fopen(filepath, \""r\"");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);""}<_**next**_>{""sha"": ""1a6ea873a250f9958d52e649399ef1398f7a2087"", ""filename"": ""keepalived/vrrp/vrrp_json.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_json.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""vrrp_iprule.h\""\n #include \""logger.h\""\n #include \""timer.h\""\n+#include \""utils.h\""\n \n static inline double\n timeval_to_double(const timeval_t *t)\n@@ -55,7 +56,7 @@ vrrp_print_json(void)\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\""/tmp/keepalived.json\"",\""w\"");\n+\tfile = fopen_safe(\""/tmp/keepalived.json\"", \""w\"");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open /tmp/keepalived.json (%d: %s)\"",\n \t\t\terrno, strerror(errno));""}<_**next**_>{""sha"": ""84704b415db95999319d3ecfe3ef8c650f20e083"", ""filename"": ""keepalived/vrrp/vrrp_parser.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \""w\""))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \""w\""))) {\n \t\t\tfprintf(tf, \""%d\\n\"", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}""}<_**next**_>{""sha"": ""aeb74bcbf5dca2f2f71faa32cf1ca91ffebed75b"", ""filename"": ""keepalived/vrrp/vrrp_print.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 10, ""changes"": 17, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_print.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -32,14 +32,15 @@\n #include \""vrrp.h\""\n #include \""vrrp_data.h\""\n #include \""vrrp_print.h\""\n+#include \""utils.h\""\n \n static const char *dump_file = \""/tmp/keepalived.data\"";\n static const char *stats_file = \""/tmp/keepalived.stats\"";\n \n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \""w\"");\n+\tFILE *file = fopen_safe(dump_file, \""w\"");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n@@ -55,28 +56,24 @@ vrrp_print_data(void)\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \""w\"");\n+\tFILE *file = fopen_safe(stats_file, \""w\"");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n \t\t\tstats_file, errno, strerror(errno));\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \""VRRP Instance: %s\\n\"", vrrp->iname);\n \t\tfprintf(file, \""  Advertisements:\\n\"");\n \t\tfprintf(file, \""    Received: %\"" PRIu64 \""\\n\"", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \""    Sent: %d\\n\"", vrrp->stats->advert_sent);\n \t\tfprintf(file, \""  Became master: %d\\n\"", vrrp->stats->become_master);\n-\t\tfprintf(file, \""  Released master: %d\\n\"",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \""  Released master: %d\\n\"", vrrp->stats->release_master);\n \t\tfprintf(file, \""  Packet Errors:\\n\"");\n \t\tfprintf(file, \""    Length: %\"" PRIu64 \""\\n\"", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \""    TTL: %\"" PRIu64 \""\\n\"", vrrp->stats->ip_ttl_err);""}<_**next**_>{""sha"": ""59217c6303694449716ba3308169b6a09539e821"", ""filename"": ""keepalived/vrrp/vrrp_scheduler.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_scheduler.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1134,7 +1134,7 @@ dump_threads(void)\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \""a\"");\n+\tfp = fopen_safe(file_name, \""a\"");\n \tFREE(file_name);\n \n \tset_time_now();""}<_**next**_>{""sha"": ""20153c800f219bb6f9c512f6970caf537e1ce5f0"", ""filename"": ""lib/logger.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/logger.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \""a\"");\n+\tlog_file = fopen_safe(file_name, \""a\"");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));""}<_**next**_>{""sha"": ""3001f3ebdcd9a411edb91ee8352f4f910b54e900"", ""filename"": ""lib/memory.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/memory.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)\n \t}\n \n \tsnprintf(log_name, log_name_len, \""/tmp/%s_mem.%d.log\"", prog_name, getpid());\n-\tlog_op = fopen(log_name, \""a\"");\n+\tlog_op = fopen_safe(log_name, \""a\"");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \""Unable to open %s for appending\"", log_name);\n \t\tlog_op = stderr;""}<_**next**_>{""sha"": ""3a8c0662a4e7a61bcbdf175f0f35c704d8e7e446"", ""filename"": ""lib/notify.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/notify.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \""Unable to open %snotify fifo %s - errno %d\"", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);""}<_**next**_>{""sha"": ""1d53595c0e876c459f5677f01ffeca9c99403e84"", ""filename"": ""lib/parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \""/tmp/keywords.%d\"", getpid());\n-\t\tfp = fopen(file_name, \""w\"");\n+\t\tfp = fopen_safe(file_name, \""w\"");\n \t\tif (!fp)\n \t\t\treturn;\n \t}""}<_**next**_>{""sha"": ""4aac594454bb3fddec3b72bbe4b8b099638ef5c8"", ""filename"": ""lib/utils.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 1, ""changes"": 43, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -123,7 +123,7 @@ write_stacktrace(const char *file_name, const char *str)\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \""%s\\n\"", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n@@ -788,6 +788,47 @@ string_equal(const char *str1, const char *str2)\n \treturn !strcmp(str1, str2);\n }\n \n+/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n+ * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\n+FILE *fopen_safe(const char *path, const char *mode)\n+{\n+\tint fd;\n+\tFILE *file;\n+\tint flags = O_NOFOLLOW | O_CREAT;\n+\n+\tif (mode[0] == 'r')\n+\t\treturn fopen(path, mode);\n+\n+\tif (mode[0] != 'a' && mode[0] != 'w')\n+\t\treturn NULL;\n+\n+\tif (mode[1] &&\n+\t    (mode[1] != '+' || mode[2]))\n+\t\treturn NULL;\n+\n+\tif (mode[0] == 'w')\n+\t\tflags |= O_TRUNC;\n+\telse\n+\t\tflags |= O_APPEND;\n+\n+\tif (mode[1])\n+\t\tflags |= O_RDWR;\n+\telse\n+\t\tflags |= O_WRONLY;\n+\n+\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n+\tif (fd == -1)\n+\t\treturn NULL;\n+\n+\tfile = fdopen (fd, \""w\"");\n+\tif (!file) {\n+\t\tclose(fd);\n+\t\treturn NULL;\n+\t}\n+\n+\treturn file;\n+}\n+\n void\n set_std_fd(bool force)\n {""}<_**next**_>{""sha"": ""19682d02546d7329c410a77ad1c9569a144b5434"", ""filename"": ""lib/utils.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.h?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -182,6 +182,7 @@ extern int inet_inaddrcmp(int, const void *, const void *);\n extern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\n extern char *get_local_name(void);\n extern bool string_equal(const char *, const char *);\n+extern FILE *fopen_safe(const char *, const char *);\n extern void set_std_fd(bool);\n extern void close_std_fd(void);\n #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_""}","read_file(gchar* filepath)
{
	FILE * f;
 	size_t length;
 	gchar *ret = NULL;
 
	f = fopen(filepath, ""r"");
 	if (f) {
 		fseek(f, 0, SEEK_END);
 		length = (size_t)ftell(f);
		fseek(f, 0, SEEK_SET);

		/* We can't use MALLOC since it isn't thread safe */
		ret = MALLOC(length + 1);
		if (ret) {
			if (fread(ret, length, 1, f) != 1) {
				log_message(LOG_INFO, ""Failed to read all of %s"", filepath);
			}
			ret[length] = '\0';
		}
		else
			log_message(LOG_INFO, ""Unable to read Dbus file %s"", filepath);

		fclose(f);
	}
	return ret;
}
","read_file(gchar* filepath)
{
	FILE * f;
 	size_t length;
 	gchar *ret = NULL;
 
	f = fopen(filepath, ""rb"");
 	if (f) {
 		fseek(f, 0, SEEK_END);
 		length = (size_t)ftell(f);
		fseek(f, 0, SEEK_SET);

		/* We can't use MALLOC since it isn't thread safe */
		ret = MALLOC(length + 1);
		if (ret) {
			if (fread(ret, length, 1, f) != 1) {
				log_message(LOG_INFO, ""Failed to read all of %s"", filepath);
			}
			ret[length] = '\0';
		}
		else
			log_message(LOG_INFO, ""Unable to read Dbus file %s"", filepath);

		fclose(f);
	}
	return ret;
}
",C,"	f = fopen(filepath, ""r"");
","	f = fopen(filepath, ""rb"");
",,"@@ -594,7 +594,7 @@ read_file(gchar* filepath)
 	size_t length;
 	gchar *ret = NULL;
 
-	f = fopen(filepath, ""rb"");
+	f = fopen(filepath, ""r"");
 	if (f) {
 		fseek(f, 0, SEEK_END);
 		length = (size_t)ftell(f);",keepalived,04f2d32871bb3b11d7dc024039952f2fe2750306,5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,1,"read_file(gchar* filepath)
{
	FILE * f;
 	size_t length;
 	gchar *ret = NULL;
 
//flaw_line_below:
	f = fopen(filepath, ""rb"");
//fix_flaw_line_below:
//	f = fopen(filepath, ""r"");
 	if (f) {
 		fseek(f, 0, SEEK_END);
 		length = (size_t)ftell(f);
		fseek(f, 0, SEEK_SET);

		/* We can't use MALLOC since it isn't thread safe */
		ret = MALLOC(length + 1);
		if (ret) {
			if (fread(ret, length, 1, f) != 1) {
				log_message(LOG_INFO, ""Failed to read all of %s"", filepath);
			}
			ret[length] = '\0';
		}
		else
			log_message(LOG_INFO, ""Unable to read Dbus file %s"", filepath);

		fclose(f);
	}
	return ret;
}
"
4425,182161,,Local,Not required,Partial,CVE-2018-19044,https://www.cvedetails.com/cve/CVE-2018-19044/,CWE-59,Medium,,Partial,,2018-11-08,3.3,"keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",2019-08-06,,1,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,04f2d32871bb3b11d7dc024039952f2fe2750306,"When opening files for write, ensure they aren't symbolic links

Issue #1048 identified that if, for example, a non privileged user
created a symbolic link from /etc/keepalvied.data to /etc/passwd,
writing to /etc/keepalived.data (which could be invoked via DBus)
would cause /etc/passwd to be overwritten.

This commit stops keepalived writing to pathnames where the ultimate
component is a symbolic link, by setting O_NOFOLLOW whenever opening
a file for writing.

This might break some setups, where, for example, /etc/keepalived.data
was a symbolic link to /home/fred/keepalived.data. If this was the case,
instead create a symbolic link from /home/fred/keepalived.data to
/tmp/keepalived.data, so that the file is still accessible via
/home/fred/keepalived.data.

There doesn't appear to be a way around this backward incompatibility,
since even checking if the pathname is a symbolic link prior to opening
for writing would create a race condition.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",1,keepalived/vrrp/vrrp_json.c,"{""sha"": ""e494976f50b4eddbab13a2704287a14541c9043b"", ""filename"": ""keepalived/core/main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/main.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \""Unable to open config-test log file %s\\n\"", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);""}<_**next**_>{""sha"": ""83f6f2fa4c1f3f7e1704c4e32b7cb9f6aafb766e"", ""filename"": ""keepalived/core/pidfile.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/pidfile.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -60,7 +60,7 @@ int\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \""w\"");\n ""}<_**next**_>{""sha"": ""d16ef3d9a6e624e724b34e6c58c7cc8878c0da5a"", ""filename"": ""keepalived/core/smtp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/smtp.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\""/tmp/smtp-alert.log\"", \""a\"");\n+\tFILE *fp = fopen_safe(\""/tmp/smtp-alert.log\"", \""a\"");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];""}<_**next**_>{""sha"": ""4cfb16366fa244d607b85bfe2ecf613495c74eb3"", ""filename"": ""keepalived/vrrp/vrrp_dbus.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_dbus.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -594,7 +594,7 @@ read_file(gchar* filepath)\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \""rb\"");\n+\tf = fopen(filepath, \""r\"");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);""}<_**next**_>{""sha"": ""1a6ea873a250f9958d52e649399ef1398f7a2087"", ""filename"": ""keepalived/vrrp/vrrp_json.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_json.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""vrrp_iprule.h\""\n #include \""logger.h\""\n #include \""timer.h\""\n+#include \""utils.h\""\n \n static inline double\n timeval_to_double(const timeval_t *t)\n@@ -55,7 +56,7 @@ vrrp_print_json(void)\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\""/tmp/keepalived.json\"",\""w\"");\n+\tfile = fopen_safe(\""/tmp/keepalived.json\"", \""w\"");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open /tmp/keepalived.json (%d: %s)\"",\n \t\t\terrno, strerror(errno));""}<_**next**_>{""sha"": ""84704b415db95999319d3ecfe3ef8c650f20e083"", ""filename"": ""keepalived/vrrp/vrrp_parser.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \""w\""))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \""w\""))) {\n \t\t\tfprintf(tf, \""%d\\n\"", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}""}<_**next**_>{""sha"": ""aeb74bcbf5dca2f2f71faa32cf1ca91ffebed75b"", ""filename"": ""keepalived/vrrp/vrrp_print.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 10, ""changes"": 17, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_print.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -32,14 +32,15 @@\n #include \""vrrp.h\""\n #include \""vrrp_data.h\""\n #include \""vrrp_print.h\""\n+#include \""utils.h\""\n \n static const char *dump_file = \""/tmp/keepalived.data\"";\n static const char *stats_file = \""/tmp/keepalived.stats\"";\n \n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \""w\"");\n+\tFILE *file = fopen_safe(dump_file, \""w\"");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n@@ -55,28 +56,24 @@ vrrp_print_data(void)\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \""w\"");\n+\tFILE *file = fopen_safe(stats_file, \""w\"");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n \t\t\tstats_file, errno, strerror(errno));\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \""VRRP Instance: %s\\n\"", vrrp->iname);\n \t\tfprintf(file, \""  Advertisements:\\n\"");\n \t\tfprintf(file, \""    Received: %\"" PRIu64 \""\\n\"", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \""    Sent: %d\\n\"", vrrp->stats->advert_sent);\n \t\tfprintf(file, \""  Became master: %d\\n\"", vrrp->stats->become_master);\n-\t\tfprintf(file, \""  Released master: %d\\n\"",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \""  Released master: %d\\n\"", vrrp->stats->release_master);\n \t\tfprintf(file, \""  Packet Errors:\\n\"");\n \t\tfprintf(file, \""    Length: %\"" PRIu64 \""\\n\"", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \""    TTL: %\"" PRIu64 \""\\n\"", vrrp->stats->ip_ttl_err);""}<_**next**_>{""sha"": ""59217c6303694449716ba3308169b6a09539e821"", ""filename"": ""keepalived/vrrp/vrrp_scheduler.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_scheduler.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1134,7 +1134,7 @@ dump_threads(void)\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \""a\"");\n+\tfp = fopen_safe(file_name, \""a\"");\n \tFREE(file_name);\n \n \tset_time_now();""}<_**next**_>{""sha"": ""20153c800f219bb6f9c512f6970caf537e1ce5f0"", ""filename"": ""lib/logger.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/logger.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \""a\"");\n+\tlog_file = fopen_safe(file_name, \""a\"");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));""}<_**next**_>{""sha"": ""3001f3ebdcd9a411edb91ee8352f4f910b54e900"", ""filename"": ""lib/memory.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/memory.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)\n \t}\n \n \tsnprintf(log_name, log_name_len, \""/tmp/%s_mem.%d.log\"", prog_name, getpid());\n-\tlog_op = fopen(log_name, \""a\"");\n+\tlog_op = fopen_safe(log_name, \""a\"");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \""Unable to open %s for appending\"", log_name);\n \t\tlog_op = stderr;""}<_**next**_>{""sha"": ""3a8c0662a4e7a61bcbdf175f0f35c704d8e7e446"", ""filename"": ""lib/notify.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/notify.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \""Unable to open %snotify fifo %s - errno %d\"", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);""}<_**next**_>{""sha"": ""1d53595c0e876c459f5677f01ffeca9c99403e84"", ""filename"": ""lib/parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \""/tmp/keywords.%d\"", getpid());\n-\t\tfp = fopen(file_name, \""w\"");\n+\t\tfp = fopen_safe(file_name, \""w\"");\n \t\tif (!fp)\n \t\t\treturn;\n \t}""}<_**next**_>{""sha"": ""4aac594454bb3fddec3b72bbe4b8b099638ef5c8"", ""filename"": ""lib/utils.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 1, ""changes"": 43, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -123,7 +123,7 @@ write_stacktrace(const char *file_name, const char *str)\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \""%s\\n\"", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n@@ -788,6 +788,47 @@ string_equal(const char *str1, const char *str2)\n \treturn !strcmp(str1, str2);\n }\n \n+/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n+ * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\n+FILE *fopen_safe(const char *path, const char *mode)\n+{\n+\tint fd;\n+\tFILE *file;\n+\tint flags = O_NOFOLLOW | O_CREAT;\n+\n+\tif (mode[0] == 'r')\n+\t\treturn fopen(path, mode);\n+\n+\tif (mode[0] != 'a' && mode[0] != 'w')\n+\t\treturn NULL;\n+\n+\tif (mode[1] &&\n+\t    (mode[1] != '+' || mode[2]))\n+\t\treturn NULL;\n+\n+\tif (mode[0] == 'w')\n+\t\tflags |= O_TRUNC;\n+\telse\n+\t\tflags |= O_APPEND;\n+\n+\tif (mode[1])\n+\t\tflags |= O_RDWR;\n+\telse\n+\t\tflags |= O_WRONLY;\n+\n+\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n+\tif (fd == -1)\n+\t\treturn NULL;\n+\n+\tfile = fdopen (fd, \""w\"");\n+\tif (!file) {\n+\t\tclose(fd);\n+\t\treturn NULL;\n+\t}\n+\n+\treturn file;\n+}\n+\n void\n set_std_fd(bool force)\n {""}<_**next**_>{""sha"": ""19682d02546d7329c410a77ad1c9569a144b5434"", ""filename"": ""lib/utils.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.h?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -182,6 +182,7 @@ extern int inet_inaddrcmp(int, const void *, const void *);\n extern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\n extern char *get_local_name(void);\n extern bool string_equal(const char *, const char *);\n+extern FILE *fopen_safe(const char *, const char *);\n extern void set_std_fd(bool);\n extern void close_std_fd(void);\n #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_""}","vrrp_print_json(void)
{
	FILE *file;
	element e;
	struct json_object *array;

 	if (LIST_ISEMPTY(vrrp_data->vrrp))
 		return;
 
	file = fopen_safe(""/tmp/keepalived.json"", ""w"");
 	if (!file) {
 		log_message(LOG_INFO, ""Can't open /tmp/keepalived.json (%d: %s)"",
 			errno, strerror(errno));
		return;
	}

	array = json_object_new_array();

	for (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {
		struct json_object *instance_json, *json_stats, *json_data,
			*vips, *evips, *track_ifp, *track_script;
#ifdef _HAVE_FIB_ROUTING_
		struct json_object *vroutes, *vrules;
#endif
		element f;

		vrrp_t *vrrp = ELEMENT_DATA(e);
		instance_json = json_object_new_object();
		json_stats = json_object_new_object();
		json_data = json_object_new_object();
		vips = json_object_new_array();
		evips = json_object_new_array();
		track_ifp = json_object_new_array();
		track_script = json_object_new_array();
#ifdef _HAVE_FIB_ROUTING_
		vroutes = json_object_new_array();
		vrules = json_object_new_array();
#endif

		json_object_object_add(json_data, ""iname"",
			json_object_new_string(vrrp->iname));
		json_object_object_add(json_data, ""dont_track_primary"",
			json_object_new_int(vrrp->dont_track_primary));
		json_object_object_add(json_data, ""skip_check_adv_addr"",
			json_object_new_int(vrrp->skip_check_adv_addr));
		json_object_object_add(json_data, ""strict_mode"",
			json_object_new_int((int)vrrp->strict_mode));
#ifdef _HAVE_VRRP_VMAC_
		json_object_object_add(json_data, ""vmac_ifname"",
			json_object_new_string(vrrp->vmac_ifname));
#endif
		if (!LIST_ISEMPTY(vrrp->track_ifp)) {
			for (f = LIST_HEAD(vrrp->track_ifp); f; ELEMENT_NEXT(f)) {
				interface_t *ifp = ELEMENT_DATA(f);
				json_object_array_add(track_ifp,
					json_object_new_string(ifp->ifname));
			}
		}
		json_object_object_add(json_data, ""track_ifp"", track_ifp);

		if (!LIST_ISEMPTY(vrrp->track_script)) {
			for (f = LIST_HEAD(vrrp->track_script); f; ELEMENT_NEXT(f)) {
				tracked_sc_t *tsc = ELEMENT_DATA(f);
				vrrp_script_t *vscript = tsc->scr;
				json_object_array_add(track_script,
					json_object_new_string(cmd_str(&vscript->script)));
			}
		}
		json_object_object_add(json_data, ""track_script"", track_script);

		json_object_object_add(json_data, ""ifp_ifname"",
			json_object_new_string(vrrp->ifp->ifname));
		json_object_object_add(json_data, ""master_priority"",
			json_object_new_int(vrrp->master_priority));
		json_object_object_add(json_data, ""last_transition"",
			json_object_new_double(timeval_to_double(&vrrp->last_transition)));
		json_object_object_add(json_data, ""garp_delay"",
			json_object_new_double(vrrp->garp_delay / TIMER_HZ_FLOAT));
		json_object_object_add(json_data, ""garp_refresh"",
			json_object_new_int((int)vrrp->garp_refresh.tv_sec));
		json_object_object_add(json_data, ""garp_rep"",
			json_object_new_int((int)vrrp->garp_rep));
		json_object_object_add(json_data, ""garp_refresh_rep"",
			json_object_new_int((int)vrrp->garp_refresh_rep));
		json_object_object_add(json_data, ""garp_lower_prio_delay"",
			json_object_new_int((int)(vrrp->garp_lower_prio_delay / TIMER_HZ)));
		json_object_object_add(json_data, ""garp_lower_prio_rep"",
			json_object_new_int((int)vrrp->garp_lower_prio_rep));
		json_object_object_add(json_data, ""lower_prio_no_advert"",
			json_object_new_int((int)vrrp->lower_prio_no_advert));
		json_object_object_add(json_data, ""higher_prio_send_advert"",
			json_object_new_int((int)vrrp->higher_prio_send_advert));
		json_object_object_add(json_data, ""vrid"",
			json_object_new_int(vrrp->vrid));
		json_object_object_add(json_data, ""base_priority"",
			json_object_new_int(vrrp->base_priority));
		json_object_object_add(json_data, ""effective_priority"",
			json_object_new_int(vrrp->effective_priority));
		json_object_object_add(json_data, ""vipset"",
			json_object_new_boolean(vrrp->vipset));

		if (!LIST_ISEMPTY(vrrp->vip)) {
			for (f = LIST_HEAD(vrrp->vip); f; ELEMENT_NEXT(f)) {
				ip_address_t *vip = ELEMENT_DATA(f);
				char ipaddr[INET6_ADDRSTRLEN];
				inet_ntop(vrrp->family, &(vip->u.sin.sin_addr.s_addr),
					ipaddr, INET6_ADDRSTRLEN);
				json_object_array_add(vips,
					json_object_new_string(ipaddr));
			}
		}
		json_object_object_add(json_data, ""vips"", vips);

		if (!LIST_ISEMPTY(vrrp->evip)) {
			for (f = LIST_HEAD(vrrp->evip); f; ELEMENT_NEXT(f)) {
				ip_address_t *evip = ELEMENT_DATA(f);
				char ipaddr[INET6_ADDRSTRLEN];
				inet_ntop(vrrp->family, &(evip->u.sin.sin_addr.s_addr),
					ipaddr, INET6_ADDRSTRLEN);
				json_object_array_add(evips,
					json_object_new_string(ipaddr));
			}
		}
		json_object_object_add(json_data, ""evips"", evips);

		json_object_object_add(json_data, ""promote_secondaries"",
			json_object_new_boolean(vrrp->promote_secondaries));

#ifdef _HAVE_FIB_ROUTING_
		if (!LIST_ISEMPTY(vrrp->vroutes)) {
			for (f = LIST_HEAD(vrrp->vroutes); f; ELEMENT_NEXT(f)) {
				ip_route_t *route = ELEMENT_DATA(f);
				char *buf = MALLOC(ROUTE_BUF_SIZE);
				format_iproute(route, buf, ROUTE_BUF_SIZE);
				json_object_array_add(vroutes,
					json_object_new_string(buf));
			}
		}
		json_object_object_add(json_data, ""vroutes"", vroutes);

		if (!LIST_ISEMPTY(vrrp->vrules)) {
			for (f = LIST_HEAD(vrrp->vrules); f; ELEMENT_NEXT(f)) {
				ip_rule_t *rule = ELEMENT_DATA(f);
				char *buf = MALLOC(RULE_BUF_SIZE);
				format_iprule(rule, buf, RULE_BUF_SIZE);
				json_object_array_add(vrules,
					json_object_new_string(buf));
			}
		}
		json_object_object_add(json_data, ""vrules"", vrules);
#endif

		json_object_object_add(json_data, ""adver_int"",
			json_object_new_double(vrrp->adver_int / TIMER_HZ_FLOAT));
		json_object_object_add(json_data, ""master_adver_int"",
			json_object_new_double(vrrp->master_adver_int / TIMER_HZ_FLOAT));
		json_object_object_add(json_data, ""accept"",
			json_object_new_int((int)vrrp->accept));
		json_object_object_add(json_data, ""nopreempt"",
			json_object_new_boolean(vrrp->nopreempt));
		json_object_object_add(json_data, ""preempt_delay"",
			json_object_new_int((int)(vrrp->preempt_delay / TIMER_HZ)));
		json_object_object_add(json_data, ""state"",
			json_object_new_int(vrrp->state));
		json_object_object_add(json_data, ""wantstate"",
			json_object_new_int(vrrp->wantstate));
		json_object_object_add(json_data, ""version"",
			json_object_new_int(vrrp->version));
		if (vrrp->script_backup)
			json_object_object_add(json_data, ""script_backup"",
				json_object_new_string(cmd_str(vrrp->script_backup)));
		if (vrrp->script_master)
			json_object_object_add(json_data, ""script_master"",
				json_object_new_string(cmd_str(vrrp->script_master)));
		if (vrrp->script_fault)
			json_object_object_add(json_data, ""script_fault"",
				json_object_new_string(cmd_str(vrrp->script_fault)));
		if (vrrp->script_stop)
			json_object_object_add(json_data, ""script_stop"",
				json_object_new_string(cmd_str(vrrp->script_stop)));
		if (vrrp->script)
			json_object_object_add(json_data, ""script"",
				json_object_new_string(cmd_str(vrrp->script)));
		if (vrrp->script_master_rx_lower_pri)
			json_object_object_add(json_data, ""script_master_rx_lower_pri"",
				json_object_new_string(cmd_str(vrrp->script_master_rx_lower_pri)));
		json_object_object_add(json_data, ""smtp_alert"",
			json_object_new_boolean(vrrp->smtp_alert));
#ifdef _WITH_VRRP_AUTH_
		if (vrrp->auth_type) {
			json_object_object_add(json_data, ""auth_type"",
				json_object_new_int(vrrp->auth_type));

			if (vrrp->auth_type != VRRP_AUTH_AH) {
				char auth_data[sizeof(vrrp->auth_data) + 1];
				memcpy(auth_data, vrrp->auth_data, sizeof(vrrp->auth_data));
				auth_data[sizeof(vrrp->auth_data)] = '\0';
				json_object_object_add(json_data, ""auth_data"",
					json_object_new_string(auth_data));
			}
		}
		else
			json_object_object_add(json_data, ""auth_type"",
				json_object_new_int(0));
#endif

		json_object_object_add(json_stats, ""advert_rcvd"",
			json_object_new_int64((int64_t)vrrp->stats->advert_rcvd));
		json_object_object_add(json_stats, ""advert_sent"",
			json_object_new_int64(vrrp->stats->advert_sent));
		json_object_object_add(json_stats, ""become_master"",
			json_object_new_int64(vrrp->stats->become_master));
		json_object_object_add(json_stats, ""release_master"",
			json_object_new_int64(vrrp->stats->release_master));
		json_object_object_add(json_stats, ""packet_len_err"",
			json_object_new_int64((int64_t)vrrp->stats->packet_len_err));
		json_object_object_add(json_stats, ""advert_interval_err"",
			json_object_new_int64((int64_t)vrrp->stats->advert_interval_err));
		json_object_object_add(json_stats, ""ip_ttl_err"",
			json_object_new_int64((int64_t)vrrp->stats->ip_ttl_err));
		json_object_object_add(json_stats, ""invalid_type_rcvd"",
			json_object_new_int64((int64_t)vrrp->stats->invalid_type_rcvd));
		json_object_object_add(json_stats, ""addr_list_err"",
			json_object_new_int64((int64_t)vrrp->stats->addr_list_err));
		json_object_object_add(json_stats, ""invalid_authtype"",
			json_object_new_int64(vrrp->stats->invalid_authtype));
#ifdef _WITH_VRRP_AUTH_
		json_object_object_add(json_stats, ""authtype_mismatch"",
			json_object_new_int64(vrrp->stats->authtype_mismatch));
		json_object_object_add(json_stats, ""auth_failure"",
			json_object_new_int64(vrrp->stats->auth_failure));
#endif
		json_object_object_add(json_stats, ""pri_zero_rcvd"",
			json_object_new_int64((int64_t)vrrp->stats->pri_zero_rcvd));
		json_object_object_add(json_stats, ""pri_zero_sent"",
			json_object_new_int64((int64_t)vrrp->stats->pri_zero_sent));

		json_object_object_add(instance_json, ""data"", json_data);
		json_object_object_add(instance_json, ""stats"", json_stats);

		json_object_array_add(array, instance_json);

	}
	fprintf(file, ""%s"", json_object_to_json_string(array));
	fclose(file);
}
","vrrp_print_json(void)
{
	FILE *file;
	element e;
	struct json_object *array;

 	if (LIST_ISEMPTY(vrrp_data->vrrp))
 		return;
 
	file = fopen (""/tmp/keepalived.json"",""w"");
 	if (!file) {
 		log_message(LOG_INFO, ""Can't open /tmp/keepalived.json (%d: %s)"",
 			errno, strerror(errno));
		return;
	}

	array = json_object_new_array();

	for (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {
		struct json_object *instance_json, *json_stats, *json_data,
			*vips, *evips, *track_ifp, *track_script;
#ifdef _HAVE_FIB_ROUTING_
		struct json_object *vroutes, *vrules;
#endif
		element f;

		vrrp_t *vrrp = ELEMENT_DATA(e);
		instance_json = json_object_new_object();
		json_stats = json_object_new_object();
		json_data = json_object_new_object();
		vips = json_object_new_array();
		evips = json_object_new_array();
		track_ifp = json_object_new_array();
		track_script = json_object_new_array();
#ifdef _HAVE_FIB_ROUTING_
		vroutes = json_object_new_array();
		vrules = json_object_new_array();
#endif

		json_object_object_add(json_data, ""iname"",
			json_object_new_string(vrrp->iname));
		json_object_object_add(json_data, ""dont_track_primary"",
			json_object_new_int(vrrp->dont_track_primary));
		json_object_object_add(json_data, ""skip_check_adv_addr"",
			json_object_new_int(vrrp->skip_check_adv_addr));
		json_object_object_add(json_data, ""strict_mode"",
			json_object_new_int((int)vrrp->strict_mode));
#ifdef _HAVE_VRRP_VMAC_
		json_object_object_add(json_data, ""vmac_ifname"",
			json_object_new_string(vrrp->vmac_ifname));
#endif
		if (!LIST_ISEMPTY(vrrp->track_ifp)) {
			for (f = LIST_HEAD(vrrp->track_ifp); f; ELEMENT_NEXT(f)) {
				interface_t *ifp = ELEMENT_DATA(f);
				json_object_array_add(track_ifp,
					json_object_new_string(ifp->ifname));
			}
		}
		json_object_object_add(json_data, ""track_ifp"", track_ifp);

		if (!LIST_ISEMPTY(vrrp->track_script)) {
			for (f = LIST_HEAD(vrrp->track_script); f; ELEMENT_NEXT(f)) {
				tracked_sc_t *tsc = ELEMENT_DATA(f);
				vrrp_script_t *vscript = tsc->scr;
				json_object_array_add(track_script,
					json_object_new_string(cmd_str(&vscript->script)));
			}
		}
		json_object_object_add(json_data, ""track_script"", track_script);

		json_object_object_add(json_data, ""ifp_ifname"",
			json_object_new_string(vrrp->ifp->ifname));
		json_object_object_add(json_data, ""master_priority"",
			json_object_new_int(vrrp->master_priority));
		json_object_object_add(json_data, ""last_transition"",
			json_object_new_double(timeval_to_double(&vrrp->last_transition)));
		json_object_object_add(json_data, ""garp_delay"",
			json_object_new_double(vrrp->garp_delay / TIMER_HZ_FLOAT));
		json_object_object_add(json_data, ""garp_refresh"",
			json_object_new_int((int)vrrp->garp_refresh.tv_sec));
		json_object_object_add(json_data, ""garp_rep"",
			json_object_new_int((int)vrrp->garp_rep));
		json_object_object_add(json_data, ""garp_refresh_rep"",
			json_object_new_int((int)vrrp->garp_refresh_rep));
		json_object_object_add(json_data, ""garp_lower_prio_delay"",
			json_object_new_int((int)(vrrp->garp_lower_prio_delay / TIMER_HZ)));
		json_object_object_add(json_data, ""garp_lower_prio_rep"",
			json_object_new_int((int)vrrp->garp_lower_prio_rep));
		json_object_object_add(json_data, ""lower_prio_no_advert"",
			json_object_new_int((int)vrrp->lower_prio_no_advert));
		json_object_object_add(json_data, ""higher_prio_send_advert"",
			json_object_new_int((int)vrrp->higher_prio_send_advert));
		json_object_object_add(json_data, ""vrid"",
			json_object_new_int(vrrp->vrid));
		json_object_object_add(json_data, ""base_priority"",
			json_object_new_int(vrrp->base_priority));
		json_object_object_add(json_data, ""effective_priority"",
			json_object_new_int(vrrp->effective_priority));
		json_object_object_add(json_data, ""vipset"",
			json_object_new_boolean(vrrp->vipset));

		if (!LIST_ISEMPTY(vrrp->vip)) {
			for (f = LIST_HEAD(vrrp->vip); f; ELEMENT_NEXT(f)) {
				ip_address_t *vip = ELEMENT_DATA(f);
				char ipaddr[INET6_ADDRSTRLEN];
				inet_ntop(vrrp->family, &(vip->u.sin.sin_addr.s_addr),
					ipaddr, INET6_ADDRSTRLEN);
				json_object_array_add(vips,
					json_object_new_string(ipaddr));
			}
		}
		json_object_object_add(json_data, ""vips"", vips);

		if (!LIST_ISEMPTY(vrrp->evip)) {
			for (f = LIST_HEAD(vrrp->evip); f; ELEMENT_NEXT(f)) {
				ip_address_t *evip = ELEMENT_DATA(f);
				char ipaddr[INET6_ADDRSTRLEN];
				inet_ntop(vrrp->family, &(evip->u.sin.sin_addr.s_addr),
					ipaddr, INET6_ADDRSTRLEN);
				json_object_array_add(evips,
					json_object_new_string(ipaddr));
			}
		}
		json_object_object_add(json_data, ""evips"", evips);

		json_object_object_add(json_data, ""promote_secondaries"",
			json_object_new_boolean(vrrp->promote_secondaries));

#ifdef _HAVE_FIB_ROUTING_
		if (!LIST_ISEMPTY(vrrp->vroutes)) {
			for (f = LIST_HEAD(vrrp->vroutes); f; ELEMENT_NEXT(f)) {
				ip_route_t *route = ELEMENT_DATA(f);
				char *buf = MALLOC(ROUTE_BUF_SIZE);
				format_iproute(route, buf, ROUTE_BUF_SIZE);
				json_object_array_add(vroutes,
					json_object_new_string(buf));
			}
		}
		json_object_object_add(json_data, ""vroutes"", vroutes);

		if (!LIST_ISEMPTY(vrrp->vrules)) {
			for (f = LIST_HEAD(vrrp->vrules); f; ELEMENT_NEXT(f)) {
				ip_rule_t *rule = ELEMENT_DATA(f);
				char *buf = MALLOC(RULE_BUF_SIZE);
				format_iprule(rule, buf, RULE_BUF_SIZE);
				json_object_array_add(vrules,
					json_object_new_string(buf));
			}
		}
		json_object_object_add(json_data, ""vrules"", vrules);
#endif

		json_object_object_add(json_data, ""adver_int"",
			json_object_new_double(vrrp->adver_int / TIMER_HZ_FLOAT));
		json_object_object_add(json_data, ""master_adver_int"",
			json_object_new_double(vrrp->master_adver_int / TIMER_HZ_FLOAT));
		json_object_object_add(json_data, ""accept"",
			json_object_new_int((int)vrrp->accept));
		json_object_object_add(json_data, ""nopreempt"",
			json_object_new_boolean(vrrp->nopreempt));
		json_object_object_add(json_data, ""preempt_delay"",
			json_object_new_int((int)(vrrp->preempt_delay / TIMER_HZ)));
		json_object_object_add(json_data, ""state"",
			json_object_new_int(vrrp->state));
		json_object_object_add(json_data, ""wantstate"",
			json_object_new_int(vrrp->wantstate));
		json_object_object_add(json_data, ""version"",
			json_object_new_int(vrrp->version));
		if (vrrp->script_backup)
			json_object_object_add(json_data, ""script_backup"",
				json_object_new_string(cmd_str(vrrp->script_backup)));
		if (vrrp->script_master)
			json_object_object_add(json_data, ""script_master"",
				json_object_new_string(cmd_str(vrrp->script_master)));
		if (vrrp->script_fault)
			json_object_object_add(json_data, ""script_fault"",
				json_object_new_string(cmd_str(vrrp->script_fault)));
		if (vrrp->script_stop)
			json_object_object_add(json_data, ""script_stop"",
				json_object_new_string(cmd_str(vrrp->script_stop)));
		if (vrrp->script)
			json_object_object_add(json_data, ""script"",
				json_object_new_string(cmd_str(vrrp->script)));
		if (vrrp->script_master_rx_lower_pri)
			json_object_object_add(json_data, ""script_master_rx_lower_pri"",
				json_object_new_string(cmd_str(vrrp->script_master_rx_lower_pri)));
		json_object_object_add(json_data, ""smtp_alert"",
			json_object_new_boolean(vrrp->smtp_alert));
#ifdef _WITH_VRRP_AUTH_
		if (vrrp->auth_type) {
			json_object_object_add(json_data, ""auth_type"",
				json_object_new_int(vrrp->auth_type));

			if (vrrp->auth_type != VRRP_AUTH_AH) {
				char auth_data[sizeof(vrrp->auth_data) + 1];
				memcpy(auth_data, vrrp->auth_data, sizeof(vrrp->auth_data));
				auth_data[sizeof(vrrp->auth_data)] = '\0';
				json_object_object_add(json_data, ""auth_data"",
					json_object_new_string(auth_data));
			}
		}
		else
			json_object_object_add(json_data, ""auth_type"",
				json_object_new_int(0));
#endif

		json_object_object_add(json_stats, ""advert_rcvd"",
			json_object_new_int64((int64_t)vrrp->stats->advert_rcvd));
		json_object_object_add(json_stats, ""advert_sent"",
			json_object_new_int64(vrrp->stats->advert_sent));
		json_object_object_add(json_stats, ""become_master"",
			json_object_new_int64(vrrp->stats->become_master));
		json_object_object_add(json_stats, ""release_master"",
			json_object_new_int64(vrrp->stats->release_master));
		json_object_object_add(json_stats, ""packet_len_err"",
			json_object_new_int64((int64_t)vrrp->stats->packet_len_err));
		json_object_object_add(json_stats, ""advert_interval_err"",
			json_object_new_int64((int64_t)vrrp->stats->advert_interval_err));
		json_object_object_add(json_stats, ""ip_ttl_err"",
			json_object_new_int64((int64_t)vrrp->stats->ip_ttl_err));
		json_object_object_add(json_stats, ""invalid_type_rcvd"",
			json_object_new_int64((int64_t)vrrp->stats->invalid_type_rcvd));
		json_object_object_add(json_stats, ""addr_list_err"",
			json_object_new_int64((int64_t)vrrp->stats->addr_list_err));
		json_object_object_add(json_stats, ""invalid_authtype"",
			json_object_new_int64(vrrp->stats->invalid_authtype));
#ifdef _WITH_VRRP_AUTH_
		json_object_object_add(json_stats, ""authtype_mismatch"",
			json_object_new_int64(vrrp->stats->authtype_mismatch));
		json_object_object_add(json_stats, ""auth_failure"",
			json_object_new_int64(vrrp->stats->auth_failure));
#endif
		json_object_object_add(json_stats, ""pri_zero_rcvd"",
			json_object_new_int64((int64_t)vrrp->stats->pri_zero_rcvd));
		json_object_object_add(json_stats, ""pri_zero_sent"",
			json_object_new_int64((int64_t)vrrp->stats->pri_zero_sent));

		json_object_object_add(instance_json, ""data"", json_data);
		json_object_object_add(instance_json, ""stats"", json_stats);

		json_object_array_add(array, instance_json);

	}
	fprintf(file, ""%s"", json_object_to_json_string(array));
	fclose(file);
}
",C,"	file = fopen_safe(""/tmp/keepalived.json"", ""w"");
","	file = fopen (""/tmp/keepalived.json"",""w"");
",,"@@ -37,6 +37,7 @@
 #include ""vrrp_iprule.h""
 #include ""logger.h""
 #include ""timer.h""
+#include ""utils.h""
 
 static inline double
 timeval_to_double(const timeval_t *t)
@@ -55,7 +56,7 @@ vrrp_print_json(void)
 	if (LIST_ISEMPTY(vrrp_data->vrrp))
 		return;
 
-	file = fopen (""/tmp/keepalived.json"",""w"");
+	file = fopen_safe(""/tmp/keepalived.json"", ""w"");
 	if (!file) {
 		log_message(LOG_INFO, ""Can't open /tmp/keepalived.json (%d: %s)"",
 			errno, strerror(errno));",keepalived,04f2d32871bb3b11d7dc024039952f2fe2750306,5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,1,"vrrp_print_json(void)
{
	FILE *file;
	element e;
	struct json_object *array;

 	if (LIST_ISEMPTY(vrrp_data->vrrp))
 		return;
 
//flaw_line_below:
	file = fopen (""/tmp/keepalived.json"",""w"");
//fix_flaw_line_below:
//	file = fopen_safe(""/tmp/keepalived.json"", ""w"");
 	if (!file) {
 		log_message(LOG_INFO, ""Can't open /tmp/keepalived.json (%d: %s)"",
 			errno, strerror(errno));
		return;
	}

	array = json_object_new_array();

	for (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {
		struct json_object *instance_json, *json_stats, *json_data,
			*vips, *evips, *track_ifp, *track_script;
#ifdef _HAVE_FIB_ROUTING_
		struct json_object *vroutes, *vrules;
#endif
		element f;

		vrrp_t *vrrp = ELEMENT_DATA(e);
		instance_json = json_object_new_object();
		json_stats = json_object_new_object();
		json_data = json_object_new_object();
		vips = json_object_new_array();
		evips = json_object_new_array();
		track_ifp = json_object_new_array();
		track_script = json_object_new_array();
#ifdef _HAVE_FIB_ROUTING_
		vroutes = json_object_new_array();
		vrules = json_object_new_array();
#endif

		// Dump data to json
		json_object_object_add(json_data, ""iname"",
			json_object_new_string(vrrp->iname));
		json_object_object_add(json_data, ""dont_track_primary"",
			json_object_new_int(vrrp->dont_track_primary));
		json_object_object_add(json_data, ""skip_check_adv_addr"",
			json_object_new_int(vrrp->skip_check_adv_addr));
		json_object_object_add(json_data, ""strict_mode"",
			json_object_new_int((int)vrrp->strict_mode));
#ifdef _HAVE_VRRP_VMAC_
		json_object_object_add(json_data, ""vmac_ifname"",
			json_object_new_string(vrrp->vmac_ifname));
#endif
		// Tracked interfaces are stored in a list
		if (!LIST_ISEMPTY(vrrp->track_ifp)) {
			for (f = LIST_HEAD(vrrp->track_ifp); f; ELEMENT_NEXT(f)) {
				interface_t *ifp = ELEMENT_DATA(f);
				json_object_array_add(track_ifp,
					json_object_new_string(ifp->ifname));
			}
		}
		json_object_object_add(json_data, ""track_ifp"", track_ifp);

		// Tracked scripts also
		if (!LIST_ISEMPTY(vrrp->track_script)) {
			for (f = LIST_HEAD(vrrp->track_script); f; ELEMENT_NEXT(f)) {
				tracked_sc_t *tsc = ELEMENT_DATA(f);
				vrrp_script_t *vscript = tsc->scr;
				json_object_array_add(track_script,
					json_object_new_string(cmd_str(&vscript->script)));
			}
		}
		json_object_object_add(json_data, ""track_script"", track_script);

		json_object_object_add(json_data, ""ifp_ifname"",
			json_object_new_string(vrrp->ifp->ifname));
		json_object_object_add(json_data, ""master_priority"",
			json_object_new_int(vrrp->master_priority));
		json_object_object_add(json_data, ""last_transition"",
			json_object_new_double(timeval_to_double(&vrrp->last_transition)));
		json_object_object_add(json_data, ""garp_delay"",
			json_object_new_double(vrrp->garp_delay / TIMER_HZ_FLOAT));
		json_object_object_add(json_data, ""garp_refresh"",
			json_object_new_int((int)vrrp->garp_refresh.tv_sec));
		json_object_object_add(json_data, ""garp_rep"",
			json_object_new_int((int)vrrp->garp_rep));
		json_object_object_add(json_data, ""garp_refresh_rep"",
			json_object_new_int((int)vrrp->garp_refresh_rep));
		json_object_object_add(json_data, ""garp_lower_prio_delay"",
			json_object_new_int((int)(vrrp->garp_lower_prio_delay / TIMER_HZ)));
		json_object_object_add(json_data, ""garp_lower_prio_rep"",
			json_object_new_int((int)vrrp->garp_lower_prio_rep));
		json_object_object_add(json_data, ""lower_prio_no_advert"",
			json_object_new_int((int)vrrp->lower_prio_no_advert));
		json_object_object_add(json_data, ""higher_prio_send_advert"",
			json_object_new_int((int)vrrp->higher_prio_send_advert));
		json_object_object_add(json_data, ""vrid"",
			json_object_new_int(vrrp->vrid));
		json_object_object_add(json_data, ""base_priority"",
			json_object_new_int(vrrp->base_priority));
		json_object_object_add(json_data, ""effective_priority"",
			json_object_new_int(vrrp->effective_priority));
		json_object_object_add(json_data, ""vipset"",
			json_object_new_boolean(vrrp->vipset));

		//Virtual IPs are stored in a list
		if (!LIST_ISEMPTY(vrrp->vip)) {
			for (f = LIST_HEAD(vrrp->vip); f; ELEMENT_NEXT(f)) {
				ip_address_t *vip = ELEMENT_DATA(f);
				char ipaddr[INET6_ADDRSTRLEN];
				inet_ntop(vrrp->family, &(vip->u.sin.sin_addr.s_addr),
					ipaddr, INET6_ADDRSTRLEN);
				json_object_array_add(vips,
					json_object_new_string(ipaddr));
			}
		}
		json_object_object_add(json_data, ""vips"", vips);

		//External VIPs are also stored in a list
		if (!LIST_ISEMPTY(vrrp->evip)) {
			for (f = LIST_HEAD(vrrp->evip); f; ELEMENT_NEXT(f)) {
				ip_address_t *evip = ELEMENT_DATA(f);
				char ipaddr[INET6_ADDRSTRLEN];
				inet_ntop(vrrp->family, &(evip->u.sin.sin_addr.s_addr),
					ipaddr, INET6_ADDRSTRLEN);
				json_object_array_add(evips,
					json_object_new_string(ipaddr));
			}
		}
		json_object_object_add(json_data, ""evips"", evips);

		json_object_object_add(json_data, ""promote_secondaries"",
			json_object_new_boolean(vrrp->promote_secondaries));

#ifdef _HAVE_FIB_ROUTING_
		// Dump vroutes
		if (!LIST_ISEMPTY(vrrp->vroutes)) {
			for (f = LIST_HEAD(vrrp->vroutes); f; ELEMENT_NEXT(f)) {
				ip_route_t *route = ELEMENT_DATA(f);
				char *buf = MALLOC(ROUTE_BUF_SIZE);
				format_iproute(route, buf, ROUTE_BUF_SIZE);
				json_object_array_add(vroutes,
					json_object_new_string(buf));
			}
		}
		json_object_object_add(json_data, ""vroutes"", vroutes);

		// Dump vrules
		if (!LIST_ISEMPTY(vrrp->vrules)) {
			for (f = LIST_HEAD(vrrp->vrules); f; ELEMENT_NEXT(f)) {
				ip_rule_t *rule = ELEMENT_DATA(f);
				char *buf = MALLOC(RULE_BUF_SIZE);
				format_iprule(rule, buf, RULE_BUF_SIZE);
				json_object_array_add(vrules,
					json_object_new_string(buf));
			}
		}
		json_object_object_add(json_data, ""vrules"", vrules);
#endif

		json_object_object_add(json_data, ""adver_int"",
			json_object_new_double(vrrp->adver_int / TIMER_HZ_FLOAT));
		json_object_object_add(json_data, ""master_adver_int"",
			json_object_new_double(vrrp->master_adver_int / TIMER_HZ_FLOAT));
		json_object_object_add(json_data, ""accept"",
			json_object_new_int((int)vrrp->accept));
		json_object_object_add(json_data, ""nopreempt"",
			json_object_new_boolean(vrrp->nopreempt));
		json_object_object_add(json_data, ""preempt_delay"",
			json_object_new_int((int)(vrrp->preempt_delay / TIMER_HZ)));
		json_object_object_add(json_data, ""state"",
			json_object_new_int(vrrp->state));
		json_object_object_add(json_data, ""wantstate"",
			json_object_new_int(vrrp->wantstate));
		json_object_object_add(json_data, ""version"",
			json_object_new_int(vrrp->version));
		if (vrrp->script_backup)
			json_object_object_add(json_data, ""script_backup"",
				json_object_new_string(cmd_str(vrrp->script_backup)));
		if (vrrp->script_master)
			json_object_object_add(json_data, ""script_master"",
				json_object_new_string(cmd_str(vrrp->script_master)));
		if (vrrp->script_fault)
			json_object_object_add(json_data, ""script_fault"",
				json_object_new_string(cmd_str(vrrp->script_fault)));
		if (vrrp->script_stop)
			json_object_object_add(json_data, ""script_stop"",
				json_object_new_string(cmd_str(vrrp->script_stop)));
		if (vrrp->script)
			json_object_object_add(json_data, ""script"",
				json_object_new_string(cmd_str(vrrp->script)));
		if (vrrp->script_master_rx_lower_pri)
			json_object_object_add(json_data, ""script_master_rx_lower_pri"",
				json_object_new_string(cmd_str(vrrp->script_master_rx_lower_pri)));
		json_object_object_add(json_data, ""smtp_alert"",
			json_object_new_boolean(vrrp->smtp_alert));
#ifdef _WITH_VRRP_AUTH_
		if (vrrp->auth_type) {
			json_object_object_add(json_data, ""auth_type"",
				json_object_new_int(vrrp->auth_type));

			if (vrrp->auth_type != VRRP_AUTH_AH) {
				char auth_data[sizeof(vrrp->auth_data) + 1];
				memcpy(auth_data, vrrp->auth_data, sizeof(vrrp->auth_data));
				auth_data[sizeof(vrrp->auth_data)] = '\0';
				json_object_object_add(json_data, ""auth_data"",
					json_object_new_string(auth_data));
			}
		}
		else
			json_object_object_add(json_data, ""auth_type"",
				json_object_new_int(0));
#endif

		// Dump stats to json
		json_object_object_add(json_stats, ""advert_rcvd"",
			json_object_new_int64((int64_t)vrrp->stats->advert_rcvd));
		json_object_object_add(json_stats, ""advert_sent"",
			json_object_new_int64(vrrp->stats->advert_sent));
		json_object_object_add(json_stats, ""become_master"",
			json_object_new_int64(vrrp->stats->become_master));
		json_object_object_add(json_stats, ""release_master"",
			json_object_new_int64(vrrp->stats->release_master));
		json_object_object_add(json_stats, ""packet_len_err"",
			json_object_new_int64((int64_t)vrrp->stats->packet_len_err));
		json_object_object_add(json_stats, ""advert_interval_err"",
			json_object_new_int64((int64_t)vrrp->stats->advert_interval_err));
		json_object_object_add(json_stats, ""ip_ttl_err"",
			json_object_new_int64((int64_t)vrrp->stats->ip_ttl_err));
		json_object_object_add(json_stats, ""invalid_type_rcvd"",
			json_object_new_int64((int64_t)vrrp->stats->invalid_type_rcvd));
		json_object_object_add(json_stats, ""addr_list_err"",
			json_object_new_int64((int64_t)vrrp->stats->addr_list_err));
		json_object_object_add(json_stats, ""invalid_authtype"",
			json_object_new_int64(vrrp->stats->invalid_authtype));
#ifdef _WITH_VRRP_AUTH_
		json_object_object_add(json_stats, ""authtype_mismatch"",
			json_object_new_int64(vrrp->stats->authtype_mismatch));
		json_object_object_add(json_stats, ""auth_failure"",
			json_object_new_int64(vrrp->stats->auth_failure));
#endif
		json_object_object_add(json_stats, ""pri_zero_rcvd"",
			json_object_new_int64((int64_t)vrrp->stats->pri_zero_rcvd));
		json_object_object_add(json_stats, ""pri_zero_sent"",
			json_object_new_int64((int64_t)vrrp->stats->pri_zero_sent));

		// Add both json_data and json_stats to main instance_json
		json_object_object_add(instance_json, ""data"", json_data);
		json_object_object_add(instance_json, ""stats"", json_stats);

		// Add instance_json to main array
		json_object_array_add(array, instance_json);

	}
	fprintf(file, ""%s"", json_object_to_json_string(array));
	fclose(file);
}
"
4426,182162,,Local,Not required,Partial,CVE-2018-19044,https://www.cvedetails.com/cve/CVE-2018-19044/,CWE-59,Medium,,Partial,,2018-11-08,3.3,"keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",2019-08-06,,1,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,04f2d32871bb3b11d7dc024039952f2fe2750306,"When opening files for write, ensure they aren't symbolic links

Issue #1048 identified that if, for example, a non privileged user
created a symbolic link from /etc/keepalvied.data to /etc/passwd,
writing to /etc/keepalived.data (which could be invoked via DBus)
would cause /etc/passwd to be overwritten.

This commit stops keepalived writing to pathnames where the ultimate
component is a symbolic link, by setting O_NOFOLLOW whenever opening
a file for writing.

This might break some setups, where, for example, /etc/keepalived.data
was a symbolic link to /home/fred/keepalived.data. If this was the case,
instead create a symbolic link from /home/fred/keepalived.data to
/tmp/keepalived.data, so that the file is still accessible via
/home/fred/keepalived.data.

There doesn't appear to be a way around this backward incompatibility,
since even checking if the pathname is a symbolic link prior to opening
for writing would create a race condition.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",1,keepalived/vrrp/vrrp_parser.c,"{""sha"": ""e494976f50b4eddbab13a2704287a14541c9043b"", ""filename"": ""keepalived/core/main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/main.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \""Unable to open config-test log file %s\\n\"", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);""}<_**next**_>{""sha"": ""83f6f2fa4c1f3f7e1704c4e32b7cb9f6aafb766e"", ""filename"": ""keepalived/core/pidfile.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/pidfile.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -60,7 +60,7 @@ int\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \""w\"");\n ""}<_**next**_>{""sha"": ""d16ef3d9a6e624e724b34e6c58c7cc8878c0da5a"", ""filename"": ""keepalived/core/smtp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/smtp.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\""/tmp/smtp-alert.log\"", \""a\"");\n+\tFILE *fp = fopen_safe(\""/tmp/smtp-alert.log\"", \""a\"");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];""}<_**next**_>{""sha"": ""4cfb16366fa244d607b85bfe2ecf613495c74eb3"", ""filename"": ""keepalived/vrrp/vrrp_dbus.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_dbus.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -594,7 +594,7 @@ read_file(gchar* filepath)\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \""rb\"");\n+\tf = fopen(filepath, \""r\"");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);""}<_**next**_>{""sha"": ""1a6ea873a250f9958d52e649399ef1398f7a2087"", ""filename"": ""keepalived/vrrp/vrrp_json.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_json.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""vrrp_iprule.h\""\n #include \""logger.h\""\n #include \""timer.h\""\n+#include \""utils.h\""\n \n static inline double\n timeval_to_double(const timeval_t *t)\n@@ -55,7 +56,7 @@ vrrp_print_json(void)\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\""/tmp/keepalived.json\"",\""w\"");\n+\tfile = fopen_safe(\""/tmp/keepalived.json\"", \""w\"");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open /tmp/keepalived.json (%d: %s)\"",\n \t\t\terrno, strerror(errno));""}<_**next**_>{""sha"": ""84704b415db95999319d3ecfe3ef8c650f20e083"", ""filename"": ""keepalived/vrrp/vrrp_parser.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \""w\""))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \""w\""))) {\n \t\t\tfprintf(tf, \""%d\\n\"", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}""}<_**next**_>{""sha"": ""aeb74bcbf5dca2f2f71faa32cf1ca91ffebed75b"", ""filename"": ""keepalived/vrrp/vrrp_print.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 10, ""changes"": 17, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_print.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -32,14 +32,15 @@\n #include \""vrrp.h\""\n #include \""vrrp_data.h\""\n #include \""vrrp_print.h\""\n+#include \""utils.h\""\n \n static const char *dump_file = \""/tmp/keepalived.data\"";\n static const char *stats_file = \""/tmp/keepalived.stats\"";\n \n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \""w\"");\n+\tFILE *file = fopen_safe(dump_file, \""w\"");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n@@ -55,28 +56,24 @@ vrrp_print_data(void)\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \""w\"");\n+\tFILE *file = fopen_safe(stats_file, \""w\"");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n \t\t\tstats_file, errno, strerror(errno));\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \""VRRP Instance: %s\\n\"", vrrp->iname);\n \t\tfprintf(file, \""  Advertisements:\\n\"");\n \t\tfprintf(file, \""    Received: %\"" PRIu64 \""\\n\"", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \""    Sent: %d\\n\"", vrrp->stats->advert_sent);\n \t\tfprintf(file, \""  Became master: %d\\n\"", vrrp->stats->become_master);\n-\t\tfprintf(file, \""  Released master: %d\\n\"",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \""  Released master: %d\\n\"", vrrp->stats->release_master);\n \t\tfprintf(file, \""  Packet Errors:\\n\"");\n \t\tfprintf(file, \""    Length: %\"" PRIu64 \""\\n\"", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \""    TTL: %\"" PRIu64 \""\\n\"", vrrp->stats->ip_ttl_err);""}<_**next**_>{""sha"": ""59217c6303694449716ba3308169b6a09539e821"", ""filename"": ""keepalived/vrrp/vrrp_scheduler.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_scheduler.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1134,7 +1134,7 @@ dump_threads(void)\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \""a\"");\n+\tfp = fopen_safe(file_name, \""a\"");\n \tFREE(file_name);\n \n \tset_time_now();""}<_**next**_>{""sha"": ""20153c800f219bb6f9c512f6970caf537e1ce5f0"", ""filename"": ""lib/logger.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/logger.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \""a\"");\n+\tlog_file = fopen_safe(file_name, \""a\"");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));""}<_**next**_>{""sha"": ""3001f3ebdcd9a411edb91ee8352f4f910b54e900"", ""filename"": ""lib/memory.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/memory.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)\n \t}\n \n \tsnprintf(log_name, log_name_len, \""/tmp/%s_mem.%d.log\"", prog_name, getpid());\n-\tlog_op = fopen(log_name, \""a\"");\n+\tlog_op = fopen_safe(log_name, \""a\"");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \""Unable to open %s for appending\"", log_name);\n \t\tlog_op = stderr;""}<_**next**_>{""sha"": ""3a8c0662a4e7a61bcbdf175f0f35c704d8e7e446"", ""filename"": ""lib/notify.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/notify.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \""Unable to open %snotify fifo %s - errno %d\"", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);""}<_**next**_>{""sha"": ""1d53595c0e876c459f5677f01ffeca9c99403e84"", ""filename"": ""lib/parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \""/tmp/keywords.%d\"", getpid());\n-\t\tfp = fopen(file_name, \""w\"");\n+\t\tfp = fopen_safe(file_name, \""w\"");\n \t\tif (!fp)\n \t\t\treturn;\n \t}""}<_**next**_>{""sha"": ""4aac594454bb3fddec3b72bbe4b8b099638ef5c8"", ""filename"": ""lib/utils.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 1, ""changes"": 43, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -123,7 +123,7 @@ write_stacktrace(const char *file_name, const char *str)\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \""%s\\n\"", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n@@ -788,6 +788,47 @@ string_equal(const char *str1, const char *str2)\n \treturn !strcmp(str1, str2);\n }\n \n+/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n+ * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\n+FILE *fopen_safe(const char *path, const char *mode)\n+{\n+\tint fd;\n+\tFILE *file;\n+\tint flags = O_NOFOLLOW | O_CREAT;\n+\n+\tif (mode[0] == 'r')\n+\t\treturn fopen(path, mode);\n+\n+\tif (mode[0] != 'a' && mode[0] != 'w')\n+\t\treturn NULL;\n+\n+\tif (mode[1] &&\n+\t    (mode[1] != '+' || mode[2]))\n+\t\treturn NULL;\n+\n+\tif (mode[0] == 'w')\n+\t\tflags |= O_TRUNC;\n+\telse\n+\t\tflags |= O_APPEND;\n+\n+\tif (mode[1])\n+\t\tflags |= O_RDWR;\n+\telse\n+\t\tflags |= O_WRONLY;\n+\n+\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n+\tif (fd == -1)\n+\t\treturn NULL;\n+\n+\tfile = fdopen (fd, \""w\"");\n+\tif (!file) {\n+\t\tclose(fd);\n+\t\treturn NULL;\n+\t}\n+\n+\treturn file;\n+}\n+\n void\n set_std_fd(bool force)\n {""}<_**next**_>{""sha"": ""19682d02546d7329c410a77ad1c9569a144b5434"", ""filename"": ""lib/utils.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.h?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -182,6 +182,7 @@ extern int inet_inaddrcmp(int, const void *, const void *);\n extern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\n extern char *get_local_name(void);\n extern bool string_equal(const char *, const char *);\n+extern FILE *fopen_safe(const char *, const char *);\n extern void set_std_fd(bool);\n extern void close_std_fd(void);\n #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_""}","vrrp_tfile_end_handler(void)
{
	vrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);
	struct stat statb;
	FILE *tf;
	int ret;

	if (!tfile->file_path) {
		report_config_error(CONFIG_GENERAL_ERROR, ""No file set for track_file %s - removing"", tfile->fname);
		free_list_element(vrrp_data->vrrp_track_files, vrrp_data->vrrp_track_files->tail);
		return;
	}

	if (track_file_init == TRACK_FILE_NO_INIT)
		return;

	ret = stat(tfile->file_path, &statb);
	if (!ret) {
		if (track_file_init == TRACK_FILE_CREATE) {
			/* The file exists */
			return;
		}
		if ((statb.st_mode & S_IFMT) != S_IFREG) {
			/* It is not a regular file */
			report_config_error(CONFIG_GENERAL_ERROR, ""Cannot initialise track file %s - it is not a regular file"", tfile->fname);
			return;
		}

		/* Don't overwrite a file on reload */
		if (reload)
			return;
	}
 
 	if (!__test_bit(CONFIG_TEST_BIT, &debug)) {
 		/* Write the value to the file */
		if ((tf = fopen_safe(tfile->file_path, ""w""))) {
 			fprintf(tf, ""%d\n"", track_file_init_value);
 			fclose(tf);
 		}
		else
			report_config_error(CONFIG_GENERAL_ERROR, ""Unable to initialise track file %s"", tfile->fname);
	}
}
","vrrp_tfile_end_handler(void)
{
	vrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);
	struct stat statb;
	FILE *tf;
	int ret;

	if (!tfile->file_path) {
		report_config_error(CONFIG_GENERAL_ERROR, ""No file set for track_file %s - removing"", tfile->fname);
		free_list_element(vrrp_data->vrrp_track_files, vrrp_data->vrrp_track_files->tail);
		return;
	}

	if (track_file_init == TRACK_FILE_NO_INIT)
		return;

	ret = stat(tfile->file_path, &statb);
	if (!ret) {
		if (track_file_init == TRACK_FILE_CREATE) {
			/* The file exists */
			return;
		}
		if ((statb.st_mode & S_IFMT) != S_IFREG) {
			/* It is not a regular file */
			report_config_error(CONFIG_GENERAL_ERROR, ""Cannot initialise track file %s - it is not a regular file"", tfile->fname);
			return;
		}

		/* Don't overwrite a file on reload */
		if (reload)
			return;
	}
 
 	if (!__test_bit(CONFIG_TEST_BIT, &debug)) {
 		/* Write the value to the file */
		if ((tf = fopen(tfile->file_path, ""w""))) {
 			fprintf(tf, ""%d\n"", track_file_init_value);
 			fclose(tf);
 		}
		else
			report_config_error(CONFIG_GENERAL_ERROR, ""Unable to initialise track file %s"", tfile->fname);
	}
}
",C,"		if ((tf = fopen_safe(tfile->file_path, ""w""))) {
","		if ((tf = fopen(tfile->file_path, ""w""))) {
",,"@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)
 
 	if (!__test_bit(CONFIG_TEST_BIT, &debug)) {
 		/* Write the value to the file */
-		if ((tf = fopen(tfile->file_path, ""w""))) {
+		if ((tf = fopen_safe(tfile->file_path, ""w""))) {
 			fprintf(tf, ""%d\n"", track_file_init_value);
 			fclose(tf);
 		}",keepalived,04f2d32871bb3b11d7dc024039952f2fe2750306,5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,1,"vrrp_tfile_end_handler(void)
{
	vrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);
	struct stat statb;
	FILE *tf;
	int ret;

	if (!tfile->file_path) {
		report_config_error(CONFIG_GENERAL_ERROR, ""No file set for track_file %s - removing"", tfile->fname);
		free_list_element(vrrp_data->vrrp_track_files, vrrp_data->vrrp_track_files->tail);
		return;
	}

	if (track_file_init == TRACK_FILE_NO_INIT)
		return;

	ret = stat(tfile->file_path, &statb);
	if (!ret) {
		if (track_file_init == TRACK_FILE_CREATE) {
			/* The file exists */
			return;
		}
		if ((statb.st_mode & S_IFMT) != S_IFREG) {
			/* It is not a regular file */
			report_config_error(CONFIG_GENERAL_ERROR, ""Cannot initialise track file %s - it is not a regular file"", tfile->fname);
			return;
		}

		/* Don't overwrite a file on reload */
		if (reload)
			return;
	}
 
 	if (!__test_bit(CONFIG_TEST_BIT, &debug)) {
 		/* Write the value to the file */
//flaw_line_below:
		if ((tf = fopen(tfile->file_path, ""w""))) {
//fix_flaw_line_below:
//		if ((tf = fopen_safe(tfile->file_path, ""w""))) {
 			fprintf(tf, ""%d\n"", track_file_init_value);
 			fclose(tf);
 		}
		else
			report_config_error(CONFIG_GENERAL_ERROR, ""Unable to initialise track file %s"", tfile->fname);
	}
}
"
4427,182163,,Local,Not required,Partial,CVE-2018-19044,https://www.cvedetails.com/cve/CVE-2018-19044/,CWE-59,Medium,,Partial,,2018-11-08,3.3,"keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",2019-08-06,,1,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,04f2d32871bb3b11d7dc024039952f2fe2750306,"When opening files for write, ensure they aren't symbolic links

Issue #1048 identified that if, for example, a non privileged user
created a symbolic link from /etc/keepalvied.data to /etc/passwd,
writing to /etc/keepalived.data (which could be invoked via DBus)
would cause /etc/passwd to be overwritten.

This commit stops keepalived writing to pathnames where the ultimate
component is a symbolic link, by setting O_NOFOLLOW whenever opening
a file for writing.

This might break some setups, where, for example, /etc/keepalived.data
was a symbolic link to /home/fred/keepalived.data. If this was the case,
instead create a symbolic link from /home/fred/keepalived.data to
/tmp/keepalived.data, so that the file is still accessible via
/home/fred/keepalived.data.

There doesn't appear to be a way around this backward incompatibility,
since even checking if the pathname is a symbolic link prior to opening
for writing would create a race condition.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",1,keepalived/vrrp/vrrp_print.c,"{""sha"": ""e494976f50b4eddbab13a2704287a14541c9043b"", ""filename"": ""keepalived/core/main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/main.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \""Unable to open config-test log file %s\\n\"", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);""}<_**next**_>{""sha"": ""83f6f2fa4c1f3f7e1704c4e32b7cb9f6aafb766e"", ""filename"": ""keepalived/core/pidfile.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/pidfile.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -60,7 +60,7 @@ int\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \""w\"");\n ""}<_**next**_>{""sha"": ""d16ef3d9a6e624e724b34e6c58c7cc8878c0da5a"", ""filename"": ""keepalived/core/smtp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/smtp.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\""/tmp/smtp-alert.log\"", \""a\"");\n+\tFILE *fp = fopen_safe(\""/tmp/smtp-alert.log\"", \""a\"");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];""}<_**next**_>{""sha"": ""4cfb16366fa244d607b85bfe2ecf613495c74eb3"", ""filename"": ""keepalived/vrrp/vrrp_dbus.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_dbus.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -594,7 +594,7 @@ read_file(gchar* filepath)\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \""rb\"");\n+\tf = fopen(filepath, \""r\"");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);""}<_**next**_>{""sha"": ""1a6ea873a250f9958d52e649399ef1398f7a2087"", ""filename"": ""keepalived/vrrp/vrrp_json.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_json.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""vrrp_iprule.h\""\n #include \""logger.h\""\n #include \""timer.h\""\n+#include \""utils.h\""\n \n static inline double\n timeval_to_double(const timeval_t *t)\n@@ -55,7 +56,7 @@ vrrp_print_json(void)\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\""/tmp/keepalived.json\"",\""w\"");\n+\tfile = fopen_safe(\""/tmp/keepalived.json\"", \""w\"");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open /tmp/keepalived.json (%d: %s)\"",\n \t\t\terrno, strerror(errno));""}<_**next**_>{""sha"": ""84704b415db95999319d3ecfe3ef8c650f20e083"", ""filename"": ""keepalived/vrrp/vrrp_parser.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \""w\""))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \""w\""))) {\n \t\t\tfprintf(tf, \""%d\\n\"", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}""}<_**next**_>{""sha"": ""aeb74bcbf5dca2f2f71faa32cf1ca91ffebed75b"", ""filename"": ""keepalived/vrrp/vrrp_print.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 10, ""changes"": 17, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_print.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -32,14 +32,15 @@\n #include \""vrrp.h\""\n #include \""vrrp_data.h\""\n #include \""vrrp_print.h\""\n+#include \""utils.h\""\n \n static const char *dump_file = \""/tmp/keepalived.data\"";\n static const char *stats_file = \""/tmp/keepalived.stats\"";\n \n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \""w\"");\n+\tFILE *file = fopen_safe(dump_file, \""w\"");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n@@ -55,28 +56,24 @@ vrrp_print_data(void)\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \""w\"");\n+\tFILE *file = fopen_safe(stats_file, \""w\"");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n \t\t\tstats_file, errno, strerror(errno));\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \""VRRP Instance: %s\\n\"", vrrp->iname);\n \t\tfprintf(file, \""  Advertisements:\\n\"");\n \t\tfprintf(file, \""    Received: %\"" PRIu64 \""\\n\"", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \""    Sent: %d\\n\"", vrrp->stats->advert_sent);\n \t\tfprintf(file, \""  Became master: %d\\n\"", vrrp->stats->become_master);\n-\t\tfprintf(file, \""  Released master: %d\\n\"",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \""  Released master: %d\\n\"", vrrp->stats->release_master);\n \t\tfprintf(file, \""  Packet Errors:\\n\"");\n \t\tfprintf(file, \""    Length: %\"" PRIu64 \""\\n\"", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \""    TTL: %\"" PRIu64 \""\\n\"", vrrp->stats->ip_ttl_err);""}<_**next**_>{""sha"": ""59217c6303694449716ba3308169b6a09539e821"", ""filename"": ""keepalived/vrrp/vrrp_scheduler.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_scheduler.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1134,7 +1134,7 @@ dump_threads(void)\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \""a\"");\n+\tfp = fopen_safe(file_name, \""a\"");\n \tFREE(file_name);\n \n \tset_time_now();""}<_**next**_>{""sha"": ""20153c800f219bb6f9c512f6970caf537e1ce5f0"", ""filename"": ""lib/logger.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/logger.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \""a\"");\n+\tlog_file = fopen_safe(file_name, \""a\"");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));""}<_**next**_>{""sha"": ""3001f3ebdcd9a411edb91ee8352f4f910b54e900"", ""filename"": ""lib/memory.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/memory.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)\n \t}\n \n \tsnprintf(log_name, log_name_len, \""/tmp/%s_mem.%d.log\"", prog_name, getpid());\n-\tlog_op = fopen(log_name, \""a\"");\n+\tlog_op = fopen_safe(log_name, \""a\"");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \""Unable to open %s for appending\"", log_name);\n \t\tlog_op = stderr;""}<_**next**_>{""sha"": ""3a8c0662a4e7a61bcbdf175f0f35c704d8e7e446"", ""filename"": ""lib/notify.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/notify.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \""Unable to open %snotify fifo %s - errno %d\"", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);""}<_**next**_>{""sha"": ""1d53595c0e876c459f5677f01ffeca9c99403e84"", ""filename"": ""lib/parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \""/tmp/keywords.%d\"", getpid());\n-\t\tfp = fopen(file_name, \""w\"");\n+\t\tfp = fopen_safe(file_name, \""w\"");\n \t\tif (!fp)\n \t\t\treturn;\n \t}""}<_**next**_>{""sha"": ""4aac594454bb3fddec3b72bbe4b8b099638ef5c8"", ""filename"": ""lib/utils.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 1, ""changes"": 43, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -123,7 +123,7 @@ write_stacktrace(const char *file_name, const char *str)\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \""%s\\n\"", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n@@ -788,6 +788,47 @@ string_equal(const char *str1, const char *str2)\n \treturn !strcmp(str1, str2);\n }\n \n+/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n+ * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\n+FILE *fopen_safe(const char *path, const char *mode)\n+{\n+\tint fd;\n+\tFILE *file;\n+\tint flags = O_NOFOLLOW | O_CREAT;\n+\n+\tif (mode[0] == 'r')\n+\t\treturn fopen(path, mode);\n+\n+\tif (mode[0] != 'a' && mode[0] != 'w')\n+\t\treturn NULL;\n+\n+\tif (mode[1] &&\n+\t    (mode[1] != '+' || mode[2]))\n+\t\treturn NULL;\n+\n+\tif (mode[0] == 'w')\n+\t\tflags |= O_TRUNC;\n+\telse\n+\t\tflags |= O_APPEND;\n+\n+\tif (mode[1])\n+\t\tflags |= O_RDWR;\n+\telse\n+\t\tflags |= O_WRONLY;\n+\n+\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n+\tif (fd == -1)\n+\t\treturn NULL;\n+\n+\tfile = fdopen (fd, \""w\"");\n+\tif (!file) {\n+\t\tclose(fd);\n+\t\treturn NULL;\n+\t}\n+\n+\treturn file;\n+}\n+\n void\n set_std_fd(bool force)\n {""}<_**next**_>{""sha"": ""19682d02546d7329c410a77ad1c9569a144b5434"", ""filename"": ""lib/utils.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.h?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -182,6 +182,7 @@ extern int inet_inaddrcmp(int, const void *, const void *);\n extern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\n extern char *get_local_name(void);\n extern bool string_equal(const char *, const char *);\n+extern FILE *fopen_safe(const char *, const char *);\n extern void set_std_fd(bool);\n extern void close_std_fd(void);\n #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_""}"," vrrp_print_data(void)
 {
	FILE *file = fopen_safe(dump_file, ""w"");
 
 	if (!file) {
 		log_message(LOG_INFO, ""Can't open %s (%d: %s)"",
			dump_file, errno, strerror(errno));
		return;
	}

	dump_data_vrrp(file);

	fclose(file);
}
"," vrrp_print_data(void)
 {
	FILE *file = fopen (dump_file, ""w"");
 
 	if (!file) {
 		log_message(LOG_INFO, ""Can't open %s (%d: %s)"",
			dump_file, errno, strerror(errno));
		return;
	}

	dump_data_vrrp(file);

	fclose(file);
}
",C,"	FILE *file = fopen_safe(dump_file, ""w"");
","	FILE *file = fopen (dump_file, ""w"");
",,"@@ -32,14 +32,15 @@
 #include ""vrrp.h""
 #include ""vrrp_data.h""
 #include ""vrrp_print.h""
+#include ""utils.h""
 
 static const char *dump_file = ""/tmp/keepalived.data"";
 static const char *stats_file = ""/tmp/keepalived.stats"";
 
 void
 vrrp_print_data(void)
 {
-	FILE *file = fopen (dump_file, ""w"");
+	FILE *file = fopen_safe(dump_file, ""w"");
 
 	if (!file) {
 		log_message(LOG_INFO, ""Can't open %s (%d: %s)"",
@@ -55,28 +56,24 @@ vrrp_print_data(void)
 void
 vrrp_print_stats(void)
 {
-	FILE *file;
-	file = fopen (stats_file, ""w"");
+	FILE *file = fopen_safe(stats_file, ""w"");
+	element e;
+	vrrp_t *vrrp;
 
 	if (!file) {
 		log_message(LOG_INFO, ""Can't open %s (%d: %s)"",
 			stats_file, errno, strerror(errno));
 		return;
 	}
 
-	list l = vrrp_data->vrrp;
-	element e;
-	vrrp_t *vrrp;
 
-	for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {
-		vrrp = ELEMENT_DATA(e);
+	LIST_FOREACH(vrrp_data->vrrp, vrrp, e) {
 		fprintf(file, ""VRRP Instance: %s\n"", vrrp->iname);
 		fprintf(file, ""  Advertisements:\n"");
 		fprintf(file, ""    Received: %"" PRIu64 ""\n"", vrrp->stats->advert_rcvd);
 		fprintf(file, ""    Sent: %d\n"", vrrp->stats->advert_sent);
 		fprintf(file, ""  Became master: %d\n"", vrrp->stats->become_master);
-		fprintf(file, ""  Released master: %d\n"",
-			vrrp->stats->release_master);
+		fprintf(file, ""  Released master: %d\n"", vrrp->stats->release_master);
 		fprintf(file, ""  Packet Errors:\n"");
 		fprintf(file, ""    Length: %"" PRIu64 ""\n"", vrrp->stats->packet_len_err);
 		fprintf(file, ""    TTL: %"" PRIu64 ""\n"", vrrp->stats->ip_ttl_err);",keepalived,04f2d32871bb3b11d7dc024039952f2fe2750306,5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,1," vrrp_print_data(void)
 {
//flaw_line_below:
	FILE *file = fopen (dump_file, ""w"");
//fix_flaw_line_below:
//	FILE *file = fopen_safe(dump_file, ""w"");
 
 	if (!file) {
 		log_message(LOG_INFO, ""Can't open %s (%d: %s)"",
			dump_file, errno, strerror(errno));
		return;
	}

	dump_data_vrrp(file);

	fclose(file);
}
"
4428,182164,,Local,Not required,Partial,CVE-2018-19044,https://www.cvedetails.com/cve/CVE-2018-19044/,CWE-59,Medium,,Partial,,2018-11-08,3.3,"keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",2019-08-06,,5,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,04f2d32871bb3b11d7dc024039952f2fe2750306,"When opening files for write, ensure they aren't symbolic links

Issue #1048 identified that if, for example, a non privileged user
created a symbolic link from /etc/keepalvied.data to /etc/passwd,
writing to /etc/keepalived.data (which could be invoked via DBus)
would cause /etc/passwd to be overwritten.

This commit stops keepalived writing to pathnames where the ultimate
component is a symbolic link, by setting O_NOFOLLOW whenever opening
a file for writing.

This might break some setups, where, for example, /etc/keepalived.data
was a symbolic link to /home/fred/keepalived.data. If this was the case,
instead create a symbolic link from /home/fred/keepalived.data to
/tmp/keepalived.data, so that the file is still accessible via
/home/fred/keepalived.data.

There doesn't appear to be a way around this backward incompatibility,
since even checking if the pathname is a symbolic link prior to opening
for writing would create a race condition.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",9,keepalived/vrrp/vrrp_print.c,"{""sha"": ""e494976f50b4eddbab13a2704287a14541c9043b"", ""filename"": ""keepalived/core/main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/main.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \""Unable to open config-test log file %s\\n\"", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);""}<_**next**_>{""sha"": ""83f6f2fa4c1f3f7e1704c4e32b7cb9f6aafb766e"", ""filename"": ""keepalived/core/pidfile.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/pidfile.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -60,7 +60,7 @@ int\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \""w\"");\n ""}<_**next**_>{""sha"": ""d16ef3d9a6e624e724b34e6c58c7cc8878c0da5a"", ""filename"": ""keepalived/core/smtp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/smtp.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\""/tmp/smtp-alert.log\"", \""a\"");\n+\tFILE *fp = fopen_safe(\""/tmp/smtp-alert.log\"", \""a\"");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];""}<_**next**_>{""sha"": ""4cfb16366fa244d607b85bfe2ecf613495c74eb3"", ""filename"": ""keepalived/vrrp/vrrp_dbus.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_dbus.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -594,7 +594,7 @@ read_file(gchar* filepath)\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \""rb\"");\n+\tf = fopen(filepath, \""r\"");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);""}<_**next**_>{""sha"": ""1a6ea873a250f9958d52e649399ef1398f7a2087"", ""filename"": ""keepalived/vrrp/vrrp_json.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_json.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""vrrp_iprule.h\""\n #include \""logger.h\""\n #include \""timer.h\""\n+#include \""utils.h\""\n \n static inline double\n timeval_to_double(const timeval_t *t)\n@@ -55,7 +56,7 @@ vrrp_print_json(void)\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\""/tmp/keepalived.json\"",\""w\"");\n+\tfile = fopen_safe(\""/tmp/keepalived.json\"", \""w\"");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open /tmp/keepalived.json (%d: %s)\"",\n \t\t\terrno, strerror(errno));""}<_**next**_>{""sha"": ""84704b415db95999319d3ecfe3ef8c650f20e083"", ""filename"": ""keepalived/vrrp/vrrp_parser.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \""w\""))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \""w\""))) {\n \t\t\tfprintf(tf, \""%d\\n\"", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}""}<_**next**_>{""sha"": ""aeb74bcbf5dca2f2f71faa32cf1ca91ffebed75b"", ""filename"": ""keepalived/vrrp/vrrp_print.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 10, ""changes"": 17, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_print.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -32,14 +32,15 @@\n #include \""vrrp.h\""\n #include \""vrrp_data.h\""\n #include \""vrrp_print.h\""\n+#include \""utils.h\""\n \n static const char *dump_file = \""/tmp/keepalived.data\"";\n static const char *stats_file = \""/tmp/keepalived.stats\"";\n \n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \""w\"");\n+\tFILE *file = fopen_safe(dump_file, \""w\"");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n@@ -55,28 +56,24 @@ vrrp_print_data(void)\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \""w\"");\n+\tFILE *file = fopen_safe(stats_file, \""w\"");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n \t\t\tstats_file, errno, strerror(errno));\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \""VRRP Instance: %s\\n\"", vrrp->iname);\n \t\tfprintf(file, \""  Advertisements:\\n\"");\n \t\tfprintf(file, \""    Received: %\"" PRIu64 \""\\n\"", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \""    Sent: %d\\n\"", vrrp->stats->advert_sent);\n \t\tfprintf(file, \""  Became master: %d\\n\"", vrrp->stats->become_master);\n-\t\tfprintf(file, \""  Released master: %d\\n\"",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \""  Released master: %d\\n\"", vrrp->stats->release_master);\n \t\tfprintf(file, \""  Packet Errors:\\n\"");\n \t\tfprintf(file, \""    Length: %\"" PRIu64 \""\\n\"", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \""    TTL: %\"" PRIu64 \""\\n\"", vrrp->stats->ip_ttl_err);""}<_**next**_>{""sha"": ""59217c6303694449716ba3308169b6a09539e821"", ""filename"": ""keepalived/vrrp/vrrp_scheduler.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_scheduler.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1134,7 +1134,7 @@ dump_threads(void)\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \""a\"");\n+\tfp = fopen_safe(file_name, \""a\"");\n \tFREE(file_name);\n \n \tset_time_now();""}<_**next**_>{""sha"": ""20153c800f219bb6f9c512f6970caf537e1ce5f0"", ""filename"": ""lib/logger.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/logger.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \""a\"");\n+\tlog_file = fopen_safe(file_name, \""a\"");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));""}<_**next**_>{""sha"": ""3001f3ebdcd9a411edb91ee8352f4f910b54e900"", ""filename"": ""lib/memory.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/memory.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)\n \t}\n \n \tsnprintf(log_name, log_name_len, \""/tmp/%s_mem.%d.log\"", prog_name, getpid());\n-\tlog_op = fopen(log_name, \""a\"");\n+\tlog_op = fopen_safe(log_name, \""a\"");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \""Unable to open %s for appending\"", log_name);\n \t\tlog_op = stderr;""}<_**next**_>{""sha"": ""3a8c0662a4e7a61bcbdf175f0f35c704d8e7e446"", ""filename"": ""lib/notify.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/notify.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \""Unable to open %snotify fifo %s - errno %d\"", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);""}<_**next**_>{""sha"": ""1d53595c0e876c459f5677f01ffeca9c99403e84"", ""filename"": ""lib/parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \""/tmp/keywords.%d\"", getpid());\n-\t\tfp = fopen(file_name, \""w\"");\n+\t\tfp = fopen_safe(file_name, \""w\"");\n \t\tif (!fp)\n \t\t\treturn;\n \t}""}<_**next**_>{""sha"": ""4aac594454bb3fddec3b72bbe4b8b099638ef5c8"", ""filename"": ""lib/utils.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 1, ""changes"": 43, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -123,7 +123,7 @@ write_stacktrace(const char *file_name, const char *str)\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \""%s\\n\"", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n@@ -788,6 +788,47 @@ string_equal(const char *str1, const char *str2)\n \treturn !strcmp(str1, str2);\n }\n \n+/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n+ * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\n+FILE *fopen_safe(const char *path, const char *mode)\n+{\n+\tint fd;\n+\tFILE *file;\n+\tint flags = O_NOFOLLOW | O_CREAT;\n+\n+\tif (mode[0] == 'r')\n+\t\treturn fopen(path, mode);\n+\n+\tif (mode[0] != 'a' && mode[0] != 'w')\n+\t\treturn NULL;\n+\n+\tif (mode[1] &&\n+\t    (mode[1] != '+' || mode[2]))\n+\t\treturn NULL;\n+\n+\tif (mode[0] == 'w')\n+\t\tflags |= O_TRUNC;\n+\telse\n+\t\tflags |= O_APPEND;\n+\n+\tif (mode[1])\n+\t\tflags |= O_RDWR;\n+\telse\n+\t\tflags |= O_WRONLY;\n+\n+\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n+\tif (fd == -1)\n+\t\treturn NULL;\n+\n+\tfile = fdopen (fd, \""w\"");\n+\tif (!file) {\n+\t\tclose(fd);\n+\t\treturn NULL;\n+\t}\n+\n+\treturn file;\n+}\n+\n void\n set_std_fd(bool force)\n {""}<_**next**_>{""sha"": ""19682d02546d7329c410a77ad1c9569a144b5434"", ""filename"": ""lib/utils.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.h?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -182,6 +182,7 @@ extern int inet_inaddrcmp(int, const void *, const void *);\n extern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\n extern char *get_local_name(void);\n extern bool string_equal(const char *, const char *);\n+extern FILE *fopen_safe(const char *, const char *);\n extern void set_std_fd(bool);\n extern void close_std_fd(void);\n #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_""}"," vrrp_print_stats(void)
 {
	FILE *file = fopen_safe(stats_file, ""w"");
	element e;
	vrrp_t *vrrp;
 
 	if (!file) {
 		log_message(LOG_INFO, ""Can't open %s (%d: %s)"",
 			stats_file, errno, strerror(errno));
 		return;
 	}
 
 
	LIST_FOREACH(vrrp_data->vrrp, vrrp, e) {
 		fprintf(file, ""VRRP Instance: %s\n"", vrrp->iname);
 		fprintf(file, ""  Advertisements:\n"");
 		fprintf(file, ""    Received: %"" PRIu64 ""\n"", vrrp->stats->advert_rcvd);
 		fprintf(file, ""    Sent: %d\n"", vrrp->stats->advert_sent);
 		fprintf(file, ""  Became master: %d\n"", vrrp->stats->become_master);
		fprintf(file, ""  Released master: %d\n"", vrrp->stats->release_master);
 		fprintf(file, ""  Packet Errors:\n"");
 		fprintf(file, ""    Length: %"" PRIu64 ""\n"", vrrp->stats->packet_len_err);
 		fprintf(file, ""    TTL: %"" PRIu64 ""\n"", vrrp->stats->ip_ttl_err);
		fprintf(file, ""    Invalid Type: %"" PRIu64 ""\n"",
			vrrp->stats->invalid_type_rcvd);
		fprintf(file, ""    Advertisement Interval: %"" PRIu64 ""\n"",
			vrrp->stats->advert_interval_err);
		fprintf(file, ""    Address List: %"" PRIu64 ""\n"",
			vrrp->stats->addr_list_err);
		fprintf(file, ""  Authentication Errors:\n"");
		fprintf(file, ""    Invalid Type: %d\n"",
			vrrp->stats->invalid_authtype);
#ifdef _WITH_VRRP_AUTH_
		fprintf(file, ""    Type Mismatch: %d\n"",
			vrrp->stats->authtype_mismatch);
		fprintf(file, ""    Failure: %d\n"",
			vrrp->stats->auth_failure);
#endif
		fprintf(file, ""  Priority Zero:\n"");
		fprintf(file, ""    Received: %"" PRIu64 ""\n"", vrrp->stats->pri_zero_rcvd);
		fprintf(file, ""    Sent: %"" PRIu64 ""\n"", vrrp->stats->pri_zero_sent);
	}
	fclose(file);
}
"," vrrp_print_stats(void)
 {
	FILE *file;
	file = fopen (stats_file, ""w"");
 
 	if (!file) {
 		log_message(LOG_INFO, ""Can't open %s (%d: %s)"",
 			stats_file, errno, strerror(errno));
 		return;
 	}
 
	list l = vrrp_data->vrrp;
	element e;
	vrrp_t *vrrp;
 
	for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {
		vrrp = ELEMENT_DATA(e);
 		fprintf(file, ""VRRP Instance: %s\n"", vrrp->iname);
 		fprintf(file, ""  Advertisements:\n"");
 		fprintf(file, ""    Received: %"" PRIu64 ""\n"", vrrp->stats->advert_rcvd);
 		fprintf(file, ""    Sent: %d\n"", vrrp->stats->advert_sent);
 		fprintf(file, ""  Became master: %d\n"", vrrp->stats->become_master);
		fprintf(file, ""  Released master: %d\n"",
			vrrp->stats->release_master);
 		fprintf(file, ""  Packet Errors:\n"");
 		fprintf(file, ""    Length: %"" PRIu64 ""\n"", vrrp->stats->packet_len_err);
 		fprintf(file, ""    TTL: %"" PRIu64 ""\n"", vrrp->stats->ip_ttl_err);
		fprintf(file, ""    Invalid Type: %"" PRIu64 ""\n"",
			vrrp->stats->invalid_type_rcvd);
		fprintf(file, ""    Advertisement Interval: %"" PRIu64 ""\n"",
			vrrp->stats->advert_interval_err);
		fprintf(file, ""    Address List: %"" PRIu64 ""\n"",
			vrrp->stats->addr_list_err);
		fprintf(file, ""  Authentication Errors:\n"");
		fprintf(file, ""    Invalid Type: %d\n"",
			vrrp->stats->invalid_authtype);
#ifdef _WITH_VRRP_AUTH_
		fprintf(file, ""    Type Mismatch: %d\n"",
			vrrp->stats->authtype_mismatch);
		fprintf(file, ""    Failure: %d\n"",
			vrrp->stats->auth_failure);
#endif
		fprintf(file, ""  Priority Zero:\n"");
		fprintf(file, ""    Received: %"" PRIu64 ""\n"", vrrp->stats->pri_zero_rcvd);
		fprintf(file, ""    Sent: %"" PRIu64 ""\n"", vrrp->stats->pri_zero_sent);
	}
	fclose(file);
}
",C,"	FILE *file = fopen_safe(stats_file, ""w"");
	element e;
	vrrp_t *vrrp;
	LIST_FOREACH(vrrp_data->vrrp, vrrp, e) {
		fprintf(file, ""  Released master: %d\n"", vrrp->stats->release_master);
","	FILE *file;
	file = fopen (stats_file, ""w"");
	list l = vrrp_data->vrrp;
	element e;
	vrrp_t *vrrp;
	for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {
		vrrp = ELEMENT_DATA(e);
		fprintf(file, ""  Released master: %d\n"",
			vrrp->stats->release_master);
",,"@@ -32,14 +32,15 @@
 #include ""vrrp.h""
 #include ""vrrp_data.h""
 #include ""vrrp_print.h""
+#include ""utils.h""
 
 static const char *dump_file = ""/tmp/keepalived.data"";
 static const char *stats_file = ""/tmp/keepalived.stats"";
 
 void
 vrrp_print_data(void)
 {
-	FILE *file = fopen (dump_file, ""w"");
+	FILE *file = fopen_safe(dump_file, ""w"");
 
 	if (!file) {
 		log_message(LOG_INFO, ""Can't open %s (%d: %s)"",
@@ -55,28 +56,24 @@ vrrp_print_data(void)
 void
 vrrp_print_stats(void)
 {
-	FILE *file;
-	file = fopen (stats_file, ""w"");
+	FILE *file = fopen_safe(stats_file, ""w"");
+	element e;
+	vrrp_t *vrrp;
 
 	if (!file) {
 		log_message(LOG_INFO, ""Can't open %s (%d: %s)"",
 			stats_file, errno, strerror(errno));
 		return;
 	}
 
-	list l = vrrp_data->vrrp;
-	element e;
-	vrrp_t *vrrp;
 
-	for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {
-		vrrp = ELEMENT_DATA(e);
+	LIST_FOREACH(vrrp_data->vrrp, vrrp, e) {
 		fprintf(file, ""VRRP Instance: %s\n"", vrrp->iname);
 		fprintf(file, ""  Advertisements:\n"");
 		fprintf(file, ""    Received: %"" PRIu64 ""\n"", vrrp->stats->advert_rcvd);
 		fprintf(file, ""    Sent: %d\n"", vrrp->stats->advert_sent);
 		fprintf(file, ""  Became master: %d\n"", vrrp->stats->become_master);
-		fprintf(file, ""  Released master: %d\n"",
-			vrrp->stats->release_master);
+		fprintf(file, ""  Released master: %d\n"", vrrp->stats->release_master);
 		fprintf(file, ""  Packet Errors:\n"");
 		fprintf(file, ""    Length: %"" PRIu64 ""\n"", vrrp->stats->packet_len_err);
 		fprintf(file, ""    TTL: %"" PRIu64 ""\n"", vrrp->stats->ip_ttl_err);",keepalived,04f2d32871bb3b11d7dc024039952f2fe2750306,5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,1," vrrp_print_stats(void)
 {
//flaw_line_below:
	FILE *file;
//flaw_line_below:
	file = fopen (stats_file, ""w"");
//fix_flaw_line_below:
//	FILE *file = fopen_safe(stats_file, ""w"");
//fix_flaw_line_below:
//	element e;
//fix_flaw_line_below:
//	vrrp_t *vrrp;
 
 	if (!file) {
 		log_message(LOG_INFO, ""Can't open %s (%d: %s)"",
 			stats_file, errno, strerror(errno));
 		return;
 	}
 
//flaw_line_below:
	list l = vrrp_data->vrrp;
//flaw_line_below:
	element e;
//flaw_line_below:
	vrrp_t *vrrp;
 
//flaw_line_below:
	for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {
//flaw_line_below:
		vrrp = ELEMENT_DATA(e);
//fix_flaw_line_below:
//	LIST_FOREACH(vrrp_data->vrrp, vrrp, e) {
 		fprintf(file, ""VRRP Instance: %s\n"", vrrp->iname);
 		fprintf(file, ""  Advertisements:\n"");
 		fprintf(file, ""    Received: %"" PRIu64 ""\n"", vrrp->stats->advert_rcvd);
 		fprintf(file, ""    Sent: %d\n"", vrrp->stats->advert_sent);
 		fprintf(file, ""  Became master: %d\n"", vrrp->stats->become_master);
//flaw_line_below:
		fprintf(file, ""  Released master: %d\n"",
//flaw_line_below:
			vrrp->stats->release_master);
//fix_flaw_line_below:
//		fprintf(file, ""  Released master: %d\n"", vrrp->stats->release_master);
 		fprintf(file, ""  Packet Errors:\n"");
 		fprintf(file, ""    Length: %"" PRIu64 ""\n"", vrrp->stats->packet_len_err);
 		fprintf(file, ""    TTL: %"" PRIu64 ""\n"", vrrp->stats->ip_ttl_err);
		fprintf(file, ""    Invalid Type: %"" PRIu64 ""\n"",
			vrrp->stats->invalid_type_rcvd);
		fprintf(file, ""    Advertisement Interval: %"" PRIu64 ""\n"",
			vrrp->stats->advert_interval_err);
		fprintf(file, ""    Address List: %"" PRIu64 ""\n"",
			vrrp->stats->addr_list_err);
		fprintf(file, ""  Authentication Errors:\n"");
		fprintf(file, ""    Invalid Type: %d\n"",
			vrrp->stats->invalid_authtype);
#ifdef _WITH_VRRP_AUTH_
		fprintf(file, ""    Type Mismatch: %d\n"",
			vrrp->stats->authtype_mismatch);
		fprintf(file, ""    Failure: %d\n"",
			vrrp->stats->auth_failure);
#endif
		fprintf(file, ""  Priority Zero:\n"");
		fprintf(file, ""    Received: %"" PRIu64 ""\n"", vrrp->stats->pri_zero_rcvd);
		fprintf(file, ""    Sent: %"" PRIu64 ""\n"", vrrp->stats->pri_zero_sent);
	}
	fclose(file);
}
"
4429,182165,,Local,Not required,Partial,CVE-2018-19044,https://www.cvedetails.com/cve/CVE-2018-19044/,CWE-59,Medium,,Partial,,2018-11-08,3.3,"keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",2019-08-06,,1,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,04f2d32871bb3b11d7dc024039952f2fe2750306,"When opening files for write, ensure they aren't symbolic links

Issue #1048 identified that if, for example, a non privileged user
created a symbolic link from /etc/keepalvied.data to /etc/passwd,
writing to /etc/keepalived.data (which could be invoked via DBus)
would cause /etc/passwd to be overwritten.

This commit stops keepalived writing to pathnames where the ultimate
component is a symbolic link, by setting O_NOFOLLOW whenever opening
a file for writing.

This might break some setups, where, for example, /etc/keepalived.data
was a symbolic link to /home/fred/keepalived.data. If this was the case,
instead create a symbolic link from /home/fred/keepalived.data to
/tmp/keepalived.data, so that the file is still accessible via
/home/fred/keepalived.data.

There doesn't appear to be a way around this backward incompatibility,
since even checking if the pathname is a symbolic link prior to opening
for writing would create a race condition.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",1,keepalived/vrrp/vrrp_scheduler.c,"{""sha"": ""e494976f50b4eddbab13a2704287a14541c9043b"", ""filename"": ""keepalived/core/main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/main.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \""Unable to open config-test log file %s\\n\"", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);""}<_**next**_>{""sha"": ""83f6f2fa4c1f3f7e1704c4e32b7cb9f6aafb766e"", ""filename"": ""keepalived/core/pidfile.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/pidfile.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -60,7 +60,7 @@ int\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \""w\"");\n ""}<_**next**_>{""sha"": ""d16ef3d9a6e624e724b34e6c58c7cc8878c0da5a"", ""filename"": ""keepalived/core/smtp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/smtp.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\""/tmp/smtp-alert.log\"", \""a\"");\n+\tFILE *fp = fopen_safe(\""/tmp/smtp-alert.log\"", \""a\"");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];""}<_**next**_>{""sha"": ""4cfb16366fa244d607b85bfe2ecf613495c74eb3"", ""filename"": ""keepalived/vrrp/vrrp_dbus.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_dbus.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -594,7 +594,7 @@ read_file(gchar* filepath)\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \""rb\"");\n+\tf = fopen(filepath, \""r\"");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);""}<_**next**_>{""sha"": ""1a6ea873a250f9958d52e649399ef1398f7a2087"", ""filename"": ""keepalived/vrrp/vrrp_json.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_json.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""vrrp_iprule.h\""\n #include \""logger.h\""\n #include \""timer.h\""\n+#include \""utils.h\""\n \n static inline double\n timeval_to_double(const timeval_t *t)\n@@ -55,7 +56,7 @@ vrrp_print_json(void)\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\""/tmp/keepalived.json\"",\""w\"");\n+\tfile = fopen_safe(\""/tmp/keepalived.json\"", \""w\"");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open /tmp/keepalived.json (%d: %s)\"",\n \t\t\terrno, strerror(errno));""}<_**next**_>{""sha"": ""84704b415db95999319d3ecfe3ef8c650f20e083"", ""filename"": ""keepalived/vrrp/vrrp_parser.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \""w\""))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \""w\""))) {\n \t\t\tfprintf(tf, \""%d\\n\"", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}""}<_**next**_>{""sha"": ""aeb74bcbf5dca2f2f71faa32cf1ca91ffebed75b"", ""filename"": ""keepalived/vrrp/vrrp_print.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 10, ""changes"": 17, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_print.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -32,14 +32,15 @@\n #include \""vrrp.h\""\n #include \""vrrp_data.h\""\n #include \""vrrp_print.h\""\n+#include \""utils.h\""\n \n static const char *dump_file = \""/tmp/keepalived.data\"";\n static const char *stats_file = \""/tmp/keepalived.stats\"";\n \n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \""w\"");\n+\tFILE *file = fopen_safe(dump_file, \""w\"");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n@@ -55,28 +56,24 @@ vrrp_print_data(void)\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \""w\"");\n+\tFILE *file = fopen_safe(stats_file, \""w\"");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n \t\t\tstats_file, errno, strerror(errno));\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \""VRRP Instance: %s\\n\"", vrrp->iname);\n \t\tfprintf(file, \""  Advertisements:\\n\"");\n \t\tfprintf(file, \""    Received: %\"" PRIu64 \""\\n\"", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \""    Sent: %d\\n\"", vrrp->stats->advert_sent);\n \t\tfprintf(file, \""  Became master: %d\\n\"", vrrp->stats->become_master);\n-\t\tfprintf(file, \""  Released master: %d\\n\"",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \""  Released master: %d\\n\"", vrrp->stats->release_master);\n \t\tfprintf(file, \""  Packet Errors:\\n\"");\n \t\tfprintf(file, \""    Length: %\"" PRIu64 \""\\n\"", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \""    TTL: %\"" PRIu64 \""\\n\"", vrrp->stats->ip_ttl_err);""}<_**next**_>{""sha"": ""59217c6303694449716ba3308169b6a09539e821"", ""filename"": ""keepalived/vrrp/vrrp_scheduler.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_scheduler.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1134,7 +1134,7 @@ dump_threads(void)\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \""a\"");\n+\tfp = fopen_safe(file_name, \""a\"");\n \tFREE(file_name);\n \n \tset_time_now();""}<_**next**_>{""sha"": ""20153c800f219bb6f9c512f6970caf537e1ce5f0"", ""filename"": ""lib/logger.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/logger.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \""a\"");\n+\tlog_file = fopen_safe(file_name, \""a\"");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));""}<_**next**_>{""sha"": ""3001f3ebdcd9a411edb91ee8352f4f910b54e900"", ""filename"": ""lib/memory.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/memory.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)\n \t}\n \n \tsnprintf(log_name, log_name_len, \""/tmp/%s_mem.%d.log\"", prog_name, getpid());\n-\tlog_op = fopen(log_name, \""a\"");\n+\tlog_op = fopen_safe(log_name, \""a\"");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \""Unable to open %s for appending\"", log_name);\n \t\tlog_op = stderr;""}<_**next**_>{""sha"": ""3a8c0662a4e7a61bcbdf175f0f35c704d8e7e446"", ""filename"": ""lib/notify.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/notify.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \""Unable to open %snotify fifo %s - errno %d\"", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);""}<_**next**_>{""sha"": ""1d53595c0e876c459f5677f01ffeca9c99403e84"", ""filename"": ""lib/parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \""/tmp/keywords.%d\"", getpid());\n-\t\tfp = fopen(file_name, \""w\"");\n+\t\tfp = fopen_safe(file_name, \""w\"");\n \t\tif (!fp)\n \t\t\treturn;\n \t}""}<_**next**_>{""sha"": ""4aac594454bb3fddec3b72bbe4b8b099638ef5c8"", ""filename"": ""lib/utils.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 1, ""changes"": 43, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -123,7 +123,7 @@ write_stacktrace(const char *file_name, const char *str)\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \""%s\\n\"", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n@@ -788,6 +788,47 @@ string_equal(const char *str1, const char *str2)\n \treturn !strcmp(str1, str2);\n }\n \n+/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n+ * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\n+FILE *fopen_safe(const char *path, const char *mode)\n+{\n+\tint fd;\n+\tFILE *file;\n+\tint flags = O_NOFOLLOW | O_CREAT;\n+\n+\tif (mode[0] == 'r')\n+\t\treturn fopen(path, mode);\n+\n+\tif (mode[0] != 'a' && mode[0] != 'w')\n+\t\treturn NULL;\n+\n+\tif (mode[1] &&\n+\t    (mode[1] != '+' || mode[2]))\n+\t\treturn NULL;\n+\n+\tif (mode[0] == 'w')\n+\t\tflags |= O_TRUNC;\n+\telse\n+\t\tflags |= O_APPEND;\n+\n+\tif (mode[1])\n+\t\tflags |= O_RDWR;\n+\telse\n+\t\tflags |= O_WRONLY;\n+\n+\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n+\tif (fd == -1)\n+\t\treturn NULL;\n+\n+\tfile = fdopen (fd, \""w\"");\n+\tif (!file) {\n+\t\tclose(fd);\n+\t\treturn NULL;\n+\t}\n+\n+\treturn file;\n+}\n+\n void\n set_std_fd(bool force)\n {""}<_**next**_>{""sha"": ""19682d02546d7329c410a77ad1c9569a144b5434"", ""filename"": ""lib/utils.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.h?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -182,6 +182,7 @@ extern int inet_inaddrcmp(int, const void *, const void *);\n extern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\n extern char *get_local_name(void);\n extern bool string_equal(const char *, const char *);\n+extern FILE *fopen_safe(const char *, const char *);\n extern void set_std_fd(bool);\n extern void close_std_fd(void);\n #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_""}","dump_threads(void)
{
	FILE *fp;
	char time_buf[26];
	element e;
	vrrp_t *vrrp;
	char *file_name;

	file_name = make_file_name(""/tmp/thread_dump.dat"",
					""vrrp"",
#if HAVE_DECL_CLONE_NEWNET
					global_data->network_namespace,
#else
 					NULL,
 #endif
 					global_data->instance_name);
	fp = fopen_safe(file_name, ""a"");
 	FREE(file_name);
 
 	set_time_now();
	ctime_r(&time_now.tv_sec, time_buf);

	fprintf(fp, ""\n%.19s.%6.6ld: Thread dump\n"", time_buf, time_now.tv_usec);

	dump_thread_data(master, fp);

	fprintf(fp, ""alloc = %lu\n"", master->alloc);

	fprintf(fp, ""\n"");
	LIST_FOREACH(vrrp_data->vrrp, vrrp, e) {
		ctime_r(&vrrp->sands.tv_sec, time_buf);
		fprintf(fp, ""VRRP instance %s, sands %.19s.%6.6lu, status %s\n"", vrrp->iname, time_buf, vrrp->sands.tv_usec,
				vrrp->state == VRRP_STATE_INIT ? ""INIT"" :
				vrrp->state == VRRP_STATE_BACK ? ""BACKUP"" :
				vrrp->state == VRRP_STATE_MAST ? ""MASTER"" :
				vrrp->state == VRRP_STATE_FAULT ? ""FAULT"" :
				vrrp->state == VRRP_STATE_STOP ? ""STOP"" :
				vrrp->state == VRRP_DISPATCHER ? ""DISPATCHER"" : ""unknown"");
	}
	fclose(fp);
}
","dump_threads(void)
{
	FILE *fp;
	char time_buf[26];
	element e;
	vrrp_t *vrrp;
	char *file_name;

	file_name = make_file_name(""/tmp/thread_dump.dat"",
					""vrrp"",
#if HAVE_DECL_CLONE_NEWNET
					global_data->network_namespace,
#else
 					NULL,
 #endif
 					global_data->instance_name);
	fp = fopen(file_name, ""a"");
 	FREE(file_name);
 
 	set_time_now();
	ctime_r(&time_now.tv_sec, time_buf);

	fprintf(fp, ""\n%.19s.%6.6ld: Thread dump\n"", time_buf, time_now.tv_usec);

	dump_thread_data(master, fp);

	fprintf(fp, ""alloc = %lu\n"", master->alloc);

	fprintf(fp, ""\n"");
	LIST_FOREACH(vrrp_data->vrrp, vrrp, e) {
		ctime_r(&vrrp->sands.tv_sec, time_buf);
		fprintf(fp, ""VRRP instance %s, sands %.19s.%6.6lu, status %s\n"", vrrp->iname, time_buf, vrrp->sands.tv_usec,
				vrrp->state == VRRP_STATE_INIT ? ""INIT"" :
				vrrp->state == VRRP_STATE_BACK ? ""BACKUP"" :
				vrrp->state == VRRP_STATE_MAST ? ""MASTER"" :
				vrrp->state == VRRP_STATE_FAULT ? ""FAULT"" :
				vrrp->state == VRRP_STATE_STOP ? ""STOP"" :
				vrrp->state == VRRP_DISPATCHER ? ""DISPATCHER"" : ""unknown"");
	}
	fclose(fp);
}
",C,"	fp = fopen_safe(file_name, ""a"");
","	fp = fopen(file_name, ""a"");
",,"@@ -1134,7 +1134,7 @@ dump_threads(void)
 					NULL,
 #endif
 					global_data->instance_name);
-	fp = fopen(file_name, ""a"");
+	fp = fopen_safe(file_name, ""a"");
 	FREE(file_name);
 
 	set_time_now();",keepalived,04f2d32871bb3b11d7dc024039952f2fe2750306,5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,1,"dump_threads(void)
{
	FILE *fp;
	char time_buf[26];
	element e;
	vrrp_t *vrrp;
	char *file_name;

	file_name = make_file_name(""/tmp/thread_dump.dat"",
					""vrrp"",
#if HAVE_DECL_CLONE_NEWNET
					global_data->network_namespace,
#else
 					NULL,
 #endif
 					global_data->instance_name);
//flaw_line_below:
	fp = fopen(file_name, ""a"");
//fix_flaw_line_below:
//	fp = fopen_safe(file_name, ""a"");
 	FREE(file_name);
 
 	set_time_now();
	ctime_r(&time_now.tv_sec, time_buf);

	fprintf(fp, ""\n%.19s.%6.6ld: Thread dump\n"", time_buf, time_now.tv_usec);

	dump_thread_data(master, fp);

	fprintf(fp, ""alloc = %lu\n"", master->alloc);

	fprintf(fp, ""\n"");
	LIST_FOREACH(vrrp_data->vrrp, vrrp, e) {
		ctime_r(&vrrp->sands.tv_sec, time_buf);
		fprintf(fp, ""VRRP instance %s, sands %.19s.%6.6lu, status %s\n"", vrrp->iname, time_buf, vrrp->sands.tv_usec,
				vrrp->state == VRRP_STATE_INIT ? ""INIT"" :
				vrrp->state == VRRP_STATE_BACK ? ""BACKUP"" :
				vrrp->state == VRRP_STATE_MAST ? ""MASTER"" :
				vrrp->state == VRRP_STATE_FAULT ? ""FAULT"" :
				vrrp->state == VRRP_STATE_STOP ? ""STOP"" :
				vrrp->state == VRRP_DISPATCHER ? ""DISPATCHER"" : ""unknown"");
	}
	fclose(fp);
}
"
4430,182166,,Local,Not required,Partial,CVE-2018-19044,https://www.cvedetails.com/cve/CVE-2018-19044/,CWE-59,Medium,,Partial,,2018-11-08,3.3,"keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",2019-08-06,,1,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,04f2d32871bb3b11d7dc024039952f2fe2750306,"When opening files for write, ensure they aren't symbolic links

Issue #1048 identified that if, for example, a non privileged user
created a symbolic link from /etc/keepalvied.data to /etc/passwd,
writing to /etc/keepalived.data (which could be invoked via DBus)
would cause /etc/passwd to be overwritten.

This commit stops keepalived writing to pathnames where the ultimate
component is a symbolic link, by setting O_NOFOLLOW whenever opening
a file for writing.

This might break some setups, where, for example, /etc/keepalived.data
was a symbolic link to /home/fred/keepalived.data. If this was the case,
instead create a symbolic link from /home/fred/keepalived.data to
/tmp/keepalived.data, so that the file is still accessible via
/home/fred/keepalived.data.

There doesn't appear to be a way around this backward incompatibility,
since even checking if the pathname is a symbolic link prior to opening
for writing would create a race condition.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",1,lib/logger.c,"{""sha"": ""e494976f50b4eddbab13a2704287a14541c9043b"", ""filename"": ""keepalived/core/main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/main.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \""Unable to open config-test log file %s\\n\"", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);""}<_**next**_>{""sha"": ""83f6f2fa4c1f3f7e1704c4e32b7cb9f6aafb766e"", ""filename"": ""keepalived/core/pidfile.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/pidfile.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -60,7 +60,7 @@ int\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \""w\"");\n ""}<_**next**_>{""sha"": ""d16ef3d9a6e624e724b34e6c58c7cc8878c0da5a"", ""filename"": ""keepalived/core/smtp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/smtp.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\""/tmp/smtp-alert.log\"", \""a\"");\n+\tFILE *fp = fopen_safe(\""/tmp/smtp-alert.log\"", \""a\"");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];""}<_**next**_>{""sha"": ""4cfb16366fa244d607b85bfe2ecf613495c74eb3"", ""filename"": ""keepalived/vrrp/vrrp_dbus.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_dbus.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -594,7 +594,7 @@ read_file(gchar* filepath)\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \""rb\"");\n+\tf = fopen(filepath, \""r\"");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);""}<_**next**_>{""sha"": ""1a6ea873a250f9958d52e649399ef1398f7a2087"", ""filename"": ""keepalived/vrrp/vrrp_json.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_json.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""vrrp_iprule.h\""\n #include \""logger.h\""\n #include \""timer.h\""\n+#include \""utils.h\""\n \n static inline double\n timeval_to_double(const timeval_t *t)\n@@ -55,7 +56,7 @@ vrrp_print_json(void)\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\""/tmp/keepalived.json\"",\""w\"");\n+\tfile = fopen_safe(\""/tmp/keepalived.json\"", \""w\"");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open /tmp/keepalived.json (%d: %s)\"",\n \t\t\terrno, strerror(errno));""}<_**next**_>{""sha"": ""84704b415db95999319d3ecfe3ef8c650f20e083"", ""filename"": ""keepalived/vrrp/vrrp_parser.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \""w\""))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \""w\""))) {\n \t\t\tfprintf(tf, \""%d\\n\"", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}""}<_**next**_>{""sha"": ""aeb74bcbf5dca2f2f71faa32cf1ca91ffebed75b"", ""filename"": ""keepalived/vrrp/vrrp_print.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 10, ""changes"": 17, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_print.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -32,14 +32,15 @@\n #include \""vrrp.h\""\n #include \""vrrp_data.h\""\n #include \""vrrp_print.h\""\n+#include \""utils.h\""\n \n static const char *dump_file = \""/tmp/keepalived.data\"";\n static const char *stats_file = \""/tmp/keepalived.stats\"";\n \n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \""w\"");\n+\tFILE *file = fopen_safe(dump_file, \""w\"");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n@@ -55,28 +56,24 @@ vrrp_print_data(void)\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \""w\"");\n+\tFILE *file = fopen_safe(stats_file, \""w\"");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n \t\t\tstats_file, errno, strerror(errno));\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \""VRRP Instance: %s\\n\"", vrrp->iname);\n \t\tfprintf(file, \""  Advertisements:\\n\"");\n \t\tfprintf(file, \""    Received: %\"" PRIu64 \""\\n\"", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \""    Sent: %d\\n\"", vrrp->stats->advert_sent);\n \t\tfprintf(file, \""  Became master: %d\\n\"", vrrp->stats->become_master);\n-\t\tfprintf(file, \""  Released master: %d\\n\"",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \""  Released master: %d\\n\"", vrrp->stats->release_master);\n \t\tfprintf(file, \""  Packet Errors:\\n\"");\n \t\tfprintf(file, \""    Length: %\"" PRIu64 \""\\n\"", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \""    TTL: %\"" PRIu64 \""\\n\"", vrrp->stats->ip_ttl_err);""}<_**next**_>{""sha"": ""59217c6303694449716ba3308169b6a09539e821"", ""filename"": ""keepalived/vrrp/vrrp_scheduler.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_scheduler.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1134,7 +1134,7 @@ dump_threads(void)\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \""a\"");\n+\tfp = fopen_safe(file_name, \""a\"");\n \tFREE(file_name);\n \n \tset_time_now();""}<_**next**_>{""sha"": ""20153c800f219bb6f9c512f6970caf537e1ce5f0"", ""filename"": ""lib/logger.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/logger.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \""a\"");\n+\tlog_file = fopen_safe(file_name, \""a\"");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));""}<_**next**_>{""sha"": ""3001f3ebdcd9a411edb91ee8352f4f910b54e900"", ""filename"": ""lib/memory.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/memory.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)\n \t}\n \n \tsnprintf(log_name, log_name_len, \""/tmp/%s_mem.%d.log\"", prog_name, getpid());\n-\tlog_op = fopen(log_name, \""a\"");\n+\tlog_op = fopen_safe(log_name, \""a\"");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \""Unable to open %s for appending\"", log_name);\n \t\tlog_op = stderr;""}<_**next**_>{""sha"": ""3a8c0662a4e7a61bcbdf175f0f35c704d8e7e446"", ""filename"": ""lib/notify.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/notify.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \""Unable to open %snotify fifo %s - errno %d\"", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);""}<_**next**_>{""sha"": ""1d53595c0e876c459f5677f01ffeca9c99403e84"", ""filename"": ""lib/parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \""/tmp/keywords.%d\"", getpid());\n-\t\tfp = fopen(file_name, \""w\"");\n+\t\tfp = fopen_safe(file_name, \""w\"");\n \t\tif (!fp)\n \t\t\treturn;\n \t}""}<_**next**_>{""sha"": ""4aac594454bb3fddec3b72bbe4b8b099638ef5c8"", ""filename"": ""lib/utils.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 1, ""changes"": 43, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -123,7 +123,7 @@ write_stacktrace(const char *file_name, const char *str)\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \""%s\\n\"", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n@@ -788,6 +788,47 @@ string_equal(const char *str1, const char *str2)\n \treturn !strcmp(str1, str2);\n }\n \n+/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n+ * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\n+FILE *fopen_safe(const char *path, const char *mode)\n+{\n+\tint fd;\n+\tFILE *file;\n+\tint flags = O_NOFOLLOW | O_CREAT;\n+\n+\tif (mode[0] == 'r')\n+\t\treturn fopen(path, mode);\n+\n+\tif (mode[0] != 'a' && mode[0] != 'w')\n+\t\treturn NULL;\n+\n+\tif (mode[1] &&\n+\t    (mode[1] != '+' || mode[2]))\n+\t\treturn NULL;\n+\n+\tif (mode[0] == 'w')\n+\t\tflags |= O_TRUNC;\n+\telse\n+\t\tflags |= O_APPEND;\n+\n+\tif (mode[1])\n+\t\tflags |= O_RDWR;\n+\telse\n+\t\tflags |= O_WRONLY;\n+\n+\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n+\tif (fd == -1)\n+\t\treturn NULL;\n+\n+\tfile = fdopen (fd, \""w\"");\n+\tif (!file) {\n+\t\tclose(fd);\n+\t\treturn NULL;\n+\t}\n+\n+\treturn file;\n+}\n+\n void\n set_std_fd(bool force)\n {""}<_**next**_>{""sha"": ""19682d02546d7329c410a77ad1c9569a144b5434"", ""filename"": ""lib/utils.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.h?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -182,6 +182,7 @@ extern int inet_inaddrcmp(int, const void *, const void *);\n extern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\n extern char *get_local_name(void);\n extern bool string_equal(const char *, const char *);\n+extern FILE *fopen_safe(const char *, const char *);\n extern void set_std_fd(bool);\n extern void close_std_fd(void);\n #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_""}","open_log_file(const char *name, const char *prog, const char *namespace, const char *instance)
{
	char *file_name;

	if (log_file) {
		fclose(log_file);
		log_file = NULL;
	}

	if (!name)
		return;
 
 	file_name = make_file_name(name, prog, namespace, instance);
 
	log_file = fopen_safe(file_name, ""a"");
 	if (log_file) {
 		int n = fileno(log_file);
 		fcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));
		fcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));
	}

	FREE(file_name);
}
","open_log_file(const char *name, const char *prog, const char *namespace, const char *instance)
{
	char *file_name;

	if (log_file) {
		fclose(log_file);
		log_file = NULL;
	}

	if (!name)
		return;
 
 	file_name = make_file_name(name, prog, namespace, instance);
 
	log_file = fopen(file_name, ""a"");
 	if (log_file) {
 		int n = fileno(log_file);
 		fcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));
		fcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));
	}

	FREE(file_name);
}
",C,"	log_file = fopen_safe(file_name, ""a"");
","	log_file = fopen(file_name, ""a"");
",,"@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c
 
 	file_name = make_file_name(name, prog, namespace, instance);
 
-	log_file = fopen(file_name, ""a"");
+	log_file = fopen_safe(file_name, ""a"");
 	if (log_file) {
 		int n = fileno(log_file);
 		fcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));",keepalived,04f2d32871bb3b11d7dc024039952f2fe2750306,5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,1,"open_log_file(const char *name, const char *prog, const char *namespace, const char *instance)
{
	char *file_name;

	if (log_file) {
		fclose(log_file);
		log_file = NULL;
	}

	if (!name)
		return;
 
 	file_name = make_file_name(name, prog, namespace, instance);
 
//flaw_line_below:
	log_file = fopen(file_name, ""a"");
//fix_flaw_line_below:
//	log_file = fopen_safe(file_name, ""a"");
 	if (log_file) {
 		int n = fileno(log_file);
 		fcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));
		fcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));
	}

	FREE(file_name);
}
"
4431,182167,,Local,Not required,Partial,CVE-2018-19044,https://www.cvedetails.com/cve/CVE-2018-19044/,CWE-59,Medium,,Partial,,2018-11-08,3.3,"keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",2019-08-06,,1,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,04f2d32871bb3b11d7dc024039952f2fe2750306,"When opening files for write, ensure they aren't symbolic links

Issue #1048 identified that if, for example, a non privileged user
created a symbolic link from /etc/keepalvied.data to /etc/passwd,
writing to /etc/keepalived.data (which could be invoked via DBus)
would cause /etc/passwd to be overwritten.

This commit stops keepalived writing to pathnames where the ultimate
component is a symbolic link, by setting O_NOFOLLOW whenever opening
a file for writing.

This might break some setups, where, for example, /etc/keepalived.data
was a symbolic link to /home/fred/keepalived.data. If this was the case,
instead create a symbolic link from /home/fred/keepalived.data to
/tmp/keepalived.data, so that the file is still accessible via
/home/fred/keepalived.data.

There doesn't appear to be a way around this backward incompatibility,
since even checking if the pathname is a symbolic link prior to opening
for writing would create a race condition.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",1,lib/memory.c,"{""sha"": ""e494976f50b4eddbab13a2704287a14541c9043b"", ""filename"": ""keepalived/core/main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/main.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \""Unable to open config-test log file %s\\n\"", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);""}<_**next**_>{""sha"": ""83f6f2fa4c1f3f7e1704c4e32b7cb9f6aafb766e"", ""filename"": ""keepalived/core/pidfile.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/pidfile.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -60,7 +60,7 @@ int\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \""w\"");\n ""}<_**next**_>{""sha"": ""d16ef3d9a6e624e724b34e6c58c7cc8878c0da5a"", ""filename"": ""keepalived/core/smtp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/smtp.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\""/tmp/smtp-alert.log\"", \""a\"");\n+\tFILE *fp = fopen_safe(\""/tmp/smtp-alert.log\"", \""a\"");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];""}<_**next**_>{""sha"": ""4cfb16366fa244d607b85bfe2ecf613495c74eb3"", ""filename"": ""keepalived/vrrp/vrrp_dbus.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_dbus.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -594,7 +594,7 @@ read_file(gchar* filepath)\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \""rb\"");\n+\tf = fopen(filepath, \""r\"");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);""}<_**next**_>{""sha"": ""1a6ea873a250f9958d52e649399ef1398f7a2087"", ""filename"": ""keepalived/vrrp/vrrp_json.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_json.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""vrrp_iprule.h\""\n #include \""logger.h\""\n #include \""timer.h\""\n+#include \""utils.h\""\n \n static inline double\n timeval_to_double(const timeval_t *t)\n@@ -55,7 +56,7 @@ vrrp_print_json(void)\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\""/tmp/keepalived.json\"",\""w\"");\n+\tfile = fopen_safe(\""/tmp/keepalived.json\"", \""w\"");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open /tmp/keepalived.json (%d: %s)\"",\n \t\t\terrno, strerror(errno));""}<_**next**_>{""sha"": ""84704b415db95999319d3ecfe3ef8c650f20e083"", ""filename"": ""keepalived/vrrp/vrrp_parser.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \""w\""))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \""w\""))) {\n \t\t\tfprintf(tf, \""%d\\n\"", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}""}<_**next**_>{""sha"": ""aeb74bcbf5dca2f2f71faa32cf1ca91ffebed75b"", ""filename"": ""keepalived/vrrp/vrrp_print.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 10, ""changes"": 17, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_print.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -32,14 +32,15 @@\n #include \""vrrp.h\""\n #include \""vrrp_data.h\""\n #include \""vrrp_print.h\""\n+#include \""utils.h\""\n \n static const char *dump_file = \""/tmp/keepalived.data\"";\n static const char *stats_file = \""/tmp/keepalived.stats\"";\n \n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \""w\"");\n+\tFILE *file = fopen_safe(dump_file, \""w\"");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n@@ -55,28 +56,24 @@ vrrp_print_data(void)\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \""w\"");\n+\tFILE *file = fopen_safe(stats_file, \""w\"");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n \t\t\tstats_file, errno, strerror(errno));\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \""VRRP Instance: %s\\n\"", vrrp->iname);\n \t\tfprintf(file, \""  Advertisements:\\n\"");\n \t\tfprintf(file, \""    Received: %\"" PRIu64 \""\\n\"", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \""    Sent: %d\\n\"", vrrp->stats->advert_sent);\n \t\tfprintf(file, \""  Became master: %d\\n\"", vrrp->stats->become_master);\n-\t\tfprintf(file, \""  Released master: %d\\n\"",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \""  Released master: %d\\n\"", vrrp->stats->release_master);\n \t\tfprintf(file, \""  Packet Errors:\\n\"");\n \t\tfprintf(file, \""    Length: %\"" PRIu64 \""\\n\"", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \""    TTL: %\"" PRIu64 \""\\n\"", vrrp->stats->ip_ttl_err);""}<_**next**_>{""sha"": ""59217c6303694449716ba3308169b6a09539e821"", ""filename"": ""keepalived/vrrp/vrrp_scheduler.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_scheduler.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1134,7 +1134,7 @@ dump_threads(void)\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \""a\"");\n+\tfp = fopen_safe(file_name, \""a\"");\n \tFREE(file_name);\n \n \tset_time_now();""}<_**next**_>{""sha"": ""20153c800f219bb6f9c512f6970caf537e1ce5f0"", ""filename"": ""lib/logger.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/logger.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \""a\"");\n+\tlog_file = fopen_safe(file_name, \""a\"");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));""}<_**next**_>{""sha"": ""3001f3ebdcd9a411edb91ee8352f4f910b54e900"", ""filename"": ""lib/memory.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/memory.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)\n \t}\n \n \tsnprintf(log_name, log_name_len, \""/tmp/%s_mem.%d.log\"", prog_name, getpid());\n-\tlog_op = fopen(log_name, \""a\"");\n+\tlog_op = fopen_safe(log_name, \""a\"");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \""Unable to open %s for appending\"", log_name);\n \t\tlog_op = stderr;""}<_**next**_>{""sha"": ""3a8c0662a4e7a61bcbdf175f0f35c704d8e7e446"", ""filename"": ""lib/notify.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/notify.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \""Unable to open %snotify fifo %s - errno %d\"", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);""}<_**next**_>{""sha"": ""1d53595c0e876c459f5677f01ffeca9c99403e84"", ""filename"": ""lib/parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \""/tmp/keywords.%d\"", getpid());\n-\t\tfp = fopen(file_name, \""w\"");\n+\t\tfp = fopen_safe(file_name, \""w\"");\n \t\tif (!fp)\n \t\t\treturn;\n \t}""}<_**next**_>{""sha"": ""4aac594454bb3fddec3b72bbe4b8b099638ef5c8"", ""filename"": ""lib/utils.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 1, ""changes"": 43, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -123,7 +123,7 @@ write_stacktrace(const char *file_name, const char *str)\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \""%s\\n\"", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n@@ -788,6 +788,47 @@ string_equal(const char *str1, const char *str2)\n \treturn !strcmp(str1, str2);\n }\n \n+/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n+ * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\n+FILE *fopen_safe(const char *path, const char *mode)\n+{\n+\tint fd;\n+\tFILE *file;\n+\tint flags = O_NOFOLLOW | O_CREAT;\n+\n+\tif (mode[0] == 'r')\n+\t\treturn fopen(path, mode);\n+\n+\tif (mode[0] != 'a' && mode[0] != 'w')\n+\t\treturn NULL;\n+\n+\tif (mode[1] &&\n+\t    (mode[1] != '+' || mode[2]))\n+\t\treturn NULL;\n+\n+\tif (mode[0] == 'w')\n+\t\tflags |= O_TRUNC;\n+\telse\n+\t\tflags |= O_APPEND;\n+\n+\tif (mode[1])\n+\t\tflags |= O_RDWR;\n+\telse\n+\t\tflags |= O_WRONLY;\n+\n+\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n+\tif (fd == -1)\n+\t\treturn NULL;\n+\n+\tfile = fdopen (fd, \""w\"");\n+\tif (!file) {\n+\t\tclose(fd);\n+\t\treturn NULL;\n+\t}\n+\n+\treturn file;\n+}\n+\n void\n set_std_fd(bool force)\n {""}<_**next**_>{""sha"": ""19682d02546d7329c410a77ad1c9569a144b5434"", ""filename"": ""lib/utils.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.h?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -182,6 +182,7 @@ extern int inet_inaddrcmp(int, const void *, const void *);\n extern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\n extern char *get_local_name(void);\n extern bool string_equal(const char *, const char *);\n+extern FILE *fopen_safe(const char *, const char *);\n extern void set_std_fd(bool);\n extern void close_std_fd(void);\n #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_""}","mem_log_init(const char* prog_name, const char *banner)
{
	size_t log_name_len;
	char *log_name;

	if (__test_bit(LOG_CONSOLE_BIT, &debug)) {
		log_op = stderr;
		return;
	}

	if (log_op)
		fclose(log_op);

	log_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1;	/* ""/tmp/"" + prog_name + ""_mem."" + PID + "".log"" + '\0"" */
	log_name = malloc(log_name_len);
	if (!log_name) {
		log_message(LOG_INFO, ""Unable to malloc log file name"");
		log_op = stderr;
		return;
 	}
 
 	snprintf(log_name, log_name_len, ""/tmp/%s_mem.%d.log"", prog_name, getpid());
	log_op = fopen_safe(log_name, ""a"");
 	if (log_op == NULL) {
 		log_message(LOG_INFO, ""Unable to open %s for appending"", log_name);
 		log_op = stderr;
	}
	else {
		int fd = fileno(log_op);

		/* We don't want any children to inherit the log file */
		fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);

		/* Make the log output line buffered. This was to ensure that
		 * children didn't inherit the buffer, but the CLOEXEC above
		 * should resolve that. */
		setlinebuf(log_op);

		fprintf(log_op, ""\n"");
	}

	free(log_name);

	terminate_banner = banner;
}
","mem_log_init(const char* prog_name, const char *banner)
{
	size_t log_name_len;
	char *log_name;

	if (__test_bit(LOG_CONSOLE_BIT, &debug)) {
		log_op = stderr;
		return;
	}

	if (log_op)
		fclose(log_op);

	log_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1;	/* ""/tmp/"" + prog_name + ""_mem."" + PID + "".log"" + '\0"" */
	log_name = malloc(log_name_len);
	if (!log_name) {
		log_message(LOG_INFO, ""Unable to malloc log file name"");
		log_op = stderr;
		return;
 	}
 
 	snprintf(log_name, log_name_len, ""/tmp/%s_mem.%d.log"", prog_name, getpid());
	log_op = fopen(log_name, ""a"");
 	if (log_op == NULL) {
 		log_message(LOG_INFO, ""Unable to open %s for appending"", log_name);
 		log_op = stderr;
	}
	else {
		int fd = fileno(log_op);

		/* We don't want any children to inherit the log file */
		fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);

		/* Make the log output line buffered. This was to ensure that
		 * children didn't inherit the buffer, but the CLOEXEC above
		 * should resolve that. */
		setlinebuf(log_op);

		fprintf(log_op, ""\n"");
	}

	free(log_name);

	terminate_banner = banner;
}
",C,"	log_op = fopen_safe(log_name, ""a"");
","	log_op = fopen(log_name, ""a"");
",,"@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)
 	}
 
 	snprintf(log_name, log_name_len, ""/tmp/%s_mem.%d.log"", prog_name, getpid());
-	log_op = fopen(log_name, ""a"");
+	log_op = fopen_safe(log_name, ""a"");
 	if (log_op == NULL) {
 		log_message(LOG_INFO, ""Unable to open %s for appending"", log_name);
 		log_op = stderr;",keepalived,04f2d32871bb3b11d7dc024039952f2fe2750306,5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,1,"mem_log_init(const char* prog_name, const char *banner)
{
	size_t log_name_len;
	char *log_name;

	if (__test_bit(LOG_CONSOLE_BIT, &debug)) {
		log_op = stderr;
		return;
	}

	if (log_op)
		fclose(log_op);

	log_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1;	/* ""/tmp/"" + prog_name + ""_mem."" + PID + "".log"" + '\0"" */
	log_name = malloc(log_name_len);
	if (!log_name) {
		log_message(LOG_INFO, ""Unable to malloc log file name"");
		log_op = stderr;
		return;
 	}
 
 	snprintf(log_name, log_name_len, ""/tmp/%s_mem.%d.log"", prog_name, getpid());
//flaw_line_below:
	log_op = fopen(log_name, ""a"");
//fix_flaw_line_below:
//	log_op = fopen_safe(log_name, ""a"");
 	if (log_op == NULL) {
 		log_message(LOG_INFO, ""Unable to open %s for appending"", log_name);
 		log_op = stderr;
	}
	else {
		int fd = fileno(log_op);

		/* We don't want any children to inherit the log file */
		fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);

		/* Make the log output line buffered. This was to ensure that
		 * children didn't inherit the buffer, but the CLOEXEC above
		 * should resolve that. */
		setlinebuf(log_op);

		fprintf(log_op, ""\n"");
	}

	free(log_name);

	terminate_banner = banner;
}
"
4432,182168,,Local,Not required,Partial,CVE-2018-19044,https://www.cvedetails.com/cve/CVE-2018-19044/,CWE-59,Medium,,Partial,,2018-11-08,3.3,"keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",2019-08-06,,1,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,04f2d32871bb3b11d7dc024039952f2fe2750306,"When opening files for write, ensure they aren't symbolic links

Issue #1048 identified that if, for example, a non privileged user
created a symbolic link from /etc/keepalvied.data to /etc/passwd,
writing to /etc/keepalived.data (which could be invoked via DBus)
would cause /etc/passwd to be overwritten.

This commit stops keepalived writing to pathnames where the ultimate
component is a symbolic link, by setting O_NOFOLLOW whenever opening
a file for writing.

This might break some setups, where, for example, /etc/keepalived.data
was a symbolic link to /home/fred/keepalived.data. If this was the case,
instead create a symbolic link from /home/fred/keepalived.data to
/tmp/keepalived.data, so that the file is still accessible via
/home/fred/keepalived.data.

There doesn't appear to be a way around this backward incompatibility,
since even checking if the pathname is a symbolic link prior to opening
for writing would create a race condition.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",1,lib/notify.c,"{""sha"": ""e494976f50b4eddbab13a2704287a14541c9043b"", ""filename"": ""keepalived/core/main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/main.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \""Unable to open config-test log file %s\\n\"", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);""}<_**next**_>{""sha"": ""83f6f2fa4c1f3f7e1704c4e32b7cb9f6aafb766e"", ""filename"": ""keepalived/core/pidfile.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/pidfile.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -60,7 +60,7 @@ int\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \""w\"");\n ""}<_**next**_>{""sha"": ""d16ef3d9a6e624e724b34e6c58c7cc8878c0da5a"", ""filename"": ""keepalived/core/smtp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/smtp.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\""/tmp/smtp-alert.log\"", \""a\"");\n+\tFILE *fp = fopen_safe(\""/tmp/smtp-alert.log\"", \""a\"");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];""}<_**next**_>{""sha"": ""4cfb16366fa244d607b85bfe2ecf613495c74eb3"", ""filename"": ""keepalived/vrrp/vrrp_dbus.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_dbus.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -594,7 +594,7 @@ read_file(gchar* filepath)\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \""rb\"");\n+\tf = fopen(filepath, \""r\"");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);""}<_**next**_>{""sha"": ""1a6ea873a250f9958d52e649399ef1398f7a2087"", ""filename"": ""keepalived/vrrp/vrrp_json.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_json.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""vrrp_iprule.h\""\n #include \""logger.h\""\n #include \""timer.h\""\n+#include \""utils.h\""\n \n static inline double\n timeval_to_double(const timeval_t *t)\n@@ -55,7 +56,7 @@ vrrp_print_json(void)\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\""/tmp/keepalived.json\"",\""w\"");\n+\tfile = fopen_safe(\""/tmp/keepalived.json\"", \""w\"");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open /tmp/keepalived.json (%d: %s)\"",\n \t\t\terrno, strerror(errno));""}<_**next**_>{""sha"": ""84704b415db95999319d3ecfe3ef8c650f20e083"", ""filename"": ""keepalived/vrrp/vrrp_parser.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \""w\""))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \""w\""))) {\n \t\t\tfprintf(tf, \""%d\\n\"", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}""}<_**next**_>{""sha"": ""aeb74bcbf5dca2f2f71faa32cf1ca91ffebed75b"", ""filename"": ""keepalived/vrrp/vrrp_print.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 10, ""changes"": 17, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_print.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -32,14 +32,15 @@\n #include \""vrrp.h\""\n #include \""vrrp_data.h\""\n #include \""vrrp_print.h\""\n+#include \""utils.h\""\n \n static const char *dump_file = \""/tmp/keepalived.data\"";\n static const char *stats_file = \""/tmp/keepalived.stats\"";\n \n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \""w\"");\n+\tFILE *file = fopen_safe(dump_file, \""w\"");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n@@ -55,28 +56,24 @@ vrrp_print_data(void)\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \""w\"");\n+\tFILE *file = fopen_safe(stats_file, \""w\"");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n \t\t\tstats_file, errno, strerror(errno));\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \""VRRP Instance: %s\\n\"", vrrp->iname);\n \t\tfprintf(file, \""  Advertisements:\\n\"");\n \t\tfprintf(file, \""    Received: %\"" PRIu64 \""\\n\"", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \""    Sent: %d\\n\"", vrrp->stats->advert_sent);\n \t\tfprintf(file, \""  Became master: %d\\n\"", vrrp->stats->become_master);\n-\t\tfprintf(file, \""  Released master: %d\\n\"",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \""  Released master: %d\\n\"", vrrp->stats->release_master);\n \t\tfprintf(file, \""  Packet Errors:\\n\"");\n \t\tfprintf(file, \""    Length: %\"" PRIu64 \""\\n\"", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \""    TTL: %\"" PRIu64 \""\\n\"", vrrp->stats->ip_ttl_err);""}<_**next**_>{""sha"": ""59217c6303694449716ba3308169b6a09539e821"", ""filename"": ""keepalived/vrrp/vrrp_scheduler.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_scheduler.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1134,7 +1134,7 @@ dump_threads(void)\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \""a\"");\n+\tfp = fopen_safe(file_name, \""a\"");\n \tFREE(file_name);\n \n \tset_time_now();""}<_**next**_>{""sha"": ""20153c800f219bb6f9c512f6970caf537e1ce5f0"", ""filename"": ""lib/logger.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/logger.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \""a\"");\n+\tlog_file = fopen_safe(file_name, \""a\"");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));""}<_**next**_>{""sha"": ""3001f3ebdcd9a411edb91ee8352f4f910b54e900"", ""filename"": ""lib/memory.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/memory.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)\n \t}\n \n \tsnprintf(log_name, log_name_len, \""/tmp/%s_mem.%d.log\"", prog_name, getpid());\n-\tlog_op = fopen(log_name, \""a\"");\n+\tlog_op = fopen_safe(log_name, \""a\"");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \""Unable to open %s for appending\"", log_name);\n \t\tlog_op = stderr;""}<_**next**_>{""sha"": ""3a8c0662a4e7a61bcbdf175f0f35c704d8e7e446"", ""filename"": ""lib/notify.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/notify.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \""Unable to open %snotify fifo %s - errno %d\"", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);""}<_**next**_>{""sha"": ""1d53595c0e876c459f5677f01ffeca9c99403e84"", ""filename"": ""lib/parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \""/tmp/keywords.%d\"", getpid());\n-\t\tfp = fopen(file_name, \""w\"");\n+\t\tfp = fopen_safe(file_name, \""w\"");\n \t\tif (!fp)\n \t\t\treturn;\n \t}""}<_**next**_>{""sha"": ""4aac594454bb3fddec3b72bbe4b8b099638ef5c8"", ""filename"": ""lib/utils.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 1, ""changes"": 43, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -123,7 +123,7 @@ write_stacktrace(const char *file_name, const char *str)\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \""%s\\n\"", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n@@ -788,6 +788,47 @@ string_equal(const char *str1, const char *str2)\n \treturn !strcmp(str1, str2);\n }\n \n+/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n+ * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\n+FILE *fopen_safe(const char *path, const char *mode)\n+{\n+\tint fd;\n+\tFILE *file;\n+\tint flags = O_NOFOLLOW | O_CREAT;\n+\n+\tif (mode[0] == 'r')\n+\t\treturn fopen(path, mode);\n+\n+\tif (mode[0] != 'a' && mode[0] != 'w')\n+\t\treturn NULL;\n+\n+\tif (mode[1] &&\n+\t    (mode[1] != '+' || mode[2]))\n+\t\treturn NULL;\n+\n+\tif (mode[0] == 'w')\n+\t\tflags |= O_TRUNC;\n+\telse\n+\t\tflags |= O_APPEND;\n+\n+\tif (mode[1])\n+\t\tflags |= O_RDWR;\n+\telse\n+\t\tflags |= O_WRONLY;\n+\n+\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n+\tif (fd == -1)\n+\t\treturn NULL;\n+\n+\tfile = fdopen (fd, \""w\"");\n+\tif (!file) {\n+\t\tclose(fd);\n+\t\treturn NULL;\n+\t}\n+\n+\treturn file;\n+}\n+\n void\n set_std_fd(bool force)\n {""}<_**next**_>{""sha"": ""19682d02546d7329c410a77ad1c9569a144b5434"", ""filename"": ""lib/utils.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.h?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -182,6 +182,7 @@ extern int inet_inaddrcmp(int, const void *, const void *);\n extern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\n extern char *get_local_name(void);\n extern bool string_equal(const char *, const char *);\n+extern FILE *fopen_safe(const char *, const char *);\n extern void set_std_fd(bool);\n extern void close_std_fd(void);\n #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_""}","fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)
{
	int ret;
	int sav_errno;

	if (fifo->name) {
		sav_errno = 0;

		if (!(ret = mkfifo(fifo->name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)))
			fifo->created_fifo = true;
		else {
			sav_errno = errno;

			if (sav_errno != EEXIST)
				log_message(LOG_INFO, ""Unable to create %snotify fifo %s"", type, fifo->name);
		}

		if (!sav_errno || sav_errno == EEXIST) {
			/* Run the notify script if there is one */
			if (fifo->script)
 				notify_fifo_exec(master, script_exit, fifo, fifo->script);
 
 			/* Now open the fifo */
			if ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {
 				log_message(LOG_INFO, ""Unable to open %snotify fifo %s - errno %d"", type, fifo->name, errno);
 				if (fifo->created_fifo) {
 					unlink(fifo->name);
					fifo->created_fifo = false;
				}
			}
		}

		if (fifo->fd == -1) {
			FREE(fifo->name);
			fifo->name = NULL;
		}
	}
}
","fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)
{
	int ret;
	int sav_errno;

	if (fifo->name) {
		sav_errno = 0;

		if (!(ret = mkfifo(fifo->name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)))
			fifo->created_fifo = true;
		else {
			sav_errno = errno;

			if (sav_errno != EEXIST)
				log_message(LOG_INFO, ""Unable to create %snotify fifo %s"", type, fifo->name);
		}

		if (!sav_errno || sav_errno == EEXIST) {
			/* Run the notify script if there is one */
			if (fifo->script)
 				notify_fifo_exec(master, script_exit, fifo, fifo->script);
 
 			/* Now open the fifo */
			if ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {
 				log_message(LOG_INFO, ""Unable to open %snotify fifo %s - errno %d"", type, fifo->name, errno);
 				if (fifo->created_fifo) {
 					unlink(fifo->name);
					fifo->created_fifo = false;
				}
			}
		}

		if (fifo->fd == -1) {
			FREE(fifo->name);
			fifo->name = NULL;
		}
	}
}
",C,"			if ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {
","			if ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {
",,"@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)
 				notify_fifo_exec(master, script_exit, fifo, fifo->script);
 
 			/* Now open the fifo */
-			if ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {
+			if ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {
 				log_message(LOG_INFO, ""Unable to open %snotify fifo %s - errno %d"", type, fifo->name, errno);
 				if (fifo->created_fifo) {
 					unlink(fifo->name);",keepalived,04f2d32871bb3b11d7dc024039952f2fe2750306,5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,1,"fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)
{
	int ret;
	int sav_errno;

	if (fifo->name) {
		sav_errno = 0;

		if (!(ret = mkfifo(fifo->name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)))
			fifo->created_fifo = true;
		else {
			sav_errno = errno;

			if (sav_errno != EEXIST)
				log_message(LOG_INFO, ""Unable to create %snotify fifo %s"", type, fifo->name);
		}

		if (!sav_errno || sav_errno == EEXIST) {
			/* Run the notify script if there is one */
			if (fifo->script)
 				notify_fifo_exec(master, script_exit, fifo, fifo->script);
 
 			/* Now open the fifo */
//flaw_line_below:
			if ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {
//fix_flaw_line_below:
//			if ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {
 				log_message(LOG_INFO, ""Unable to open %snotify fifo %s - errno %d"", type, fifo->name, errno);
 				if (fifo->created_fifo) {
 					unlink(fifo->name);
					fifo->created_fifo = false;
				}
			}
		}

		if (fifo->fd == -1) {
			FREE(fifo->name);
			fifo->name = NULL;
		}
	}
}
"
4433,182169,,Local,Not required,Partial,CVE-2018-19044,https://www.cvedetails.com/cve/CVE-2018-19044/,CWE-59,Medium,,Partial,,2018-11-08,3.3,"keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",2019-08-06,,2,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,04f2d32871bb3b11d7dc024039952f2fe2750306,"When opening files for write, ensure they aren't symbolic links

Issue #1048 identified that if, for example, a non privileged user
created a symbolic link from /etc/keepalvied.data to /etc/passwd,
writing to /etc/keepalived.data (which could be invoked via DBus)
would cause /etc/passwd to be overwritten.

This commit stops keepalived writing to pathnames where the ultimate
component is a symbolic link, by setting O_NOFOLLOW whenever opening
a file for writing.

This might break some setups, where, for example, /etc/keepalived.data
was a symbolic link to /home/fred/keepalived.data. If this was the case,
instead create a symbolic link from /home/fred/keepalived.data to
/tmp/keepalived.data, so that the file is still accessible via
/home/fred/keepalived.data.

There doesn't appear to be a way around this backward incompatibility,
since even checking if the pathname is a symbolic link prior to opening
for writing would create a race condition.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",2,lib/parser.c,"{""sha"": ""e494976f50b4eddbab13a2704287a14541c9043b"", ""filename"": ""keepalived/core/main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/main.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \""Unable to open config-test log file %s\\n\"", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);""}<_**next**_>{""sha"": ""83f6f2fa4c1f3f7e1704c4e32b7cb9f6aafb766e"", ""filename"": ""keepalived/core/pidfile.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/pidfile.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -60,7 +60,7 @@ int\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \""w\"");\n ""}<_**next**_>{""sha"": ""d16ef3d9a6e624e724b34e6c58c7cc8878c0da5a"", ""filename"": ""keepalived/core/smtp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/smtp.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\""/tmp/smtp-alert.log\"", \""a\"");\n+\tFILE *fp = fopen_safe(\""/tmp/smtp-alert.log\"", \""a\"");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];""}<_**next**_>{""sha"": ""4cfb16366fa244d607b85bfe2ecf613495c74eb3"", ""filename"": ""keepalived/vrrp/vrrp_dbus.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_dbus.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -594,7 +594,7 @@ read_file(gchar* filepath)\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \""rb\"");\n+\tf = fopen(filepath, \""r\"");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);""}<_**next**_>{""sha"": ""1a6ea873a250f9958d52e649399ef1398f7a2087"", ""filename"": ""keepalived/vrrp/vrrp_json.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_json.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""vrrp_iprule.h\""\n #include \""logger.h\""\n #include \""timer.h\""\n+#include \""utils.h\""\n \n static inline double\n timeval_to_double(const timeval_t *t)\n@@ -55,7 +56,7 @@ vrrp_print_json(void)\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\""/tmp/keepalived.json\"",\""w\"");\n+\tfile = fopen_safe(\""/tmp/keepalived.json\"", \""w\"");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open /tmp/keepalived.json (%d: %s)\"",\n \t\t\terrno, strerror(errno));""}<_**next**_>{""sha"": ""84704b415db95999319d3ecfe3ef8c650f20e083"", ""filename"": ""keepalived/vrrp/vrrp_parser.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \""w\""))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \""w\""))) {\n \t\t\tfprintf(tf, \""%d\\n\"", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}""}<_**next**_>{""sha"": ""aeb74bcbf5dca2f2f71faa32cf1ca91ffebed75b"", ""filename"": ""keepalived/vrrp/vrrp_print.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 10, ""changes"": 17, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_print.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -32,14 +32,15 @@\n #include \""vrrp.h\""\n #include \""vrrp_data.h\""\n #include \""vrrp_print.h\""\n+#include \""utils.h\""\n \n static const char *dump_file = \""/tmp/keepalived.data\"";\n static const char *stats_file = \""/tmp/keepalived.stats\"";\n \n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \""w\"");\n+\tFILE *file = fopen_safe(dump_file, \""w\"");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n@@ -55,28 +56,24 @@ vrrp_print_data(void)\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \""w\"");\n+\tFILE *file = fopen_safe(stats_file, \""w\"");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n \t\t\tstats_file, errno, strerror(errno));\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \""VRRP Instance: %s\\n\"", vrrp->iname);\n \t\tfprintf(file, \""  Advertisements:\\n\"");\n \t\tfprintf(file, \""    Received: %\"" PRIu64 \""\\n\"", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \""    Sent: %d\\n\"", vrrp->stats->advert_sent);\n \t\tfprintf(file, \""  Became master: %d\\n\"", vrrp->stats->become_master);\n-\t\tfprintf(file, \""  Released master: %d\\n\"",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \""  Released master: %d\\n\"", vrrp->stats->release_master);\n \t\tfprintf(file, \""  Packet Errors:\\n\"");\n \t\tfprintf(file, \""    Length: %\"" PRIu64 \""\\n\"", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \""    TTL: %\"" PRIu64 \""\\n\"", vrrp->stats->ip_ttl_err);""}<_**next**_>{""sha"": ""59217c6303694449716ba3308169b6a09539e821"", ""filename"": ""keepalived/vrrp/vrrp_scheduler.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_scheduler.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1134,7 +1134,7 @@ dump_threads(void)\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \""a\"");\n+\tfp = fopen_safe(file_name, \""a\"");\n \tFREE(file_name);\n \n \tset_time_now();""}<_**next**_>{""sha"": ""20153c800f219bb6f9c512f6970caf537e1ce5f0"", ""filename"": ""lib/logger.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/logger.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \""a\"");\n+\tlog_file = fopen_safe(file_name, \""a\"");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));""}<_**next**_>{""sha"": ""3001f3ebdcd9a411edb91ee8352f4f910b54e900"", ""filename"": ""lib/memory.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/memory.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)\n \t}\n \n \tsnprintf(log_name, log_name_len, \""/tmp/%s_mem.%d.log\"", prog_name, getpid());\n-\tlog_op = fopen(log_name, \""a\"");\n+\tlog_op = fopen_safe(log_name, \""a\"");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \""Unable to open %s for appending\"", log_name);\n \t\tlog_op = stderr;""}<_**next**_>{""sha"": ""3a8c0662a4e7a61bcbdf175f0f35c704d8e7e446"", ""filename"": ""lib/notify.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/notify.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \""Unable to open %snotify fifo %s - errno %d\"", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);""}<_**next**_>{""sha"": ""1d53595c0e876c459f5677f01ffeca9c99403e84"", ""filename"": ""lib/parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \""/tmp/keywords.%d\"", getpid());\n-\t\tfp = fopen(file_name, \""w\"");\n+\t\tfp = fopen_safe(file_name, \""w\"");\n \t\tif (!fp)\n \t\t\treturn;\n \t}""}<_**next**_>{""sha"": ""4aac594454bb3fddec3b72bbe4b8b099638ef5c8"", ""filename"": ""lib/utils.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 1, ""changes"": 43, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -123,7 +123,7 @@ write_stacktrace(const char *file_name, const char *str)\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \""%s\\n\"", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n@@ -788,6 +788,47 @@ string_equal(const char *str1, const char *str2)\n \treturn !strcmp(str1, str2);\n }\n \n+/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n+ * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\n+FILE *fopen_safe(const char *path, const char *mode)\n+{\n+\tint fd;\n+\tFILE *file;\n+\tint flags = O_NOFOLLOW | O_CREAT;\n+\n+\tif (mode[0] == 'r')\n+\t\treturn fopen(path, mode);\n+\n+\tif (mode[0] != 'a' && mode[0] != 'w')\n+\t\treturn NULL;\n+\n+\tif (mode[1] &&\n+\t    (mode[1] != '+' || mode[2]))\n+\t\treturn NULL;\n+\n+\tif (mode[0] == 'w')\n+\t\tflags |= O_TRUNC;\n+\telse\n+\t\tflags |= O_APPEND;\n+\n+\tif (mode[1])\n+\t\tflags |= O_RDWR;\n+\telse\n+\t\tflags |= O_WRONLY;\n+\n+\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n+\tif (fd == -1)\n+\t\treturn NULL;\n+\n+\tfile = fdopen (fd, \""w\"");\n+\tif (!file) {\n+\t\tclose(fd);\n+\t\treturn NULL;\n+\t}\n+\n+\treturn file;\n+}\n+\n void\n set_std_fd(bool force)\n {""}<_**next**_>{""sha"": ""19682d02546d7329c410a77ad1c9569a144b5434"", ""filename"": ""lib/utils.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.h?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -182,6 +182,7 @@ extern int inet_inaddrcmp(int, const void *, const void *);\n extern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\n extern char *get_local_name(void);\n extern bool string_equal(const char *, const char *);\n+extern FILE *fopen_safe(const char *, const char *);\n extern void set_std_fd(bool);\n extern void close_std_fd(void);\n #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_""}","dump_keywords(vector_t *keydump, int level, FILE *fp)
 {
 	unsigned int i;
 	keyword_t *keyword_vec;
	char file_name[22];
 
 	if (!level) {
 		snprintf(file_name, sizeof(file_name), ""/tmp/keywords.%d"", getpid());
		fp = fopen_safe(file_name, ""w"");
 		if (!fp)
 			return;
 	}

	for (i = 0; i < vector_size(keydump); i++) {
		keyword_vec = vector_slot(keydump, i);
		fprintf(fp, ""%*sKeyword : %s (%s)\n"", level * 2, """", keyword_vec->string, keyword_vec->active ? ""active"": ""disabled"");
		if (keyword_vec->sub)
			dump_keywords(keyword_vec->sub, level + 1, fp);
	}

	if (!level)
		fclose(fp);
}
","dump_keywords(vector_t *keydump, int level, FILE *fp)
 {
 	unsigned int i;
 	keyword_t *keyword_vec;
	char file_name[21];
 
 	if (!level) {
 		snprintf(file_name, sizeof(file_name), ""/tmp/keywords.%d"", getpid());
		fp = fopen(file_name, ""w"");
 		if (!fp)
 			return;
 	}

	for (i = 0; i < vector_size(keydump); i++) {
		keyword_vec = vector_slot(keydump, i);
		fprintf(fp, ""%*sKeyword : %s (%s)\n"", level * 2, """", keyword_vec->string, keyword_vec->active ? ""active"": ""disabled"");
		if (keyword_vec->sub)
			dump_keywords(keyword_vec->sub, level + 1, fp);
	}

	if (!level)
		fclose(fp);
}
",C,"	char file_name[22];
		fp = fopen_safe(file_name, ""w"");
","	char file_name[21];
		fp = fopen(file_name, ""w"");
",,"@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)
 {
 	unsigned int i;
 	keyword_t *keyword_vec;
-	char file_name[21];
+	char file_name[22];
 
 	if (!level) {
 		snprintf(file_name, sizeof(file_name), ""/tmp/keywords.%d"", getpid());
-		fp = fopen(file_name, ""w"");
+		fp = fopen_safe(file_name, ""w"");
 		if (!fp)
 			return;
 	}",keepalived,04f2d32871bb3b11d7dc024039952f2fe2750306,5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,1,"dump_keywords(vector_t *keydump, int level, FILE *fp)
 {
 	unsigned int i;
 	keyword_t *keyword_vec;
//flaw_line_below:
	char file_name[21];
//fix_flaw_line_below:
//	char file_name[22];
 
 	if (!level) {
 		snprintf(file_name, sizeof(file_name), ""/tmp/keywords.%d"", getpid());
//flaw_line_below:
		fp = fopen(file_name, ""w"");
//fix_flaw_line_below:
//		fp = fopen_safe(file_name, ""w"");
 		if (!fp)
 			return;
 	}

	for (i = 0; i < vector_size(keydump); i++) {
		keyword_vec = vector_slot(keydump, i);
		fprintf(fp, ""%*sKeyword : %s (%s)\n"", level * 2, """", keyword_vec->string, keyword_vec->active ? ""active"": ""disabled"");
		if (keyword_vec->sub)
			dump_keywords(keyword_vec->sub, level + 1, fp);
	}

	if (!level)
		fclose(fp);
}
"
4781,182517,,Local,Not required,Partial,CVE-2018-6198,https://www.cvedetails.com/cve/CVE-2018-6198/,CWE-59,Medium,,Partial,,2018-01-24,3.3,"w3m through 0.5.3 does not properly handle temporary files when the ~/.w3m directory is unwritable, which allows a local attacker to craft a symlink attack to overwrite arbitrary files.",2019-10-02,,7,https://github.com/tats/w3m/commit/18dcbadf2771cdb0c18509b14e4e73505b242753,18dcbadf2771cdb0c18509b14e4e73505b242753,Make temporary directory safely when ~/.w3m is unwritable,0,main.c,"{""sha"": ""4d9c1197e22008a8396576bf5b0e8d4d4f4081e0"", ""filename"": ""config.h.dist"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/tats/w3m/blob/18dcbadf2771cdb0c18509b14e4e73505b242753/config.h.dist"", ""raw_url"": ""https://github.com/tats/w3m/raw/18dcbadf2771cdb0c18509b14e4e73505b242753/config.h.dist"", ""contents_url"": ""https://api.github.com/repos/tats/w3m/contents/config.h.dist?ref=18dcbadf2771cdb0c18509b14e4e73505b242753"", ""patch"": ""@@ -210,6 +210,7 @@ typedef long clen_t;\n #define HAVE_SRANDOM\n #undef HAVE_GETPASSPHRASE\n #define HAVE_CHDIR\n+#define HAVE_MKDTEMP\n \n \n #define SETJMP(env) sigsetjmp(env,1)""}<_**next**_>{""sha"": ""6ab3008ed78fe3167bb34f075f70ec6c2a8a5c96"", ""filename"": ""config.h.in"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/tats/w3m/blob/18dcbadf2771cdb0c18509b14e4e73505b242753/config.h.in"", ""raw_url"": ""https://github.com/tats/w3m/raw/18dcbadf2771cdb0c18509b14e4e73505b242753/config.h.in"", ""contents_url"": ""https://api.github.com/repos/tats/w3m/contents/config.h.in?ref=18dcbadf2771cdb0c18509b14e4e73505b242753"", ""patch"": ""@@ -143,6 +143,7 @@ typedef long clen_t;\n #undef HAVE_SRANDOM\n #undef HAVE_GETPASSPHRASE\n #undef HAVE_CHDIR\n+#undef HAVE_MKDTEMP\n #undef HAVE_SETPGRP\n #undef HAVE_SETLOCALE\n #undef HAVE_LANGINFO_CODESET""}<_**next**_>{""sha"": ""8699b436c8cb1a7deb577569fcc50cb02281357b"", ""filename"": ""configure"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/tats/w3m/blob/18dcbadf2771cdb0c18509b14e4e73505b242753/configure"", ""raw_url"": ""https://github.com/tats/w3m/raw/18dcbadf2771cdb0c18509b14e4e73505b242753/configure"", ""contents_url"": ""https://api.github.com/repos/tats/w3m/contents/configure?ref=18dcbadf2771cdb0c18509b14e4e73505b242753"", ""patch"": ""@@ -8767,7 +8767,7 @@ _ACEOF\n \n \n \n-for ac_func in strcasecmp strcasestr strchr memcpy strerror bcopy setpgrp chdir getcwd getwd readlink setenv putenv strtoll stroq atoll atoq symlink readlink lstat srand48 srandom getpassphrase waitpid setlocale\n+for ac_func in strcasecmp strcasestr strchr memcpy strerror bcopy setpgrp chdir mkdtemp getcwd getwd readlink setenv putenv strtoll stroq atoll atoq symlink readlink lstat srand48 srandom getpassphrase waitpid setlocale\n do :\n   as_ac_var=`$as_echo \""ac_cv_func_$ac_func\"" | $as_tr_sh`\n ac_fn_c_check_func \""$LINENO\"" \""$ac_func\"" \""$as_ac_var\""""}<_**next**_>{""sha"": ""ebb3282d007b6dfa11fc0cf1d425898f11792cb4"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/tats/w3m/blob/18dcbadf2771cdb0c18509b14e4e73505b242753/configure.ac"", ""raw_url"": ""https://github.com/tats/w3m/raw/18dcbadf2771cdb0c18509b14e4e73505b242753/configure.ac"", ""contents_url"": ""https://api.github.com/repos/tats/w3m/contents/configure.ac?ref=18dcbadf2771cdb0c18509b14e4e73505b242753"", ""patch"": ""@@ -150,7 +150,7 @@ dnl AC_FUNC_MEMCMP\n dnl AC_FUNC_MMAP\n dnl AC_FUNC_SETVBUF_REVERSED\n dnl AC_FUNC_VPRINTF\n-AC_CHECK_FUNCS(strcasecmp strcasestr strchr memcpy strerror bcopy setpgrp chdir getcwd getwd readlink setenv putenv strtoll stroq atoll atoq symlink readlink lstat srand48 srandom getpassphrase waitpid setlocale)\n+AC_CHECK_FUNCS(strcasecmp strcasestr strchr memcpy strerror bcopy setpgrp chdir mkdtemp getcwd getwd readlink setenv putenv strtoll stroq atoll atoq symlink readlink lstat srand48 srandom getpassphrase waitpid setlocale)\n AC_FUNC_STRFTIME\n AC_FUNC_WAIT3\n AC_FUNC_SETPGRP""}<_**next**_>{""sha"": ""43e181c87bd36d37a88fd71609bc446c87657039"", ""filename"": ""main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/tats/w3m/blob/18dcbadf2771cdb0c18509b14e4e73505b242753/main.c"", ""raw_url"": ""https://github.com/tats/w3m/raw/18dcbadf2771cdb0c18509b14e4e73505b242753/main.c"", ""contents_url"": ""https://api.github.com/repos/tats/w3m/contents/main.c?ref=18dcbadf2771cdb0c18509b14e4e73505b242753"", ""patch"": ""@@ -5971,6 +5971,13 @@ w3m_exit(int i)\n #endif\n #ifdef __MINGW32_VERSION\n     WSACleanup();\n+#endif\n+#ifdef HAVE_MKDTEMP\n+    if (no_rc_dir && tmp_dir != rc_dir)\n+\tif (rmdir(tmp_dir) != 0) {\n+\t    fprintf(stderr, \""Can't remove temporary directory (%s)!\\n\"", tmp_dir);\n+\t    exit(1);\n+\t}\n #endif\n     exit(i);\n }""}<_**next**_>{""sha"": ""3fd84efdaddc1e8f80b3f8439d2e925bbecde523"", ""filename"": ""rc.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/tats/w3m/blob/18dcbadf2771cdb0c18509b14e4e73505b242753/rc.c"", ""raw_url"": ""https://github.com/tats/w3m/raw/18dcbadf2771cdb0c18509b14e4e73505b242753/rc.c"", ""contents_url"": ""https://api.github.com/repos/tats/w3m/contents/rc.c?ref=18dcbadf2771cdb0c18509b14e4e73505b242753"", ""patch"": ""@@ -1330,6 +1330,11 @@ init_rc(void)\n \t((tmp_dir = getenv(\""TMP\"")) == NULL || *tmp_dir == '\\0') &&\n \t((tmp_dir = getenv(\""TEMP\"")) == NULL || *tmp_dir == '\\0'))\n \ttmp_dir = \""/tmp\"";\n+#ifdef HAVE_MKDTEMP\n+    tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, \""/w3m-XXXXXX\"", NULL)->ptr);\n+    if (tmp_dir == NULL)\n+\ttmp_dir = rc_dir;\n+#endif\n     create_option_search_table();\n     goto open_rc;\n }""}","w3m_exit(int i)
{
#ifdef USE_MIGEMO
    init_migemo();		/* close pipe to migemo */
#endif
    stopDownload();
    deleteFiles();
#ifdef USE_SSL
    free_ssl_ctx();
#endif
    disconnectFTP();
#ifdef USE_NNTP
    disconnectNews();
 #endif
 #ifdef __MINGW32_VERSION
     WSACleanup();
#endif
#ifdef HAVE_MKDTEMP
    if (no_rc_dir && tmp_dir != rc_dir)
	if (rmdir(tmp_dir) != 0) {
	    fprintf(stderr, ""Can't remove temporary directory (%s)!\n"", tmp_dir);
	    exit(1);
	}
 #endif
     exit(i);
 }
","w3m_exit(int i)
{
#ifdef USE_MIGEMO
    init_migemo();		/* close pipe to migemo */
#endif
    stopDownload();
    deleteFiles();
#ifdef USE_SSL
    free_ssl_ctx();
#endif
    disconnectFTP();
#ifdef USE_NNTP
    disconnectNews();
 #endif
 #ifdef __MINGW32_VERSION
     WSACleanup();
 #endif
     exit(i);
 }
",C,"#endif
#ifdef HAVE_MKDTEMP
    if (no_rc_dir && tmp_dir != rc_dir)
	if (rmdir(tmp_dir) != 0) {
	    fprintf(stderr, ""Can't remove temporary directory (%s)!\n"", tmp_dir);
	    exit(1);
	}
",,,"@@ -5971,6 +5971,13 @@ w3m_exit(int i)
 #endif
 #ifdef __MINGW32_VERSION
     WSACleanup();
+#endif
+#ifdef HAVE_MKDTEMP
+    if (no_rc_dir && tmp_dir != rc_dir)
+	if (rmdir(tmp_dir) != 0) {
+	    fprintf(stderr, ""Can't remove temporary directory (%s)!\n"", tmp_dir);
+	    exit(1);
+	}
 #endif
     exit(i);
 }",w3m,18dcbadf2771cdb0c18509b14e4e73505b242753,b592dac63b39fba505525b0cee1d914182e825ff,1,"w3m_exit(int i)
{
#ifdef USE_MIGEMO
    init_migemo();		/* close pipe to migemo */
#endif
    stopDownload();
    deleteFiles();
#ifdef USE_SSL
    free_ssl_ctx();
#endif
    disconnectFTP();
#ifdef USE_NNTP
    disconnectNews();
 #endif
 #ifdef __MINGW32_VERSION
     WSACleanup();
//fix_flaw_line_below:
//#endif
//fix_flaw_line_below:
//#ifdef HAVE_MKDTEMP
//fix_flaw_line_below:
//    if (no_rc_dir && tmp_dir != rc_dir)
//fix_flaw_line_below:
//	if (rmdir(tmp_dir) != 0) {
//fix_flaw_line_below:
//	    fprintf(stderr, ""Can't remove temporary directory (%s)!\n"", tmp_dir);
//fix_flaw_line_below:
//	    exit(1);
//fix_flaw_line_below:
//	}
 #endif
     exit(i);
 }
"
4782,182518,,Local,Not required,Partial,CVE-2018-6198,https://www.cvedetails.com/cve/CVE-2018-6198/,CWE-59,Medium,,Partial,,2018-01-24,3.3,"w3m through 0.5.3 does not properly handle temporary files when the ~/.w3m directory is unwritable, which allows a local attacker to craft a symlink attack to overwrite arbitrary files.",2019-10-02,,5,https://github.com/tats/w3m/commit/18dcbadf2771cdb0c18509b14e4e73505b242753,18dcbadf2771cdb0c18509b14e4e73505b242753,Make temporary directory safely when ~/.w3m is unwritable,0,rc.c,"{""sha"": ""4d9c1197e22008a8396576bf5b0e8d4d4f4081e0"", ""filename"": ""config.h.dist"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/tats/w3m/blob/18dcbadf2771cdb0c18509b14e4e73505b242753/config.h.dist"", ""raw_url"": ""https://github.com/tats/w3m/raw/18dcbadf2771cdb0c18509b14e4e73505b242753/config.h.dist"", ""contents_url"": ""https://api.github.com/repos/tats/w3m/contents/config.h.dist?ref=18dcbadf2771cdb0c18509b14e4e73505b242753"", ""patch"": ""@@ -210,6 +210,7 @@ typedef long clen_t;\n #define HAVE_SRANDOM\n #undef HAVE_GETPASSPHRASE\n #define HAVE_CHDIR\n+#define HAVE_MKDTEMP\n \n \n #define SETJMP(env) sigsetjmp(env,1)""}<_**next**_>{""sha"": ""6ab3008ed78fe3167bb34f075f70ec6c2a8a5c96"", ""filename"": ""config.h.in"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/tats/w3m/blob/18dcbadf2771cdb0c18509b14e4e73505b242753/config.h.in"", ""raw_url"": ""https://github.com/tats/w3m/raw/18dcbadf2771cdb0c18509b14e4e73505b242753/config.h.in"", ""contents_url"": ""https://api.github.com/repos/tats/w3m/contents/config.h.in?ref=18dcbadf2771cdb0c18509b14e4e73505b242753"", ""patch"": ""@@ -143,6 +143,7 @@ typedef long clen_t;\n #undef HAVE_SRANDOM\n #undef HAVE_GETPASSPHRASE\n #undef HAVE_CHDIR\n+#undef HAVE_MKDTEMP\n #undef HAVE_SETPGRP\n #undef HAVE_SETLOCALE\n #undef HAVE_LANGINFO_CODESET""}<_**next**_>{""sha"": ""8699b436c8cb1a7deb577569fcc50cb02281357b"", ""filename"": ""configure"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/tats/w3m/blob/18dcbadf2771cdb0c18509b14e4e73505b242753/configure"", ""raw_url"": ""https://github.com/tats/w3m/raw/18dcbadf2771cdb0c18509b14e4e73505b242753/configure"", ""contents_url"": ""https://api.github.com/repos/tats/w3m/contents/configure?ref=18dcbadf2771cdb0c18509b14e4e73505b242753"", ""patch"": ""@@ -8767,7 +8767,7 @@ _ACEOF\n \n \n \n-for ac_func in strcasecmp strcasestr strchr memcpy strerror bcopy setpgrp chdir getcwd getwd readlink setenv putenv strtoll stroq atoll atoq symlink readlink lstat srand48 srandom getpassphrase waitpid setlocale\n+for ac_func in strcasecmp strcasestr strchr memcpy strerror bcopy setpgrp chdir mkdtemp getcwd getwd readlink setenv putenv strtoll stroq atoll atoq symlink readlink lstat srand48 srandom getpassphrase waitpid setlocale\n do :\n   as_ac_var=`$as_echo \""ac_cv_func_$ac_func\"" | $as_tr_sh`\n ac_fn_c_check_func \""$LINENO\"" \""$ac_func\"" \""$as_ac_var\""""}<_**next**_>{""sha"": ""ebb3282d007b6dfa11fc0cf1d425898f11792cb4"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/tats/w3m/blob/18dcbadf2771cdb0c18509b14e4e73505b242753/configure.ac"", ""raw_url"": ""https://github.com/tats/w3m/raw/18dcbadf2771cdb0c18509b14e4e73505b242753/configure.ac"", ""contents_url"": ""https://api.github.com/repos/tats/w3m/contents/configure.ac?ref=18dcbadf2771cdb0c18509b14e4e73505b242753"", ""patch"": ""@@ -150,7 +150,7 @@ dnl AC_FUNC_MEMCMP\n dnl AC_FUNC_MMAP\n dnl AC_FUNC_SETVBUF_REVERSED\n dnl AC_FUNC_VPRINTF\n-AC_CHECK_FUNCS(strcasecmp strcasestr strchr memcpy strerror bcopy setpgrp chdir getcwd getwd readlink setenv putenv strtoll stroq atoll atoq symlink readlink lstat srand48 srandom getpassphrase waitpid setlocale)\n+AC_CHECK_FUNCS(strcasecmp strcasestr strchr memcpy strerror bcopy setpgrp chdir mkdtemp getcwd getwd readlink setenv putenv strtoll stroq atoll atoq symlink readlink lstat srand48 srandom getpassphrase waitpid setlocale)\n AC_FUNC_STRFTIME\n AC_FUNC_WAIT3\n AC_FUNC_SETPGRP""}<_**next**_>{""sha"": ""43e181c87bd36d37a88fd71609bc446c87657039"", ""filename"": ""main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/tats/w3m/blob/18dcbadf2771cdb0c18509b14e4e73505b242753/main.c"", ""raw_url"": ""https://github.com/tats/w3m/raw/18dcbadf2771cdb0c18509b14e4e73505b242753/main.c"", ""contents_url"": ""https://api.github.com/repos/tats/w3m/contents/main.c?ref=18dcbadf2771cdb0c18509b14e4e73505b242753"", ""patch"": ""@@ -5971,6 +5971,13 @@ w3m_exit(int i)\n #endif\n #ifdef __MINGW32_VERSION\n     WSACleanup();\n+#endif\n+#ifdef HAVE_MKDTEMP\n+    if (no_rc_dir && tmp_dir != rc_dir)\n+\tif (rmdir(tmp_dir) != 0) {\n+\t    fprintf(stderr, \""Can't remove temporary directory (%s)!\\n\"", tmp_dir);\n+\t    exit(1);\n+\t}\n #endif\n     exit(i);\n }""}<_**next**_>{""sha"": ""3fd84efdaddc1e8f80b3f8439d2e925bbecde523"", ""filename"": ""rc.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/tats/w3m/blob/18dcbadf2771cdb0c18509b14e4e73505b242753/rc.c"", ""raw_url"": ""https://github.com/tats/w3m/raw/18dcbadf2771cdb0c18509b14e4e73505b242753/rc.c"", ""contents_url"": ""https://api.github.com/repos/tats/w3m/contents/rc.c?ref=18dcbadf2771cdb0c18509b14e4e73505b242753"", ""patch"": ""@@ -1330,6 +1330,11 @@ init_rc(void)\n \t((tmp_dir = getenv(\""TMP\"")) == NULL || *tmp_dir == '\\0') &&\n \t((tmp_dir = getenv(\""TEMP\"")) == NULL || *tmp_dir == '\\0'))\n \ttmp_dir = \""/tmp\"";\n+#ifdef HAVE_MKDTEMP\n+    tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, \""/w3m-XXXXXX\"", NULL)->ptr);\n+    if (tmp_dir == NULL)\n+\ttmp_dir = rc_dir;\n+#endif\n     create_option_search_table();\n     goto open_rc;\n }""}","init_rc(void)
{
    int i;
    struct stat st;
    FILE *f;

    if (rc_dir != NULL)
	goto open_rc;

    rc_dir = expandPath(RC_DIR);
    i = strlen(rc_dir);
    if (i > 1 && rc_dir[i - 1] == '/')
	rc_dir[i - 1] = '\0';

#ifdef USE_M17N
    display_charset_str = wc_get_ces_list();
    document_charset_str = display_charset_str;
    system_charset_str = display_charset_str;
#endif

    if (stat(rc_dir, &st) < 0) {
	if (errno == ENOENT) {	/* no directory */
	    if (do_mkdir(rc_dir, 0700) < 0) {
		/* fprintf(stderr, ""Can't create config directory (%s)!\n"", rc_dir); */
		goto rc_dir_err;
	    }
	    else {
		stat(rc_dir, &st);
	    }
	}
	else {
	    /* fprintf(stderr, ""Can't open config directory (%s)!\n"", rc_dir); */
	    goto rc_dir_err;
	}
    }
    if (!S_ISDIR(st.st_mode)) {
	/* not a directory */
	/* fprintf(stderr, ""%s is not a directory!\n"", rc_dir); */
	goto rc_dir_err;
    }
    if (!(st.st_mode & S_IWUSR)) {
	/* fprintf(stderr, ""%s is not writable!\n"", rc_dir); */
	goto rc_dir_err;
    }
    no_rc_dir = FALSE;
    tmp_dir = rc_dir;

    if (config_file == NULL)
	config_file = rcFile(CONFIG_FILE);

    create_option_search_table();

  open_rc:
    /* open config file */
    if ((f = fopen(etcFile(W3MCONFIG), ""rt"")) != NULL) {
	interpret_rc(f);
	fclose(f);
    }
    if ((f = fopen(confFile(CONFIG_FILE), ""rt"")) != NULL) {
	interpret_rc(f);
	fclose(f);
    }
    if (config_file && (f = fopen(config_file, ""rt"")) != NULL) {
	interpret_rc(f);
	fclose(f);
    }
    return;

  rc_dir_err:
    no_rc_dir = TRUE;
    if (((tmp_dir = getenv(""TMPDIR"")) == NULL || *tmp_dir == '\0') &&
 	((tmp_dir = getenv(""TMP"")) == NULL || *tmp_dir == '\0') &&
 	((tmp_dir = getenv(""TEMP"")) == NULL || *tmp_dir == '\0'))
 	tmp_dir = ""/tmp"";
#ifdef HAVE_MKDTEMP
    tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, ""/w3m-XXXXXX"", NULL)->ptr);
    if (tmp_dir == NULL)
	tmp_dir = rc_dir;
#endif
     create_option_search_table();
     goto open_rc;
 }
","init_rc(void)
{
    int i;
    struct stat st;
    FILE *f;

    if (rc_dir != NULL)
	goto open_rc;

    rc_dir = expandPath(RC_DIR);
    i = strlen(rc_dir);
    if (i > 1 && rc_dir[i - 1] == '/')
	rc_dir[i - 1] = '\0';

#ifdef USE_M17N
    display_charset_str = wc_get_ces_list();
    document_charset_str = display_charset_str;
    system_charset_str = display_charset_str;
#endif

    if (stat(rc_dir, &st) < 0) {
	if (errno == ENOENT) {	/* no directory */
	    if (do_mkdir(rc_dir, 0700) < 0) {
		/* fprintf(stderr, ""Can't create config directory (%s)!\n"", rc_dir); */
		goto rc_dir_err;
	    }
	    else {
		stat(rc_dir, &st);
	    }
	}
	else {
	    /* fprintf(stderr, ""Can't open config directory (%s)!\n"", rc_dir); */
	    goto rc_dir_err;
	}
    }
    if (!S_ISDIR(st.st_mode)) {
	/* not a directory */
	/* fprintf(stderr, ""%s is not a directory!\n"", rc_dir); */
	goto rc_dir_err;
    }
    if (!(st.st_mode & S_IWUSR)) {
	/* fprintf(stderr, ""%s is not writable!\n"", rc_dir); */
	goto rc_dir_err;
    }
    no_rc_dir = FALSE;
    tmp_dir = rc_dir;

    if (config_file == NULL)
	config_file = rcFile(CONFIG_FILE);

    create_option_search_table();

  open_rc:
    /* open config file */
    if ((f = fopen(etcFile(W3MCONFIG), ""rt"")) != NULL) {
	interpret_rc(f);
	fclose(f);
    }
    if ((f = fopen(confFile(CONFIG_FILE), ""rt"")) != NULL) {
	interpret_rc(f);
	fclose(f);
    }
    if (config_file && (f = fopen(config_file, ""rt"")) != NULL) {
	interpret_rc(f);
	fclose(f);
    }
    return;

  rc_dir_err:
    no_rc_dir = TRUE;
    if (((tmp_dir = getenv(""TMPDIR"")) == NULL || *tmp_dir == '\0') &&
 	((tmp_dir = getenv(""TMP"")) == NULL || *tmp_dir == '\0') &&
 	((tmp_dir = getenv(""TEMP"")) == NULL || *tmp_dir == '\0'))
 	tmp_dir = ""/tmp"";
     create_option_search_table();
     goto open_rc;
 }
",C,"#ifdef HAVE_MKDTEMP
    tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, ""/w3m-XXXXXX"", NULL)->ptr);
    if (tmp_dir == NULL)
	tmp_dir = rc_dir;
#endif
",,,"@@ -1330,6 +1330,11 @@ init_rc(void)
 	((tmp_dir = getenv(""TMP"")) == NULL || *tmp_dir == '\0') &&
 	((tmp_dir = getenv(""TEMP"")) == NULL || *tmp_dir == '\0'))
 	tmp_dir = ""/tmp"";
+#ifdef HAVE_MKDTEMP
+    tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, ""/w3m-XXXXXX"", NULL)->ptr);
+    if (tmp_dir == NULL)
+	tmp_dir = rc_dir;
+#endif
     create_option_search_table();
     goto open_rc;
 }",w3m,18dcbadf2771cdb0c18509b14e4e73505b242753,b592dac63b39fba505525b0cee1d914182e825ff,1,"init_rc(void)
{
    int i;
    struct stat st;
    FILE *f;

    if (rc_dir != NULL)
	goto open_rc;

    rc_dir = expandPath(RC_DIR);
    i = strlen(rc_dir);
    if (i > 1 && rc_dir[i - 1] == '/')
	rc_dir[i - 1] = '\0';

#ifdef USE_M17N
    display_charset_str = wc_get_ces_list();
    document_charset_str = display_charset_str;
    system_charset_str = display_charset_str;
#endif

    if (stat(rc_dir, &st) < 0) {
	if (errno == ENOENT) {	/* no directory */
	    if (do_mkdir(rc_dir, 0700) < 0) {
		/* fprintf(stderr, ""Can't create config directory (%s)!\n"", rc_dir); */
		goto rc_dir_err;
	    }
	    else {
		stat(rc_dir, &st);
	    }
	}
	else {
	    /* fprintf(stderr, ""Can't open config directory (%s)!\n"", rc_dir); */
	    goto rc_dir_err;
	}
    }
    if (!S_ISDIR(st.st_mode)) {
	/* not a directory */
	/* fprintf(stderr, ""%s is not a directory!\n"", rc_dir); */
	goto rc_dir_err;
    }
    if (!(st.st_mode & S_IWUSR)) {
	/* fprintf(stderr, ""%s is not writable!\n"", rc_dir); */
	goto rc_dir_err;
    }
    no_rc_dir = FALSE;
    tmp_dir = rc_dir;

    if (config_file == NULL)
	config_file = rcFile(CONFIG_FILE);

    create_option_search_table();

  open_rc:
    /* open config file */
    if ((f = fopen(etcFile(W3MCONFIG), ""rt"")) != NULL) {
	interpret_rc(f);
	fclose(f);
    }
    if ((f = fopen(confFile(CONFIG_FILE), ""rt"")) != NULL) {
	interpret_rc(f);
	fclose(f);
    }
    if (config_file && (f = fopen(config_file, ""rt"")) != NULL) {
	interpret_rc(f);
	fclose(f);
    }
    return;

  rc_dir_err:
    no_rc_dir = TRUE;
    if (((tmp_dir = getenv(""TMPDIR"")) == NULL || *tmp_dir == '\0') &&
 	((tmp_dir = getenv(""TMP"")) == NULL || *tmp_dir == '\0') &&
 	((tmp_dir = getenv(""TEMP"")) == NULL || *tmp_dir == '\0'))
 	tmp_dir = ""/tmp"";
//fix_flaw_line_below:
//#ifdef HAVE_MKDTEMP
//fix_flaw_line_below:
//    tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, ""/w3m-XXXXXX"", NULL)->ptr);
//fix_flaw_line_below:
//    if (tmp_dir == NULL)
//fix_flaw_line_below:
//	tmp_dir = rc_dir;
//fix_flaw_line_below:
//#endif
     create_option_search_table();
     goto open_rc;
 }
"
4870,182606,,Local,Not required,Complete,CVE-2017-7500,https://www.cvedetails.com/cve/CVE-2017-7500/,CWE-59,Low,Complete,Complete,,2018-08-13,7.2,"It was found that rpm did not properly handle RPM installations when a destination path was a symbolic link to a directory, possibly changing ownership and permissions of an arbitrary directory, and RPM files being placed in an arbitrary destination. An attacker, with write access to a directory in which a subdirectory will be installed, could redirect that directory to an arbitrary location and gain root privilege.",2019-10-09,+Priv ,12,https://github.com/rpm-software-management/rpm/commit/c815822c8bdb138066ff58c624ae83e3a12ebfa9,c815822c8bdb138066ff58c624ae83e3a12ebfa9,"Make verification match the new restricted directory symlink behavior

Only follow directory symlinks owned by target directory owner or root
during verification to match the behavior of fsmVerify() in the new
CVE-2017-7500 world order.

The code is klunkier than it should and the logic should use common code
with fsmVerify() instead of duplicating it here, but that needs more
changes than is comfortable to backport so starting with this.

Also worth noting that the previous ""follow the link"" logic from
commit 3ccd774255b8215733e0bdfdf5a683da9dd10923 was not quite right,
it'd fail with RPMVERIFY_LSTATFAIL on a broken symlink when it should've
ran verification on the symlink itself. This behavior is fixed here too.

Finally, once again fakechroot gets in the way and forces the related
verify testcase to be changed to be able to create a valid link. Reuse
the replacement testcase for the purpose and add another case for
verifying an invalid link.",3,lib/verify.c,"{""sha"": ""62eec08617fb02a6d8e4fa89e9236e844a277cc7"", ""filename"": ""lib/verify.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 3, ""changes"": 15, ""blob_url"": ""https://github.com/rpm-software-management/rpm/blob/c815822c8bdb138066ff58c624ae83e3a12ebfa9/lib/verify.c"", ""raw_url"": ""https://github.com/rpm-software-management/rpm/raw/c815822c8bdb138066ff58c624ae83e3a12ebfa9/lib/verify.c"", ""contents_url"": ""https://api.github.com/repos/rpm-software-management/rpm/contents/lib/verify.c?ref=c815822c8bdb138066ff58c624ae83e3a12ebfa9"", ""patch"": ""@@ -94,9 +94,18 @@ rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)\n     }\n \n     /* If we expected a directory but got a symlink to one, follow the link */\n-    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {\n-\tvfy |= RPMVERIFY_LSTATFAIL;\n-\tgoto exit;\n+    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {\n+\tstruct stat dsb;\n+\t/* ...if it actually points to a directory  */\n+\tif (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {\n+\t    uid_t fuid;\n+\t    /* ...and is by a legit user, to match fsmVerify() behavior */\n+\t    if (sb.st_uid == 0 ||\n+\t\t\t(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&\n+\t\t\t sb.st_uid == fuid)) {\n+\t\tsb = dsb; /* struct assignment */\n+\t    }\n+\t}\n     }\n \n     /* Links have no mode, other types have no linkto */""}<_**next**_>{""sha"": ""c5530de69ca263e2e0e6934bb8de61c05155c85e"", ""filename"": ""tests/rpmverify.at"", ""status"": ""modified"", ""additions"": 47, ""deletions"": 9, ""changes"": 56, ""blob_url"": ""https://github.com/rpm-software-management/rpm/blob/c815822c8bdb138066ff58c624ae83e3a12ebfa9/tests/rpmverify.at"", ""raw_url"": ""https://github.com/rpm-software-management/rpm/raw/c815822c8bdb138066ff58c624ae83e3a12ebfa9/tests/rpmverify.at"", ""contents_url"": ""https://api.github.com/repos/rpm-software-management/rpm/contents/tests/rpmverify.at?ref=c815822c8bdb138066ff58c624ae83e3a12ebfa9"", ""patch"": ""@@ -69,18 +69,56 @@ AT_KEYWORDS([verify])\n AT_CHECK([\n RPMDB_CLEAR\n RPMDB_INIT\n+tf=\""${RPMTEST}\""/opt/foo\n+rm -rf \""${RPMTEST}\""/opt/*\n+rm -rf \""${TOPDIR}\""\n \n-runroot rpm -U --nodeps --noscripts --ignorearch --ignoreos \\\n-\t/data/RPMS/hello-1.0-1.i386.rpm\n-mv \""${RPMTEST}\""/usr/share/doc/hello-1.0 \""${RPMTEST}\""/usr/share/doc/hello-1.0.orig\n-ln -s hello-1.0.orig \""${RPMTEST}\""/usr/share/doc/hello-1.0\n-runroot rpm -Vva --nodeps --nouser --nogroup\n-rm -rf \""${RPMTEST}\""/usr/share/doc/\n+runroot rpmbuild --quiet -bb \\\n+        --define \""ver 1.0\"" \\\n+        --define \""filetype datadir\"" \\\n+        --define \""filedata README1\"" \\\n+        --define \""user $(id -u -n)\"" \\\n+          /data/SPECS/replacetest.spec\n+\n+runroot rpm -U /build/RPMS/noarch/replacetest-1.0-1.noarch.rpm\n+mv \""${RPMTEST}\""/opt/foo \""${RPMTEST}\""/opt/was\n+ln -s was \""${RPMTEST}\""/opt/foo\n+runroot rpm -Vv replacetest\n ],\n [0],\n-[.........    /usr/local/bin/hello\n-.........    /usr/share/doc/hello-1.0\n-.........  d /usr/share/doc/hello-1.0/FAQ\n+[.........    /opt/foo\n+.........    /opt/foo/README1\n+.........    /opt/goo\n+.........    /opt/zoo\n+],\n+[])\n+AT_CLEANUP\n+\n+AT_SETUP([directory replaced with an invalid directory symlink])\n+AT_KEYWORDS([verify])\n+AT_CHECK([\n+RPMDB_CLEAR\n+RPMDB_INIT\n+tf=\""${RPMTEST}\""/opt/foo\n+rm -rf \""${RPMTEST}\""/opt/*\n+rm -rf \""${TOPDIR}\""\n+\n+runroot rpmbuild --quiet -bb \\\n+        --define \""ver 1.0\"" \\\n+        --define \""filetype datadir\"" \\\n+        --define \""filedata README1\"" \\\n+          /data/SPECS/replacetest.spec\n+\n+runroot rpm -U /build/RPMS/noarch/replacetest-1.0-1.noarch.rpm\n+mv \""${RPMTEST}\""/opt/foo \""${RPMTEST}\""/opt/was\n+ln -s was \""${RPMTEST}\""/opt/foo\n+runroot rpm -Vv --nouser --nogroup replacetest\n+],\n+[1],\n+[....L....    /opt/foo\n+.........    /opt/foo/README1\n+.........    /opt/goo\n+.........    /opt/zoo\n ],\n [])\n AT_CLEANUP""}","rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
{
    rpm_mode_t fmode = rpmfilesFMode(fi, ix);
    rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);
    rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);
    const char * fn = rpmfilesFN(fi, ix);
    struct stat sb;
    rpmVerifyAttrs vfy = RPMVERIFY_NONE;

    /*
     * Check to see if the file was installed - if not pretend all is OK.
     */
    switch (rpmfilesFState(fi, ix)) {
    case RPMFILE_STATE_NETSHARED:
    case RPMFILE_STATE_NOTINSTALLED:
	goto exit;
	break;
    case RPMFILE_STATE_REPLACED:
	/* For replaced files we can only verify if it exists at all */
	flags = RPMVERIFY_LSTATFAIL;
	break;
    case RPMFILE_STATE_WRONGCOLOR:
	/*
	 * Files with wrong color are supposed to share some attributes
	 * with the actually installed file - verify what we can.
	 */
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_RDEV);
	break;
    case RPMFILE_STATE_NORMAL:
    /* File from a non-installed package, try to verify nevertheless */
    case RPMFILE_STATE_MISSING:
	break;
    }

    if (fn == NULL || lstat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* If we expected a directory but got a symlink to one, follow the link */
    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {
	struct stat dsb;
	/* ...if it actually points to a directory  */
	if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {
	    uid_t fuid;
	    /* ...and is by a legit user, to match fsmVerify() behavior */
	    if (sb.st_uid == 0 ||
			(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&
			 sb.st_uid == fuid)) {
		sb = dsb; /* struct assignment */
	    }
	}
     }
 
     /* Links have no mode, other types have no linkto */
    if (S_ISLNK(sb.st_mode))
	flags &= ~(RPMVERIFY_MODE);
    else
	flags &= ~(RPMVERIFY_LINKTO);

    /* Not all attributes of non-regular files can be verified */
    if (!S_ISREG(sb.st_mode))
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_CAPS);

    /* Content checks of %ghost files are meaningless. */
    if (fileAttrs & RPMFILE_GHOST)
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_LINKTO);

    /* Don't verify any features in omitMask. */
    flags &= ~(omitMask | RPMVERIFY_FAILURES);


    if (flags & RPMVERIFY_FILEDIGEST) {
	const unsigned char *digest; 
	int algo;
	size_t diglen;

	/* XXX If --nomd5, then prelinked library sizes are not corrected. */
	if ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {
	    unsigned char fdigest[diglen];
	    rpm_loff_t fsize;

	    if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {
		vfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);
	    } else {
		sb.st_size = fsize;
		if (memcmp(fdigest, digest, diglen))
		    vfy |= RPMVERIFY_FILEDIGEST;
	    }
	} else {
	    vfy |= RPMVERIFY_FILEDIGEST;
	} 
    } 

    if (flags & RPMVERIFY_LINKTO) {
	char linkto[1024+1];
	int size = 0;

	if ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)
	    vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);
	else {
	    const char * flink = rpmfilesFLink(fi, ix);
	    linkto[size] = '\0';
	    if (flink == NULL || !rstreq(linkto, flink))
		vfy |= RPMVERIFY_LINKTO;
	}
    } 

    if (flags & RPMVERIFY_FILESIZE) {
	if (sb.st_size != rpmfilesFSize(fi, ix))
	    vfy |= RPMVERIFY_FILESIZE;
    } 

    if (flags & RPMVERIFY_MODE) {
	rpm_mode_t metamode = fmode;
	rpm_mode_t filemode;

	/*
	 * Platforms (like AIX) where sizeof(rpm_mode_t) != sizeof(mode_t)
	 * need the (rpm_mode_t) cast here. 
	 */
	filemode = (rpm_mode_t)sb.st_mode;

	/*
	 * Comparing the type of %ghost files is meaningless, but perms are OK.
	 */
	if (fileAttrs & RPMFILE_GHOST) {
	    metamode &= ~0xf000;
	    filemode &= ~0xf000;
	}

	if (metamode != filemode)
	    vfy |= RPMVERIFY_MODE;

#if WITH_ACL
	/*
	 * For now, any non-default acl's on a file is a difference as rpm
	 * cannot have set them.
	 */
	acl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);
	if (facl) {
	    if (acl_equiv_mode(facl, NULL) == 1) {
		vfy |= RPMVERIFY_MODE;
	    }
	    acl_free(facl);
	}
#endif 
    }

    if (flags & RPMVERIFY_RDEV) {
	if (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)
	 || S_ISBLK(fmode) != S_ISBLK(sb.st_mode))
	{
	    vfy |= RPMVERIFY_RDEV;
	} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {
	    rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);
	    rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);
	    if (st_rdev != frdev)
		vfy |= RPMVERIFY_RDEV;
	} 
    }

#if WITH_CAP
    if (flags & RPMVERIFY_CAPS) {
	/*
 	 * Empty capability set (""="") is not exactly the same as no
 	 * capabilities at all but suffices for now... 
 	 */
	cap_t cap, fcap;
	cap = cap_from_text(rpmfilesFCaps(fi, ix));
	if (!cap) {
	    cap = cap_from_text(""="");
	}
	fcap = cap_get_file(fn);
	if (!fcap) {
	    fcap = cap_from_text(""="");
	}
	
	if (cap_compare(cap, fcap) != 0)
	    vfy |= RPMVERIFY_CAPS;

	cap_free(fcap);
	cap_free(cap);
    }
#endif

    if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {
	vfy |= RPMVERIFY_MTIME;
    }

    if (flags & RPMVERIFY_USER) {
	const char * name = rpmugUname(sb.st_uid);
	const char * fuser = rpmfilesFUser(fi, ix);
	uid_t uid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fuser)
	   namematch =  rstreq(name, fuser);
	if (fuser && rpmugUid(fuser, &uid) == 0)
	    idmatch = (uid == sb.st_uid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate username or UID for user %s\n""), fuser);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_USER;
    }

    if (flags & RPMVERIFY_GROUP) {
	const char * name = rpmugGname(sb.st_gid);
	const char * fgroup = rpmfilesFGroup(fi, ix);
	gid_t gid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fgroup)
	    namematch = rstreq(name, fgroup);
	if (fgroup && rpmugGid(fgroup, &gid) == 0)
	    idmatch = (gid == sb.st_gid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate groupname or GID for group %s\n""), fgroup);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_GROUP;
    }

exit:
    return vfy;
}
","rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
{
    rpm_mode_t fmode = rpmfilesFMode(fi, ix);
    rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);
    rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);
    const char * fn = rpmfilesFN(fi, ix);
    struct stat sb;
    rpmVerifyAttrs vfy = RPMVERIFY_NONE;

    /*
     * Check to see if the file was installed - if not pretend all is OK.
     */
    switch (rpmfilesFState(fi, ix)) {
    case RPMFILE_STATE_NETSHARED:
    case RPMFILE_STATE_NOTINSTALLED:
	goto exit;
	break;
    case RPMFILE_STATE_REPLACED:
	/* For replaced files we can only verify if it exists at all */
	flags = RPMVERIFY_LSTATFAIL;
	break;
    case RPMFILE_STATE_WRONGCOLOR:
	/*
	 * Files with wrong color are supposed to share some attributes
	 * with the actually installed file - verify what we can.
	 */
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_RDEV);
	break;
    case RPMFILE_STATE_NORMAL:
    /* File from a non-installed package, try to verify nevertheless */
    case RPMFILE_STATE_MISSING:
	break;
    }

    if (fn == NULL || lstat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* If we expected a directory but got a symlink to one, follow the link */
    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* Links have no mode, other types have no linkto */
    if (S_ISLNK(sb.st_mode))
	flags &= ~(RPMVERIFY_MODE);
    else
	flags &= ~(RPMVERIFY_LINKTO);

    /* Not all attributes of non-regular files can be verified */
    if (!S_ISREG(sb.st_mode))
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_CAPS);

    /* Content checks of %ghost files are meaningless. */
    if (fileAttrs & RPMFILE_GHOST)
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_LINKTO);

    /* Don't verify any features in omitMask. */
    flags &= ~(omitMask | RPMVERIFY_FAILURES);


    if (flags & RPMVERIFY_FILEDIGEST) {
	const unsigned char *digest; 
	int algo;
	size_t diglen;

	/* XXX If --nomd5, then prelinked library sizes are not corrected. */
	if ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {
	    unsigned char fdigest[diglen];
	    rpm_loff_t fsize;

	    if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {
		vfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);
	    } else {
		sb.st_size = fsize;
		if (memcmp(fdigest, digest, diglen))
		    vfy |= RPMVERIFY_FILEDIGEST;
	    }
	} else {
	    vfy |= RPMVERIFY_FILEDIGEST;
	} 
    } 

    if (flags & RPMVERIFY_LINKTO) {
	char linkto[1024+1];
	int size = 0;

	if ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)
	    vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);
	else {
	    const char * flink = rpmfilesFLink(fi, ix);
	    linkto[size] = '\0';
	    if (flink == NULL || !rstreq(linkto, flink))
		vfy |= RPMVERIFY_LINKTO;
	}
    } 

    if (flags & RPMVERIFY_FILESIZE) {
	if (sb.st_size != rpmfilesFSize(fi, ix))
	    vfy |= RPMVERIFY_FILESIZE;
    } 

    if (flags & RPMVERIFY_MODE) {
	rpm_mode_t metamode = fmode;
	rpm_mode_t filemode;

	/*
	 * Platforms (like AIX) where sizeof(rpm_mode_t) != sizeof(mode_t)
	 * need the (rpm_mode_t) cast here. 
	 */
	filemode = (rpm_mode_t)sb.st_mode;

	/*
	 * Comparing the type of %ghost files is meaningless, but perms are OK.
	 */
	if (fileAttrs & RPMFILE_GHOST) {
	    metamode &= ~0xf000;
	    filemode &= ~0xf000;
	}

	if (metamode != filemode)
	    vfy |= RPMVERIFY_MODE;

#if WITH_ACL
	/*
	 * For now, any non-default acl's on a file is a difference as rpm
	 * cannot have set them.
	 */
	acl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);
	if (facl) {
	    if (acl_equiv_mode(facl, NULL) == 1) {
		vfy |= RPMVERIFY_MODE;
	    }
	    acl_free(facl);
	}
#endif 
    }

    if (flags & RPMVERIFY_RDEV) {
	if (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)
	 || S_ISBLK(fmode) != S_ISBLK(sb.st_mode))
	{
	    vfy |= RPMVERIFY_RDEV;
	} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {
	    rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);
	    rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);
	    if (st_rdev != frdev)
		vfy |= RPMVERIFY_RDEV;
	} 
    }

#if WITH_CAP
    if (flags & RPMVERIFY_CAPS) {
	/*
 	 * Empty capability set (""="") is not exactly the same as no
 	 * capabilities at all but suffices for now... 
 	 */
	cap_t cap, fcap;
	cap = cap_from_text(rpmfilesFCaps(fi, ix));
	if (!cap) {
	    cap = cap_from_text(""="");
	}
	fcap = cap_get_file(fn);
	if (!fcap) {
	    fcap = cap_from_text(""="");
	}
	
	if (cap_compare(cap, fcap) != 0)
	    vfy |= RPMVERIFY_CAPS;

	cap_free(fcap);
	cap_free(cap);
    }
#endif

    if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {
	vfy |= RPMVERIFY_MTIME;
    }

    if (flags & RPMVERIFY_USER) {
	const char * name = rpmugUname(sb.st_uid);
	const char * fuser = rpmfilesFUser(fi, ix);
	uid_t uid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fuser)
	   namematch =  rstreq(name, fuser);
	if (fuser && rpmugUid(fuser, &uid) == 0)
	    idmatch = (uid == sb.st_uid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate username or UID for user %s\n""), fuser);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_USER;
    }

    if (flags & RPMVERIFY_GROUP) {
	const char * name = rpmugGname(sb.st_gid);
	const char * fgroup = rpmfilesFGroup(fi, ix);
	gid_t gid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fgroup)
	    namematch = rstreq(name, fgroup);
	if (fgroup && rpmugGid(fgroup, &gid) == 0)
	    idmatch = (gid == sb.st_gid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate groupname or GID for group %s\n""), fgroup);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_GROUP;
    }

exit:
    return vfy;
}
",C,"    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {
	struct stat dsb;
	/* ...if it actually points to a directory  */
	if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {
	    uid_t fuid;
	    /* ...and is by a legit user, to match fsmVerify() behavior */
	    if (sb.st_uid == 0 ||
			(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&
			 sb.st_uid == fuid)) {
		sb = dsb; /* struct assignment */
	    }
	}
","    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
",,"@@ -94,9 +94,18 @@ rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
     }
 
     /* If we expected a directory but got a symlink to one, follow the link */
-    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {
-	vfy |= RPMVERIFY_LSTATFAIL;
-	goto exit;
+    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {
+	struct stat dsb;
+	/* ...if it actually points to a directory  */
+	if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {
+	    uid_t fuid;
+	    /* ...and is by a legit user, to match fsmVerify() behavior */
+	    if (sb.st_uid == 0 ||
+			(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&
+			 sb.st_uid == fuid)) {
+		sb = dsb; /* struct assignment */
+	    }
+	}
     }
 
     /* Links have no mode, other types have no linkto */",rpm,c815822c8bdb138066ff58c624ae83e3a12ebfa9,f2d3be2a8741234faaa96f5fd05fdfdc75779a79,1,"rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
{
    rpm_mode_t fmode = rpmfilesFMode(fi, ix);
    rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);
    rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);
    const char * fn = rpmfilesFN(fi, ix);
    struct stat sb;
    rpmVerifyAttrs vfy = RPMVERIFY_NONE;

    /*
     * Check to see if the file was installed - if not pretend all is OK.
     */
    switch (rpmfilesFState(fi, ix)) {
    case RPMFILE_STATE_NETSHARED:
    case RPMFILE_STATE_NOTINSTALLED:
	goto exit;
	break;
    case RPMFILE_STATE_REPLACED:
	/* For replaced files we can only verify if it exists at all */
	flags = RPMVERIFY_LSTATFAIL;
	break;
    case RPMFILE_STATE_WRONGCOLOR:
	/*
	 * Files with wrong color are supposed to share some attributes
	 * with the actually installed file - verify what we can.
	 */
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_RDEV);
	break;
    case RPMFILE_STATE_NORMAL:
    /* File from a non-installed package, try to verify nevertheless */
    case RPMFILE_STATE_MISSING:
	break;
    }

    if (fn == NULL || lstat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* If we expected a directory but got a symlink to one, follow the link */
//flaw_line_below:
    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {
//flaw_line_below:
	vfy |= RPMVERIFY_LSTATFAIL;
//flaw_line_below:
	goto exit;
//fix_flaw_line_below:
//    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {
//fix_flaw_line_below:
//	struct stat dsb;
//fix_flaw_line_below:
//	/* ...if it actually points to a directory  */
//fix_flaw_line_below:
//	if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {
//fix_flaw_line_below:
//	    uid_t fuid;
//fix_flaw_line_below:
//	    /* ...and is by a legit user, to match fsmVerify() behavior */
//fix_flaw_line_below:
//	    if (sb.st_uid == 0 ||
//fix_flaw_line_below:
//			(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&
//fix_flaw_line_below:
//			 sb.st_uid == fuid)) {
//fix_flaw_line_below:
//		sb = dsb; /* struct assignment */
//fix_flaw_line_below:
//	    }
//fix_flaw_line_below:
//	}
     }
 
     /* Links have no mode, other types have no linkto */
    if (S_ISLNK(sb.st_mode))
	flags &= ~(RPMVERIFY_MODE);
    else
	flags &= ~(RPMVERIFY_LINKTO);

    /* Not all attributes of non-regular files can be verified */
    if (!S_ISREG(sb.st_mode))
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_CAPS);

    /* Content checks of %ghost files are meaningless. */
    if (fileAttrs & RPMFILE_GHOST)
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_LINKTO);

    /* Don't verify any features in omitMask. */
    flags &= ~(omitMask | RPMVERIFY_FAILURES);


    if (flags & RPMVERIFY_FILEDIGEST) {
	const unsigned char *digest; 
	int algo;
	size_t diglen;

	/* XXX If --nomd5, then prelinked library sizes are not corrected. */
	if ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {
	    unsigned char fdigest[diglen];
	    rpm_loff_t fsize;

	    if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {
		vfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);
	    } else {
		sb.st_size = fsize;
		if (memcmp(fdigest, digest, diglen))
		    vfy |= RPMVERIFY_FILEDIGEST;
	    }
	} else {
	    vfy |= RPMVERIFY_FILEDIGEST;
	} 
    } 

    if (flags & RPMVERIFY_LINKTO) {
	char linkto[1024+1];
	int size = 0;

	if ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)
	    vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);
	else {
	    const char * flink = rpmfilesFLink(fi, ix);
	    linkto[size] = '\0';
	    if (flink == NULL || !rstreq(linkto, flink))
		vfy |= RPMVERIFY_LINKTO;
	}
    } 

    if (flags & RPMVERIFY_FILESIZE) {
	if (sb.st_size != rpmfilesFSize(fi, ix))
	    vfy |= RPMVERIFY_FILESIZE;
    } 

    if (flags & RPMVERIFY_MODE) {
	rpm_mode_t metamode = fmode;
	rpm_mode_t filemode;

	/*
	 * Platforms (like AIX) where sizeof(rpm_mode_t) != sizeof(mode_t)
	 * need the (rpm_mode_t) cast here. 
	 */
	filemode = (rpm_mode_t)sb.st_mode;

	/*
	 * Comparing the type of %ghost files is meaningless, but perms are OK.
	 */
	if (fileAttrs & RPMFILE_GHOST) {
	    metamode &= ~0xf000;
	    filemode &= ~0xf000;
	}

	if (metamode != filemode)
	    vfy |= RPMVERIFY_MODE;

#if WITH_ACL
	/*
	 * For now, any non-default acl's on a file is a difference as rpm
	 * cannot have set them.
	 */
	acl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);
	if (facl) {
	    if (acl_equiv_mode(facl, NULL) == 1) {
		vfy |= RPMVERIFY_MODE;
	    }
	    acl_free(facl);
	}
#endif 
    }

    if (flags & RPMVERIFY_RDEV) {
	if (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)
	 || S_ISBLK(fmode) != S_ISBLK(sb.st_mode))
	{
	    vfy |= RPMVERIFY_RDEV;
	} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {
	    rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);
	    rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);
	    if (st_rdev != frdev)
		vfy |= RPMVERIFY_RDEV;
	} 
    }

#if WITH_CAP
    if (flags & RPMVERIFY_CAPS) {
	/*
 	 * Empty capability set (""="") is not exactly the same as no
 	 * capabilities at all but suffices for now... 
 	 */
	cap_t cap, fcap;
	cap = cap_from_text(rpmfilesFCaps(fi, ix));
	if (!cap) {
	    cap = cap_from_text(""="");
	}
	fcap = cap_get_file(fn);
	if (!fcap) {
	    fcap = cap_from_text(""="");
	}
	
	if (cap_compare(cap, fcap) != 0)
	    vfy |= RPMVERIFY_CAPS;

	cap_free(fcap);
	cap_free(cap);
    }
#endif

    if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {
	vfy |= RPMVERIFY_MTIME;
    }

    if (flags & RPMVERIFY_USER) {
	const char * name = rpmugUname(sb.st_uid);
	const char * fuser = rpmfilesFUser(fi, ix);
	uid_t uid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fuser)
	   namematch =  rstreq(name, fuser);
	if (fuser && rpmugUid(fuser, &uid) == 0)
	    idmatch = (uid == sb.st_uid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate username or UID for user %s\n""), fuser);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_USER;
    }

    if (flags & RPMVERIFY_GROUP) {
	const char * name = rpmugGname(sb.st_gid);
	const char * fgroup = rpmfilesFGroup(fi, ix);
	gid_t gid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fgroup)
	    namematch = rstreq(name, fgroup);
	if (fgroup && rpmugGid(fgroup, &gid) == 0)
	    idmatch = (gid == sb.st_gid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate groupname or GID for group %s\n""), fgroup);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_GROUP;
    }

exit:
    return vfy;
}
"
5506,183242,,Local,Not required,,CVE-2017-7418,https://www.cvedetails.com/cve/CVE-2017-7418/,CWE-59,Low,,Partial,,2017-04-04,2.1,"ProFTPD before 1.3.5e and 1.3.6 before 1.3.6rc5 controls whether the home directory of a user could contain a symbolic link through the AllowChrootSymlinks configuration option, but checks only the last path component when enforcing AllowChrootSymlinks. Attackers with local access could bypass the AllowChrootSymlinks control by replacing a path component (other than the last one) with a symbolic link. The threat model includes an attacker who is not granted full filesystem access by a hosting provider, but can reconfigure the home directory of an FTP user.",2019-08-08,Bypass ,5,https://github.com/proftpd/proftpd/commit/ecff21e0d0e84f35c299ef91d7fda088e516d4ed,ecff21e0d0e84f35c299ef91d7fda088e516d4ed,"Backporting recursive handling of DefaultRoot path, when AllowChrootSymlinks
is off, to 1.3.5 branch.",13,modules/mod_auth.c,"{""sha"": ""410215979a91ad5056eab1d8a301a06312e65be8"", ""filename"": ""modules/mod_auth.c"", ""status"": ""modified"", ""additions"": 65, ""deletions"": 18, ""changes"": 83, ""blob_url"": ""https://github.com/proftpd/proftpd/blob/ecff21e0d0e84f35c299ef91d7fda088e516d4ed/modules/mod_auth.c"", ""raw_url"": ""https://github.com/proftpd/proftpd/raw/ecff21e0d0e84f35c299ef91d7fda088e516d4ed/modules/mod_auth.c"", ""contents_url"": ""https://api.github.com/repos/proftpd/proftpd/contents/modules/mod_auth.c?ref=ecff21e0d0e84f35c299ef91d7fda088e516d4ed"", ""patch"": ""@@ -2,7 +2,7 @@\n  * ProFTPD - FTP server daemon\n  * Copyright (c) 1997, 1998 Public Flood Software\n  * Copyright (c) 1999, 2000 MacGyver aka Habeeb J. Dihu <macgyver@tos.net>\n- * Copyright (c) 2001-2016 The ProFTPD Project team\n+ * Copyright (c) 2001-2017 The ProFTPD Project team\n  *\n  * This program is free software; you can redistribute it and/or modify\n  * it under the terms of the GNU General Public License as published by\n@@ -688,9 +688,66 @@ static char *get_default_chdir(pool *p, xaset_t *conf) {\n   return dir;\n }\n \n-/* Determine if the user (non-anon) needs a default root dir other than /.\n- */\n+static int is_symlink_path(pool *p, const char *path, size_t pathlen) {\n+  int res, xerrno = 0;\n+  struct stat st;\n+  char *ptr;\n+\n+  if (pathlen == 0) {\n+    return 0;\n+  }\n+\n+  pr_fs_clear_cache();\n+  res = pr_fsio_lstat(path, &st);\n+  if (res < 0) {\n+    xerrno = errno;\n+\n+    pr_log_pri(PR_LOG_WARNING, \""error: unable to check %s: %s\"", path,\n+      strerror(xerrno));\n+\n+    errno = xerrno;\n+    return -1;\n+  }\n \n+  if (S_ISLNK(st.st_mode)) {\n+    errno = EPERM;\n+    return -1;\n+  }\n+\n+  /* To handle the case where a component further up the path might be a\n+   * symlink (which lstat(2) will NOT handle), we walk the path backwards,\n+   * calling ourselves recursively.\n+   */\n+\n+  ptr = strrchr(path, '/');\n+  if (ptr != NULL) {\n+    char *new_path;\n+    size_t new_pathlen;\n+\n+    pr_signals_handle();\n+\n+    new_pathlen = ptr - path;\n+\n+    /* Make sure our pointer actually changed position. */\n+    if (new_pathlen == pathlen) {\n+      return 0;\n+    }\n+\n+    new_path = pstrndup(p, path, new_pathlen);\n+\n+    pr_log_debug(DEBUG10,\n+      \""AllowChrootSymlink: path '%s' not a symlink, checking '%s'\"", path,\n+      new_path);\n+    res = is_symlink_path(p, new_path, new_pathlen);\n+    if (res < 0) {\n+      return -1;\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n+/* Determine if the user (non-anon) needs a default root dir other than /. */\n static int get_default_root(pool *p, int allow_symlinks, char **root) {\n   config_rec *c = NULL;\n   char *dir = NULL;\n@@ -733,7 +790,6 @@ static int get_default_root(pool *p, int allow_symlinks, char **root) {\n \n       if (allow_symlinks == FALSE) {\n         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n-        struct stat st;\n         size_t pathlen;\n \n         /* First, deal with any possible interpolation.  dir_realpath() will\n@@ -764,22 +820,13 @@ static int get_default_root(pool *p, int allow_symlinks, char **root) {\n           path[pathlen-1] = '\\0';\n         }\n \n-        pr_fs_clear_cache();\n-        res = pr_fsio_lstat(path, &st);\n+        res = is_symlink_path(p, path, pathlen);\n         if (res < 0) {\n-          xerrno = errno;\n-\n-          pr_log_pri(PR_LOG_WARNING, \""error: unable to check %s: %s\"", path,\n-            strerror(xerrno));\n-\n-          errno = xerrno;\n-          return -1;\n-        }\n+          if (errno == EPERM) {\n+            pr_log_pri(PR_LOG_WARNING, \""error: DefaultRoot %s is a symlink \""\n+              \""(denied by AllowChrootSymlinks config)\"", path);\n+          }\n \n-        if (S_ISLNK(st.st_mode)) {\n-          pr_log_pri(PR_LOG_WARNING,\n-            \""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \""\n-            \""config)\"", path);\n           errno = EPERM;\n           return -1;\n         }""}"," static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir) {
    char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = dir;
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
 
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
"," static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir) {
    char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = dir;
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        pr_fs_clear_cache();
        res = pr_fsio_lstat(path, &st);
         if (res < 0) {
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
 
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
",C,"        res = is_symlink_path(p, path, pathlen);
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
","        struct stat st;
        pr_fs_clear_cache();
        res = pr_fsio_lstat(path, &st);
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
",,"@@ -2,7 +2,7 @@
  * ProFTPD - FTP server daemon
  * Copyright (c) 1997, 1998 Public Flood Software
  * Copyright (c) 1999, 2000 MacGyver aka Habeeb J. Dihu <macgyver@tos.net>
- * Copyright (c) 2001-2016 The ProFTPD Project team
+ * Copyright (c) 2001-2017 The ProFTPD Project team
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -688,9 +688,66 @@ static char *get_default_chdir(pool *p, xaset_t *conf) {
   return dir;
 }
 
-/* Determine if the user (non-anon) needs a default root dir other than /.
- */
+static int is_symlink_path(pool *p, const char *path, size_t pathlen) {
+  int res, xerrno = 0;
+  struct stat st;
+  char *ptr;
+
+  if (pathlen == 0) {
+    return 0;
+  }
+
+  pr_fs_clear_cache();
+  res = pr_fsio_lstat(path, &st);
+  if (res < 0) {
+    xerrno = errno;
+
+    pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
+      strerror(xerrno));
+
+    errno = xerrno;
+    return -1;
+  }
 
+  if (S_ISLNK(st.st_mode)) {
+    errno = EPERM;
+    return -1;
+  }
+
+  /* To handle the case where a component further up the path might be a
+   * symlink (which lstat(2) will NOT handle), we walk the path backwards,
+   * calling ourselves recursively.
+   */
+
+  ptr = strrchr(path, '/');
+  if (ptr != NULL) {
+    char *new_path;
+    size_t new_pathlen;
+
+    pr_signals_handle();
+
+    new_pathlen = ptr - path;
+
+    /* Make sure our pointer actually changed position. */
+    if (new_pathlen == pathlen) {
+      return 0;
+    }
+
+    new_path = pstrndup(p, path, new_pathlen);
+
+    pr_log_debug(DEBUG10,
+      ""AllowChrootSymlink: path '%s' not a symlink, checking '%s'"", path,
+      new_path);
+    res = is_symlink_path(p, new_path, new_pathlen);
+    if (res < 0) {
+      return -1;
+    }
+  }
+
+  return 0;
+}
+
+/* Determine if the user (non-anon) needs a default root dir other than /. */
 static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
@@ -733,7 +790,6 @@ static int get_default_root(pool *p, int allow_symlinks, char **root) {
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
-        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
@@ -764,22 +820,13 @@ static int get_default_root(pool *p, int allow_symlinks, char **root) {
           path[pathlen-1] = '\0';
         }
 
-        pr_fs_clear_cache();
-        res = pr_fsio_lstat(path, &st);
+        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
-          xerrno = errno;
-
-          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
-            strerror(xerrno));
-
-          errno = xerrno;
-          return -1;
-        }
+          if (errno == EPERM) {
+            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
+              ""(denied by AllowChrootSymlinks config)"", path);
+          }
 
-        if (S_ISLNK(st.st_mode)) {
-          pr_log_pri(PR_LOG_WARNING,
-            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
-            ""config)"", path);
           errno = EPERM;
           return -1;
         }",proftpd,ecff21e0d0e84f35c299ef91d7fda088e516d4ed,5a2ca0f12723c6fa9bdaa4faa1c2979335e50b07,1," static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir) {
    char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
//flaw_line_below:
        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = dir;
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
//flaw_line_below:
        pr_fs_clear_cache();
//flaw_line_below:
        res = pr_fsio_lstat(path, &st);
//fix_flaw_line_below:
//        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
//flaw_line_below:
          xerrno = errno;
//flaw_line_below:

//flaw_line_below:
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
//flaw_line_below:
            strerror(xerrno));
//flaw_line_below:

//flaw_line_below:
          errno = xerrno;
//flaw_line_below:
          return -1;
//flaw_line_below:
        }
//fix_flaw_line_below:
//          if (errno == EPERM) {
//fix_flaw_line_below:
//            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
//fix_flaw_line_below:
//              ""(denied by AllowChrootSymlinks config)"", path);
//fix_flaw_line_below:
//          }
 
//flaw_line_below:
        if (S_ISLNK(st.st_mode)) {
//flaw_line_below:
          pr_log_pri(PR_LOG_WARNING,
//flaw_line_below:
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
//flaw_line_below:
            ""config)"", path);
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
"
5571,183307,,Local,Not required,Complete,CVE-2015-3315,https://www.cvedetails.com/cve/CVE-2015-3315/,CWE-59,Low,Complete,Complete,,2017-06-26,7.2,"Automatic Bug Reporting Tool (ABRT) allows local users to read, change the ownership of, or have other unspecified impact on arbitrary files via a symlink attack on (1) /var/tmp/abrt/*/maps, (2) /tmp/jvm-*/hs_error.log, (3) /proc/*/exe, (4) /etc/os-release in a chroot, or (5) an unspecified root directory related to librpm.",2018-02-18,,1,https://github.com/abrt/abrt/commit/4f2c1ddd3e3b81d2d5146b883115371f1cada9f9,4f2c1ddd3e3b81d2d5146b883115371f1cada9f9,"ccpp: do not read data from root directories

Users are allowed to modify /proc/[pid]/root to any directory by running
their own MOUNT namespace.

Related: #1211835

Signed-off-by: Jakub Filak <jfilak@redhat.com>",1,src/hooks/abrt-hook-ccpp.c,"{""sha"": ""0606519eeef82a144e3019d940336059628f9212"", ""filename"": ""src/hooks/abrt-hook-ccpp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/abrt/abrt/blob/4f2c1ddd3e3b81d2d5146b883115371f1cada9f9/src/hooks/abrt-hook-ccpp.c"", ""raw_url"": ""https://github.com/abrt/abrt/raw/4f2c1ddd3e3b81d2d5146b883115371f1cada9f9/src/hooks/abrt-hook-ccpp.c"", ""contents_url"": ""https://api.github.com/repos/abrt/abrt/contents/src/hooks/abrt-hook-ccpp.c?ref=4f2c1ddd3e3b81d2d5146b883115371f1cada9f9"", ""patch"": ""@@ -678,7 +678,7 @@ int main(int argc, char** argv)\n     {\n         char *rootdir = get_rootdir(pid);\n \n-        dd_create_basic_files(dd, fsuid, (rootdir && strcmp(rootdir, \""/\"") != 0) ? rootdir : NULL);\n+        dd_create_basic_files(dd, fsuid, NULL);\n \n         char source_filename[sizeof(\""/proc/%lu/somewhat_long_name\"") + sizeof(long)*3];\n         int source_base_ofs = sprintf(source_filename, \""/proc/%lu/smaps\"", (long)pid);""}","int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
	fd = xdup(fd);
    if (fd > 2)
	close(fd);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %h */
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME [HOSTNAME]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }

    struct utsname uts;
    if (!argv[8]) /* no HOSTNAME? */
    {
        uname(&uts);
        argv[8] = uts.nodename;
    }

    char path[PATH_MAX];

    int src_fd_binary = -1;
    char *executable = get_executable(pid, setting_SaveBinaryImage ? &src_fd_binary : NULL);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid();
    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
        {
            fsuid = tmp_fsuid;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        goto create_user_core;
    }

    const char *signame = NULL;
    switch (signal_no)
    {
        case SIGILL : signame = ""ILL"" ; break;
        case SIGFPE : signame = ""FPE"" ; break;
        case SIGSEGV: signame = ""SEGV""; break;
        case SIGBUS : signame = ""BUS"" ; break; //Bus error (bad memory access)
        case SIGABRT: signame = ""ABRT""; break; //usually when abort() was called
        case SIGTRAP: signame = ""TRAP""; break; //Trace/breakpoint trap
        default: goto create_user_core; // not a signal we care about
    }

    if (!daemon_is_ok())
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        goto create_user_core;
    }

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            goto create_user_core;
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        goto create_user_core;
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
        snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
        if (core_size < 0 || fsync(abrt_core_fd) != 0)
        {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        return 0;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        goto create_user_core;
    }

    /* use fsuid instead of uid, so we don't expose any sensitive
     * information of suided app in /var/tmp/abrt
     */
    dd = dd_create(path, fsuid, DEFAULT_DUMP_DIR_MODE);
    if (dd)
     {
         char *rootdir = get_rootdir(pid);
 
        dd_create_basic_files(dd, fsuid, NULL);
 
         char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
         int source_base_ofs = sprintf(source_filename, ""/proc/%lu/smaps"", (long)pid);
        source_base_ofs -= strlen(""smaps"");
        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;


        strcpy(source_filename + source_base_ofs, ""maps"");
        strcpy(dest_base, FILENAME_MAPS);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(source_filename + source_base_ofs, ""limits"");
        strcpy(dest_base, FILENAME_LIMITS);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        strcpy(dest_base, FILENAME_CGROUP);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        dd_save_text(dd, FILENAME_ANALYZER, ""CCpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        if (src_fd_binary > 0)
        {
            strcpy(path + path_len, ""/""FILENAME_BINARY);
            int dst_fd = create_or_die(path);
            off_t sz = copyfd_eof(src_fd_binary, dst_fd, COPYFD_SPARSE);
            if (fsync(dst_fd) != 0 || close(dst_fd) != 0 || sz < 0)
            {
                dd_delete(dd);
                error_msg_and_die(""Error saving '%s'"", path);
            }
            close(src_fd_binary);
        }

        strcpy(path + path_len, ""/""FILENAME_COREDUMP);
        int abrt_core_fd = create_or_die(path);

        /* We write both coredumps at once.
         * We can't write user coredump first, since it might be truncated
         * and thus can't be copied and used as abrt coredump;
         * and if we write abrt coredump first and then copy it as user one,
         * then we have a race when process exits but coredump does not exist yet:
         * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
         * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
         * 21631 Segmentation fault (core dumped) ./test
         * ls: cannot access core*: No such file or directory <=== BAD
         */
        off_t core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
        if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
        {
            unlink(path);
            dd_delete(dd);
            if (user_core_fd >= 0)
            {
                xchdir(user_pwd);
                unlink(core_basename);
            }
            /* copyfd_sparse logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error writing '%s'"", path);
        }
        if (user_core_fd >= 0
            /* error writing user coredump? */
         && (fsync(user_core_fd) != 0 || close(user_core_fd) != 0
            /* user coredump is too big? */
            || (ulimit_c == 0 /* paranoia */ || core_size > ulimit_c)
            )
        ) {
            /* nuke it (silently) */
            xchdir(user_pwd);
            unlink(core_basename);
        }

/* Because of #1211835 and #1126850 */
#if 0
        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    dd_delete(dd);
                    error_msg_and_die(""Error saving '%s'"", path);
                }
                close(src_fd);
            }
        }
#endif

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        path[path_len] = '\0'; /* path now contains only directory name */
        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);

        notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        free(rootdir);
        return 0;
    }

    /* We didn't create abrt dump, but may need to create compat coredump */
 create_user_core:
    if (user_core_fd >= 0)
    {
        off_t core_size = copyfd_size(STDIN_FILENO, user_core_fd, ulimit_c, COPYFD_SPARSE);
        if (fsync(user_core_fd) != 0 || close(user_core_fd) != 0 || core_size < 0)
        {
            /* perror first, otherwise unlink may trash errno */
            perror_msg(""Error writing '%s'"", full_core_basename);
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        if (ulimit_c == 0 || core_size > ulimit_c)
        {
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        log(""Saved core dump of pid %lu to %s (%llu bytes)"", (long)pid, full_core_basename, (long long)core_size);
    }

    return 0;
}
","int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
	fd = xdup(fd);
    if (fd > 2)
	close(fd);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %h */
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME [HOSTNAME]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }

    struct utsname uts;
    if (!argv[8]) /* no HOSTNAME? */
    {
        uname(&uts);
        argv[8] = uts.nodename;
    }

    char path[PATH_MAX];

    int src_fd_binary = -1;
    char *executable = get_executable(pid, setting_SaveBinaryImage ? &src_fd_binary : NULL);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid();
    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
        {
            fsuid = tmp_fsuid;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        goto create_user_core;
    }

    const char *signame = NULL;
    switch (signal_no)
    {
        case SIGILL : signame = ""ILL"" ; break;
        case SIGFPE : signame = ""FPE"" ; break;
        case SIGSEGV: signame = ""SEGV""; break;
        case SIGBUS : signame = ""BUS"" ; break; //Bus error (bad memory access)
        case SIGABRT: signame = ""ABRT""; break; //usually when abort() was called
        case SIGTRAP: signame = ""TRAP""; break; //Trace/breakpoint trap
        default: goto create_user_core; // not a signal we care about
    }

    if (!daemon_is_ok())
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        goto create_user_core;
    }

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            goto create_user_core;
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        goto create_user_core;
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
        snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
        if (core_size < 0 || fsync(abrt_core_fd) != 0)
        {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        return 0;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        goto create_user_core;
    }

    /* use fsuid instead of uid, so we don't expose any sensitive
     * information of suided app in /var/tmp/abrt
     */
    dd = dd_create(path, fsuid, DEFAULT_DUMP_DIR_MODE);
    if (dd)
     {
         char *rootdir = get_rootdir(pid);
 
        dd_create_basic_files(dd, fsuid, (rootdir && strcmp(rootdir, ""/"") != 0) ? rootdir : NULL);
 
         char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
         int source_base_ofs = sprintf(source_filename, ""/proc/%lu/smaps"", (long)pid);
        source_base_ofs -= strlen(""smaps"");
        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;


        strcpy(source_filename + source_base_ofs, ""maps"");
        strcpy(dest_base, FILENAME_MAPS);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(source_filename + source_base_ofs, ""limits"");
        strcpy(dest_base, FILENAME_LIMITS);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        strcpy(dest_base, FILENAME_CGROUP);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        dd_save_text(dd, FILENAME_ANALYZER, ""CCpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        if (src_fd_binary > 0)
        {
            strcpy(path + path_len, ""/""FILENAME_BINARY);
            int dst_fd = create_or_die(path);
            off_t sz = copyfd_eof(src_fd_binary, dst_fd, COPYFD_SPARSE);
            if (fsync(dst_fd) != 0 || close(dst_fd) != 0 || sz < 0)
            {
                dd_delete(dd);
                error_msg_and_die(""Error saving '%s'"", path);
            }
            close(src_fd_binary);
        }

        strcpy(path + path_len, ""/""FILENAME_COREDUMP);
        int abrt_core_fd = create_or_die(path);

        /* We write both coredumps at once.
         * We can't write user coredump first, since it might be truncated
         * and thus can't be copied and used as abrt coredump;
         * and if we write abrt coredump first and then copy it as user one,
         * then we have a race when process exits but coredump does not exist yet:
         * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
         * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
         * 21631 Segmentation fault (core dumped) ./test
         * ls: cannot access core*: No such file or directory <=== BAD
         */
        off_t core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
        if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
        {
            unlink(path);
            dd_delete(dd);
            if (user_core_fd >= 0)
            {
                xchdir(user_pwd);
                unlink(core_basename);
            }
            /* copyfd_sparse logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error writing '%s'"", path);
        }
        if (user_core_fd >= 0
            /* error writing user coredump? */
         && (fsync(user_core_fd) != 0 || close(user_core_fd) != 0
            /* user coredump is too big? */
            || (ulimit_c == 0 /* paranoia */ || core_size > ulimit_c)
            )
        ) {
            /* nuke it (silently) */
            xchdir(user_pwd);
            unlink(core_basename);
        }

/* Because of #1211835 and #1126850 */
#if 0
        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    dd_delete(dd);
                    error_msg_and_die(""Error saving '%s'"", path);
                }
                close(src_fd);
            }
        }
#endif

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        path[path_len] = '\0'; /* path now contains only directory name */
        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);

        notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        free(rootdir);
        return 0;
    }

    /* We didn't create abrt dump, but may need to create compat coredump */
 create_user_core:
    if (user_core_fd >= 0)
    {
        off_t core_size = copyfd_size(STDIN_FILENO, user_core_fd, ulimit_c, COPYFD_SPARSE);
        if (fsync(user_core_fd) != 0 || close(user_core_fd) != 0 || core_size < 0)
        {
            /* perror first, otherwise unlink may trash errno */
            perror_msg(""Error writing '%s'"", full_core_basename);
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        if (ulimit_c == 0 || core_size > ulimit_c)
        {
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        log(""Saved core dump of pid %lu to %s (%llu bytes)"", (long)pid, full_core_basename, (long long)core_size);
    }

    return 0;
}
",C,"        dd_create_basic_files(dd, fsuid, NULL);
","        dd_create_basic_files(dd, fsuid, (rootdir && strcmp(rootdir, ""/"") != 0) ? rootdir : NULL);
",,"@@ -678,7 +678,7 @@ int main(int argc, char** argv)
     {
         char *rootdir = get_rootdir(pid);
 
-        dd_create_basic_files(dd, fsuid, (rootdir && strcmp(rootdir, ""/"") != 0) ? rootdir : NULL);
+        dd_create_basic_files(dd, fsuid, NULL);
 
         char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
         int source_base_ofs = sprintf(source_filename, ""/proc/%lu/smaps"", (long)pid);",abrt,4f2c1ddd3e3b81d2d5146b883115371f1cada9f9,17cb66b13997b0159b4253b3f5722db79f476d68,1,"int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
	fd = xdup(fd);
    if (fd > 2)
	close(fd);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %h */
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME [HOSTNAME]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }

    struct utsname uts;
    if (!argv[8]) /* no HOSTNAME? */
    {
        uname(&uts);
        argv[8] = uts.nodename;
    }

    char path[PATH_MAX];

    int src_fd_binary = -1;
    char *executable = get_executable(pid, setting_SaveBinaryImage ? &src_fd_binary : NULL);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid();
    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
        {
            fsuid = tmp_fsuid;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        goto create_user_core;
    }

    const char *signame = NULL;
    switch (signal_no)
    {
        case SIGILL : signame = ""ILL"" ; break;
        case SIGFPE : signame = ""FPE"" ; break;
        case SIGSEGV: signame = ""SEGV""; break;
        case SIGBUS : signame = ""BUS"" ; break; //Bus error (bad memory access)
        case SIGABRT: signame = ""ABRT""; break; //usually when abort() was called
    // We have real-world reports from users who see buggy programs
    // dying with SIGTRAP, uncommented it too:
        case SIGTRAP: signame = ""TRAP""; break; //Trace/breakpoint trap
    // These usually aren't caused by bugs:
      //case SIGQUIT: signame = ""QUIT""; break; //Quit from keyboard
      //case SIGSYS : signame = ""SYS"" ; break; //Bad argument to routine (SVr4)
      //case SIGXCPU: signame = ""XCPU""; break; //CPU time limit exceeded (4.2BSD)
      //case SIGXFSZ: signame = ""XFSZ""; break; //File size limit exceeded (4.2BSD)
        default: goto create_user_core; // not a signal we care about
    }

    if (!daemon_is_ok())
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        goto create_user_core;
    }

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            goto create_user_core;
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        goto create_user_core;
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
        snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
        if (core_size < 0 || fsync(abrt_core_fd) != 0)
        {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        return 0;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        goto create_user_core;
    }

    /* use fsuid instead of uid, so we don't expose any sensitive
     * information of suided app in /var/tmp/abrt
     */
    dd = dd_create(path, fsuid, DEFAULT_DUMP_DIR_MODE);
    if (dd)
     {
         char *rootdir = get_rootdir(pid);
 
//flaw_line_below:
        dd_create_basic_files(dd, fsuid, (rootdir && strcmp(rootdir, ""/"") != 0) ? rootdir : NULL);
//fix_flaw_line_below:
//        dd_create_basic_files(dd, fsuid, NULL);
 
         char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
         int source_base_ofs = sprintf(source_filename, ""/proc/%lu/smaps"", (long)pid);
        source_base_ofs -= strlen(""smaps"");
        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;

        // Disabled for now: /proc/PID/smaps tends to be BIG,
        // and not much more informative than /proc/PID/maps:
        //copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(source_filename + source_base_ofs, ""maps"");
        strcpy(dest_base, FILENAME_MAPS);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(source_filename + source_base_ofs, ""limits"");
        strcpy(dest_base, FILENAME_LIMITS);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        strcpy(dest_base, FILENAME_CGROUP);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        dd_save_text(dd, FILENAME_ANALYZER, ""CCpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        if (src_fd_binary > 0)
        {
            strcpy(path + path_len, ""/""FILENAME_BINARY);
            int dst_fd = create_or_die(path);
            off_t sz = copyfd_eof(src_fd_binary, dst_fd, COPYFD_SPARSE);
            if (fsync(dst_fd) != 0 || close(dst_fd) != 0 || sz < 0)
            {
                dd_delete(dd);
                error_msg_and_die(""Error saving '%s'"", path);
            }
            close(src_fd_binary);
        }

        strcpy(path + path_len, ""/""FILENAME_COREDUMP);
        int abrt_core_fd = create_or_die(path);

        /* We write both coredumps at once.
         * We can't write user coredump first, since it might be truncated
         * and thus can't be copied and used as abrt coredump;
         * and if we write abrt coredump first and then copy it as user one,
         * then we have a race when process exits but coredump does not exist yet:
         * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
         * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
         * 21631 Segmentation fault (core dumped) ./test
         * ls: cannot access core*: No such file or directory <=== BAD
         */
        off_t core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
        if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
        {
            unlink(path);
            dd_delete(dd);
            if (user_core_fd >= 0)
            {
                xchdir(user_pwd);
                unlink(core_basename);
            }
            /* copyfd_sparse logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error writing '%s'"", path);
        }
        if (user_core_fd >= 0
            /* error writing user coredump? */
         && (fsync(user_core_fd) != 0 || close(user_core_fd) != 0
            /* user coredump is too big? */
            || (ulimit_c == 0 /* paranoia */ || core_size > ulimit_c)
            )
        ) {
            /* nuke it (silently) */
            xchdir(user_pwd);
            unlink(core_basename);
        }

/* Because of #1211835 and #1126850 */
#if 0
        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    dd_delete(dd);
                    error_msg_and_die(""Error saving '%s'"", path);
                }
                close(src_fd);
            }
        }
#endif

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        path[path_len] = '\0'; /* path now contains only directory name */
        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);

        notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        free(rootdir);
        return 0;
    }

    /* We didn't create abrt dump, but may need to create compat coredump */
 create_user_core:
    if (user_core_fd >= 0)
    {
        off_t core_size = copyfd_size(STDIN_FILENO, user_core_fd, ulimit_c, COPYFD_SPARSE);
        if (fsync(user_core_fd) != 0 || close(user_core_fd) != 0 || core_size < 0)
        {
            /* perror first, otherwise unlink may trash errno */
            perror_msg(""Error writing '%s'"", full_core_basename);
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        if (ulimit_c == 0 || core_size > ulimit_c)
        {
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        log(""Saved core dump of pid %lu to %s (%llu bytes)"", (long)pid, full_core_basename, (long long)core_size);
    }

    return 0;
}
"
5572,183308,,Local,Not required,Complete,CVE-2015-3315,https://www.cvedetails.com/cve/CVE-2015-3315/,CWE-59,Low,Complete,Complete,,2017-06-26,7.2,"Automatic Bug Reporting Tool (ABRT) allows local users to read, change the ownership of, or have other unspecified impact on arbitrary files via a symlink attack on (1) /var/tmp/abrt/*/maps, (2) /tmp/jvm-*/hs_error.log, (3) /proc/*/exe, (4) /etc/os-release in a chroot, or (5) an unspecified root directory related to librpm.",2018-02-18,,11,https://github.com/abrt/abrt/commit/80408e9e24a1c10f85fd969e1853e0f192157f92,80408e9e24a1c10f85fd969e1853e0f192157f92,"ccpp: fix symlink race conditions

Fix copy & chown race conditions

Related: #1211835

Signed-off-by: Jakub Filak <jfilak@redhat.com>",0,src/hooks/abrt-hook-ccpp.c,"{""sha"": ""be16fab8ae037b47d08f9e0b1e70c85184a11055"", ""filename"": ""src/hooks/abrt-hook-ccpp.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 11, ""changes"": 27, ""blob_url"": ""https://github.com/abrt/abrt/blob/80408e9e24a1c10f85fd969e1853e0f192157f92/src/hooks/abrt-hook-ccpp.c"", ""raw_url"": ""https://github.com/abrt/abrt/raw/80408e9e24a1c10f85fd969e1853e0f192157f92/src/hooks/abrt-hook-ccpp.c"", ""contents_url"": ""https://api.github.com/repos/abrt/abrt/contents/src/hooks/abrt-hook-ccpp.c?ref=80408e9e24a1c10f85fd969e1853e0f192157f92"", ""patch"": ""@@ -397,7 +397,7 @@ static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_valu\n     return user_core_fd;\n }\n \n-static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)\n+static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)\n {\n     FILE *fp = fopen(dest_filename, \""w\"");\n     if (!fp)\n@@ -429,6 +429,16 @@ static bool dump_fd_info(const char *dest_filename, char *source_filename, int s\n         }\n         fclose(in);\n     }\n+\n+    const int dest_fd = fileno(fp);\n+    if (fchown(dest_fd, uid, gid) < 0)\n+    {\n+        perror_msg(\""Can't change '%s' ownership to %lu:%lu\"", dest_filename, (long)uid, (long)gid);\n+        fclose(fp);\n+        unlink(dest_filename);\n+        return false;\n+    }\n+\n     fclose(fp);\n     return true;\n }\n@@ -678,27 +688,22 @@ int main(int argc, char** argv)\n \n         // Disabled for now: /proc/PID/smaps tends to be BIG,\n         // and not much more informative than /proc/PID/maps:\n-        //copy_file(source_filename, dest_filename, 0640);\n-        //chown(dest_filename, dd->dd_uid, dd->dd_gid);\n+        //copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);\n \n         strcpy(source_filename + source_base_ofs, \""maps\"");\n         strcpy(dest_base, FILENAME_MAPS);\n-        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);\n-        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));\n+        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);\n \n         strcpy(source_filename + source_base_ofs, \""limits\"");\n         strcpy(dest_base, FILENAME_LIMITS);\n-        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);\n-        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));\n+        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);\n \n         strcpy(source_filename + source_base_ofs, \""cgroup\"");\n         strcpy(dest_base, FILENAME_CGROUP);\n-        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);\n-        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));\n+        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);\n \n         strcpy(dest_base, FILENAME_OPEN_FDS);\n-        if (dump_fd_info(dest_filename, source_filename, source_base_ofs))\n-            IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));\n+        dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);\n \n         free(dest_filename);\n ""}","static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)
static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
     FILE *fp = fopen(dest_filename, ""w"");
     if (!fp)
        return false;

    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
         }
         fclose(in);
     }

    const int dest_fd = fileno(fp);
    if (fchown(dest_fd, uid, gid) < 0)
    {
        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
        fclose(fp);
        unlink(dest_filename);
        return false;
    }

     fclose(fp);
     return true;
 }
","static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)
 {
     FILE *fp = fopen(dest_filename, ""w"");
     if (!fp)
        return false;

    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
         }
         fclose(in);
     }
     fclose(fp);
     return true;
 }
",C,"static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)

    const int dest_fd = fileno(fp);
    if (fchown(dest_fd, uid, gid) < 0)
    {
        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
        fclose(fp);
        unlink(dest_filename);
        return false;
    }

",,,"@@ -397,7 +397,7 @@ static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_valu
     return user_core_fd;
 }
 
-static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)
+static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
     FILE *fp = fopen(dest_filename, ""w"");
     if (!fp)
@@ -429,6 +429,16 @@ static bool dump_fd_info(const char *dest_filename, char *source_filename, int s
         }
         fclose(in);
     }
+
+    const int dest_fd = fileno(fp);
+    if (fchown(dest_fd, uid, gid) < 0)
+    {
+        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
+        fclose(fp);
+        unlink(dest_filename);
+        return false;
+    }
+
     fclose(fp);
     return true;
 }
@@ -678,27 +688,22 @@ int main(int argc, char** argv)
 
         // Disabled for now: /proc/PID/smaps tends to be BIG,
         // and not much more informative than /proc/PID/maps:
-        //copy_file(source_filename, dest_filename, 0640);
-        //chown(dest_filename, dd->dd_uid, dd->dd_gid);
+        //copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(source_filename + source_base_ofs, ""maps"");
         strcpy(dest_base, FILENAME_MAPS);
-        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);
-        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
+        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(source_filename + source_base_ofs, ""limits"");
         strcpy(dest_base, FILENAME_LIMITS);
-        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);
-        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
+        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(source_filename + source_base_ofs, ""cgroup"");
         strcpy(dest_base, FILENAME_CGROUP);
-        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);
-        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
+        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(dest_base, FILENAME_OPEN_FDS);
-        if (dump_fd_info(dest_filename, source_filename, source_base_ofs))
-            IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
+        dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);
 
         free(dest_filename);
 ",abrt,80408e9e24a1c10f85fd969e1853e0f192157f92,fdf93685d4f3fc36fe50d34a11e24662c4cb2d8c,1,"static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)
//fix_flaw_line_below:
//static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
     FILE *fp = fopen(dest_filename, ""w"");
     if (!fp)
        return false;

    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
         }
         fclose(in);
     }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    const int dest_fd = fileno(fp);
//fix_flaw_line_below:
//    if (fchown(dest_fd, uid, gid) < 0)
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
//fix_flaw_line_below:
//        fclose(fp);
//fix_flaw_line_below:
//        unlink(dest_filename);
//fix_flaw_line_below:
//        return false;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     fclose(fp);
     return true;
 }
"
5573,183309,,Local,Not required,Complete,CVE-2015-3315,https://www.cvedetails.com/cve/CVE-2015-3315/,CWE-59,Low,Complete,Complete,,2017-06-26,7.2,"Automatic Bug Reporting Tool (ABRT) allows local users to read, change the ownership of, or have other unspecified impact on arbitrary files via a symlink attack on (1) /var/tmp/abrt/*/maps, (2) /tmp/jvm-*/hs_error.log, (3) /proc/*/exe, (4) /etc/os-release in a chroot, or (5) an unspecified root directory related to librpm.",2018-02-18,,5,https://github.com/abrt/abrt/commit/80408e9e24a1c10f85fd969e1853e0f192157f92,80408e9e24a1c10f85fd969e1853e0f192157f92,"ccpp: fix symlink race conditions

Fix copy & chown race conditions

Related: #1211835

Signed-off-by: Jakub Filak <jfilak@redhat.com>",8,src/hooks/abrt-hook-ccpp.c,"{""sha"": ""be16fab8ae037b47d08f9e0b1e70c85184a11055"", ""filename"": ""src/hooks/abrt-hook-ccpp.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 11, ""changes"": 27, ""blob_url"": ""https://github.com/abrt/abrt/blob/80408e9e24a1c10f85fd969e1853e0f192157f92/src/hooks/abrt-hook-ccpp.c"", ""raw_url"": ""https://github.com/abrt/abrt/raw/80408e9e24a1c10f85fd969e1853e0f192157f92/src/hooks/abrt-hook-ccpp.c"", ""contents_url"": ""https://api.github.com/repos/abrt/abrt/contents/src/hooks/abrt-hook-ccpp.c?ref=80408e9e24a1c10f85fd969e1853e0f192157f92"", ""patch"": ""@@ -397,7 +397,7 @@ static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_valu\n     return user_core_fd;\n }\n \n-static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)\n+static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)\n {\n     FILE *fp = fopen(dest_filename, \""w\"");\n     if (!fp)\n@@ -429,6 +429,16 @@ static bool dump_fd_info(const char *dest_filename, char *source_filename, int s\n         }\n         fclose(in);\n     }\n+\n+    const int dest_fd = fileno(fp);\n+    if (fchown(dest_fd, uid, gid) < 0)\n+    {\n+        perror_msg(\""Can't change '%s' ownership to %lu:%lu\"", dest_filename, (long)uid, (long)gid);\n+        fclose(fp);\n+        unlink(dest_filename);\n+        return false;\n+    }\n+\n     fclose(fp);\n     return true;\n }\n@@ -678,27 +688,22 @@ int main(int argc, char** argv)\n \n         // Disabled for now: /proc/PID/smaps tends to be BIG,\n         // and not much more informative than /proc/PID/maps:\n-        //copy_file(source_filename, dest_filename, 0640);\n-        //chown(dest_filename, dd->dd_uid, dd->dd_gid);\n+        //copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);\n \n         strcpy(source_filename + source_base_ofs, \""maps\"");\n         strcpy(dest_base, FILENAME_MAPS);\n-        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);\n-        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));\n+        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);\n \n         strcpy(source_filename + source_base_ofs, \""limits\"");\n         strcpy(dest_base, FILENAME_LIMITS);\n-        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);\n-        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));\n+        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);\n \n         strcpy(source_filename + source_base_ofs, \""cgroup\"");\n         strcpy(dest_base, FILENAME_CGROUP);\n-        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);\n-        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));\n+        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);\n \n         strcpy(dest_base, FILENAME_OPEN_FDS);\n-        if (dump_fd_info(dest_filename, source_filename, source_base_ofs))\n-            IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));\n+        dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);\n \n         free(dest_filename);\n ""}","int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
	fd = xdup(fd);
    if (fd > 2)
	close(fd);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %h */
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME [HOSTNAME]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }

    struct utsname uts;
    if (!argv[8]) /* no HOSTNAME? */
    {
        uname(&uts);
        argv[8] = uts.nodename;
    }

    char path[PATH_MAX];

    int src_fd_binary = -1;
    char *executable = get_executable(pid, setting_SaveBinaryImage ? &src_fd_binary : NULL);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid();
    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
        {
            fsuid = tmp_fsuid;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        goto create_user_core;
    }

    const char *signame = NULL;
    switch (signal_no)
    {
        case SIGILL : signame = ""ILL"" ; break;
        case SIGFPE : signame = ""FPE"" ; break;
        case SIGSEGV: signame = ""SEGV""; break;
        case SIGBUS : signame = ""BUS"" ; break; //Bus error (bad memory access)
        case SIGABRT: signame = ""ABRT""; break; //usually when abort() was called
        case SIGTRAP: signame = ""TRAP""; break; //Trace/breakpoint trap
        default: goto create_user_core; // not a signal we care about
    }

    if (!daemon_is_ok())
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        goto create_user_core;
    }

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            goto create_user_core;
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        goto create_user_core;
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
        snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
        if (core_size < 0 || fsync(abrt_core_fd) != 0)
        {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        return 0;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        goto create_user_core;
    }

    /* use fsuid instead of uid, so we don't expose any sensitive
     * information of suided app in /var/tmp/abrt
     */
    dd = dd_create(path, fsuid, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char *rootdir = get_rootdir(pid);

        dd_create_basic_files(dd, fsuid, (rootdir && strcmp(rootdir, ""/"") != 0) ? rootdir : NULL);

        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/smaps"", (long)pid);
        source_base_ofs -= strlen(""smaps"");
        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;
 
        //copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(source_filename + source_base_ofs, ""maps"");
         strcpy(dest_base, FILENAME_MAPS);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(source_filename + source_base_ofs, ""limits"");
         strcpy(dest_base, FILENAME_LIMITS);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(source_filename + source_base_ofs, ""cgroup"");
         strcpy(dest_base, FILENAME_CGROUP);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(dest_base, FILENAME_OPEN_FDS);
        dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);
 
         free(dest_filename);
 
        dd_save_text(dd, FILENAME_ANALYZER, ""CCpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        if (src_fd_binary > 0)
        {
            strcpy(path + path_len, ""/""FILENAME_BINARY);
            int dst_fd = create_or_die(path);
            off_t sz = copyfd_eof(src_fd_binary, dst_fd, COPYFD_SPARSE);
            if (fsync(dst_fd) != 0 || close(dst_fd) != 0 || sz < 0)
            {
                dd_delete(dd);
                error_msg_and_die(""Error saving '%s'"", path);
            }
            close(src_fd_binary);
        }

        strcpy(path + path_len, ""/""FILENAME_COREDUMP);
        int abrt_core_fd = create_or_die(path);

        /* We write both coredumps at once.
         * We can't write user coredump first, since it might be truncated
         * and thus can't be copied and used as abrt coredump;
         * and if we write abrt coredump first and then copy it as user one,
         * then we have a race when process exits but coredump does not exist yet:
         * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
         * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
         * 21631 Segmentation fault (core dumped) ./test
         * ls: cannot access core*: No such file or directory <=== BAD
         */
        off_t core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
        if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
        {
            unlink(path);
            dd_delete(dd);
            if (user_core_fd >= 0)
            {
                xchdir(user_pwd);
                unlink(core_basename);
            }
            /* copyfd_sparse logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error writing '%s'"", path);
        }
        if (user_core_fd >= 0
            /* error writing user coredump? */
         && (fsync(user_core_fd) != 0 || close(user_core_fd) != 0
            /* user coredump is too big? */
            || (ulimit_c == 0 /* paranoia */ || core_size > ulimit_c)
            )
        ) {
            /* nuke it (silently) */
            xchdir(user_pwd);
            unlink(core_basename);
        }

        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    dd_delete(dd);
                    error_msg_and_die(""Error saving '%s'"", path);
                }
                close(src_fd);
            }
        }

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        path[path_len] = '\0'; /* path now contains only directory name */
        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);

        notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        free(rootdir);
        return 0;
    }

    /* We didn't create abrt dump, but may need to create compat coredump */
 create_user_core:
    if (user_core_fd >= 0)
    {
        off_t core_size = copyfd_size(STDIN_FILENO, user_core_fd, ulimit_c, COPYFD_SPARSE);
        if (fsync(user_core_fd) != 0 || close(user_core_fd) != 0 || core_size < 0)
        {
            /* perror first, otherwise unlink may trash errno */
            perror_msg(""Error writing '%s'"", full_core_basename);
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        if (ulimit_c == 0 || core_size > ulimit_c)
        {
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        log(""Saved core dump of pid %lu to %s (%llu bytes)"", (long)pid, full_core_basename, (long long)core_size);
    }

    return 0;
}
","int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
	fd = xdup(fd);
    if (fd > 2)
	close(fd);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %h */
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME [HOSTNAME]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }

    struct utsname uts;
    if (!argv[8]) /* no HOSTNAME? */
    {
        uname(&uts);
        argv[8] = uts.nodename;
    }

    char path[PATH_MAX];

    int src_fd_binary = -1;
    char *executable = get_executable(pid, setting_SaveBinaryImage ? &src_fd_binary : NULL);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid();
    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
        {
            fsuid = tmp_fsuid;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        goto create_user_core;
    }

    const char *signame = NULL;
    switch (signal_no)
    {
        case SIGILL : signame = ""ILL"" ; break;
        case SIGFPE : signame = ""FPE"" ; break;
        case SIGSEGV: signame = ""SEGV""; break;
        case SIGBUS : signame = ""BUS"" ; break; //Bus error (bad memory access)
        case SIGABRT: signame = ""ABRT""; break; //usually when abort() was called
        case SIGTRAP: signame = ""TRAP""; break; //Trace/breakpoint trap
        default: goto create_user_core; // not a signal we care about
    }

    if (!daemon_is_ok())
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        goto create_user_core;
    }

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            goto create_user_core;
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        goto create_user_core;
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
        snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
        if (core_size < 0 || fsync(abrt_core_fd) != 0)
        {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        return 0;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        goto create_user_core;
    }

    /* use fsuid instead of uid, so we don't expose any sensitive
     * information of suided app in /var/tmp/abrt
     */
    dd = dd_create(path, fsuid, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char *rootdir = get_rootdir(pid);

        dd_create_basic_files(dd, fsuid, (rootdir && strcmp(rootdir, ""/"") != 0) ? rootdir : NULL);

        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/smaps"", (long)pid);
        source_base_ofs -= strlen(""smaps"");
        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;
 
 
         strcpy(source_filename + source_base_ofs, ""maps"");
         strcpy(dest_base, FILENAME_MAPS);
        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);
        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
 
         strcpy(source_filename + source_base_ofs, ""limits"");
         strcpy(dest_base, FILENAME_LIMITS);
        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);
        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
 
         strcpy(source_filename + source_base_ofs, ""cgroup"");
         strcpy(dest_base, FILENAME_CGROUP);
        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);
        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
 
         strcpy(dest_base, FILENAME_OPEN_FDS);
        if (dump_fd_info(dest_filename, source_filename, source_base_ofs))
            IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
 
         free(dest_filename);
 
        dd_save_text(dd, FILENAME_ANALYZER, ""CCpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        if (src_fd_binary > 0)
        {
            strcpy(path + path_len, ""/""FILENAME_BINARY);
            int dst_fd = create_or_die(path);
            off_t sz = copyfd_eof(src_fd_binary, dst_fd, COPYFD_SPARSE);
            if (fsync(dst_fd) != 0 || close(dst_fd) != 0 || sz < 0)
            {
                dd_delete(dd);
                error_msg_and_die(""Error saving '%s'"", path);
            }
            close(src_fd_binary);
        }

        strcpy(path + path_len, ""/""FILENAME_COREDUMP);
        int abrt_core_fd = create_or_die(path);

        /* We write both coredumps at once.
         * We can't write user coredump first, since it might be truncated
         * and thus can't be copied and used as abrt coredump;
         * and if we write abrt coredump first and then copy it as user one,
         * then we have a race when process exits but coredump does not exist yet:
         * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
         * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
         * 21631 Segmentation fault (core dumped) ./test
         * ls: cannot access core*: No such file or directory <=== BAD
         */
        off_t core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
        if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
        {
            unlink(path);
            dd_delete(dd);
            if (user_core_fd >= 0)
            {
                xchdir(user_pwd);
                unlink(core_basename);
            }
            /* copyfd_sparse logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error writing '%s'"", path);
        }
        if (user_core_fd >= 0
            /* error writing user coredump? */
         && (fsync(user_core_fd) != 0 || close(user_core_fd) != 0
            /* user coredump is too big? */
            || (ulimit_c == 0 /* paranoia */ || core_size > ulimit_c)
            )
        ) {
            /* nuke it (silently) */
            xchdir(user_pwd);
            unlink(core_basename);
        }

        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    dd_delete(dd);
                    error_msg_and_die(""Error saving '%s'"", path);
                }
                close(src_fd);
            }
        }

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        path[path_len] = '\0'; /* path now contains only directory name */
        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);

        notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        free(rootdir);
        return 0;
    }

    /* We didn't create abrt dump, but may need to create compat coredump */
 create_user_core:
    if (user_core_fd >= 0)
    {
        off_t core_size = copyfd_size(STDIN_FILENO, user_core_fd, ulimit_c, COPYFD_SPARSE);
        if (fsync(user_core_fd) != 0 || close(user_core_fd) != 0 || core_size < 0)
        {
            /* perror first, otherwise unlink may trash errno */
            perror_msg(""Error writing '%s'"", full_core_basename);
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        if (ulimit_c == 0 || core_size > ulimit_c)
        {
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        log(""Saved core dump of pid %lu to %s (%llu bytes)"", (long)pid, full_core_basename, (long long)core_size);
    }

    return 0;
}
",C,"        //copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
        dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);
","        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);
        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);
        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);
        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
        if (dump_fd_info(dest_filename, source_filename, source_base_ofs))
            IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
",,"@@ -397,7 +397,7 @@ static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_valu
     return user_core_fd;
 }
 
-static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)
+static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
     FILE *fp = fopen(dest_filename, ""w"");
     if (!fp)
@@ -429,6 +429,16 @@ static bool dump_fd_info(const char *dest_filename, char *source_filename, int s
         }
         fclose(in);
     }
+
+    const int dest_fd = fileno(fp);
+    if (fchown(dest_fd, uid, gid) < 0)
+    {
+        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
+        fclose(fp);
+        unlink(dest_filename);
+        return false;
+    }
+
     fclose(fp);
     return true;
 }
@@ -678,27 +688,22 @@ int main(int argc, char** argv)
 
         // Disabled for now: /proc/PID/smaps tends to be BIG,
         // and not much more informative than /proc/PID/maps:
-        //copy_file(source_filename, dest_filename, 0640);
-        //chown(dest_filename, dd->dd_uid, dd->dd_gid);
+        //copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(source_filename + source_base_ofs, ""maps"");
         strcpy(dest_base, FILENAME_MAPS);
-        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);
-        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
+        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(source_filename + source_base_ofs, ""limits"");
         strcpy(dest_base, FILENAME_LIMITS);
-        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);
-        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
+        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(source_filename + source_base_ofs, ""cgroup"");
         strcpy(dest_base, FILENAME_CGROUP);
-        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);
-        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
+        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(dest_base, FILENAME_OPEN_FDS);
-        if (dump_fd_info(dest_filename, source_filename, source_base_ofs))
-            IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
+        dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);
 
         free(dest_filename);
 ",abrt,80408e9e24a1c10f85fd969e1853e0f192157f92,fdf93685d4f3fc36fe50d34a11e24662c4cb2d8c,1,"int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
	fd = xdup(fd);
    if (fd > 2)
	close(fd);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %h */
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME [HOSTNAME]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }

    struct utsname uts;
    if (!argv[8]) /* no HOSTNAME? */
    {
        uname(&uts);
        argv[8] = uts.nodename;
    }

    char path[PATH_MAX];

    int src_fd_binary = -1;
    char *executable = get_executable(pid, setting_SaveBinaryImage ? &src_fd_binary : NULL);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid();
    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
        {
            fsuid = tmp_fsuid;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        goto create_user_core;
    }

    const char *signame = NULL;
    switch (signal_no)
    {
        case SIGILL : signame = ""ILL"" ; break;
        case SIGFPE : signame = ""FPE"" ; break;
        case SIGSEGV: signame = ""SEGV""; break;
        case SIGBUS : signame = ""BUS"" ; break; //Bus error (bad memory access)
        case SIGABRT: signame = ""ABRT""; break; //usually when abort() was called
    // We have real-world reports from users who see buggy programs
    // dying with SIGTRAP, uncommented it too:
        case SIGTRAP: signame = ""TRAP""; break; //Trace/breakpoint trap
    // These usually aren't caused by bugs:
      //case SIGQUIT: signame = ""QUIT""; break; //Quit from keyboard
      //case SIGSYS : signame = ""SYS"" ; break; //Bad argument to routine (SVr4)
      //case SIGXCPU: signame = ""XCPU""; break; //CPU time limit exceeded (4.2BSD)
      //case SIGXFSZ: signame = ""XFSZ""; break; //File size limit exceeded (4.2BSD)
        default: goto create_user_core; // not a signal we care about
    }

    if (!daemon_is_ok())
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        goto create_user_core;
    }

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            goto create_user_core;
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        goto create_user_core;
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
        snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
        if (core_size < 0 || fsync(abrt_core_fd) != 0)
        {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        return 0;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        goto create_user_core;
    }

    /* use fsuid instead of uid, so we don't expose any sensitive
     * information of suided app in /var/tmp/abrt
     */
    dd = dd_create(path, fsuid, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char *rootdir = get_rootdir(pid);

        dd_create_basic_files(dd, fsuid, (rootdir && strcmp(rootdir, ""/"") != 0) ? rootdir : NULL);

        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/smaps"", (long)pid);
        source_base_ofs -= strlen(""smaps"");
        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;
 
         // Disabled for now: /proc/PID/smaps tends to be BIG,
         // and not much more informative than /proc/PID/maps:
//flaw_line_below:
        //copy_file(source_filename, dest_filename, 0640);
//flaw_line_below:
        //chown(dest_filename, dd->dd_uid, dd->dd_gid);
//fix_flaw_line_below:
//        //copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(source_filename + source_base_ofs, ""maps"");
         strcpy(dest_base, FILENAME_MAPS);
//flaw_line_below:
        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);
//flaw_line_below:
        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
//fix_flaw_line_below:
//        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(source_filename + source_base_ofs, ""limits"");
         strcpy(dest_base, FILENAME_LIMITS);
//flaw_line_below:
        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);
//flaw_line_below:
        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
//fix_flaw_line_below:
//        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(source_filename + source_base_ofs, ""cgroup"");
         strcpy(dest_base, FILENAME_CGROUP);
//flaw_line_below:
        copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);
//flaw_line_below:
        IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
//fix_flaw_line_below:
//        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(dest_base, FILENAME_OPEN_FDS);
//flaw_line_below:
        if (dump_fd_info(dest_filename, source_filename, source_base_ofs))
//flaw_line_below:
            IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));
//fix_flaw_line_below:
//        dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);
 
         free(dest_filename);
 
        dd_save_text(dd, FILENAME_ANALYZER, ""CCpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        if (src_fd_binary > 0)
        {
            strcpy(path + path_len, ""/""FILENAME_BINARY);
            int dst_fd = create_or_die(path);
            off_t sz = copyfd_eof(src_fd_binary, dst_fd, COPYFD_SPARSE);
            if (fsync(dst_fd) != 0 || close(dst_fd) != 0 || sz < 0)
            {
                dd_delete(dd);
                error_msg_and_die(""Error saving '%s'"", path);
            }
            close(src_fd_binary);
        }

        strcpy(path + path_len, ""/""FILENAME_COREDUMP);
        int abrt_core_fd = create_or_die(path);

        /* We write both coredumps at once.
         * We can't write user coredump first, since it might be truncated
         * and thus can't be copied and used as abrt coredump;
         * and if we write abrt coredump first and then copy it as user one,
         * then we have a race when process exits but coredump does not exist yet:
         * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
         * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
         * 21631 Segmentation fault (core dumped) ./test
         * ls: cannot access core*: No such file or directory <=== BAD
         */
        off_t core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
        if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
        {
            unlink(path);
            dd_delete(dd);
            if (user_core_fd >= 0)
            {
                xchdir(user_pwd);
                unlink(core_basename);
            }
            /* copyfd_sparse logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error writing '%s'"", path);
        }
        if (user_core_fd >= 0
            /* error writing user coredump? */
         && (fsync(user_core_fd) != 0 || close(user_core_fd) != 0
            /* user coredump is too big? */
            || (ulimit_c == 0 /* paranoia */ || core_size > ulimit_c)
            )
        ) {
            /* nuke it (silently) */
            xchdir(user_pwd);
            unlink(core_basename);
        }

        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    dd_delete(dd);
                    error_msg_and_die(""Error saving '%s'"", path);
                }
                close(src_fd);
            }
        }

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        path[path_len] = '\0'; /* path now contains only directory name */
        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);

        notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        free(rootdir);
        return 0;
    }

    /* We didn't create abrt dump, but may need to create compat coredump */
 create_user_core:
    if (user_core_fd >= 0)
    {
        off_t core_size = copyfd_size(STDIN_FILENO, user_core_fd, ulimit_c, COPYFD_SPARSE);
        if (fsync(user_core_fd) != 0 || close(user_core_fd) != 0 || core_size < 0)
        {
            /* perror first, otherwise unlink may trash errno */
            perror_msg(""Error writing '%s'"", full_core_basename);
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        if (ulimit_c == 0 || core_size > ulimit_c)
        {
            xchdir(user_pwd);
            unlink(core_basename);
            return 1;
        }
        log(""Saved core dump of pid %lu to %s (%llu bytes)"", (long)pid, full_core_basename, (long long)core_size);
    }

    return 0;
}
"
5574,183310,,Local,Not required,Complete,CVE-2015-3315,https://www.cvedetails.com/cve/CVE-2015-3315/,CWE-59,Low,Complete,Complete,,2017-06-26,7.2,"Automatic Bug Reporting Tool (ABRT) allows local users to read, change the ownership of, or have other unspecified impact on arbitrary files via a symlink attack on (1) /var/tmp/abrt/*/maps, (2) /tmp/jvm-*/hs_error.log, (3) /proc/*/exe, (4) /etc/os-release in a chroot, or (5) an unspecified root directory related to librpm.",2018-02-18,,1,https://github.com/abrt/abrt/commit/d6e2f6f128cef4c21cb80941ae674c9842681aa7,d6e2f6f128cef4c21cb80941ae674c9842681aa7,"ccpp: open file for dump_fd_info with O_EXCL

To avoid possible races.

Related: #1211835

Signed-off-by: Jakub Filak <jfilak@redhat.com>",1,src/hooks/abrt-hook-ccpp.c,"{""sha"": ""ece1ecebc00cabdb05bb06a6d80a6289d58968b7"", ""filename"": ""src/hooks/abrt-hook-ccpp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/abrt/abrt/blob/d6e2f6f128cef4c21cb80941ae674c9842681aa7/src/hooks/abrt-hook-ccpp.c"", ""raw_url"": ""https://github.com/abrt/abrt/raw/d6e2f6f128cef4c21cb80941ae674c9842681aa7/src/hooks/abrt-hook-ccpp.c"", ""contents_url"": ""https://api.github.com/repos/abrt/abrt/contents/src/hooks/abrt-hook-ccpp.c?ref=d6e2f6f128cef4c21cb80941ae674c9842681aa7"", ""patch"": ""@@ -399,7 +399,7 @@ static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_valu\n \n static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)\n {\n-    FILE *fp = fopen(dest_filename, \""w\"");\n+    FILE *fp = fopen(dest_filename, \""wx\"");\n     if (!fp)\n         return false;\n ""}"," static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
    FILE *fp = fopen(dest_filename, ""wx"");
     if (!fp)
         return false;
 
    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }

    const int dest_fd = fileno(fp);
    if (fchown(dest_fd, uid, gid) < 0)
    {
        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
        fclose(fp);
        unlink(dest_filename);
        return false;
    }

    fclose(fp);
    return true;
}
"," static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
    FILE *fp = fopen(dest_filename, ""w"");
     if (!fp)
         return false;
 
    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }

    const int dest_fd = fileno(fp);
    if (fchown(dest_fd, uid, gid) < 0)
    {
        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
        fclose(fp);
        unlink(dest_filename);
        return false;
    }

    fclose(fp);
    return true;
}
",C,"    FILE *fp = fopen(dest_filename, ""wx"");
","    FILE *fp = fopen(dest_filename, ""w"");
",,"@@ -399,7 +399,7 @@ static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_valu
 
 static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
-    FILE *fp = fopen(dest_filename, ""w"");
+    FILE *fp = fopen(dest_filename, ""wx"");
     if (!fp)
         return false;
 ",abrt,d6e2f6f128cef4c21cb80941ae674c9842681aa7,4f2c1ddd3e3b81d2d5146b883115371f1cada9f9,1," static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
//flaw_line_below:
    FILE *fp = fopen(dest_filename, ""w"");
//fix_flaw_line_below:
//    FILE *fp = fopen(dest_filename, ""wx"");
     if (!fp)
         return false;
 
    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }

    const int dest_fd = fileno(fp);
    if (fchown(dest_fd, uid, gid) < 0)
    {
        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
        fclose(fp);
        unlink(dest_filename);
        return false;
    }

    fclose(fp);
    return true;
}
"
5612,183348,,Local,Not required,Complete,CVE-2017-7500,https://www.cvedetails.com/cve/CVE-2017-7500/,CWE-59,Low,Complete,Complete,,2018-08-13,7.2,"It was found that rpm did not properly handle RPM installations when a destination path was a symbolic link to a directory, possibly changing ownership and permissions of an arbitrary directory, and RPM files being placed in an arbitrary destination. An attacker, with write access to a directory in which a subdirectory will be installed, could redirect that directory to an arbitrary location and gain root privilege.",2019-10-09,+Priv ,5,https://github.com/rpm-software-management/rpm/commit/f2d3be2a8741234faaa96f5fd05fdfdc75779a79,f2d3be2a8741234faaa96f5fd05fdfdc75779a79,"Restrict following symlinks to directories by ownership (CVE-2017-7500)

Only follow directory symlinks owned by target directory owner or root.
This prevents privilege escalation from user-writable directories via
directory symlinks to privileged directories on package upgrade, while
still allowing admin to arrange disk usage with symlinks.

The rationale is that if you can create symlinks owned by user X you *are*
user X (or root), and if you also own directory Y you can do whatever with
it already, including change permissions. So when you create a symlink to
that directory, the link ownership acts as a simple stamp of authority that
you indeed want rpm to treat this symlink as it were the directory that
you own. Such a permission can only be given by you or root, which
is just the way we want it. Plus it's almost ridiculously simple as far
as rules go, compared to trying to calculate something from the
source vs destination directory permissions etc.

In the normal case, the user arranging diskspace with symlinks is indeed
root so nothing changes, the only real change here is to links created by
non-privileged users which should be few and far between in practise.
Unfortunately our test-suite runs as a regular user via fakechroot and
thus the testcase for this fails under the new rules. Adjust the testcase
to get the ownership straight and add a second case for the illegal
behavior, basically the same as the old one but with different expectations.",1,lib/fsm.c,"{""sha"": ""ceb38d463d4f91832e75448277e57f31f1c6abbc"", ""filename"": ""lib/fsm.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/rpm-software-management/rpm/blob/f2d3be2a8741234faaa96f5fd05fdfdc75779a79/lib/fsm.c"", ""raw_url"": ""https://github.com/rpm-software-management/rpm/raw/f2d3be2a8741234faaa96f5fd05fdfdc75779a79/lib/fsm.c"", ""contents_url"": ""https://api.github.com/repos/rpm-software-management/rpm/contents/lib/fsm.c?ref=f2d3be2a8741234faaa96f5fd05fdfdc75779a79"", ""patch"": ""@@ -650,7 +650,7 @@ static int fsmUtime(const char *path, mode_t mode, time_t mtime)\n     return rc;\n }\n \n-static int fsmVerify(const char *path, rpmfi fi)\n+static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb)\n {\n     int rc;\n     int saveerrno = errno;\n@@ -675,11 +675,14 @@ static int fsmVerify(const char *path, rpmfi fi)\n     } else if (S_ISDIR(mode)) {\n         if (S_ISDIR(dsb.st_mode)) return 0;\n         if (S_ISLNK(dsb.st_mode)) {\n+\t    uid_t luid = dsb.st_uid;\n             rc = fsmStat(path, 0, &dsb);\n             if (rc == RPMERR_ENOENT) rc = 0;\n             if (rc) return rc;\n             errno = saveerrno;\n-            if (S_ISDIR(dsb.st_mode)) return 0;\n+\t    /* Only permit directory symlinks by target owner and root */\n+            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid))\n+\t\t    return 0;\n         }\n     } else if (S_ISLNK(mode)) {\n         if (S_ISLNK(dsb.st_mode)) {\n@@ -921,7 +924,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n \t    }\n \t    /* Assume file does't exist when tmp suffix is in use */\n \t    if (!suffix) {\n-\t\trc = fsmVerify(fpath, fi);\n+\t\trc = fsmVerify(fpath, fi, &sb);\n \t    } else {\n \t\trc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;\n \t    }""}<_**next**_>{""sha"": ""c764adc27e501d639069afc820226f0febe678e5"", ""filename"": ""tests/data/SPECS/replacetest.spec"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/rpm-software-management/rpm/blob/f2d3be2a8741234faaa96f5fd05fdfdc75779a79/tests/data/SPECS/replacetest.spec"", ""raw_url"": ""https://github.com/rpm-software-management/rpm/raw/f2d3be2a8741234faaa96f5fd05fdfdc75779a79/tests/data/SPECS/replacetest.spec"", ""contents_url"": ""https://api.github.com/repos/rpm-software-management/rpm/contents/tests/data/SPECS/replacetest.spec?ref=f2d3be2a8741234faaa96f5fd05fdfdc75779a79"", ""patch"": ""@@ -1,5 +1,6 @@\n %{!?filetype: %global filetype file}\n %{?fixit: %global havepretrans 1}\n+%{!?user: %global user root}\n \n Name:\t\treplacetest%{?sub:-%{sub}}\n Version:\t%{ver}\n@@ -43,5 +44,5 @@ rm -rf $RPM_BUILD_ROOT\n %endif\n \n %files\n-%defattr(-,root,root,-)\n+%defattr(-,%{user},%{user},-)\n /opt/*""}<_**next**_>{""sha"": ""11e6221d73099750c60c4443693e9395a31b4204"", ""filename"": ""tests/rpmreplace.at"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 0, ""changes"": 34, ""blob_url"": ""https://github.com/rpm-software-management/rpm/blob/f2d3be2a8741234faaa96f5fd05fdfdc75779a79/tests/rpmreplace.at"", ""raw_url"": ""https://github.com/rpm-software-management/rpm/raw/f2d3be2a8741234faaa96f5fd05fdfdc75779a79/tests/rpmreplace.at"", ""contents_url"": ""https://api.github.com/repos/rpm-software-management/rpm/contents/tests/rpmreplace.at?ref=f2d3be2a8741234faaa96f5fd05fdfdc75779a79"", ""patch"": ""@@ -402,12 +402,14 @@ runroot rpmbuild --quiet -bb \\\n         --define \""ver 1.0\"" \\\n \t--define \""filetype datadir\"" \\\n \t--define \""filedata README1\"" \\\n+\t--define \""user $(id -u -n)\"" \\\n           /data/SPECS/replacetest.spec\n \n runroot rpmbuild --quiet -bb \\\n         --define \""ver 2.0\"" \\\n \t--define \""filetype datadir\"" \\\n \t--define \""filedata README2\"" \\\n+\t--define \""user $(id -u -n)\"" \\\n           /data/SPECS/replacetest.spec\n \n mkdir \""${RPMTEST}\""/opt/f00f\n@@ -421,6 +423,38 @@ test -L \""${tf}\"" && test -d \""${tf}\""\n [])\n AT_CLEANUP\n \n+AT_SETUP([upgrade invalid locally symlinked directory])\n+AT_KEYWORDS([install])\n+AT_CHECK([\n+RPMDB_CLEAR\n+RPMDB_INIT\n+tf=\""${RPMTEST}\""/opt/foo\n+rm -rf \""${RPMTEST}\""/opt/*\n+rm -rf \""${TOPDIR}\""\n+\n+runroot rpmbuild --quiet -bb \\\n+        --define \""ver 1.0\"" \\\n+\t--define \""filetype datadir\"" \\\n+\t--define \""filedata README1\"" \\\n+          /data/SPECS/replacetest.spec\n+\n+runroot rpmbuild --quiet -bb \\\n+        --define \""ver 2.0\"" \\\n+\t--define \""filetype datadir\"" \\\n+\t--define \""filedata README2\"" \\\n+          /data/SPECS/replacetest.spec\n+\n+mkdir \""${RPMTEST}\""/opt/f00f\n+ln -s f00f \""${RPMTEST}\""/opt/foo\n+runroot rpm -U /build/RPMS/noarch/replacetest-1.0-1.noarch.rpm\n+test -L \""${tf}\"" && test -d \""${tf}\"" && runroot rpm -U /build/RPMS/noarch/replacetest-2.0-1.noarch.rpm\n+test -d \""${tf}\""\n+],\n+[0],\n+[],\n+[])\n+AT_CLEANUP\n+\n AT_SETUP([upgrade empty directory to broken link])\n AT_KEYWORDS([install])\n AT_CHECK([""}","static int fsmVerify(const char *path, rpmfi fi)
static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb)
 {
     int rc;
     int saveerrno = errno;
    struct stat dsb;
    mode_t mode = rpmfiFMode(fi);

    rc = fsmStat(path, 1, &dsb);
    if (rc)
	return rc;

    if (S_ISREG(mode)) {
	/* HP-UX (and other os'es) don't permit unlink on busy files. */
	char *rmpath = rstrscat(NULL, path, ""-RPMDELETE"", NULL);
	rc = fsmRename(path, rmpath);
	/* XXX shouldn't we take unlink return code here? */
	if (!rc)
	    (void) fsmUnlink(rmpath);
	else
	    rc = RPMERR_UNLINK_FAILED;
	free(rmpath);
        return (rc ? rc : RPMERR_ENOENT);	/* XXX HACK */
     } else if (S_ISDIR(mode)) {
         if (S_ISDIR(dsb.st_mode)) return 0;
         if (S_ISLNK(dsb.st_mode)) {
	    uid_t luid = dsb.st_uid;
             rc = fsmStat(path, 0, &dsb);
             if (rc == RPMERR_ENOENT) rc = 0;
             if (rc) return rc;
             errno = saveerrno;
	    /* Only permit directory symlinks by target owner and root */
            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid))
		    return 0;
         }
     } else if (S_ISLNK(mode)) {
         if (S_ISLNK(dsb.st_mode)) {
            char buf[8 * BUFSIZ];
            size_t len;
            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);
            errno = saveerrno;
            if (rc) return rc;
            if (rstreq(rpmfiFLink(fi), buf)) return 0;
        }
    } else if (S_ISFIFO(mode)) {
        if (S_ISFIFO(dsb.st_mode)) return 0;
    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {
        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&
            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;
    } else if (S_ISSOCK(mode)) {
        if (S_ISSOCK(dsb.st_mode)) return 0;
    }
    /* XXX shouldn't do this with commit/undo. */
    rc = fsmUnlink(path);
    if (rc == 0)	rc = RPMERR_ENOENT;
    return (rc ? rc : RPMERR_ENOENT);	/* XXX HACK */
}
","static int fsmVerify(const char *path, rpmfi fi)
 {
     int rc;
     int saveerrno = errno;
    struct stat dsb;
    mode_t mode = rpmfiFMode(fi);

    rc = fsmStat(path, 1, &dsb);
    if (rc)
	return rc;

    if (S_ISREG(mode)) {
	/* HP-UX (and other os'es) don't permit unlink on busy files. */
	char *rmpath = rstrscat(NULL, path, ""-RPMDELETE"", NULL);
	rc = fsmRename(path, rmpath);
	/* XXX shouldn't we take unlink return code here? */
	if (!rc)
	    (void) fsmUnlink(rmpath);
	else
	    rc = RPMERR_UNLINK_FAILED;
	free(rmpath);
        return (rc ? rc : RPMERR_ENOENT);	/* XXX HACK */
     } else if (S_ISDIR(mode)) {
         if (S_ISDIR(dsb.st_mode)) return 0;
         if (S_ISLNK(dsb.st_mode)) {
             rc = fsmStat(path, 0, &dsb);
             if (rc == RPMERR_ENOENT) rc = 0;
             if (rc) return rc;
             errno = saveerrno;
            if (S_ISDIR(dsb.st_mode)) return 0;
         }
     } else if (S_ISLNK(mode)) {
         if (S_ISLNK(dsb.st_mode)) {
            char buf[8 * BUFSIZ];
            size_t len;
            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);
            errno = saveerrno;
            if (rc) return rc;
            if (rstreq(rpmfiFLink(fi), buf)) return 0;
        }
    } else if (S_ISFIFO(mode)) {
        if (S_ISFIFO(dsb.st_mode)) return 0;
    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {
        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&
            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;
    } else if (S_ISSOCK(mode)) {
        if (S_ISSOCK(dsb.st_mode)) return 0;
    }
    /* XXX shouldn't do this with commit/undo. */
    rc = fsmUnlink(path);
    if (rc == 0)	rc = RPMERR_ENOENT;
    return (rc ? rc : RPMERR_ENOENT);	/* XXX HACK */
}
",C,"static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb)
	    uid_t luid = dsb.st_uid;
	    /* Only permit directory symlinks by target owner and root */
            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid))
		    return 0;
","            if (S_ISDIR(dsb.st_mode)) return 0;
",,"@@ -650,7 +650,7 @@ static int fsmUtime(const char *path, mode_t mode, time_t mtime)
     return rc;
 }
 
-static int fsmVerify(const char *path, rpmfi fi)
+static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb)
 {
     int rc;
     int saveerrno = errno;
@@ -675,11 +675,14 @@ static int fsmVerify(const char *path, rpmfi fi)
     } else if (S_ISDIR(mode)) {
         if (S_ISDIR(dsb.st_mode)) return 0;
         if (S_ISLNK(dsb.st_mode)) {
+	    uid_t luid = dsb.st_uid;
             rc = fsmStat(path, 0, &dsb);
             if (rc == RPMERR_ENOENT) rc = 0;
             if (rc) return rc;
             errno = saveerrno;
-            if (S_ISDIR(dsb.st_mode)) return 0;
+	    /* Only permit directory symlinks by target owner and root */
+            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid))
+		    return 0;
         }
     } else if (S_ISLNK(mode)) {
         if (S_ISLNK(dsb.st_mode)) {
@@ -921,7 +924,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	    }
 	    /* Assume file does't exist when tmp suffix is in use */
 	    if (!suffix) {
-		rc = fsmVerify(fpath, fi);
+		rc = fsmVerify(fpath, fi, &sb);
 	    } else {
 		rc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;
 	    }",rpm,f2d3be2a8741234faaa96f5fd05fdfdc75779a79,e9d1ec565dc54a85e4a8c3bb448afa3ae4ed8441,1,"static int fsmVerify(const char *path, rpmfi fi)
//fix_flaw_line_below:
//static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb)
 {
     int rc;
     int saveerrno = errno;
    struct stat dsb;
    mode_t mode = rpmfiFMode(fi);

    rc = fsmStat(path, 1, &dsb);
    if (rc)
	return rc;

    if (S_ISREG(mode)) {
	/* HP-UX (and other os'es) don't permit unlink on busy files. */
	char *rmpath = rstrscat(NULL, path, ""-RPMDELETE"", NULL);
	rc = fsmRename(path, rmpath);
	/* XXX shouldn't we take unlink return code here? */
	if (!rc)
	    (void) fsmUnlink(rmpath);
	else
	    rc = RPMERR_UNLINK_FAILED;
	free(rmpath);
        return (rc ? rc : RPMERR_ENOENT);	/* XXX HACK */
     } else if (S_ISDIR(mode)) {
         if (S_ISDIR(dsb.st_mode)) return 0;
         if (S_ISLNK(dsb.st_mode)) {
//fix_flaw_line_below:
//	    uid_t luid = dsb.st_uid;
             rc = fsmStat(path, 0, &dsb);
             if (rc == RPMERR_ENOENT) rc = 0;
             if (rc) return rc;
             errno = saveerrno;
//flaw_line_below:
            if (S_ISDIR(dsb.st_mode)) return 0;
//fix_flaw_line_below:
//	    /* Only permit directory symlinks by target owner and root */
//fix_flaw_line_below:
//            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid))
//fix_flaw_line_below:
//		    return 0;
         }
     } else if (S_ISLNK(mode)) {
         if (S_ISLNK(dsb.st_mode)) {
            char buf[8 * BUFSIZ];
            size_t len;
            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);
            errno = saveerrno;
            if (rc) return rc;
            if (rstreq(rpmfiFLink(fi), buf)) return 0;
        }
    } else if (S_ISFIFO(mode)) {
        if (S_ISFIFO(dsb.st_mode)) return 0;
    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {
        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&
            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;
    } else if (S_ISSOCK(mode)) {
        if (S_ISSOCK(dsb.st_mode)) return 0;
    }
    /* XXX shouldn't do this with commit/undo. */
    rc = fsmUnlink(path);
    if (rc == 0)	rc = RPMERR_ENOENT;
    return (rc ? rc : RPMERR_ENOENT);	/* XXX HACK */
}
"
5613,183349,,Local,Not required,Complete,CVE-2017-7500,https://www.cvedetails.com/cve/CVE-2017-7500/,CWE-59,Low,Complete,Complete,,2018-08-13,7.2,"It was found that rpm did not properly handle RPM installations when a destination path was a symbolic link to a directory, possibly changing ownership and permissions of an arbitrary directory, and RPM files being placed in an arbitrary destination. An attacker, with write access to a directory in which a subdirectory will be installed, could redirect that directory to an arbitrary location and gain root privilege.",2019-10-09,+Priv ,1,https://github.com/rpm-software-management/rpm/commit/f2d3be2a8741234faaa96f5fd05fdfdc75779a79,f2d3be2a8741234faaa96f5fd05fdfdc75779a79,"Restrict following symlinks to directories by ownership (CVE-2017-7500)

Only follow directory symlinks owned by target directory owner or root.
This prevents privilege escalation from user-writable directories via
directory symlinks to privileged directories on package upgrade, while
still allowing admin to arrange disk usage with symlinks.

The rationale is that if you can create symlinks owned by user X you *are*
user X (or root), and if you also own directory Y you can do whatever with
it already, including change permissions. So when you create a symlink to
that directory, the link ownership acts as a simple stamp of authority that
you indeed want rpm to treat this symlink as it were the directory that
you own. Such a permission can only be given by you or root, which
is just the way we want it. Plus it's almost ridiculously simple as far
as rules go, compared to trying to calculate something from the
source vs destination directory permissions etc.

In the normal case, the user arranging diskspace with symlinks is indeed
root so nothing changes, the only real change here is to links created by
non-privileged users which should be few and far between in practise.
Unfortunately our test-suite runs as a regular user via fakechroot and
thus the testcase for this fails under the new rules. Adjust the testcase
to get the ownership straight and add a second case for the illegal
behavior, basically the same as the old one but with different expectations.",1,lib/fsm.c,"{""sha"": ""ceb38d463d4f91832e75448277e57f31f1c6abbc"", ""filename"": ""lib/fsm.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/rpm-software-management/rpm/blob/f2d3be2a8741234faaa96f5fd05fdfdc75779a79/lib/fsm.c"", ""raw_url"": ""https://github.com/rpm-software-management/rpm/raw/f2d3be2a8741234faaa96f5fd05fdfdc75779a79/lib/fsm.c"", ""contents_url"": ""https://api.github.com/repos/rpm-software-management/rpm/contents/lib/fsm.c?ref=f2d3be2a8741234faaa96f5fd05fdfdc75779a79"", ""patch"": ""@@ -650,7 +650,7 @@ static int fsmUtime(const char *path, mode_t mode, time_t mtime)\n     return rc;\n }\n \n-static int fsmVerify(const char *path, rpmfi fi)\n+static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb)\n {\n     int rc;\n     int saveerrno = errno;\n@@ -675,11 +675,14 @@ static int fsmVerify(const char *path, rpmfi fi)\n     } else if (S_ISDIR(mode)) {\n         if (S_ISDIR(dsb.st_mode)) return 0;\n         if (S_ISLNK(dsb.st_mode)) {\n+\t    uid_t luid = dsb.st_uid;\n             rc = fsmStat(path, 0, &dsb);\n             if (rc == RPMERR_ENOENT) rc = 0;\n             if (rc) return rc;\n             errno = saveerrno;\n-            if (S_ISDIR(dsb.st_mode)) return 0;\n+\t    /* Only permit directory symlinks by target owner and root */\n+            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid))\n+\t\t    return 0;\n         }\n     } else if (S_ISLNK(mode)) {\n         if (S_ISLNK(dsb.st_mode)) {\n@@ -921,7 +924,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n \t    }\n \t    /* Assume file does't exist when tmp suffix is in use */\n \t    if (!suffix) {\n-\t\trc = fsmVerify(fpath, fi);\n+\t\trc = fsmVerify(fpath, fi, &sb);\n \t    } else {\n \t\trc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;\n \t    }""}<_**next**_>{""sha"": ""c764adc27e501d639069afc820226f0febe678e5"", ""filename"": ""tests/data/SPECS/replacetest.spec"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/rpm-software-management/rpm/blob/f2d3be2a8741234faaa96f5fd05fdfdc75779a79/tests/data/SPECS/replacetest.spec"", ""raw_url"": ""https://github.com/rpm-software-management/rpm/raw/f2d3be2a8741234faaa96f5fd05fdfdc75779a79/tests/data/SPECS/replacetest.spec"", ""contents_url"": ""https://api.github.com/repos/rpm-software-management/rpm/contents/tests/data/SPECS/replacetest.spec?ref=f2d3be2a8741234faaa96f5fd05fdfdc75779a79"", ""patch"": ""@@ -1,5 +1,6 @@\n %{!?filetype: %global filetype file}\n %{?fixit: %global havepretrans 1}\n+%{!?user: %global user root}\n \n Name:\t\treplacetest%{?sub:-%{sub}}\n Version:\t%{ver}\n@@ -43,5 +44,5 @@ rm -rf $RPM_BUILD_ROOT\n %endif\n \n %files\n-%defattr(-,root,root,-)\n+%defattr(-,%{user},%{user},-)\n /opt/*""}<_**next**_>{""sha"": ""11e6221d73099750c60c4443693e9395a31b4204"", ""filename"": ""tests/rpmreplace.at"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 0, ""changes"": 34, ""blob_url"": ""https://github.com/rpm-software-management/rpm/blob/f2d3be2a8741234faaa96f5fd05fdfdc75779a79/tests/rpmreplace.at"", ""raw_url"": ""https://github.com/rpm-software-management/rpm/raw/f2d3be2a8741234faaa96f5fd05fdfdc75779a79/tests/rpmreplace.at"", ""contents_url"": ""https://api.github.com/repos/rpm-software-management/rpm/contents/tests/rpmreplace.at?ref=f2d3be2a8741234faaa96f5fd05fdfdc75779a79"", ""patch"": ""@@ -402,12 +402,14 @@ runroot rpmbuild --quiet -bb \\\n         --define \""ver 1.0\"" \\\n \t--define \""filetype datadir\"" \\\n \t--define \""filedata README1\"" \\\n+\t--define \""user $(id -u -n)\"" \\\n           /data/SPECS/replacetest.spec\n \n runroot rpmbuild --quiet -bb \\\n         --define \""ver 2.0\"" \\\n \t--define \""filetype datadir\"" \\\n \t--define \""filedata README2\"" \\\n+\t--define \""user $(id -u -n)\"" \\\n           /data/SPECS/replacetest.spec\n \n mkdir \""${RPMTEST}\""/opt/f00f\n@@ -421,6 +423,38 @@ test -L \""${tf}\"" && test -d \""${tf}\""\n [])\n AT_CLEANUP\n \n+AT_SETUP([upgrade invalid locally symlinked directory])\n+AT_KEYWORDS([install])\n+AT_CHECK([\n+RPMDB_CLEAR\n+RPMDB_INIT\n+tf=\""${RPMTEST}\""/opt/foo\n+rm -rf \""${RPMTEST}\""/opt/*\n+rm -rf \""${TOPDIR}\""\n+\n+runroot rpmbuild --quiet -bb \\\n+        --define \""ver 1.0\"" \\\n+\t--define \""filetype datadir\"" \\\n+\t--define \""filedata README1\"" \\\n+          /data/SPECS/replacetest.spec\n+\n+runroot rpmbuild --quiet -bb \\\n+        --define \""ver 2.0\"" \\\n+\t--define \""filetype datadir\"" \\\n+\t--define \""filedata README2\"" \\\n+          /data/SPECS/replacetest.spec\n+\n+mkdir \""${RPMTEST}\""/opt/f00f\n+ln -s f00f \""${RPMTEST}\""/opt/foo\n+runroot rpm -U /build/RPMS/noarch/replacetest-1.0-1.noarch.rpm\n+test -L \""${tf}\"" && test -d \""${tf}\"" && runroot rpm -U /build/RPMS/noarch/replacetest-2.0-1.noarch.rpm\n+test -d \""${tf}\""\n+],\n+[0],\n+[],\n+[])\n+AT_CLEANUP\n+\n AT_SETUP([upgrade empty directory to broken link])\n AT_KEYWORDS([install])\n AT_CHECK([""}","int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
              rpmpsm psm, char ** failedFile)
{
    FD_t payload = rpmtePayload(te);
    rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);
    rpmfs fs = rpmteGetFileStates(te);
    rpmPlugins plugins = rpmtsPlugins(ts);
    struct stat sb;
    int saveerrno = errno;
    int rc = 0;
    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;
    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;
    int firsthardlink = -1;
    int skip;
    rpmFileAction action;
    char *tid = NULL;
    const char *suffix;
    char *fpath = NULL;

    if (fi == NULL) {
	rc = RPMERR_BAD_MAGIC;
	goto exit;
    }

    /* transaction id used for temporary path suffix while installing */
    rasprintf(&tid, "";%08x"", (unsigned)rpmtsGetTid(ts));

    /* Detect and create directories not explicitly in package. */
    rc = fsmMkdirs(files, fs, plugins);

    while (!rc) {
	/* Read next payload header. */
	rc = rpmfiNext(fi);

	if (rc < 0) {
	    if (rc == RPMERR_ITER_END)
		rc = 0;
	    break;
	}

	action = rpmfsGetAction(fs, rpmfiFX(fi));
	skip = XFA_SKIPPING(action);
	suffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;
	if (action != FA_TOUCH) {
	    fpath = fsmFsPath(fi, suffix);
	} else {
	    fpath = fsmFsPath(fi, """");
	}

	/* Remap file perms, owner, and group. */
	rc = rpmfiStat(fi, 1, &sb);

	fsmDebug(fpath, action, &sb);

        /* Exit on error. */
        if (rc)
            break;

	/* Run fsm file pre hook for all plugins */
	rc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,
				      sb.st_mode, action);
	if (rc) {
	    skip = 1;
	} else {
	    setFileState(fs, rpmfiFX(fi));
	}

        if (!skip) {
	    int setmeta = 1;

	    /* Directories replacing something need early backup */
	    if (!suffix) {
		rc = fsmBackup(fi, action);
 	    }
 	    /* Assume file does't exist when tmp suffix is in use */
 	    if (!suffix) {
		rc = fsmVerify(fpath, fi, &sb);
 	    } else {
 		rc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;
 	    }

            if (S_ISREG(sb.st_mode)) {
		if (rc == RPMERR_ENOENT) {
		    rc = fsmMkfile(fi, fpath, files, psm, nodigest,
				   &setmeta, &firsthardlink);
		}
            } else if (S_ISDIR(sb.st_mode)) {
                if (rc == RPMERR_ENOENT) {
                    mode_t mode = sb.st_mode;
                    mode &= ~07777;
                    mode |=  00700;
                    rc = fsmMkdir(fpath, mode);
                }
            } else if (S_ISLNK(sb.st_mode)) {
		if (rc == RPMERR_ENOENT) {
		    rc = fsmSymlink(rpmfiFLink(fi), fpath);
		}
            } else if (S_ISFIFO(sb.st_mode)) {
                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */
                if (rc == RPMERR_ENOENT) {
                    rc = fsmMkfifo(fpath, 0000);
                }
            } else if (S_ISCHR(sb.st_mode) ||
                       S_ISBLK(sb.st_mode) ||
                       S_ISSOCK(sb.st_mode))
            {
                if (rc == RPMERR_ENOENT) {
                    rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev);
                }
            } else {
                /* XXX Special case /dev/log, which shouldn't be packaged anyways */
                if (!IS_DEV_LOG(fpath))
                    rc = RPMERR_UNKNOWN_FILETYPE;
            }
	    /* Set permissions, timestamps etc for non-hardlink entries */
	    if (!rc && setmeta) {
		rc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps);
	    }
        } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) {
	    /* we skip the hard linked file containing the content */
	    /* write the content to the first used instead */
	    char *fn = rpmfilesFN(files, firsthardlink);
	    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);
	    firsthardlink = -1;
	    free(fn);
	}

        if (rc) {
            if (!skip) {
                /* XXX only erase if temp fn w suffix is in use */
                if (suffix && (action != FA_TOUCH)) {
		    (void) fsmRemove(fpath, sb.st_mode);
                }
                errno = saveerrno;
            }
        } else {
	    /* Notify on success. */
	    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));

	    if (!skip) {
		/* Backup file if needed. Directories are handled earlier */
		if (suffix)
		    rc = fsmBackup(fi, action);

		if (!rc)
		    rc = fsmCommit(&fpath, fi, action, suffix);
	    }
	}

	if (rc)
	    *failedFile = xstrdup(fpath);

	/* Run fsm file post hook for all plugins */
	rpmpluginsCallFsmFilePost(plugins, fi, fpath,
				  sb.st_mode, action, rc);
	fpath = _free(fpath);
    }

    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));
    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));

exit:

    /* No need to bother with close errors on read */
    rpmfiArchiveClose(fi);
    rpmfiFree(fi);
    Fclose(payload);
    free(tid);
    free(fpath);

    return rc;
}
","int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
              rpmpsm psm, char ** failedFile)
{
    FD_t payload = rpmtePayload(te);
    rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);
    rpmfs fs = rpmteGetFileStates(te);
    rpmPlugins plugins = rpmtsPlugins(ts);
    struct stat sb;
    int saveerrno = errno;
    int rc = 0;
    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;
    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;
    int firsthardlink = -1;
    int skip;
    rpmFileAction action;
    char *tid = NULL;
    const char *suffix;
    char *fpath = NULL;

    if (fi == NULL) {
	rc = RPMERR_BAD_MAGIC;
	goto exit;
    }

    /* transaction id used for temporary path suffix while installing */
    rasprintf(&tid, "";%08x"", (unsigned)rpmtsGetTid(ts));

    /* Detect and create directories not explicitly in package. */
    rc = fsmMkdirs(files, fs, plugins);

    while (!rc) {
	/* Read next payload header. */
	rc = rpmfiNext(fi);

	if (rc < 0) {
	    if (rc == RPMERR_ITER_END)
		rc = 0;
	    break;
	}

	action = rpmfsGetAction(fs, rpmfiFX(fi));
	skip = XFA_SKIPPING(action);
	suffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;
	if (action != FA_TOUCH) {
	    fpath = fsmFsPath(fi, suffix);
	} else {
	    fpath = fsmFsPath(fi, """");
	}

	/* Remap file perms, owner, and group. */
	rc = rpmfiStat(fi, 1, &sb);

	fsmDebug(fpath, action, &sb);

        /* Exit on error. */
        if (rc)
            break;

	/* Run fsm file pre hook for all plugins */
	rc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,
				      sb.st_mode, action);
	if (rc) {
	    skip = 1;
	} else {
	    setFileState(fs, rpmfiFX(fi));
	}

        if (!skip) {
	    int setmeta = 1;

	    /* Directories replacing something need early backup */
	    if (!suffix) {
		rc = fsmBackup(fi, action);
 	    }
 	    /* Assume file does't exist when tmp suffix is in use */
 	    if (!suffix) {
		rc = fsmVerify(fpath, fi);
 	    } else {
 		rc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;
 	    }

            if (S_ISREG(sb.st_mode)) {
		if (rc == RPMERR_ENOENT) {
		    rc = fsmMkfile(fi, fpath, files, psm, nodigest,
				   &setmeta, &firsthardlink);
		}
            } else if (S_ISDIR(sb.st_mode)) {
                if (rc == RPMERR_ENOENT) {
                    mode_t mode = sb.st_mode;
                    mode &= ~07777;
                    mode |=  00700;
                    rc = fsmMkdir(fpath, mode);
                }
            } else if (S_ISLNK(sb.st_mode)) {
		if (rc == RPMERR_ENOENT) {
		    rc = fsmSymlink(rpmfiFLink(fi), fpath);
		}
            } else if (S_ISFIFO(sb.st_mode)) {
                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */
                if (rc == RPMERR_ENOENT) {
                    rc = fsmMkfifo(fpath, 0000);
                }
            } else if (S_ISCHR(sb.st_mode) ||
                       S_ISBLK(sb.st_mode) ||
                       S_ISSOCK(sb.st_mode))
            {
                if (rc == RPMERR_ENOENT) {
                    rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev);
                }
            } else {
                /* XXX Special case /dev/log, which shouldn't be packaged anyways */
                if (!IS_DEV_LOG(fpath))
                    rc = RPMERR_UNKNOWN_FILETYPE;
            }
	    /* Set permissions, timestamps etc for non-hardlink entries */
	    if (!rc && setmeta) {
		rc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps);
	    }
        } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) {
	    /* we skip the hard linked file containing the content */
	    /* write the content to the first used instead */
	    char *fn = rpmfilesFN(files, firsthardlink);
	    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);
	    firsthardlink = -1;
	    free(fn);
	}

        if (rc) {
            if (!skip) {
                /* XXX only erase if temp fn w suffix is in use */
                if (suffix && (action != FA_TOUCH)) {
		    (void) fsmRemove(fpath, sb.st_mode);
                }
                errno = saveerrno;
            }
        } else {
	    /* Notify on success. */
	    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));

	    if (!skip) {
		/* Backup file if needed. Directories are handled earlier */
		if (suffix)
		    rc = fsmBackup(fi, action);

		if (!rc)
		    rc = fsmCommit(&fpath, fi, action, suffix);
	    }
	}

	if (rc)
	    *failedFile = xstrdup(fpath);

	/* Run fsm file post hook for all plugins */
	rpmpluginsCallFsmFilePost(plugins, fi, fpath,
				  sb.st_mode, action, rc);
	fpath = _free(fpath);
    }

    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));
    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));

exit:

    /* No need to bother with close errors on read */
    rpmfiArchiveClose(fi);
    rpmfiFree(fi);
    Fclose(payload);
    free(tid);
    free(fpath);

    return rc;
}
",C,"		rc = fsmVerify(fpath, fi, &sb);
","		rc = fsmVerify(fpath, fi);
",,"@@ -650,7 +650,7 @@ static int fsmUtime(const char *path, mode_t mode, time_t mtime)
     return rc;
 }
 
-static int fsmVerify(const char *path, rpmfi fi)
+static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb)
 {
     int rc;
     int saveerrno = errno;
@@ -675,11 +675,14 @@ static int fsmVerify(const char *path, rpmfi fi)
     } else if (S_ISDIR(mode)) {
         if (S_ISDIR(dsb.st_mode)) return 0;
         if (S_ISLNK(dsb.st_mode)) {
+	    uid_t luid = dsb.st_uid;
             rc = fsmStat(path, 0, &dsb);
             if (rc == RPMERR_ENOENT) rc = 0;
             if (rc) return rc;
             errno = saveerrno;
-            if (S_ISDIR(dsb.st_mode)) return 0;
+	    /* Only permit directory symlinks by target owner and root */
+            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid))
+		    return 0;
         }
     } else if (S_ISLNK(mode)) {
         if (S_ISLNK(dsb.st_mode)) {
@@ -921,7 +924,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	    }
 	    /* Assume file does't exist when tmp suffix is in use */
 	    if (!suffix) {
-		rc = fsmVerify(fpath, fi);
+		rc = fsmVerify(fpath, fi, &sb);
 	    } else {
 		rc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;
 	    }",rpm,f2d3be2a8741234faaa96f5fd05fdfdc75779a79,e9d1ec565dc54a85e4a8c3bb448afa3ae4ed8441,1,"int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
              rpmpsm psm, char ** failedFile)
{
    FD_t payload = rpmtePayload(te);
    rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);
    rpmfs fs = rpmteGetFileStates(te);
    rpmPlugins plugins = rpmtsPlugins(ts);
    struct stat sb;
    int saveerrno = errno;
    int rc = 0;
    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;
    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;
    int firsthardlink = -1;
    int skip;
    rpmFileAction action;
    char *tid = NULL;
    const char *suffix;
    char *fpath = NULL;

    if (fi == NULL) {
	rc = RPMERR_BAD_MAGIC;
	goto exit;
    }

    /* transaction id used for temporary path suffix while installing */
    rasprintf(&tid, "";%08x"", (unsigned)rpmtsGetTid(ts));

    /* Detect and create directories not explicitly in package. */
    rc = fsmMkdirs(files, fs, plugins);

    while (!rc) {
	/* Read next payload header. */
	rc = rpmfiNext(fi);

	if (rc < 0) {
	    if (rc == RPMERR_ITER_END)
		rc = 0;
	    break;
	}

	action = rpmfsGetAction(fs, rpmfiFX(fi));
	skip = XFA_SKIPPING(action);
	suffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;
	if (action != FA_TOUCH) {
	    fpath = fsmFsPath(fi, suffix);
	} else {
	    fpath = fsmFsPath(fi, """");
	}

	/* Remap file perms, owner, and group. */
	rc = rpmfiStat(fi, 1, &sb);

	fsmDebug(fpath, action, &sb);

        /* Exit on error. */
        if (rc)
            break;

	/* Run fsm file pre hook for all plugins */
	rc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,
				      sb.st_mode, action);
	if (rc) {
	    skip = 1;
	} else {
	    setFileState(fs, rpmfiFX(fi));
	}

        if (!skip) {
	    int setmeta = 1;

	    /* Directories replacing something need early backup */
	    if (!suffix) {
		rc = fsmBackup(fi, action);
 	    }
 	    /* Assume file does't exist when tmp suffix is in use */
 	    if (!suffix) {
//flaw_line_below:
		rc = fsmVerify(fpath, fi);
//fix_flaw_line_below:
//		rc = fsmVerify(fpath, fi, &sb);
 	    } else {
 		rc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;
 	    }

            if (S_ISREG(sb.st_mode)) {
		if (rc == RPMERR_ENOENT) {
		    rc = fsmMkfile(fi, fpath, files, psm, nodigest,
				   &setmeta, &firsthardlink);
		}
            } else if (S_ISDIR(sb.st_mode)) {
                if (rc == RPMERR_ENOENT) {
                    mode_t mode = sb.st_mode;
                    mode &= ~07777;
                    mode |=  00700;
                    rc = fsmMkdir(fpath, mode);
                }
            } else if (S_ISLNK(sb.st_mode)) {
		if (rc == RPMERR_ENOENT) {
		    rc = fsmSymlink(rpmfiFLink(fi), fpath);
		}
            } else if (S_ISFIFO(sb.st_mode)) {
                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */
                if (rc == RPMERR_ENOENT) {
                    rc = fsmMkfifo(fpath, 0000);
                }
            } else if (S_ISCHR(sb.st_mode) ||
                       S_ISBLK(sb.st_mode) ||
                       S_ISSOCK(sb.st_mode))
            {
                if (rc == RPMERR_ENOENT) {
                    rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev);
                }
            } else {
                /* XXX Special case /dev/log, which shouldn't be packaged anyways */
                if (!IS_DEV_LOG(fpath))
                    rc = RPMERR_UNKNOWN_FILETYPE;
            }
	    /* Set permissions, timestamps etc for non-hardlink entries */
	    if (!rc && setmeta) {
		rc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps);
	    }
        } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) {
	    /* we skip the hard linked file containing the content */
	    /* write the content to the first used instead */
	    char *fn = rpmfilesFN(files, firsthardlink);
	    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);
	    firsthardlink = -1;
	    free(fn);
	}

        if (rc) {
            if (!skip) {
                /* XXX only erase if temp fn w suffix is in use */
                if (suffix && (action != FA_TOUCH)) {
		    (void) fsmRemove(fpath, sb.st_mode);
                }
                errno = saveerrno;
            }
        } else {
	    /* Notify on success. */
	    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));

	    if (!skip) {
		/* Backup file if needed. Directories are handled earlier */
		if (suffix)
		    rc = fsmBackup(fi, action);

		if (!rc)
		    rc = fsmCommit(&fpath, fi, action, suffix);
	    }
	}

	if (rc)
	    *failedFile = xstrdup(fpath);

	/* Run fsm file post hook for all plugins */
	rpmpluginsCallFsmFilePost(plugins, fi, fpath,
				  sb.st_mode, action, rc);
	fpath = _free(fpath);
    }

    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));
    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));

exit:

    /* No need to bother with close errors on read */
    rpmfiArchiveClose(fi);
    rpmfiFree(fi);
    Fclose(payload);
    free(tid);
    free(fpath);

    return rc;
}
"
