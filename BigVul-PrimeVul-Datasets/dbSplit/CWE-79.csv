,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
2908,180644,,Remote,Not required,,CVE-2015-8935,https://www.cvedetails.com/cve/CVE-2015-8935/,CWE-79,Medium,,Partial,,2016-08-07,4.3,"The sapi_header_op function in main/SAPI.c in PHP before 5.4.38, 5.5.x before 5.5.22, and 5.6.x before 5.6.6 supports deprecated line folding without considering browser compatibility, which allows remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer by leveraging (1) %0A%20 or (2) %0D%0A%20 mishandling in the header function.",2018-01-04,XSS ,2,https://github.com/php/php-src/commit/996faf964bba1aec06b153b370a7f20d3dd2bb8b?w=1,996faf964bba1aec06b153b370a7f20d3dd2bb8b?w=1,Update header handling to RFC 7230,7,main/SAPI.c,"{""sha"": ""2cdde78a4a9140d98acf0e5683aaaaaf6213e063"", ""filename"": ""ext/standard/tests/general_functions/bug60227_2.phpt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/php/php-src/blob/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_2.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_2.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/standard/tests/general_functions/bug60227_2.phpt?ref=996faf964bba1aec06b153b370a7f20d3dd2bb8b"", ""patch"": ""@@ -1,14 +1,15 @@\n --TEST--\n Bug #60227 (header() cannot detect the multi-line header with CR), \\r before \\n\n+--INI--\n+expose_php=0\n --FILE--\n <?php\n header(\""X-foo: e\\n foo\"");\n-header(\""X-Foo6: e\\rSet-Cookie: ID=123\\n d\"");\n echo 'foo';\n ?>\n --EXPECTF--\n+\n Warning: Header may not contain more than a single header, new line detected in %s on line %d\n foo\n --EXPECTHEADERS--\n-X-foo: e\n-foo\n+Content-type: text/html; charset=UTF-8""}<_**next**_>{""sha"": ""8246f1743835c307beb889604bc1f3ba76d0fb4a"", ""filename"": ""ext/standard/tests/general_functions/bug60227_3.phpt"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/php/php-src/blob/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_3.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_3.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/standard/tests/general_functions/bug60227_3.phpt?ref=996faf964bba1aec06b153b370a7f20d3dd2bb8b"", ""patch"": ""@@ -1,14 +1,14 @@\n --TEST--\n Bug #60227 (header() cannot detect the multi-line header with CR), \\0 before \\n\n+--INI--\n+expose_php=0\n --FILE--\n <?php\n-header(\""X-foo: e\\n foo\"");\n header(\""X-Foo6: e\\0Set-Cookie: ID=\\n123\\n d\"");\n echo 'foo';\n ?>\n --EXPECTF--\n Warning: Header may not contain NUL bytes in %s on line %d\n foo\n --EXPECTHEADERS--\n-X-foo: e\n-foo\n+Content-type: text/html; charset=UTF-8""}<_**next**_>{""sha"": ""20dba1a26568e55ad47a0af4e91efe9f59a417ba"", ""filename"": ""ext/standard/tests/general_functions/bug60227_4.phpt"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/php/php-src/blob/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_4.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_4.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/standard/tests/general_functions/bug60227_4.phpt?ref=996faf964bba1aec06b153b370a7f20d3dd2bb8b"", ""patch"": ""@@ -1,14 +1,14 @@\n --TEST--\n Bug #60227 (header() cannot detect the multi-line header with CR), CRLF\n+--INI--\n+expose_php=0\n --FILE--\n <?php\n-header(\""X-foo: e\\r\\n foo\"");\n header(\""X-foo: e\\r\\nfoo\"");\n echo 'foo';\n ?>\n --EXPECTF--\n Warning: Header may not contain more than a single header, new line detected in %s on line %d\n foo\n --EXPECTHEADERS--\n-X-foo: e\n- foo\n+Content-type: text/html; charset=UTF-8""}<_**next**_>{""sha"": ""0dd0b55df548f59b60fad2cd0d5733665fe1b123"", ""filename"": ""main/SAPI.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 7, ""changes"": 9, ""blob_url"": ""https://github.com/php/php-src/blob/996faf964bba1aec06b153b370a7f20d3dd2bb8b/main/SAPI.c"", ""raw_url"": ""https://github.com/php/php-src/raw/996faf964bba1aec06b153b370a7f20d3dd2bb8b/main/SAPI.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/main/SAPI.c?ref=996faf964bba1aec06b153b370a7f20d3dd2bb8b"", ""patch"": ""@@ -743,13 +743,8 @@ SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)\n \t\t/* new line/NUL character safety check */\n \t\tint i;\n \t\tfor (i = 0; i < header_line_len; i++) {\n-\t\t\t/* RFC 2616 allows new lines if followed by SP or HT */\n-\t\t\tint illegal_break =\n-\t\t\t\t\t(header_line[i+1] != ' ' && header_line[i+1] != '\\t')\n-\t\t\t\t\t&& (\n-\t\t\t\t\t\theader_line[i] == '\\n'\n-\t\t\t\t\t\t|| (header_line[i] == '\\r' && header_line[i+1] != '\\n'));\n-\t\t\tif (illegal_break) {\n+\t\t\t/* RFC 7230 ch. 3.2.4 deprecates folding support */\n+\t\t\tif (header_line[i] == '\\n' || header_line[i] == '\\r') {\n \t\t\t\tefree(header_line);\n \t\t\t\tsapi_module.sapi_error(E_WARNING, \""Header may not contain \""\n \t\t\t\t\t\t\""more than a single header, new line detected\"");""}","SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)
{
	sapi_header_struct sapi_header;
	char *colon_offset;
	char *header_line;
	uint header_line_len;
	int http_response_code;

	if (SG(headers_sent) && !SG(request_info).no_headers) {
		const char *output_start_filename = php_output_get_start_filename(TSRMLS_C);
		int output_start_lineno = php_output_get_start_lineno(TSRMLS_C);

		if (output_start_filename) {
			sapi_module.sapi_error(E_WARNING, ""Cannot modify header information - headers already sent by (output started at %s:%d)"",
				output_start_filename, output_start_lineno);
		} else {
			sapi_module.sapi_error(E_WARNING, ""Cannot modify header information - headers already sent"");
		}
		return FAILURE;
	}

	switch (op) {
		case SAPI_HEADER_SET_STATUS:
			sapi_update_response_code((int)(zend_intptr_t) arg TSRMLS_CC);
			return SUCCESS;

		case SAPI_HEADER_ADD:
		case SAPI_HEADER_REPLACE:
		case SAPI_HEADER_DELETE: {
				sapi_header_line *p = arg;

				if (!p->line || !p->line_len) {
					return FAILURE;
				}
				header_line = p->line;
				header_line_len = p->line_len;
				http_response_code = p->response_code;
				break;
			}

		case SAPI_HEADER_DELETE_ALL:
			if (sapi_module.header_handler) {
				sapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);
			}
			zend_llist_clean(&SG(sapi_headers).headers);
			return SUCCESS;

		default:
			return FAILURE;
	}

	header_line = estrndup(header_line, header_line_len);

	/* cut off trailing spaces, linefeeds and carriage-returns */
	if (header_line_len && isspace(header_line[header_line_len-1])) {
		do {
			header_line_len--;
		} while(header_line_len && isspace(header_line[header_line_len-1]));
		header_line[header_line_len]='\0';
	}
	
	if (op == SAPI_HEADER_DELETE) {
		if (strchr(header_line, ':')) {
			efree(header_line);
			sapi_module.sapi_error(E_WARNING, ""Header to delete may not contain colon."");
			return FAILURE;
		}
		if (sapi_module.header_handler) {
			sapi_header.header = header_line;
			sapi_header.header_len = header_line_len;
			sapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);
		}
		sapi_remove_header(&SG(sapi_headers).headers, header_line, header_line_len);
		efree(header_line);
		return SUCCESS;
	} else {
 		/* new line/NUL character safety check */
 		int i;
 		for (i = 0; i < header_line_len; i++) {
			/* RFC 7230 ch. 3.2.4 deprecates folding support */
			if (header_line[i] == '\n' || header_line[i] == '\r') {
 				efree(header_line);
 				sapi_module.sapi_error(E_WARNING, ""Header may not contain ""
 						""more than a single header, new line detected"");
				return FAILURE;
			}
			if (header_line[i] == '\0') {
				efree(header_line);
				sapi_module.sapi_error(E_WARNING, ""Header may not contain NUL bytes"");
				return FAILURE;
			}
		}
	}

	sapi_header.header = header_line;
	sapi_header.header_len = header_line_len;

	/* Check the header for a few cases that we have special support for in SAPI */
	if (header_line_len>=5 
		&& !strncasecmp(header_line, ""HTTP/"", 5)) {
		/* filter out the response code */
		sapi_update_response_code(sapi_extract_response_code(header_line) TSRMLS_CC);
		/* sapi_update_response_code doesn't free the status line if the code didn't change */
		if (SG(sapi_headers).http_status_line) {
			efree(SG(sapi_headers).http_status_line);
		}
		SG(sapi_headers).http_status_line = header_line;
		return SUCCESS;
	} else {
		colon_offset = strchr(header_line, ':');
		if (colon_offset) {
			*colon_offset = 0;
			if (!STRCASECMP(header_line, ""Content-Type"")) {
				char *ptr = colon_offset+1, *mimetype = NULL, *newheader;
				size_t len = header_line_len - (ptr - header_line), newlen;
				while (*ptr == ' ') {
					ptr++;
					len--;
				}

				/* Disable possible output compression for images */
				if (!strncmp(ptr, ""image/"", sizeof(""image/"")-1)) {
					zend_alter_ini_entry(""zlib.output_compression"", sizeof(""zlib.output_compression""), ""0"", sizeof(""0"") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
				}

				mimetype = estrdup(ptr);
				newlen = sapi_apply_default_charset(&mimetype, len TSRMLS_CC);
				if (!SG(sapi_headers).mimetype){
					SG(sapi_headers).mimetype = estrdup(mimetype);
				}

				if (newlen != 0) {
					newlen += sizeof(""Content-type: "");
					newheader = emalloc(newlen);
					PHP_STRLCPY(newheader, ""Content-type: "", newlen, sizeof(""Content-type: "")-1);
					strlcat(newheader, mimetype, newlen);
					sapi_header.header = newheader;
					sapi_header.header_len = newlen - 1;
					efree(header_line);
				}
				efree(mimetype);
				SG(sapi_headers).send_default_content_type = 0;
			} else if (!STRCASECMP(header_line, ""Content-Length"")) {
				/* Script is setting Content-length. The script cannot reasonably
				 * know the size of the message body after compression, so it's best
				 * do disable compression altogether. This contributes to making scripts
				 * portable between setups that have and don't have zlib compression
				 * enabled globally. See req #44164 */
				zend_alter_ini_entry(""zlib.output_compression"", sizeof(""zlib.output_compression""),
					""0"", sizeof(""0"") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
			} else if (!STRCASECMP(header_line, ""Location"")) {
				if ((SG(sapi_headers).http_response_code < 300 ||
					SG(sapi_headers).http_response_code > 399) &&
					SG(sapi_headers).http_response_code != 201) {
					/* Return a Found Redirect if one is not already specified */
					if (http_response_code) { /* user specified redirect code */
						sapi_update_response_code(http_response_code TSRMLS_CC);
					} else if (SG(request_info).proto_num > 1000 && 
					   SG(request_info).request_method && 
					   strcmp(SG(request_info).request_method, ""HEAD"") &&
					   strcmp(SG(request_info).request_method, ""GET"")) {
						sapi_update_response_code(303 TSRMLS_CC);
					} else {
						sapi_update_response_code(302 TSRMLS_CC);
					}
				}
			} else if (!STRCASECMP(header_line, ""WWW-Authenticate"")) { /* HTTP Authentication */
				sapi_update_response_code(401 TSRMLS_CC); /* authentication-required */
			}
			if (sapi_header.header==header_line) {
				*colon_offset = ':';
			}
		}
	}
	if (http_response_code) {
		sapi_update_response_code(http_response_code TSRMLS_CC);
	}
	sapi_header_add_op(op, &sapi_header TSRMLS_CC);
	return SUCCESS;
}
","SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)
{
	sapi_header_struct sapi_header;
	char *colon_offset;
	char *header_line;
	uint header_line_len;
	int http_response_code;

	if (SG(headers_sent) && !SG(request_info).no_headers) {
		const char *output_start_filename = php_output_get_start_filename(TSRMLS_C);
		int output_start_lineno = php_output_get_start_lineno(TSRMLS_C);

		if (output_start_filename) {
			sapi_module.sapi_error(E_WARNING, ""Cannot modify header information - headers already sent by (output started at %s:%d)"",
				output_start_filename, output_start_lineno);
		} else {
			sapi_module.sapi_error(E_WARNING, ""Cannot modify header information - headers already sent"");
		}
		return FAILURE;
	}

	switch (op) {
		case SAPI_HEADER_SET_STATUS:
			sapi_update_response_code((int)(zend_intptr_t) arg TSRMLS_CC);
			return SUCCESS;

		case SAPI_HEADER_ADD:
		case SAPI_HEADER_REPLACE:
		case SAPI_HEADER_DELETE: {
				sapi_header_line *p = arg;

				if (!p->line || !p->line_len) {
					return FAILURE;
				}
				header_line = p->line;
				header_line_len = p->line_len;
				http_response_code = p->response_code;
				break;
			}

		case SAPI_HEADER_DELETE_ALL:
			if (sapi_module.header_handler) {
				sapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);
			}
			zend_llist_clean(&SG(sapi_headers).headers);
			return SUCCESS;

		default:
			return FAILURE;
	}

	header_line = estrndup(header_line, header_line_len);

	/* cut off trailing spaces, linefeeds and carriage-returns */
	if (header_line_len && isspace(header_line[header_line_len-1])) {
		do {
			header_line_len--;
		} while(header_line_len && isspace(header_line[header_line_len-1]));
		header_line[header_line_len]='\0';
	}
	
	if (op == SAPI_HEADER_DELETE) {
		if (strchr(header_line, ':')) {
			efree(header_line);
			sapi_module.sapi_error(E_WARNING, ""Header to delete may not contain colon."");
			return FAILURE;
		}
		if (sapi_module.header_handler) {
			sapi_header.header = header_line;
			sapi_header.header_len = header_line_len;
			sapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);
		}
		sapi_remove_header(&SG(sapi_headers).headers, header_line, header_line_len);
		efree(header_line);
		return SUCCESS;
	} else {
 		/* new line/NUL character safety check */
 		int i;
 		for (i = 0; i < header_line_len; i++) {
			/* RFC 2616 allows new lines if followed by SP or HT */
			int illegal_break =
					(header_line[i+1] != ' ' && header_line[i+1] != '\t')
					&& (
						header_line[i] == '\n'
						|| (header_line[i] == '\r' && header_line[i+1] != '\n'));
			if (illegal_break) {
 				efree(header_line);
 				sapi_module.sapi_error(E_WARNING, ""Header may not contain ""
 						""more than a single header, new line detected"");
				return FAILURE;
			}
			if (header_line[i] == '\0') {
				efree(header_line);
				sapi_module.sapi_error(E_WARNING, ""Header may not contain NUL bytes"");
				return FAILURE;
			}
		}
	}

	sapi_header.header = header_line;
	sapi_header.header_len = header_line_len;

	/* Check the header for a few cases that we have special support for in SAPI */
	if (header_line_len>=5 
		&& !strncasecmp(header_line, ""HTTP/"", 5)) {
		/* filter out the response code */
		sapi_update_response_code(sapi_extract_response_code(header_line) TSRMLS_CC);
		/* sapi_update_response_code doesn't free the status line if the code didn't change */
		if (SG(sapi_headers).http_status_line) {
			efree(SG(sapi_headers).http_status_line);
		}
		SG(sapi_headers).http_status_line = header_line;
		return SUCCESS;
	} else {
		colon_offset = strchr(header_line, ':');
		if (colon_offset) {
			*colon_offset = 0;
			if (!STRCASECMP(header_line, ""Content-Type"")) {
				char *ptr = colon_offset+1, *mimetype = NULL, *newheader;
				size_t len = header_line_len - (ptr - header_line), newlen;
				while (*ptr == ' ') {
					ptr++;
					len--;
				}

				/* Disable possible output compression for images */
				if (!strncmp(ptr, ""image/"", sizeof(""image/"")-1)) {
					zend_alter_ini_entry(""zlib.output_compression"", sizeof(""zlib.output_compression""), ""0"", sizeof(""0"") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
				}

				mimetype = estrdup(ptr);
				newlen = sapi_apply_default_charset(&mimetype, len TSRMLS_CC);
				if (!SG(sapi_headers).mimetype){
					SG(sapi_headers).mimetype = estrdup(mimetype);
				}

				if (newlen != 0) {
					newlen += sizeof(""Content-type: "");
					newheader = emalloc(newlen);
					PHP_STRLCPY(newheader, ""Content-type: "", newlen, sizeof(""Content-type: "")-1);
					strlcat(newheader, mimetype, newlen);
					sapi_header.header = newheader;
					sapi_header.header_len = newlen - 1;
					efree(header_line);
				}
				efree(mimetype);
				SG(sapi_headers).send_default_content_type = 0;
			} else if (!STRCASECMP(header_line, ""Content-Length"")) {
				/* Script is setting Content-length. The script cannot reasonably
				 * know the size of the message body after compression, so it's best
				 * do disable compression altogether. This contributes to making scripts
				 * portable between setups that have and don't have zlib compression
				 * enabled globally. See req #44164 */
				zend_alter_ini_entry(""zlib.output_compression"", sizeof(""zlib.output_compression""),
					""0"", sizeof(""0"") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
			} else if (!STRCASECMP(header_line, ""Location"")) {
				if ((SG(sapi_headers).http_response_code < 300 ||
					SG(sapi_headers).http_response_code > 399) &&
					SG(sapi_headers).http_response_code != 201) {
					/* Return a Found Redirect if one is not already specified */
					if (http_response_code) { /* user specified redirect code */
						sapi_update_response_code(http_response_code TSRMLS_CC);
					} else if (SG(request_info).proto_num > 1000 && 
					   SG(request_info).request_method && 
					   strcmp(SG(request_info).request_method, ""HEAD"") &&
					   strcmp(SG(request_info).request_method, ""GET"")) {
						sapi_update_response_code(303 TSRMLS_CC);
					} else {
						sapi_update_response_code(302 TSRMLS_CC);
					}
				}
			} else if (!STRCASECMP(header_line, ""WWW-Authenticate"")) { /* HTTP Authentication */
				sapi_update_response_code(401 TSRMLS_CC); /* authentication-required */
			}
			if (sapi_header.header==header_line) {
				*colon_offset = ':';
			}
		}
	}
	if (http_response_code) {
		sapi_update_response_code(http_response_code TSRMLS_CC);
	}
	sapi_header_add_op(op, &sapi_header TSRMLS_CC);
	return SUCCESS;
}
",C,"			/* RFC 7230 ch. 3.2.4 deprecates folding support */
			if (header_line[i] == '\n' || header_line[i] == '\r') {
","			/* RFC 2616 allows new lines if followed by SP or HT */
			int illegal_break =
					(header_line[i+1] != ' ' && header_line[i+1] != '\t')
					&& (
						header_line[i] == '\n'
						|| (header_line[i] == '\r' && header_line[i+1] != '\n'));
			if (illegal_break) {
",,"@@ -743,13 +743,8 @@ SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)
 		/* new line/NUL character safety check */
 		int i;
 		for (i = 0; i < header_line_len; i++) {
-			/* RFC 2616 allows new lines if followed by SP or HT */
-			int illegal_break =
-					(header_line[i+1] != ' ' && header_line[i+1] != '\t')
-					&& (
-						header_line[i] == '\n'
-						|| (header_line[i] == '\r' && header_line[i+1] != '\n'));
-			if (illegal_break) {
+			/* RFC 7230 ch. 3.2.4 deprecates folding support */
+			if (header_line[i] == '\n' || header_line[i] == '\r') {
 				efree(header_line);
 				sapi_module.sapi_error(E_WARNING, ""Header may not contain ""
 						""more than a single header, new line detected"");",php-src,996faf964bba1aec06b153b370a7f20d3dd2bb8b?w=1,d8bc34942d4f94cecdcbc63aa0772c5717525279,1,"SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)
{
	sapi_header_struct sapi_header;
	char *colon_offset;
	char *header_line;
	uint header_line_len;
	int http_response_code;

	if (SG(headers_sent) && !SG(request_info).no_headers) {
		const char *output_start_filename = php_output_get_start_filename(TSRMLS_C);
		int output_start_lineno = php_output_get_start_lineno(TSRMLS_C);

		if (output_start_filename) {
			sapi_module.sapi_error(E_WARNING, ""Cannot modify header information - headers already sent by (output started at %s:%d)"",
				output_start_filename, output_start_lineno);
		} else {
			sapi_module.sapi_error(E_WARNING, ""Cannot modify header information - headers already sent"");
		}
		return FAILURE;
	}

	switch (op) {
		case SAPI_HEADER_SET_STATUS:
			sapi_update_response_code((int)(zend_intptr_t) arg TSRMLS_CC);
			return SUCCESS;

		case SAPI_HEADER_ADD:
		case SAPI_HEADER_REPLACE:
		case SAPI_HEADER_DELETE: {
				sapi_header_line *p = arg;

				if (!p->line || !p->line_len) {
					return FAILURE;
				}
				header_line = p->line;
				header_line_len = p->line_len;
				http_response_code = p->response_code;
				break;
			}

		case SAPI_HEADER_DELETE_ALL:
			if (sapi_module.header_handler) {
				sapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);
			}
			zend_llist_clean(&SG(sapi_headers).headers);
			return SUCCESS;

		default:
			return FAILURE;
	}

	header_line = estrndup(header_line, header_line_len);

	/* cut off trailing spaces, linefeeds and carriage-returns */
	if (header_line_len && isspace(header_line[header_line_len-1])) {
		do {
			header_line_len--;
		} while(header_line_len && isspace(header_line[header_line_len-1]));
		header_line[header_line_len]='\0';
	}
	
	if (op == SAPI_HEADER_DELETE) {
		if (strchr(header_line, ':')) {
			efree(header_line);
			sapi_module.sapi_error(E_WARNING, ""Header to delete may not contain colon."");
			return FAILURE;
		}
		if (sapi_module.header_handler) {
			sapi_header.header = header_line;
			sapi_header.header_len = header_line_len;
			sapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);
		}
		sapi_remove_header(&SG(sapi_headers).headers, header_line, header_line_len);
		efree(header_line);
		return SUCCESS;
	} else {
 		/* new line/NUL character safety check */
 		int i;
 		for (i = 0; i < header_line_len; i++) {
//flaw_line_below:
			/* RFC 2616 allows new lines if followed by SP or HT */
//flaw_line_below:
			int illegal_break =
//flaw_line_below:
					(header_line[i+1] != ' ' && header_line[i+1] != '\t')
//flaw_line_below:
					&& (
//flaw_line_below:
						header_line[i] == '\n'
//flaw_line_below:
						|| (header_line[i] == '\r' && header_line[i+1] != '\n'));
//flaw_line_below:
			if (illegal_break) {
//fix_flaw_line_below:
//			/* RFC 7230 ch. 3.2.4 deprecates folding support */
//fix_flaw_line_below:
//			if (header_line[i] == '\n' || header_line[i] == '\r') {
 				efree(header_line);
 				sapi_module.sapi_error(E_WARNING, ""Header may not contain ""
 						""more than a single header, new line detected"");
				return FAILURE;
			}
			if (header_line[i] == '\0') {
				efree(header_line);
				sapi_module.sapi_error(E_WARNING, ""Header may not contain NUL bytes"");
				return FAILURE;
			}
		}
	}

	sapi_header.header = header_line;
	sapi_header.header_len = header_line_len;

	/* Check the header for a few cases that we have special support for in SAPI */
	if (header_line_len>=5 
		&& !strncasecmp(header_line, ""HTTP/"", 5)) {
		/* filter out the response code */
		sapi_update_response_code(sapi_extract_response_code(header_line) TSRMLS_CC);
		/* sapi_update_response_code doesn't free the status line if the code didn't change */
		if (SG(sapi_headers).http_status_line) {
			efree(SG(sapi_headers).http_status_line);
		}
		SG(sapi_headers).http_status_line = header_line;
		return SUCCESS;
	} else {
		colon_offset = strchr(header_line, ':');
		if (colon_offset) {
			*colon_offset = 0;
			if (!STRCASECMP(header_line, ""Content-Type"")) {
				char *ptr = colon_offset+1, *mimetype = NULL, *newheader;
				size_t len = header_line_len - (ptr - header_line), newlen;
				while (*ptr == ' ') {
					ptr++;
					len--;
				}

				/* Disable possible output compression for images */
				if (!strncmp(ptr, ""image/"", sizeof(""image/"")-1)) {
					zend_alter_ini_entry(""zlib.output_compression"", sizeof(""zlib.output_compression""), ""0"", sizeof(""0"") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
				}

				mimetype = estrdup(ptr);
				newlen = sapi_apply_default_charset(&mimetype, len TSRMLS_CC);
				if (!SG(sapi_headers).mimetype){
					SG(sapi_headers).mimetype = estrdup(mimetype);
				}

				if (newlen != 0) {
					newlen += sizeof(""Content-type: "");
					newheader = emalloc(newlen);
					PHP_STRLCPY(newheader, ""Content-type: "", newlen, sizeof(""Content-type: "")-1);
					strlcat(newheader, mimetype, newlen);
					sapi_header.header = newheader;
					sapi_header.header_len = newlen - 1;
					efree(header_line);
				}
				efree(mimetype);
				SG(sapi_headers).send_default_content_type = 0;
			} else if (!STRCASECMP(header_line, ""Content-Length"")) {
				/* Script is setting Content-length. The script cannot reasonably
				 * know the size of the message body after compression, so it's best
				 * do disable compression altogether. This contributes to making scripts
				 * portable between setups that have and don't have zlib compression
				 * enabled globally. See req #44164 */
				zend_alter_ini_entry(""zlib.output_compression"", sizeof(""zlib.output_compression""),
					""0"", sizeof(""0"") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
			} else if (!STRCASECMP(header_line, ""Location"")) {
				if ((SG(sapi_headers).http_response_code < 300 ||
					SG(sapi_headers).http_response_code > 399) &&
					SG(sapi_headers).http_response_code != 201) {
					/* Return a Found Redirect if one is not already specified */
					if (http_response_code) { /* user specified redirect code */
						sapi_update_response_code(http_response_code TSRMLS_CC);
					} else if (SG(request_info).proto_num > 1000 && 
					   SG(request_info).request_method && 
					   strcmp(SG(request_info).request_method, ""HEAD"") &&
					   strcmp(SG(request_info).request_method, ""GET"")) {
						sapi_update_response_code(303 TSRMLS_CC);
					} else {
						sapi_update_response_code(302 TSRMLS_CC);
					}
				}
			} else if (!STRCASECMP(header_line, ""WWW-Authenticate"")) { /* HTTP Authentication */
				sapi_update_response_code(401 TSRMLS_CC); /* authentication-required */
			}
			if (sapi_header.header==header_line) {
				*colon_offset = ':';
			}
		}
	}
	if (http_response_code) {
		sapi_update_response_code(http_response_code TSRMLS_CC);
	}
	sapi_header_add_op(op, &sapi_header TSRMLS_CC);
	return SUCCESS;
}
"
4464,182200,,Remote,Not required,,CVE-2018-17082,https://www.cvedetails.com/cve/CVE-2018-17082/,CWE-79,Medium,,Partial,,2018-09-16,4.3,"The Apache2 component in PHP before 5.6.38, 7.0.x before 7.0.32, 7.1.x before 7.1.22, and 7.2.x before 7.2.10 allows XSS via the body of a *Transfer-Encoding: chunked* request, because the bucket brigade is mishandled in the php_handler function in sapi/apache2handler/sapi_apache2.c.",2019-08-19,XSS ,1,https://github.com/php/php-src/commit/23b057742e3cf199612fa8050ae86cae675e214e,23b057742e3cf199612fa8050ae86cae675e214e,"Fix for bug #76582

The brigade seems to end up in a messed up state if something fails
in shutdown, so we clean it up.",0,sapi/apache2handler/sapi_apache2.c,"{""sha"": ""0ebca9bca863909aef3fd3417bb3baad1605df34"", ""filename"": ""sapi/apache2handler/sapi_apache2.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/php/php-src/blob/23b057742e3cf199612fa8050ae86cae675e214e/sapi/apache2handler/sapi_apache2.c"", ""raw_url"": ""https://github.com/php/php-src/raw/23b057742e3cf199612fa8050ae86cae675e214e/sapi/apache2handler/sapi_apache2.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/sapi/apache2handler/sapi_apache2.c?ref=23b057742e3cf199612fa8050ae86cae675e214e"", ""patch"": ""@@ -678,6 +678,7 @@ zend_first_try {\n \tif (!parent_req) {\n \t\tphp_apache_request_dtor(r TSRMLS_CC);\n \t\tctx->request_processed = 1;\n+\t\tapr_brigade_cleanup(brigade);\n \t\tbucket = apr_bucket_eos_create(r->connection->bucket_alloc);\n \t\tAPR_BRIGADE_INSERT_TAIL(brigade, bucket);\n ""}","static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
","static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
",C,"		apr_brigade_cleanup(brigade);
",,,"@@ -678,6 +678,7 @@ zend_first_try {
 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
+		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 ",php-src,23b057742e3cf199612fa8050ae86cae675e214e,1ba3314335b8bb7c86c24443588d5ef9c55d4a44,1,"static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
//fix_flaw_line_below:
//		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
"
6547,184283,,Remote,Not required,,CVE-2012-2889,https://www.cvedetails.com/cve/CVE-2012-2889/,CWE-79,Medium,,Partial,,2012-09-26,4.3,"Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*",2017-09-18,XSS ,1,https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5,7f8cdab6fda192d15e45a3e9682b1eec427870c5,"[views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/ui/views/extensions/shell_window_views.cc,"{""sha"": ""5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b"", ""filename"": ""chrome/browser/ui/views/extensions/shell_window_views.cc"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 16, ""changes"": 53, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5"", ""patch"": ""@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \""browser/ui/views/extensions/ShellWindowFrameView\"";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }""}"," void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
"," void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
   if (sender == close_button_)
     frame_->Close();
 }
",C,"  DCHECK(!is_frameless_);
",,,"@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     ""browser/ui/views/extensions/ShellWindowFrameView"";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }",Chrome,7f8cdab6fda192d15e45a3e9682b1eec427870c5,d7ddf81573776614bf124ce1845b99f9115fb64b,1," void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
//fix_flaw_line_below:
//  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
"
6548,184284,,Remote,Not required,,CVE-2012-2889,https://www.cvedetails.com/cve/CVE-2012-2889/,CWE-79,Medium,,Partial,,2012-09-26,4.3,"Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*",2017-09-18,XSS ,2,https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5,7f8cdab6fda192d15e45a3e9682b1eec427870c5,"[views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98",1,chrome/browser/ui/views/extensions/shell_window_views.cc,"{""sha"": ""5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b"", ""filename"": ""chrome/browser/ui/views/extensions/shell_window_views.cc"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 16, ""changes"": 53, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5"", ""patch"": ""@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \""browser/ui/views/extensions/ShellWindowFrameView\"";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }""}"," views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
  ShellWindowFrameView* frame_view =
      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }
"," views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
   frame_view->Init(window_);
   return frame_view;
 }
",C,"  ShellWindowFrameView* frame_view =
      new ShellWindowFrameView(use_custom_frame_);
","  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
",,"@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     ""browser/ui/views/extensions/ShellWindowFrameView"";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }",Chrome,7f8cdab6fda192d15e45a3e9682b1eec427870c5,d7ddf81573776614bf124ce1845b99f9115fb64b,1," views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
//flaw_line_below:
  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
//fix_flaw_line_below:
//  ShellWindowFrameView* frame_view =
//fix_flaw_line_below:
//      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }
"
6549,184285,,Remote,Not required,,CVE-2012-2889,https://www.cvedetails.com/cve/CVE-2012-2889/,CWE-79,Medium,,Partial,,2012-09-26,4.3,"Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*",2017-09-18,XSS ,1,https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5,7f8cdab6fda192d15e45a3e9682b1eec427870c5,"[views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98",1,chrome/browser/ui/views/extensions/shell_window_views.cc,"{""sha"": ""5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b"", ""filename"": ""chrome/browser/ui/views/extensions/shell_window_views.cc"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 16, ""changes"": 53, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5"", ""patch"": ""@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \""browser/ui/views/extensions/ShellWindowFrameView\"";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }""}"," gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
"," gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
  if (frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
",C,"  if (is_frameless_ || frame_->IsFullscreen())
","  if (frame_->IsFullscreen())
",,"@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     ""browser/ui/views/extensions/ShellWindowFrameView"";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }",Chrome,7f8cdab6fda192d15e45a3e9682b1eec427870c5,d7ddf81573776614bf124ce1845b99f9115fb64b,1," gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
//flaw_line_below:
  if (frame_->IsFullscreen())
//fix_flaw_line_below:
//  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
"
6550,184286,,Remote,Not required,,CVE-2012-2889,https://www.cvedetails.com/cve/CVE-2012-2889/,CWE-79,Medium,,Partial,,2012-09-26,4.3,"Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*",2017-09-18,XSS ,3,https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5,7f8cdab6fda192d15e45a3e9682b1eec427870c5,"[views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/ui/views/extensions/shell_window_views.cc,"{""sha"": ""5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b"", ""filename"": ""chrome/browser/ui/views/extensions/shell_window_views.cc"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 16, ""changes"": 53, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5"", ""patch"": ""@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \""browser/ui/views/extensions/ShellWindowFrameView\"";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }""}"," gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
  if (is_frameless_)
    return max_size;

   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
  }
  return max_size;
}
"," gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
  }
  return max_size;
}
",C,"  if (is_frameless_)
    return max_size;

",,,"@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     ""browser/ui/views/extensions/ShellWindowFrameView"";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }",Chrome,7f8cdab6fda192d15e45a3e9682b1eec427870c5,d7ddf81573776614bf124ce1845b99f9115fb64b,1," gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
//fix_flaw_line_below:
//  if (is_frameless_)
//fix_flaw_line_below:
//    return max_size;
//fix_flaw_line_below:
//
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
  }
  return max_size;
}
"
6551,184287,,Remote,Not required,,CVE-2012-2889,https://www.cvedetails.com/cve/CVE-2012-2889/,CWE-79,Medium,,Partial,,2012-09-26,4.3,"Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*",2017-09-18,XSS ,3,https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5,7f8cdab6fda192d15e45a3e9682b1eec427870c5,"[views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/ui/views/extensions/shell_window_views.cc,"{""sha"": ""5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b"", ""filename"": ""chrome/browser/ui/views/extensions/shell_window_views.cc"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 16, ""changes"": 53, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5"", ""patch"": ""@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \""browser/ui/views/extensions/ShellWindowFrameView\"";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }""}"," gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
  if (is_frameless_)
    return min_size;

   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
  int closeButtonOffsetX =
      (kCaptionHeight - close_button_->height()) / 2;
  int header_width = close_button_->width() + closeButtonOffsetX * 2;
  if (header_width > min_size.width())
    min_size.set_width(header_width);
  return min_size;
}
"," gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
  int closeButtonOffsetX =
      (kCaptionHeight - close_button_->height()) / 2;
  int header_width = close_button_->width() + closeButtonOffsetX * 2;
  if (header_width > min_size.width())
    min_size.set_width(header_width);
  return min_size;
}
",C,"  if (is_frameless_)
    return min_size;

",,,"@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     ""browser/ui/views/extensions/ShellWindowFrameView"";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }",Chrome,7f8cdab6fda192d15e45a3e9682b1eec427870c5,d7ddf81573776614bf124ce1845b99f9115fb64b,1," gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
//fix_flaw_line_below:
//  if (is_frameless_)
//fix_flaw_line_below:
//    return min_size;
//fix_flaw_line_below:
//
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
  // Ensure we have enough space for the window icon and buttons.  We allow
  // the title string to collapse to zero width.
  int closeButtonOffsetX =
      (kCaptionHeight - close_button_->height()) / 2;
  int header_width = close_button_->width() + closeButtonOffsetX * 2;
  if (header_width > min_size.width())
    min_size.set_width(header_width);
  return min_size;
}
"
6552,184288,,Remote,Not required,,CVE-2012-2889,https://www.cvedetails.com/cve/CVE-2012-2889/,CWE-79,Medium,,Partial,,2012-09-26,4.3,"Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*",2017-09-18,XSS ,3,https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5,7f8cdab6fda192d15e45a3e9682b1eec427870c5,"[views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/ui/views/extensions/shell_window_views.cc,"{""sha"": ""5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b"", ""filename"": ""chrome/browser/ui/views/extensions/shell_window_views.cc"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 16, ""changes"": 53, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5"", ""patch"": ""@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \""browser/ui/views/extensions/ShellWindowFrameView\"";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }""}"," gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
  if (is_frameless_)
    return client_bounds;

   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
  return gfx::Rect(client_bounds.x(),
                   std::max(0, client_bounds.y() - kCaptionHeight),
                   std::max(header_width, client_bounds.width()),
                   client_bounds.height() + kCaptionHeight);
}
"," gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
  return gfx::Rect(client_bounds.x(),
                   std::max(0, client_bounds.y() - kCaptionHeight),
                   std::max(header_width, client_bounds.width()),
                   client_bounds.height() + kCaptionHeight);
}
",C,"  if (is_frameless_)
    return client_bounds;

",,,"@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     ""browser/ui/views/extensions/ShellWindowFrameView"";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }",Chrome,7f8cdab6fda192d15e45a3e9682b1eec427870c5,d7ddf81573776614bf124ce1845b99f9115fb64b,1," gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
//fix_flaw_line_below:
//  if (is_frameless_)
//fix_flaw_line_below:
//    return client_bounds;
//fix_flaw_line_below:
//
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
  return gfx::Rect(client_bounds.x(),
                   std::max(0, client_bounds.y() - kCaptionHeight),
                   std::max(header_width, client_bounds.width()),
                   client_bounds.height() + kCaptionHeight);
}
"
6553,184289,,Remote,Not required,,CVE-2012-2889,https://www.cvedetails.com/cve/CVE-2012-2889/,CWE-79,Medium,,Partial,,2012-09-26,4.3,"Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*",2017-09-18,XSS ,14,https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5,7f8cdab6fda192d15e45a3e9682b1eec427870c5,"[views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98",11,chrome/browser/ui/views/extensions/shell_window_views.cc,"{""sha"": ""5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b"", ""filename"": ""chrome/browser/ui/views/extensions/shell_window_views.cc"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 16, ""changes"": 53, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5"", ""patch"": ""@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \""browser/ui/views/extensions/ShellWindowFrameView\"";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }""}"," void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;

  if (!is_frameless_) {
    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
    close_button_ = new views::ImageButton(this);
    close_button_->SetImage(views::CustomButton::BS_NORMAL,
        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
    close_button_->SetImage(views::CustomButton::BS_HOT,
        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
    close_button_->SetImage(views::CustomButton::BS_PUSHED,
        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
    close_button_->SetAccessibleName(
        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
    AddChildView(close_button_);
  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
  int outside_bounds = ui::GetDisplayLayout() == ui::LAYOUT_TOUCH ?
      kResizeOutsideBoundsSizeTouch :
      kResizeOutsideBoundsSize;
  window->set_hit_test_bounds_override_outer(
      gfx::Insets(-outside_bounds, -outside_bounds,
                  -outside_bounds, -outside_bounds));
  window->set_hit_test_bounds_override_inner(
      gfx::Insets(kResizeInsideBoundsSize, kResizeInsideBoundsSize,
                  kResizeInsideBoundsSize, kResizeInsideBoundsSize));
#endif
 }
"," void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
  close_button_ = new views::ImageButton(this);
  close_button_->SetImage(views::CustomButton::BS_NORMAL,
      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
  close_button_->SetImage(views::CustomButton::BS_HOT,
      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
  close_button_->SetImage(views::CustomButton::BS_PUSHED,
      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
  close_button_->SetAccessibleName(
      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
  AddChildView(close_button_);
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
  int outside_bounds = ui::GetDisplayLayout() == ui::LAYOUT_TOUCH ?
      kResizeOutsideBoundsSizeTouch :
      kResizeOutsideBoundsSize;
  window->set_hit_test_bounds_override_outer(
      gfx::Insets(-outside_bounds, -outside_bounds,
                  -outside_bounds, -outside_bounds));
  window->set_hit_test_bounds_override_inner(
      gfx::Insets(kResizeInsideBoundsSize, kResizeInsideBoundsSize,
                  kResizeInsideBoundsSize, kResizeInsideBoundsSize));
#endif
 }
",C,"
  if (!is_frameless_) {
    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
    close_button_ = new views::ImageButton(this);
    close_button_->SetImage(views::CustomButton::BS_NORMAL,
        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
    close_button_->SetImage(views::CustomButton::BS_HOT,
        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
    close_button_->SetImage(views::CustomButton::BS_PUSHED,
        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
    close_button_->SetAccessibleName(
        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
    AddChildView(close_button_);
  }
","  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
  close_button_ = new views::ImageButton(this);
  close_button_->SetImage(views::CustomButton::BS_NORMAL,
      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
  close_button_->SetImage(views::CustomButton::BS_HOT,
      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
  close_button_->SetImage(views::CustomButton::BS_PUSHED,
      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
  close_button_->SetAccessibleName(
      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
  AddChildView(close_button_);
",,"@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     ""browser/ui/views/extensions/ShellWindowFrameView"";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }",Chrome,7f8cdab6fda192d15e45a3e9682b1eec427870c5,d7ddf81573776614bf124ce1845b99f9115fb64b,1," void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
//flaw_line_below:
  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
//flaw_line_below:
  close_button_ = new views::ImageButton(this);
//flaw_line_below:
  close_button_->SetImage(views::CustomButton::BS_NORMAL,
//flaw_line_below:
      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
//flaw_line_below:
  close_button_->SetImage(views::CustomButton::BS_HOT,
//flaw_line_below:
      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
//flaw_line_below:
  close_button_->SetImage(views::CustomButton::BS_PUSHED,
//flaw_line_below:
      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
//flaw_line_below:
  close_button_->SetAccessibleName(
//flaw_line_below:
      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
//flaw_line_below:
  AddChildView(close_button_);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  if (!is_frameless_) {
//fix_flaw_line_below:
//    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
//fix_flaw_line_below:
//    close_button_ = new views::ImageButton(this);
//fix_flaw_line_below:
//    close_button_->SetImage(views::CustomButton::BS_NORMAL,
//fix_flaw_line_below:
//        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
//fix_flaw_line_below:
//    close_button_->SetImage(views::CustomButton::BS_HOT,
//fix_flaw_line_below:
//        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
//fix_flaw_line_below:
//    close_button_->SetImage(views::CustomButton::BS_PUSHED,
//fix_flaw_line_below:
//        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
//fix_flaw_line_below:
//    close_button_->SetAccessibleName(
//fix_flaw_line_below:
//        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
//fix_flaw_line_below:
//    AddChildView(close_button_);
//fix_flaw_line_below:
//  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
  // Ensure we get resize cursors for a few pixels outside our bounds.
  int outside_bounds = ui::GetDisplayLayout() == ui::LAYOUT_TOUCH ?
      kResizeOutsideBoundsSizeTouch :
      kResizeOutsideBoundsSize;
  window->set_hit_test_bounds_override_outer(
      gfx::Insets(-outside_bounds, -outside_bounds,
                  -outside_bounds, -outside_bounds));
  // Ensure we get resize cursors just inside our bounds as well.
  // TODO(jeremya): do we need to update these when in fullscreen/maximized?
  window->set_hit_test_bounds_override_inner(
      gfx::Insets(kResizeInsideBoundsSize, kResizeInsideBoundsSize,
                  kResizeInsideBoundsSize, kResizeInsideBoundsSize));
#endif
 }
"
6554,184290,,Remote,Not required,,CVE-2012-2889,https://www.cvedetails.com/cve/CVE-2012-2889/,CWE-79,Medium,,Partial,,2012-09-26,4.3,"Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*",2017-09-18,XSS ,2,https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5,7f8cdab6fda192d15e45a3e9682b1eec427870c5,"[views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/ui/views/extensions/shell_window_views.cc,"{""sha"": ""5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b"", ""filename"": ""chrome/browser/ui/views/extensions/shell_window_views.cc"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 16, ""changes"": 53, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5"", ""patch"": ""@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \""browser/ui/views/extensions/ShellWindowFrameView\"";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }""}"," void ShellWindowFrameView::Layout() {
  if (is_frameless_)
    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
  int closeButtonOffsetX = closeButtonOffsetY;
  close_button_->SetBounds(
      width() - closeButtonOffsetX - close_size.width(),
      closeButtonOffsetY,
      close_size.width(),
      close_size.height());
 }
"," void ShellWindowFrameView::Layout() {
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
  int closeButtonOffsetX = closeButtonOffsetY;
  close_button_->SetBounds(
      width() - closeButtonOffsetX - close_size.width(),
      closeButtonOffsetY,
      close_size.width(),
      close_size.height());
 }
",C,"  if (is_frameless_)
    return;
",,,"@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     ""browser/ui/views/extensions/ShellWindowFrameView"";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }",Chrome,7f8cdab6fda192d15e45a3e9682b1eec427870c5,d7ddf81573776614bf124ce1845b99f9115fb64b,1," void ShellWindowFrameView::Layout() {
//fix_flaw_line_below:
//  if (is_frameless_)
//fix_flaw_line_below:
//    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
  int closeButtonOffsetX = closeButtonOffsetY;
  close_button_->SetBounds(
      width() - closeButtonOffsetX - close_size.width(),
      closeButtonOffsetY,
      close_size.width(),
      close_size.height());
 }
"
6555,184291,,Remote,Not required,,CVE-2012-2889,https://www.cvedetails.com/cve/CVE-2012-2889/,CWE-79,Medium,,Partial,,2012-09-26,4.3,"Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*",2017-09-18,XSS ,2,https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5,7f8cdab6fda192d15e45a3e9682b1eec427870c5,"[views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/ui/views/extensions/shell_window_views.cc,"{""sha"": ""5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b"", ""filename"": ""chrome/browser/ui/views/extensions/shell_window_views.cc"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 16, ""changes"": 53, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5"", ""patch"": ""@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \""browser/ui/views/extensions/ShellWindowFrameView\"";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }""}"," void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
  if (is_frameless_)
    return;
   SkPaint paint;
   paint.setAntiAlias(false);
  paint.setStyle(SkPaint::kFill_Style);
  paint.setColor(SK_ColorWHITE);
  gfx::Path path;
  const int radius = 1;
  path.moveTo(0, radius);
  path.lineTo(radius, 0);
  path.lineTo(width() - radius - 1, 0);
  path.lineTo(width(), radius + 1);
  path.lineTo(width(), kCaptionHeight);
  path.lineTo(0, kCaptionHeight);
  path.close();
  canvas->DrawPath(path, paint);
}
"," void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
   SkPaint paint;
   paint.setAntiAlias(false);
  paint.setStyle(SkPaint::kFill_Style);
  paint.setColor(SK_ColorWHITE);
  gfx::Path path;
  const int radius = 1;
  path.moveTo(0, radius);
  path.lineTo(radius, 0);
  path.lineTo(width() - radius - 1, 0);
  path.lineTo(width(), radius + 1);
  path.lineTo(width(), kCaptionHeight);
  path.lineTo(0, kCaptionHeight);
  path.close();
  canvas->DrawPath(path, paint);
}
",C,"  if (is_frameless_)
    return;
",,,"@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     ""browser/ui/views/extensions/ShellWindowFrameView"";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }",Chrome,7f8cdab6fda192d15e45a3e9682b1eec427870c5,d7ddf81573776614bf124ce1845b99f9115fb64b,1," void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
//fix_flaw_line_below:
//  if (is_frameless_)
//fix_flaw_line_below:
//    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
  paint.setStyle(SkPaint::kFill_Style);
  paint.setColor(SK_ColorWHITE);
  gfx::Path path;
  const int radius = 1;
  path.moveTo(0, radius);
  path.lineTo(radius, 0);
  path.lineTo(width() - radius - 1, 0);
  path.lineTo(width(), radius + 1);
  path.lineTo(width(), kCaptionHeight);
  path.lineTo(0, kCaptionHeight);
  path.close();
  canvas->DrawPath(path, paint);
}
"
6556,184292,,Remote,Not required,,CVE-2012-2889,https://www.cvedetails.com/cve/CVE-2012-2889/,CWE-79,Medium,,Partial,,2012-09-26,4.3,"Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*",2017-09-18,XSS ,3,https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5,7f8cdab6fda192d15e45a3e9682b1eec427870c5,"[views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98",1,chrome/browser/ui/views/extensions/shell_window_views.cc,"{""sha"": ""5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b"", ""filename"": ""chrome/browser/ui/views/extensions/shell_window_views.cc"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 16, ""changes"": 53, ""blob_url"": ""https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5"", ""patch"": ""@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \""browser/ui/views/extensions/ShellWindowFrameView\"";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }""}","ShellWindowFrameView::ShellWindowFrameView()
ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
      close_button_(NULL),
      is_frameless_(frameless) {
 }
","ShellWindowFrameView::ShellWindowFrameView()
     : frame_(NULL),
      close_button_(NULL) {
 }
",C,"ShellWindowFrameView::ShellWindowFrameView(bool frameless)
      close_button_(NULL),
      is_frameless_(frameless) {
","      close_button_(NULL) {
",,"@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     ""browser/ui/views/extensions/ShellWindowFrameView"";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }",Chrome,7f8cdab6fda192d15e45a3e9682b1eec427870c5,d7ddf81573776614bf124ce1845b99f9115fb64b,1,"ShellWindowFrameView::ShellWindowFrameView()
//fix_flaw_line_below:
//ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
//flaw_line_below:
      close_button_(NULL) {
//fix_flaw_line_below:
//      close_button_(NULL),
//fix_flaw_line_below:
//      is_frameless_(frameless) {
 }
"
6557,184293,,Remote,Not required,,CVE-2012-2886,https://www.cvedetails.com/cve/CVE-2012-2886/,CWE-79,Medium,,Partial,,2012-09-26,4.3,"Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors related to the Google V8 bindings, aka *Universal XSS (UXSS).*",2018-10-30,XSS ,2,https://github.com/chromium/chromium/commit/10b688f204a81d8447c83021624220607353552e,10b688f204a81d8447c83021624220607353552e,"ash: Make UserActivityDetector ignore synthetic mouse events

This may have been preventing us from suspending (e.g.
mouse event is synthesized in response to lock window being
shown so Chrome tells powerd that the user is active).

BUG=133419
TEST=added


Review URL: https://chromiumcodereview.appspot.com/10574044

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143437 0039d316-1c4b-4281-b951-d872f2087c98",1,ash/wm/user_activity_detector.cc,"{""sha"": ""5a3b04dc4fb34943c5bb0a1129e74498162f68be"", ""filename"": ""ash/ash.gyp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/ash.gyp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/ash.gyp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/ash.gyp?ref=10b688f204a81d8447c83021624220607353552e"", ""patch"": ""@@ -421,6 +421,7 @@\n         'wm/system_gesture_event_filter_unittest.cc',\n         'wm/system_modal_container_layout_manager_unittest.cc',\n         'wm/toplevel_window_event_filter_unittest.cc',\n+        'wm/user_activity_detector_unittest.cc',\n         'wm/video_detector_unittest.cc',\n         'wm/visibility_controller_unittest.cc',\n         'wm/window_animations_unittest.cc',""}<_**next**_>{""sha"": ""5329087294664a540f505add21d0850ec2cc4518"", ""filename"": ""ash/wm/user_activity_detector.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/wm/user_activity_detector.cc?ref=10b688f204a81d8447c83021624220607353552e"", ""patch"": ""@@ -5,6 +5,7 @@\n #include \""ash/wm/user_activity_detector.h\""\n \n #include \""ash/wm/user_activity_observer.h\""\n+#include \""ui/aura/event.h\""\n \n namespace ash {\n \n@@ -32,7 +33,8 @@ bool UserActivityDetector::PreHandleKeyEvent(aura::Window* target,\n \n bool UserActivityDetector::PreHandleMouseEvent(aura::Window* target,\n                                                aura::MouseEvent* event) {\n-  MaybeNotify();\n+  if (!(event->flags() & ui::EF_IS_SYNTHESIZED))\n+    MaybeNotify();\n   return false;\n }\n \n@@ -51,7 +53,8 @@ ui::GestureStatus UserActivityDetector::PreHandleGestureEvent(\n }\n \n void UserActivityDetector::MaybeNotify() {\n-  base::TimeTicks now = base::TimeTicks::Now();\n+  base::TimeTicks now =\n+      !now_for_test_.is_null() ? now_for_test_ : base::TimeTicks::Now();\n   if (last_observer_notification_time_.is_null() ||\n       (now - last_observer_notification_time_).InSecondsF() >=\n       kNotifyIntervalSec) {""}<_**next**_>{""sha"": ""a6114db8e48d3c4edeb91d872bf4e3c80b53f068"", ""filename"": ""ash/wm/user_activity_detector.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/wm/user_activity_detector.h?ref=10b688f204a81d8447c83021624220607353552e"", ""patch"": ""@@ -27,6 +27,8 @@ class ASH_EXPORT UserActivityDetector : public aura::EventFilter {\n   UserActivityDetector();\n   virtual ~UserActivityDetector();\n \n+  void set_now_for_test(base::TimeTicks now) { now_for_test_ = now; }\n+\n   void AddObserver(UserActivityObserver* observer);\n   void RemoveObserver(UserActivityObserver* observer);\n \n@@ -53,6 +55,10 @@ class ASH_EXPORT UserActivityDetector : public aura::EventFilter {\n   // Last time at which we notified observers that the user was active.\n   base::TimeTicks last_observer_notification_time_;\n \n+  // If set, used when the current time is needed.  This can be set by tests to\n+  // simulate the passage of time.\n+  base::TimeTicks now_for_test_;\n+\n   DISALLOW_COPY_AND_ASSIGN(UserActivityDetector);\n };\n ""}<_**next**_>{""sha"": ""3af566b469c90b336b46254f7ef4e5bd249c8684"", ""filename"": ""ash/wm/user_activity_detector_unittest.cc"", ""status"": ""added"", ""additions"": 156, ""deletions"": 0, ""changes"": 156, ""blob_url"": ""https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/wm/user_activity_detector_unittest.cc?ref=10b688f204a81d8447c83021624220607353552e"", ""patch"": ""@@ -0,0 +1,156 @@\n+// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""ash/wm/user_activity_detector.h\""\n+\n+#include \""ash/shell.h\""\n+#include \""ash/test/ash_test_base.h\""\n+#include \""ash/wm/user_activity_observer.h\""\n+#include \""base/compiler_specific.h\""\n+#include \""base/memory/scoped_ptr.h\""\n+#include \""base/time.h\""\n+#include \""ui/aura/event.h\""\n+#include \""ui/aura/test/test_windows.h\""\n+#include \""ui/aura/window.h\""\n+#include \""ui/base/events.h\""\n+#include \""ui/base/keycodes/keyboard_codes.h\""\n+#include \""ui/gfx/point.h\""\n+\n+namespace ash {\n+namespace test {\n+\n+// Implementation that just counts the number of times we've been told that the\n+// user is active.\n+class TestUserActivityObserver : public UserActivityObserver {\n+ public:\n+  TestUserActivityObserver() : num_invocations_(0) {}\n+\n+  int num_invocations() const { return num_invocations_; }\n+  void reset_stats() { num_invocations_ = 0; }\n+\n+  // UserActivityObserver implementation.\n+  virtual void OnUserActivity() OVERRIDE { num_invocations_++; }\n+\n+ private:\n+  // Number of times that OnUserActivity() has been called.\n+  int num_invocations_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(TestUserActivityObserver);\n+};\n+\n+class UserActivityDetectorTest : public AshTestBase {\n+ public:\n+  UserActivityDetectorTest() {}\n+  virtual ~UserActivityDetectorTest() {}\n+\n+  virtual void SetUp() OVERRIDE {\n+    AshTestBase::SetUp();\n+    observer_.reset(new TestUserActivityObserver);\n+    detector_ = Shell::GetInstance()->user_activity_detector();\n+    detector_->AddObserver(observer_.get());\n+\n+    now_ = base::TimeTicks::Now();\n+    detector_->set_now_for_test(now_);\n+  }\n+\n+  virtual void TearDown() OVERRIDE {\n+    detector_->RemoveObserver(observer_.get());\n+    AshTestBase::TearDown();\n+  }\n+\n+ protected:\n+  // Move |detector_|'s idea of the current time forward by |delta|.\n+  void AdvanceTime(base::TimeDelta delta) {\n+    now_ += delta;\n+    detector_->set_now_for_test(now_);\n+  }\n+\n+  UserActivityDetector* detector_;  // not owned\n+\n+  scoped_ptr<TestUserActivityObserver> observer_;\n+\n+  base::TimeTicks now_;\n+\n+ private:\n+  DISALLOW_COPY_AND_ASSIGN(UserActivityDetectorTest);\n+};\n+\n+// Checks that the observer is notified in response to different types of input\n+// events.\n+TEST_F(UserActivityDetectorTest, Basic) {\n+  scoped_ptr<aura::Window> window(\n+      aura::test::CreateTestWindowWithId(12345, NULL));\n+\n+  aura::KeyEvent key_event(ui::ET_KEY_PRESSED, ui::VKEY_A, ui::EF_NONE);\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &key_event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  base::TimeDelta advance_delta =\n+      base::TimeDelta::FromSeconds(UserActivityDetector::kNotifyIntervalSec);\n+  AdvanceTime(advance_delta);\n+  aura::MouseEvent mouse_event(\n+      ui::ET_MOUSE_MOVED, gfx::Point(), gfx::Point(), ui::EF_NONE);\n+  EXPECT_FALSE(detector_->PreHandleMouseEvent(window.get(), &mouse_event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  AdvanceTime(advance_delta);\n+  aura::TouchEvent touch_event(\n+      ui::ET_TOUCH_PRESSED, gfx::Point(), 0, base::TimeDelta());\n+  EXPECT_FALSE(detector_->PreHandleTouchEvent(window.get(), &touch_event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  AdvanceTime(advance_delta);\n+  aura::GestureEvent gesture_event(\n+      ui::ET_GESTURE_TAP, 0, 0, ui::EF_NONE, base::Time(), 0, 0, 0U);\n+  EXPECT_FALSE(detector_->PreHandleGestureEvent(window.get(), &gesture_event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+}\n+\n+// Checks that observers aren't notified too frequently.\n+TEST_F(UserActivityDetectorTest, RateLimitNotifications) {\n+  scoped_ptr<aura::Window> window(\n+      aura::test::CreateTestWindowWithId(12345, NULL));\n+\n+  // The observer should be notified about a key event.\n+  aura::KeyEvent event(ui::ET_KEY_PRESSED, ui::VKEY_A, ui::EF_NONE);\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  // It shouldn't be notified if a second event occurs in the same second,\n+  // though.\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &event));\n+  EXPECT_EQ(0, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  // Advance the time, but not quite enough for another notification to be sent.\n+  AdvanceTime(\n+      base::TimeDelta::FromSeconds(\n+          UserActivityDetector::kNotifyIntervalSec - 1));\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &event));\n+  EXPECT_EQ(0, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  // One second later, we should send a notification again.\n+  AdvanceTime(base::TimeDelta::FromSeconds(1));\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+}\n+\n+// Checks that the detector ignores synthetic mouse events.\n+TEST_F(UserActivityDetectorTest, IgnoreSyntheticMouseEvents) {\n+  scoped_ptr<aura::Window> window(\n+      aura::test::CreateTestWindowWithId(12345, NULL));\n+  aura::MouseEvent mouse_event(\n+      ui::ET_MOUSE_MOVED, gfx::Point(), gfx::Point(), ui::EF_IS_SYNTHESIZED);\n+  EXPECT_FALSE(detector_->PreHandleMouseEvent(window.get(), &mouse_event));\n+  EXPECT_EQ(0, observer_->num_invocations());\n+}\n+\n+}  // namespace test\n+}  // namespace ash""}<_**next**_>{""sha"": ""0730ee7b7e50968ca9b08da0b23939667fa989c7"", ""filename"": ""ash/wm/video_detector_unittest.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/wm/video_detector_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/wm/video_detector_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/wm/video_detector_unittest.cc?ref=10b688f204a81d8447c83021624220607353552e"", ""patch"": ""@@ -53,6 +53,11 @@ class VideoDetectorTest : public AshTestBase {\n     detector_->set_now_for_test(now_);\n   }\n \n+  virtual void TearDown() OVERRIDE {\n+    detector_->RemoveObserver(observer_.get());\n+    AshTestBase::TearDown();\n+  }\n+\n  protected:\n   // Move |detector_|'s idea of the current time forward by |delta|.\n   void AdvanceTime(base::TimeDelta delta) {""}"," void UserActivityDetector::MaybeNotify() {
  base::TimeTicks now =
      !now_for_test_.is_null() ? now_for_test_ : base::TimeTicks::Now();
   if (last_observer_notification_time_.is_null() ||
       (now - last_observer_notification_time_).InSecondsF() >=
       kNotifyIntervalSec) {
    FOR_EACH_OBSERVER(UserActivityObserver, observers_, OnUserActivity());
    last_observer_notification_time_ = now;
  }
}
"," void UserActivityDetector::MaybeNotify() {
  base::TimeTicks now = base::TimeTicks::Now();
   if (last_observer_notification_time_.is_null() ||
       (now - last_observer_notification_time_).InSecondsF() >=
       kNotifyIntervalSec) {
    FOR_EACH_OBSERVER(UserActivityObserver, observers_, OnUserActivity());
    last_observer_notification_time_ = now;
  }
}
",C,"  base::TimeTicks now =
      !now_for_test_.is_null() ? now_for_test_ : base::TimeTicks::Now();
","  base::TimeTicks now = base::TimeTicks::Now();
",,"@@ -5,6 +5,7 @@
 #include ""ash/wm/user_activity_detector.h""
 
 #include ""ash/wm/user_activity_observer.h""
+#include ""ui/aura/event.h""
 
 namespace ash {
 
@@ -32,7 +33,8 @@ bool UserActivityDetector::PreHandleKeyEvent(aura::Window* target,
 
 bool UserActivityDetector::PreHandleMouseEvent(aura::Window* target,
                                                aura::MouseEvent* event) {
-  MaybeNotify();
+  if (!(event->flags() & ui::EF_IS_SYNTHESIZED))
+    MaybeNotify();
   return false;
 }
 
@@ -51,7 +53,8 @@ ui::GestureStatus UserActivityDetector::PreHandleGestureEvent(
 }
 
 void UserActivityDetector::MaybeNotify() {
-  base::TimeTicks now = base::TimeTicks::Now();
+  base::TimeTicks now =
+      !now_for_test_.is_null() ? now_for_test_ : base::TimeTicks::Now();
   if (last_observer_notification_time_.is_null() ||
       (now - last_observer_notification_time_).InSecondsF() >=
       kNotifyIntervalSec) {",Chrome,10b688f204a81d8447c83021624220607353552e,47cadc4c09a3732a47efdb561cd6555735487841,1," void UserActivityDetector::MaybeNotify() {
//flaw_line_below:
  base::TimeTicks now = base::TimeTicks::Now();
//fix_flaw_line_below:
//  base::TimeTicks now =
//fix_flaw_line_below:
//      !now_for_test_.is_null() ? now_for_test_ : base::TimeTicks::Now();
   if (last_observer_notification_time_.is_null() ||
       (now - last_observer_notification_time_).InSecondsF() >=
       kNotifyIntervalSec) {
    FOR_EACH_OBSERVER(UserActivityObserver, observers_, OnUserActivity());
    last_observer_notification_time_ = now;
  }
}
"
6558,184294,,Remote,Not required,,CVE-2012-2886,https://www.cvedetails.com/cve/CVE-2012-2886/,CWE-79,Medium,,Partial,,2012-09-26,4.3,"Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors related to the Google V8 bindings, aka *Universal XSS (UXSS).*",2018-10-30,XSS ,2,https://github.com/chromium/chromium/commit/10b688f204a81d8447c83021624220607353552e,10b688f204a81d8447c83021624220607353552e,"ash: Make UserActivityDetector ignore synthetic mouse events

This may have been preventing us from suspending (e.g.
mouse event is synthesized in response to lock window being
shown so Chrome tells powerd that the user is active).

BUG=133419
TEST=added


Review URL: https://chromiumcodereview.appspot.com/10574044

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143437 0039d316-1c4b-4281-b951-d872f2087c98",1,ash/wm/user_activity_detector.cc,"{""sha"": ""5a3b04dc4fb34943c5bb0a1129e74498162f68be"", ""filename"": ""ash/ash.gyp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/ash.gyp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/ash.gyp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/ash.gyp?ref=10b688f204a81d8447c83021624220607353552e"", ""patch"": ""@@ -421,6 +421,7 @@\n         'wm/system_gesture_event_filter_unittest.cc',\n         'wm/system_modal_container_layout_manager_unittest.cc',\n         'wm/toplevel_window_event_filter_unittest.cc',\n+        'wm/user_activity_detector_unittest.cc',\n         'wm/video_detector_unittest.cc',\n         'wm/visibility_controller_unittest.cc',\n         'wm/window_animations_unittest.cc',""}<_**next**_>{""sha"": ""5329087294664a540f505add21d0850ec2cc4518"", ""filename"": ""ash/wm/user_activity_detector.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/wm/user_activity_detector.cc?ref=10b688f204a81d8447c83021624220607353552e"", ""patch"": ""@@ -5,6 +5,7 @@\n #include \""ash/wm/user_activity_detector.h\""\n \n #include \""ash/wm/user_activity_observer.h\""\n+#include \""ui/aura/event.h\""\n \n namespace ash {\n \n@@ -32,7 +33,8 @@ bool UserActivityDetector::PreHandleKeyEvent(aura::Window* target,\n \n bool UserActivityDetector::PreHandleMouseEvent(aura::Window* target,\n                                                aura::MouseEvent* event) {\n-  MaybeNotify();\n+  if (!(event->flags() & ui::EF_IS_SYNTHESIZED))\n+    MaybeNotify();\n   return false;\n }\n \n@@ -51,7 +53,8 @@ ui::GestureStatus UserActivityDetector::PreHandleGestureEvent(\n }\n \n void UserActivityDetector::MaybeNotify() {\n-  base::TimeTicks now = base::TimeTicks::Now();\n+  base::TimeTicks now =\n+      !now_for_test_.is_null() ? now_for_test_ : base::TimeTicks::Now();\n   if (last_observer_notification_time_.is_null() ||\n       (now - last_observer_notification_time_).InSecondsF() >=\n       kNotifyIntervalSec) {""}<_**next**_>{""sha"": ""a6114db8e48d3c4edeb91d872bf4e3c80b53f068"", ""filename"": ""ash/wm/user_activity_detector.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/wm/user_activity_detector.h?ref=10b688f204a81d8447c83021624220607353552e"", ""patch"": ""@@ -27,6 +27,8 @@ class ASH_EXPORT UserActivityDetector : public aura::EventFilter {\n   UserActivityDetector();\n   virtual ~UserActivityDetector();\n \n+  void set_now_for_test(base::TimeTicks now) { now_for_test_ = now; }\n+\n   void AddObserver(UserActivityObserver* observer);\n   void RemoveObserver(UserActivityObserver* observer);\n \n@@ -53,6 +55,10 @@ class ASH_EXPORT UserActivityDetector : public aura::EventFilter {\n   // Last time at which we notified observers that the user was active.\n   base::TimeTicks last_observer_notification_time_;\n \n+  // If set, used when the current time is needed.  This can be set by tests to\n+  // simulate the passage of time.\n+  base::TimeTicks now_for_test_;\n+\n   DISALLOW_COPY_AND_ASSIGN(UserActivityDetector);\n };\n ""}<_**next**_>{""sha"": ""3af566b469c90b336b46254f7ef4e5bd249c8684"", ""filename"": ""ash/wm/user_activity_detector_unittest.cc"", ""status"": ""added"", ""additions"": 156, ""deletions"": 0, ""changes"": 156, ""blob_url"": ""https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/wm/user_activity_detector_unittest.cc?ref=10b688f204a81d8447c83021624220607353552e"", ""patch"": ""@@ -0,0 +1,156 @@\n+// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""ash/wm/user_activity_detector.h\""\n+\n+#include \""ash/shell.h\""\n+#include \""ash/test/ash_test_base.h\""\n+#include \""ash/wm/user_activity_observer.h\""\n+#include \""base/compiler_specific.h\""\n+#include \""base/memory/scoped_ptr.h\""\n+#include \""base/time.h\""\n+#include \""ui/aura/event.h\""\n+#include \""ui/aura/test/test_windows.h\""\n+#include \""ui/aura/window.h\""\n+#include \""ui/base/events.h\""\n+#include \""ui/base/keycodes/keyboard_codes.h\""\n+#include \""ui/gfx/point.h\""\n+\n+namespace ash {\n+namespace test {\n+\n+// Implementation that just counts the number of times we've been told that the\n+// user is active.\n+class TestUserActivityObserver : public UserActivityObserver {\n+ public:\n+  TestUserActivityObserver() : num_invocations_(0) {}\n+\n+  int num_invocations() const { return num_invocations_; }\n+  void reset_stats() { num_invocations_ = 0; }\n+\n+  // UserActivityObserver implementation.\n+  virtual void OnUserActivity() OVERRIDE { num_invocations_++; }\n+\n+ private:\n+  // Number of times that OnUserActivity() has been called.\n+  int num_invocations_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(TestUserActivityObserver);\n+};\n+\n+class UserActivityDetectorTest : public AshTestBase {\n+ public:\n+  UserActivityDetectorTest() {}\n+  virtual ~UserActivityDetectorTest() {}\n+\n+  virtual void SetUp() OVERRIDE {\n+    AshTestBase::SetUp();\n+    observer_.reset(new TestUserActivityObserver);\n+    detector_ = Shell::GetInstance()->user_activity_detector();\n+    detector_->AddObserver(observer_.get());\n+\n+    now_ = base::TimeTicks::Now();\n+    detector_->set_now_for_test(now_);\n+  }\n+\n+  virtual void TearDown() OVERRIDE {\n+    detector_->RemoveObserver(observer_.get());\n+    AshTestBase::TearDown();\n+  }\n+\n+ protected:\n+  // Move |detector_|'s idea of the current time forward by |delta|.\n+  void AdvanceTime(base::TimeDelta delta) {\n+    now_ += delta;\n+    detector_->set_now_for_test(now_);\n+  }\n+\n+  UserActivityDetector* detector_;  // not owned\n+\n+  scoped_ptr<TestUserActivityObserver> observer_;\n+\n+  base::TimeTicks now_;\n+\n+ private:\n+  DISALLOW_COPY_AND_ASSIGN(UserActivityDetectorTest);\n+};\n+\n+// Checks that the observer is notified in response to different types of input\n+// events.\n+TEST_F(UserActivityDetectorTest, Basic) {\n+  scoped_ptr<aura::Window> window(\n+      aura::test::CreateTestWindowWithId(12345, NULL));\n+\n+  aura::KeyEvent key_event(ui::ET_KEY_PRESSED, ui::VKEY_A, ui::EF_NONE);\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &key_event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  base::TimeDelta advance_delta =\n+      base::TimeDelta::FromSeconds(UserActivityDetector::kNotifyIntervalSec);\n+  AdvanceTime(advance_delta);\n+  aura::MouseEvent mouse_event(\n+      ui::ET_MOUSE_MOVED, gfx::Point(), gfx::Point(), ui::EF_NONE);\n+  EXPECT_FALSE(detector_->PreHandleMouseEvent(window.get(), &mouse_event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  AdvanceTime(advance_delta);\n+  aura::TouchEvent touch_event(\n+      ui::ET_TOUCH_PRESSED, gfx::Point(), 0, base::TimeDelta());\n+  EXPECT_FALSE(detector_->PreHandleTouchEvent(window.get(), &touch_event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  AdvanceTime(advance_delta);\n+  aura::GestureEvent gesture_event(\n+      ui::ET_GESTURE_TAP, 0, 0, ui::EF_NONE, base::Time(), 0, 0, 0U);\n+  EXPECT_FALSE(detector_->PreHandleGestureEvent(window.get(), &gesture_event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+}\n+\n+// Checks that observers aren't notified too frequently.\n+TEST_F(UserActivityDetectorTest, RateLimitNotifications) {\n+  scoped_ptr<aura::Window> window(\n+      aura::test::CreateTestWindowWithId(12345, NULL));\n+\n+  // The observer should be notified about a key event.\n+  aura::KeyEvent event(ui::ET_KEY_PRESSED, ui::VKEY_A, ui::EF_NONE);\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  // It shouldn't be notified if a second event occurs in the same second,\n+  // though.\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &event));\n+  EXPECT_EQ(0, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  // Advance the time, but not quite enough for another notification to be sent.\n+  AdvanceTime(\n+      base::TimeDelta::FromSeconds(\n+          UserActivityDetector::kNotifyIntervalSec - 1));\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &event));\n+  EXPECT_EQ(0, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  // One second later, we should send a notification again.\n+  AdvanceTime(base::TimeDelta::FromSeconds(1));\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+}\n+\n+// Checks that the detector ignores synthetic mouse events.\n+TEST_F(UserActivityDetectorTest, IgnoreSyntheticMouseEvents) {\n+  scoped_ptr<aura::Window> window(\n+      aura::test::CreateTestWindowWithId(12345, NULL));\n+  aura::MouseEvent mouse_event(\n+      ui::ET_MOUSE_MOVED, gfx::Point(), gfx::Point(), ui::EF_IS_SYNTHESIZED);\n+  EXPECT_FALSE(detector_->PreHandleMouseEvent(window.get(), &mouse_event));\n+  EXPECT_EQ(0, observer_->num_invocations());\n+}\n+\n+}  // namespace test\n+}  // namespace ash""}<_**next**_>{""sha"": ""0730ee7b7e50968ca9b08da0b23939667fa989c7"", ""filename"": ""ash/wm/video_detector_unittest.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/wm/video_detector_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/wm/video_detector_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/wm/video_detector_unittest.cc?ref=10b688f204a81d8447c83021624220607353552e"", ""patch"": ""@@ -53,6 +53,11 @@ class VideoDetectorTest : public AshTestBase {\n     detector_->set_now_for_test(now_);\n   }\n \n+  virtual void TearDown() OVERRIDE {\n+    detector_->RemoveObserver(observer_.get());\n+    AshTestBase::TearDown();\n+  }\n+\n  protected:\n   // Move |detector_|'s idea of the current time forward by |delta|.\n   void AdvanceTime(base::TimeDelta delta) {""}"," bool UserActivityDetector::PreHandleMouseEvent(aura::Window* target,
                                                aura::MouseEvent* event) {
  if (!(event->flags() & ui::EF_IS_SYNTHESIZED))
    MaybeNotify();
   return false;
 }
"," bool UserActivityDetector::PreHandleMouseEvent(aura::Window* target,
                                                aura::MouseEvent* event) {
  MaybeNotify();
   return false;
 }
",C,"  if (!(event->flags() & ui::EF_IS_SYNTHESIZED))
    MaybeNotify();
","  MaybeNotify();
",,"@@ -5,6 +5,7 @@
 #include ""ash/wm/user_activity_detector.h""
 
 #include ""ash/wm/user_activity_observer.h""
+#include ""ui/aura/event.h""
 
 namespace ash {
 
@@ -32,7 +33,8 @@ bool UserActivityDetector::PreHandleKeyEvent(aura::Window* target,
 
 bool UserActivityDetector::PreHandleMouseEvent(aura::Window* target,
                                                aura::MouseEvent* event) {
-  MaybeNotify();
+  if (!(event->flags() & ui::EF_IS_SYNTHESIZED))
+    MaybeNotify();
   return false;
 }
 
@@ -51,7 +53,8 @@ ui::GestureStatus UserActivityDetector::PreHandleGestureEvent(
 }
 
 void UserActivityDetector::MaybeNotify() {
-  base::TimeTicks now = base::TimeTicks::Now();
+  base::TimeTicks now =
+      !now_for_test_.is_null() ? now_for_test_ : base::TimeTicks::Now();
   if (last_observer_notification_time_.is_null() ||
       (now - last_observer_notification_time_).InSecondsF() >=
       kNotifyIntervalSec) {",Chrome,10b688f204a81d8447c83021624220607353552e,47cadc4c09a3732a47efdb561cd6555735487841,1," bool UserActivityDetector::PreHandleMouseEvent(aura::Window* target,
                                                aura::MouseEvent* event) {
//flaw_line_below:
  MaybeNotify();
//fix_flaw_line_below:
//  if (!(event->flags() & ui::EF_IS_SYNTHESIZED))
//fix_flaw_line_below:
//    MaybeNotify();
   return false;
 }
"
6756,184492,,Remote,Not required,,CVE-2012-2872,https://www.cvedetails.com/cve/CVE-2012-2872/,CWE-79,Medium,,Partial,,2012-08-31,4.3,Cross-site scripting (XSS) vulnerability in an SSL interstitial page in Google Chrome before 21.0.1180.89 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.,2018-10-30,XSS ,3,https://github.com/chromium/chromium/commit/68b6502084af7e2021f7321633f5fbb5f997a58b,68b6502084af7e2021f7321633f5fbb5f997a58b,"Properly EscapeForHTML potentially malicious input from X.509 certificates.

BUG=142956

TEST=Create an X.509 certificate with a CN field that contains JavaScript.
When you get the SSL error screen, check that the HTML + JavaScript is
escape instead of being treated as HTML and/or script.

Review URL: https://chromiumcodereview.appspot.com/10827364

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@152210 0039d316-1c4b-4281-b951-d872f2087c98",2,chrome/browser/ssl/ssl_error_info.cc,"{""sha"": ""d33960e55ff85b6899415bd0be1f0f9e14daca04"", ""filename"": ""chrome/browser/ssl/ssl_error_info.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/68b6502084af7e2021f7321633f5fbb5f997a58b/chrome/browser/ssl/ssl_error_info.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/68b6502084af7e2021f7321633f5fbb5f997a58b/chrome/browser/ssl/ssl_error_info.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ssl/ssl_error_info.cc?ref=68b6502084af7e2021f7321633f5fbb5f997a58b"", ""patch"": ""@@ -12,6 +12,7 @@\n #include \""grit/chromium_strings.h\""\n #include \""grit/generated_resources.h\""\n #include \""net/base/cert_status_flags.h\""\n+#include \""net/base/escape.h\""\n #include \""net/base/net_errors.h\""\n #include \""net/base/ssl_info.h\""\n #include \""ui/base/l10n/l10n_util.h\""\n@@ -55,7 +56,8 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,\n       details =\n           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,\n                                      UTF8ToUTF16(request_url.host()),\n-                                     UTF8ToUTF16(dns_names[i]),\n+                                     net::EscapeForHTML(\n+                                         UTF8ToUTF16(dns_names[i])),\n                                      UTF8ToUTF16(request_url.host()));\n       short_description = l10n_util::GetStringUTF16(\n           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);\n@@ -64,7 +66,7 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,\n       extra_info.push_back(\n           l10n_util::GetStringFUTF16(\n               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,\n-              UTF8ToUTF16(cert->subject().common_name),\n+              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),\n               UTF8ToUTF16(request_url.host())));\n       break;\n     }""}","SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     net::EscapeForHTML(
                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
","SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     UTF8ToUTF16(dns_names[i]),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              UTF8ToUTF16(cert->subject().common_name),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
",C,"                                     net::EscapeForHTML(
                                         UTF8ToUTF16(dns_names[i])),
              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
","                                     UTF8ToUTF16(dns_names[i]),
              UTF8ToUTF16(cert->subject().common_name),
",,"@@ -12,6 +12,7 @@
 #include ""grit/chromium_strings.h""
 #include ""grit/generated_resources.h""
 #include ""net/base/cert_status_flags.h""
+#include ""net/base/escape.h""
 #include ""net/base/net_errors.h""
 #include ""net/base/ssl_info.h""
 #include ""ui/base/l10n/l10n_util.h""
@@ -55,7 +56,8 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
-                                     UTF8ToUTF16(dns_names[i]),
+                                     net::EscapeForHTML(
+                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
@@ -64,7 +66,7 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
-              UTF8ToUTF16(cert->subject().common_name),
+              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }",Chrome,68b6502084af7e2021f7321633f5fbb5f997a58b,4150ecc30d10d0f211033346f10611e3c6083160,1,"SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      // If the certificate contains multiple DNS names, we choose the most
      // representative one -- either the DNS name that's also in the subject
      // field, or the first one.  If this heuristic turns out to be
      // inadequate, we can consider choosing the DNS name that is the
      // ""closest match"" to the host name in the request URL, or listing all
      // the DNS names with an HTML <ul>.
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
//flaw_line_below:
                                     UTF8ToUTF16(dns_names[i]),
//fix_flaw_line_below:
//                                     net::EscapeForHTML(
//fix_flaw_line_below:
//                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
//flaw_line_below:
              UTF8ToUTF16(cert->subject().common_name),
//fix_flaw_line_below:
//              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        // Then it must be not yet valid.  We don't check that it is not yet
        // valid as there is still a very unlikely chance that the cert might
        // have become valid since the error occurred.
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
"
7590,185326,,Remote,Not required,,CVE-2014-1747,https://www.cvedetails.com/cve/CVE-2014-1747/,CWE-79,Medium,,Partial,,2014-05-21,4.3,"Cross-site scripting (XSS) vulnerability in the DocumentLoader::maybeCreateArchive function in core/loader/DocumentLoader.cpp in Blink, as used in Google Chrome before 35.0.1916.114, allows remote attackers to inject arbitrary web script or HTML via crafted MHTML content, aka *Universal XSS (UXSS).*",2017-12-28,XSS ,1,https://github.com/chromium/chromium/commit/1924f747637265f563892b8f56a64391f6208194,1924f747637265f563892b8f56a64391f6208194,"Allow the cast tray to function as expected when the installed extension is missing API methods.

BUG=489445

Review URL: https://codereview.chromium.org/1145833003

Cr-Commit-Position: refs/heads/master@{#330663}",1,ash/system/cast/tray_cast.cc,"{""sha"": ""d997e0c26bfef095d87be8c1d343ac30cee969a8"", ""filename"": ""ash/ash_strings.grd"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/ash_strings.grd?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -278,6 +278,12 @@ Press Ctrl+Alt+Z to disable.\n       <message name=\""IDS_ASH_STATUS_TRAY_CAST_STOP\"" desc=\""The label used in the tray popup to stop casting.\"">\n         Stop\n       </message>\n+      <message name=\""IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE\"" desc=\""The label used when we have detected we are casting but do not know if we are casting a tab or the desktop.\"">\n+        Casting\n+      </message>\n+      <message name=\""IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER\"" desc=\""The label used when we have detected we are casting but do not know the name of the receiver.\"">\n+        Unknown receiver\n+      </message>\n \n       <message name=\""IDS_ASH_STATUS_TRAY_BLUETOOTH\"" desc=\""The label used as the header in the bluetooth popup.\"">\n         Bluetooth""}<_**next**_>{""sha"": ""f38a05c5f3f6322ad00a77f7b24d61a6916f6fbb"", ""filename"": ""ash/cast_config_delegate.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 7, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/cast_config_delegate.h?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -83,13 +83,8 @@ class CastConfigDelegate {\n   // Cast to a receiver specified by |receiver_id|.\n   virtual void CastToReceiver(const std::string& receiver_id) = 0;\n \n-  // Stop ongoing cast. The |activity_id| is the unique identifier associated\n-  // with the ongoing cast. Each receiver has only one possible activity\n-  // associated with it. The |activity_id| is available by invoking\n-  // GetReceiversAndActivities(); if the receiver is currently casting, then the\n-  // associated activity data will have an id. This id can be used to stop the\n-  // cast in this method.\n-  virtual void StopCasting(const std::string& activity_id) = 0;\n+  // Stop an ongoing cast.\n+  virtual void StopCasting() = 0;\n \n   // Opens Options page for cast.\n   virtual void LaunchCastOptions() = 0;""}<_**next**_>{""sha"": ""355eb404d27750dfe60dce19869fdb21fcc125be"", ""filename"": ""ash/system/cast/tray_cast.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 23, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/system/cast/tray_cast.cc?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -38,28 +38,6 @@ namespace ash {\n \n namespace {\n const int kStopButtonRightPadding = 18;\n-\n-// Callback helper for StopCast().\n-void StopCastCallback(\n-    CastConfigDelegate* cast_config,\n-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {\n-  for (auto& item : receivers_activities) {\n-    CastConfigDelegate::Activity activity = item.second.activity;\n-    if (activity.allow_stop && activity.id.empty() == false)\n-      cast_config->StopCasting(activity.id);\n-  }\n-}\n-\n-// Stops currently casting device.\n-void StopCast() {\n-  CastConfigDelegate* cast_config =\n-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();\n-  if (cast_config && cast_config->HasCastExtension()) {\n-    cast_config->GetReceiversAndActivities(\n-        base::Bind(&StopCastCallback, cast_config));\n-  }\n-}\n-\n }  // namespace\n \n namespace tray {\n@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)\n   title_ = new views::Label;\n   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));\n+  title_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));\n   label_container_->AddChildView(title_);\n \n   details_ = new views::Label;\n   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   details_->SetMultiLine(false);\n   details_->SetEnabledColor(kHeaderTextColorNormal);\n+  details_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));\n   label_container_->AddChildView(details_);\n \n   AddChildView(label_container_);\n@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(\n void CastCastView::ButtonPressed(views::Button* sender,\n                                  const ui::Event& event) {\n   DCHECK(sender == stop_button_);\n-  StopCast();\n+  cast_config_delegate_->StopCasting();\n }\n \n // This view by itself does very little. It acts as a front-end for managing""}<_**next**_>{""sha"": ""9873cf404c009dd69fa9d0d8da2cd80f6a693ae2"", ""filename"": ""chrome/browser/ui/ash/cast_config_delegate_chromeos.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -138,8 +138,14 @@ void CastConfigDelegateChromeos::CastToReceiver(\n                     \""');\"");\n }\n \n-void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {\n+void CastConfigDelegateChromeos::StopCasting() {\n   ExecuteJavaScript(\""backgroundSetup.stopCastMirroring('user-stop');\"");\n+\n+  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.\n+  // The current beta/release versions of the cast extension do not export\n+  // stopCastMirroring, so we will also try to call the minified version.\n+  // See crbug.com/489929.\n+  ExecuteJavaScript(\""backgroundSetup.Qu('user-stop');\"");\n }\n \n void CastConfigDelegateChromeos::LaunchCastOptions() {""}<_**next**_>{""sha"": ""c77afebdd8a45e32aa1f95a450a13bc3e575483e"", ""filename"": ""chrome/browser/ui/ash/cast_config_delegate_chromeos.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.h?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -27,7 +27,7 @@ class CastConfigDelegateChromeos : public ash::CastConfigDelegate {\n   void GetReceiversAndActivities(\n       const ReceiversAndActivitesCallback& callback) override;\n   void CastToReceiver(const std::string& receiver_id) override;\n-  void StopCasting(const std::string& activity_id) override;\n+  void StopCasting() override;\n   void LaunchCastOptions() override;\n \n   DISALLOW_COPY_AND_ASSIGN(CastConfigDelegateChromeos);""}"," void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
  cast_config_delegate_->StopCasting();
 }
"," void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
  StopCast();
 }
",C,"  cast_config_delegate_->StopCasting();
","  StopCast();
",,"@@ -38,28 +38,6 @@ namespace ash {
 
 namespace {
 const int kStopButtonRightPadding = 18;
-
-// Callback helper for StopCast().
-void StopCastCallback(
-    CastConfigDelegate* cast_config,
-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {
-  for (auto& item : receivers_activities) {
-    CastConfigDelegate::Activity activity = item.second.activity;
-    if (activity.allow_stop && activity.id.empty() == false)
-      cast_config->StopCasting(activity.id);
-  }
-}
-
-// Stops currently casting device.
-void StopCast() {
-  CastConfigDelegate* cast_config =
-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();
-  if (cast_config && cast_config->HasCastExtension()) {
-    cast_config->GetReceiversAndActivities(
-        base::Bind(&StopCastCallback, cast_config));
-  }
-}
-
 }  // namespace
 
 namespace tray {
@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)
   title_ = new views::Label;
   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));
+  title_->SetText(
+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));
   label_container_->AddChildView(title_);
 
   details_ = new views::Label;
   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   details_->SetMultiLine(false);
   details_->SetEnabledColor(kHeaderTextColorNormal);
+  details_->SetText(
+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));
   label_container_->AddChildView(details_);
 
   AddChildView(label_container_);
@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(
 void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
-  StopCast();
+  cast_config_delegate_->StopCasting();
 }
 
 // This view by itself does very little. It acts as a front-end for managing",Chrome,1924f747637265f563892b8f56a64391f6208194,04192cf91fe892f516854317886ae2227af0ccb5,1," void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
//flaw_line_below:
  StopCast();
//fix_flaw_line_below:
//  cast_config_delegate_->StopCasting();
 }
"
7591,185327,,Remote,Not required,,CVE-2014-1747,https://www.cvedetails.com/cve/CVE-2014-1747/,CWE-79,Medium,,Partial,,2014-05-21,4.3,"Cross-site scripting (XSS) vulnerability in the DocumentLoader::maybeCreateArchive function in core/loader/DocumentLoader.cpp in Blink, as used in Google Chrome before 35.0.1916.114, allows remote attackers to inject arbitrary web script or HTML via crafted MHTML content, aka *Universal XSS (UXSS).*",2017-12-28,XSS ,4,https://github.com/chromium/chromium/commit/1924f747637265f563892b8f56a64391f6208194,1924f747637265f563892b8f56a64391f6208194,"Allow the cast tray to function as expected when the installed extension is missing API methods.

BUG=489445

Review URL: https://codereview.chromium.org/1145833003

Cr-Commit-Position: refs/heads/master@{#330663}",0,ash/system/cast/tray_cast.cc,"{""sha"": ""d997e0c26bfef095d87be8c1d343ac30cee969a8"", ""filename"": ""ash/ash_strings.grd"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/ash_strings.grd?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -278,6 +278,12 @@ Press Ctrl+Alt+Z to disable.\n       <message name=\""IDS_ASH_STATUS_TRAY_CAST_STOP\"" desc=\""The label used in the tray popup to stop casting.\"">\n         Stop\n       </message>\n+      <message name=\""IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE\"" desc=\""The label used when we have detected we are casting but do not know if we are casting a tab or the desktop.\"">\n+        Casting\n+      </message>\n+      <message name=\""IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER\"" desc=\""The label used when we have detected we are casting but do not know the name of the receiver.\"">\n+        Unknown receiver\n+      </message>\n \n       <message name=\""IDS_ASH_STATUS_TRAY_BLUETOOTH\"" desc=\""The label used as the header in the bluetooth popup.\"">\n         Bluetooth""}<_**next**_>{""sha"": ""f38a05c5f3f6322ad00a77f7b24d61a6916f6fbb"", ""filename"": ""ash/cast_config_delegate.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 7, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/cast_config_delegate.h?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -83,13 +83,8 @@ class CastConfigDelegate {\n   // Cast to a receiver specified by |receiver_id|.\n   virtual void CastToReceiver(const std::string& receiver_id) = 0;\n \n-  // Stop ongoing cast. The |activity_id| is the unique identifier associated\n-  // with the ongoing cast. Each receiver has only one possible activity\n-  // associated with it. The |activity_id| is available by invoking\n-  // GetReceiversAndActivities(); if the receiver is currently casting, then the\n-  // associated activity data will have an id. This id can be used to stop the\n-  // cast in this method.\n-  virtual void StopCasting(const std::string& activity_id) = 0;\n+  // Stop an ongoing cast.\n+  virtual void StopCasting() = 0;\n \n   // Opens Options page for cast.\n   virtual void LaunchCastOptions() = 0;""}<_**next**_>{""sha"": ""355eb404d27750dfe60dce19869fdb21fcc125be"", ""filename"": ""ash/system/cast/tray_cast.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 23, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/system/cast/tray_cast.cc?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -38,28 +38,6 @@ namespace ash {\n \n namespace {\n const int kStopButtonRightPadding = 18;\n-\n-// Callback helper for StopCast().\n-void StopCastCallback(\n-    CastConfigDelegate* cast_config,\n-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {\n-  for (auto& item : receivers_activities) {\n-    CastConfigDelegate::Activity activity = item.second.activity;\n-    if (activity.allow_stop && activity.id.empty() == false)\n-      cast_config->StopCasting(activity.id);\n-  }\n-}\n-\n-// Stops currently casting device.\n-void StopCast() {\n-  CastConfigDelegate* cast_config =\n-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();\n-  if (cast_config && cast_config->HasCastExtension()) {\n-    cast_config->GetReceiversAndActivities(\n-        base::Bind(&StopCastCallback, cast_config));\n-  }\n-}\n-\n }  // namespace\n \n namespace tray {\n@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)\n   title_ = new views::Label;\n   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));\n+  title_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));\n   label_container_->AddChildView(title_);\n \n   details_ = new views::Label;\n   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   details_->SetMultiLine(false);\n   details_->SetEnabledColor(kHeaderTextColorNormal);\n+  details_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));\n   label_container_->AddChildView(details_);\n \n   AddChildView(label_container_);\n@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(\n void CastCastView::ButtonPressed(views::Button* sender,\n                                  const ui::Event& event) {\n   DCHECK(sender == stop_button_);\n-  StopCast();\n+  cast_config_delegate_->StopCasting();\n }\n \n // This view by itself does very little. It acts as a front-end for managing""}<_**next**_>{""sha"": ""9873cf404c009dd69fa9d0d8da2cd80f6a693ae2"", ""filename"": ""chrome/browser/ui/ash/cast_config_delegate_chromeos.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -138,8 +138,14 @@ void CastConfigDelegateChromeos::CastToReceiver(\n                     \""');\"");\n }\n \n-void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {\n+void CastConfigDelegateChromeos::StopCasting() {\n   ExecuteJavaScript(\""backgroundSetup.stopCastMirroring('user-stop');\"");\n+\n+  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.\n+  // The current beta/release versions of the cast extension do not export\n+  // stopCastMirroring, so we will also try to call the minified version.\n+  // See crbug.com/489929.\n+  ExecuteJavaScript(\""backgroundSetup.Qu('user-stop');\"");\n }\n \n void CastConfigDelegateChromeos::LaunchCastOptions() {""}<_**next**_>{""sha"": ""c77afebdd8a45e32aa1f95a450a13bc3e575483e"", ""filename"": ""chrome/browser/ui/ash/cast_config_delegate_chromeos.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.h?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -27,7 +27,7 @@ class CastConfigDelegateChromeos : public ash::CastConfigDelegate {\n   void GetReceiversAndActivities(\n       const ReceiversAndActivitesCallback& callback) override;\n   void CastToReceiver(const std::string& receiver_id) override;\n-  void StopCasting(const std::string& activity_id) override;\n+  void StopCasting() override;\n   void LaunchCastOptions() override;\n \n   DISALLOW_COPY_AND_ASSIGN(CastConfigDelegateChromeos);""}","CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)
    : cast_config_delegate_(cast_config_delegate) {

  set_background(views::Background::CreateSolidBackground(kBackgroundColor));
  ui::ResourceBundle& bundle = ui::ResourceBundle::GetSharedInstance();
  SetLayoutManager(new views::BoxLayout(views::BoxLayout::kHorizontal,
                                        kTrayPopupPaddingHorizontal, 0,
                                        kTrayPopupPaddingBetweenItems));
  icon_ = new FixedSizedImageView(0, kTrayPopupItemHeight);
  icon_->SetImage(
      bundle.GetImageNamed(IDR_AURA_UBER_TRAY_CAST_ENABLED).ToImageSkia());
  AddChildView(icon_);

  label_container_ = new views::View;
  label_container_->SetLayoutManager(
      new views::BoxLayout(views::BoxLayout::kVertical, 0, 0, 0));

   title_ = new views::Label;
   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));
  title_->SetText(
      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));
   label_container_->AddChildView(title_);
 
   details_ = new views::Label;
   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   details_->SetMultiLine(false);
   details_->SetEnabledColor(kHeaderTextColorNormal);
  details_->SetText(
      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));
   label_container_->AddChildView(details_);
 
   AddChildView(label_container_);

  base::string16 stop_button_text =
      ui::ResourceBundle::GetSharedInstance().GetLocalizedString(
          IDS_ASH_STATUS_TRAY_CAST_STOP);
  stop_button_ = new TrayPopupLabelButton(this, stop_button_text);
  AddChildView(stop_button_);

  UpdateLabel();
}
","CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)
    : cast_config_delegate_(cast_config_delegate) {

  set_background(views::Background::CreateSolidBackground(kBackgroundColor));
  ui::ResourceBundle& bundle = ui::ResourceBundle::GetSharedInstance();
  SetLayoutManager(new views::BoxLayout(views::BoxLayout::kHorizontal,
                                        kTrayPopupPaddingHorizontal, 0,
                                        kTrayPopupPaddingBetweenItems));
  icon_ = new FixedSizedImageView(0, kTrayPopupItemHeight);
  icon_->SetImage(
      bundle.GetImageNamed(IDR_AURA_UBER_TRAY_CAST_ENABLED).ToImageSkia());
  AddChildView(icon_);

  label_container_ = new views::View;
  label_container_->SetLayoutManager(
      new views::BoxLayout(views::BoxLayout::kVertical, 0, 0, 0));

   title_ = new views::Label;
   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));
   label_container_->AddChildView(title_);
 
   details_ = new views::Label;
   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   details_->SetMultiLine(false);
   details_->SetEnabledColor(kHeaderTextColorNormal);
   label_container_->AddChildView(details_);
 
   AddChildView(label_container_);

  base::string16 stop_button_text =
      ui::ResourceBundle::GetSharedInstance().GetLocalizedString(
          IDS_ASH_STATUS_TRAY_CAST_STOP);
  stop_button_ = new TrayPopupLabelButton(this, stop_button_text);
  AddChildView(stop_button_);

  UpdateLabel();
}
",C,"  title_->SetText(
      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));
  details_->SetText(
      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));
",,,"@@ -38,28 +38,6 @@ namespace ash {
 
 namespace {
 const int kStopButtonRightPadding = 18;
-
-// Callback helper for StopCast().
-void StopCastCallback(
-    CastConfigDelegate* cast_config,
-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {
-  for (auto& item : receivers_activities) {
-    CastConfigDelegate::Activity activity = item.second.activity;
-    if (activity.allow_stop && activity.id.empty() == false)
-      cast_config->StopCasting(activity.id);
-  }
-}
-
-// Stops currently casting device.
-void StopCast() {
-  CastConfigDelegate* cast_config =
-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();
-  if (cast_config && cast_config->HasCastExtension()) {
-    cast_config->GetReceiversAndActivities(
-        base::Bind(&StopCastCallback, cast_config));
-  }
-}
-
 }  // namespace
 
 namespace tray {
@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)
   title_ = new views::Label;
   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));
+  title_->SetText(
+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));
   label_container_->AddChildView(title_);
 
   details_ = new views::Label;
   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   details_->SetMultiLine(false);
   details_->SetEnabledColor(kHeaderTextColorNormal);
+  details_->SetText(
+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));
   label_container_->AddChildView(details_);
 
   AddChildView(label_container_);
@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(
 void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
-  StopCast();
+  cast_config_delegate_->StopCasting();
 }
 
 // This view by itself does very little. It acts as a front-end for managing",Chrome,1924f747637265f563892b8f56a64391f6208194,04192cf91fe892f516854317886ae2227af0ccb5,1,"CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)
    : cast_config_delegate_(cast_config_delegate) {
  // We will initialize the primary tray view which shows a stop button here.

  set_background(views::Background::CreateSolidBackground(kBackgroundColor));
  ui::ResourceBundle& bundle = ui::ResourceBundle::GetSharedInstance();
  SetLayoutManager(new views::BoxLayout(views::BoxLayout::kHorizontal,
                                        kTrayPopupPaddingHorizontal, 0,
                                        kTrayPopupPaddingBetweenItems));
  icon_ = new FixedSizedImageView(0, kTrayPopupItemHeight);
  icon_->SetImage(
      bundle.GetImageNamed(IDR_AURA_UBER_TRAY_CAST_ENABLED).ToImageSkia());
  AddChildView(icon_);

  // The view has two labels, one above the other. The top label (|title_|)
  // specifies that we are, say, ""Casting desktop"". The bottom label
  // (|details_|) specifies where we are casting to, ie, ""SomeRandom cast""
  label_container_ = new views::View;
  label_container_->SetLayoutManager(
      new views::BoxLayout(views::BoxLayout::kVertical, 0, 0, 0));

   title_ = new views::Label;
   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));
//fix_flaw_line_below:
//  title_->SetText(
//fix_flaw_line_below:
//      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));
   label_container_->AddChildView(title_);
 
   details_ = new views::Label;
   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   details_->SetMultiLine(false);
   details_->SetEnabledColor(kHeaderTextColorNormal);
//fix_flaw_line_below:
//  details_->SetText(
//fix_flaw_line_below:
//      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));
   label_container_->AddChildView(details_);
 
   AddChildView(label_container_);

  // Add the stop bottom on the far-right. We customize how this stop button is
  // displayed inside of |Layout()|.
  base::string16 stop_button_text =
      ui::ResourceBundle::GetSharedInstance().GetLocalizedString(
          IDS_ASH_STATUS_TRAY_CAST_STOP);
  stop_button_ = new TrayPopupLabelButton(this, stop_button_text);
  AddChildView(stop_button_);

  UpdateLabel();
}
"
7592,185328,,Remote,Not required,,CVE-2014-1747,https://www.cvedetails.com/cve/CVE-2014-1747/,CWE-79,Medium,,Partial,,2014-05-21,4.3,"Cross-site scripting (XSS) vulnerability in the DocumentLoader::maybeCreateArchive function in core/loader/DocumentLoader.cpp in Blink, as used in Google Chrome before 35.0.1916.114, allows remote attackers to inject arbitrary web script or HTML via crafted MHTML content, aka *Universal XSS (UXSS).*",2017-12-28,XSS ,0,https://github.com/chromium/chromium/commit/1924f747637265f563892b8f56a64391f6208194,1924f747637265f563892b8f56a64391f6208194,"Allow the cast tray to function as expected when the installed extension is missing API methods.

BUG=489445

Review URL: https://codereview.chromium.org/1145833003

Cr-Commit-Position: refs/heads/master@{#330663}",7,ash/system/cast/tray_cast.cc,"{""sha"": ""d997e0c26bfef095d87be8c1d343ac30cee969a8"", ""filename"": ""ash/ash_strings.grd"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/ash_strings.grd?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -278,6 +278,12 @@ Press Ctrl+Alt+Z to disable.\n       <message name=\""IDS_ASH_STATUS_TRAY_CAST_STOP\"" desc=\""The label used in the tray popup to stop casting.\"">\n         Stop\n       </message>\n+      <message name=\""IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE\"" desc=\""The label used when we have detected we are casting but do not know if we are casting a tab or the desktop.\"">\n+        Casting\n+      </message>\n+      <message name=\""IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER\"" desc=\""The label used when we have detected we are casting but do not know the name of the receiver.\"">\n+        Unknown receiver\n+      </message>\n \n       <message name=\""IDS_ASH_STATUS_TRAY_BLUETOOTH\"" desc=\""The label used as the header in the bluetooth popup.\"">\n         Bluetooth""}<_**next**_>{""sha"": ""f38a05c5f3f6322ad00a77f7b24d61a6916f6fbb"", ""filename"": ""ash/cast_config_delegate.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 7, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/cast_config_delegate.h?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -83,13 +83,8 @@ class CastConfigDelegate {\n   // Cast to a receiver specified by |receiver_id|.\n   virtual void CastToReceiver(const std::string& receiver_id) = 0;\n \n-  // Stop ongoing cast. The |activity_id| is the unique identifier associated\n-  // with the ongoing cast. Each receiver has only one possible activity\n-  // associated with it. The |activity_id| is available by invoking\n-  // GetReceiversAndActivities(); if the receiver is currently casting, then the\n-  // associated activity data will have an id. This id can be used to stop the\n-  // cast in this method.\n-  virtual void StopCasting(const std::string& activity_id) = 0;\n+  // Stop an ongoing cast.\n+  virtual void StopCasting() = 0;\n \n   // Opens Options page for cast.\n   virtual void LaunchCastOptions() = 0;""}<_**next**_>{""sha"": ""355eb404d27750dfe60dce19869fdb21fcc125be"", ""filename"": ""ash/system/cast/tray_cast.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 23, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/system/cast/tray_cast.cc?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -38,28 +38,6 @@ namespace ash {\n \n namespace {\n const int kStopButtonRightPadding = 18;\n-\n-// Callback helper for StopCast().\n-void StopCastCallback(\n-    CastConfigDelegate* cast_config,\n-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {\n-  for (auto& item : receivers_activities) {\n-    CastConfigDelegate::Activity activity = item.second.activity;\n-    if (activity.allow_stop && activity.id.empty() == false)\n-      cast_config->StopCasting(activity.id);\n-  }\n-}\n-\n-// Stops currently casting device.\n-void StopCast() {\n-  CastConfigDelegate* cast_config =\n-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();\n-  if (cast_config && cast_config->HasCastExtension()) {\n-    cast_config->GetReceiversAndActivities(\n-        base::Bind(&StopCastCallback, cast_config));\n-  }\n-}\n-\n }  // namespace\n \n namespace tray {\n@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)\n   title_ = new views::Label;\n   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));\n+  title_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));\n   label_container_->AddChildView(title_);\n \n   details_ = new views::Label;\n   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   details_->SetMultiLine(false);\n   details_->SetEnabledColor(kHeaderTextColorNormal);\n+  details_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));\n   label_container_->AddChildView(details_);\n \n   AddChildView(label_container_);\n@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(\n void CastCastView::ButtonPressed(views::Button* sender,\n                                  const ui::Event& event) {\n   DCHECK(sender == stop_button_);\n-  StopCast();\n+  cast_config_delegate_->StopCasting();\n }\n \n // This view by itself does very little. It acts as a front-end for managing""}<_**next**_>{""sha"": ""9873cf404c009dd69fa9d0d8da2cd80f6a693ae2"", ""filename"": ""chrome/browser/ui/ash/cast_config_delegate_chromeos.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -138,8 +138,14 @@ void CastConfigDelegateChromeos::CastToReceiver(\n                     \""');\"");\n }\n \n-void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {\n+void CastConfigDelegateChromeos::StopCasting() {\n   ExecuteJavaScript(\""backgroundSetup.stopCastMirroring('user-stop');\"");\n+\n+  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.\n+  // The current beta/release versions of the cast extension do not export\n+  // stopCastMirroring, so we will also try to call the minified version.\n+  // See crbug.com/489929.\n+  ExecuteJavaScript(\""backgroundSetup.Qu('user-stop');\"");\n }\n \n void CastConfigDelegateChromeos::LaunchCastOptions() {""}<_**next**_>{""sha"": ""c77afebdd8a45e32aa1f95a450a13bc3e575483e"", ""filename"": ""chrome/browser/ui/ash/cast_config_delegate_chromeos.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.h?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -27,7 +27,7 @@ class CastConfigDelegateChromeos : public ash::CastConfigDelegate {\n   void GetReceiversAndActivities(\n       const ReceiversAndActivitesCallback& callback) override;\n   void CastToReceiver(const std::string& receiver_id) override;\n-  void StopCasting(const std::string& activity_id) override;\n+  void StopCasting() override;\n   void LaunchCastOptions() override;\n \n   DISALLOW_COPY_AND_ASSIGN(CastConfigDelegateChromeos);""}","void StopCast() {
","void StopCast() {
  CastConfigDelegate* cast_config =
      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();
  if (cast_config && cast_config->HasCastExtension()) {
    cast_config->GetReceiversAndActivities(
        base::Bind(&StopCastCallback, cast_config));
  }
}
",C,,"  CastConfigDelegate* cast_config =
      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();
  if (cast_config && cast_config->HasCastExtension()) {
    cast_config->GetReceiversAndActivities(
        base::Bind(&StopCastCallback, cast_config));
  }
}
",,"@@ -38,28 +38,6 @@ namespace ash {
 
 namespace {
 const int kStopButtonRightPadding = 18;
-
-// Callback helper for StopCast().
-void StopCastCallback(
-    CastConfigDelegate* cast_config,
-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {
-  for (auto& item : receivers_activities) {
-    CastConfigDelegate::Activity activity = item.second.activity;
-    if (activity.allow_stop && activity.id.empty() == false)
-      cast_config->StopCasting(activity.id);
-  }
-}
-
-// Stops currently casting device.
-void StopCast() {
-  CastConfigDelegate* cast_config =
-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();
-  if (cast_config && cast_config->HasCastExtension()) {
-    cast_config->GetReceiversAndActivities(
-        base::Bind(&StopCastCallback, cast_config));
-  }
-}
-
 }  // namespace
 
 namespace tray {
@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)
   title_ = new views::Label;
   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));
+  title_->SetText(
+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));
   label_container_->AddChildView(title_);
 
   details_ = new views::Label;
   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   details_->SetMultiLine(false);
   details_->SetEnabledColor(kHeaderTextColorNormal);
+  details_->SetText(
+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));
   label_container_->AddChildView(details_);
 
   AddChildView(label_container_);
@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(
 void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
-  StopCast();
+  cast_config_delegate_->StopCasting();
 }
 
 // This view by itself does very little. It acts as a front-end for managing",Chrome,1924f747637265f563892b8f56a64391f6208194,04192cf91fe892f516854317886ae2227af0ccb5,1,"void StopCast() {
//flaw_line_below:
  CastConfigDelegate* cast_config =
//flaw_line_below:
      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();
//flaw_line_below:
  if (cast_config && cast_config->HasCastExtension()) {
//flaw_line_below:
    cast_config->GetReceiversAndActivities(
//flaw_line_below:
        base::Bind(&StopCastCallback, cast_config));
//flaw_line_below:
  }
//flaw_line_below:
}
"
7593,185329,,Remote,Not required,,CVE-2014-1747,https://www.cvedetails.com/cve/CVE-2014-1747/,CWE-79,Medium,,Partial,,2014-05-21,4.3,"Cross-site scripting (XSS) vulnerability in the DocumentLoader::maybeCreateArchive function in core/loader/DocumentLoader.cpp in Blink, as used in Google Chrome before 35.0.1916.114, allows remote attackers to inject arbitrary web script or HTML via crafted MHTML content, aka *Universal XSS (UXSS).*",2017-12-28,XSS ,0,https://github.com/chromium/chromium/commit/1924f747637265f563892b8f56a64391f6208194,1924f747637265f563892b8f56a64391f6208194,"Allow the cast tray to function as expected when the installed extension is missing API methods.

BUG=489445

Review URL: https://codereview.chromium.org/1145833003

Cr-Commit-Position: refs/heads/master@{#330663}",8,ash/system/cast/tray_cast.cc,"{""sha"": ""d997e0c26bfef095d87be8c1d343ac30cee969a8"", ""filename"": ""ash/ash_strings.grd"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/ash_strings.grd?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -278,6 +278,12 @@ Press Ctrl+Alt+Z to disable.\n       <message name=\""IDS_ASH_STATUS_TRAY_CAST_STOP\"" desc=\""The label used in the tray popup to stop casting.\"">\n         Stop\n       </message>\n+      <message name=\""IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE\"" desc=\""The label used when we have detected we are casting but do not know if we are casting a tab or the desktop.\"">\n+        Casting\n+      </message>\n+      <message name=\""IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER\"" desc=\""The label used when we have detected we are casting but do not know the name of the receiver.\"">\n+        Unknown receiver\n+      </message>\n \n       <message name=\""IDS_ASH_STATUS_TRAY_BLUETOOTH\"" desc=\""The label used as the header in the bluetooth popup.\"">\n         Bluetooth""}<_**next**_>{""sha"": ""f38a05c5f3f6322ad00a77f7b24d61a6916f6fbb"", ""filename"": ""ash/cast_config_delegate.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 7, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/cast_config_delegate.h?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -83,13 +83,8 @@ class CastConfigDelegate {\n   // Cast to a receiver specified by |receiver_id|.\n   virtual void CastToReceiver(const std::string& receiver_id) = 0;\n \n-  // Stop ongoing cast. The |activity_id| is the unique identifier associated\n-  // with the ongoing cast. Each receiver has only one possible activity\n-  // associated with it. The |activity_id| is available by invoking\n-  // GetReceiversAndActivities(); if the receiver is currently casting, then the\n-  // associated activity data will have an id. This id can be used to stop the\n-  // cast in this method.\n-  virtual void StopCasting(const std::string& activity_id) = 0;\n+  // Stop an ongoing cast.\n+  virtual void StopCasting() = 0;\n \n   // Opens Options page for cast.\n   virtual void LaunchCastOptions() = 0;""}<_**next**_>{""sha"": ""355eb404d27750dfe60dce19869fdb21fcc125be"", ""filename"": ""ash/system/cast/tray_cast.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 23, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/system/cast/tray_cast.cc?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -38,28 +38,6 @@ namespace ash {\n \n namespace {\n const int kStopButtonRightPadding = 18;\n-\n-// Callback helper for StopCast().\n-void StopCastCallback(\n-    CastConfigDelegate* cast_config,\n-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {\n-  for (auto& item : receivers_activities) {\n-    CastConfigDelegate::Activity activity = item.second.activity;\n-    if (activity.allow_stop && activity.id.empty() == false)\n-      cast_config->StopCasting(activity.id);\n-  }\n-}\n-\n-// Stops currently casting device.\n-void StopCast() {\n-  CastConfigDelegate* cast_config =\n-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();\n-  if (cast_config && cast_config->HasCastExtension()) {\n-    cast_config->GetReceiversAndActivities(\n-        base::Bind(&StopCastCallback, cast_config));\n-  }\n-}\n-\n }  // namespace\n \n namespace tray {\n@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)\n   title_ = new views::Label;\n   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));\n+  title_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));\n   label_container_->AddChildView(title_);\n \n   details_ = new views::Label;\n   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   details_->SetMultiLine(false);\n   details_->SetEnabledColor(kHeaderTextColorNormal);\n+  details_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));\n   label_container_->AddChildView(details_);\n \n   AddChildView(label_container_);\n@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(\n void CastCastView::ButtonPressed(views::Button* sender,\n                                  const ui::Event& event) {\n   DCHECK(sender == stop_button_);\n-  StopCast();\n+  cast_config_delegate_->StopCasting();\n }\n \n // This view by itself does very little. It acts as a front-end for managing""}<_**next**_>{""sha"": ""9873cf404c009dd69fa9d0d8da2cd80f6a693ae2"", ""filename"": ""chrome/browser/ui/ash/cast_config_delegate_chromeos.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -138,8 +138,14 @@ void CastConfigDelegateChromeos::CastToReceiver(\n                     \""');\"");\n }\n \n-void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {\n+void CastConfigDelegateChromeos::StopCasting() {\n   ExecuteJavaScript(\""backgroundSetup.stopCastMirroring('user-stop');\"");\n+\n+  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.\n+  // The current beta/release versions of the cast extension do not export\n+  // stopCastMirroring, so we will also try to call the minified version.\n+  // See crbug.com/489929.\n+  ExecuteJavaScript(\""backgroundSetup.Qu('user-stop');\"");\n }\n \n void CastConfigDelegateChromeos::LaunchCastOptions() {""}<_**next**_>{""sha"": ""c77afebdd8a45e32aa1f95a450a13bc3e575483e"", ""filename"": ""chrome/browser/ui/ash/cast_config_delegate_chromeos.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.h?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -27,7 +27,7 @@ class CastConfigDelegateChromeos : public ash::CastConfigDelegate {\n   void GetReceiversAndActivities(\n       const ReceiversAndActivitesCallback& callback) override;\n   void CastToReceiver(const std::string& receiver_id) override;\n-  void StopCasting(const std::string& activity_id) override;\n+  void StopCasting() override;\n   void LaunchCastOptions() override;\n \n   DISALLOW_COPY_AND_ASSIGN(CastConfigDelegateChromeos);""}","void StopCastCallback(
","void StopCastCallback(
    CastConfigDelegate* cast_config,
    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {
  for (auto& item : receivers_activities) {
    CastConfigDelegate::Activity activity = item.second.activity;
    if (activity.allow_stop && activity.id.empty() == false)
      cast_config->StopCasting(activity.id);
  }
}
",C,,"    CastConfigDelegate* cast_config,
    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {
  for (auto& item : receivers_activities) {
    CastConfigDelegate::Activity activity = item.second.activity;
    if (activity.allow_stop && activity.id.empty() == false)
      cast_config->StopCasting(activity.id);
  }
}
",,"@@ -38,28 +38,6 @@ namespace ash {
 
 namespace {
 const int kStopButtonRightPadding = 18;
-
-// Callback helper for StopCast().
-void StopCastCallback(
-    CastConfigDelegate* cast_config,
-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {
-  for (auto& item : receivers_activities) {
-    CastConfigDelegate::Activity activity = item.second.activity;
-    if (activity.allow_stop && activity.id.empty() == false)
-      cast_config->StopCasting(activity.id);
-  }
-}
-
-// Stops currently casting device.
-void StopCast() {
-  CastConfigDelegate* cast_config =
-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();
-  if (cast_config && cast_config->HasCastExtension()) {
-    cast_config->GetReceiversAndActivities(
-        base::Bind(&StopCastCallback, cast_config));
-  }
-}
-
 }  // namespace
 
 namespace tray {
@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)
   title_ = new views::Label;
   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));
+  title_->SetText(
+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));
   label_container_->AddChildView(title_);
 
   details_ = new views::Label;
   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   details_->SetMultiLine(false);
   details_->SetEnabledColor(kHeaderTextColorNormal);
+  details_->SetText(
+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));
   label_container_->AddChildView(details_);
 
   AddChildView(label_container_);
@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(
 void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
-  StopCast();
+  cast_config_delegate_->StopCasting();
 }
 
 // This view by itself does very little. It acts as a front-end for managing",Chrome,1924f747637265f563892b8f56a64391f6208194,04192cf91fe892f516854317886ae2227af0ccb5,1,"void StopCastCallback(
//flaw_line_below:
    CastConfigDelegate* cast_config,
//flaw_line_below:
    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {
//flaw_line_below:
  for (auto& item : receivers_activities) {
//flaw_line_below:
    CastConfigDelegate::Activity activity = item.second.activity;
//flaw_line_below:
    if (activity.allow_stop && activity.id.empty() == false)
//flaw_line_below:
      cast_config->StopCasting(activity.id);
//flaw_line_below:
  }
//flaw_line_below:
}
"
7594,185330,,Remote,Not required,,CVE-2014-1747,https://www.cvedetails.com/cve/CVE-2014-1747/,CWE-79,Medium,,Partial,,2014-05-21,4.3,"Cross-site scripting (XSS) vulnerability in the DocumentLoader::maybeCreateArchive function in core/loader/DocumentLoader.cpp in Blink, as used in Google Chrome before 35.0.1916.114, allows remote attackers to inject arbitrary web script or HTML via crafted MHTML content, aka *Universal XSS (UXSS).*",2017-12-28,XSS ,7,https://github.com/chromium/chromium/commit/1924f747637265f563892b8f56a64391f6208194,1924f747637265f563892b8f56a64391f6208194,"Allow the cast tray to function as expected when the installed extension is missing API methods.

BUG=489445

Review URL: https://codereview.chromium.org/1145833003

Cr-Commit-Position: refs/heads/master@{#330663}",0,chrome/browser/ui/ash/cast_config_delegate_chromeos.cc,"{""sha"": ""d997e0c26bfef095d87be8c1d343ac30cee969a8"", ""filename"": ""ash/ash_strings.grd"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/ash_strings.grd?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -278,6 +278,12 @@ Press Ctrl+Alt+Z to disable.\n       <message name=\""IDS_ASH_STATUS_TRAY_CAST_STOP\"" desc=\""The label used in the tray popup to stop casting.\"">\n         Stop\n       </message>\n+      <message name=\""IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE\"" desc=\""The label used when we have detected we are casting but do not know if we are casting a tab or the desktop.\"">\n+        Casting\n+      </message>\n+      <message name=\""IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER\"" desc=\""The label used when we have detected we are casting but do not know the name of the receiver.\"">\n+        Unknown receiver\n+      </message>\n \n       <message name=\""IDS_ASH_STATUS_TRAY_BLUETOOTH\"" desc=\""The label used as the header in the bluetooth popup.\"">\n         Bluetooth""}<_**next**_>{""sha"": ""f38a05c5f3f6322ad00a77f7b24d61a6916f6fbb"", ""filename"": ""ash/cast_config_delegate.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 7, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/cast_config_delegate.h?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -83,13 +83,8 @@ class CastConfigDelegate {\n   // Cast to a receiver specified by |receiver_id|.\n   virtual void CastToReceiver(const std::string& receiver_id) = 0;\n \n-  // Stop ongoing cast. The |activity_id| is the unique identifier associated\n-  // with the ongoing cast. Each receiver has only one possible activity\n-  // associated with it. The |activity_id| is available by invoking\n-  // GetReceiversAndActivities(); if the receiver is currently casting, then the\n-  // associated activity data will have an id. This id can be used to stop the\n-  // cast in this method.\n-  virtual void StopCasting(const std::string& activity_id) = 0;\n+  // Stop an ongoing cast.\n+  virtual void StopCasting() = 0;\n \n   // Opens Options page for cast.\n   virtual void LaunchCastOptions() = 0;""}<_**next**_>{""sha"": ""355eb404d27750dfe60dce19869fdb21fcc125be"", ""filename"": ""ash/system/cast/tray_cast.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 23, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ash/system/cast/tray_cast.cc?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -38,28 +38,6 @@ namespace ash {\n \n namespace {\n const int kStopButtonRightPadding = 18;\n-\n-// Callback helper for StopCast().\n-void StopCastCallback(\n-    CastConfigDelegate* cast_config,\n-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {\n-  for (auto& item : receivers_activities) {\n-    CastConfigDelegate::Activity activity = item.second.activity;\n-    if (activity.allow_stop && activity.id.empty() == false)\n-      cast_config->StopCasting(activity.id);\n-  }\n-}\n-\n-// Stops currently casting device.\n-void StopCast() {\n-  CastConfigDelegate* cast_config =\n-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();\n-  if (cast_config && cast_config->HasCastExtension()) {\n-    cast_config->GetReceiversAndActivities(\n-        base::Bind(&StopCastCallback, cast_config));\n-  }\n-}\n-\n }  // namespace\n \n namespace tray {\n@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)\n   title_ = new views::Label;\n   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));\n+  title_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));\n   label_container_->AddChildView(title_);\n \n   details_ = new views::Label;\n   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   details_->SetMultiLine(false);\n   details_->SetEnabledColor(kHeaderTextColorNormal);\n+  details_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));\n   label_container_->AddChildView(details_);\n \n   AddChildView(label_container_);\n@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(\n void CastCastView::ButtonPressed(views::Button* sender,\n                                  const ui::Event& event) {\n   DCHECK(sender == stop_button_);\n-  StopCast();\n+  cast_config_delegate_->StopCasting();\n }\n \n // This view by itself does very little. It acts as a front-end for managing""}<_**next**_>{""sha"": ""9873cf404c009dd69fa9d0d8da2cd80f6a693ae2"", ""filename"": ""chrome/browser/ui/ash/cast_config_delegate_chromeos.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -138,8 +138,14 @@ void CastConfigDelegateChromeos::CastToReceiver(\n                     \""');\"");\n }\n \n-void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {\n+void CastConfigDelegateChromeos::StopCasting() {\n   ExecuteJavaScript(\""backgroundSetup.stopCastMirroring('user-stop');\"");\n+\n+  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.\n+  // The current beta/release versions of the cast extension do not export\n+  // stopCastMirroring, so we will also try to call the minified version.\n+  // See crbug.com/489929.\n+  ExecuteJavaScript(\""backgroundSetup.Qu('user-stop');\"");\n }\n \n void CastConfigDelegateChromeos::LaunchCastOptions() {""}<_**next**_>{""sha"": ""c77afebdd8a45e32aa1f95a450a13bc3e575483e"", ""filename"": ""chrome/browser/ui/ash/cast_config_delegate_chromeos.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.h?ref=1924f747637265f563892b8f56a64391f6208194"", ""patch"": ""@@ -27,7 +27,7 @@ class CastConfigDelegateChromeos : public ash::CastConfigDelegate {\n   void GetReceiversAndActivities(\n       const ReceiversAndActivitesCallback& callback) override;\n   void CastToReceiver(const std::string& receiver_id) override;\n-  void StopCasting(const std::string& activity_id) override;\n+  void StopCasting() override;\n   void LaunchCastOptions() override;\n \n   DISALLOW_COPY_AND_ASSIGN(CastConfigDelegateChromeos);""}","void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {
void CastConfigDelegateChromeos::StopCasting() {
   ExecuteJavaScript(""backgroundSetup.stopCastMirroring('user-stop');"");

  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.
  // The current beta/release versions of the cast extension do not export
  // stopCastMirroring, so we will also try to call the minified version.
  // See crbug.com/489929.
  ExecuteJavaScript(""backgroundSetup.Qu('user-stop');"");
 }
","void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {
   ExecuteJavaScript(""backgroundSetup.stopCastMirroring('user-stop');"");
 }
",C,"void CastConfigDelegateChromeos::StopCasting() {

  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.
  // The current beta/release versions of the cast extension do not export
  // stopCastMirroring, so we will also try to call the minified version.
  // See crbug.com/489929.
  ExecuteJavaScript(""backgroundSetup.Qu('user-stop');"");
",,,"@@ -138,8 +138,14 @@ void CastConfigDelegateChromeos::CastToReceiver(
                     ""');"");
 }
 
-void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {
+void CastConfigDelegateChromeos::StopCasting() {
   ExecuteJavaScript(""backgroundSetup.stopCastMirroring('user-stop');"");
+
+  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.
+  // The current beta/release versions of the cast extension do not export
+  // stopCastMirroring, so we will also try to call the minified version.
+  // See crbug.com/489929.
+  ExecuteJavaScript(""backgroundSetup.Qu('user-stop');"");
 }
 
 void CastConfigDelegateChromeos::LaunchCastOptions() {",Chrome,1924f747637265f563892b8f56a64391f6208194,04192cf91fe892f516854317886ae2227af0ccb5,1,"void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {
//fix_flaw_line_below:
//void CastConfigDelegateChromeos::StopCasting() {
   ExecuteJavaScript(""backgroundSetup.stopCastMirroring('user-stop');"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.
//fix_flaw_line_below:
//  // The current beta/release versions of the cast extension do not export
//fix_flaw_line_below:
//  // stopCastMirroring, so we will also try to call the minified version.
//fix_flaw_line_below:
//  // See crbug.com/489929.
//fix_flaw_line_below:
//  ExecuteJavaScript(""backgroundSetup.Qu('user-stop');"");
 }
"
8090,185826,,Remote,Not required,,CVE-2015-1286,https://www.cvedetails.com/cve/CVE-2015-1286/,CWE-79,Medium,,Partial,,2015-07-22,4.3,"Cross-site scripting (XSS) vulnerability in the V8ContextNativeHandler::GetModuleSystem function in extensions/renderer/v8_context_native_handler.cc in Google Chrome before 44.0.2403.89 allows remote attackers to inject arbitrary web script or HTML by leveraging the lack of a certain V8 context restriction, aka a Blink *Universal XSS (UXSS).*",2018-10-30,XSS ,2,https://github.com/chromium/chromium/commit/7923c2a2c443d98c432864e361b1d090f0c911ca,7923c2a2c443d98c432864e361b1d090f0c911ca,"Add a test that getModuleSystem() doesn't work cross origin

BUG=504011
R=kalman@chromium.org
TBR=fukino@chromium.org

Review URL: https://codereview.chromium.org/1241443004

Cr-Commit-Position: refs/heads/master@{#338663}",4,extensions/renderer/v8_context_native_handler.cc,"{""sha"": ""9843e7ff430b7cc5976402ecf3b734fb91cc65e6"", ""filename"": ""chrome/browser/extensions/extension_bindings_apitest.cc"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 1, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/chrome/browser/extensions/extension_bindings_apitest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/chrome/browser/extensions/extension_bindings_apitest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_bindings_apitest.cc?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -6,7 +6,9 @@\n \n #include \""chrome/browser/extensions/api/permissions/permissions_api.h\""\n #include \""chrome/browser/extensions/extension_apitest.h\""\n+#include \""chrome/browser/net/url_request_mock_util.h\""\n #include \""chrome/browser/ui/browser.h\""\n+#include \""content/public/browser/browser_thread.h\""\n #include \""content/public/test/browser_test_utils.h\""\n #include \""extensions/browser/extension_host.h\""\n #include \""extensions/browser/process_manager.h\""\n@@ -16,7 +18,14 @@\n namespace extensions {\n namespace {\n \n-class ExtensionBindingsApiTest : public ExtensionApiTest {};\n+class ExtensionBindingsApiTest : public ExtensionApiTest {\n+ public:\n+  void SetUpOnMainThread() override {\n+    content::BrowserThread::PostTask(\n+        content::BrowserThread::IO, FROM_HERE,\n+        base::Bind(&chrome_browser_net::SetUrlRequestMocksEnabled, true));\n+  }\n+};\n \n IN_PROC_BROWSER_TEST_F(ExtensionBindingsApiTest,\n                        UnavailableBindingsNeverRegistered) {\n@@ -96,5 +105,11 @@ IN_PROC_BROWSER_TEST_F(ExtensionBindingsApiTest, ApiEnums) {\n   ASSERT_TRUE(RunExtensionTest(\""bindings/api_enums\"")) << message_;\n };\n \n+// Regression test for http://crbug.com/504011 - proper access checks on\n+// getModuleSystem().\n+IN_PROC_BROWSER_TEST_F(ExtensionBindingsApiTest, ModuleSystem) {\n+  ASSERT_TRUE(RunExtensionTest(\""bindings/module_system\"")) << message_;\n+}\n+\n }  // namespace\n }  // namespace extensions""}<_**next**_>{""sha"": ""cc788ec5922f3d5029c83b5b69162ed38e164e23"", ""filename"": ""chrome/test/data/extensions/api_test/automation/tests/unit/test.js"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/chrome/test/data/extensions/api_test/automation/tests/unit/test.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/chrome/test/data/extensions/api_test/automation/tests/unit/test.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/automation/tests/unit/test.js?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -2,7 +2,8 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-chrome.test.runWithModuleSystem(function(moduleSystem) {\n+chrome.test.runWithNativesEnabled(function() {\n+  var moduleSystem = chrome.test.getModuleSystem(window);\n   window.AutomationRootNode =\n       moduleSystem.require('automationNode').AutomationRootNode;\n   window.privates = moduleSystem.privates;""}<_**next**_>{""sha"": ""f646363a0cad68203113476e6efd2b9201d77a99"", ""filename"": ""chrome/test/data/extensions/api_test/bindings/module_system/background.js"", ""status"": ""added"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/chrome/test/data/extensions/api_test/bindings/module_system/background.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/chrome/test/data/extensions/api_test/bindings/module_system/background.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/bindings/module_system/background.js?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -0,0 +1,15 @@\n+// Copyright 2015 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+chrome.test.assertTrue(chrome.hasOwnProperty('runtime'));\n+\n+var iframe = document.createElement('iframe');\n+iframe.src = 'http://mock.http/';\n+iframe.onload = function() {\n+  chrome.test.assertTrue(chrome.test.getModuleSystem(window) instanceof Object);\n+  chrome.test.assertEq(undefined,\n+                       chrome.test.getModuleSystem(iframe.contentWindow));\n+  chrome.test.notifyPass();\n+};\n+document.body.appendChild(iframe);""}<_**next**_>{""sha"": ""b976fcf7ab1053019fed11952d7c5f0f55ae9114"", ""filename"": ""chrome/test/data/extensions/api_test/bindings/module_system/manifest.json"", ""status"": ""added"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/chrome/test/data/extensions/api_test/bindings/module_system/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/chrome/test/data/extensions/api_test/bindings/module_system/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/bindings/module_system/manifest.json?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -0,0 +1,8 @@\n+{\n+  \""name\"": \""bindings/module_system\"",\n+  \""manifest_version\"": 2,\n+  \""version\"": \""1\"",\n+  \""background\"": {\n+    \""scripts\"": [\""background.js\""]\n+  }\n+}""}<_**next**_>{""sha"": ""1b910a98a0c534688dcd4b8a827408ef6c643cd4"", ""filename"": ""extensions/common/api/test.json"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 2, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/common/api/test.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/common/api/test.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/common/api/test.json?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -147,17 +147,34 @@\n         ]\n       },\n       {\n-        \""name\"": \""runWithModuleSystem\"",\n+        \""name\"": \""runWithNativesEnabled\"",\n         \""type\"": \""function\"",\n         \""nocompile\"": true,\n-        \""description\"": \""Gets a module system suitable for use in the context of a test.\"",\n+        \""description\"": \""Runs the given function with access to native methods enabled.\"",\n         \""parameters\"": [\n           {\n             \""type\"": \""function\"",\n             \""name\"": \""callback\""\n           }\n         ]\n       },\n+      {\n+        \""name\"": \""getModuleSystem\"",\n+        \""type\"": \""function\"",\n+        \""nocompile\"": true,\n+        \""description\"": \""Returns an instance of the module system for the given context.\"",\n+        \""parameters\"": [\n+          {\n+            \""type\"": \""any\"",\n+            \""name\"": \""context\""\n+          }\n+        ],\n+        \""returns\"": {\n+          \""type\"": \""any\"",\n+          \""description\"": \""The module system\"",\n+          \""optional\"": true\n+        }\n+      },\n       {\n         \""name\"": \""assertTrue\"",\n         \""type\"": \""function\"",""}<_**next**_>{""sha"": ""ebb3f1b30a7ce2cd00e0c316e645e6fdac7b1398"", ""filename"": ""extensions/renderer/resources/test_custom_bindings.js"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 4, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/renderer/resources/test_custom_bindings.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/renderer/resources/test_custom_bindings.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/resources/test_custom_bindings.js?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -14,8 +14,8 @@ var GetAPIFeatures = requireNative('test_features').GetAPIFeatures;\n var uncaughtExceptionHandler = require('uncaught_exception_handler');\n var userGestures = requireNative('user_gestures');\n \n-var RunWithNativesEnabledModuleSystem =\n-    requireNative('v8_context').RunWithNativesEnabledModuleSystem;\n+var RunWithNativesEnabled = requireNative('v8_context').RunWithNativesEnabled;\n+var GetModuleSystem = requireNative('v8_context').GetModuleSystem;\n \n binding.registerCustomHook(function(api) {\n   var chromeTest = api.compiledApi;\n@@ -122,8 +122,12 @@ binding.registerCustomHook(function(api) {\n     testDone();\n   });\n \n-  apiFunctions.setHandleRequest('runWithModuleSystem', function(callback) {\n-    RunWithNativesEnabledModuleSystem(callback);\n+  apiFunctions.setHandleRequest('runWithNativesEnabled', function(callback) {\n+    RunWithNativesEnabled(callback);\n+  });\n+\n+  apiFunctions.setHandleRequest('getModuleSystem', function(context) {\n+    return GetModuleSystem(context);\n   });\n \n   apiFunctions.setHandleRequest('assertTrue', function(test, message) {""}<_**next**_>{""sha"": ""7dbc2b8d69f5874a7faad72168d8da5e9a7934a2"", ""filename"": ""extensions/renderer/v8_context_native_handler.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/renderer/v8_context_native_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/renderer/v8_context_native_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/v8_context_native_handler.cc?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -24,8 +24,8 @@ V8ContextNativeHandler::V8ContextNativeHandler(ScriptContext* context,\n                 base::Bind(&V8ContextNativeHandler::GetModuleSystem,\n                            base::Unretained(this)));\n   RouteFunction(\n-      \""RunWithNativesEnabledModuleSystem\"",\n-      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabledModuleSystem,\n+      \""RunWithNativesEnabled\"",\n+      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,\n                  base::Unretained(this)));\n }\n \n@@ -58,15 +58,12 @@ void V8ContextNativeHandler::GetModuleSystem(\n     args.GetReturnValue().Set(context->module_system()->NewInstance());\n }\n \n-void V8ContextNativeHandler::RunWithNativesEnabledModuleSystem(\n+void V8ContextNativeHandler::RunWithNativesEnabled(\n     const v8::FunctionCallbackInfo<v8::Value>& args) {\n   CHECK_EQ(args.Length(), 1);\n   CHECK(args[0]->IsFunction());\n-  v8::Local<v8::Value> call_with_args[] = {\n-    context()->module_system()->NewInstance()};\n   ModuleSystem::NativesEnabledScope natives_enabled(context()->module_system());\n-  context()->CallFunction(v8::Local<v8::Function>::Cast(args[0]), 1,\n-                          call_with_args);\n+  context()->CallFunction(v8::Local<v8::Function>::Cast(args[0]));\n }\n \n }  // namespace extensions""}<_**next**_>{""sha"": ""da5098b2c3262512b1c03566dccaaa3e3fea1243"", ""filename"": ""extensions/renderer/v8_context_native_handler.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/renderer/v8_context_native_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/renderer/v8_context_native_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/v8_context_native_handler.h?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -19,8 +19,7 @@ class V8ContextNativeHandler : public ObjectBackedNativeHandler {\n   void GetAvailability(const v8::FunctionCallbackInfo<v8::Value>& args);\n   void GetModuleSystem(const v8::FunctionCallbackInfo<v8::Value>& args);\n \n-  void RunWithNativesEnabledModuleSystem(\n-      const v8::FunctionCallbackInfo<v8::Value>& args);\n+  void RunWithNativesEnabled(const v8::FunctionCallbackInfo<v8::Value>& args);\n \n   ScriptContext* context_;\n   Dispatcher* dispatcher_;""}<_**next**_>{""sha"": ""10c479272ed442b27b95dbc532a6f73c2ef31d9b"", ""filename"": ""extensions/test/data/api_test_base_unittest.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/test/data/api_test_base_unittest.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/test/data/api_test_base_unittest.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/test/data/api_test_base_unittest.js?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -55,7 +55,7 @@ unittestBindings.exportTests([\n     }\n     test.runWithUserGesture(increment);\n     test.runWithoutUserGesture(increment);\n-    test.runWithModuleSystem(increment);\n+    test.runWithNativesEnabled(increment);\n     test.assertEq(3, counter);\n     test.assertFalse(test.isProcessingUserGesture());\n     test.assertTrue(!!test.getApiFeatures());""}<_**next**_>{""sha"": ""b76bbacd56c2bd0b8a53643466afbfc14f9ec731"", ""filename"": ""ui/file_manager/externs/chrome_test.js"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 2, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/ui/file_manager/externs/chrome_test.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/ui/file_manager/externs/chrome_test.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/file_manager/externs/chrome_test.js?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -62,10 +62,16 @@ chrome.test.fail = function(message) {};\n chrome.test.succeed = function(message) {};\n \n /**\n- * Gets a module system suitable for use in the context of a test.\n+ * Runs the given function with access to native methods enabled.\n  * @param {Function} callback\n  */\n-chrome.test.runWithModuleSystem = function(callback) {};\n+chrome.test.runWithNativesEnabled = function(callback) {};\n+\n+/**\n+ * Returns an instance of the ModuleSystem for the given context.\n+ * @param {Object} context\n+ */\n+chrome.test.getModuleSystem = function(context) {};\n \n /**\n  * @param {?} test""}","void V8ContextNativeHandler::RunWithNativesEnabledModuleSystem(
void V8ContextNativeHandler::RunWithNativesEnabled(
     const v8::FunctionCallbackInfo<v8::Value>& args) {
   CHECK_EQ(args.Length(), 1);
   CHECK(args[0]->IsFunction());
   ModuleSystem::NativesEnabledScope natives_enabled(context()->module_system());
  context()->CallFunction(v8::Local<v8::Function>::Cast(args[0]));
 }
","void V8ContextNativeHandler::RunWithNativesEnabledModuleSystem(
     const v8::FunctionCallbackInfo<v8::Value>& args) {
   CHECK_EQ(args.Length(), 1);
   CHECK(args[0]->IsFunction());
  v8::Local<v8::Value> call_with_args[] = {
    context()->module_system()->NewInstance()};
   ModuleSystem::NativesEnabledScope natives_enabled(context()->module_system());
  context()->CallFunction(v8::Local<v8::Function>::Cast(args[0]), 1,
                          call_with_args);
 }
",C,"void V8ContextNativeHandler::RunWithNativesEnabled(
  context()->CallFunction(v8::Local<v8::Function>::Cast(args[0]));
","  v8::Local<v8::Value> call_with_args[] = {
    context()->module_system()->NewInstance()};
  context()->CallFunction(v8::Local<v8::Function>::Cast(args[0]), 1,
                          call_with_args);
",,"@@ -24,8 +24,8 @@ V8ContextNativeHandler::V8ContextNativeHandler(ScriptContext* context,
                 base::Bind(&V8ContextNativeHandler::GetModuleSystem,
                            base::Unretained(this)));
   RouteFunction(
-      ""RunWithNativesEnabledModuleSystem"",
-      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabledModuleSystem,
+      ""RunWithNativesEnabled"",
+      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,
                  base::Unretained(this)));
 }
 
@@ -58,15 +58,12 @@ void V8ContextNativeHandler::GetModuleSystem(
     args.GetReturnValue().Set(context->module_system()->NewInstance());
 }
 
-void V8ContextNativeHandler::RunWithNativesEnabledModuleSystem(
+void V8ContextNativeHandler::RunWithNativesEnabled(
     const v8::FunctionCallbackInfo<v8::Value>& args) {
   CHECK_EQ(args.Length(), 1);
   CHECK(args[0]->IsFunction());
-  v8::Local<v8::Value> call_with_args[] = {
-    context()->module_system()->NewInstance()};
   ModuleSystem::NativesEnabledScope natives_enabled(context()->module_system());
-  context()->CallFunction(v8::Local<v8::Function>::Cast(args[0]), 1,
-                          call_with_args);
+  context()->CallFunction(v8::Local<v8::Function>::Cast(args[0]));
 }
 
 }  // namespace extensions",Chrome,7923c2a2c443d98c432864e361b1d090f0c911ca,a0743be4faeba12784322efb70387bf708308bf6,1,"void V8ContextNativeHandler::RunWithNativesEnabledModuleSystem(
//fix_flaw_line_below:
//void V8ContextNativeHandler::RunWithNativesEnabled(
     const v8::FunctionCallbackInfo<v8::Value>& args) {
   CHECK_EQ(args.Length(), 1);
   CHECK(args[0]->IsFunction());
//flaw_line_below:
  v8::Local<v8::Value> call_with_args[] = {
//flaw_line_below:
    context()->module_system()->NewInstance()};
   ModuleSystem::NativesEnabledScope natives_enabled(context()->module_system());
//flaw_line_below:
  context()->CallFunction(v8::Local<v8::Function>::Cast(args[0]), 1,
//flaw_line_below:
                          call_with_args);
//fix_flaw_line_below:
//  context()->CallFunction(v8::Local<v8::Function>::Cast(args[0]));
 }
"
8091,185827,,Remote,Not required,,CVE-2015-1286,https://www.cvedetails.com/cve/CVE-2015-1286/,CWE-79,Medium,,Partial,,2015-07-22,4.3,"Cross-site scripting (XSS) vulnerability in the V8ContextNativeHandler::GetModuleSystem function in extensions/renderer/v8_context_native_handler.cc in Google Chrome before 44.0.2403.89 allows remote attackers to inject arbitrary web script or HTML by leveraging the lack of a certain V8 context restriction, aka a Blink *Universal XSS (UXSS).*",2018-10-30,XSS ,2,https://github.com/chromium/chromium/commit/7923c2a2c443d98c432864e361b1d090f0c911ca,7923c2a2c443d98c432864e361b1d090f0c911ca,"Add a test that getModuleSystem() doesn't work cross origin

BUG=504011
R=kalman@chromium.org
TBR=fukino@chromium.org

Review URL: https://codereview.chromium.org/1241443004

Cr-Commit-Position: refs/heads/master@{#338663}",2,extensions/renderer/v8_context_native_handler.cc,"{""sha"": ""9843e7ff430b7cc5976402ecf3b734fb91cc65e6"", ""filename"": ""chrome/browser/extensions/extension_bindings_apitest.cc"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 1, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/chrome/browser/extensions/extension_bindings_apitest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/chrome/browser/extensions/extension_bindings_apitest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_bindings_apitest.cc?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -6,7 +6,9 @@\n \n #include \""chrome/browser/extensions/api/permissions/permissions_api.h\""\n #include \""chrome/browser/extensions/extension_apitest.h\""\n+#include \""chrome/browser/net/url_request_mock_util.h\""\n #include \""chrome/browser/ui/browser.h\""\n+#include \""content/public/browser/browser_thread.h\""\n #include \""content/public/test/browser_test_utils.h\""\n #include \""extensions/browser/extension_host.h\""\n #include \""extensions/browser/process_manager.h\""\n@@ -16,7 +18,14 @@\n namespace extensions {\n namespace {\n \n-class ExtensionBindingsApiTest : public ExtensionApiTest {};\n+class ExtensionBindingsApiTest : public ExtensionApiTest {\n+ public:\n+  void SetUpOnMainThread() override {\n+    content::BrowserThread::PostTask(\n+        content::BrowserThread::IO, FROM_HERE,\n+        base::Bind(&chrome_browser_net::SetUrlRequestMocksEnabled, true));\n+  }\n+};\n \n IN_PROC_BROWSER_TEST_F(ExtensionBindingsApiTest,\n                        UnavailableBindingsNeverRegistered) {\n@@ -96,5 +105,11 @@ IN_PROC_BROWSER_TEST_F(ExtensionBindingsApiTest, ApiEnums) {\n   ASSERT_TRUE(RunExtensionTest(\""bindings/api_enums\"")) << message_;\n };\n \n+// Regression test for http://crbug.com/504011 - proper access checks on\n+// getModuleSystem().\n+IN_PROC_BROWSER_TEST_F(ExtensionBindingsApiTest, ModuleSystem) {\n+  ASSERT_TRUE(RunExtensionTest(\""bindings/module_system\"")) << message_;\n+}\n+\n }  // namespace\n }  // namespace extensions""}<_**next**_>{""sha"": ""cc788ec5922f3d5029c83b5b69162ed38e164e23"", ""filename"": ""chrome/test/data/extensions/api_test/automation/tests/unit/test.js"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/chrome/test/data/extensions/api_test/automation/tests/unit/test.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/chrome/test/data/extensions/api_test/automation/tests/unit/test.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/automation/tests/unit/test.js?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -2,7 +2,8 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-chrome.test.runWithModuleSystem(function(moduleSystem) {\n+chrome.test.runWithNativesEnabled(function() {\n+  var moduleSystem = chrome.test.getModuleSystem(window);\n   window.AutomationRootNode =\n       moduleSystem.require('automationNode').AutomationRootNode;\n   window.privates = moduleSystem.privates;""}<_**next**_>{""sha"": ""f646363a0cad68203113476e6efd2b9201d77a99"", ""filename"": ""chrome/test/data/extensions/api_test/bindings/module_system/background.js"", ""status"": ""added"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/chrome/test/data/extensions/api_test/bindings/module_system/background.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/chrome/test/data/extensions/api_test/bindings/module_system/background.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/bindings/module_system/background.js?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -0,0 +1,15 @@\n+// Copyright 2015 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+chrome.test.assertTrue(chrome.hasOwnProperty('runtime'));\n+\n+var iframe = document.createElement('iframe');\n+iframe.src = 'http://mock.http/';\n+iframe.onload = function() {\n+  chrome.test.assertTrue(chrome.test.getModuleSystem(window) instanceof Object);\n+  chrome.test.assertEq(undefined,\n+                       chrome.test.getModuleSystem(iframe.contentWindow));\n+  chrome.test.notifyPass();\n+};\n+document.body.appendChild(iframe);""}<_**next**_>{""sha"": ""b976fcf7ab1053019fed11952d7c5f0f55ae9114"", ""filename"": ""chrome/test/data/extensions/api_test/bindings/module_system/manifest.json"", ""status"": ""added"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/chrome/test/data/extensions/api_test/bindings/module_system/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/chrome/test/data/extensions/api_test/bindings/module_system/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/bindings/module_system/manifest.json?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -0,0 +1,8 @@\n+{\n+  \""name\"": \""bindings/module_system\"",\n+  \""manifest_version\"": 2,\n+  \""version\"": \""1\"",\n+  \""background\"": {\n+    \""scripts\"": [\""background.js\""]\n+  }\n+}""}<_**next**_>{""sha"": ""1b910a98a0c534688dcd4b8a827408ef6c643cd4"", ""filename"": ""extensions/common/api/test.json"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 2, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/common/api/test.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/common/api/test.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/common/api/test.json?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -147,17 +147,34 @@\n         ]\n       },\n       {\n-        \""name\"": \""runWithModuleSystem\"",\n+        \""name\"": \""runWithNativesEnabled\"",\n         \""type\"": \""function\"",\n         \""nocompile\"": true,\n-        \""description\"": \""Gets a module system suitable for use in the context of a test.\"",\n+        \""description\"": \""Runs the given function with access to native methods enabled.\"",\n         \""parameters\"": [\n           {\n             \""type\"": \""function\"",\n             \""name\"": \""callback\""\n           }\n         ]\n       },\n+      {\n+        \""name\"": \""getModuleSystem\"",\n+        \""type\"": \""function\"",\n+        \""nocompile\"": true,\n+        \""description\"": \""Returns an instance of the module system for the given context.\"",\n+        \""parameters\"": [\n+          {\n+            \""type\"": \""any\"",\n+            \""name\"": \""context\""\n+          }\n+        ],\n+        \""returns\"": {\n+          \""type\"": \""any\"",\n+          \""description\"": \""The module system\"",\n+          \""optional\"": true\n+        }\n+      },\n       {\n         \""name\"": \""assertTrue\"",\n         \""type\"": \""function\"",""}<_**next**_>{""sha"": ""ebb3f1b30a7ce2cd00e0c316e645e6fdac7b1398"", ""filename"": ""extensions/renderer/resources/test_custom_bindings.js"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 4, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/renderer/resources/test_custom_bindings.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/renderer/resources/test_custom_bindings.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/resources/test_custom_bindings.js?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -14,8 +14,8 @@ var GetAPIFeatures = requireNative('test_features').GetAPIFeatures;\n var uncaughtExceptionHandler = require('uncaught_exception_handler');\n var userGestures = requireNative('user_gestures');\n \n-var RunWithNativesEnabledModuleSystem =\n-    requireNative('v8_context').RunWithNativesEnabledModuleSystem;\n+var RunWithNativesEnabled = requireNative('v8_context').RunWithNativesEnabled;\n+var GetModuleSystem = requireNative('v8_context').GetModuleSystem;\n \n binding.registerCustomHook(function(api) {\n   var chromeTest = api.compiledApi;\n@@ -122,8 +122,12 @@ binding.registerCustomHook(function(api) {\n     testDone();\n   });\n \n-  apiFunctions.setHandleRequest('runWithModuleSystem', function(callback) {\n-    RunWithNativesEnabledModuleSystem(callback);\n+  apiFunctions.setHandleRequest('runWithNativesEnabled', function(callback) {\n+    RunWithNativesEnabled(callback);\n+  });\n+\n+  apiFunctions.setHandleRequest('getModuleSystem', function(context) {\n+    return GetModuleSystem(context);\n   });\n \n   apiFunctions.setHandleRequest('assertTrue', function(test, message) {""}<_**next**_>{""sha"": ""7dbc2b8d69f5874a7faad72168d8da5e9a7934a2"", ""filename"": ""extensions/renderer/v8_context_native_handler.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/renderer/v8_context_native_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/renderer/v8_context_native_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/v8_context_native_handler.cc?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -24,8 +24,8 @@ V8ContextNativeHandler::V8ContextNativeHandler(ScriptContext* context,\n                 base::Bind(&V8ContextNativeHandler::GetModuleSystem,\n                            base::Unretained(this)));\n   RouteFunction(\n-      \""RunWithNativesEnabledModuleSystem\"",\n-      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabledModuleSystem,\n+      \""RunWithNativesEnabled\"",\n+      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,\n                  base::Unretained(this)));\n }\n \n@@ -58,15 +58,12 @@ void V8ContextNativeHandler::GetModuleSystem(\n     args.GetReturnValue().Set(context->module_system()->NewInstance());\n }\n \n-void V8ContextNativeHandler::RunWithNativesEnabledModuleSystem(\n+void V8ContextNativeHandler::RunWithNativesEnabled(\n     const v8::FunctionCallbackInfo<v8::Value>& args) {\n   CHECK_EQ(args.Length(), 1);\n   CHECK(args[0]->IsFunction());\n-  v8::Local<v8::Value> call_with_args[] = {\n-    context()->module_system()->NewInstance()};\n   ModuleSystem::NativesEnabledScope natives_enabled(context()->module_system());\n-  context()->CallFunction(v8::Local<v8::Function>::Cast(args[0]), 1,\n-                          call_with_args);\n+  context()->CallFunction(v8::Local<v8::Function>::Cast(args[0]));\n }\n \n }  // namespace extensions""}<_**next**_>{""sha"": ""da5098b2c3262512b1c03566dccaaa3e3fea1243"", ""filename"": ""extensions/renderer/v8_context_native_handler.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/renderer/v8_context_native_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/renderer/v8_context_native_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/v8_context_native_handler.h?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -19,8 +19,7 @@ class V8ContextNativeHandler : public ObjectBackedNativeHandler {\n   void GetAvailability(const v8::FunctionCallbackInfo<v8::Value>& args);\n   void GetModuleSystem(const v8::FunctionCallbackInfo<v8::Value>& args);\n \n-  void RunWithNativesEnabledModuleSystem(\n-      const v8::FunctionCallbackInfo<v8::Value>& args);\n+  void RunWithNativesEnabled(const v8::FunctionCallbackInfo<v8::Value>& args);\n \n   ScriptContext* context_;\n   Dispatcher* dispatcher_;""}<_**next**_>{""sha"": ""10c479272ed442b27b95dbc532a6f73c2ef31d9b"", ""filename"": ""extensions/test/data/api_test_base_unittest.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/test/data/api_test_base_unittest.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/extensions/test/data/api_test_base_unittest.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/test/data/api_test_base_unittest.js?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -55,7 +55,7 @@ unittestBindings.exportTests([\n     }\n     test.runWithUserGesture(increment);\n     test.runWithoutUserGesture(increment);\n-    test.runWithModuleSystem(increment);\n+    test.runWithNativesEnabled(increment);\n     test.assertEq(3, counter);\n     test.assertFalse(test.isProcessingUserGesture());\n     test.assertTrue(!!test.getApiFeatures());""}<_**next**_>{""sha"": ""b76bbacd56c2bd0b8a53643466afbfc14f9ec731"", ""filename"": ""ui/file_manager/externs/chrome_test.js"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 2, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/7923c2a2c443d98c432864e361b1d090f0c911ca/ui/file_manager/externs/chrome_test.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7923c2a2c443d98c432864e361b1d090f0c911ca/ui/file_manager/externs/chrome_test.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/file_manager/externs/chrome_test.js?ref=7923c2a2c443d98c432864e361b1d090f0c911ca"", ""patch"": ""@@ -62,10 +62,16 @@ chrome.test.fail = function(message) {};\n chrome.test.succeed = function(message) {};\n \n /**\n- * Gets a module system suitable for use in the context of a test.\n+ * Runs the given function with access to native methods enabled.\n  * @param {Function} callback\n  */\n-chrome.test.runWithModuleSystem = function(callback) {};\n+chrome.test.runWithNativesEnabled = function(callback) {};\n+\n+/**\n+ * Returns an instance of the ModuleSystem for the given context.\n+ * @param {Object} context\n+ */\n+chrome.test.getModuleSystem = function(context) {};\n \n /**\n  * @param {?} test""}","V8ContextNativeHandler::V8ContextNativeHandler(ScriptContext* context,
                                               Dispatcher* dispatcher)
    : ObjectBackedNativeHandler(context),
      context_(context),
      dispatcher_(dispatcher) {
  RouteFunction(""GetAvailability"",
                base::Bind(&V8ContextNativeHandler::GetAvailability,
                           base::Unretained(this)));
  RouteFunction(""GetModuleSystem"",
                 base::Bind(&V8ContextNativeHandler::GetModuleSystem,
                            base::Unretained(this)));
   RouteFunction(
      ""RunWithNativesEnabled"",
      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,
                  base::Unretained(this)));
 }
","V8ContextNativeHandler::V8ContextNativeHandler(ScriptContext* context,
                                               Dispatcher* dispatcher)
    : ObjectBackedNativeHandler(context),
      context_(context),
      dispatcher_(dispatcher) {
  RouteFunction(""GetAvailability"",
                base::Bind(&V8ContextNativeHandler::GetAvailability,
                           base::Unretained(this)));
  RouteFunction(""GetModuleSystem"",
                 base::Bind(&V8ContextNativeHandler::GetModuleSystem,
                            base::Unretained(this)));
   RouteFunction(
      ""RunWithNativesEnabledModuleSystem"",
      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabledModuleSystem,
                  base::Unretained(this)));
 }
",C,"      ""RunWithNativesEnabled"",
      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,
","      ""RunWithNativesEnabledModuleSystem"",
      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabledModuleSystem,
",,"@@ -24,8 +24,8 @@ V8ContextNativeHandler::V8ContextNativeHandler(ScriptContext* context,
                 base::Bind(&V8ContextNativeHandler::GetModuleSystem,
                            base::Unretained(this)));
   RouteFunction(
-      ""RunWithNativesEnabledModuleSystem"",
-      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabledModuleSystem,
+      ""RunWithNativesEnabled"",
+      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,
                  base::Unretained(this)));
 }
 
@@ -58,15 +58,12 @@ void V8ContextNativeHandler::GetModuleSystem(
     args.GetReturnValue().Set(context->module_system()->NewInstance());
 }
 
-void V8ContextNativeHandler::RunWithNativesEnabledModuleSystem(
+void V8ContextNativeHandler::RunWithNativesEnabled(
     const v8::FunctionCallbackInfo<v8::Value>& args) {
   CHECK_EQ(args.Length(), 1);
   CHECK(args[0]->IsFunction());
-  v8::Local<v8::Value> call_with_args[] = {
-    context()->module_system()->NewInstance()};
   ModuleSystem::NativesEnabledScope natives_enabled(context()->module_system());
-  context()->CallFunction(v8::Local<v8::Function>::Cast(args[0]), 1,
-                          call_with_args);
+  context()->CallFunction(v8::Local<v8::Function>::Cast(args[0]));
 }
 
 }  // namespace extensions",Chrome,7923c2a2c443d98c432864e361b1d090f0c911ca,a0743be4faeba12784322efb70387bf708308bf6,1,"V8ContextNativeHandler::V8ContextNativeHandler(ScriptContext* context,
                                               Dispatcher* dispatcher)
    : ObjectBackedNativeHandler(context),
      context_(context),
      dispatcher_(dispatcher) {
  RouteFunction(""GetAvailability"",
                base::Bind(&V8ContextNativeHandler::GetAvailability,
                           base::Unretained(this)));
  RouteFunction(""GetModuleSystem"",
                 base::Bind(&V8ContextNativeHandler::GetModuleSystem,
                            base::Unretained(this)));
   RouteFunction(
//flaw_line_below:
      ""RunWithNativesEnabledModuleSystem"",
//flaw_line_below:
      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabledModuleSystem,
//fix_flaw_line_below:
//      ""RunWithNativesEnabled"",
//fix_flaw_line_below:
//      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,
                  base::Unretained(this)));
 }
"
8224,185960,,Remote,Not required,,CVE-2016-5147,https://www.cvedetails.com/cve/CVE-2016-5147/,CWE-79,Medium,,Partial,,2016-09-11,4.3,"Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, mishandles deferred page loads, which allows remote attackers to inject arbitrary web script or HTML via a crafted web site, aka *Universal XSS (UXSS).*",2017-08-12,XSS ,3,https://github.com/chromium/chromium/commit/5472db1c7eca35822219d03be5c817d9a9258c11,5472db1c7eca35822219d03be5c817d9a9258c11,"Always call UpdateCompositedScrollOffset, not just for the root layer

Bug: 927560
Change-Id: I1d5522aae4f11dd3f5b8947bb089bac1bf19bdb4
Reviewed-on: https://chromium-review.googlesource.com/c/1452701
Reviewed-by: Chris Harrelson <chrishtr@chromium.org>
Commit-Queue: Mason Freed <masonfreed@chromium.org>
Cr-Commit-Position: refs/heads/master@{#628942}",1,third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc,"{""sha"": ""7f1f0a4890e03135c6d704b67d0de508ffda6c7d"", ""filename"": ""third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5472db1c7eca35822219d03be5c817d9a9258c11/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5472db1c7eca35822219d03be5c817d9a9258c11/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc?ref=5472db1c7eca35822219d03be5c817d9a9258c11"", ""patch"": ""@@ -2159,7 +2159,9 @@ void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {\n     DCHECK(Layer()->HasCompositedLayerMapping());\n     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();\n     bool handled_scroll =\n-        Layer()->IsRootLayer() && scrolling_coordinator &&\n+        (Layer()->IsRootLayer() ||\n+         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&\n+        scrolling_coordinator &&\n         scrolling_coordinator->UpdateCompositedScrollOffset(this);\n \n     if (!handled_scroll) {""}","void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        (Layer()->IsRootLayer() ||
         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
        scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
","void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        Layer()->IsRootLayer() && scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
",C,"        (Layer()->IsRootLayer() ||
         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
        scrolling_coordinator &&
","        Layer()->IsRootLayer() && scrolling_coordinator &&
",,"@@ -2159,7 +2159,9 @@ void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
-        Layer()->IsRootLayer() && scrolling_coordinator &&
+        (Layer()->IsRootLayer() ||
+         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
+        scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {",Chrome,5472db1c7eca35822219d03be5c817d9a9258c11,756828f7b127d39fb9863dc0c5db67640a88724f,1,"void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
//flaw_line_below:
        Layer()->IsRootLayer() && scrolling_coordinator &&
//fix_flaw_line_below:
//        (Layer()->IsRootLayer() ||
//fix_flaw_line_below:
//         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
//fix_flaw_line_below:
//        scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        // In non-BGPT mode, we need to do a full sub-tree update here, because
        // we need to update the position property to compute
        // offset_to_transform_parent. For more context, see the comment from
        // chrishtr@ here:
        // https://chromium-review.googlesource.com/c/chromium/src/+/1403639/6/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    // If we have fixed elements and we scroll the root layer we might
    // change compositing since the fixed elements might now overlap a
    // composited layer.
    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
"
8239,185975,,Remote,Not required,,CVE-2016-5164,https://www.cvedetails.com/cve/CVE-2016-5164/,CWE-79,Medium,,Partial,,2016-09-11,4.3,"Cross-site scripting (XSS) vulnerability in WebKit/Source/platform/v8_inspector/V8Debugger.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to inject arbitrary web script or HTML into the Developer Tools (aka DevTools) subsystem via a crafted web site, aka *Universal XSS (UXSS).*",2018-10-30,XSS ,2,https://github.com/chromium/chromium/commit/93bc623489bdcfc7e9127614fcfb3258edf3f0f9,93bc623489bdcfc7e9127614fcfb3258edf3f0f9,"[DevTools] Copy objects from debugger context to inspected context properly.

BUG=637594

Review-Url: https://codereview.chromium.org/2253643002
Cr-Commit-Position: refs/heads/master@{#412436}",0,third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp,"{""sha"": ""2c2187b08bb5c2340fde0bae42f64e30e2d45ef8"", ""filename"": ""third_party/WebKit/Source/platform/blink_platform.gypi"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/blink_platform.gypi"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/blink_platform.gypi"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/blink_platform.gypi?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -1176,6 +1176,8 @@\n       'v8_inspector/V8StackTraceImpl.h',\n       'v8_inspector/V8StringUtil.cpp',\n       'v8_inspector/V8StringUtil.h',\n+      'v8_inspector/V8ValueCopier.cpp',\n+      'v8_inspector/V8ValueCopier.h',\n       'v8_inspector/public/V8ContextInfo.h',\n       'v8_inspector/public/V8Inspector.h',\n       'v8_inspector/public/V8InspectorClient.h',""}<_**next**_>{""sha"": ""73a90e225e11aeac62626e36a217ceaa5b2ecf51"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -659,6 +659,8 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> console = v8::Object::New(isolate);\n+    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, console, \""debug\"", V8Console::debugCallback);\n     createBoundFunctionProperty(context, console, \""error\"", V8Console::errorCallback);\n@@ -684,9 +686,6 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex\n     createBoundFunctionProperty(context, console, \""timeEnd\"", V8Console::timeEndCallback);\n     createBoundFunctionProperty(context, console, \""timeStamp\"", V8Console::timeStampCallback);\n \n-    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n-    DCHECK(success);\n-\n     if (hasMemoryAttribute)\n         console->SetAccessorProperty(toV8StringInternalized(isolate, \""memory\""), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);\n \n@@ -707,6 +706,8 @@ v8::Local<v8::Object> V8Console::createCommandLineAPI(InspectedContext* inspecte\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> commandLineAPI = v8::Object::New(isolate);\n+    bool success = commandLineAPI->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, commandLineAPI, \""dir\"", V8Console::dirCallback, \""function dir(value) { [Command Line API] }\"");\n     createBoundFunctionProperty(context, commandLineAPI, \""dirxml\"", V8Console::dirxmlCallback, \""function dirxml(value) { [Command Line API] }\"");""}<_**next**_>{""sha"": ""616bfbe7e474266857090c3ac0f420a9467afbdb"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 22, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -12,6 +12,7 @@\n #include \""platform/v8_inspector/V8InternalValueType.h\""\n #include \""platform/v8_inspector/V8StackTraceImpl.h\""\n #include \""platform/v8_inspector/V8StringUtil.h\""\n+#include \""platform/v8_inspector/V8ValueCopier.h\""\n #include \""platform/v8_inspector/public/V8InspectorClient.h\""\n \n namespace v8_inspector {\n@@ -581,25 +582,24 @@ v8::Local<v8::Context> V8Debugger::debuggerContext() const\n     return m_debuggerContext.Get(m_isolate);\n }\n \n-v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)\n+v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));\n     }\n     v8::Local<v8::Value> argv[] = { function };\n     v8::Local<v8::Value> scopesValue;\n-    if (!callDebuggerMethod(\""getFunctionScopes\"", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())\n+    if (!callDebuggerMethod(\""getFunctionScopes\"", 1, argv).ToLocal(&scopesValue))\n         return v8::MaybeLocal<v8::Value>();\n-    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::MaybeLocal<v8::Value>();\n-    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))\n+    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))\n         return v8::MaybeLocal<v8::Value>();\n-    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n-        return v8::Undefined(m_isolate);\n-    return scopes;\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))\n+        return v8::MaybeLocal<v8::Value>();\n+    return copied;\n }\n \n v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)\n@@ -629,7 +629,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>\n         }\n     }\n     if (value->IsGeneratorObject()) {\n-        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));\n+        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));\n         if (location->IsObject()) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \""[[GeneratorLocation]]\""));\n             properties->Set(properties->Length(), location);\n@@ -639,7 +639,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>\n         v8::Local<v8::Function> function = value.As<v8::Function>();\n         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();\n         v8::Local<v8::Value> scopes;\n-        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {\n+        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \""[[Scopes]]\""));\n             properties->Set(properties->Length(), scopes);\n         }\n@@ -655,30 +655,28 @@ v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> contex\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> entriesValue = callDebuggerMethod(\""getCollectionEntries\"", 1, argv).ToLocalChecked();\n-    if (!entriesValue->IsArray())\n-        return v8::Undefined(m_isolate);\n-    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();\n-    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::Undefined(m_isolate);\n-    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))\n         return v8::Undefined(m_isolate);\n-    return entries;\n+    return copied;\n }\n \n-v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)\n+v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Null(m_isolate);\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> location = callDebuggerMethod(\""getGeneratorObjectLocation\"", 1, argv).ToLocalChecked();\n-    if (!location->IsObject())\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())\n         return v8::Null(m_isolate);\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))\n+    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))\n         return v8::Null(m_isolate);\n-    return location;\n+    return copied;\n }\n \n v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n@@ -691,6 +689,8 @@ v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context\n     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)\n         return v8::Null(m_isolate);\n     v8::Local<v8::Object> location = v8::Object::New(m_isolate);\n+    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+        return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \""scriptId\""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))\n         return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \""lineNumber\""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))""}<_**next**_>{""sha"": ""02e762eb01c420f407ca4476c9c6bc642d12521b"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -76,7 +76,6 @@ class V8Debugger {\n     std::unique_ptr<V8StackTraceImpl> createStackTrace(v8::Local<v8::StackTrace>);\n     std::unique_ptr<V8StackTraceImpl> captureStackTrace(bool fullStack);\n \n-    v8::MaybeLocal<v8::Value> functionScopes(v8::Local<v8::Function>);\n     v8::MaybeLocal<v8::Array> internalProperties(v8::Local<v8::Context>, v8::Local<v8::Value>);\n \n     void asyncTaskScheduled(const String16& taskName, void* task, bool recurring);\n@@ -102,8 +101,9 @@ class V8Debugger {\n     void handleV8AsyncTaskEvent(v8::Local<v8::Context>, v8::Local<v8::Object> executionState, v8::Local<v8::Object> eventData);\n \n     v8::Local<v8::Value> collectionEntries(v8::Local<v8::Context>, v8::Local<v8::Object>);\n-    v8::Local<v8::Value> generatorObjectLocation(v8::Local<v8::Object>);\n+    v8::Local<v8::Value> generatorObjectLocation(v8::Local<v8::Context>, v8::Local<v8::Object>);\n     v8::Local<v8::Value> functionLocation(v8::Local<v8::Context>, v8::Local<v8::Function>);\n+    v8::MaybeLocal<v8::Value> functionScopes(v8::Local<v8::Context>, v8::Local<v8::Function>);\n \n     v8::Isolate* m_isolate;\n     V8InspectorImpl* m_inspector;""}<_**next**_>{""sha"": ""782e5bbab014739c75726871ec7dc193b38f4843"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -42,6 +42,8 @@ v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> contex\n {\n     v8::Isolate* isolate = inspector->isolate();\n     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);\n+    bool success = injectedScriptHost->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);\n     setFunctionProperty(context, injectedScriptHost, \""internalConstructorName\"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);\n     setFunctionProperty(context, injectedScriptHost, \""formatAccessorsAsProperties\"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);""}<_**next**_>{""sha"": ""3347abeba5929aa7c15fa3c05afc4c3072a8232c"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""status"": ""added"", ""additions"": 90, ""deletions"": 0, ""changes"": 90, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -0,0 +1,90 @@\n+// Copyright 2016 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""platform/v8_inspector/V8ValueCopier.h\""\n+\n+namespace v8_inspector {\n+\n+namespace {\n+\n+static int kMaxDepth = 20;\n+static int kMaxCalls = 1000;\n+\n+class V8ValueCopier {\n+public:\n+    v8::MaybeLocal<v8::Value> copy(v8::Local<v8::Value> value, int depth)\n+    {\n+        if (++m_calls > kMaxCalls || depth > kMaxDepth)\n+            return v8::MaybeLocal<v8::Value>();\n+\n+        if (value.IsEmpty())\n+            return v8::MaybeLocal<v8::Value>();\n+        if (value->IsNull() || value->IsUndefined() || value->IsBoolean() || value->IsString() || value->IsNumber())\n+            return value;\n+        if (!value->IsObject())\n+            return v8::MaybeLocal<v8::Value>();\n+        v8::Local<v8::Object> object = value.As<v8::Object>();\n+        if (object->CreationContext() != m_from)\n+            return value;\n+\n+        if (object->IsArray()) {\n+            v8::Local<v8::Array> array = object.As<v8::Array>();\n+            v8::Local<v8::Array> result = v8::Array::New(m_isolate, array->Length());\n+            if (!result->SetPrototype(m_to, v8::Null(m_isolate)).FromMaybe(false))\n+                return v8::MaybeLocal<v8::Value>();\n+            for (size_t i = 0; i < array->Length(); ++i) {\n+                v8::Local<v8::Value> item;\n+                if (!array->Get(m_from, i).ToLocal(&item))\n+                    return v8::MaybeLocal<v8::Value>();\n+                v8::Local<v8::Value> copied;\n+                if (!copy(item, depth + 1).ToLocal(&copied))\n+                    return v8::MaybeLocal<v8::Value>();\n+                if (!result->Set(m_to, i, copied).FromMaybe(false))\n+                    return v8::MaybeLocal<v8::Value>();\n+            }\n+            return result;\n+        }\n+\n+\n+        v8::Local<v8::Object> result = v8::Object::New(m_isolate);\n+        if (!result->SetPrototype(m_to, v8::Null(m_isolate)).FromMaybe(false))\n+            return v8::MaybeLocal<v8::Value>();\n+        v8::Local<v8::Array> properties;\n+        if (!object->GetOwnPropertyNames(m_from).ToLocal(&properties))\n+            return v8::MaybeLocal<v8::Value>();\n+        for (size_t i = 0; i < properties->Length(); ++i) {\n+            v8::Local<v8::Value> name;\n+            if (!properties->Get(m_from, i).ToLocal(&name) || !name->IsString())\n+                return v8::MaybeLocal<v8::Value>();\n+            v8::Local<v8::Value> property;\n+            if (!object->Get(m_from, name).ToLocal(&property))\n+                return v8::MaybeLocal<v8::Value>();\n+            v8::Local<v8::Value> copied;\n+            if (!copy(property, depth + 1).ToLocal(&copied))\n+                return v8::MaybeLocal<v8::Value>();\n+            if (!result->Set(m_to, name, copied).FromMaybe(false))\n+                return v8::MaybeLocal<v8::Value>();\n+        }\n+        return result;\n+    }\n+\n+    v8::Isolate* m_isolate;\n+    v8::Local<v8::Context> m_from;\n+    v8::Local<v8::Context> m_to;\n+    int m_calls;\n+};\n+\n+} // namespace\n+\n+v8::MaybeLocal<v8::Value> copyValueFromDebuggerContext(v8::Isolate* isolate, v8::Local<v8::Context> debuggerContext, v8::Local<v8::Context> toContext, v8::Local<v8::Value> value)\n+{\n+    V8ValueCopier copier;\n+    copier.m_isolate = isolate;\n+    copier.m_from = debuggerContext;\n+    copier.m_to = toContext;\n+    copier.m_calls = 0;\n+    return copier.copy(value, 0);\n+}\n+\n+} // namespace v8_inspector""}<_**next**_>{""sha"": ""9cd650cc80168bb4f8379cb44dd6000881deeab7"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -0,0 +1,16 @@\n+// Copyright 2016 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef V8ValueCopier_h\n+#define V8ValueCopier_h\n+\n+#include <v8.h>\n+\n+namespace v8_inspector {\n+\n+v8::MaybeLocal<v8::Value> copyValueFromDebuggerContext(v8::Isolate*, v8::Local<v8::Context> debuggerContext, v8::Local<v8::Context> toContext, v8::Local<v8::Value>);\n+\n+} // namespace v8_inspector\n+\n+#endif // !defined(V8ValueCopier_h)""}<_**next**_>{""sha"": ""3c496be8f6252b226fcca829b1d00b39422dc14b"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -294,6 +294,8 @@\n         'V8StackTraceImpl.h',\n         'V8StringUtil.cpp',\n         'V8StringUtil.h',\n+        'V8ValueCopier.cpp',\n+        'V8ValueCopier.h',\n         'public/V8EventListenerInfo.h',\n         'public/V8ContextInfo.h',\n         'public/V8Inspector.h',""}","v8::Local<v8::Object> V8Console::createCommandLineAPI(InspectedContext* inspectedContext)
{
    v8::Local<v8::Context> context = inspectedContext->context();
    v8::Isolate* isolate = context->GetIsolate();
     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);
 
     v8::Local<v8::Object> commandLineAPI = v8::Object::New(isolate);
    bool success = commandLineAPI->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);
    DCHECK(success);
 
     createBoundFunctionProperty(context, commandLineAPI, ""dir"", V8Console::dirCallback, ""function dir(value) { [Command Line API] }"");
     createBoundFunctionProperty(context, commandLineAPI, ""dirxml"", V8Console::dirxmlCallback, ""function dirxml(value) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""profile"", V8Console::profileCallback, ""function profile(title) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""profileEnd"", V8Console::profileEndCallback, ""function profileEnd(title) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""clear"", V8Console::clearCallback, ""function clear() { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""table"", V8Console::tableCallback, ""function table(data, [columns]) { [Command Line API] }"");

    createBoundFunctionProperty(context, commandLineAPI, ""keys"", V8Console::keysCallback, ""function keys(object) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""values"", V8Console::valuesCallback, ""function values(object) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""debug"", V8Console::debugFunctionCallback, ""function debug(function) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""undebug"", V8Console::undebugFunctionCallback, ""function undebug(function) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""monitor"", V8Console::monitorFunctionCallback, ""function monitor(function) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""unmonitor"", V8Console::unmonitorFunctionCallback, ""function unmonitor(function) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""inspect"", V8Console::inspectCallback, ""function inspect(object) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""copy"", V8Console::copyCallback, ""function copy(value) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""$_"", V8Console::lastEvaluationResultCallback);
    createBoundFunctionProperty(context, commandLineAPI, ""$0"", V8Console::inspectedObject0);
    createBoundFunctionProperty(context, commandLineAPI, ""$1"", V8Console::inspectedObject1);
    createBoundFunctionProperty(context, commandLineAPI, ""$2"", V8Console::inspectedObject2);
    createBoundFunctionProperty(context, commandLineAPI, ""$3"", V8Console::inspectedObject3);
    createBoundFunctionProperty(context, commandLineAPI, ""$4"", V8Console::inspectedObject4);

    inspectedContext->inspector()->client()->installAdditionalCommandLineAPI(context, commandLineAPI);

    commandLineAPI->SetPrivate(context, inspectedContextPrivateKey(isolate), v8::External::New(isolate, inspectedContext));
    return commandLineAPI;
}
","v8::Local<v8::Object> V8Console::createCommandLineAPI(InspectedContext* inspectedContext)
{
    v8::Local<v8::Context> context = inspectedContext->context();
    v8::Isolate* isolate = context->GetIsolate();
     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);
 
     v8::Local<v8::Object> commandLineAPI = v8::Object::New(isolate);
 
     createBoundFunctionProperty(context, commandLineAPI, ""dir"", V8Console::dirCallback, ""function dir(value) { [Command Line API] }"");
     createBoundFunctionProperty(context, commandLineAPI, ""dirxml"", V8Console::dirxmlCallback, ""function dirxml(value) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""profile"", V8Console::profileCallback, ""function profile(title) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""profileEnd"", V8Console::profileEndCallback, ""function profileEnd(title) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""clear"", V8Console::clearCallback, ""function clear() { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""table"", V8Console::tableCallback, ""function table(data, [columns]) { [Command Line API] }"");

    createBoundFunctionProperty(context, commandLineAPI, ""keys"", V8Console::keysCallback, ""function keys(object) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""values"", V8Console::valuesCallback, ""function values(object) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""debug"", V8Console::debugFunctionCallback, ""function debug(function) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""undebug"", V8Console::undebugFunctionCallback, ""function undebug(function) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""monitor"", V8Console::monitorFunctionCallback, ""function monitor(function) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""unmonitor"", V8Console::unmonitorFunctionCallback, ""function unmonitor(function) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""inspect"", V8Console::inspectCallback, ""function inspect(object) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""copy"", V8Console::copyCallback, ""function copy(value) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""$_"", V8Console::lastEvaluationResultCallback);
    createBoundFunctionProperty(context, commandLineAPI, ""$0"", V8Console::inspectedObject0);
    createBoundFunctionProperty(context, commandLineAPI, ""$1"", V8Console::inspectedObject1);
    createBoundFunctionProperty(context, commandLineAPI, ""$2"", V8Console::inspectedObject2);
    createBoundFunctionProperty(context, commandLineAPI, ""$3"", V8Console::inspectedObject3);
    createBoundFunctionProperty(context, commandLineAPI, ""$4"", V8Console::inspectedObject4);

    inspectedContext->inspector()->client()->installAdditionalCommandLineAPI(context, commandLineAPI);

    commandLineAPI->SetPrivate(context, inspectedContextPrivateKey(isolate), v8::External::New(isolate, inspectedContext));
    return commandLineAPI;
}
",C,"    bool success = commandLineAPI->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);
    DCHECK(success);
",,,"@@ -659,6 +659,8 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex
     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);
 
     v8::Local<v8::Object> console = v8::Object::New(isolate);
+    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);
+    DCHECK(success);
 
     createBoundFunctionProperty(context, console, ""debug"", V8Console::debugCallback);
     createBoundFunctionProperty(context, console, ""error"", V8Console::errorCallback);
@@ -684,9 +686,6 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex
     createBoundFunctionProperty(context, console, ""timeEnd"", V8Console::timeEndCallback);
     createBoundFunctionProperty(context, console, ""timeStamp"", V8Console::timeStampCallback);
 
-    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);
-    DCHECK(success);
-
     if (hasMemoryAttribute)
         console->SetAccessorProperty(toV8StringInternalized(isolate, ""memory""), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);
 
@@ -707,6 +706,8 @@ v8::Local<v8::Object> V8Console::createCommandLineAPI(InspectedContext* inspecte
     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);
 
     v8::Local<v8::Object> commandLineAPI = v8::Object::New(isolate);
+    bool success = commandLineAPI->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);
+    DCHECK(success);
 
     createBoundFunctionProperty(context, commandLineAPI, ""dir"", V8Console::dirCallback, ""function dir(value) { [Command Line API] }"");
     createBoundFunctionProperty(context, commandLineAPI, ""dirxml"", V8Console::dirxmlCallback, ""function dirxml(value) { [Command Line API] }"");",Chrome,93bc623489bdcfc7e9127614fcfb3258edf3f0f9,04c479295e7c67a27ea4a51a5d58436f44542f58,1,"v8::Local<v8::Object> V8Console::createCommandLineAPI(InspectedContext* inspectedContext)
{
    v8::Local<v8::Context> context = inspectedContext->context();
    v8::Isolate* isolate = context->GetIsolate();
     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);
 
     v8::Local<v8::Object> commandLineAPI = v8::Object::New(isolate);
//fix_flaw_line_below:
//    bool success = commandLineAPI->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);
//fix_flaw_line_below:
//    DCHECK(success);
 
     createBoundFunctionProperty(context, commandLineAPI, ""dir"", V8Console::dirCallback, ""function dir(value) { [Command Line API] }"");
     createBoundFunctionProperty(context, commandLineAPI, ""dirxml"", V8Console::dirxmlCallback, ""function dirxml(value) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""profile"", V8Console::profileCallback, ""function profile(title) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""profileEnd"", V8Console::profileEndCallback, ""function profileEnd(title) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""clear"", V8Console::clearCallback, ""function clear() { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""table"", V8Console::tableCallback, ""function table(data, [columns]) { [Command Line API] }"");

    createBoundFunctionProperty(context, commandLineAPI, ""keys"", V8Console::keysCallback, ""function keys(object) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""values"", V8Console::valuesCallback, ""function values(object) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""debug"", V8Console::debugFunctionCallback, ""function debug(function) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""undebug"", V8Console::undebugFunctionCallback, ""function undebug(function) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""monitor"", V8Console::monitorFunctionCallback, ""function monitor(function) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""unmonitor"", V8Console::unmonitorFunctionCallback, ""function unmonitor(function) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""inspect"", V8Console::inspectCallback, ""function inspect(object) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""copy"", V8Console::copyCallback, ""function copy(value) { [Command Line API] }"");
    createBoundFunctionProperty(context, commandLineAPI, ""$_"", V8Console::lastEvaluationResultCallback);
    createBoundFunctionProperty(context, commandLineAPI, ""$0"", V8Console::inspectedObject0);
    createBoundFunctionProperty(context, commandLineAPI, ""$1"", V8Console::inspectedObject1);
    createBoundFunctionProperty(context, commandLineAPI, ""$2"", V8Console::inspectedObject2);
    createBoundFunctionProperty(context, commandLineAPI, ""$3"", V8Console::inspectedObject3);
    createBoundFunctionProperty(context, commandLineAPI, ""$4"", V8Console::inspectedObject4);

    inspectedContext->inspector()->client()->installAdditionalCommandLineAPI(context, commandLineAPI);

    commandLineAPI->SetPrivate(context, inspectedContextPrivateKey(isolate), v8::External::New(isolate, inspectedContext));
    return commandLineAPI;
}
"
8240,185976,,Remote,Not required,,CVE-2016-5164,https://www.cvedetails.com/cve/CVE-2016-5164/,CWE-79,Medium,,Partial,,2016-09-11,4.3,"Cross-site scripting (XSS) vulnerability in WebKit/Source/platform/v8_inspector/V8Debugger.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to inject arbitrary web script or HTML into the Developer Tools (aka DevTools) subsystem via a crafted web site, aka *Universal XSS (UXSS).*",2018-10-30,XSS ,2,https://github.com/chromium/chromium/commit/93bc623489bdcfc7e9127614fcfb3258edf3f0f9,93bc623489bdcfc7e9127614fcfb3258edf3f0f9,"[DevTools] Copy objects from debugger context to inspected context properly.

BUG=637594

Review-Url: https://codereview.chromium.org/2253643002
Cr-Commit-Position: refs/heads/master@{#412436}",2,third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp,"{""sha"": ""2c2187b08bb5c2340fde0bae42f64e30e2d45ef8"", ""filename"": ""third_party/WebKit/Source/platform/blink_platform.gypi"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/blink_platform.gypi"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/blink_platform.gypi"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/blink_platform.gypi?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -1176,6 +1176,8 @@\n       'v8_inspector/V8StackTraceImpl.h',\n       'v8_inspector/V8StringUtil.cpp',\n       'v8_inspector/V8StringUtil.h',\n+      'v8_inspector/V8ValueCopier.cpp',\n+      'v8_inspector/V8ValueCopier.h',\n       'v8_inspector/public/V8ContextInfo.h',\n       'v8_inspector/public/V8Inspector.h',\n       'v8_inspector/public/V8InspectorClient.h',""}<_**next**_>{""sha"": ""73a90e225e11aeac62626e36a217ceaa5b2ecf51"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -659,6 +659,8 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> console = v8::Object::New(isolate);\n+    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, console, \""debug\"", V8Console::debugCallback);\n     createBoundFunctionProperty(context, console, \""error\"", V8Console::errorCallback);\n@@ -684,9 +686,6 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex\n     createBoundFunctionProperty(context, console, \""timeEnd\"", V8Console::timeEndCallback);\n     createBoundFunctionProperty(context, console, \""timeStamp\"", V8Console::timeStampCallback);\n \n-    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n-    DCHECK(success);\n-\n     if (hasMemoryAttribute)\n         console->SetAccessorProperty(toV8StringInternalized(isolate, \""memory\""), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);\n \n@@ -707,6 +706,8 @@ v8::Local<v8::Object> V8Console::createCommandLineAPI(InspectedContext* inspecte\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> commandLineAPI = v8::Object::New(isolate);\n+    bool success = commandLineAPI->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, commandLineAPI, \""dir\"", V8Console::dirCallback, \""function dir(value) { [Command Line API] }\"");\n     createBoundFunctionProperty(context, commandLineAPI, \""dirxml\"", V8Console::dirxmlCallback, \""function dirxml(value) { [Command Line API] }\"");""}<_**next**_>{""sha"": ""616bfbe7e474266857090c3ac0f420a9467afbdb"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 22, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -12,6 +12,7 @@\n #include \""platform/v8_inspector/V8InternalValueType.h\""\n #include \""platform/v8_inspector/V8StackTraceImpl.h\""\n #include \""platform/v8_inspector/V8StringUtil.h\""\n+#include \""platform/v8_inspector/V8ValueCopier.h\""\n #include \""platform/v8_inspector/public/V8InspectorClient.h\""\n \n namespace v8_inspector {\n@@ -581,25 +582,24 @@ v8::Local<v8::Context> V8Debugger::debuggerContext() const\n     return m_debuggerContext.Get(m_isolate);\n }\n \n-v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)\n+v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));\n     }\n     v8::Local<v8::Value> argv[] = { function };\n     v8::Local<v8::Value> scopesValue;\n-    if (!callDebuggerMethod(\""getFunctionScopes\"", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())\n+    if (!callDebuggerMethod(\""getFunctionScopes\"", 1, argv).ToLocal(&scopesValue))\n         return v8::MaybeLocal<v8::Value>();\n-    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::MaybeLocal<v8::Value>();\n-    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))\n+    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))\n         return v8::MaybeLocal<v8::Value>();\n-    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n-        return v8::Undefined(m_isolate);\n-    return scopes;\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))\n+        return v8::MaybeLocal<v8::Value>();\n+    return copied;\n }\n \n v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)\n@@ -629,7 +629,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>\n         }\n     }\n     if (value->IsGeneratorObject()) {\n-        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));\n+        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));\n         if (location->IsObject()) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \""[[GeneratorLocation]]\""));\n             properties->Set(properties->Length(), location);\n@@ -639,7 +639,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>\n         v8::Local<v8::Function> function = value.As<v8::Function>();\n         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();\n         v8::Local<v8::Value> scopes;\n-        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {\n+        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \""[[Scopes]]\""));\n             properties->Set(properties->Length(), scopes);\n         }\n@@ -655,30 +655,28 @@ v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> contex\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> entriesValue = callDebuggerMethod(\""getCollectionEntries\"", 1, argv).ToLocalChecked();\n-    if (!entriesValue->IsArray())\n-        return v8::Undefined(m_isolate);\n-    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();\n-    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::Undefined(m_isolate);\n-    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))\n         return v8::Undefined(m_isolate);\n-    return entries;\n+    return copied;\n }\n \n-v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)\n+v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Null(m_isolate);\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> location = callDebuggerMethod(\""getGeneratorObjectLocation\"", 1, argv).ToLocalChecked();\n-    if (!location->IsObject())\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())\n         return v8::Null(m_isolate);\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))\n+    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))\n         return v8::Null(m_isolate);\n-    return location;\n+    return copied;\n }\n \n v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n@@ -691,6 +689,8 @@ v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context\n     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)\n         return v8::Null(m_isolate);\n     v8::Local<v8::Object> location = v8::Object::New(m_isolate);\n+    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+        return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \""scriptId\""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))\n         return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \""lineNumber\""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))""}<_**next**_>{""sha"": ""02e762eb01c420f407ca4476c9c6bc642d12521b"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -76,7 +76,6 @@ class V8Debugger {\n     std::unique_ptr<V8StackTraceImpl> createStackTrace(v8::Local<v8::StackTrace>);\n     std::unique_ptr<V8StackTraceImpl> captureStackTrace(bool fullStack);\n \n-    v8::MaybeLocal<v8::Value> functionScopes(v8::Local<v8::Function>);\n     v8::MaybeLocal<v8::Array> internalProperties(v8::Local<v8::Context>, v8::Local<v8::Value>);\n \n     void asyncTaskScheduled(const String16& taskName, void* task, bool recurring);\n@@ -102,8 +101,9 @@ class V8Debugger {\n     void handleV8AsyncTaskEvent(v8::Local<v8::Context>, v8::Local<v8::Object> executionState, v8::Local<v8::Object> eventData);\n \n     v8::Local<v8::Value> collectionEntries(v8::Local<v8::Context>, v8::Local<v8::Object>);\n-    v8::Local<v8::Value> generatorObjectLocation(v8::Local<v8::Object>);\n+    v8::Local<v8::Value> generatorObjectLocation(v8::Local<v8::Context>, v8::Local<v8::Object>);\n     v8::Local<v8::Value> functionLocation(v8::Local<v8::Context>, v8::Local<v8::Function>);\n+    v8::MaybeLocal<v8::Value> functionScopes(v8::Local<v8::Context>, v8::Local<v8::Function>);\n \n     v8::Isolate* m_isolate;\n     V8InspectorImpl* m_inspector;""}<_**next**_>{""sha"": ""782e5bbab014739c75726871ec7dc193b38f4843"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -42,6 +42,8 @@ v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> contex\n {\n     v8::Isolate* isolate = inspector->isolate();\n     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);\n+    bool success = injectedScriptHost->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);\n     setFunctionProperty(context, injectedScriptHost, \""internalConstructorName\"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);\n     setFunctionProperty(context, injectedScriptHost, \""formatAccessorsAsProperties\"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);""}<_**next**_>{""sha"": ""3347abeba5929aa7c15fa3c05afc4c3072a8232c"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""status"": ""added"", ""additions"": 90, ""deletions"": 0, ""changes"": 90, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -0,0 +1,90 @@\n+// Copyright 2016 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""platform/v8_inspector/V8ValueCopier.h\""\n+\n+namespace v8_inspector {\n+\n+namespace {\n+\n+static int kMaxDepth = 20;\n+static int kMaxCalls = 1000;\n+\n+class V8ValueCopier {\n+public:\n+    v8::MaybeLocal<v8::Value> copy(v8::Local<v8::Value> value, int depth)\n+    {\n+        if (++m_calls > kMaxCalls || depth > kMaxDepth)\n+            return v8::MaybeLocal<v8::Value>();\n+\n+        if (value.IsEmpty())\n+            return v8::MaybeLocal<v8::Value>();\n+        if (value->IsNull() || value->IsUndefined() || value->IsBoolean() || value->IsString() || value->IsNumber())\n+            return value;\n+        if (!value->IsObject())\n+            return v8::MaybeLocal<v8::Value>();\n+        v8::Local<v8::Object> object = value.As<v8::Object>();\n+        if (object->CreationContext() != m_from)\n+            return value;\n+\n+        if (object->IsArray()) {\n+            v8::Local<v8::Array> array = object.As<v8::Array>();\n+            v8::Local<v8::Array> result = v8::Array::New(m_isolate, array->Length());\n+            if (!result->SetPrototype(m_to, v8::Null(m_isolate)).FromMaybe(false))\n+                return v8::MaybeLocal<v8::Value>();\n+            for (size_t i = 0; i < array->Length(); ++i) {\n+                v8::Local<v8::Value> item;\n+                if (!array->Get(m_from, i).ToLocal(&item))\n+                    return v8::MaybeLocal<v8::Value>();\n+                v8::Local<v8::Value> copied;\n+                if (!copy(item, depth + 1).ToLocal(&copied))\n+                    return v8::MaybeLocal<v8::Value>();\n+                if (!result->Set(m_to, i, copied).FromMaybe(false))\n+                    return v8::MaybeLocal<v8::Value>();\n+            }\n+            return result;\n+        }\n+\n+\n+        v8::Local<v8::Object> result = v8::Object::New(m_isolate);\n+        if (!result->SetPrototype(m_to, v8::Null(m_isolate)).FromMaybe(false))\n+            return v8::MaybeLocal<v8::Value>();\n+        v8::Local<v8::Array> properties;\n+        if (!object->GetOwnPropertyNames(m_from).ToLocal(&properties))\n+            return v8::MaybeLocal<v8::Value>();\n+        for (size_t i = 0; i < properties->Length(); ++i) {\n+            v8::Local<v8::Value> name;\n+            if (!properties->Get(m_from, i).ToLocal(&name) || !name->IsString())\n+                return v8::MaybeLocal<v8::Value>();\n+            v8::Local<v8::Value> property;\n+            if (!object->Get(m_from, name).ToLocal(&property))\n+                return v8::MaybeLocal<v8::Value>();\n+            v8::Local<v8::Value> copied;\n+            if (!copy(property, depth + 1).ToLocal(&copied))\n+                return v8::MaybeLocal<v8::Value>();\n+            if (!result->Set(m_to, name, copied).FromMaybe(false))\n+                return v8::MaybeLocal<v8::Value>();\n+        }\n+        return result;\n+    }\n+\n+    v8::Isolate* m_isolate;\n+    v8::Local<v8::Context> m_from;\n+    v8::Local<v8::Context> m_to;\n+    int m_calls;\n+};\n+\n+} // namespace\n+\n+v8::MaybeLocal<v8::Value> copyValueFromDebuggerContext(v8::Isolate* isolate, v8::Local<v8::Context> debuggerContext, v8::Local<v8::Context> toContext, v8::Local<v8::Value> value)\n+{\n+    V8ValueCopier copier;\n+    copier.m_isolate = isolate;\n+    copier.m_from = debuggerContext;\n+    copier.m_to = toContext;\n+    copier.m_calls = 0;\n+    return copier.copy(value, 0);\n+}\n+\n+} // namespace v8_inspector""}<_**next**_>{""sha"": ""9cd650cc80168bb4f8379cb44dd6000881deeab7"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -0,0 +1,16 @@\n+// Copyright 2016 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef V8ValueCopier_h\n+#define V8ValueCopier_h\n+\n+#include <v8.h>\n+\n+namespace v8_inspector {\n+\n+v8::MaybeLocal<v8::Value> copyValueFromDebuggerContext(v8::Isolate*, v8::Local<v8::Context> debuggerContext, v8::Local<v8::Context> toContext, v8::Local<v8::Value>);\n+\n+} // namespace v8_inspector\n+\n+#endif // !defined(V8ValueCopier_h)""}<_**next**_>{""sha"": ""3c496be8f6252b226fcca829b1d00b39422dc14b"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -294,6 +294,8 @@\n         'V8StackTraceImpl.h',\n         'V8StringUtil.cpp',\n         'V8StringUtil.h',\n+        'V8ValueCopier.cpp',\n+        'V8ValueCopier.h',\n         'public/V8EventListenerInfo.h',\n         'public/V8ContextInfo.h',\n         'public/V8Inspector.h',""}","v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContext, bool hasMemoryAttribute)
{
    v8::Local<v8::Context> context = inspectedContext->context();
    v8::Context::Scope contextScope(context);
    v8::Isolate* isolate = context->GetIsolate();
     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);
 
     v8::Local<v8::Object> console = v8::Object::New(isolate);
    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);
    DCHECK(success);
 
     createBoundFunctionProperty(context, console, ""debug"", V8Console::debugCallback);
     createBoundFunctionProperty(context, console, ""error"", V8Console::errorCallback);
    createBoundFunctionProperty(context, console, ""info"", V8Console::infoCallback);
    createBoundFunctionProperty(context, console, ""log"", V8Console::logCallback);
    createBoundFunctionProperty(context, console, ""warn"", V8Console::warnCallback);
    createBoundFunctionProperty(context, console, ""dir"", V8Console::dirCallback);
    createBoundFunctionProperty(context, console, ""dirxml"", V8Console::dirxmlCallback);
    createBoundFunctionProperty(context, console, ""table"", V8Console::tableCallback);
    createBoundFunctionProperty(context, console, ""trace"", V8Console::traceCallback);
    createBoundFunctionProperty(context, console, ""group"", V8Console::groupCallback);
    createBoundFunctionProperty(context, console, ""groupCollapsed"", V8Console::groupCollapsedCallback);
    createBoundFunctionProperty(context, console, ""groupEnd"", V8Console::groupEndCallback);
    createBoundFunctionProperty(context, console, ""clear"", V8Console::clearCallback);
    createBoundFunctionProperty(context, console, ""count"", V8Console::countCallback);
    createBoundFunctionProperty(context, console, ""assert"", V8Console::assertCallback);
    createBoundFunctionProperty(context, console, ""markTimeline"", V8Console::markTimelineCallback);
    createBoundFunctionProperty(context, console, ""profile"", V8Console::profileCallback);
    createBoundFunctionProperty(context, console, ""profileEnd"", V8Console::profileEndCallback);
    createBoundFunctionProperty(context, console, ""timeline"", V8Console::timelineCallback);
    createBoundFunctionProperty(context, console, ""timelineEnd"", V8Console::timelineEndCallback);
    createBoundFunctionProperty(context, console, ""time"", V8Console::timeCallback);
     createBoundFunctionProperty(context, console, ""timeEnd"", V8Console::timeEndCallback);
     createBoundFunctionProperty(context, console, ""timeStamp"", V8Console::timeStampCallback);
 
     if (hasMemoryAttribute)
         console->SetAccessorProperty(toV8StringInternalized(isolate, ""memory""), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);
 
    console->SetPrivate(context, inspectedContextPrivateKey(isolate), v8::External::New(isolate, inspectedContext));
    return console;
}
","v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContext, bool hasMemoryAttribute)
{
    v8::Local<v8::Context> context = inspectedContext->context();
    v8::Context::Scope contextScope(context);
    v8::Isolate* isolate = context->GetIsolate();
     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);
 
     v8::Local<v8::Object> console = v8::Object::New(isolate);
 
     createBoundFunctionProperty(context, console, ""debug"", V8Console::debugCallback);
     createBoundFunctionProperty(context, console, ""error"", V8Console::errorCallback);
    createBoundFunctionProperty(context, console, ""info"", V8Console::infoCallback);
    createBoundFunctionProperty(context, console, ""log"", V8Console::logCallback);
    createBoundFunctionProperty(context, console, ""warn"", V8Console::warnCallback);
    createBoundFunctionProperty(context, console, ""dir"", V8Console::dirCallback);
    createBoundFunctionProperty(context, console, ""dirxml"", V8Console::dirxmlCallback);
    createBoundFunctionProperty(context, console, ""table"", V8Console::tableCallback);
    createBoundFunctionProperty(context, console, ""trace"", V8Console::traceCallback);
    createBoundFunctionProperty(context, console, ""group"", V8Console::groupCallback);
    createBoundFunctionProperty(context, console, ""groupCollapsed"", V8Console::groupCollapsedCallback);
    createBoundFunctionProperty(context, console, ""groupEnd"", V8Console::groupEndCallback);
    createBoundFunctionProperty(context, console, ""clear"", V8Console::clearCallback);
    createBoundFunctionProperty(context, console, ""count"", V8Console::countCallback);
    createBoundFunctionProperty(context, console, ""assert"", V8Console::assertCallback);
    createBoundFunctionProperty(context, console, ""markTimeline"", V8Console::markTimelineCallback);
    createBoundFunctionProperty(context, console, ""profile"", V8Console::profileCallback);
    createBoundFunctionProperty(context, console, ""profileEnd"", V8Console::profileEndCallback);
    createBoundFunctionProperty(context, console, ""timeline"", V8Console::timelineCallback);
    createBoundFunctionProperty(context, console, ""timelineEnd"", V8Console::timelineEndCallback);
    createBoundFunctionProperty(context, console, ""time"", V8Console::timeCallback);
     createBoundFunctionProperty(context, console, ""timeEnd"", V8Console::timeEndCallback);
     createBoundFunctionProperty(context, console, ""timeStamp"", V8Console::timeStampCallback);
 
    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);
    DCHECK(success);
     if (hasMemoryAttribute)
         console->SetAccessorProperty(toV8StringInternalized(isolate, ""memory""), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);
 
    console->SetPrivate(context, inspectedContextPrivateKey(isolate), v8::External::New(isolate, inspectedContext));
    return console;
}
",C,"    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);
    DCHECK(success);
","    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);
    DCHECK(success);
",,"@@ -659,6 +659,8 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex
     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);
 
     v8::Local<v8::Object> console = v8::Object::New(isolate);
+    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);
+    DCHECK(success);
 
     createBoundFunctionProperty(context, console, ""debug"", V8Console::debugCallback);
     createBoundFunctionProperty(context, console, ""error"", V8Console::errorCallback);
@@ -684,9 +686,6 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex
     createBoundFunctionProperty(context, console, ""timeEnd"", V8Console::timeEndCallback);
     createBoundFunctionProperty(context, console, ""timeStamp"", V8Console::timeStampCallback);
 
-    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);
-    DCHECK(success);
-
     if (hasMemoryAttribute)
         console->SetAccessorProperty(toV8StringInternalized(isolate, ""memory""), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);
 
@@ -707,6 +706,8 @@ v8::Local<v8::Object> V8Console::createCommandLineAPI(InspectedContext* inspecte
     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);
 
     v8::Local<v8::Object> commandLineAPI = v8::Object::New(isolate);
+    bool success = commandLineAPI->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);
+    DCHECK(success);
 
     createBoundFunctionProperty(context, commandLineAPI, ""dir"", V8Console::dirCallback, ""function dir(value) { [Command Line API] }"");
     createBoundFunctionProperty(context, commandLineAPI, ""dirxml"", V8Console::dirxmlCallback, ""function dirxml(value) { [Command Line API] }"");",Chrome,93bc623489bdcfc7e9127614fcfb3258edf3f0f9,04c479295e7c67a27ea4a51a5d58436f44542f58,1,"v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContext, bool hasMemoryAttribute)
{
    v8::Local<v8::Context> context = inspectedContext->context();
    v8::Context::Scope contextScope(context);
    v8::Isolate* isolate = context->GetIsolate();
     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);
 
     v8::Local<v8::Object> console = v8::Object::New(isolate);
//fix_flaw_line_below:
//    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);
//fix_flaw_line_below:
//    DCHECK(success);
 
     createBoundFunctionProperty(context, console, ""debug"", V8Console::debugCallback);
     createBoundFunctionProperty(context, console, ""error"", V8Console::errorCallback);
    createBoundFunctionProperty(context, console, ""info"", V8Console::infoCallback);
    createBoundFunctionProperty(context, console, ""log"", V8Console::logCallback);
    createBoundFunctionProperty(context, console, ""warn"", V8Console::warnCallback);
    createBoundFunctionProperty(context, console, ""dir"", V8Console::dirCallback);
    createBoundFunctionProperty(context, console, ""dirxml"", V8Console::dirxmlCallback);
    createBoundFunctionProperty(context, console, ""table"", V8Console::tableCallback);
    createBoundFunctionProperty(context, console, ""trace"", V8Console::traceCallback);
    createBoundFunctionProperty(context, console, ""group"", V8Console::groupCallback);
    createBoundFunctionProperty(context, console, ""groupCollapsed"", V8Console::groupCollapsedCallback);
    createBoundFunctionProperty(context, console, ""groupEnd"", V8Console::groupEndCallback);
    createBoundFunctionProperty(context, console, ""clear"", V8Console::clearCallback);
    createBoundFunctionProperty(context, console, ""count"", V8Console::countCallback);
    createBoundFunctionProperty(context, console, ""assert"", V8Console::assertCallback);
    createBoundFunctionProperty(context, console, ""markTimeline"", V8Console::markTimelineCallback);
    createBoundFunctionProperty(context, console, ""profile"", V8Console::profileCallback);
    createBoundFunctionProperty(context, console, ""profileEnd"", V8Console::profileEndCallback);
    createBoundFunctionProperty(context, console, ""timeline"", V8Console::timelineCallback);
    createBoundFunctionProperty(context, console, ""timelineEnd"", V8Console::timelineEndCallback);
    createBoundFunctionProperty(context, console, ""time"", V8Console::timeCallback);
     createBoundFunctionProperty(context, console, ""timeEnd"", V8Console::timeEndCallback);
     createBoundFunctionProperty(context, console, ""timeStamp"", V8Console::timeStampCallback);
 
//flaw_line_below:
    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);
//flaw_line_below:
    DCHECK(success);
//flaw_line_below:

     if (hasMemoryAttribute)
         console->SetAccessorProperty(toV8StringInternalized(isolate, ""memory""), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);
 
    console->SetPrivate(context, inspectedContextPrivateKey(isolate), v8::External::New(isolate, inspectedContext));
    return console;
}
"
8241,185977,,Remote,Not required,,CVE-2016-5164,https://www.cvedetails.com/cve/CVE-2016-5164/,CWE-79,Medium,,Partial,,2016-09-11,4.3,"Cross-site scripting (XSS) vulnerability in WebKit/Source/platform/v8_inspector/V8Debugger.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to inject arbitrary web script or HTML into the Developer Tools (aka DevTools) subsystem via a crafted web site, aka *Universal XSS (UXSS).*",2018-10-30,XSS ,4,https://github.com/chromium/chromium/commit/93bc623489bdcfc7e9127614fcfb3258edf3f0f9,93bc623489bdcfc7e9127614fcfb3258edf3f0f9,"[DevTools] Copy objects from debugger context to inspected context properly.

BUG=637594

Review-Url: https://codereview.chromium.org/2253643002
Cr-Commit-Position: refs/heads/master@{#412436}",6,third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp,"{""sha"": ""2c2187b08bb5c2340fde0bae42f64e30e2d45ef8"", ""filename"": ""third_party/WebKit/Source/platform/blink_platform.gypi"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/blink_platform.gypi"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/blink_platform.gypi"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/blink_platform.gypi?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -1176,6 +1176,8 @@\n       'v8_inspector/V8StackTraceImpl.h',\n       'v8_inspector/V8StringUtil.cpp',\n       'v8_inspector/V8StringUtil.h',\n+      'v8_inspector/V8ValueCopier.cpp',\n+      'v8_inspector/V8ValueCopier.h',\n       'v8_inspector/public/V8ContextInfo.h',\n       'v8_inspector/public/V8Inspector.h',\n       'v8_inspector/public/V8InspectorClient.h',""}<_**next**_>{""sha"": ""73a90e225e11aeac62626e36a217ceaa5b2ecf51"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -659,6 +659,8 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> console = v8::Object::New(isolate);\n+    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, console, \""debug\"", V8Console::debugCallback);\n     createBoundFunctionProperty(context, console, \""error\"", V8Console::errorCallback);\n@@ -684,9 +686,6 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex\n     createBoundFunctionProperty(context, console, \""timeEnd\"", V8Console::timeEndCallback);\n     createBoundFunctionProperty(context, console, \""timeStamp\"", V8Console::timeStampCallback);\n \n-    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n-    DCHECK(success);\n-\n     if (hasMemoryAttribute)\n         console->SetAccessorProperty(toV8StringInternalized(isolate, \""memory\""), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);\n \n@@ -707,6 +706,8 @@ v8::Local<v8::Object> V8Console::createCommandLineAPI(InspectedContext* inspecte\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> commandLineAPI = v8::Object::New(isolate);\n+    bool success = commandLineAPI->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, commandLineAPI, \""dir\"", V8Console::dirCallback, \""function dir(value) { [Command Line API] }\"");\n     createBoundFunctionProperty(context, commandLineAPI, \""dirxml\"", V8Console::dirxmlCallback, \""function dirxml(value) { [Command Line API] }\"");""}<_**next**_>{""sha"": ""616bfbe7e474266857090c3ac0f420a9467afbdb"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 22, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -12,6 +12,7 @@\n #include \""platform/v8_inspector/V8InternalValueType.h\""\n #include \""platform/v8_inspector/V8StackTraceImpl.h\""\n #include \""platform/v8_inspector/V8StringUtil.h\""\n+#include \""platform/v8_inspector/V8ValueCopier.h\""\n #include \""platform/v8_inspector/public/V8InspectorClient.h\""\n \n namespace v8_inspector {\n@@ -581,25 +582,24 @@ v8::Local<v8::Context> V8Debugger::debuggerContext() const\n     return m_debuggerContext.Get(m_isolate);\n }\n \n-v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)\n+v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));\n     }\n     v8::Local<v8::Value> argv[] = { function };\n     v8::Local<v8::Value> scopesValue;\n-    if (!callDebuggerMethod(\""getFunctionScopes\"", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())\n+    if (!callDebuggerMethod(\""getFunctionScopes\"", 1, argv).ToLocal(&scopesValue))\n         return v8::MaybeLocal<v8::Value>();\n-    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::MaybeLocal<v8::Value>();\n-    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))\n+    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))\n         return v8::MaybeLocal<v8::Value>();\n-    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n-        return v8::Undefined(m_isolate);\n-    return scopes;\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))\n+        return v8::MaybeLocal<v8::Value>();\n+    return copied;\n }\n \n v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)\n@@ -629,7 +629,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>\n         }\n     }\n     if (value->IsGeneratorObject()) {\n-        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));\n+        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));\n         if (location->IsObject()) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \""[[GeneratorLocation]]\""));\n             properties->Set(properties->Length(), location);\n@@ -639,7 +639,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>\n         v8::Local<v8::Function> function = value.As<v8::Function>();\n         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();\n         v8::Local<v8::Value> scopes;\n-        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {\n+        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \""[[Scopes]]\""));\n             properties->Set(properties->Length(), scopes);\n         }\n@@ -655,30 +655,28 @@ v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> contex\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> entriesValue = callDebuggerMethod(\""getCollectionEntries\"", 1, argv).ToLocalChecked();\n-    if (!entriesValue->IsArray())\n-        return v8::Undefined(m_isolate);\n-    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();\n-    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::Undefined(m_isolate);\n-    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))\n         return v8::Undefined(m_isolate);\n-    return entries;\n+    return copied;\n }\n \n-v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)\n+v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Null(m_isolate);\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> location = callDebuggerMethod(\""getGeneratorObjectLocation\"", 1, argv).ToLocalChecked();\n-    if (!location->IsObject())\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())\n         return v8::Null(m_isolate);\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))\n+    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))\n         return v8::Null(m_isolate);\n-    return location;\n+    return copied;\n }\n \n v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n@@ -691,6 +689,8 @@ v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context\n     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)\n         return v8::Null(m_isolate);\n     v8::Local<v8::Object> location = v8::Object::New(m_isolate);\n+    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+        return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \""scriptId\""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))\n         return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \""lineNumber\""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))""}<_**next**_>{""sha"": ""02e762eb01c420f407ca4476c9c6bc642d12521b"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -76,7 +76,6 @@ class V8Debugger {\n     std::unique_ptr<V8StackTraceImpl> createStackTrace(v8::Local<v8::StackTrace>);\n     std::unique_ptr<V8StackTraceImpl> captureStackTrace(bool fullStack);\n \n-    v8::MaybeLocal<v8::Value> functionScopes(v8::Local<v8::Function>);\n     v8::MaybeLocal<v8::Array> internalProperties(v8::Local<v8::Context>, v8::Local<v8::Value>);\n \n     void asyncTaskScheduled(const String16& taskName, void* task, bool recurring);\n@@ -102,8 +101,9 @@ class V8Debugger {\n     void handleV8AsyncTaskEvent(v8::Local<v8::Context>, v8::Local<v8::Object> executionState, v8::Local<v8::Object> eventData);\n \n     v8::Local<v8::Value> collectionEntries(v8::Local<v8::Context>, v8::Local<v8::Object>);\n-    v8::Local<v8::Value> generatorObjectLocation(v8::Local<v8::Object>);\n+    v8::Local<v8::Value> generatorObjectLocation(v8::Local<v8::Context>, v8::Local<v8::Object>);\n     v8::Local<v8::Value> functionLocation(v8::Local<v8::Context>, v8::Local<v8::Function>);\n+    v8::MaybeLocal<v8::Value> functionScopes(v8::Local<v8::Context>, v8::Local<v8::Function>);\n \n     v8::Isolate* m_isolate;\n     V8InspectorImpl* m_inspector;""}<_**next**_>{""sha"": ""782e5bbab014739c75726871ec7dc193b38f4843"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -42,6 +42,8 @@ v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> contex\n {\n     v8::Isolate* isolate = inspector->isolate();\n     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);\n+    bool success = injectedScriptHost->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);\n     setFunctionProperty(context, injectedScriptHost, \""internalConstructorName\"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);\n     setFunctionProperty(context, injectedScriptHost, \""formatAccessorsAsProperties\"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);""}<_**next**_>{""sha"": ""3347abeba5929aa7c15fa3c05afc4c3072a8232c"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""status"": ""added"", ""additions"": 90, ""deletions"": 0, ""changes"": 90, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -0,0 +1,90 @@\n+// Copyright 2016 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""platform/v8_inspector/V8ValueCopier.h\""\n+\n+namespace v8_inspector {\n+\n+namespace {\n+\n+static int kMaxDepth = 20;\n+static int kMaxCalls = 1000;\n+\n+class V8ValueCopier {\n+public:\n+    v8::MaybeLocal<v8::Value> copy(v8::Local<v8::Value> value, int depth)\n+    {\n+        if (++m_calls > kMaxCalls || depth > kMaxDepth)\n+            return v8::MaybeLocal<v8::Value>();\n+\n+        if (value.IsEmpty())\n+            return v8::MaybeLocal<v8::Value>();\n+        if (value->IsNull() || value->IsUndefined() || value->IsBoolean() || value->IsString() || value->IsNumber())\n+            return value;\n+        if (!value->IsObject())\n+            return v8::MaybeLocal<v8::Value>();\n+        v8::Local<v8::Object> object = value.As<v8::Object>();\n+        if (object->CreationContext() != m_from)\n+            return value;\n+\n+        if (object->IsArray()) {\n+            v8::Local<v8::Array> array = object.As<v8::Array>();\n+            v8::Local<v8::Array> result = v8::Array::New(m_isolate, array->Length());\n+            if (!result->SetPrototype(m_to, v8::Null(m_isolate)).FromMaybe(false))\n+                return v8::MaybeLocal<v8::Value>();\n+            for (size_t i = 0; i < array->Length(); ++i) {\n+                v8::Local<v8::Value> item;\n+                if (!array->Get(m_from, i).ToLocal(&item))\n+                    return v8::MaybeLocal<v8::Value>();\n+                v8::Local<v8::Value> copied;\n+                if (!copy(item, depth + 1).ToLocal(&copied))\n+                    return v8::MaybeLocal<v8::Value>();\n+                if (!result->Set(m_to, i, copied).FromMaybe(false))\n+                    return v8::MaybeLocal<v8::Value>();\n+            }\n+            return result;\n+        }\n+\n+\n+        v8::Local<v8::Object> result = v8::Object::New(m_isolate);\n+        if (!result->SetPrototype(m_to, v8::Null(m_isolate)).FromMaybe(false))\n+            return v8::MaybeLocal<v8::Value>();\n+        v8::Local<v8::Array> properties;\n+        if (!object->GetOwnPropertyNames(m_from).ToLocal(&properties))\n+            return v8::MaybeLocal<v8::Value>();\n+        for (size_t i = 0; i < properties->Length(); ++i) {\n+            v8::Local<v8::Value> name;\n+            if (!properties->Get(m_from, i).ToLocal(&name) || !name->IsString())\n+                return v8::MaybeLocal<v8::Value>();\n+            v8::Local<v8::Value> property;\n+            if (!object->Get(m_from, name).ToLocal(&property))\n+                return v8::MaybeLocal<v8::Value>();\n+            v8::Local<v8::Value> copied;\n+            if (!copy(property, depth + 1).ToLocal(&copied))\n+                return v8::MaybeLocal<v8::Value>();\n+            if (!result->Set(m_to, name, copied).FromMaybe(false))\n+                return v8::MaybeLocal<v8::Value>();\n+        }\n+        return result;\n+    }\n+\n+    v8::Isolate* m_isolate;\n+    v8::Local<v8::Context> m_from;\n+    v8::Local<v8::Context> m_to;\n+    int m_calls;\n+};\n+\n+} // namespace\n+\n+v8::MaybeLocal<v8::Value> copyValueFromDebuggerContext(v8::Isolate* isolate, v8::Local<v8::Context> debuggerContext, v8::Local<v8::Context> toContext, v8::Local<v8::Value> value)\n+{\n+    V8ValueCopier copier;\n+    copier.m_isolate = isolate;\n+    copier.m_from = debuggerContext;\n+    copier.m_to = toContext;\n+    copier.m_calls = 0;\n+    return copier.copy(value, 0);\n+}\n+\n+} // namespace v8_inspector""}<_**next**_>{""sha"": ""9cd650cc80168bb4f8379cb44dd6000881deeab7"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -0,0 +1,16 @@\n+// Copyright 2016 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef V8ValueCopier_h\n+#define V8ValueCopier_h\n+\n+#include <v8.h>\n+\n+namespace v8_inspector {\n+\n+v8::MaybeLocal<v8::Value> copyValueFromDebuggerContext(v8::Isolate*, v8::Local<v8::Context> debuggerContext, v8::Local<v8::Context> toContext, v8::Local<v8::Value>);\n+\n+} // namespace v8_inspector\n+\n+#endif // !defined(V8ValueCopier_h)""}<_**next**_>{""sha"": ""3c496be8f6252b226fcca829b1d00b39422dc14b"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -294,6 +294,8 @@\n         'V8StackTraceImpl.h',\n         'V8StringUtil.cpp',\n         'V8StringUtil.h',\n+        'V8ValueCopier.cpp',\n+        'V8ValueCopier.h',\n         'public/V8EventListenerInfo.h',\n         'public/V8ContextInfo.h',\n         'public/V8Inspector.h',""}","v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> context, v8::Local<v8::Object> object)
{
    if (!enabled()) {
        NOTREACHED();
        return v8::Undefined(m_isolate);
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> entriesValue = callDebuggerMethod(""getCollectionEntries"", 1, argv).ToLocalChecked();
    v8::Local<v8::Value> copied;
    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())
         return v8::Undefined(m_isolate);
    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))
         return v8::Undefined(m_isolate);
    return copied;
 }
","v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> context, v8::Local<v8::Object> object)
{
    if (!enabled()) {
        NOTREACHED();
        return v8::Undefined(m_isolate);
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> entriesValue = callDebuggerMethod(""getCollectionEntries"", 1, argv).ToLocalChecked();
    if (!entriesValue->IsArray())
        return v8::Undefined(m_isolate);
    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();
    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))
         return v8::Undefined(m_isolate);
    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
         return v8::Undefined(m_isolate);
    return entries;
 }
",C,"    v8::Local<v8::Value> copied;
    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())
    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))
    return copied;
","    if (!entriesValue->IsArray())
        return v8::Undefined(m_isolate);
    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();
    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))
    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
    return entries;
",,"@@ -12,6 +12,7 @@
 #include ""platform/v8_inspector/V8InternalValueType.h""
 #include ""platform/v8_inspector/V8StackTraceImpl.h""
 #include ""platform/v8_inspector/V8StringUtil.h""
+#include ""platform/v8_inspector/V8ValueCopier.h""
 #include ""platform/v8_inspector/public/V8InspectorClient.h""
 
 namespace v8_inspector {
@@ -581,25 +582,24 @@ v8::Local<v8::Context> V8Debugger::debuggerContext() const
     return m_debuggerContext.Get(m_isolate);
 }
 
-v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)
+v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));
     }
     v8::Local<v8::Value> argv[] = { function };
     v8::Local<v8::Value> scopesValue;
-    if (!callDebuggerMethod(""getFunctionScopes"", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())
+    if (!callDebuggerMethod(""getFunctionScopes"", 1, argv).ToLocal(&scopesValue))
         return v8::MaybeLocal<v8::Value>();
-    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();
-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
-    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))
+    v8::Local<v8::Value> copied;
+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())
         return v8::MaybeLocal<v8::Value>();
-    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))
+    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))
         return v8::MaybeLocal<v8::Value>();
-    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
-        return v8::Undefined(m_isolate);
-    return scopes;
+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))
+        return v8::MaybeLocal<v8::Value>();
+    return copied;
 }
 
 v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)
@@ -629,7 +629,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>
         }
     }
     if (value->IsGeneratorObject()) {
-        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));
+        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));
         if (location->IsObject()) {
             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[GeneratorLocation]]""));
             properties->Set(properties->Length(), location);
@@ -639,7 +639,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>
         v8::Local<v8::Function> function = value.As<v8::Function>();
         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();
         v8::Local<v8::Value> scopes;
-        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {
+        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {
             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[Scopes]]""));
             properties->Set(properties->Length(), scopes);
         }
@@ -655,30 +655,28 @@ v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> contex
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> entriesValue = callDebuggerMethod(""getCollectionEntries"", 1, argv).ToLocalChecked();
-    if (!entriesValue->IsArray())
-        return v8::Undefined(m_isolate);
-    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();
-    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))
+    v8::Local<v8::Value> copied;
+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())
         return v8::Undefined(m_isolate);
-    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))
         return v8::Undefined(m_isolate);
-    return entries;
+    return copied;
 }
 
-v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)
+v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Null(m_isolate);
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> location = callDebuggerMethod(""getGeneratorObjectLocation"", 1, argv).ToLocalChecked();
-    if (!location->IsObject())
+    v8::Local<v8::Value> copied;
+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())
         return v8::Null(m_isolate);
-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
-    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))
+    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))
         return v8::Null(m_isolate);
-    return location;
+    return copied;
 }
 
 v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
@@ -691,6 +689,8 @@ v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context
     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)
         return v8::Null(m_isolate);
     v8::Local<v8::Object> location = v8::Object::New(m_isolate);
+    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
+        return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""scriptId""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))
         return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""lineNumber""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))",Chrome,93bc623489bdcfc7e9127614fcfb3258edf3f0f9,04c479295e7c67a27ea4a51a5d58436f44542f58,1,"v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> context, v8::Local<v8::Object> object)
{
    if (!enabled()) {
        NOTREACHED();
        return v8::Undefined(m_isolate);
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> entriesValue = callDebuggerMethod(""getCollectionEntries"", 1, argv).ToLocalChecked();
//flaw_line_below:
    if (!entriesValue->IsArray())
//flaw_line_below:
        return v8::Undefined(m_isolate);
//flaw_line_below:
    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();
//flaw_line_below:
    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))
//fix_flaw_line_below:
//    v8::Local<v8::Value> copied;
//fix_flaw_line_below:
//    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())
         return v8::Undefined(m_isolate);
//flaw_line_below:
    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
//fix_flaw_line_below:
//    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))
         return v8::Undefined(m_isolate);
//flaw_line_below:
    return entries;
//fix_flaw_line_below:
//    return copied;
 }
"
8242,185978,,Remote,Not required,,CVE-2016-5164,https://www.cvedetails.com/cve/CVE-2016-5164/,CWE-79,Medium,,Partial,,2016-09-11,4.3,"Cross-site scripting (XSS) vulnerability in WebKit/Source/platform/v8_inspector/V8Debugger.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to inject arbitrary web script or HTML into the Developer Tools (aka DevTools) subsystem via a crafted web site, aka *Universal XSS (UXSS).*",2018-10-30,XSS ,2,https://github.com/chromium/chromium/commit/93bc623489bdcfc7e9127614fcfb3258edf3f0f9,93bc623489bdcfc7e9127614fcfb3258edf3f0f9,"[DevTools] Copy objects from debugger context to inspected context properly.

BUG=637594

Review-Url: https://codereview.chromium.org/2253643002
Cr-Commit-Position: refs/heads/master@{#412436}",0,third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp,"{""sha"": ""2c2187b08bb5c2340fde0bae42f64e30e2d45ef8"", ""filename"": ""third_party/WebKit/Source/platform/blink_platform.gypi"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/blink_platform.gypi"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/blink_platform.gypi"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/blink_platform.gypi?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -1176,6 +1176,8 @@\n       'v8_inspector/V8StackTraceImpl.h',\n       'v8_inspector/V8StringUtil.cpp',\n       'v8_inspector/V8StringUtil.h',\n+      'v8_inspector/V8ValueCopier.cpp',\n+      'v8_inspector/V8ValueCopier.h',\n       'v8_inspector/public/V8ContextInfo.h',\n       'v8_inspector/public/V8Inspector.h',\n       'v8_inspector/public/V8InspectorClient.h',""}<_**next**_>{""sha"": ""73a90e225e11aeac62626e36a217ceaa5b2ecf51"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -659,6 +659,8 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> console = v8::Object::New(isolate);\n+    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, console, \""debug\"", V8Console::debugCallback);\n     createBoundFunctionProperty(context, console, \""error\"", V8Console::errorCallback);\n@@ -684,9 +686,6 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex\n     createBoundFunctionProperty(context, console, \""timeEnd\"", V8Console::timeEndCallback);\n     createBoundFunctionProperty(context, console, \""timeStamp\"", V8Console::timeStampCallback);\n \n-    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n-    DCHECK(success);\n-\n     if (hasMemoryAttribute)\n         console->SetAccessorProperty(toV8StringInternalized(isolate, \""memory\""), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);\n \n@@ -707,6 +706,8 @@ v8::Local<v8::Object> V8Console::createCommandLineAPI(InspectedContext* inspecte\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> commandLineAPI = v8::Object::New(isolate);\n+    bool success = commandLineAPI->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, commandLineAPI, \""dir\"", V8Console::dirCallback, \""function dir(value) { [Command Line API] }\"");\n     createBoundFunctionProperty(context, commandLineAPI, \""dirxml\"", V8Console::dirxmlCallback, \""function dirxml(value) { [Command Line API] }\"");""}<_**next**_>{""sha"": ""616bfbe7e474266857090c3ac0f420a9467afbdb"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 22, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -12,6 +12,7 @@\n #include \""platform/v8_inspector/V8InternalValueType.h\""\n #include \""platform/v8_inspector/V8StackTraceImpl.h\""\n #include \""platform/v8_inspector/V8StringUtil.h\""\n+#include \""platform/v8_inspector/V8ValueCopier.h\""\n #include \""platform/v8_inspector/public/V8InspectorClient.h\""\n \n namespace v8_inspector {\n@@ -581,25 +582,24 @@ v8::Local<v8::Context> V8Debugger::debuggerContext() const\n     return m_debuggerContext.Get(m_isolate);\n }\n \n-v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)\n+v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));\n     }\n     v8::Local<v8::Value> argv[] = { function };\n     v8::Local<v8::Value> scopesValue;\n-    if (!callDebuggerMethod(\""getFunctionScopes\"", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())\n+    if (!callDebuggerMethod(\""getFunctionScopes\"", 1, argv).ToLocal(&scopesValue))\n         return v8::MaybeLocal<v8::Value>();\n-    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::MaybeLocal<v8::Value>();\n-    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))\n+    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))\n         return v8::MaybeLocal<v8::Value>();\n-    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n-        return v8::Undefined(m_isolate);\n-    return scopes;\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))\n+        return v8::MaybeLocal<v8::Value>();\n+    return copied;\n }\n \n v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)\n@@ -629,7 +629,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>\n         }\n     }\n     if (value->IsGeneratorObject()) {\n-        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));\n+        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));\n         if (location->IsObject()) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \""[[GeneratorLocation]]\""));\n             properties->Set(properties->Length(), location);\n@@ -639,7 +639,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>\n         v8::Local<v8::Function> function = value.As<v8::Function>();\n         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();\n         v8::Local<v8::Value> scopes;\n-        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {\n+        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \""[[Scopes]]\""));\n             properties->Set(properties->Length(), scopes);\n         }\n@@ -655,30 +655,28 @@ v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> contex\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> entriesValue = callDebuggerMethod(\""getCollectionEntries\"", 1, argv).ToLocalChecked();\n-    if (!entriesValue->IsArray())\n-        return v8::Undefined(m_isolate);\n-    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();\n-    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::Undefined(m_isolate);\n-    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))\n         return v8::Undefined(m_isolate);\n-    return entries;\n+    return copied;\n }\n \n-v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)\n+v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Null(m_isolate);\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> location = callDebuggerMethod(\""getGeneratorObjectLocation\"", 1, argv).ToLocalChecked();\n-    if (!location->IsObject())\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())\n         return v8::Null(m_isolate);\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))\n+    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))\n         return v8::Null(m_isolate);\n-    return location;\n+    return copied;\n }\n \n v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n@@ -691,6 +689,8 @@ v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context\n     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)\n         return v8::Null(m_isolate);\n     v8::Local<v8::Object> location = v8::Object::New(m_isolate);\n+    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+        return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \""scriptId\""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))\n         return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \""lineNumber\""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))""}<_**next**_>{""sha"": ""02e762eb01c420f407ca4476c9c6bc642d12521b"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -76,7 +76,6 @@ class V8Debugger {\n     std::unique_ptr<V8StackTraceImpl> createStackTrace(v8::Local<v8::StackTrace>);\n     std::unique_ptr<V8StackTraceImpl> captureStackTrace(bool fullStack);\n \n-    v8::MaybeLocal<v8::Value> functionScopes(v8::Local<v8::Function>);\n     v8::MaybeLocal<v8::Array> internalProperties(v8::Local<v8::Context>, v8::Local<v8::Value>);\n \n     void asyncTaskScheduled(const String16& taskName, void* task, bool recurring);\n@@ -102,8 +101,9 @@ class V8Debugger {\n     void handleV8AsyncTaskEvent(v8::Local<v8::Context>, v8::Local<v8::Object> executionState, v8::Local<v8::Object> eventData);\n \n     v8::Local<v8::Value> collectionEntries(v8::Local<v8::Context>, v8::Local<v8::Object>);\n-    v8::Local<v8::Value> generatorObjectLocation(v8::Local<v8::Object>);\n+    v8::Local<v8::Value> generatorObjectLocation(v8::Local<v8::Context>, v8::Local<v8::Object>);\n     v8::Local<v8::Value> functionLocation(v8::Local<v8::Context>, v8::Local<v8::Function>);\n+    v8::MaybeLocal<v8::Value> functionScopes(v8::Local<v8::Context>, v8::Local<v8::Function>);\n \n     v8::Isolate* m_isolate;\n     V8InspectorImpl* m_inspector;""}<_**next**_>{""sha"": ""782e5bbab014739c75726871ec7dc193b38f4843"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -42,6 +42,8 @@ v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> contex\n {\n     v8::Isolate* isolate = inspector->isolate();\n     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);\n+    bool success = injectedScriptHost->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);\n     setFunctionProperty(context, injectedScriptHost, \""internalConstructorName\"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);\n     setFunctionProperty(context, injectedScriptHost, \""formatAccessorsAsProperties\"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);""}<_**next**_>{""sha"": ""3347abeba5929aa7c15fa3c05afc4c3072a8232c"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""status"": ""added"", ""additions"": 90, ""deletions"": 0, ""changes"": 90, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -0,0 +1,90 @@\n+// Copyright 2016 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""platform/v8_inspector/V8ValueCopier.h\""\n+\n+namespace v8_inspector {\n+\n+namespace {\n+\n+static int kMaxDepth = 20;\n+static int kMaxCalls = 1000;\n+\n+class V8ValueCopier {\n+public:\n+    v8::MaybeLocal<v8::Value> copy(v8::Local<v8::Value> value, int depth)\n+    {\n+        if (++m_calls > kMaxCalls || depth > kMaxDepth)\n+            return v8::MaybeLocal<v8::Value>();\n+\n+        if (value.IsEmpty())\n+            return v8::MaybeLocal<v8::Value>();\n+        if (value->IsNull() || value->IsUndefined() || value->IsBoolean() || value->IsString() || value->IsNumber())\n+            return value;\n+        if (!value->IsObject())\n+            return v8::MaybeLocal<v8::Value>();\n+        v8::Local<v8::Object> object = value.As<v8::Object>();\n+        if (object->CreationContext() != m_from)\n+            return value;\n+\n+        if (object->IsArray()) {\n+            v8::Local<v8::Array> array = object.As<v8::Array>();\n+            v8::Local<v8::Array> result = v8::Array::New(m_isolate, array->Length());\n+            if (!result->SetPrototype(m_to, v8::Null(m_isolate)).FromMaybe(false))\n+                return v8::MaybeLocal<v8::Value>();\n+            for (size_t i = 0; i < array->Length(); ++i) {\n+                v8::Local<v8::Value> item;\n+                if (!array->Get(m_from, i).ToLocal(&item))\n+                    return v8::MaybeLocal<v8::Value>();\n+                v8::Local<v8::Value> copied;\n+                if (!copy(item, depth + 1).ToLocal(&copied))\n+                    return v8::MaybeLocal<v8::Value>();\n+                if (!result->Set(m_to, i, copied).FromMaybe(false))\n+                    return v8::MaybeLocal<v8::Value>();\n+            }\n+            return result;\n+        }\n+\n+\n+        v8::Local<v8::Object> result = v8::Object::New(m_isolate);\n+        if (!result->SetPrototype(m_to, v8::Null(m_isolate)).FromMaybe(false))\n+            return v8::MaybeLocal<v8::Value>();\n+        v8::Local<v8::Array> properties;\n+        if (!object->GetOwnPropertyNames(m_from).ToLocal(&properties))\n+            return v8::MaybeLocal<v8::Value>();\n+        for (size_t i = 0; i < properties->Length(); ++i) {\n+            v8::Local<v8::Value> name;\n+            if (!properties->Get(m_from, i).ToLocal(&name) || !name->IsString())\n+                return v8::MaybeLocal<v8::Value>();\n+            v8::Local<v8::Value> property;\n+            if (!object->Get(m_from, name).ToLocal(&property))\n+                return v8::MaybeLocal<v8::Value>();\n+            v8::Local<v8::Value> copied;\n+            if (!copy(property, depth + 1).ToLocal(&copied))\n+                return v8::MaybeLocal<v8::Value>();\n+            if (!result->Set(m_to, name, copied).FromMaybe(false))\n+                return v8::MaybeLocal<v8::Value>();\n+        }\n+        return result;\n+    }\n+\n+    v8::Isolate* m_isolate;\n+    v8::Local<v8::Context> m_from;\n+    v8::Local<v8::Context> m_to;\n+    int m_calls;\n+};\n+\n+} // namespace\n+\n+v8::MaybeLocal<v8::Value> copyValueFromDebuggerContext(v8::Isolate* isolate, v8::Local<v8::Context> debuggerContext, v8::Local<v8::Context> toContext, v8::Local<v8::Value> value)\n+{\n+    V8ValueCopier copier;\n+    copier.m_isolate = isolate;\n+    copier.m_from = debuggerContext;\n+    copier.m_to = toContext;\n+    copier.m_calls = 0;\n+    return copier.copy(value, 0);\n+}\n+\n+} // namespace v8_inspector""}<_**next**_>{""sha"": ""9cd650cc80168bb4f8379cb44dd6000881deeab7"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -0,0 +1,16 @@\n+// Copyright 2016 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef V8ValueCopier_h\n+#define V8ValueCopier_h\n+\n+#include <v8.h>\n+\n+namespace v8_inspector {\n+\n+v8::MaybeLocal<v8::Value> copyValueFromDebuggerContext(v8::Isolate*, v8::Local<v8::Context> debuggerContext, v8::Local<v8::Context> toContext, v8::Local<v8::Value>);\n+\n+} // namespace v8_inspector\n+\n+#endif // !defined(V8ValueCopier_h)""}<_**next**_>{""sha"": ""3c496be8f6252b226fcca829b1d00b39422dc14b"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -294,6 +294,8 @@\n         'V8StackTraceImpl.h',\n         'V8StringUtil.cpp',\n         'V8StringUtil.h',\n+        'V8ValueCopier.cpp',\n+        'V8ValueCopier.h',\n         'public/V8EventListenerInfo.h',\n         'public/V8ContextInfo.h',\n         'public/V8Inspector.h',""}"," v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
{
    int scriptId = function->ScriptId();
    if (scriptId == v8::UnboundScript::kNoScriptId)
        return v8::Null(m_isolate);
    int lineNumber = function->GetScriptLineNumber();
    int columnNumber = function->GetScriptColumnNumber();
     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)
         return v8::Null(m_isolate);
     v8::Local<v8::Object> location = v8::Object::New(m_isolate);
    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
        return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""scriptId""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))
         return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""lineNumber""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))
        return v8::Null(m_isolate);
    if (!location->Set(context, toV8StringInternalized(m_isolate, ""columnNumber""), v8::Integer::New(m_isolate, columnNumber)).FromMaybe(false))
        return v8::Null(m_isolate);
    if (!markAsInternal(context, location, V8InternalValueType::kLocation))
        return v8::Null(m_isolate);
    return location;
}
"," v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
{
    int scriptId = function->ScriptId();
    if (scriptId == v8::UnboundScript::kNoScriptId)
        return v8::Null(m_isolate);
    int lineNumber = function->GetScriptLineNumber();
    int columnNumber = function->GetScriptColumnNumber();
     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)
         return v8::Null(m_isolate);
     v8::Local<v8::Object> location = v8::Object::New(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""scriptId""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))
         return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""lineNumber""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))
        return v8::Null(m_isolate);
    if (!location->Set(context, toV8StringInternalized(m_isolate, ""columnNumber""), v8::Integer::New(m_isolate, columnNumber)).FromMaybe(false))
        return v8::Null(m_isolate);
    if (!markAsInternal(context, location, V8InternalValueType::kLocation))
        return v8::Null(m_isolate);
    return location;
}
",C,"    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
        return v8::Null(m_isolate);
",,,"@@ -12,6 +12,7 @@
 #include ""platform/v8_inspector/V8InternalValueType.h""
 #include ""platform/v8_inspector/V8StackTraceImpl.h""
 #include ""platform/v8_inspector/V8StringUtil.h""
+#include ""platform/v8_inspector/V8ValueCopier.h""
 #include ""platform/v8_inspector/public/V8InspectorClient.h""
 
 namespace v8_inspector {
@@ -581,25 +582,24 @@ v8::Local<v8::Context> V8Debugger::debuggerContext() const
     return m_debuggerContext.Get(m_isolate);
 }
 
-v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)
+v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));
     }
     v8::Local<v8::Value> argv[] = { function };
     v8::Local<v8::Value> scopesValue;
-    if (!callDebuggerMethod(""getFunctionScopes"", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())
+    if (!callDebuggerMethod(""getFunctionScopes"", 1, argv).ToLocal(&scopesValue))
         return v8::MaybeLocal<v8::Value>();
-    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();
-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
-    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))
+    v8::Local<v8::Value> copied;
+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())
         return v8::MaybeLocal<v8::Value>();
-    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))
+    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))
         return v8::MaybeLocal<v8::Value>();
-    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
-        return v8::Undefined(m_isolate);
-    return scopes;
+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))
+        return v8::MaybeLocal<v8::Value>();
+    return copied;
 }
 
 v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)
@@ -629,7 +629,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>
         }
     }
     if (value->IsGeneratorObject()) {
-        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));
+        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));
         if (location->IsObject()) {
             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[GeneratorLocation]]""));
             properties->Set(properties->Length(), location);
@@ -639,7 +639,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>
         v8::Local<v8::Function> function = value.As<v8::Function>();
         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();
         v8::Local<v8::Value> scopes;
-        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {
+        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {
             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[Scopes]]""));
             properties->Set(properties->Length(), scopes);
         }
@@ -655,30 +655,28 @@ v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> contex
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> entriesValue = callDebuggerMethod(""getCollectionEntries"", 1, argv).ToLocalChecked();
-    if (!entriesValue->IsArray())
-        return v8::Undefined(m_isolate);
-    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();
-    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))
+    v8::Local<v8::Value> copied;
+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())
         return v8::Undefined(m_isolate);
-    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))
         return v8::Undefined(m_isolate);
-    return entries;
+    return copied;
 }
 
-v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)
+v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Null(m_isolate);
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> location = callDebuggerMethod(""getGeneratorObjectLocation"", 1, argv).ToLocalChecked();
-    if (!location->IsObject())
+    v8::Local<v8::Value> copied;
+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())
         return v8::Null(m_isolate);
-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
-    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))
+    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))
         return v8::Null(m_isolate);
-    return location;
+    return copied;
 }
 
 v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
@@ -691,6 +689,8 @@ v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context
     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)
         return v8::Null(m_isolate);
     v8::Local<v8::Object> location = v8::Object::New(m_isolate);
+    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
+        return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""scriptId""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))
         return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""lineNumber""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))",Chrome,93bc623489bdcfc7e9127614fcfb3258edf3f0f9,04c479295e7c67a27ea4a51a5d58436f44542f58,1," v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
{
    int scriptId = function->ScriptId();
    if (scriptId == v8::UnboundScript::kNoScriptId)
        return v8::Null(m_isolate);
    int lineNumber = function->GetScriptLineNumber();
    int columnNumber = function->GetScriptColumnNumber();
     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)
         return v8::Null(m_isolate);
     v8::Local<v8::Object> location = v8::Object::New(m_isolate);
//fix_flaw_line_below:
//    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
//fix_flaw_line_below:
//        return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""scriptId""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))
         return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""lineNumber""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))
        return v8::Null(m_isolate);
    if (!location->Set(context, toV8StringInternalized(m_isolate, ""columnNumber""), v8::Integer::New(m_isolate, columnNumber)).FromMaybe(false))
        return v8::Null(m_isolate);
    if (!markAsInternal(context, location, V8InternalValueType::kLocation))
        return v8::Null(m_isolate);
    return location;
}
"
8243,185979,,Remote,Not required,,CVE-2016-5164,https://www.cvedetails.com/cve/CVE-2016-5164/,CWE-79,Medium,,Partial,,2016-09-11,4.3,"Cross-site scripting (XSS) vulnerability in WebKit/Source/platform/v8_inspector/V8Debugger.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to inject arbitrary web script or HTML into the Developer Tools (aka DevTools) subsystem via a crafted web site, aka *Universal XSS (UXSS).*",2018-10-30,XSS ,8,https://github.com/chromium/chromium/commit/93bc623489bdcfc7e9127614fcfb3258edf3f0f9,93bc623489bdcfc7e9127614fcfb3258edf3f0f9,"[DevTools] Copy objects from debugger context to inspected context properly.

BUG=637594

Review-Url: https://codereview.chromium.org/2253643002
Cr-Commit-Position: refs/heads/master@{#412436}",8,third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp,"{""sha"": ""2c2187b08bb5c2340fde0bae42f64e30e2d45ef8"", ""filename"": ""third_party/WebKit/Source/platform/blink_platform.gypi"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/blink_platform.gypi"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/blink_platform.gypi"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/blink_platform.gypi?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -1176,6 +1176,8 @@\n       'v8_inspector/V8StackTraceImpl.h',\n       'v8_inspector/V8StringUtil.cpp',\n       'v8_inspector/V8StringUtil.h',\n+      'v8_inspector/V8ValueCopier.cpp',\n+      'v8_inspector/V8ValueCopier.h',\n       'v8_inspector/public/V8ContextInfo.h',\n       'v8_inspector/public/V8Inspector.h',\n       'v8_inspector/public/V8InspectorClient.h',""}<_**next**_>{""sha"": ""73a90e225e11aeac62626e36a217ceaa5b2ecf51"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -659,6 +659,8 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> console = v8::Object::New(isolate);\n+    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, console, \""debug\"", V8Console::debugCallback);\n     createBoundFunctionProperty(context, console, \""error\"", V8Console::errorCallback);\n@@ -684,9 +686,6 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex\n     createBoundFunctionProperty(context, console, \""timeEnd\"", V8Console::timeEndCallback);\n     createBoundFunctionProperty(context, console, \""timeStamp\"", V8Console::timeStampCallback);\n \n-    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n-    DCHECK(success);\n-\n     if (hasMemoryAttribute)\n         console->SetAccessorProperty(toV8StringInternalized(isolate, \""memory\""), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);\n \n@@ -707,6 +706,8 @@ v8::Local<v8::Object> V8Console::createCommandLineAPI(InspectedContext* inspecte\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> commandLineAPI = v8::Object::New(isolate);\n+    bool success = commandLineAPI->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, commandLineAPI, \""dir\"", V8Console::dirCallback, \""function dir(value) { [Command Line API] }\"");\n     createBoundFunctionProperty(context, commandLineAPI, \""dirxml\"", V8Console::dirxmlCallback, \""function dirxml(value) { [Command Line API] }\"");""}<_**next**_>{""sha"": ""616bfbe7e474266857090c3ac0f420a9467afbdb"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 22, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -12,6 +12,7 @@\n #include \""platform/v8_inspector/V8InternalValueType.h\""\n #include \""platform/v8_inspector/V8StackTraceImpl.h\""\n #include \""platform/v8_inspector/V8StringUtil.h\""\n+#include \""platform/v8_inspector/V8ValueCopier.h\""\n #include \""platform/v8_inspector/public/V8InspectorClient.h\""\n \n namespace v8_inspector {\n@@ -581,25 +582,24 @@ v8::Local<v8::Context> V8Debugger::debuggerContext() const\n     return m_debuggerContext.Get(m_isolate);\n }\n \n-v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)\n+v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));\n     }\n     v8::Local<v8::Value> argv[] = { function };\n     v8::Local<v8::Value> scopesValue;\n-    if (!callDebuggerMethod(\""getFunctionScopes\"", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())\n+    if (!callDebuggerMethod(\""getFunctionScopes\"", 1, argv).ToLocal(&scopesValue))\n         return v8::MaybeLocal<v8::Value>();\n-    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::MaybeLocal<v8::Value>();\n-    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))\n+    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))\n         return v8::MaybeLocal<v8::Value>();\n-    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n-        return v8::Undefined(m_isolate);\n-    return scopes;\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))\n+        return v8::MaybeLocal<v8::Value>();\n+    return copied;\n }\n \n v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)\n@@ -629,7 +629,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>\n         }\n     }\n     if (value->IsGeneratorObject()) {\n-        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));\n+        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));\n         if (location->IsObject()) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \""[[GeneratorLocation]]\""));\n             properties->Set(properties->Length(), location);\n@@ -639,7 +639,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>\n         v8::Local<v8::Function> function = value.As<v8::Function>();\n         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();\n         v8::Local<v8::Value> scopes;\n-        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {\n+        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \""[[Scopes]]\""));\n             properties->Set(properties->Length(), scopes);\n         }\n@@ -655,30 +655,28 @@ v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> contex\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> entriesValue = callDebuggerMethod(\""getCollectionEntries\"", 1, argv).ToLocalChecked();\n-    if (!entriesValue->IsArray())\n-        return v8::Undefined(m_isolate);\n-    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();\n-    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::Undefined(m_isolate);\n-    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))\n         return v8::Undefined(m_isolate);\n-    return entries;\n+    return copied;\n }\n \n-v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)\n+v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Null(m_isolate);\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> location = callDebuggerMethod(\""getGeneratorObjectLocation\"", 1, argv).ToLocalChecked();\n-    if (!location->IsObject())\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())\n         return v8::Null(m_isolate);\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))\n+    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))\n         return v8::Null(m_isolate);\n-    return location;\n+    return copied;\n }\n \n v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n@@ -691,6 +689,8 @@ v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context\n     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)\n         return v8::Null(m_isolate);\n     v8::Local<v8::Object> location = v8::Object::New(m_isolate);\n+    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+        return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \""scriptId\""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))\n         return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \""lineNumber\""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))""}<_**next**_>{""sha"": ""02e762eb01c420f407ca4476c9c6bc642d12521b"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -76,7 +76,6 @@ class V8Debugger {\n     std::unique_ptr<V8StackTraceImpl> createStackTrace(v8::Local<v8::StackTrace>);\n     std::unique_ptr<V8StackTraceImpl> captureStackTrace(bool fullStack);\n \n-    v8::MaybeLocal<v8::Value> functionScopes(v8::Local<v8::Function>);\n     v8::MaybeLocal<v8::Array> internalProperties(v8::Local<v8::Context>, v8::Local<v8::Value>);\n \n     void asyncTaskScheduled(const String16& taskName, void* task, bool recurring);\n@@ -102,8 +101,9 @@ class V8Debugger {\n     void handleV8AsyncTaskEvent(v8::Local<v8::Context>, v8::Local<v8::Object> executionState, v8::Local<v8::Object> eventData);\n \n     v8::Local<v8::Value> collectionEntries(v8::Local<v8::Context>, v8::Local<v8::Object>);\n-    v8::Local<v8::Value> generatorObjectLocation(v8::Local<v8::Object>);\n+    v8::Local<v8::Value> generatorObjectLocation(v8::Local<v8::Context>, v8::Local<v8::Object>);\n     v8::Local<v8::Value> functionLocation(v8::Local<v8::Context>, v8::Local<v8::Function>);\n+    v8::MaybeLocal<v8::Value> functionScopes(v8::Local<v8::Context>, v8::Local<v8::Function>);\n \n     v8::Isolate* m_isolate;\n     V8InspectorImpl* m_inspector;""}<_**next**_>{""sha"": ""782e5bbab014739c75726871ec7dc193b38f4843"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -42,6 +42,8 @@ v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> contex\n {\n     v8::Isolate* isolate = inspector->isolate();\n     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);\n+    bool success = injectedScriptHost->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);\n     setFunctionProperty(context, injectedScriptHost, \""internalConstructorName\"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);\n     setFunctionProperty(context, injectedScriptHost, \""formatAccessorsAsProperties\"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);""}<_**next**_>{""sha"": ""3347abeba5929aa7c15fa3c05afc4c3072a8232c"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""status"": ""added"", ""additions"": 90, ""deletions"": 0, ""changes"": 90, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -0,0 +1,90 @@\n+// Copyright 2016 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""platform/v8_inspector/V8ValueCopier.h\""\n+\n+namespace v8_inspector {\n+\n+namespace {\n+\n+static int kMaxDepth = 20;\n+static int kMaxCalls = 1000;\n+\n+class V8ValueCopier {\n+public:\n+    v8::MaybeLocal<v8::Value> copy(v8::Local<v8::Value> value, int depth)\n+    {\n+        if (++m_calls > kMaxCalls || depth > kMaxDepth)\n+            return v8::MaybeLocal<v8::Value>();\n+\n+        if (value.IsEmpty())\n+            return v8::MaybeLocal<v8::Value>();\n+        if (value->IsNull() || value->IsUndefined() || value->IsBoolean() || value->IsString() || value->IsNumber())\n+            return value;\n+        if (!value->IsObject())\n+            return v8::MaybeLocal<v8::Value>();\n+        v8::Local<v8::Object> object = value.As<v8::Object>();\n+        if (object->CreationContext() != m_from)\n+            return value;\n+\n+        if (object->IsArray()) {\n+            v8::Local<v8::Array> array = object.As<v8::Array>();\n+            v8::Local<v8::Array> result = v8::Array::New(m_isolate, array->Length());\n+            if (!result->SetPrototype(m_to, v8::Null(m_isolate)).FromMaybe(false))\n+                return v8::MaybeLocal<v8::Value>();\n+            for (size_t i = 0; i < array->Length(); ++i) {\n+                v8::Local<v8::Value> item;\n+                if (!array->Get(m_from, i).ToLocal(&item))\n+                    return v8::MaybeLocal<v8::Value>();\n+                v8::Local<v8::Value> copied;\n+                if (!copy(item, depth + 1).ToLocal(&copied))\n+                    return v8::MaybeLocal<v8::Value>();\n+                if (!result->Set(m_to, i, copied).FromMaybe(false))\n+                    return v8::MaybeLocal<v8::Value>();\n+            }\n+            return result;\n+        }\n+\n+\n+        v8::Local<v8::Object> result = v8::Object::New(m_isolate);\n+        if (!result->SetPrototype(m_to, v8::Null(m_isolate)).FromMaybe(false))\n+            return v8::MaybeLocal<v8::Value>();\n+        v8::Local<v8::Array> properties;\n+        if (!object->GetOwnPropertyNames(m_from).ToLocal(&properties))\n+            return v8::MaybeLocal<v8::Value>();\n+        for (size_t i = 0; i < properties->Length(); ++i) {\n+            v8::Local<v8::Value> name;\n+            if (!properties->Get(m_from, i).ToLocal(&name) || !name->IsString())\n+                return v8::MaybeLocal<v8::Value>();\n+            v8::Local<v8::Value> property;\n+            if (!object->Get(m_from, name).ToLocal(&property))\n+                return v8::MaybeLocal<v8::Value>();\n+            v8::Local<v8::Value> copied;\n+            if (!copy(property, depth + 1).ToLocal(&copied))\n+                return v8::MaybeLocal<v8::Value>();\n+            if (!result->Set(m_to, name, copied).FromMaybe(false))\n+                return v8::MaybeLocal<v8::Value>();\n+        }\n+        return result;\n+    }\n+\n+    v8::Isolate* m_isolate;\n+    v8::Local<v8::Context> m_from;\n+    v8::Local<v8::Context> m_to;\n+    int m_calls;\n+};\n+\n+} // namespace\n+\n+v8::MaybeLocal<v8::Value> copyValueFromDebuggerContext(v8::Isolate* isolate, v8::Local<v8::Context> debuggerContext, v8::Local<v8::Context> toContext, v8::Local<v8::Value> value)\n+{\n+    V8ValueCopier copier;\n+    copier.m_isolate = isolate;\n+    copier.m_from = debuggerContext;\n+    copier.m_to = toContext;\n+    copier.m_calls = 0;\n+    return copier.copy(value, 0);\n+}\n+\n+} // namespace v8_inspector""}<_**next**_>{""sha"": ""9cd650cc80168bb4f8379cb44dd6000881deeab7"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -0,0 +1,16 @@\n+// Copyright 2016 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef V8ValueCopier_h\n+#define V8ValueCopier_h\n+\n+#include <v8.h>\n+\n+namespace v8_inspector {\n+\n+v8::MaybeLocal<v8::Value> copyValueFromDebuggerContext(v8::Isolate*, v8::Local<v8::Context> debuggerContext, v8::Local<v8::Context> toContext, v8::Local<v8::Value>);\n+\n+} // namespace v8_inspector\n+\n+#endif // !defined(V8ValueCopier_h)""}<_**next**_>{""sha"": ""3c496be8f6252b226fcca829b1d00b39422dc14b"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -294,6 +294,8 @@\n         'V8StackTraceImpl.h',\n         'V8StringUtil.cpp',\n         'V8StringUtil.h',\n+        'V8ValueCopier.cpp',\n+        'V8ValueCopier.h',\n         'public/V8EventListenerInfo.h',\n         'public/V8ContextInfo.h',\n         'public/V8Inspector.h',""}","v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)
v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));
     }
     v8::Local<v8::Value> argv[] = { function };
     v8::Local<v8::Value> scopesValue;
    if (!callDebuggerMethod(""getFunctionScopes"", 1, argv).ToLocal(&scopesValue))
         return v8::MaybeLocal<v8::Value>();
    v8::Local<v8::Value> copied;
    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())
         return v8::MaybeLocal<v8::Value>();
    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))
         return v8::MaybeLocal<v8::Value>();
    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))
        return v8::MaybeLocal<v8::Value>();
    return copied;
 }
","v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));
     }
     v8::Local<v8::Value> argv[] = { function };
     v8::Local<v8::Value> scopesValue;
    if (!callDebuggerMethod(""getFunctionScopes"", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())
         return v8::MaybeLocal<v8::Value>();
    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();
    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))
         return v8::MaybeLocal<v8::Value>();
    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))
         return v8::MaybeLocal<v8::Value>();
    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
        return v8::Undefined(m_isolate);
    return scopes;
 }
",C,"v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
    if (!callDebuggerMethod(""getFunctionScopes"", 1, argv).ToLocal(&scopesValue))
    v8::Local<v8::Value> copied;
    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())
    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))
    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))
        return v8::MaybeLocal<v8::Value>();
    return copied;
","    if (!callDebuggerMethod(""getFunctionScopes"", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())
    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();
    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))
    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))
    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
        return v8::Undefined(m_isolate);
    return scopes;
",,"@@ -12,6 +12,7 @@
 #include ""platform/v8_inspector/V8InternalValueType.h""
 #include ""platform/v8_inspector/V8StackTraceImpl.h""
 #include ""platform/v8_inspector/V8StringUtil.h""
+#include ""platform/v8_inspector/V8ValueCopier.h""
 #include ""platform/v8_inspector/public/V8InspectorClient.h""
 
 namespace v8_inspector {
@@ -581,25 +582,24 @@ v8::Local<v8::Context> V8Debugger::debuggerContext() const
     return m_debuggerContext.Get(m_isolate);
 }
 
-v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)
+v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));
     }
     v8::Local<v8::Value> argv[] = { function };
     v8::Local<v8::Value> scopesValue;
-    if (!callDebuggerMethod(""getFunctionScopes"", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())
+    if (!callDebuggerMethod(""getFunctionScopes"", 1, argv).ToLocal(&scopesValue))
         return v8::MaybeLocal<v8::Value>();
-    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();
-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
-    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))
+    v8::Local<v8::Value> copied;
+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())
         return v8::MaybeLocal<v8::Value>();
-    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))
+    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))
         return v8::MaybeLocal<v8::Value>();
-    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
-        return v8::Undefined(m_isolate);
-    return scopes;
+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))
+        return v8::MaybeLocal<v8::Value>();
+    return copied;
 }
 
 v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)
@@ -629,7 +629,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>
         }
     }
     if (value->IsGeneratorObject()) {
-        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));
+        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));
         if (location->IsObject()) {
             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[GeneratorLocation]]""));
             properties->Set(properties->Length(), location);
@@ -639,7 +639,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>
         v8::Local<v8::Function> function = value.As<v8::Function>();
         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();
         v8::Local<v8::Value> scopes;
-        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {
+        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {
             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[Scopes]]""));
             properties->Set(properties->Length(), scopes);
         }
@@ -655,30 +655,28 @@ v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> contex
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> entriesValue = callDebuggerMethod(""getCollectionEntries"", 1, argv).ToLocalChecked();
-    if (!entriesValue->IsArray())
-        return v8::Undefined(m_isolate);
-    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();
-    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))
+    v8::Local<v8::Value> copied;
+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())
         return v8::Undefined(m_isolate);
-    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))
         return v8::Undefined(m_isolate);
-    return entries;
+    return copied;
 }
 
-v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)
+v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Null(m_isolate);
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> location = callDebuggerMethod(""getGeneratorObjectLocation"", 1, argv).ToLocalChecked();
-    if (!location->IsObject())
+    v8::Local<v8::Value> copied;
+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())
         return v8::Null(m_isolate);
-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
-    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))
+    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))
         return v8::Null(m_isolate);
-    return location;
+    return copied;
 }
 
 v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
@@ -691,6 +689,8 @@ v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context
     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)
         return v8::Null(m_isolate);
     v8::Local<v8::Object> location = v8::Object::New(m_isolate);
+    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
+        return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""scriptId""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))
         return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""lineNumber""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))",Chrome,93bc623489bdcfc7e9127614fcfb3258edf3f0f9,04c479295e7c67a27ea4a51a5d58436f44542f58,1,"v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)
//fix_flaw_line_below:
//v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));
     }
     v8::Local<v8::Value> argv[] = { function };
     v8::Local<v8::Value> scopesValue;
//flaw_line_below:
    if (!callDebuggerMethod(""getFunctionScopes"", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())
//fix_flaw_line_below:
//    if (!callDebuggerMethod(""getFunctionScopes"", 1, argv).ToLocal(&scopesValue))
         return v8::MaybeLocal<v8::Value>();
//flaw_line_below:
    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();
//flaw_line_below:
    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
//flaw_line_below:
    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))
//fix_flaw_line_below:
//    v8::Local<v8::Value> copied;
//fix_flaw_line_below:
//    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())
         return v8::MaybeLocal<v8::Value>();
//flaw_line_below:
    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))
//fix_flaw_line_below:
//    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))
         return v8::MaybeLocal<v8::Value>();
//flaw_line_below:
    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
//flaw_line_below:
        return v8::Undefined(m_isolate);
//flaw_line_below:
    return scopes;
//fix_flaw_line_below:
//    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))
//fix_flaw_line_below:
//        return v8::MaybeLocal<v8::Value>();
//fix_flaw_line_below:
//    return copied;
 }
"
8244,185980,,Remote,Not required,,CVE-2016-5164,https://www.cvedetails.com/cve/CVE-2016-5164/,CWE-79,Medium,,Partial,,2016-09-11,4.3,"Cross-site scripting (XSS) vulnerability in WebKit/Source/platform/v8_inspector/V8Debugger.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to inject arbitrary web script or HTML into the Developer Tools (aka DevTools) subsystem via a crafted web site, aka *Universal XSS (UXSS).*",2018-10-30,XSS ,5,https://github.com/chromium/chromium/commit/93bc623489bdcfc7e9127614fcfb3258edf3f0f9,93bc623489bdcfc7e9127614fcfb3258edf3f0f9,"[DevTools] Copy objects from debugger context to inspected context properly.

BUG=637594

Review-Url: https://codereview.chromium.org/2253643002
Cr-Commit-Position: refs/heads/master@{#412436}",4,third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp,"{""sha"": ""2c2187b08bb5c2340fde0bae42f64e30e2d45ef8"", ""filename"": ""third_party/WebKit/Source/platform/blink_platform.gypi"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/blink_platform.gypi"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/blink_platform.gypi"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/blink_platform.gypi?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -1176,6 +1176,8 @@\n       'v8_inspector/V8StackTraceImpl.h',\n       'v8_inspector/V8StringUtil.cpp',\n       'v8_inspector/V8StringUtil.h',\n+      'v8_inspector/V8ValueCopier.cpp',\n+      'v8_inspector/V8ValueCopier.h',\n       'v8_inspector/public/V8ContextInfo.h',\n       'v8_inspector/public/V8Inspector.h',\n       'v8_inspector/public/V8InspectorClient.h',""}<_**next**_>{""sha"": ""73a90e225e11aeac62626e36a217ceaa5b2ecf51"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -659,6 +659,8 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> console = v8::Object::New(isolate);\n+    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, console, \""debug\"", V8Console::debugCallback);\n     createBoundFunctionProperty(context, console, \""error\"", V8Console::errorCallback);\n@@ -684,9 +686,6 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex\n     createBoundFunctionProperty(context, console, \""timeEnd\"", V8Console::timeEndCallback);\n     createBoundFunctionProperty(context, console, \""timeStamp\"", V8Console::timeStampCallback);\n \n-    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n-    DCHECK(success);\n-\n     if (hasMemoryAttribute)\n         console->SetAccessorProperty(toV8StringInternalized(isolate, \""memory\""), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);\n \n@@ -707,6 +706,8 @@ v8::Local<v8::Object> V8Console::createCommandLineAPI(InspectedContext* inspecte\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> commandLineAPI = v8::Object::New(isolate);\n+    bool success = commandLineAPI->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, commandLineAPI, \""dir\"", V8Console::dirCallback, \""function dir(value) { [Command Line API] }\"");\n     createBoundFunctionProperty(context, commandLineAPI, \""dirxml\"", V8Console::dirxmlCallback, \""function dirxml(value) { [Command Line API] }\"");""}<_**next**_>{""sha"": ""616bfbe7e474266857090c3ac0f420a9467afbdb"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 22, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -12,6 +12,7 @@\n #include \""platform/v8_inspector/V8InternalValueType.h\""\n #include \""platform/v8_inspector/V8StackTraceImpl.h\""\n #include \""platform/v8_inspector/V8StringUtil.h\""\n+#include \""platform/v8_inspector/V8ValueCopier.h\""\n #include \""platform/v8_inspector/public/V8InspectorClient.h\""\n \n namespace v8_inspector {\n@@ -581,25 +582,24 @@ v8::Local<v8::Context> V8Debugger::debuggerContext() const\n     return m_debuggerContext.Get(m_isolate);\n }\n \n-v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)\n+v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));\n     }\n     v8::Local<v8::Value> argv[] = { function };\n     v8::Local<v8::Value> scopesValue;\n-    if (!callDebuggerMethod(\""getFunctionScopes\"", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())\n+    if (!callDebuggerMethod(\""getFunctionScopes\"", 1, argv).ToLocal(&scopesValue))\n         return v8::MaybeLocal<v8::Value>();\n-    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::MaybeLocal<v8::Value>();\n-    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))\n+    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))\n         return v8::MaybeLocal<v8::Value>();\n-    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n-        return v8::Undefined(m_isolate);\n-    return scopes;\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))\n+        return v8::MaybeLocal<v8::Value>();\n+    return copied;\n }\n \n v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)\n@@ -629,7 +629,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>\n         }\n     }\n     if (value->IsGeneratorObject()) {\n-        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));\n+        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));\n         if (location->IsObject()) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \""[[GeneratorLocation]]\""));\n             properties->Set(properties->Length(), location);\n@@ -639,7 +639,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>\n         v8::Local<v8::Function> function = value.As<v8::Function>();\n         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();\n         v8::Local<v8::Value> scopes;\n-        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {\n+        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \""[[Scopes]]\""));\n             properties->Set(properties->Length(), scopes);\n         }\n@@ -655,30 +655,28 @@ v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> contex\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> entriesValue = callDebuggerMethod(\""getCollectionEntries\"", 1, argv).ToLocalChecked();\n-    if (!entriesValue->IsArray())\n-        return v8::Undefined(m_isolate);\n-    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();\n-    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::Undefined(m_isolate);\n-    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))\n         return v8::Undefined(m_isolate);\n-    return entries;\n+    return copied;\n }\n \n-v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)\n+v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Null(m_isolate);\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> location = callDebuggerMethod(\""getGeneratorObjectLocation\"", 1, argv).ToLocalChecked();\n-    if (!location->IsObject())\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())\n         return v8::Null(m_isolate);\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))\n+    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))\n         return v8::Null(m_isolate);\n-    return location;\n+    return copied;\n }\n \n v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n@@ -691,6 +689,8 @@ v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context\n     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)\n         return v8::Null(m_isolate);\n     v8::Local<v8::Object> location = v8::Object::New(m_isolate);\n+    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+        return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \""scriptId\""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))\n         return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \""lineNumber\""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))""}<_**next**_>{""sha"": ""02e762eb01c420f407ca4476c9c6bc642d12521b"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -76,7 +76,6 @@ class V8Debugger {\n     std::unique_ptr<V8StackTraceImpl> createStackTrace(v8::Local<v8::StackTrace>);\n     std::unique_ptr<V8StackTraceImpl> captureStackTrace(bool fullStack);\n \n-    v8::MaybeLocal<v8::Value> functionScopes(v8::Local<v8::Function>);\n     v8::MaybeLocal<v8::Array> internalProperties(v8::Local<v8::Context>, v8::Local<v8::Value>);\n \n     void asyncTaskScheduled(const String16& taskName, void* task, bool recurring);\n@@ -102,8 +101,9 @@ class V8Debugger {\n     void handleV8AsyncTaskEvent(v8::Local<v8::Context>, v8::Local<v8::Object> executionState, v8::Local<v8::Object> eventData);\n \n     v8::Local<v8::Value> collectionEntries(v8::Local<v8::Context>, v8::Local<v8::Object>);\n-    v8::Local<v8::Value> generatorObjectLocation(v8::Local<v8::Object>);\n+    v8::Local<v8::Value> generatorObjectLocation(v8::Local<v8::Context>, v8::Local<v8::Object>);\n     v8::Local<v8::Value> functionLocation(v8::Local<v8::Context>, v8::Local<v8::Function>);\n+    v8::MaybeLocal<v8::Value> functionScopes(v8::Local<v8::Context>, v8::Local<v8::Function>);\n \n     v8::Isolate* m_isolate;\n     V8InspectorImpl* m_inspector;""}<_**next**_>{""sha"": ""782e5bbab014739c75726871ec7dc193b38f4843"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -42,6 +42,8 @@ v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> contex\n {\n     v8::Isolate* isolate = inspector->isolate();\n     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);\n+    bool success = injectedScriptHost->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);\n     setFunctionProperty(context, injectedScriptHost, \""internalConstructorName\"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);\n     setFunctionProperty(context, injectedScriptHost, \""formatAccessorsAsProperties\"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);""}<_**next**_>{""sha"": ""3347abeba5929aa7c15fa3c05afc4c3072a8232c"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""status"": ""added"", ""additions"": 90, ""deletions"": 0, ""changes"": 90, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -0,0 +1,90 @@\n+// Copyright 2016 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""platform/v8_inspector/V8ValueCopier.h\""\n+\n+namespace v8_inspector {\n+\n+namespace {\n+\n+static int kMaxDepth = 20;\n+static int kMaxCalls = 1000;\n+\n+class V8ValueCopier {\n+public:\n+    v8::MaybeLocal<v8::Value> copy(v8::Local<v8::Value> value, int depth)\n+    {\n+        if (++m_calls > kMaxCalls || depth > kMaxDepth)\n+            return v8::MaybeLocal<v8::Value>();\n+\n+        if (value.IsEmpty())\n+            return v8::MaybeLocal<v8::Value>();\n+        if (value->IsNull() || value->IsUndefined() || value->IsBoolean() || value->IsString() || value->IsNumber())\n+            return value;\n+        if (!value->IsObject())\n+            return v8::MaybeLocal<v8::Value>();\n+        v8::Local<v8::Object> object = value.As<v8::Object>();\n+        if (object->CreationContext() != m_from)\n+            return value;\n+\n+        if (object->IsArray()) {\n+            v8::Local<v8::Array> array = object.As<v8::Array>();\n+            v8::Local<v8::Array> result = v8::Array::New(m_isolate, array->Length());\n+            if (!result->SetPrototype(m_to, v8::Null(m_isolate)).FromMaybe(false))\n+                return v8::MaybeLocal<v8::Value>();\n+            for (size_t i = 0; i < array->Length(); ++i) {\n+                v8::Local<v8::Value> item;\n+                if (!array->Get(m_from, i).ToLocal(&item))\n+                    return v8::MaybeLocal<v8::Value>();\n+                v8::Local<v8::Value> copied;\n+                if (!copy(item, depth + 1).ToLocal(&copied))\n+                    return v8::MaybeLocal<v8::Value>();\n+                if (!result->Set(m_to, i, copied).FromMaybe(false))\n+                    return v8::MaybeLocal<v8::Value>();\n+            }\n+            return result;\n+        }\n+\n+\n+        v8::Local<v8::Object> result = v8::Object::New(m_isolate);\n+        if (!result->SetPrototype(m_to, v8::Null(m_isolate)).FromMaybe(false))\n+            return v8::MaybeLocal<v8::Value>();\n+        v8::Local<v8::Array> properties;\n+        if (!object->GetOwnPropertyNames(m_from).ToLocal(&properties))\n+            return v8::MaybeLocal<v8::Value>();\n+        for (size_t i = 0; i < properties->Length(); ++i) {\n+            v8::Local<v8::Value> name;\n+            if (!properties->Get(m_from, i).ToLocal(&name) || !name->IsString())\n+                return v8::MaybeLocal<v8::Value>();\n+            v8::Local<v8::Value> property;\n+            if (!object->Get(m_from, name).ToLocal(&property))\n+                return v8::MaybeLocal<v8::Value>();\n+            v8::Local<v8::Value> copied;\n+            if (!copy(property, depth + 1).ToLocal(&copied))\n+                return v8::MaybeLocal<v8::Value>();\n+            if (!result->Set(m_to, name, copied).FromMaybe(false))\n+                return v8::MaybeLocal<v8::Value>();\n+        }\n+        return result;\n+    }\n+\n+    v8::Isolate* m_isolate;\n+    v8::Local<v8::Context> m_from;\n+    v8::Local<v8::Context> m_to;\n+    int m_calls;\n+};\n+\n+} // namespace\n+\n+v8::MaybeLocal<v8::Value> copyValueFromDebuggerContext(v8::Isolate* isolate, v8::Local<v8::Context> debuggerContext, v8::Local<v8::Context> toContext, v8::Local<v8::Value> value)\n+{\n+    V8ValueCopier copier;\n+    copier.m_isolate = isolate;\n+    copier.m_from = debuggerContext;\n+    copier.m_to = toContext;\n+    copier.m_calls = 0;\n+    return copier.copy(value, 0);\n+}\n+\n+} // namespace v8_inspector""}<_**next**_>{""sha"": ""9cd650cc80168bb4f8379cb44dd6000881deeab7"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -0,0 +1,16 @@\n+// Copyright 2016 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef V8ValueCopier_h\n+#define V8ValueCopier_h\n+\n+#include <v8.h>\n+\n+namespace v8_inspector {\n+\n+v8::MaybeLocal<v8::Value> copyValueFromDebuggerContext(v8::Isolate*, v8::Local<v8::Context> debuggerContext, v8::Local<v8::Context> toContext, v8::Local<v8::Value>);\n+\n+} // namespace v8_inspector\n+\n+#endif // !defined(V8ValueCopier_h)""}<_**next**_>{""sha"": ""3c496be8f6252b226fcca829b1d00b39422dc14b"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -294,6 +294,8 @@\n         'V8StackTraceImpl.h',\n         'V8StringUtil.cpp',\n         'V8StringUtil.h',\n+        'V8ValueCopier.cpp',\n+        'V8ValueCopier.h',\n         'public/V8EventListenerInfo.h',\n         'public/V8ContextInfo.h',\n         'public/V8Inspector.h',""}","v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)
v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Null(m_isolate);
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> location = callDebuggerMethod(""getGeneratorObjectLocation"", 1, argv).ToLocalChecked();
    v8::Local<v8::Value> copied;
    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())
         return v8::Null(m_isolate);
    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))
         return v8::Null(m_isolate);
    return copied;
 }
","v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Null(m_isolate);
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> location = callDebuggerMethod(""getGeneratorObjectLocation"", 1, argv).ToLocalChecked();
    if (!location->IsObject())
         return v8::Null(m_isolate);
    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))
         return v8::Null(m_isolate);
    return location;
 }
",C,"v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)
    v8::Local<v8::Value> copied;
    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())
    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))
    return copied;
","    if (!location->IsObject())
    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))
    return location;
",,"@@ -12,6 +12,7 @@
 #include ""platform/v8_inspector/V8InternalValueType.h""
 #include ""platform/v8_inspector/V8StackTraceImpl.h""
 #include ""platform/v8_inspector/V8StringUtil.h""
+#include ""platform/v8_inspector/V8ValueCopier.h""
 #include ""platform/v8_inspector/public/V8InspectorClient.h""
 
 namespace v8_inspector {
@@ -581,25 +582,24 @@ v8::Local<v8::Context> V8Debugger::debuggerContext() const
     return m_debuggerContext.Get(m_isolate);
 }
 
-v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)
+v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));
     }
     v8::Local<v8::Value> argv[] = { function };
     v8::Local<v8::Value> scopesValue;
-    if (!callDebuggerMethod(""getFunctionScopes"", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())
+    if (!callDebuggerMethod(""getFunctionScopes"", 1, argv).ToLocal(&scopesValue))
         return v8::MaybeLocal<v8::Value>();
-    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();
-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
-    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))
+    v8::Local<v8::Value> copied;
+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())
         return v8::MaybeLocal<v8::Value>();
-    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))
+    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))
         return v8::MaybeLocal<v8::Value>();
-    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
-        return v8::Undefined(m_isolate);
-    return scopes;
+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))
+        return v8::MaybeLocal<v8::Value>();
+    return copied;
 }
 
 v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)
@@ -629,7 +629,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>
         }
     }
     if (value->IsGeneratorObject()) {
-        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));
+        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));
         if (location->IsObject()) {
             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[GeneratorLocation]]""));
             properties->Set(properties->Length(), location);
@@ -639,7 +639,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>
         v8::Local<v8::Function> function = value.As<v8::Function>();
         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();
         v8::Local<v8::Value> scopes;
-        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {
+        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {
             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[Scopes]]""));
             properties->Set(properties->Length(), scopes);
         }
@@ -655,30 +655,28 @@ v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> contex
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> entriesValue = callDebuggerMethod(""getCollectionEntries"", 1, argv).ToLocalChecked();
-    if (!entriesValue->IsArray())
-        return v8::Undefined(m_isolate);
-    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();
-    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))
+    v8::Local<v8::Value> copied;
+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())
         return v8::Undefined(m_isolate);
-    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))
         return v8::Undefined(m_isolate);
-    return entries;
+    return copied;
 }
 
-v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)
+v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Null(m_isolate);
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> location = callDebuggerMethod(""getGeneratorObjectLocation"", 1, argv).ToLocalChecked();
-    if (!location->IsObject())
+    v8::Local<v8::Value> copied;
+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())
         return v8::Null(m_isolate);
-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
-    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))
+    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))
         return v8::Null(m_isolate);
-    return location;
+    return copied;
 }
 
 v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
@@ -691,6 +689,8 @@ v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context
     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)
         return v8::Null(m_isolate);
     v8::Local<v8::Object> location = v8::Object::New(m_isolate);
+    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
+        return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""scriptId""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))
         return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""lineNumber""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))",Chrome,93bc623489bdcfc7e9127614fcfb3258edf3f0f9,04c479295e7c67a27ea4a51a5d58436f44542f58,1,"v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)
//fix_flaw_line_below:
//v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Null(m_isolate);
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> location = callDebuggerMethod(""getGeneratorObjectLocation"", 1, argv).ToLocalChecked();
//flaw_line_below:
    if (!location->IsObject())
//fix_flaw_line_below:
//    v8::Local<v8::Value> copied;
//fix_flaw_line_below:
//    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())
         return v8::Null(m_isolate);
//flaw_line_below:
    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
//flaw_line_below:
    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))
//fix_flaw_line_below:
//    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))
         return v8::Null(m_isolate);
//flaw_line_below:
    return location;
//fix_flaw_line_below:
//    return copied;
 }
"
8245,185981,,Remote,Not required,,CVE-2016-5164,https://www.cvedetails.com/cve/CVE-2016-5164/,CWE-79,Medium,,Partial,,2016-09-11,4.3,"Cross-site scripting (XSS) vulnerability in WebKit/Source/platform/v8_inspector/V8Debugger.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to inject arbitrary web script or HTML into the Developer Tools (aka DevTools) subsystem via a crafted web site, aka *Universal XSS (UXSS).*",2018-10-30,XSS ,2,https://github.com/chromium/chromium/commit/93bc623489bdcfc7e9127614fcfb3258edf3f0f9,93bc623489bdcfc7e9127614fcfb3258edf3f0f9,"[DevTools] Copy objects from debugger context to inspected context properly.

BUG=637594

Review-Url: https://codereview.chromium.org/2253643002
Cr-Commit-Position: refs/heads/master@{#412436}",2,third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp,"{""sha"": ""2c2187b08bb5c2340fde0bae42f64e30e2d45ef8"", ""filename"": ""third_party/WebKit/Source/platform/blink_platform.gypi"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/blink_platform.gypi"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/blink_platform.gypi"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/blink_platform.gypi?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -1176,6 +1176,8 @@\n       'v8_inspector/V8StackTraceImpl.h',\n       'v8_inspector/V8StringUtil.cpp',\n       'v8_inspector/V8StringUtil.h',\n+      'v8_inspector/V8ValueCopier.cpp',\n+      'v8_inspector/V8ValueCopier.h',\n       'v8_inspector/public/V8ContextInfo.h',\n       'v8_inspector/public/V8Inspector.h',\n       'v8_inspector/public/V8InspectorClient.h',""}<_**next**_>{""sha"": ""73a90e225e11aeac62626e36a217ceaa5b2ecf51"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -659,6 +659,8 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> console = v8::Object::New(isolate);\n+    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, console, \""debug\"", V8Console::debugCallback);\n     createBoundFunctionProperty(context, console, \""error\"", V8Console::errorCallback);\n@@ -684,9 +686,6 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex\n     createBoundFunctionProperty(context, console, \""timeEnd\"", V8Console::timeEndCallback);\n     createBoundFunctionProperty(context, console, \""timeStamp\"", V8Console::timeStampCallback);\n \n-    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n-    DCHECK(success);\n-\n     if (hasMemoryAttribute)\n         console->SetAccessorProperty(toV8StringInternalized(isolate, \""memory\""), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);\n \n@@ -707,6 +706,8 @@ v8::Local<v8::Object> V8Console::createCommandLineAPI(InspectedContext* inspecte\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> commandLineAPI = v8::Object::New(isolate);\n+    bool success = commandLineAPI->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, commandLineAPI, \""dir\"", V8Console::dirCallback, \""function dir(value) { [Command Line API] }\"");\n     createBoundFunctionProperty(context, commandLineAPI, \""dirxml\"", V8Console::dirxmlCallback, \""function dirxml(value) { [Command Line API] }\"");""}<_**next**_>{""sha"": ""616bfbe7e474266857090c3ac0f420a9467afbdb"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 22, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -12,6 +12,7 @@\n #include \""platform/v8_inspector/V8InternalValueType.h\""\n #include \""platform/v8_inspector/V8StackTraceImpl.h\""\n #include \""platform/v8_inspector/V8StringUtil.h\""\n+#include \""platform/v8_inspector/V8ValueCopier.h\""\n #include \""platform/v8_inspector/public/V8InspectorClient.h\""\n \n namespace v8_inspector {\n@@ -581,25 +582,24 @@ v8::Local<v8::Context> V8Debugger::debuggerContext() const\n     return m_debuggerContext.Get(m_isolate);\n }\n \n-v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)\n+v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));\n     }\n     v8::Local<v8::Value> argv[] = { function };\n     v8::Local<v8::Value> scopesValue;\n-    if (!callDebuggerMethod(\""getFunctionScopes\"", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())\n+    if (!callDebuggerMethod(\""getFunctionScopes\"", 1, argv).ToLocal(&scopesValue))\n         return v8::MaybeLocal<v8::Value>();\n-    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::MaybeLocal<v8::Value>();\n-    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))\n+    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))\n         return v8::MaybeLocal<v8::Value>();\n-    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n-        return v8::Undefined(m_isolate);\n-    return scopes;\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))\n+        return v8::MaybeLocal<v8::Value>();\n+    return copied;\n }\n \n v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)\n@@ -629,7 +629,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>\n         }\n     }\n     if (value->IsGeneratorObject()) {\n-        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));\n+        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));\n         if (location->IsObject()) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \""[[GeneratorLocation]]\""));\n             properties->Set(properties->Length(), location);\n@@ -639,7 +639,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>\n         v8::Local<v8::Function> function = value.As<v8::Function>();\n         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();\n         v8::Local<v8::Value> scopes;\n-        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {\n+        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \""[[Scopes]]\""));\n             properties->Set(properties->Length(), scopes);\n         }\n@@ -655,30 +655,28 @@ v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> contex\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> entriesValue = callDebuggerMethod(\""getCollectionEntries\"", 1, argv).ToLocalChecked();\n-    if (!entriesValue->IsArray())\n-        return v8::Undefined(m_isolate);\n-    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();\n-    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::Undefined(m_isolate);\n-    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))\n         return v8::Undefined(m_isolate);\n-    return entries;\n+    return copied;\n }\n \n-v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)\n+v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Null(m_isolate);\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> location = callDebuggerMethod(\""getGeneratorObjectLocation\"", 1, argv).ToLocalChecked();\n-    if (!location->IsObject())\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())\n         return v8::Null(m_isolate);\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))\n+    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))\n         return v8::Null(m_isolate);\n-    return location;\n+    return copied;\n }\n \n v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n@@ -691,6 +689,8 @@ v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context\n     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)\n         return v8::Null(m_isolate);\n     v8::Local<v8::Object> location = v8::Object::New(m_isolate);\n+    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+        return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \""scriptId\""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))\n         return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \""lineNumber\""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))""}<_**next**_>{""sha"": ""02e762eb01c420f407ca4476c9c6bc642d12521b"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -76,7 +76,6 @@ class V8Debugger {\n     std::unique_ptr<V8StackTraceImpl> createStackTrace(v8::Local<v8::StackTrace>);\n     std::unique_ptr<V8StackTraceImpl> captureStackTrace(bool fullStack);\n \n-    v8::MaybeLocal<v8::Value> functionScopes(v8::Local<v8::Function>);\n     v8::MaybeLocal<v8::Array> internalProperties(v8::Local<v8::Context>, v8::Local<v8::Value>);\n \n     void asyncTaskScheduled(const String16& taskName, void* task, bool recurring);\n@@ -102,8 +101,9 @@ class V8Debugger {\n     void handleV8AsyncTaskEvent(v8::Local<v8::Context>, v8::Local<v8::Object> executionState, v8::Local<v8::Object> eventData);\n \n     v8::Local<v8::Value> collectionEntries(v8::Local<v8::Context>, v8::Local<v8::Object>);\n-    v8::Local<v8::Value> generatorObjectLocation(v8::Local<v8::Object>);\n+    v8::Local<v8::Value> generatorObjectLocation(v8::Local<v8::Context>, v8::Local<v8::Object>);\n     v8::Local<v8::Value> functionLocation(v8::Local<v8::Context>, v8::Local<v8::Function>);\n+    v8::MaybeLocal<v8::Value> functionScopes(v8::Local<v8::Context>, v8::Local<v8::Function>);\n \n     v8::Isolate* m_isolate;\n     V8InspectorImpl* m_inspector;""}<_**next**_>{""sha"": ""782e5bbab014739c75726871ec7dc193b38f4843"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -42,6 +42,8 @@ v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> contex\n {\n     v8::Isolate* isolate = inspector->isolate();\n     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);\n+    bool success = injectedScriptHost->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);\n     setFunctionProperty(context, injectedScriptHost, \""internalConstructorName\"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);\n     setFunctionProperty(context, injectedScriptHost, \""formatAccessorsAsProperties\"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);""}<_**next**_>{""sha"": ""3347abeba5929aa7c15fa3c05afc4c3072a8232c"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""status"": ""added"", ""additions"": 90, ""deletions"": 0, ""changes"": 90, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -0,0 +1,90 @@\n+// Copyright 2016 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""platform/v8_inspector/V8ValueCopier.h\""\n+\n+namespace v8_inspector {\n+\n+namespace {\n+\n+static int kMaxDepth = 20;\n+static int kMaxCalls = 1000;\n+\n+class V8ValueCopier {\n+public:\n+    v8::MaybeLocal<v8::Value> copy(v8::Local<v8::Value> value, int depth)\n+    {\n+        if (++m_calls > kMaxCalls || depth > kMaxDepth)\n+            return v8::MaybeLocal<v8::Value>();\n+\n+        if (value.IsEmpty())\n+            return v8::MaybeLocal<v8::Value>();\n+        if (value->IsNull() || value->IsUndefined() || value->IsBoolean() || value->IsString() || value->IsNumber())\n+            return value;\n+        if (!value->IsObject())\n+            return v8::MaybeLocal<v8::Value>();\n+        v8::Local<v8::Object> object = value.As<v8::Object>();\n+        if (object->CreationContext() != m_from)\n+            return value;\n+\n+        if (object->IsArray()) {\n+            v8::Local<v8::Array> array = object.As<v8::Array>();\n+            v8::Local<v8::Array> result = v8::Array::New(m_isolate, array->Length());\n+            if (!result->SetPrototype(m_to, v8::Null(m_isolate)).FromMaybe(false))\n+                return v8::MaybeLocal<v8::Value>();\n+            for (size_t i = 0; i < array->Length(); ++i) {\n+                v8::Local<v8::Value> item;\n+                if (!array->Get(m_from, i).ToLocal(&item))\n+                    return v8::MaybeLocal<v8::Value>();\n+                v8::Local<v8::Value> copied;\n+                if (!copy(item, depth + 1).ToLocal(&copied))\n+                    return v8::MaybeLocal<v8::Value>();\n+                if (!result->Set(m_to, i, copied).FromMaybe(false))\n+                    return v8::MaybeLocal<v8::Value>();\n+            }\n+            return result;\n+        }\n+\n+\n+        v8::Local<v8::Object> result = v8::Object::New(m_isolate);\n+        if (!result->SetPrototype(m_to, v8::Null(m_isolate)).FromMaybe(false))\n+            return v8::MaybeLocal<v8::Value>();\n+        v8::Local<v8::Array> properties;\n+        if (!object->GetOwnPropertyNames(m_from).ToLocal(&properties))\n+            return v8::MaybeLocal<v8::Value>();\n+        for (size_t i = 0; i < properties->Length(); ++i) {\n+            v8::Local<v8::Value> name;\n+            if (!properties->Get(m_from, i).ToLocal(&name) || !name->IsString())\n+                return v8::MaybeLocal<v8::Value>();\n+            v8::Local<v8::Value> property;\n+            if (!object->Get(m_from, name).ToLocal(&property))\n+                return v8::MaybeLocal<v8::Value>();\n+            v8::Local<v8::Value> copied;\n+            if (!copy(property, depth + 1).ToLocal(&copied))\n+                return v8::MaybeLocal<v8::Value>();\n+            if (!result->Set(m_to, name, copied).FromMaybe(false))\n+                return v8::MaybeLocal<v8::Value>();\n+        }\n+        return result;\n+    }\n+\n+    v8::Isolate* m_isolate;\n+    v8::Local<v8::Context> m_from;\n+    v8::Local<v8::Context> m_to;\n+    int m_calls;\n+};\n+\n+} // namespace\n+\n+v8::MaybeLocal<v8::Value> copyValueFromDebuggerContext(v8::Isolate* isolate, v8::Local<v8::Context> debuggerContext, v8::Local<v8::Context> toContext, v8::Local<v8::Value> value)\n+{\n+    V8ValueCopier copier;\n+    copier.m_isolate = isolate;\n+    copier.m_from = debuggerContext;\n+    copier.m_to = toContext;\n+    copier.m_calls = 0;\n+    return copier.copy(value, 0);\n+}\n+\n+} // namespace v8_inspector""}<_**next**_>{""sha"": ""9cd650cc80168bb4f8379cb44dd6000881deeab7"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -0,0 +1,16 @@\n+// Copyright 2016 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef V8ValueCopier_h\n+#define V8ValueCopier_h\n+\n+#include <v8.h>\n+\n+namespace v8_inspector {\n+\n+v8::MaybeLocal<v8::Value> copyValueFromDebuggerContext(v8::Isolate*, v8::Local<v8::Context> debuggerContext, v8::Local<v8::Context> toContext, v8::Local<v8::Value>);\n+\n+} // namespace v8_inspector\n+\n+#endif // !defined(V8ValueCopier_h)""}<_**next**_>{""sha"": ""3c496be8f6252b226fcca829b1d00b39422dc14b"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -294,6 +294,8 @@\n         'V8StackTraceImpl.h',\n         'V8StringUtil.cpp',\n         'V8StringUtil.h',\n+        'V8ValueCopier.cpp',\n+        'V8ValueCopier.h',\n         'public/V8EventListenerInfo.h',\n         'public/V8ContextInfo.h',\n         'public/V8Inspector.h',""}"," v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)
{
    v8::Local<v8::Array> properties;
    if (!v8::Debug::GetInternalProperties(m_isolate, value).ToLocal(&properties))
        return v8::MaybeLocal<v8::Array>();
    if (value->IsFunction()) {
        v8::Local<v8::Function> function = value.As<v8::Function>();
        v8::Local<v8::Value> location = functionLocation(context, function);
        if (location->IsObject()) {
            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[FunctionLocation]]""));
            properties->Set(properties->Length(), location);
        }
        if (function->IsGeneratorFunction()) {
            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[IsGenerator]]""));
            properties->Set(properties->Length(), v8::True(m_isolate));
        }
    }
    if (!enabled())
        return properties;
    if (value->IsMap() || value->IsWeakMap() || value->IsSet() || value->IsWeakSet() || value->IsSetIterator() || value->IsMapIterator()) {
        v8::Local<v8::Value> entries = collectionEntries(context, v8::Local<v8::Object>::Cast(value));
        if (entries->IsArray()) {
            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[Entries]]""));
            properties->Set(properties->Length(), entries);
         }
     }
     if (value->IsGeneratorObject()) {
        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));
         if (location->IsObject()) {
             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[GeneratorLocation]]""));
             properties->Set(properties->Length(), location);
        }
    }
    if (value->IsFunction()) {
         v8::Local<v8::Function> function = value.As<v8::Function>();
         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();
         v8::Local<v8::Value> scopes;
        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {
             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[Scopes]]""));
             properties->Set(properties->Length(), scopes);
         }
    }
    return properties;
}
"," v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)
{
    v8::Local<v8::Array> properties;
    if (!v8::Debug::GetInternalProperties(m_isolate, value).ToLocal(&properties))
        return v8::MaybeLocal<v8::Array>();
    if (value->IsFunction()) {
        v8::Local<v8::Function> function = value.As<v8::Function>();
        v8::Local<v8::Value> location = functionLocation(context, function);
        if (location->IsObject()) {
            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[FunctionLocation]]""));
            properties->Set(properties->Length(), location);
        }
        if (function->IsGeneratorFunction()) {
            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[IsGenerator]]""));
            properties->Set(properties->Length(), v8::True(m_isolate));
        }
    }
    if (!enabled())
        return properties;
    if (value->IsMap() || value->IsWeakMap() || value->IsSet() || value->IsWeakSet() || value->IsSetIterator() || value->IsMapIterator()) {
        v8::Local<v8::Value> entries = collectionEntries(context, v8::Local<v8::Object>::Cast(value));
        if (entries->IsArray()) {
            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[Entries]]""));
            properties->Set(properties->Length(), entries);
         }
     }
     if (value->IsGeneratorObject()) {
        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));
         if (location->IsObject()) {
             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[GeneratorLocation]]""));
             properties->Set(properties->Length(), location);
        }
    }
    if (value->IsFunction()) {
         v8::Local<v8::Function> function = value.As<v8::Function>();
         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();
         v8::Local<v8::Value> scopes;
        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {
             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[Scopes]]""));
             properties->Set(properties->Length(), scopes);
         }
    }
    return properties;
}
",C,"        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));
        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {
","        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));
        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {
",,"@@ -12,6 +12,7 @@
 #include ""platform/v8_inspector/V8InternalValueType.h""
 #include ""platform/v8_inspector/V8StackTraceImpl.h""
 #include ""platform/v8_inspector/V8StringUtil.h""
+#include ""platform/v8_inspector/V8ValueCopier.h""
 #include ""platform/v8_inspector/public/V8InspectorClient.h""
 
 namespace v8_inspector {
@@ -581,25 +582,24 @@ v8::Local<v8::Context> V8Debugger::debuggerContext() const
     return m_debuggerContext.Get(m_isolate);
 }
 
-v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)
+v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));
     }
     v8::Local<v8::Value> argv[] = { function };
     v8::Local<v8::Value> scopesValue;
-    if (!callDebuggerMethod(""getFunctionScopes"", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())
+    if (!callDebuggerMethod(""getFunctionScopes"", 1, argv).ToLocal(&scopesValue))
         return v8::MaybeLocal<v8::Value>();
-    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();
-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
-    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))
+    v8::Local<v8::Value> copied;
+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())
         return v8::MaybeLocal<v8::Value>();
-    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))
+    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))
         return v8::MaybeLocal<v8::Value>();
-    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
-        return v8::Undefined(m_isolate);
-    return scopes;
+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))
+        return v8::MaybeLocal<v8::Value>();
+    return copied;
 }
 
 v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)
@@ -629,7 +629,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>
         }
     }
     if (value->IsGeneratorObject()) {
-        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));
+        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));
         if (location->IsObject()) {
             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[GeneratorLocation]]""));
             properties->Set(properties->Length(), location);
@@ -639,7 +639,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>
         v8::Local<v8::Function> function = value.As<v8::Function>();
         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();
         v8::Local<v8::Value> scopes;
-        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {
+        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {
             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[Scopes]]""));
             properties->Set(properties->Length(), scopes);
         }
@@ -655,30 +655,28 @@ v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> contex
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> entriesValue = callDebuggerMethod(""getCollectionEntries"", 1, argv).ToLocalChecked();
-    if (!entriesValue->IsArray())
-        return v8::Undefined(m_isolate);
-    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();
-    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))
+    v8::Local<v8::Value> copied;
+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())
         return v8::Undefined(m_isolate);
-    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))
         return v8::Undefined(m_isolate);
-    return entries;
+    return copied;
 }
 
-v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)
+v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Null(m_isolate);
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> location = callDebuggerMethod(""getGeneratorObjectLocation"", 1, argv).ToLocalChecked();
-    if (!location->IsObject())
+    v8::Local<v8::Value> copied;
+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())
         return v8::Null(m_isolate);
-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
-    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))
+    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))
         return v8::Null(m_isolate);
-    return location;
+    return copied;
 }
 
 v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
@@ -691,6 +689,8 @@ v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context
     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)
         return v8::Null(m_isolate);
     v8::Local<v8::Object> location = v8::Object::New(m_isolate);
+    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))
+        return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""scriptId""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))
         return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""lineNumber""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))",Chrome,93bc623489bdcfc7e9127614fcfb3258edf3f0f9,04c479295e7c67a27ea4a51a5d58436f44542f58,1," v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)
{
    v8::Local<v8::Array> properties;
    if (!v8::Debug::GetInternalProperties(m_isolate, value).ToLocal(&properties))
        return v8::MaybeLocal<v8::Array>();
    if (value->IsFunction()) {
        v8::Local<v8::Function> function = value.As<v8::Function>();
        v8::Local<v8::Value> location = functionLocation(context, function);
        if (location->IsObject()) {
            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[FunctionLocation]]""));
            properties->Set(properties->Length(), location);
        }
        if (function->IsGeneratorFunction()) {
            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[IsGenerator]]""));
            properties->Set(properties->Length(), v8::True(m_isolate));
        }
    }
    if (!enabled())
        return properties;
    if (value->IsMap() || value->IsWeakMap() || value->IsSet() || value->IsWeakSet() || value->IsSetIterator() || value->IsMapIterator()) {
        v8::Local<v8::Value> entries = collectionEntries(context, v8::Local<v8::Object>::Cast(value));
        if (entries->IsArray()) {
            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[Entries]]""));
            properties->Set(properties->Length(), entries);
         }
     }
     if (value->IsGeneratorObject()) {
//flaw_line_below:
        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));
//fix_flaw_line_below:
//        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));
         if (location->IsObject()) {
             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[GeneratorLocation]]""));
             properties->Set(properties->Length(), location);
        }
    }
    if (value->IsFunction()) {
         v8::Local<v8::Function> function = value.As<v8::Function>();
         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();
         v8::Local<v8::Value> scopes;
//flaw_line_below:
        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {
//fix_flaw_line_below:
//        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {
             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, ""[[Scopes]]""));
             properties->Set(properties->Length(), scopes);
         }
    }
    return properties;
}
"
8246,185982,,Remote,Not required,,CVE-2016-5164,https://www.cvedetails.com/cve/CVE-2016-5164/,CWE-79,Medium,,Partial,,2016-09-11,4.3,"Cross-site scripting (XSS) vulnerability in WebKit/Source/platform/v8_inspector/V8Debugger.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to inject arbitrary web script or HTML into the Developer Tools (aka DevTools) subsystem via a crafted web site, aka *Universal XSS (UXSS).*",2018-10-30,XSS ,2,https://github.com/chromium/chromium/commit/93bc623489bdcfc7e9127614fcfb3258edf3f0f9,93bc623489bdcfc7e9127614fcfb3258edf3f0f9,"[DevTools] Copy objects from debugger context to inspected context properly.

BUG=637594

Review-Url: https://codereview.chromium.org/2253643002
Cr-Commit-Position: refs/heads/master@{#412436}",0,third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp,"{""sha"": ""2c2187b08bb5c2340fde0bae42f64e30e2d45ef8"", ""filename"": ""third_party/WebKit/Source/platform/blink_platform.gypi"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/blink_platform.gypi"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/blink_platform.gypi"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/blink_platform.gypi?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -1176,6 +1176,8 @@\n       'v8_inspector/V8StackTraceImpl.h',\n       'v8_inspector/V8StringUtil.cpp',\n       'v8_inspector/V8StringUtil.h',\n+      'v8_inspector/V8ValueCopier.cpp',\n+      'v8_inspector/V8ValueCopier.h',\n       'v8_inspector/public/V8ContextInfo.h',\n       'v8_inspector/public/V8Inspector.h',\n       'v8_inspector/public/V8InspectorClient.h',""}<_**next**_>{""sha"": ""73a90e225e11aeac62626e36a217ceaa5b2ecf51"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Console.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -659,6 +659,8 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> console = v8::Object::New(isolate);\n+    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, console, \""debug\"", V8Console::debugCallback);\n     createBoundFunctionProperty(context, console, \""error\"", V8Console::errorCallback);\n@@ -684,9 +686,6 @@ v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContex\n     createBoundFunctionProperty(context, console, \""timeEnd\"", V8Console::timeEndCallback);\n     createBoundFunctionProperty(context, console, \""timeStamp\"", V8Console::timeStampCallback);\n \n-    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n-    DCHECK(success);\n-\n     if (hasMemoryAttribute)\n         console->SetAccessorProperty(toV8StringInternalized(isolate, \""memory\""), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);\n \n@@ -707,6 +706,8 @@ v8::Local<v8::Object> V8Console::createCommandLineAPI(InspectedContext* inspecte\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> commandLineAPI = v8::Object::New(isolate);\n+    bool success = commandLineAPI->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, commandLineAPI, \""dir\"", V8Console::dirCallback, \""function dir(value) { [Command Line API] }\"");\n     createBoundFunctionProperty(context, commandLineAPI, \""dirxml\"", V8Console::dirxmlCallback, \""function dirxml(value) { [Command Line API] }\"");""}<_**next**_>{""sha"": ""616bfbe7e474266857090c3ac0f420a9467afbdb"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 22, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -12,6 +12,7 @@\n #include \""platform/v8_inspector/V8InternalValueType.h\""\n #include \""platform/v8_inspector/V8StackTraceImpl.h\""\n #include \""platform/v8_inspector/V8StringUtil.h\""\n+#include \""platform/v8_inspector/V8ValueCopier.h\""\n #include \""platform/v8_inspector/public/V8InspectorClient.h\""\n \n namespace v8_inspector {\n@@ -581,25 +582,24 @@ v8::Local<v8::Context> V8Debugger::debuggerContext() const\n     return m_debuggerContext.Get(m_isolate);\n }\n \n-v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)\n+v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));\n     }\n     v8::Local<v8::Value> argv[] = { function };\n     v8::Local<v8::Value> scopesValue;\n-    if (!callDebuggerMethod(\""getFunctionScopes\"", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())\n+    if (!callDebuggerMethod(\""getFunctionScopes\"", 1, argv).ToLocal(&scopesValue))\n         return v8::MaybeLocal<v8::Value>();\n-    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::MaybeLocal<v8::Value>();\n-    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))\n+    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))\n         return v8::MaybeLocal<v8::Value>();\n-    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n-        return v8::Undefined(m_isolate);\n-    return scopes;\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))\n+        return v8::MaybeLocal<v8::Value>();\n+    return copied;\n }\n \n v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)\n@@ -629,7 +629,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>\n         }\n     }\n     if (value->IsGeneratorObject()) {\n-        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));\n+        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));\n         if (location->IsObject()) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \""[[GeneratorLocation]]\""));\n             properties->Set(properties->Length(), location);\n@@ -639,7 +639,7 @@ v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context>\n         v8::Local<v8::Function> function = value.As<v8::Function>();\n         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();\n         v8::Local<v8::Value> scopes;\n-        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {\n+        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \""[[Scopes]]\""));\n             properties->Set(properties->Length(), scopes);\n         }\n@@ -655,30 +655,28 @@ v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> contex\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> entriesValue = callDebuggerMethod(\""getCollectionEntries\"", 1, argv).ToLocalChecked();\n-    if (!entriesValue->IsArray())\n-        return v8::Undefined(m_isolate);\n-    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();\n-    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::Undefined(m_isolate);\n-    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))\n         return v8::Undefined(m_isolate);\n-    return entries;\n+    return copied;\n }\n \n-v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)\n+v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Null(m_isolate);\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> location = callDebuggerMethod(\""getGeneratorObjectLocation\"", 1, argv).ToLocalChecked();\n-    if (!location->IsObject())\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())\n         return v8::Null(m_isolate);\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))\n+    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))\n         return v8::Null(m_isolate);\n-    return location;\n+    return copied;\n }\n \n v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n@@ -691,6 +689,8 @@ v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context\n     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)\n         return v8::Null(m_isolate);\n     v8::Local<v8::Object> location = v8::Object::New(m_isolate);\n+    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+        return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \""scriptId\""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))\n         return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \""lineNumber\""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))""}<_**next**_>{""sha"": ""02e762eb01c420f407ca4476c9c6bc642d12521b"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8Debugger.h?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -76,7 +76,6 @@ class V8Debugger {\n     std::unique_ptr<V8StackTraceImpl> createStackTrace(v8::Local<v8::StackTrace>);\n     std::unique_ptr<V8StackTraceImpl> captureStackTrace(bool fullStack);\n \n-    v8::MaybeLocal<v8::Value> functionScopes(v8::Local<v8::Function>);\n     v8::MaybeLocal<v8::Array> internalProperties(v8::Local<v8::Context>, v8::Local<v8::Value>);\n \n     void asyncTaskScheduled(const String16& taskName, void* task, bool recurring);\n@@ -102,8 +101,9 @@ class V8Debugger {\n     void handleV8AsyncTaskEvent(v8::Local<v8::Context>, v8::Local<v8::Object> executionState, v8::Local<v8::Object> eventData);\n \n     v8::Local<v8::Value> collectionEntries(v8::Local<v8::Context>, v8::Local<v8::Object>);\n-    v8::Local<v8::Value> generatorObjectLocation(v8::Local<v8::Object>);\n+    v8::Local<v8::Value> generatorObjectLocation(v8::Local<v8::Context>, v8::Local<v8::Object>);\n     v8::Local<v8::Value> functionLocation(v8::Local<v8::Context>, v8::Local<v8::Function>);\n+    v8::MaybeLocal<v8::Value> functionScopes(v8::Local<v8::Context>, v8::Local<v8::Function>);\n \n     v8::Isolate* m_isolate;\n     V8InspectorImpl* m_inspector;""}<_**next**_>{""sha"": ""782e5bbab014739c75726871ec7dc193b38f4843"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8InjectedScriptHost.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -42,6 +42,8 @@ v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> contex\n {\n     v8::Isolate* isolate = inspector->isolate();\n     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);\n+    bool success = injectedScriptHost->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);\n     setFunctionProperty(context, injectedScriptHost, \""internalConstructorName\"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);\n     setFunctionProperty(context, injectedScriptHost, \""formatAccessorsAsProperties\"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);""}<_**next**_>{""sha"": ""3347abeba5929aa7c15fa3c05afc4c3072a8232c"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""status"": ""added"", ""additions"": 90, ""deletions"": 0, ""changes"": 90, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.cpp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -0,0 +1,90 @@\n+// Copyright 2016 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""platform/v8_inspector/V8ValueCopier.h\""\n+\n+namespace v8_inspector {\n+\n+namespace {\n+\n+static int kMaxDepth = 20;\n+static int kMaxCalls = 1000;\n+\n+class V8ValueCopier {\n+public:\n+    v8::MaybeLocal<v8::Value> copy(v8::Local<v8::Value> value, int depth)\n+    {\n+        if (++m_calls > kMaxCalls || depth > kMaxDepth)\n+            return v8::MaybeLocal<v8::Value>();\n+\n+        if (value.IsEmpty())\n+            return v8::MaybeLocal<v8::Value>();\n+        if (value->IsNull() || value->IsUndefined() || value->IsBoolean() || value->IsString() || value->IsNumber())\n+            return value;\n+        if (!value->IsObject())\n+            return v8::MaybeLocal<v8::Value>();\n+        v8::Local<v8::Object> object = value.As<v8::Object>();\n+        if (object->CreationContext() != m_from)\n+            return value;\n+\n+        if (object->IsArray()) {\n+            v8::Local<v8::Array> array = object.As<v8::Array>();\n+            v8::Local<v8::Array> result = v8::Array::New(m_isolate, array->Length());\n+            if (!result->SetPrototype(m_to, v8::Null(m_isolate)).FromMaybe(false))\n+                return v8::MaybeLocal<v8::Value>();\n+            for (size_t i = 0; i < array->Length(); ++i) {\n+                v8::Local<v8::Value> item;\n+                if (!array->Get(m_from, i).ToLocal(&item))\n+                    return v8::MaybeLocal<v8::Value>();\n+                v8::Local<v8::Value> copied;\n+                if (!copy(item, depth + 1).ToLocal(&copied))\n+                    return v8::MaybeLocal<v8::Value>();\n+                if (!result->Set(m_to, i, copied).FromMaybe(false))\n+                    return v8::MaybeLocal<v8::Value>();\n+            }\n+            return result;\n+        }\n+\n+\n+        v8::Local<v8::Object> result = v8::Object::New(m_isolate);\n+        if (!result->SetPrototype(m_to, v8::Null(m_isolate)).FromMaybe(false))\n+            return v8::MaybeLocal<v8::Value>();\n+        v8::Local<v8::Array> properties;\n+        if (!object->GetOwnPropertyNames(m_from).ToLocal(&properties))\n+            return v8::MaybeLocal<v8::Value>();\n+        for (size_t i = 0; i < properties->Length(); ++i) {\n+            v8::Local<v8::Value> name;\n+            if (!properties->Get(m_from, i).ToLocal(&name) || !name->IsString())\n+                return v8::MaybeLocal<v8::Value>();\n+            v8::Local<v8::Value> property;\n+            if (!object->Get(m_from, name).ToLocal(&property))\n+                return v8::MaybeLocal<v8::Value>();\n+            v8::Local<v8::Value> copied;\n+            if (!copy(property, depth + 1).ToLocal(&copied))\n+                return v8::MaybeLocal<v8::Value>();\n+            if (!result->Set(m_to, name, copied).FromMaybe(false))\n+                return v8::MaybeLocal<v8::Value>();\n+        }\n+        return result;\n+    }\n+\n+    v8::Isolate* m_isolate;\n+    v8::Local<v8::Context> m_from;\n+    v8::Local<v8::Context> m_to;\n+    int m_calls;\n+};\n+\n+} // namespace\n+\n+v8::MaybeLocal<v8::Value> copyValueFromDebuggerContext(v8::Isolate* isolate, v8::Local<v8::Context> debuggerContext, v8::Local<v8::Context> toContext, v8::Local<v8::Value> value)\n+{\n+    V8ValueCopier copier;\n+    copier.m_isolate = isolate;\n+    copier.m_from = debuggerContext;\n+    copier.m_to = toContext;\n+    copier.m_calls = 0;\n+    return copier.copy(value, 0);\n+}\n+\n+} // namespace v8_inspector""}<_**next**_>{""sha"": ""9cd650cc80168bb4f8379cb44dd6000881deeab7"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/V8ValueCopier.h?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -0,0 +1,16 @@\n+// Copyright 2016 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef V8ValueCopier_h\n+#define V8ValueCopier_h\n+\n+#include <v8.h>\n+\n+namespace v8_inspector {\n+\n+v8::MaybeLocal<v8::Value> copyValueFromDebuggerContext(v8::Isolate*, v8::Local<v8::Context> debuggerContext, v8::Local<v8::Context> toContext, v8::Local<v8::Value>);\n+\n+} // namespace v8_inspector\n+\n+#endif // !defined(V8ValueCopier_h)""}<_**next**_>{""sha"": ""3c496be8f6252b226fcca829b1d00b39422dc14b"", ""filename"": ""third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/93bc623489bdcfc7e9127614fcfb3258edf3f0f9/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/v8_inspector/v8_inspector.gyp?ref=93bc623489bdcfc7e9127614fcfb3258edf3f0f9"", ""patch"": ""@@ -294,6 +294,8 @@\n         'V8StackTraceImpl.h',\n         'V8StringUtil.cpp',\n         'V8StringUtil.h',\n+        'V8ValueCopier.cpp',\n+        'V8ValueCopier.h',\n         'public/V8EventListenerInfo.h',\n         'public/V8ContextInfo.h',\n         'public/V8Inspector.h',""}","v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> context, V8InspectorImpl* inspector)
 {
     v8::Isolate* isolate = inspector->isolate();
     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);
    bool success = injectedScriptHost->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);
    DCHECK(success);
     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);
     setFunctionProperty(context, injectedScriptHost, ""internalConstructorName"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);
     setFunctionProperty(context, injectedScriptHost, ""formatAccessorsAsProperties"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""subtype"", V8InjectedScriptHost::subtypeCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""getInternalProperties"", V8InjectedScriptHost::getInternalPropertiesCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""objectHasOwnProperty"", V8InjectedScriptHost::objectHasOwnPropertyCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""bind"", V8InjectedScriptHost::bindCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""proxyTargetValue"", V8InjectedScriptHost::proxyTargetValueCallback, debuggerExternal);
    return injectedScriptHost;
}
","v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> context, V8InspectorImpl* inspector)
 {
     v8::Isolate* isolate = inspector->isolate();
     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);
     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);
     setFunctionProperty(context, injectedScriptHost, ""internalConstructorName"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);
     setFunctionProperty(context, injectedScriptHost, ""formatAccessorsAsProperties"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""subtype"", V8InjectedScriptHost::subtypeCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""getInternalProperties"", V8InjectedScriptHost::getInternalPropertiesCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""objectHasOwnProperty"", V8InjectedScriptHost::objectHasOwnPropertyCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""bind"", V8InjectedScriptHost::bindCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""proxyTargetValue"", V8InjectedScriptHost::proxyTargetValueCallback, debuggerExternal);
    return injectedScriptHost;
}
",C,"    bool success = injectedScriptHost->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);
    DCHECK(success);
",,,"@@ -42,6 +42,8 @@ v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> contex
 {
     v8::Isolate* isolate = inspector->isolate();
     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);
+    bool success = injectedScriptHost->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);
+    DCHECK(success);
     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);
     setFunctionProperty(context, injectedScriptHost, ""internalConstructorName"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);
     setFunctionProperty(context, injectedScriptHost, ""formatAccessorsAsProperties"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);",Chrome,93bc623489bdcfc7e9127614fcfb3258edf3f0f9,04c479295e7c67a27ea4a51a5d58436f44542f58,1,"v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> context, V8InspectorImpl* inspector)
 {
     v8::Isolate* isolate = inspector->isolate();
     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);
//fix_flaw_line_below:
//    bool success = injectedScriptHost->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);
//fix_flaw_line_below:
//    DCHECK(success);
     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);
     setFunctionProperty(context, injectedScriptHost, ""internalConstructorName"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);
     setFunctionProperty(context, injectedScriptHost, ""formatAccessorsAsProperties"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""subtype"", V8InjectedScriptHost::subtypeCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""getInternalProperties"", V8InjectedScriptHost::getInternalPropertiesCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""objectHasOwnProperty"", V8InjectedScriptHost::objectHasOwnPropertyCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""bind"", V8InjectedScriptHost::bindCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""proxyTargetValue"", V8InjectedScriptHost::proxyTargetValueCallback, debuggerExternal);
    return injectedScriptHost;
}
"
8247,185983,,Remote,Not required,,CVE-2016-5165,https://www.cvedetails.com/cve/CVE-2016-5165/,CWE-79,Medium,,Partial,,2016-09-11,4.3,Cross-site scripting (XSS) vulnerability in the Developer Tools (aka DevTools) subsystem in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux allows remote attackers to inject arbitrary web script or HTML via the settings parameter in a chrome-devtools-frontend.appspot.com URL's query string.,2018-10-30,XSS ,3,https://github.com/chromium/chromium/commit/19b8593007150b9a78da7d13f6e5f8feb10881a7,19b8593007150b9a78da7d13f6e5f8feb10881a7,"Add CPU metrics provider and Add CPU/GPU provider for UKM.

Bug: 907674
Change-Id: I61b88aeac8d2a7ff81d812fa5a267f48203ec7e2
Reviewed-on: https://chromium-review.googlesource.com/c/1381376
Commit-Queue: Nik Bhagat <nikunjb@chromium.org>
Reviewed-by: Robert Kaplow <rkaplow@chromium.org>
Cr-Commit-Position: refs/heads/master@{#618037}",0,chrome/browser/metrics/chrome_metrics_service_client.cc,"{""sha"": ""6bfa3bc75563eb09dc6d18a58d8454f7e524b5a4"", ""filename"": ""chrome/browser/metrics/chrome_metrics_service_client.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/chrome/browser/metrics/chrome_metrics_service_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/chrome/browser/metrics/chrome_metrics_service_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/metrics/chrome_metrics_service_client.cc?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -65,6 +65,7 @@\n #include \""components/history/core/browser/history_service.h\""\n #include \""components/metrics/call_stack_profile_metrics_provider.h\""\n #include \""components/metrics/component_metrics_provider.h\""\n+#include \""components/metrics/cpu_metrics_provider.h\""\n #include \""components/metrics/drive_metrics_provider.h\""\n #include \""components/metrics/field_trials_provider.h\""\n #include \""components/metrics/gpu/gpu_metrics_provider.h\""\n@@ -625,6 +626,9 @@ void ChromeMetricsServiceClient::RegisterMetricsServiceProviders() {\n   metrics_service_->RegisterMetricsProvider(\n       std::make_unique<metrics::GPUMetricsProvider>());\n \n+  metrics_service_->RegisterMetricsProvider(\n+      std::make_unique<metrics::CPUMetricsProvider>());\n+\n   metrics_service_->RegisterMetricsProvider(\n       std::make_unique<metrics::ScreenInfoMetricsProvider>());\n \n@@ -744,6 +748,15 @@ void ChromeMetricsServiceClient::RegisterUKMProviders() {\n       std::make_unique<ChromeOSMetricsProvider>());\n #endif  // !defined(OS_CHROMEOS)\n \n+  metrics_service_->RegisterMetricsProvider(\n+      std::make_unique<metrics::GPUMetricsProvider>());\n+\n+  metrics_service_->RegisterMetricsProvider(\n+      std::make_unique<metrics::CPUMetricsProvider>());\n+\n+  metrics_service_->RegisterMetricsProvider(\n+      std::make_unique<metrics::ScreenInfoMetricsProvider>());\n+\n   // TODO(rkaplow): Support synthetic trials for UKM.\n   ukm_service_->RegisterMetricsProvider(\n       std::make_unique<variations::FieldTrialsProvider>(nullptr,""}<_**next**_>{""sha"": ""1b8eb95706b53758fa8673458cac033b281d5291"", ""filename"": ""components/metrics/BUILD.gn"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/metrics/BUILD.gn?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -15,6 +15,8 @@ jumbo_static_library(\""metrics\"") {\n     \""client_info.h\"",\n     \""cloned_install_detector.cc\"",\n     \""cloned_install_detector.h\"",\n+    \""cpu_metrics_provider.cc\"",\n+    \""cpu_metrics_provider.h\"",\n     \""daily_event.cc\"",\n     \""daily_event.h\"",\n     \""data_use_tracker.cc\"",""}<_**next**_>{""sha"": ""93af571626e314b7f85ba04833eb95f2875cf67f"", ""filename"": ""components/metrics/cpu_metrics_provider.cc"", ""status"": ""added"", ""additions"": 28, ""deletions"": 0, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/cpu_metrics_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/cpu_metrics_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/metrics/cpu_metrics_provider.cc?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -0,0 +1,28 @@\n+// Copyright 2018 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""components/metrics/cpu_metrics_provider.h\""\n+\n+#include \""base/cpu.h\""\n+#include \""base/system/sys_info.h\""\n+#include \""third_party/metrics_proto/system_profile.pb.h\""\n+\n+namespace metrics {\n+\n+CPUMetricsProvider::CPUMetricsProvider() {}\n+\n+CPUMetricsProvider::~CPUMetricsProvider() {}\n+\n+void CPUMetricsProvider::ProvideSystemProfileMetrics(\n+    SystemProfileProto* system_profile) {\n+  SystemProfileProto::Hardware::CPU* cpu =\n+      system_profile->mutable_hardware()->mutable_cpu();\n+  // All the CPU information is generated in the constructor.\n+  base::CPU cpu_info;\n+  cpu->set_vendor_name(cpu_info.vendor_name());\n+  cpu->set_signature(cpu_info.signature());\n+  cpu->set_num_cores(base::SysInfo::NumberOfProcessors());\n+}\n+\n+}  // namespace metrics""}<_**next**_>{""sha"": ""067822bd2bf6cbe2e10e99adaff70a9c2184f67e"", ""filename"": ""components/metrics/cpu_metrics_provider.h"", ""status"": ""added"", ""additions"": 30, ""deletions"": 0, ""changes"": 30, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/cpu_metrics_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/cpu_metrics_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/metrics/cpu_metrics_provider.h?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -0,0 +1,30 @@\n+// Copyright 2018 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef COMPONENTS_METRICS_CPU_METRICS_PROVIDER_H_\n+#define COMPONENTS_METRICS_CPU_METRICS_PROVIDER_H_\n+\n+#include \""base/macros.h\""\n+#include \""components/metrics/metrics_provider.h\""\n+\n+namespace metrics {\n+\n+// CPUMetricsProvider adds CPU Info in the system profile. These include\n+// CPU vendor information, cpu cores, etc. This doesn't provide CPU usage\n+// information.\n+class CPUMetricsProvider : public MetricsProvider {\n+ public:\n+  CPUMetricsProvider();\n+  ~CPUMetricsProvider() override;\n+\n+  void ProvideSystemProfileMetrics(\n+      SystemProfileProto* system_profile_proto) override;\n+\n+ private:\n+  DISALLOW_COPY_AND_ASSIGN(CPUMetricsProvider);\n+};\n+\n+}  // namespace metrics\n+\n+#endif  // COMPONENTS_METRICS_CPU_METRICS_PROVIDER_H_""}<_**next**_>{""sha"": ""18c6f9d7aef4c56b16645db0eacc7a3e94edd4f1"", ""filename"": ""components/metrics/metrics_log.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/metrics_log.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/metrics_log.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/metrics/metrics_log.cc?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -296,13 +296,6 @@ const SystemProfileProto& MetricsLog::RecordEnvironment(\n   if (client_->GetBrand(&brand_code))\n     system_profile->set_brand_code(brand_code);\n \n-  SystemProfileProto::Hardware::CPU* cpu =\n-      system_profile->mutable_hardware()->mutable_cpu();\n-  base::CPU cpu_info;\n-  cpu->set_vendor_name(cpu_info.vendor_name());\n-  cpu->set_signature(cpu_info.signature());\n-  cpu->set_num_cores(base::SysInfo::NumberOfProcessors());\n-\n   delegating_provider->ProvideSystemProfileMetrics(system_profile);\n \n   return *system_profile;""}<_**next**_>{""sha"": ""752991aabb1b5db4011ba4e6978152c47193491e"", ""filename"": ""components/metrics/metrics_log_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/metrics_log_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/metrics_log_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/metrics/metrics_log_unittest.cc?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -18,6 +18,7 @@\n #include \""base/strings/stringprintf.h\""\n #include \""base/system/sys_info.h\""\n #include \""base/time/time.h\""\n+#include \""components/metrics/cpu_metrics_provider.h\""\n #include \""components/metrics/delegating_provider.h\""\n #include \""components/metrics/environment_recorder.h\""\n #include \""components/metrics/metrics_pref_names.h\""\n@@ -237,6 +238,8 @@ TEST_F(MetricsLogTest, RecordEnvironment) {\n   TestMetricsLog log(kClientId, kSessionId, MetricsLog::ONGOING_LOG, &client);\n \n   DelegatingProvider delegating_provider;\n+  auto cpu_provider = std::make_unique<metrics::CPUMetricsProvider>();\n+  delegating_provider.RegisterMetricsProvider(std::move(cpu_provider));\n   log.RecordEnvironment(&delegating_provider);\n   // Check that the system profile on the log has the correct values set.\n   CheckSystemProfile(log.system_profile());""}","void ChromeMetricsServiceClient::RegisterMetricsServiceProviders() {
  PrefService* local_state = g_browser_process->local_state();

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<SubprocessMetricsProvider>());

#if BUILDFLAG(ENABLE_EXTENSIONS)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<ExtensionsMetricsProvider>(metrics_state_manager_));
#endif

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::NetworkMetricsProvider>(
          content::CreateNetworkConnectionTrackerAsyncGetter(),
          std::make_unique<metrics::NetworkQualityEstimatorProviderImpl>()));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<OmniboxMetricsProvider>(
          base::Bind(&chrome::IsIncognitoSessionActive)));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<ChromeStabilityMetricsProvider>(local_state));

   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::GPUMetricsProvider>());
 
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::CPUMetricsProvider>());

   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::ScreenInfoMetricsProvider>());
 
  metrics_service_->RegisterMetricsProvider(CreateFileMetricsProvider(
      metrics_state_manager_->IsMetricsReportingEnabled()));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::DriveMetricsProvider>(
          chrome::FILE_LOCAL_STATE));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::CallStackProfileMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::SamplingMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<translate::TranslateRankerMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::ComponentMetricsProvider>(
          g_browser_process->component_updater()));

#if defined(OS_ANDROID)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<AndroidMetricsProvider>());
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<PageLoadMetricsProvider>());
#endif  // defined(OS_ANDROID)

#if defined(OS_WIN)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<GoogleUpdateMetricsProviderWin>());

  base::FilePath user_data_dir;
  base::FilePath crash_dir;
  if (!base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir) ||
      !base::PathService::Get(chrome::DIR_CRASH_DUMPS, &crash_dir)) {
    user_data_dir = base::FilePath();
    crash_dir = base::FilePath();
  }
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<browser_watcher::WatcherMetricsProviderWin>(
          chrome::GetBrowserExitCodesRegistryPath(), user_data_dir, crash_dir,
          base::Bind(&GetExecutableVersionDetails)));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<AntiVirusMetricsProvider>());
#endif  // defined(OS_WIN)

#if BUILDFLAG(ENABLE_PLUGINS)
  plugin_metrics_provider_ = new PluginMetricsProvider(local_state);
  metrics_service_->RegisterMetricsProvider(
      std::unique_ptr<metrics::MetricsProvider>(plugin_metrics_provider_));
#endif  // BUILDFLAG(ENABLE_PLUGINS)

#if defined(OS_CHROMEOS)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<ChromeOSMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<SigninStatusMetricsProviderChromeOS>());

  if (metrics::GetMetricsReportingDefaultState(local_state) ==
      metrics::EnableMetricsDefault::DEFAULT_UNKNOWN) {
    metrics::RecordMetricsReportingDefaultState(
        local_state, metrics::EnableMetricsDefault::OPT_OUT);
  }

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<chromeos::PrinterMetricsProvider>());
#endif  // defined(OS_CHROMEOS)

#if !defined(OS_CHROMEOS)
  metrics_service_->RegisterMetricsProvider(
      SigninStatusMetricsProvider::CreateInstance(
          std::make_unique<ChromeSigninStatusMetricsProviderDelegate>()));
#endif  // !defined(OS_CHROMEOS)

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<syncer::DeviceCountMetricsProvider>(
          base::Bind(&browser_sync::ChromeSyncClient::GetDeviceInfoTrackers)));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<HttpsEngagementMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<CertificateReportingMetricsProvider>());

#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<UpgradeMetricsProvider>());
#endif  //! defined(OS_ANDROID) && !defined(OS_CHROMEOS)

#if defined(OS_MACOSX)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<PowerMetricsProvider>());
#endif

#if BUILDFLAG(ENABLE_CROS_ASSISTANT)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<AssistantServiceMetricsProvider>());
#endif  // BUILDFLAG(ENABLE_CROS_ASSISTANT)
}
","void ChromeMetricsServiceClient::RegisterMetricsServiceProviders() {
  PrefService* local_state = g_browser_process->local_state();

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<SubprocessMetricsProvider>());

#if BUILDFLAG(ENABLE_EXTENSIONS)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<ExtensionsMetricsProvider>(metrics_state_manager_));
#endif

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::NetworkMetricsProvider>(
          content::CreateNetworkConnectionTrackerAsyncGetter(),
          std::make_unique<metrics::NetworkQualityEstimatorProviderImpl>()));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<OmniboxMetricsProvider>(
          base::Bind(&chrome::IsIncognitoSessionActive)));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<ChromeStabilityMetricsProvider>(local_state));

   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::GPUMetricsProvider>());
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::ScreenInfoMetricsProvider>());
 
  metrics_service_->RegisterMetricsProvider(CreateFileMetricsProvider(
      metrics_state_manager_->IsMetricsReportingEnabled()));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::DriveMetricsProvider>(
          chrome::FILE_LOCAL_STATE));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::CallStackProfileMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::SamplingMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<translate::TranslateRankerMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::ComponentMetricsProvider>(
          g_browser_process->component_updater()));

#if defined(OS_ANDROID)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<AndroidMetricsProvider>());
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<PageLoadMetricsProvider>());
#endif  // defined(OS_ANDROID)

#if defined(OS_WIN)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<GoogleUpdateMetricsProviderWin>());

  base::FilePath user_data_dir;
  base::FilePath crash_dir;
  if (!base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir) ||
      !base::PathService::Get(chrome::DIR_CRASH_DUMPS, &crash_dir)) {
    user_data_dir = base::FilePath();
    crash_dir = base::FilePath();
  }
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<browser_watcher::WatcherMetricsProviderWin>(
          chrome::GetBrowserExitCodesRegistryPath(), user_data_dir, crash_dir,
          base::Bind(&GetExecutableVersionDetails)));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<AntiVirusMetricsProvider>());
#endif  // defined(OS_WIN)

#if BUILDFLAG(ENABLE_PLUGINS)
  plugin_metrics_provider_ = new PluginMetricsProvider(local_state);
  metrics_service_->RegisterMetricsProvider(
      std::unique_ptr<metrics::MetricsProvider>(plugin_metrics_provider_));
#endif  // BUILDFLAG(ENABLE_PLUGINS)

#if defined(OS_CHROMEOS)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<ChromeOSMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<SigninStatusMetricsProviderChromeOS>());

  if (metrics::GetMetricsReportingDefaultState(local_state) ==
      metrics::EnableMetricsDefault::DEFAULT_UNKNOWN) {
    metrics::RecordMetricsReportingDefaultState(
        local_state, metrics::EnableMetricsDefault::OPT_OUT);
  }

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<chromeos::PrinterMetricsProvider>());
#endif  // defined(OS_CHROMEOS)

#if !defined(OS_CHROMEOS)
  metrics_service_->RegisterMetricsProvider(
      SigninStatusMetricsProvider::CreateInstance(
          std::make_unique<ChromeSigninStatusMetricsProviderDelegate>()));
#endif  // !defined(OS_CHROMEOS)

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<syncer::DeviceCountMetricsProvider>(
          base::Bind(&browser_sync::ChromeSyncClient::GetDeviceInfoTrackers)));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<HttpsEngagementMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<CertificateReportingMetricsProvider>());

#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<UpgradeMetricsProvider>());
#endif  //! defined(OS_ANDROID) && !defined(OS_CHROMEOS)

#if defined(OS_MACOSX)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<PowerMetricsProvider>());
#endif

#if BUILDFLAG(ENABLE_CROS_ASSISTANT)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<AssistantServiceMetricsProvider>());
#endif  // BUILDFLAG(ENABLE_CROS_ASSISTANT)
}
",C,"  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::CPUMetricsProvider>());

",,,"@@ -65,6 +65,7 @@
 #include ""components/history/core/browser/history_service.h""
 #include ""components/metrics/call_stack_profile_metrics_provider.h""
 #include ""components/metrics/component_metrics_provider.h""
+#include ""components/metrics/cpu_metrics_provider.h""
 #include ""components/metrics/drive_metrics_provider.h""
 #include ""components/metrics/field_trials_provider.h""
 #include ""components/metrics/gpu/gpu_metrics_provider.h""
@@ -625,6 +626,9 @@ void ChromeMetricsServiceClient::RegisterMetricsServiceProviders() {
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::GPUMetricsProvider>());
 
+  metrics_service_->RegisterMetricsProvider(
+      std::make_unique<metrics::CPUMetricsProvider>());
+
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::ScreenInfoMetricsProvider>());
 
@@ -744,6 +748,15 @@ void ChromeMetricsServiceClient::RegisterUKMProviders() {
       std::make_unique<ChromeOSMetricsProvider>());
 #endif  // !defined(OS_CHROMEOS)
 
+  metrics_service_->RegisterMetricsProvider(
+      std::make_unique<metrics::GPUMetricsProvider>());
+
+  metrics_service_->RegisterMetricsProvider(
+      std::make_unique<metrics::CPUMetricsProvider>());
+
+  metrics_service_->RegisterMetricsProvider(
+      std::make_unique<metrics::ScreenInfoMetricsProvider>());
+
   // TODO(rkaplow): Support synthetic trials for UKM.
   ukm_service_->RegisterMetricsProvider(
       std::make_unique<variations::FieldTrialsProvider>(nullptr,",Chrome,19b8593007150b9a78da7d13f6e5f8feb10881a7,1d937c7a926082670b9025f7a04e62d8fc3128d6,1,"void ChromeMetricsServiceClient::RegisterMetricsServiceProviders() {
  PrefService* local_state = g_browser_process->local_state();

  // Gets access to persistent metrics shared by sub-processes.
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<SubprocessMetricsProvider>());

#if BUILDFLAG(ENABLE_EXTENSIONS)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<ExtensionsMetricsProvider>(metrics_state_manager_));
#endif

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::NetworkMetricsProvider>(
          content::CreateNetworkConnectionTrackerAsyncGetter(),
          std::make_unique<metrics::NetworkQualityEstimatorProviderImpl>()));

  // Currently, we configure OmniboxMetricsProvider to not log events to UMA
  // if there is a single incognito session visible. In the future, it may
  // be worth revisiting this to still log events from non-incognito sessions.
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<OmniboxMetricsProvider>(
          base::Bind(&chrome::IsIncognitoSessionActive)));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<ChromeStabilityMetricsProvider>(local_state));

   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::GPUMetricsProvider>());
 
//fix_flaw_line_below:
//  metrics_service_->RegisterMetricsProvider(
//fix_flaw_line_below:
//      std::make_unique<metrics::CPUMetricsProvider>());
//fix_flaw_line_below:
//
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::ScreenInfoMetricsProvider>());
 
  metrics_service_->RegisterMetricsProvider(CreateFileMetricsProvider(
      metrics_state_manager_->IsMetricsReportingEnabled()));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::DriveMetricsProvider>(
          chrome::FILE_LOCAL_STATE));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::CallStackProfileMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::SamplingMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<translate::TranslateRankerMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::ComponentMetricsProvider>(
          g_browser_process->component_updater()));

#if defined(OS_ANDROID)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<AndroidMetricsProvider>());
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<PageLoadMetricsProvider>());
#endif  // defined(OS_ANDROID)

#if defined(OS_WIN)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<GoogleUpdateMetricsProviderWin>());

  base::FilePath user_data_dir;
  base::FilePath crash_dir;
  if (!base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir) ||
      !base::PathService::Get(chrome::DIR_CRASH_DUMPS, &crash_dir)) {
    // If either call fails, then clear both.
    user_data_dir = base::FilePath();
    crash_dir = base::FilePath();
  }
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<browser_watcher::WatcherMetricsProviderWin>(
          chrome::GetBrowserExitCodesRegistryPath(), user_data_dir, crash_dir,
          base::Bind(&GetExecutableVersionDetails)));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<AntiVirusMetricsProvider>());
#endif  // defined(OS_WIN)

#if BUILDFLAG(ENABLE_PLUGINS)
  plugin_metrics_provider_ = new PluginMetricsProvider(local_state);
  metrics_service_->RegisterMetricsProvider(
      std::unique_ptr<metrics::MetricsProvider>(plugin_metrics_provider_));
#endif  // BUILDFLAG(ENABLE_PLUGINS)

#if defined(OS_CHROMEOS)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<ChromeOSMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<SigninStatusMetricsProviderChromeOS>());

  // Record default UMA state as opt-out for all Chrome OS users, if not
  // recorded yet.
  if (metrics::GetMetricsReportingDefaultState(local_state) ==
      metrics::EnableMetricsDefault::DEFAULT_UNKNOWN) {
    metrics::RecordMetricsReportingDefaultState(
        local_state, metrics::EnableMetricsDefault::OPT_OUT);
  }

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<chromeos::PrinterMetricsProvider>());
#endif  // defined(OS_CHROMEOS)

#if !defined(OS_CHROMEOS)
  metrics_service_->RegisterMetricsProvider(
      SigninStatusMetricsProvider::CreateInstance(
          std::make_unique<ChromeSigninStatusMetricsProviderDelegate>()));
#endif  // !defined(OS_CHROMEOS)

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<syncer::DeviceCountMetricsProvider>(
          base::Bind(&browser_sync::ChromeSyncClient::GetDeviceInfoTrackers)));

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<HttpsEngagementMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<CertificateReportingMetricsProvider>());

#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<UpgradeMetricsProvider>());
#endif  //! defined(OS_ANDROID) && !defined(OS_CHROMEOS)

#if defined(OS_MACOSX)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<PowerMetricsProvider>());
#endif

#if BUILDFLAG(ENABLE_CROS_ASSISTANT)
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<AssistantServiceMetricsProvider>());
#endif  // BUILDFLAG(ENABLE_CROS_ASSISTANT)
}
"
8248,185984,,Remote,Not required,,CVE-2016-5165,https://www.cvedetails.com/cve/CVE-2016-5165/,CWE-79,Medium,,Partial,,2016-09-11,4.3,Cross-site scripting (XSS) vulnerability in the Developer Tools (aka DevTools) subsystem in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux allows remote attackers to inject arbitrary web script or HTML via the settings parameter in a chrome-devtools-frontend.appspot.com URL's query string.,2018-10-30,XSS ,9,https://github.com/chromium/chromium/commit/19b8593007150b9a78da7d13f6e5f8feb10881a7,19b8593007150b9a78da7d13f6e5f8feb10881a7,"Add CPU metrics provider and Add CPU/GPU provider for UKM.

Bug: 907674
Change-Id: I61b88aeac8d2a7ff81d812fa5a267f48203ec7e2
Reviewed-on: https://chromium-review.googlesource.com/c/1381376
Commit-Queue: Nik Bhagat <nikunjb@chromium.org>
Reviewed-by: Robert Kaplow <rkaplow@chromium.org>
Cr-Commit-Position: refs/heads/master@{#618037}",0,chrome/browser/metrics/chrome_metrics_service_client.cc,"{""sha"": ""6bfa3bc75563eb09dc6d18a58d8454f7e524b5a4"", ""filename"": ""chrome/browser/metrics/chrome_metrics_service_client.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/chrome/browser/metrics/chrome_metrics_service_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/chrome/browser/metrics/chrome_metrics_service_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/metrics/chrome_metrics_service_client.cc?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -65,6 +65,7 @@\n #include \""components/history/core/browser/history_service.h\""\n #include \""components/metrics/call_stack_profile_metrics_provider.h\""\n #include \""components/metrics/component_metrics_provider.h\""\n+#include \""components/metrics/cpu_metrics_provider.h\""\n #include \""components/metrics/drive_metrics_provider.h\""\n #include \""components/metrics/field_trials_provider.h\""\n #include \""components/metrics/gpu/gpu_metrics_provider.h\""\n@@ -625,6 +626,9 @@ void ChromeMetricsServiceClient::RegisterMetricsServiceProviders() {\n   metrics_service_->RegisterMetricsProvider(\n       std::make_unique<metrics::GPUMetricsProvider>());\n \n+  metrics_service_->RegisterMetricsProvider(\n+      std::make_unique<metrics::CPUMetricsProvider>());\n+\n   metrics_service_->RegisterMetricsProvider(\n       std::make_unique<metrics::ScreenInfoMetricsProvider>());\n \n@@ -744,6 +748,15 @@ void ChromeMetricsServiceClient::RegisterUKMProviders() {\n       std::make_unique<ChromeOSMetricsProvider>());\n #endif  // !defined(OS_CHROMEOS)\n \n+  metrics_service_->RegisterMetricsProvider(\n+      std::make_unique<metrics::GPUMetricsProvider>());\n+\n+  metrics_service_->RegisterMetricsProvider(\n+      std::make_unique<metrics::CPUMetricsProvider>());\n+\n+  metrics_service_->RegisterMetricsProvider(\n+      std::make_unique<metrics::ScreenInfoMetricsProvider>());\n+\n   // TODO(rkaplow): Support synthetic trials for UKM.\n   ukm_service_->RegisterMetricsProvider(\n       std::make_unique<variations::FieldTrialsProvider>(nullptr,""}<_**next**_>{""sha"": ""1b8eb95706b53758fa8673458cac033b281d5291"", ""filename"": ""components/metrics/BUILD.gn"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/metrics/BUILD.gn?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -15,6 +15,8 @@ jumbo_static_library(\""metrics\"") {\n     \""client_info.h\"",\n     \""cloned_install_detector.cc\"",\n     \""cloned_install_detector.h\"",\n+    \""cpu_metrics_provider.cc\"",\n+    \""cpu_metrics_provider.h\"",\n     \""daily_event.cc\"",\n     \""daily_event.h\"",\n     \""data_use_tracker.cc\"",""}<_**next**_>{""sha"": ""93af571626e314b7f85ba04833eb95f2875cf67f"", ""filename"": ""components/metrics/cpu_metrics_provider.cc"", ""status"": ""added"", ""additions"": 28, ""deletions"": 0, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/cpu_metrics_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/cpu_metrics_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/metrics/cpu_metrics_provider.cc?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -0,0 +1,28 @@\n+// Copyright 2018 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""components/metrics/cpu_metrics_provider.h\""\n+\n+#include \""base/cpu.h\""\n+#include \""base/system/sys_info.h\""\n+#include \""third_party/metrics_proto/system_profile.pb.h\""\n+\n+namespace metrics {\n+\n+CPUMetricsProvider::CPUMetricsProvider() {}\n+\n+CPUMetricsProvider::~CPUMetricsProvider() {}\n+\n+void CPUMetricsProvider::ProvideSystemProfileMetrics(\n+    SystemProfileProto* system_profile) {\n+  SystemProfileProto::Hardware::CPU* cpu =\n+      system_profile->mutable_hardware()->mutable_cpu();\n+  // All the CPU information is generated in the constructor.\n+  base::CPU cpu_info;\n+  cpu->set_vendor_name(cpu_info.vendor_name());\n+  cpu->set_signature(cpu_info.signature());\n+  cpu->set_num_cores(base::SysInfo::NumberOfProcessors());\n+}\n+\n+}  // namespace metrics""}<_**next**_>{""sha"": ""067822bd2bf6cbe2e10e99adaff70a9c2184f67e"", ""filename"": ""components/metrics/cpu_metrics_provider.h"", ""status"": ""added"", ""additions"": 30, ""deletions"": 0, ""changes"": 30, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/cpu_metrics_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/cpu_metrics_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/metrics/cpu_metrics_provider.h?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -0,0 +1,30 @@\n+// Copyright 2018 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef COMPONENTS_METRICS_CPU_METRICS_PROVIDER_H_\n+#define COMPONENTS_METRICS_CPU_METRICS_PROVIDER_H_\n+\n+#include \""base/macros.h\""\n+#include \""components/metrics/metrics_provider.h\""\n+\n+namespace metrics {\n+\n+// CPUMetricsProvider adds CPU Info in the system profile. These include\n+// CPU vendor information, cpu cores, etc. This doesn't provide CPU usage\n+// information.\n+class CPUMetricsProvider : public MetricsProvider {\n+ public:\n+  CPUMetricsProvider();\n+  ~CPUMetricsProvider() override;\n+\n+  void ProvideSystemProfileMetrics(\n+      SystemProfileProto* system_profile_proto) override;\n+\n+ private:\n+  DISALLOW_COPY_AND_ASSIGN(CPUMetricsProvider);\n+};\n+\n+}  // namespace metrics\n+\n+#endif  // COMPONENTS_METRICS_CPU_METRICS_PROVIDER_H_""}<_**next**_>{""sha"": ""18c6f9d7aef4c56b16645db0eacc7a3e94edd4f1"", ""filename"": ""components/metrics/metrics_log.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/metrics_log.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/metrics_log.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/metrics/metrics_log.cc?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -296,13 +296,6 @@ const SystemProfileProto& MetricsLog::RecordEnvironment(\n   if (client_->GetBrand(&brand_code))\n     system_profile->set_brand_code(brand_code);\n \n-  SystemProfileProto::Hardware::CPU* cpu =\n-      system_profile->mutable_hardware()->mutable_cpu();\n-  base::CPU cpu_info;\n-  cpu->set_vendor_name(cpu_info.vendor_name());\n-  cpu->set_signature(cpu_info.signature());\n-  cpu->set_num_cores(base::SysInfo::NumberOfProcessors());\n-\n   delegating_provider->ProvideSystemProfileMetrics(system_profile);\n \n   return *system_profile;""}<_**next**_>{""sha"": ""752991aabb1b5db4011ba4e6978152c47193491e"", ""filename"": ""components/metrics/metrics_log_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/metrics_log_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/metrics_log_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/metrics/metrics_log_unittest.cc?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -18,6 +18,7 @@\n #include \""base/strings/stringprintf.h\""\n #include \""base/system/sys_info.h\""\n #include \""base/time/time.h\""\n+#include \""components/metrics/cpu_metrics_provider.h\""\n #include \""components/metrics/delegating_provider.h\""\n #include \""components/metrics/environment_recorder.h\""\n #include \""components/metrics/metrics_pref_names.h\""\n@@ -237,6 +238,8 @@ TEST_F(MetricsLogTest, RecordEnvironment) {\n   TestMetricsLog log(kClientId, kSessionId, MetricsLog::ONGOING_LOG, &client);\n \n   DelegatingProvider delegating_provider;\n+  auto cpu_provider = std::make_unique<metrics::CPUMetricsProvider>();\n+  delegating_provider.RegisterMetricsProvider(std::move(cpu_provider));\n   log.RecordEnvironment(&delegating_provider);\n   // Check that the system profile on the log has the correct values set.\n   CheckSystemProfile(log.system_profile());""}","void ChromeMetricsServiceClient::RegisterUKMProviders() {
  ukm_service_->RegisterMetricsProvider(
      std::make_unique<metrics::NetworkMetricsProvider>(
          content::CreateNetworkConnectionTrackerAsyncGetter(),
          std::make_unique<metrics::NetworkQualityEstimatorProviderImpl>()));

#if defined(OS_CHROMEOS)
  ukm_service_->RegisterMetricsProvider(
       std::make_unique<ChromeOSMetricsProvider>());
 #endif  // !defined(OS_CHROMEOS)
 
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::GPUMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::CPUMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::ScreenInfoMetricsProvider>());

   ukm_service_->RegisterMetricsProvider(
       std::make_unique<variations::FieldTrialsProvider>(nullptr,
                                                        kUKMFieldTrialSuffix));
}
","void ChromeMetricsServiceClient::RegisterUKMProviders() {
  ukm_service_->RegisterMetricsProvider(
      std::make_unique<metrics::NetworkMetricsProvider>(
          content::CreateNetworkConnectionTrackerAsyncGetter(),
          std::make_unique<metrics::NetworkQualityEstimatorProviderImpl>()));

#if defined(OS_CHROMEOS)
  ukm_service_->RegisterMetricsProvider(
       std::make_unique<ChromeOSMetricsProvider>());
 #endif  // !defined(OS_CHROMEOS)
 
   ukm_service_->RegisterMetricsProvider(
       std::make_unique<variations::FieldTrialsProvider>(nullptr,
                                                        kUKMFieldTrialSuffix));
}
",C,"  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::GPUMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::CPUMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::ScreenInfoMetricsProvider>());

",,,"@@ -65,6 +65,7 @@
 #include ""components/history/core/browser/history_service.h""
 #include ""components/metrics/call_stack_profile_metrics_provider.h""
 #include ""components/metrics/component_metrics_provider.h""
+#include ""components/metrics/cpu_metrics_provider.h""
 #include ""components/metrics/drive_metrics_provider.h""
 #include ""components/metrics/field_trials_provider.h""
 #include ""components/metrics/gpu/gpu_metrics_provider.h""
@@ -625,6 +626,9 @@ void ChromeMetricsServiceClient::RegisterMetricsServiceProviders() {
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::GPUMetricsProvider>());
 
+  metrics_service_->RegisterMetricsProvider(
+      std::make_unique<metrics::CPUMetricsProvider>());
+
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::ScreenInfoMetricsProvider>());
 
@@ -744,6 +748,15 @@ void ChromeMetricsServiceClient::RegisterUKMProviders() {
       std::make_unique<ChromeOSMetricsProvider>());
 #endif  // !defined(OS_CHROMEOS)
 
+  metrics_service_->RegisterMetricsProvider(
+      std::make_unique<metrics::GPUMetricsProvider>());
+
+  metrics_service_->RegisterMetricsProvider(
+      std::make_unique<metrics::CPUMetricsProvider>());
+
+  metrics_service_->RegisterMetricsProvider(
+      std::make_unique<metrics::ScreenInfoMetricsProvider>());
+
   // TODO(rkaplow): Support synthetic trials for UKM.
   ukm_service_->RegisterMetricsProvider(
       std::make_unique<variations::FieldTrialsProvider>(nullptr,",Chrome,19b8593007150b9a78da7d13f6e5f8feb10881a7,1d937c7a926082670b9025f7a04e62d8fc3128d6,1,"void ChromeMetricsServiceClient::RegisterUKMProviders() {
  ukm_service_->RegisterMetricsProvider(
      std::make_unique<metrics::NetworkMetricsProvider>(
          content::CreateNetworkConnectionTrackerAsyncGetter(),
          std::make_unique<metrics::NetworkQualityEstimatorProviderImpl>()));

#if defined(OS_CHROMEOS)
  ukm_service_->RegisterMetricsProvider(
       std::make_unique<ChromeOSMetricsProvider>());
 #endif  // !defined(OS_CHROMEOS)
 
//fix_flaw_line_below:
//  metrics_service_->RegisterMetricsProvider(
//fix_flaw_line_below:
//      std::make_unique<metrics::GPUMetricsProvider>());
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  metrics_service_->RegisterMetricsProvider(
//fix_flaw_line_below:
//      std::make_unique<metrics::CPUMetricsProvider>());
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  metrics_service_->RegisterMetricsProvider(
//fix_flaw_line_below:
//      std::make_unique<metrics::ScreenInfoMetricsProvider>());
//fix_flaw_line_below:
//
   // TODO(rkaplow): Support synthetic trials for UKM.
   ukm_service_->RegisterMetricsProvider(
       std::make_unique<variations::FieldTrialsProvider>(nullptr,
                                                        kUKMFieldTrialSuffix));
}
"
8249,185985,,Remote,Not required,,CVE-2016-5165,https://www.cvedetails.com/cve/CVE-2016-5165/,CWE-79,Medium,,Partial,,2016-09-11,4.3,Cross-site scripting (XSS) vulnerability in the Developer Tools (aka DevTools) subsystem in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux allows remote attackers to inject arbitrary web script or HTML via the settings parameter in a chrome-devtools-frontend.appspot.com URL's query string.,2018-10-30,XSS ,0,https://github.com/chromium/chromium/commit/19b8593007150b9a78da7d13f6e5f8feb10881a7,19b8593007150b9a78da7d13f6e5f8feb10881a7,"Add CPU metrics provider and Add CPU/GPU provider for UKM.

Bug: 907674
Change-Id: I61b88aeac8d2a7ff81d812fa5a267f48203ec7e2
Reviewed-on: https://chromium-review.googlesource.com/c/1381376
Commit-Queue: Nik Bhagat <nikunjb@chromium.org>
Reviewed-by: Robert Kaplow <rkaplow@chromium.org>
Cr-Commit-Position: refs/heads/master@{#618037}",6,components/metrics/metrics_log.cc,"{""sha"": ""6bfa3bc75563eb09dc6d18a58d8454f7e524b5a4"", ""filename"": ""chrome/browser/metrics/chrome_metrics_service_client.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/chrome/browser/metrics/chrome_metrics_service_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/chrome/browser/metrics/chrome_metrics_service_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/metrics/chrome_metrics_service_client.cc?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -65,6 +65,7 @@\n #include \""components/history/core/browser/history_service.h\""\n #include \""components/metrics/call_stack_profile_metrics_provider.h\""\n #include \""components/metrics/component_metrics_provider.h\""\n+#include \""components/metrics/cpu_metrics_provider.h\""\n #include \""components/metrics/drive_metrics_provider.h\""\n #include \""components/metrics/field_trials_provider.h\""\n #include \""components/metrics/gpu/gpu_metrics_provider.h\""\n@@ -625,6 +626,9 @@ void ChromeMetricsServiceClient::RegisterMetricsServiceProviders() {\n   metrics_service_->RegisterMetricsProvider(\n       std::make_unique<metrics::GPUMetricsProvider>());\n \n+  metrics_service_->RegisterMetricsProvider(\n+      std::make_unique<metrics::CPUMetricsProvider>());\n+\n   metrics_service_->RegisterMetricsProvider(\n       std::make_unique<metrics::ScreenInfoMetricsProvider>());\n \n@@ -744,6 +748,15 @@ void ChromeMetricsServiceClient::RegisterUKMProviders() {\n       std::make_unique<ChromeOSMetricsProvider>());\n #endif  // !defined(OS_CHROMEOS)\n \n+  metrics_service_->RegisterMetricsProvider(\n+      std::make_unique<metrics::GPUMetricsProvider>());\n+\n+  metrics_service_->RegisterMetricsProvider(\n+      std::make_unique<metrics::CPUMetricsProvider>());\n+\n+  metrics_service_->RegisterMetricsProvider(\n+      std::make_unique<metrics::ScreenInfoMetricsProvider>());\n+\n   // TODO(rkaplow): Support synthetic trials for UKM.\n   ukm_service_->RegisterMetricsProvider(\n       std::make_unique<variations::FieldTrialsProvider>(nullptr,""}<_**next**_>{""sha"": ""1b8eb95706b53758fa8673458cac033b281d5291"", ""filename"": ""components/metrics/BUILD.gn"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/metrics/BUILD.gn?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -15,6 +15,8 @@ jumbo_static_library(\""metrics\"") {\n     \""client_info.h\"",\n     \""cloned_install_detector.cc\"",\n     \""cloned_install_detector.h\"",\n+    \""cpu_metrics_provider.cc\"",\n+    \""cpu_metrics_provider.h\"",\n     \""daily_event.cc\"",\n     \""daily_event.h\"",\n     \""data_use_tracker.cc\"",""}<_**next**_>{""sha"": ""93af571626e314b7f85ba04833eb95f2875cf67f"", ""filename"": ""components/metrics/cpu_metrics_provider.cc"", ""status"": ""added"", ""additions"": 28, ""deletions"": 0, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/cpu_metrics_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/cpu_metrics_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/metrics/cpu_metrics_provider.cc?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -0,0 +1,28 @@\n+// Copyright 2018 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""components/metrics/cpu_metrics_provider.h\""\n+\n+#include \""base/cpu.h\""\n+#include \""base/system/sys_info.h\""\n+#include \""third_party/metrics_proto/system_profile.pb.h\""\n+\n+namespace metrics {\n+\n+CPUMetricsProvider::CPUMetricsProvider() {}\n+\n+CPUMetricsProvider::~CPUMetricsProvider() {}\n+\n+void CPUMetricsProvider::ProvideSystemProfileMetrics(\n+    SystemProfileProto* system_profile) {\n+  SystemProfileProto::Hardware::CPU* cpu =\n+      system_profile->mutable_hardware()->mutable_cpu();\n+  // All the CPU information is generated in the constructor.\n+  base::CPU cpu_info;\n+  cpu->set_vendor_name(cpu_info.vendor_name());\n+  cpu->set_signature(cpu_info.signature());\n+  cpu->set_num_cores(base::SysInfo::NumberOfProcessors());\n+}\n+\n+}  // namespace metrics""}<_**next**_>{""sha"": ""067822bd2bf6cbe2e10e99adaff70a9c2184f67e"", ""filename"": ""components/metrics/cpu_metrics_provider.h"", ""status"": ""added"", ""additions"": 30, ""deletions"": 0, ""changes"": 30, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/cpu_metrics_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/cpu_metrics_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/metrics/cpu_metrics_provider.h?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -0,0 +1,30 @@\n+// Copyright 2018 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef COMPONENTS_METRICS_CPU_METRICS_PROVIDER_H_\n+#define COMPONENTS_METRICS_CPU_METRICS_PROVIDER_H_\n+\n+#include \""base/macros.h\""\n+#include \""components/metrics/metrics_provider.h\""\n+\n+namespace metrics {\n+\n+// CPUMetricsProvider adds CPU Info in the system profile. These include\n+// CPU vendor information, cpu cores, etc. This doesn't provide CPU usage\n+// information.\n+class CPUMetricsProvider : public MetricsProvider {\n+ public:\n+  CPUMetricsProvider();\n+  ~CPUMetricsProvider() override;\n+\n+  void ProvideSystemProfileMetrics(\n+      SystemProfileProto* system_profile_proto) override;\n+\n+ private:\n+  DISALLOW_COPY_AND_ASSIGN(CPUMetricsProvider);\n+};\n+\n+}  // namespace metrics\n+\n+#endif  // COMPONENTS_METRICS_CPU_METRICS_PROVIDER_H_""}<_**next**_>{""sha"": ""18c6f9d7aef4c56b16645db0eacc7a3e94edd4f1"", ""filename"": ""components/metrics/metrics_log.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/metrics_log.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/metrics_log.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/metrics/metrics_log.cc?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -296,13 +296,6 @@ const SystemProfileProto& MetricsLog::RecordEnvironment(\n   if (client_->GetBrand(&brand_code))\n     system_profile->set_brand_code(brand_code);\n \n-  SystemProfileProto::Hardware::CPU* cpu =\n-      system_profile->mutable_hardware()->mutable_cpu();\n-  base::CPU cpu_info;\n-  cpu->set_vendor_name(cpu_info.vendor_name());\n-  cpu->set_signature(cpu_info.signature());\n-  cpu->set_num_cores(base::SysInfo::NumberOfProcessors());\n-\n   delegating_provider->ProvideSystemProfileMetrics(system_profile);\n \n   return *system_profile;""}<_**next**_>{""sha"": ""752991aabb1b5db4011ba4e6978152c47193491e"", ""filename"": ""components/metrics/metrics_log_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/metrics_log_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/19b8593007150b9a78da7d13f6e5f8feb10881a7/components/metrics/metrics_log_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/metrics/metrics_log_unittest.cc?ref=19b8593007150b9a78da7d13f6e5f8feb10881a7"", ""patch"": ""@@ -18,6 +18,7 @@\n #include \""base/strings/stringprintf.h\""\n #include \""base/system/sys_info.h\""\n #include \""base/time/time.h\""\n+#include \""components/metrics/cpu_metrics_provider.h\""\n #include \""components/metrics/delegating_provider.h\""\n #include \""components/metrics/environment_recorder.h\""\n #include \""components/metrics/metrics_pref_names.h\""\n@@ -237,6 +238,8 @@ TEST_F(MetricsLogTest, RecordEnvironment) {\n   TestMetricsLog log(kClientId, kSessionId, MetricsLog::ONGOING_LOG, &client);\n \n   DelegatingProvider delegating_provider;\n+  auto cpu_provider = std::make_unique<metrics::CPUMetricsProvider>();\n+  delegating_provider.RegisterMetricsProvider(std::move(cpu_provider));\n   log.RecordEnvironment(&delegating_provider);\n   // Check that the system profile on the log has the correct values set.\n   CheckSystemProfile(log.system_profile());""}","const SystemProfileProto& MetricsLog::RecordEnvironment(
    DelegatingProvider* delegating_provider) {
  DCHECK(!has_environment_);
  has_environment_ = true;

  SystemProfileProto* system_profile = uma_proto()->mutable_system_profile();

  WriteMetricsEnableDefault(client_->GetMetricsReportingDefaultState(),
                            system_profile);

  std::string brand_code;
   if (client_->GetBrand(&brand_code))
     system_profile->set_brand_code(brand_code);
 
   delegating_provider->ProvideSystemProfileMetrics(system_profile);
 
   return *system_profile;
}
","const SystemProfileProto& MetricsLog::RecordEnvironment(
    DelegatingProvider* delegating_provider) {
  DCHECK(!has_environment_);
  has_environment_ = true;

  SystemProfileProto* system_profile = uma_proto()->mutable_system_profile();

  WriteMetricsEnableDefault(client_->GetMetricsReportingDefaultState(),
                            system_profile);

  std::string brand_code;
   if (client_->GetBrand(&brand_code))
     system_profile->set_brand_code(brand_code);
 
  SystemProfileProto::Hardware::CPU* cpu =
      system_profile->mutable_hardware()->mutable_cpu();
  base::CPU cpu_info;
  cpu->set_vendor_name(cpu_info.vendor_name());
  cpu->set_signature(cpu_info.signature());
  cpu->set_num_cores(base::SysInfo::NumberOfProcessors());
   delegating_provider->ProvideSystemProfileMetrics(system_profile);
 
   return *system_profile;
}
",C,,"  SystemProfileProto::Hardware::CPU* cpu =
      system_profile->mutable_hardware()->mutable_cpu();
  base::CPU cpu_info;
  cpu->set_vendor_name(cpu_info.vendor_name());
  cpu->set_signature(cpu_info.signature());
  cpu->set_num_cores(base::SysInfo::NumberOfProcessors());
",,"@@ -296,13 +296,6 @@ const SystemProfileProto& MetricsLog::RecordEnvironment(
   if (client_->GetBrand(&brand_code))
     system_profile->set_brand_code(brand_code);
 
-  SystemProfileProto::Hardware::CPU* cpu =
-      system_profile->mutable_hardware()->mutable_cpu();
-  base::CPU cpu_info;
-  cpu->set_vendor_name(cpu_info.vendor_name());
-  cpu->set_signature(cpu_info.signature());
-  cpu->set_num_cores(base::SysInfo::NumberOfProcessors());
-
   delegating_provider->ProvideSystemProfileMetrics(system_profile);
 
   return *system_profile;",Chrome,19b8593007150b9a78da7d13f6e5f8feb10881a7,1d937c7a926082670b9025f7a04e62d8fc3128d6,1,"const SystemProfileProto& MetricsLog::RecordEnvironment(
    DelegatingProvider* delegating_provider) {
  DCHECK(!has_environment_);
  has_environment_ = true;

  SystemProfileProto* system_profile = uma_proto()->mutable_system_profile();

  WriteMetricsEnableDefault(client_->GetMetricsReportingDefaultState(),
                            system_profile);

  std::string brand_code;
   if (client_->GetBrand(&brand_code))
     system_profile->set_brand_code(brand_code);
 
//flaw_line_below:
  SystemProfileProto::Hardware::CPU* cpu =
//flaw_line_below:
      system_profile->mutable_hardware()->mutable_cpu();
//flaw_line_below:
  base::CPU cpu_info;
//flaw_line_below:
  cpu->set_vendor_name(cpu_info.vendor_name());
//flaw_line_below:
  cpu->set_signature(cpu_info.signature());
//flaw_line_below:
  cpu->set_num_cores(base::SysInfo::NumberOfProcessors());
//flaw_line_below:

   delegating_provider->ProvideSystemProfileMetrics(system_profile);
 
   return *system_profile;
}
"
8251,185987,,Remote,Not required,,CVE-2016-5181,https://www.cvedetails.com/cve/CVE-2016-5181/,CWE-79,Medium,,Partial,,2016-12-17,4.3,"Blink in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android permitted execution of v8 microtasks while the DOM was in an inconsistent state, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via crafted HTML pages.",2018-01-04,XSS ,1,https://github.com/chromium/chromium/commit/0a242b6c8a66ee530d5b68c74dfabe74e6415d45,0a242b6c8a66ee530d5b68c74dfabe74e6415d45,"Blink-in-JS should not run micro tasks

If Blink-in-JS runs micro tasks, there's a risk of causing a UXSS bug
(see 645211 for concrete steps).

This CL makes Blink-in-JS use callInternalFunction (instead of callFunction)
to avoid running micro tasks after Blink-in-JS' callbacks.

BUG=645211

Review-Url: https://codereview.chromium.org/2330843002
Cr-Commit-Position: refs/heads/master@{#417874}",1,third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp,"{""sha"": ""f4358df152ad10eaa608913b600943aceaac96ee"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a242b6c8a66ee530d5b68c74dfabe74e6415d45/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a242b6c8a66ee530d5b68c74dfabe74e6415d45/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp?ref=0a242b6c8a66ee530d5b68c74dfabe74e6415d45"", ""patch"": ""@@ -200,7 +200,7 @@ static void initializeHolderIfNeeded(ScriptState* scriptState, v8::Local<v8::Obj\n     if (classObject->Get(scriptState->context(), v8String(isolate, \""initialize\"")).ToLocal(&initializeFunction) && initializeFunction->IsFunction()) {\n         v8::TryCatch block(isolate);\n         v8::Local<v8::Value> result;\n-        if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(initializeFunction), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {\n+        if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(initializeFunction), holder, 0, 0, isolate).ToLocal(&result)) {\n             fprintf(stderr, \""Private script error: Object constructor threw an exception.\\n\"");\n             dumpV8Message(context, block.Message());\n             RELEASE_NOTREACHED();\n@@ -305,7 +305,7 @@ v8::Local<v8::Value> PrivateScriptRunner::runDOMAttributeGetter(ScriptState* scr\n     initializeHolderIfNeeded(scriptState, classObject, holder);\n     v8::TryCatch block(isolate);\n     v8::Local<v8::Value> result;\n-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(getter), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {\n+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(getter), holder, 0, 0, isolate).ToLocal(&result)) {\n         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::GetterContext, attributeName, className);\n         block.ReThrow();\n         return v8::Local<v8::Value>();\n@@ -331,7 +331,7 @@ bool PrivateScriptRunner::runDOMAttributeSetter(ScriptState* scriptState, Script\n     v8::Local<v8::Value> argv[] = { v8Value };\n     v8::TryCatch block(isolate);\n     v8::Local<v8::Value> result;\n-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(setter), scriptState->getExecutionContext(), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {\n+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {\n         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::SetterContext, attributeName, className);\n         block.ReThrow();\n         return false;\n@@ -350,7 +350,7 @@ v8::Local<v8::Value> PrivateScriptRunner::runDOMMethod(ScriptState* scriptState,\n     initializeHolderIfNeeded(scriptState, classObject, holder);\n     v8::TryCatch block(scriptState->isolate());\n     v8::Local<v8::Value> result;\n-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(method), scriptState->getExecutionContext(), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {\n+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(method), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {\n         rethrowExceptionInPrivateScript(scriptState->isolate(), block, scriptStateInUserScript, ExceptionState::ExecutionContext, methodName, className);\n         block.ReThrow();\n         return v8::Local<v8::Value>();""}","static void initializeHolderIfNeeded(ScriptState* scriptState, v8::Local<v8::Object> classObject, v8::Local<v8::Value> holder)
{
    RELEASE_ASSERT(!holder.IsEmpty());
    RELEASE_ASSERT(holder->IsObject());
    v8::Local<v8::Object> holderObject = v8::Local<v8::Object>::Cast(holder);
    v8::Isolate* isolate = scriptState->isolate();
    v8::Local<v8::Context> context = scriptState->context();
    auto privateIsInitialized = V8PrivateProperty::getPrivateScriptRunnerIsInitialized(isolate);
    if (privateIsInitialized.hasValue(context, holderObject))
        return; // Already initialized.

    v8::TryCatch block(isolate);
    v8::Local<v8::Value> initializeFunction;
     if (classObject->Get(scriptState->context(), v8String(isolate, ""initialize"")).ToLocal(&initializeFunction) && initializeFunction->IsFunction()) {
         v8::TryCatch block(isolate);
         v8::Local<v8::Value> result;
        if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(initializeFunction), holder, 0, 0, isolate).ToLocal(&result)) {
             fprintf(stderr, ""Private script error: Object constructor threw an exception.\n"");
             dumpV8Message(context, block.Message());
             RELEASE_NOTREACHED();
        }
    }

    if (classObject->GetPrototype() != holderObject->GetPrototype()) {
        if (!v8CallBoolean(classObject->SetPrototype(context, holderObject->GetPrototype()))) {
            fprintf(stderr, ""Private script error: SetPrototype failed.\n"");
            dumpV8Message(context, block.Message());
            RELEASE_NOTREACHED();
        }
    }
    if (!v8CallBoolean(holderObject->SetPrototype(context, classObject))) {
        fprintf(stderr, ""Private script error: SetPrototype failed.\n"");
        dumpV8Message(context, block.Message());
        RELEASE_NOTREACHED();
    }

    privateIsInitialized.set(context, holderObject, v8Boolean(true, isolate));
}
","static void initializeHolderIfNeeded(ScriptState* scriptState, v8::Local<v8::Object> classObject, v8::Local<v8::Value> holder)
{
    RELEASE_ASSERT(!holder.IsEmpty());
    RELEASE_ASSERT(holder->IsObject());
    v8::Local<v8::Object> holderObject = v8::Local<v8::Object>::Cast(holder);
    v8::Isolate* isolate = scriptState->isolate();
    v8::Local<v8::Context> context = scriptState->context();
    auto privateIsInitialized = V8PrivateProperty::getPrivateScriptRunnerIsInitialized(isolate);
    if (privateIsInitialized.hasValue(context, holderObject))
        return; // Already initialized.

    v8::TryCatch block(isolate);
    v8::Local<v8::Value> initializeFunction;
     if (classObject->Get(scriptState->context(), v8String(isolate, ""initialize"")).ToLocal(&initializeFunction) && initializeFunction->IsFunction()) {
         v8::TryCatch block(isolate);
         v8::Local<v8::Value> result;
        if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(initializeFunction), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {
             fprintf(stderr, ""Private script error: Object constructor threw an exception.\n"");
             dumpV8Message(context, block.Message());
             RELEASE_NOTREACHED();
        }
    }

    if (classObject->GetPrototype() != holderObject->GetPrototype()) {
        if (!v8CallBoolean(classObject->SetPrototype(context, holderObject->GetPrototype()))) {
            fprintf(stderr, ""Private script error: SetPrototype failed.\n"");
            dumpV8Message(context, block.Message());
            RELEASE_NOTREACHED();
        }
    }
    if (!v8CallBoolean(holderObject->SetPrototype(context, classObject))) {
        fprintf(stderr, ""Private script error: SetPrototype failed.\n"");
        dumpV8Message(context, block.Message());
        RELEASE_NOTREACHED();
    }

    privateIsInitialized.set(context, holderObject, v8Boolean(true, isolate));
}
",C,"        if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(initializeFunction), holder, 0, 0, isolate).ToLocal(&result)) {
","        if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(initializeFunction), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {
",,"@@ -200,7 +200,7 @@ static void initializeHolderIfNeeded(ScriptState* scriptState, v8::Local<v8::Obj
     if (classObject->Get(scriptState->context(), v8String(isolate, ""initialize"")).ToLocal(&initializeFunction) && initializeFunction->IsFunction()) {
         v8::TryCatch block(isolate);
         v8::Local<v8::Value> result;
-        if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(initializeFunction), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {
+        if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(initializeFunction), holder, 0, 0, isolate).ToLocal(&result)) {
             fprintf(stderr, ""Private script error: Object constructor threw an exception.\n"");
             dumpV8Message(context, block.Message());
             RELEASE_NOTREACHED();
@@ -305,7 +305,7 @@ v8::Local<v8::Value> PrivateScriptRunner::runDOMAttributeGetter(ScriptState* scr
     initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::TryCatch block(isolate);
     v8::Local<v8::Value> result;
-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(getter), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {
+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(getter), holder, 0, 0, isolate).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::GetterContext, attributeName, className);
         block.ReThrow();
         return v8::Local<v8::Value>();
@@ -331,7 +331,7 @@ bool PrivateScriptRunner::runDOMAttributeSetter(ScriptState* scriptState, Script
     v8::Local<v8::Value> argv[] = { v8Value };
     v8::TryCatch block(isolate);
     v8::Local<v8::Value> result;
-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(setter), scriptState->getExecutionContext(), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {
+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::SetterContext, attributeName, className);
         block.ReThrow();
         return false;
@@ -350,7 +350,7 @@ v8::Local<v8::Value> PrivateScriptRunner::runDOMMethod(ScriptState* scriptState,
     initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::TryCatch block(scriptState->isolate());
     v8::Local<v8::Value> result;
-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(method), scriptState->getExecutionContext(), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(method), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(scriptState->isolate(), block, scriptStateInUserScript, ExceptionState::ExecutionContext, methodName, className);
         block.ReThrow();
         return v8::Local<v8::Value>();",Chrome,0a242b6c8a66ee530d5b68c74dfabe74e6415d45,8eb88763df5a272f9cd161689c7273da125167a1,1,"static void initializeHolderIfNeeded(ScriptState* scriptState, v8::Local<v8::Object> classObject, v8::Local<v8::Value> holder)
{
    RELEASE_ASSERT(!holder.IsEmpty());
    RELEASE_ASSERT(holder->IsObject());
    v8::Local<v8::Object> holderObject = v8::Local<v8::Object>::Cast(holder);
    v8::Isolate* isolate = scriptState->isolate();
    v8::Local<v8::Context> context = scriptState->context();
    auto privateIsInitialized = V8PrivateProperty::getPrivateScriptRunnerIsInitialized(isolate);
    if (privateIsInitialized.hasValue(context, holderObject))
        return; // Already initialized.

    v8::TryCatch block(isolate);
    v8::Local<v8::Value> initializeFunction;
     if (classObject->Get(scriptState->context(), v8String(isolate, ""initialize"")).ToLocal(&initializeFunction) && initializeFunction->IsFunction()) {
         v8::TryCatch block(isolate);
         v8::Local<v8::Value> result;
//flaw_line_below:
        if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(initializeFunction), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {
//fix_flaw_line_below:
//        if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(initializeFunction), holder, 0, 0, isolate).ToLocal(&result)) {
             fprintf(stderr, ""Private script error: Object constructor threw an exception.\n"");
             dumpV8Message(context, block.Message());
             RELEASE_NOTREACHED();
        }
    }

    // Inject the prototype object of the private script into the prototype chain of the holder object.
    // This is necessary to let the holder object use properties defined on the prototype object
    // of the private script. (e.g., if the prototype object has |foo|, the holder object should be able
    // to use it with |this.foo|.)
    if (classObject->GetPrototype() != holderObject->GetPrototype()) {
        if (!v8CallBoolean(classObject->SetPrototype(context, holderObject->GetPrototype()))) {
            fprintf(stderr, ""Private script error: SetPrototype failed.\n"");
            dumpV8Message(context, block.Message());
            RELEASE_NOTREACHED();
        }
    }
    if (!v8CallBoolean(holderObject->SetPrototype(context, classObject))) {
        fprintf(stderr, ""Private script error: SetPrototype failed.\n"");
        dumpV8Message(context, block.Message());
        RELEASE_NOTREACHED();
    }

    privateIsInitialized.set(context, holderObject, v8Boolean(true, isolate));
}
"
8252,185988,,Remote,Not required,,CVE-2016-5181,https://www.cvedetails.com/cve/CVE-2016-5181/,CWE-79,Medium,,Partial,,2016-12-17,4.3,"Blink in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android permitted execution of v8 microtasks while the DOM was in an inconsistent state, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via crafted HTML pages.",2018-01-04,XSS ,1,https://github.com/chromium/chromium/commit/0a242b6c8a66ee530d5b68c74dfabe74e6415d45,0a242b6c8a66ee530d5b68c74dfabe74e6415d45,"Blink-in-JS should not run micro tasks

If Blink-in-JS runs micro tasks, there's a risk of causing a UXSS bug
(see 645211 for concrete steps).

This CL makes Blink-in-JS use callInternalFunction (instead of callFunction)
to avoid running micro tasks after Blink-in-JS' callbacks.

BUG=645211

Review-Url: https://codereview.chromium.org/2330843002
Cr-Commit-Position: refs/heads/master@{#417874}",1,third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp,"{""sha"": ""f4358df152ad10eaa608913b600943aceaac96ee"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a242b6c8a66ee530d5b68c74dfabe74e6415d45/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a242b6c8a66ee530d5b68c74dfabe74e6415d45/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp?ref=0a242b6c8a66ee530d5b68c74dfabe74e6415d45"", ""patch"": ""@@ -200,7 +200,7 @@ static void initializeHolderIfNeeded(ScriptState* scriptState, v8::Local<v8::Obj\n     if (classObject->Get(scriptState->context(), v8String(isolate, \""initialize\"")).ToLocal(&initializeFunction) && initializeFunction->IsFunction()) {\n         v8::TryCatch block(isolate);\n         v8::Local<v8::Value> result;\n-        if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(initializeFunction), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {\n+        if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(initializeFunction), holder, 0, 0, isolate).ToLocal(&result)) {\n             fprintf(stderr, \""Private script error: Object constructor threw an exception.\\n\"");\n             dumpV8Message(context, block.Message());\n             RELEASE_NOTREACHED();\n@@ -305,7 +305,7 @@ v8::Local<v8::Value> PrivateScriptRunner::runDOMAttributeGetter(ScriptState* scr\n     initializeHolderIfNeeded(scriptState, classObject, holder);\n     v8::TryCatch block(isolate);\n     v8::Local<v8::Value> result;\n-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(getter), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {\n+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(getter), holder, 0, 0, isolate).ToLocal(&result)) {\n         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::GetterContext, attributeName, className);\n         block.ReThrow();\n         return v8::Local<v8::Value>();\n@@ -331,7 +331,7 @@ bool PrivateScriptRunner::runDOMAttributeSetter(ScriptState* scriptState, Script\n     v8::Local<v8::Value> argv[] = { v8Value };\n     v8::TryCatch block(isolate);\n     v8::Local<v8::Value> result;\n-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(setter), scriptState->getExecutionContext(), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {\n+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {\n         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::SetterContext, attributeName, className);\n         block.ReThrow();\n         return false;\n@@ -350,7 +350,7 @@ v8::Local<v8::Value> PrivateScriptRunner::runDOMMethod(ScriptState* scriptState,\n     initializeHolderIfNeeded(scriptState, classObject, holder);\n     v8::TryCatch block(scriptState->isolate());\n     v8::Local<v8::Value> result;\n-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(method), scriptState->getExecutionContext(), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {\n+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(method), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {\n         rethrowExceptionInPrivateScript(scriptState->isolate(), block, scriptStateInUserScript, ExceptionState::ExecutionContext, methodName, className);\n         block.ReThrow();\n         return v8::Local<v8::Value>();""}","v8::Local<v8::Value> PrivateScriptRunner::runDOMAttributeGetter(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* attributeName, v8::Local<v8::Value> holder)
{
    v8::Isolate* isolate = scriptState->isolate();
    v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);
    v8::Local<v8::Value> descriptor;
    if (!classObject->GetOwnPropertyDescriptor(scriptState->context(), v8String(isolate, attributeName)).ToLocal(&descriptor) || !descriptor->IsObject()) {
        fprintf(stderr, ""Private script error: Target DOM attribute getter was not found. (Class name = %s, Attribute name = %s)\n"", className, attributeName);
        RELEASE_NOTREACHED();
    }
    v8::Local<v8::Value> getter;
    if (!v8::Local<v8::Object>::Cast(descriptor)->Get(scriptState->context(), v8String(isolate, ""get"")).ToLocal(&getter) || !getter->IsFunction()) {
        fprintf(stderr, ""Private script error: Target DOM attribute getter was not found. (Class name = %s, Attribute name = %s)\n"", className, attributeName);
        RELEASE_NOTREACHED();
    }
     initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::TryCatch block(isolate);
     v8::Local<v8::Value> result;
    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(getter), holder, 0, 0, isolate).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::GetterContext, attributeName, className);
         block.ReThrow();
         return v8::Local<v8::Value>();
    }
    return result;
}
","v8::Local<v8::Value> PrivateScriptRunner::runDOMAttributeGetter(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* attributeName, v8::Local<v8::Value> holder)
{
    v8::Isolate* isolate = scriptState->isolate();
    v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);
    v8::Local<v8::Value> descriptor;
    if (!classObject->GetOwnPropertyDescriptor(scriptState->context(), v8String(isolate, attributeName)).ToLocal(&descriptor) || !descriptor->IsObject()) {
        fprintf(stderr, ""Private script error: Target DOM attribute getter was not found. (Class name = %s, Attribute name = %s)\n"", className, attributeName);
        RELEASE_NOTREACHED();
    }
    v8::Local<v8::Value> getter;
    if (!v8::Local<v8::Object>::Cast(descriptor)->Get(scriptState->context(), v8String(isolate, ""get"")).ToLocal(&getter) || !getter->IsFunction()) {
        fprintf(stderr, ""Private script error: Target DOM attribute getter was not found. (Class name = %s, Attribute name = %s)\n"", className, attributeName);
        RELEASE_NOTREACHED();
    }
     initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::TryCatch block(isolate);
     v8::Local<v8::Value> result;
    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(getter), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::GetterContext, attributeName, className);
         block.ReThrow();
         return v8::Local<v8::Value>();
    }
    return result;
}
",C,"    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(getter), holder, 0, 0, isolate).ToLocal(&result)) {
","    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(getter), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {
",,"@@ -200,7 +200,7 @@ static void initializeHolderIfNeeded(ScriptState* scriptState, v8::Local<v8::Obj
     if (classObject->Get(scriptState->context(), v8String(isolate, ""initialize"")).ToLocal(&initializeFunction) && initializeFunction->IsFunction()) {
         v8::TryCatch block(isolate);
         v8::Local<v8::Value> result;
-        if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(initializeFunction), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {
+        if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(initializeFunction), holder, 0, 0, isolate).ToLocal(&result)) {
             fprintf(stderr, ""Private script error: Object constructor threw an exception.\n"");
             dumpV8Message(context, block.Message());
             RELEASE_NOTREACHED();
@@ -305,7 +305,7 @@ v8::Local<v8::Value> PrivateScriptRunner::runDOMAttributeGetter(ScriptState* scr
     initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::TryCatch block(isolate);
     v8::Local<v8::Value> result;
-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(getter), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {
+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(getter), holder, 0, 0, isolate).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::GetterContext, attributeName, className);
         block.ReThrow();
         return v8::Local<v8::Value>();
@@ -331,7 +331,7 @@ bool PrivateScriptRunner::runDOMAttributeSetter(ScriptState* scriptState, Script
     v8::Local<v8::Value> argv[] = { v8Value };
     v8::TryCatch block(isolate);
     v8::Local<v8::Value> result;
-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(setter), scriptState->getExecutionContext(), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {
+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::SetterContext, attributeName, className);
         block.ReThrow();
         return false;
@@ -350,7 +350,7 @@ v8::Local<v8::Value> PrivateScriptRunner::runDOMMethod(ScriptState* scriptState,
     initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::TryCatch block(scriptState->isolate());
     v8::Local<v8::Value> result;
-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(method), scriptState->getExecutionContext(), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(method), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(scriptState->isolate(), block, scriptStateInUserScript, ExceptionState::ExecutionContext, methodName, className);
         block.ReThrow();
         return v8::Local<v8::Value>();",Chrome,0a242b6c8a66ee530d5b68c74dfabe74e6415d45,8eb88763df5a272f9cd161689c7273da125167a1,1,"v8::Local<v8::Value> PrivateScriptRunner::runDOMAttributeGetter(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* attributeName, v8::Local<v8::Value> holder)
{
    v8::Isolate* isolate = scriptState->isolate();
    v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);
    v8::Local<v8::Value> descriptor;
    if (!classObject->GetOwnPropertyDescriptor(scriptState->context(), v8String(isolate, attributeName)).ToLocal(&descriptor) || !descriptor->IsObject()) {
        fprintf(stderr, ""Private script error: Target DOM attribute getter was not found. (Class name = %s, Attribute name = %s)\n"", className, attributeName);
        RELEASE_NOTREACHED();
    }
    v8::Local<v8::Value> getter;
    if (!v8::Local<v8::Object>::Cast(descriptor)->Get(scriptState->context(), v8String(isolate, ""get"")).ToLocal(&getter) || !getter->IsFunction()) {
        fprintf(stderr, ""Private script error: Target DOM attribute getter was not found. (Class name = %s, Attribute name = %s)\n"", className, attributeName);
        RELEASE_NOTREACHED();
    }
     initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::TryCatch block(isolate);
     v8::Local<v8::Value> result;
//flaw_line_below:
    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(getter), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {
//fix_flaw_line_below:
//    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(getter), holder, 0, 0, isolate).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::GetterContext, attributeName, className);
         block.ReThrow();
         return v8::Local<v8::Value>();
    }
    return result;
}
"
8253,185989,,Remote,Not required,,CVE-2016-5181,https://www.cvedetails.com/cve/CVE-2016-5181/,CWE-79,Medium,,Partial,,2016-12-17,4.3,"Blink in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android permitted execution of v8 microtasks while the DOM was in an inconsistent state, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via crafted HTML pages.",2018-01-04,XSS ,1,https://github.com/chromium/chromium/commit/0a242b6c8a66ee530d5b68c74dfabe74e6415d45,0a242b6c8a66ee530d5b68c74dfabe74e6415d45,"Blink-in-JS should not run micro tasks

If Blink-in-JS runs micro tasks, there's a risk of causing a UXSS bug
(see 645211 for concrete steps).

This CL makes Blink-in-JS use callInternalFunction (instead of callFunction)
to avoid running micro tasks after Blink-in-JS' callbacks.

BUG=645211

Review-Url: https://codereview.chromium.org/2330843002
Cr-Commit-Position: refs/heads/master@{#417874}",1,third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp,"{""sha"": ""f4358df152ad10eaa608913b600943aceaac96ee"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a242b6c8a66ee530d5b68c74dfabe74e6415d45/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a242b6c8a66ee530d5b68c74dfabe74e6415d45/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp?ref=0a242b6c8a66ee530d5b68c74dfabe74e6415d45"", ""patch"": ""@@ -200,7 +200,7 @@ static void initializeHolderIfNeeded(ScriptState* scriptState, v8::Local<v8::Obj\n     if (classObject->Get(scriptState->context(), v8String(isolate, \""initialize\"")).ToLocal(&initializeFunction) && initializeFunction->IsFunction()) {\n         v8::TryCatch block(isolate);\n         v8::Local<v8::Value> result;\n-        if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(initializeFunction), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {\n+        if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(initializeFunction), holder, 0, 0, isolate).ToLocal(&result)) {\n             fprintf(stderr, \""Private script error: Object constructor threw an exception.\\n\"");\n             dumpV8Message(context, block.Message());\n             RELEASE_NOTREACHED();\n@@ -305,7 +305,7 @@ v8::Local<v8::Value> PrivateScriptRunner::runDOMAttributeGetter(ScriptState* scr\n     initializeHolderIfNeeded(scriptState, classObject, holder);\n     v8::TryCatch block(isolate);\n     v8::Local<v8::Value> result;\n-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(getter), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {\n+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(getter), holder, 0, 0, isolate).ToLocal(&result)) {\n         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::GetterContext, attributeName, className);\n         block.ReThrow();\n         return v8::Local<v8::Value>();\n@@ -331,7 +331,7 @@ bool PrivateScriptRunner::runDOMAttributeSetter(ScriptState* scriptState, Script\n     v8::Local<v8::Value> argv[] = { v8Value };\n     v8::TryCatch block(isolate);\n     v8::Local<v8::Value> result;\n-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(setter), scriptState->getExecutionContext(), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {\n+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {\n         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::SetterContext, attributeName, className);\n         block.ReThrow();\n         return false;\n@@ -350,7 +350,7 @@ v8::Local<v8::Value> PrivateScriptRunner::runDOMMethod(ScriptState* scriptState,\n     initializeHolderIfNeeded(scriptState, classObject, holder);\n     v8::TryCatch block(scriptState->isolate());\n     v8::Local<v8::Value> result;\n-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(method), scriptState->getExecutionContext(), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {\n+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(method), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {\n         rethrowExceptionInPrivateScript(scriptState->isolate(), block, scriptStateInUserScript, ExceptionState::ExecutionContext, methodName, className);\n         block.ReThrow();\n         return v8::Local<v8::Value>();""}","bool PrivateScriptRunner::runDOMAttributeSetter(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* attributeName, v8::Local<v8::Value> holder, v8::Local<v8::Value> v8Value)
{
    v8::Isolate* isolate = scriptState->isolate();
    v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);
    v8::Local<v8::Value> descriptor;
    if (!classObject->GetOwnPropertyDescriptor(scriptState->context(), v8String(isolate, attributeName)).ToLocal(&descriptor) || !descriptor->IsObject()) {
        fprintf(stderr, ""Private script error: Target DOM attribute setter was not found. (Class name = %s, Attribute name = %s)\n"", className, attributeName);
        RELEASE_NOTREACHED();
    }
    v8::Local<v8::Value> setter;
    if (!v8::Local<v8::Object>::Cast(descriptor)->Get(scriptState->context(), v8String(isolate, ""set"")).ToLocal(&setter) || !setter->IsFunction()) {
        fprintf(stderr, ""Private script error: Target DOM attribute setter was not found. (Class name = %s, Attribute name = %s)\n"", className, attributeName);
        RELEASE_NOTREACHED();
    }
    initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::Local<v8::Value> argv[] = { v8Value };
     v8::TryCatch block(isolate);
     v8::Local<v8::Value> result;
    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::SetterContext, attributeName, className);
         block.ReThrow();
         return false;
    }
    return true;
}
","bool PrivateScriptRunner::runDOMAttributeSetter(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* attributeName, v8::Local<v8::Value> holder, v8::Local<v8::Value> v8Value)
{
    v8::Isolate* isolate = scriptState->isolate();
    v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);
    v8::Local<v8::Value> descriptor;
    if (!classObject->GetOwnPropertyDescriptor(scriptState->context(), v8String(isolate, attributeName)).ToLocal(&descriptor) || !descriptor->IsObject()) {
        fprintf(stderr, ""Private script error: Target DOM attribute setter was not found. (Class name = %s, Attribute name = %s)\n"", className, attributeName);
        RELEASE_NOTREACHED();
    }
    v8::Local<v8::Value> setter;
    if (!v8::Local<v8::Object>::Cast(descriptor)->Get(scriptState->context(), v8String(isolate, ""set"")).ToLocal(&setter) || !setter->IsFunction()) {
        fprintf(stderr, ""Private script error: Target DOM attribute setter was not found. (Class name = %s, Attribute name = %s)\n"", className, attributeName);
        RELEASE_NOTREACHED();
    }
    initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::Local<v8::Value> argv[] = { v8Value };
     v8::TryCatch block(isolate);
     v8::Local<v8::Value> result;
    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(setter), scriptState->getExecutionContext(), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::SetterContext, attributeName, className);
         block.ReThrow();
         return false;
    }
    return true;
}
",C,"    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {
","    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(setter), scriptState->getExecutionContext(), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {
",,"@@ -200,7 +200,7 @@ static void initializeHolderIfNeeded(ScriptState* scriptState, v8::Local<v8::Obj
     if (classObject->Get(scriptState->context(), v8String(isolate, ""initialize"")).ToLocal(&initializeFunction) && initializeFunction->IsFunction()) {
         v8::TryCatch block(isolate);
         v8::Local<v8::Value> result;
-        if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(initializeFunction), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {
+        if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(initializeFunction), holder, 0, 0, isolate).ToLocal(&result)) {
             fprintf(stderr, ""Private script error: Object constructor threw an exception.\n"");
             dumpV8Message(context, block.Message());
             RELEASE_NOTREACHED();
@@ -305,7 +305,7 @@ v8::Local<v8::Value> PrivateScriptRunner::runDOMAttributeGetter(ScriptState* scr
     initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::TryCatch block(isolate);
     v8::Local<v8::Value> result;
-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(getter), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {
+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(getter), holder, 0, 0, isolate).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::GetterContext, attributeName, className);
         block.ReThrow();
         return v8::Local<v8::Value>();
@@ -331,7 +331,7 @@ bool PrivateScriptRunner::runDOMAttributeSetter(ScriptState* scriptState, Script
     v8::Local<v8::Value> argv[] = { v8Value };
     v8::TryCatch block(isolate);
     v8::Local<v8::Value> result;
-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(setter), scriptState->getExecutionContext(), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {
+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::SetterContext, attributeName, className);
         block.ReThrow();
         return false;
@@ -350,7 +350,7 @@ v8::Local<v8::Value> PrivateScriptRunner::runDOMMethod(ScriptState* scriptState,
     initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::TryCatch block(scriptState->isolate());
     v8::Local<v8::Value> result;
-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(method), scriptState->getExecutionContext(), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(method), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(scriptState->isolate(), block, scriptStateInUserScript, ExceptionState::ExecutionContext, methodName, className);
         block.ReThrow();
         return v8::Local<v8::Value>();",Chrome,0a242b6c8a66ee530d5b68c74dfabe74e6415d45,8eb88763df5a272f9cd161689c7273da125167a1,1,"bool PrivateScriptRunner::runDOMAttributeSetter(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* attributeName, v8::Local<v8::Value> holder, v8::Local<v8::Value> v8Value)
{
    v8::Isolate* isolate = scriptState->isolate();
    v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);
    v8::Local<v8::Value> descriptor;
    if (!classObject->GetOwnPropertyDescriptor(scriptState->context(), v8String(isolate, attributeName)).ToLocal(&descriptor) || !descriptor->IsObject()) {
        fprintf(stderr, ""Private script error: Target DOM attribute setter was not found. (Class name = %s, Attribute name = %s)\n"", className, attributeName);
        RELEASE_NOTREACHED();
    }
    v8::Local<v8::Value> setter;
    if (!v8::Local<v8::Object>::Cast(descriptor)->Get(scriptState->context(), v8String(isolate, ""set"")).ToLocal(&setter) || !setter->IsFunction()) {
        fprintf(stderr, ""Private script error: Target DOM attribute setter was not found. (Class name = %s, Attribute name = %s)\n"", className, attributeName);
        RELEASE_NOTREACHED();
    }
    initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::Local<v8::Value> argv[] = { v8Value };
     v8::TryCatch block(isolate);
     v8::Local<v8::Value> result;
//flaw_line_below:
    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(setter), scriptState->getExecutionContext(), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {
//fix_flaw_line_below:
//    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::SetterContext, attributeName, className);
         block.ReThrow();
         return false;
    }
    return true;
}
"
8254,185990,,Remote,Not required,,CVE-2016-5181,https://www.cvedetails.com/cve/CVE-2016-5181/,CWE-79,Medium,,Partial,,2016-12-17,4.3,"Blink in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android permitted execution of v8 microtasks while the DOM was in an inconsistent state, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via crafted HTML pages.",2018-01-04,XSS ,1,https://github.com/chromium/chromium/commit/0a242b6c8a66ee530d5b68c74dfabe74e6415d45,0a242b6c8a66ee530d5b68c74dfabe74e6415d45,"Blink-in-JS should not run micro tasks

If Blink-in-JS runs micro tasks, there's a risk of causing a UXSS bug
(see 645211 for concrete steps).

This CL makes Blink-in-JS use callInternalFunction (instead of callFunction)
to avoid running micro tasks after Blink-in-JS' callbacks.

BUG=645211

Review-Url: https://codereview.chromium.org/2330843002
Cr-Commit-Position: refs/heads/master@{#417874}",1,third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp,"{""sha"": ""f4358df152ad10eaa608913b600943aceaac96ee"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a242b6c8a66ee530d5b68c74dfabe74e6415d45/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a242b6c8a66ee530d5b68c74dfabe74e6415d45/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp?ref=0a242b6c8a66ee530d5b68c74dfabe74e6415d45"", ""patch"": ""@@ -200,7 +200,7 @@ static void initializeHolderIfNeeded(ScriptState* scriptState, v8::Local<v8::Obj\n     if (classObject->Get(scriptState->context(), v8String(isolate, \""initialize\"")).ToLocal(&initializeFunction) && initializeFunction->IsFunction()) {\n         v8::TryCatch block(isolate);\n         v8::Local<v8::Value> result;\n-        if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(initializeFunction), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {\n+        if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(initializeFunction), holder, 0, 0, isolate).ToLocal(&result)) {\n             fprintf(stderr, \""Private script error: Object constructor threw an exception.\\n\"");\n             dumpV8Message(context, block.Message());\n             RELEASE_NOTREACHED();\n@@ -305,7 +305,7 @@ v8::Local<v8::Value> PrivateScriptRunner::runDOMAttributeGetter(ScriptState* scr\n     initializeHolderIfNeeded(scriptState, classObject, holder);\n     v8::TryCatch block(isolate);\n     v8::Local<v8::Value> result;\n-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(getter), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {\n+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(getter), holder, 0, 0, isolate).ToLocal(&result)) {\n         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::GetterContext, attributeName, className);\n         block.ReThrow();\n         return v8::Local<v8::Value>();\n@@ -331,7 +331,7 @@ bool PrivateScriptRunner::runDOMAttributeSetter(ScriptState* scriptState, Script\n     v8::Local<v8::Value> argv[] = { v8Value };\n     v8::TryCatch block(isolate);\n     v8::Local<v8::Value> result;\n-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(setter), scriptState->getExecutionContext(), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {\n+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {\n         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::SetterContext, attributeName, className);\n         block.ReThrow();\n         return false;\n@@ -350,7 +350,7 @@ v8::Local<v8::Value> PrivateScriptRunner::runDOMMethod(ScriptState* scriptState,\n     initializeHolderIfNeeded(scriptState, classObject, holder);\n     v8::TryCatch block(scriptState->isolate());\n     v8::Local<v8::Value> result;\n-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(method), scriptState->getExecutionContext(), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {\n+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(method), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {\n         rethrowExceptionInPrivateScript(scriptState->isolate(), block, scriptStateInUserScript, ExceptionState::ExecutionContext, methodName, className);\n         block.ReThrow();\n         return v8::Local<v8::Value>();""}","v8::Local<v8::Value> PrivateScriptRunner::runDOMMethod(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* methodName, v8::Local<v8::Value> holder, int argc, v8::Local<v8::Value> argv[])
{
    v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);
    v8::Local<v8::Value> method;
    if (!classObject->Get(scriptState->context(), v8String(scriptState->isolate(), methodName)).ToLocal(&method) || !method->IsFunction()) {
        fprintf(stderr, ""Private script error: Target DOM method was not found. (Class name = %s, Method name = %s)\n"", className, methodName);
        RELEASE_NOTREACHED();
    }
     initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::TryCatch block(scriptState->isolate());
     v8::Local<v8::Value> result;
    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(method), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(scriptState->isolate(), block, scriptStateInUserScript, ExceptionState::ExecutionContext, methodName, className);
         block.ReThrow();
         return v8::Local<v8::Value>();
    }
    return result;
}
","v8::Local<v8::Value> PrivateScriptRunner::runDOMMethod(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* methodName, v8::Local<v8::Value> holder, int argc, v8::Local<v8::Value> argv[])
{
    v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);
    v8::Local<v8::Value> method;
    if (!classObject->Get(scriptState->context(), v8String(scriptState->isolate(), methodName)).ToLocal(&method) || !method->IsFunction()) {
        fprintf(stderr, ""Private script error: Target DOM method was not found. (Class name = %s, Method name = %s)\n"", className, methodName);
        RELEASE_NOTREACHED();
    }
     initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::TryCatch block(scriptState->isolate());
     v8::Local<v8::Value> result;
    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(method), scriptState->getExecutionContext(), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(scriptState->isolate(), block, scriptStateInUserScript, ExceptionState::ExecutionContext, methodName, className);
         block.ReThrow();
         return v8::Local<v8::Value>();
    }
    return result;
}
",C,"    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(method), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
","    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(method), scriptState->getExecutionContext(), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
",,"@@ -200,7 +200,7 @@ static void initializeHolderIfNeeded(ScriptState* scriptState, v8::Local<v8::Obj
     if (classObject->Get(scriptState->context(), v8String(isolate, ""initialize"")).ToLocal(&initializeFunction) && initializeFunction->IsFunction()) {
         v8::TryCatch block(isolate);
         v8::Local<v8::Value> result;
-        if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(initializeFunction), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {
+        if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(initializeFunction), holder, 0, 0, isolate).ToLocal(&result)) {
             fprintf(stderr, ""Private script error: Object constructor threw an exception.\n"");
             dumpV8Message(context, block.Message());
             RELEASE_NOTREACHED();
@@ -305,7 +305,7 @@ v8::Local<v8::Value> PrivateScriptRunner::runDOMAttributeGetter(ScriptState* scr
     initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::TryCatch block(isolate);
     v8::Local<v8::Value> result;
-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(getter), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {
+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(getter), holder, 0, 0, isolate).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::GetterContext, attributeName, className);
         block.ReThrow();
         return v8::Local<v8::Value>();
@@ -331,7 +331,7 @@ bool PrivateScriptRunner::runDOMAttributeSetter(ScriptState* scriptState, Script
     v8::Local<v8::Value> argv[] = { v8Value };
     v8::TryCatch block(isolate);
     v8::Local<v8::Value> result;
-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(setter), scriptState->getExecutionContext(), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {
+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::SetterContext, attributeName, className);
         block.ReThrow();
         return false;
@@ -350,7 +350,7 @@ v8::Local<v8::Value> PrivateScriptRunner::runDOMMethod(ScriptState* scriptState,
     initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::TryCatch block(scriptState->isolate());
     v8::Local<v8::Value> result;
-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(method), scriptState->getExecutionContext(), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(method), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(scriptState->isolate(), block, scriptStateInUserScript, ExceptionState::ExecutionContext, methodName, className);
         block.ReThrow();
         return v8::Local<v8::Value>();",Chrome,0a242b6c8a66ee530d5b68c74dfabe74e6415d45,8eb88763df5a272f9cd161689c7273da125167a1,1,"v8::Local<v8::Value> PrivateScriptRunner::runDOMMethod(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* methodName, v8::Local<v8::Value> holder, int argc, v8::Local<v8::Value> argv[])
{
    v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);
    v8::Local<v8::Value> method;
    if (!classObject->Get(scriptState->context(), v8String(scriptState->isolate(), methodName)).ToLocal(&method) || !method->IsFunction()) {
        fprintf(stderr, ""Private script error: Target DOM method was not found. (Class name = %s, Method name = %s)\n"", className, methodName);
        RELEASE_NOTREACHED();
    }
     initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::TryCatch block(scriptState->isolate());
     v8::Local<v8::Value> result;
//flaw_line_below:
    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(method), scriptState->getExecutionContext(), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
//fix_flaw_line_below:
//    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(method), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(scriptState->isolate(), block, scriptStateInUserScript, ExceptionState::ExecutionContext, methodName, className);
         block.ReThrow();
         return v8::Local<v8::Value>();
    }
    return result;
}
"
8280,186016,,Remote,Not required,,CVE-2016-5191,https://www.cvedetails.com/cve/CVE-2016-5191/,CWE-79,Medium,,Partial,,2016-12-17,4.3,"Bookmark handling in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android had insufficient validation of supplied data, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via crafted HTML pages, as demonstrated by an interpretation conflict between userinfo and scheme in an http://javascript:",2018-01-04,XSS ,12,https://github.com/chromium/chromium/commit/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4,fa34e547d6ee25ea0692436ba7462ed0a0ef45f4,"Prevent interpretating userinfo as url scheme when editing bookmarks

Chrome's Edit Bookmark dialog formats urls for display such that a
url of http://javascript:scripttext@host.com is later converted to a
javascript url scheme, allowing persistence of a script injection
attack within the user's bookmarks.

This fix prevents such misinterpretations by always showing the
scheme when a userinfo component is present within the url.

BUG=639126

Review-Url: https://codereview.chromium.org/2368593002
Cr-Commit-Position: refs/heads/master@{#422467}",4,chrome/browser/ui/bookmarks/bookmark_utils.cc,"{""sha"": ""ffebacaa0f6864fd57e0d0cda9b2dbb08552a13c"", ""filename"": ""chrome/browser/ui/bookmarks/bookmark_utils.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 5, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/bookmarks/bookmark_utils.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/bookmarks/bookmark_utils.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/bookmarks/bookmark_utils.cc?ref=fa34e547d6ee25ea0692436ba7462ed0a0ef45f4"", ""patch"": ""@@ -126,13 +126,20 @@ void ToggleBookmarkBarWhenVisible(content::BrowserContext* browser_context) {\n \n base::string16 FormatBookmarkURLForDisplay(const GURL& url) {\n   // Because this gets re-parsed by FixupURL(), it's safe to omit the scheme\n-  // and trailing slash, and unescape most characters.  However, it's\n+  // and trailing slash, and unescape most characters. However, it's\n   // important not to drop any username/password, or unescape anything that\n   // changes the URL's meaning.\n-  return url_formatter::FormatUrl(\n-      url, url_formatter::kFormatUrlOmitAll &\n-               ~url_formatter::kFormatUrlOmitUsernamePassword,\n-      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);\n+  url_formatter::FormatUrlTypes format_types =\n+      url_formatter::kFormatUrlOmitAll &\n+      ~url_formatter::kFormatUrlOmitUsernamePassword;\n+\n+  // If username is present, we must not omit the scheme because FixupURL() will\n+  // subsequently interpret the username as a scheme. crbug.com/639126\n+  if (url.has_username())\n+    format_types &= ~url_formatter::kFormatUrlOmitHTTP;\n+\n+  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,\n+                                  nullptr, nullptr, nullptr);\n }\n \n bool IsAppsShortcutEnabled(Profile* profile) {""}<_**next**_>{""sha"": ""1a5bf29d3599fce20c987c7c997a9c80aa331c7a"", ""filename"": ""chrome/browser/ui/bookmarks/bookmark_utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/bookmarks/bookmark_utils.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/bookmarks/bookmark_utils.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/bookmarks/bookmark_utils.h?ref=fa34e547d6ee25ea0692436ba7462ed0a0ef45f4"", ""patch"": ""@@ -53,9 +53,8 @@ void GetURLAndTitleToBookmark(content::WebContents* web_contents,\n // all tabs. This is a preference modifier, not a visual modifier.\n void ToggleBookmarkBarWhenVisible(content::BrowserContext* browser_context);\n \n-// Returns a formatted version of |url| appropriate to display to a user with\n-// the given |prefs|, which may be NULL.  When re-parsing this URL, clients\n-// should call url_formatter::FixupURL().\n+// Returns a formatted version of |url| appropriate to display to a user.\n+// When re-parsing this URL, clients should call url_formatter::FixupURL().\n base::string16 FormatBookmarkURLForDisplay(const GURL& url);\n \n // Returns whether the Apps shortcut is enabled. If true, then the visibility""}<_**next**_>{""sha"": ""4098467fc081af1263246bbe49d32fbea47d7ae9"", ""filename"": ""chrome/browser/ui/cocoa/bookmarks/bookmark_editor_controller_unittest.mm"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 0, ""changes"": 39, ""blob_url"": ""https://github.com/chromium/chromium/blob/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/cocoa/bookmarks/bookmark_editor_controller_unittest.mm"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/cocoa/bookmarks/bookmark_editor_controller_unittest.mm"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/cocoa/bookmarks/bookmark_editor_controller_unittest.mm?ref=fa34e547d6ee25ea0692436ba7462ed0a0ef45f4"", ""patch"": ""@@ -259,6 +259,45 @@ void TearDown() override {\n   [controller_ cancel:nil];\n }\n \n+using BookmarkEditorControllerEditKeepsSchemeTest = CocoaProfileTest;\n+TEST_F(BookmarkEditorControllerEditKeepsSchemeTest, EditKeepsScheme) {\n+  // Edits the bookmark and ensures resulting URL keeps the same scheme, even\n+  // when userinfo is present in the URL\n+  ASSERT_TRUE(profile());\n+\n+  BookmarkModel* model = BookmarkModelFactory::GetForBrowserContext(profile());\n+  const BookmarkNode* kParent = model->bookmark_bar_node();\n+  const base::string16 kTitle = ASCIIToUTF16(\""EditingKeepsScheme\"");\n+\n+  const GURL kUrl = GURL(\""http://javascript:scripttext@example.com/\"");\n+  const BookmarkNode* kNode = model->AddURL(kParent, 0, base::string16(), kUrl);\n+\n+  BookmarkEditorController* controller = [[BookmarkEditorController alloc]\n+      initWithParentWindow:test_window()\n+                   profile:profile()\n+                    parent:kParent\n+                      node:kNode\n+                       url:GURL()\n+                     title:base::string16()\n+             configuration:BookmarkEditor::SHOW_TREE];\n+\n+  [controller runAsModalSheet];\n+\n+  // We expect only the trailing / to be trimmed when userinfo is present\n+  EXPECT_NSEQ(base::SysUTF8ToNSString(kUrl.spec()),\n+              [[controller displayURL] stringByAppendingString:@\""/\""]);\n+\n+  [controller setDisplayName:base::SysUTF16ToNSString(kTitle)];\n+\n+  EXPECT_TRUE([controller okButtonEnabled]);\n+  [controller ok:nil];\n+\n+  ASSERT_EQ(1, kParent->child_count());\n+  const BookmarkNode* kChild = kParent->GetChild(0);\n+  EXPECT_EQ(kTitle, kChild->GetTitle());\n+  EXPECT_EQ(kUrl, kChild->url());\n+}\n+\n class BookmarkEditorControllerTreeTest : public CocoaProfileTest {\n \n  public:""}<_**next**_>{""sha"": ""2abe3d77823e2f144ab3c2c62b5117ac182d68d0"", ""filename"": ""chrome/browser/ui/views/bookmarks/bookmark_editor_view_unittest.cc"", ""status"": ""modified"", ""additions"": 35, ""deletions"": 0, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/views/bookmarks/bookmark_editor_view_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/views/bookmarks/bookmark_editor_view_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/bookmarks/bookmark_editor_view_unittest.cc?ref=fa34e547d6ee25ea0692436ba7462ed0a0ef45f4"", ""patch"": ""@@ -73,6 +73,13 @@ class BookmarkEditorViewTest : public testing::Test {\n       editor_->url_tf_->SetText(text);\n   }\n \n+  base::string16 GetURLText() const {\n+    if (editor_->details_.type != BookmarkEditor::EditDetails::NEW_FOLDER)\n+      return editor_->url_tf_->text();\n+\n+    return base::string16();\n+  }\n+\n   void ApplyEdits() {\n     editor_->ApplyEdits();\n   }\n@@ -332,6 +339,34 @@ TEST_F(BookmarkEditorViewTest, ChangeTitleNoTree) {\n   EXPECT_EQ(ASCIIToUTF16(\""new_a\""), new_node->GetTitle());\n }\n \n+// Edits the bookmark and ensures resulting URL keeps the same scheme, even\n+// when userinfo is present in the URL\n+TEST_F(BookmarkEditorViewTest, EditKeepsScheme) {\n+  const BookmarkNode* kBBNode = model_->bookmark_bar_node();\n+\n+  const GURL kUrl = GURL(\""http://javascript:scripttext@example.com/\"");\n+\n+  CreateEditor(profile_.get(), kBBNode,\n+               BookmarkEditor::EditDetails::AddNodeInFolder(kBBNode, 1, kUrl,\n+                                                            base::string16()),\n+               BookmarkEditorView::SHOW_TREE);\n+\n+  // We expect only the trailing / to be trimmed when userinfo is present\n+  EXPECT_EQ(ASCIIToUTF16(kUrl.spec()), GetURLText() + ASCIIToUTF16(\""/\""));\n+\n+  const base::string16& kTitle = ASCIIToUTF16(\""EditingKeepsScheme\"");\n+  SetTitleText(kTitle);\n+\n+  ApplyEdits(editor_tree_model()->GetRoot()->GetChild(0));\n+\n+  ASSERT_EQ(4, kBBNode->child_count());\n+\n+  const BookmarkNode* kNewNode = kBBNode->GetChild(1);\n+\n+  EXPECT_EQ(kTitle, kNewNode->GetTitle());\n+  EXPECT_EQ(kUrl, kNewNode->url());\n+}\n+\n // Creates a new folder.\n TEST_F(BookmarkEditorViewTest, NewFolder) {\n   const BookmarkNode* bb_node = model_->bookmark_bar_node();""}"," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
  // and trailing slash, and unescape most characters. However, it's
  url_formatter::FormatUrlTypes format_types =
      url_formatter::kFormatUrlOmitAll &
      ~url_formatter::kFormatUrlOmitUsernamePassword;

  // If username is present, we must not omit the scheme because FixupURL() will
  // subsequently interpret the username as a scheme. crbug.com/639126
  if (url.has_username())
    format_types &= ~url_formatter::kFormatUrlOmitHTTP;

  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
                                  nullptr, nullptr, nullptr);
 }
"," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
  return url_formatter::FormatUrl(
      url, url_formatter::kFormatUrlOmitAll &
               ~url_formatter::kFormatUrlOmitUsernamePassword,
      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
 }
",C,"  // and trailing slash, and unescape most characters. However, it's
  url_formatter::FormatUrlTypes format_types =
      url_formatter::kFormatUrlOmitAll &
      ~url_formatter::kFormatUrlOmitUsernamePassword;

  // If username is present, we must not omit the scheme because FixupURL() will
  // subsequently interpret the username as a scheme. crbug.com/639126
  if (url.has_username())
    format_types &= ~url_formatter::kFormatUrlOmitHTTP;

  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
                                  nullptr, nullptr, nullptr);
","  return url_formatter::FormatUrl(
      url, url_formatter::kFormatUrlOmitAll &
               ~url_formatter::kFormatUrlOmitUsernamePassword,
      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
",,"@@ -126,13 +126,20 @@ void ToggleBookmarkBarWhenVisible(content::BrowserContext* browser_context) {
 
 base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
   // Because this gets re-parsed by FixupURL(), it's safe to omit the scheme
-  // and trailing slash, and unescape most characters.  However, it's
+  // and trailing slash, and unescape most characters. However, it's
   // important not to drop any username/password, or unescape anything that
   // changes the URL's meaning.
-  return url_formatter::FormatUrl(
-      url, url_formatter::kFormatUrlOmitAll &
-               ~url_formatter::kFormatUrlOmitUsernamePassword,
-      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
+  url_formatter::FormatUrlTypes format_types =
+      url_formatter::kFormatUrlOmitAll &
+      ~url_formatter::kFormatUrlOmitUsernamePassword;
+
+  // If username is present, we must not omit the scheme because FixupURL() will
+  // subsequently interpret the username as a scheme. crbug.com/639126
+  if (url.has_username())
+    format_types &= ~url_formatter::kFormatUrlOmitHTTP;
+
+  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
+                                  nullptr, nullptr, nullptr);
 }
 
 bool IsAppsShortcutEnabled(Profile* profile) {",Chrome,fa34e547d6ee25ea0692436ba7462ed0a0ef45f4,60cf29f2af9a364c215f71c9ac8fdd92c16b82b4,1," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
   // Because this gets re-parsed by FixupURL(), it's safe to omit the scheme
//flaw_line_below:
  // and trailing slash, and unescape most characters.  However, it's
//fix_flaw_line_below:
//  // and trailing slash, and unescape most characters. However, it's
   // important not to drop any username/password, or unescape anything that
   // changes the URL's meaning.
//flaw_line_below:
  return url_formatter::FormatUrl(
//flaw_line_below:
      url, url_formatter::kFormatUrlOmitAll &
//flaw_line_below:
               ~url_formatter::kFormatUrlOmitUsernamePassword,
//flaw_line_below:
      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
//fix_flaw_line_below:
//  url_formatter::FormatUrlTypes format_types =
//fix_flaw_line_below:
//      url_formatter::kFormatUrlOmitAll &
//fix_flaw_line_below:
//      ~url_formatter::kFormatUrlOmitUsernamePassword;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  // If username is present, we must not omit the scheme because FixupURL() will
//fix_flaw_line_below:
//  // subsequently interpret the username as a scheme. crbug.com/639126
//fix_flaw_line_below:
//  if (url.has_username())
//fix_flaw_line_below:
//    format_types &= ~url_formatter::kFormatUrlOmitHTTP;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
//fix_flaw_line_below:
//                                  nullptr, nullptr, nullptr);
 }
"
8510,186246,,Remote,Not required,,CVE-2016-1652,https://www.cvedetails.com/cve/CVE-2016-1652/,CWE-79,Medium,,Partial,,2016-04-18,4.3,"Cross-site scripting (XSS) vulnerability in the ModuleSystem::RequireForJsInner function in extensions/renderer/module_system.cc in the Extensions subsystem in Google Chrome before 50.0.2661.75 allows remote attackers to inject arbitrary web script or HTML via a crafted web site, aka *Universal XSS (UXSS).*",2018-10-30,XSS ,5,https://github.com/chromium/chromium/commit/7c5aa07be11cd63d953fbe66370c5869a52170bf,7c5aa07be11cd63d953fbe66370c5869a52170bf,"Use install_static::GetAppGuid instead of the hardcoded string in BrandcodeConfigFetcher.

Bug: 769756
Change-Id: Ifdcb0a5145ffad1d563562e2b2ea2390ff074cdc
Reviewed-on: https://chromium-review.googlesource.com/1213178
Reviewed-by: Dominic Battré <battre@chromium.org>
Commit-Queue: Vasilii Sukhanov <vasilii@chromium.org>
Cr-Commit-Position: refs/heads/master@{#590275}",6,chrome/browser/profile_resetter/brandcode_config_fetcher.cc,"{""sha"": ""c15c60c3ac2815695cc024d1e7891827c18383c5"", ""filename"": ""chrome/browser/profile_resetter/brandcode_config_fetcher.cc"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 10, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/7c5aa07be11cd63d953fbe66370c5869a52170bf/chrome/browser/profile_resetter/brandcode_config_fetcher.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7c5aa07be11cd63d953fbe66370c5869a52170bf/chrome/browser/profile_resetter/brandcode_config_fetcher.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profile_resetter/brandcode_config_fetcher.cc?ref=7c5aa07be11cd63d953fbe66370c5869a52170bf"", ""patch"": ""@@ -9,7 +9,9 @@\n \n #include \""base/callback_helpers.h\""\n #include \""base/macros.h\""\n+#include \""base/strings/stringprintf.h\""\n #include \""base/strings/utf_string_conversions.h\""\n+#include \""build/build_config.h\""\n #include \""chrome/browser/browser_process.h\""\n #include \""chrome/browser/profile_resetter/brandcoded_default_settings.h\""\n #include \""libxml/parser.h\""\n@@ -20,30 +22,34 @@\n #include \""services/network/public/cpp/simple_url_loader.h\""\n #include \""services/network/public/mojom/url_loader_factory.mojom.h\""\n \n+#if defined(OS_WIN)\n+#include \""chrome/install_static/install_util.h\""\n+#endif  // defined(OS_WIN)\n+\n namespace {\n \n-const int kDownloadTimeoutSec = 10;\n-const char kPostXml[] =\n+constexpr char kDefaultAppID[] = \""{8A69D345-D564-463C-AFF1-A69D9E530F96}\"";\n+constexpr int kDownloadTimeoutSec = 10;\n+constexpr char kPostXml[] =\n     \""<?xml version=\\\""1.0\\\"" encoding=\\\""UTF-8\\\""?>\""\n     \""<request\""\n     \""    version=\\\""chromeprofilereset-1.1\\\""\""\n     \""    protocol=\\\""3.0\\\""\""\n     \""    installsource=\\\""profilereset\\\"">\""\n-    \""  <app appid=\\\""{8A69D345-D564-463C-AFF1-A69D9E530F96}\\\"">\""\n-    \""    <data name=\\\""install\\\"" index=\\\""__BRANDCODE_PLACEHOLDER__\\\""/>\""\n+    \""  <app appid=\\\""%s\\\"">\""\n+    \""    <data name=\\\""install\\\"" index=\\\""%s\\\""/>\""\n     \""  </app>\""\n     \""</request>\"";\n \n // Returns the query to the server which can be used to retrieve the config.\n // |brand| is a brand code, it mustn't be empty.\n std::string GetUploadData(const std::string& brand) {\n+  std::string app_id(kDefaultAppID);\n+#if defined(OS_WIN)\n+  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());\n+#endif  // defined(OS_WIN)\n   DCHECK(!brand.empty());\n-  std::string data(kPostXml);\n-  const std::string placeholder(\""__BRANDCODE_PLACEHOLDER__\"");\n-  size_t placeholder_pos = data.find(placeholder);\n-  DCHECK(placeholder_pos != std::string::npos);\n-  data.replace(placeholder_pos, placeholder.size(), brand);\n-  return data;\n+  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());\n }\n \n // Extracts json master prefs from xml.""}"," std::string GetUploadData(const std::string& brand) {
  std::string app_id(kDefaultAppID);
#if defined(OS_WIN)
  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
#endif  // defined(OS_WIN)
   DCHECK(!brand.empty());
  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
 }
"," std::string GetUploadData(const std::string& brand) {
   DCHECK(!brand.empty());
  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
 }
",C,"  std::string app_id(kDefaultAppID);
#if defined(OS_WIN)
  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
#endif  // defined(OS_WIN)
  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
","  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
",,"@@ -9,7 +9,9 @@
 
 #include ""base/callback_helpers.h""
 #include ""base/macros.h""
+#include ""base/strings/stringprintf.h""
 #include ""base/strings/utf_string_conversions.h""
+#include ""build/build_config.h""
 #include ""chrome/browser/browser_process.h""
 #include ""chrome/browser/profile_resetter/brandcoded_default_settings.h""
 #include ""libxml/parser.h""
@@ -20,30 +22,34 @@
 #include ""services/network/public/cpp/simple_url_loader.h""
 #include ""services/network/public/mojom/url_loader_factory.mojom.h""
 
+#if defined(OS_WIN)
+#include ""chrome/install_static/install_util.h""
+#endif  // defined(OS_WIN)
+
 namespace {
 
-const int kDownloadTimeoutSec = 10;
-const char kPostXml[] =
+constexpr char kDefaultAppID[] = ""{8A69D345-D564-463C-AFF1-A69D9E530F96}"";
+constexpr int kDownloadTimeoutSec = 10;
+constexpr char kPostXml[] =
     ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>""
     ""<request""
     ""    version=\""chromeprofilereset-1.1\""""
     ""    protocol=\""3.0\""""
     ""    installsource=\""profilereset\"">""
-    ""  <app appid=\""{8A69D345-D564-463C-AFF1-A69D9E530F96}\"">""
-    ""    <data name=\""install\"" index=\""__BRANDCODE_PLACEHOLDER__\""/>""
+    ""  <app appid=\""%s\"">""
+    ""    <data name=\""install\"" index=\""%s\""/>""
     ""  </app>""
     ""</request>"";
 
 // Returns the query to the server which can be used to retrieve the config.
 // |brand| is a brand code, it mustn't be empty.
 std::string GetUploadData(const std::string& brand) {
+  std::string app_id(kDefaultAppID);
+#if defined(OS_WIN)
+  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
+#endif  // defined(OS_WIN)
   DCHECK(!brand.empty());
-  std::string data(kPostXml);
-  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
-  size_t placeholder_pos = data.find(placeholder);
-  DCHECK(placeholder_pos != std::string::npos);
-  data.replace(placeholder_pos, placeholder.size(), brand);
-  return data;
+  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
 }
 
 // Extracts json master prefs from xml.",Chrome,7c5aa07be11cd63d953fbe66370c5869a52170bf,32582f5489e1e45821e4583886ba5c19845bb2ac,1," std::string GetUploadData(const std::string& brand) {
//fix_flaw_line_below:
//  std::string app_id(kDefaultAppID);
//fix_flaw_line_below:
//#if defined(OS_WIN)
//fix_flaw_line_below:
//  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
//fix_flaw_line_below:
//#endif  // defined(OS_WIN)
   DCHECK(!brand.empty());
//flaw_line_below:
  std::string data(kPostXml);
//flaw_line_below:
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
//flaw_line_below:
  size_t placeholder_pos = data.find(placeholder);
//flaw_line_below:
  DCHECK(placeholder_pos != std::string::npos);
//flaw_line_below:
  data.replace(placeholder_pos, placeholder.size(), brand);
//flaw_line_below:
  return data;
//fix_flaw_line_below:
//  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
 }
"
8630,186366,,Remote,Not required,,CVE-2017-5069,https://www.cvedetails.com/cve/CVE-2017-5069/,CWE-79,Medium,,Partial,,2017-10-27,4.3,"Incorrect MIME type of XSS-Protection reports in Blink in Google Chrome prior to 58.0.3029.81 for Linux, Windows, and Mac, and 58.0.3029.83 for Android, allowed a remote attacker to circumvent Cross-Origin Resource Sharing checks via a crafted HTML page.",2019-10-02,XSS ,1,https://github.com/chromium/chromium/commit/7a0dee9d17d0ee7fd1b40b017442f4952384a7c2,7a0dee9d17d0ee7fd1b40b017442f4952384a7c2,"Prevent regular mode session startup pref type turning to default.

When user loses past session tabs of regular mode after
invoking a new window from the incognito mode.

This was happening because the SessionStartUpPref type was being set
to default, from last, for regular user mode. This was happening in
the RestoreIfNecessary method where the restoration was taking place
for users whose SessionStartUpPref type was set to last.

The fix was to make the protocol of changing the pref type to
default more explicit to incognito users and not regular users
of pref type last.

Bug: 481373
Change-Id: I96efb4cf196949312181c83c6dcd45986ddded13
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1774441
Reviewed-by: Tommy Martino <tmartino@chromium.org>
Reviewed-by: Ramin Halavati <rhalavati@chromium.org>
Commit-Queue: Rohit Agarwal <roagarwal@chromium.org>
Cr-Commit-Position: refs/heads/master@{#691726}",2,chrome/browser/ui/startup/startup_browser_creator.cc,"{""sha"": ""f118e6d27ecca45fecfc48580608159a47d2de24"", ""filename"": ""chrome/browser/ui/startup/startup_browser_creator.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/7a0dee9d17d0ee7fd1b40b017442f4952384a7c2/chrome/browser/ui/startup/startup_browser_creator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7a0dee9d17d0ee7fd1b40b017442f4952384a7c2/chrome/browser/ui/startup/startup_browser_creator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/startup/startup_browser_creator.cc?ref=7a0dee9d17d0ee7fd1b40b017442f4952384a7c2"", ""patch"": ""@@ -468,8 +468,7 @@ SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(\n       pref.type = SessionStartupPref::LAST;\n   }\n \n-  if (pref.type == SessionStartupPref::LAST &&\n-      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {\n+  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {\n     // We don't store session information when incognito. If the user has\n     // chosen to restore last session and launched incognito, fallback to\n     // default launch behavior.""}","SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
","SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
  if (pref.type == SessionStartupPref::LAST &&
      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
",C,"  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
","  if (pref.type == SessionStartupPref::LAST &&
      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
",,"@@ -468,8 +468,7 @@ SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
       pref.type = SessionStartupPref::LAST;
   }
 
-  if (pref.type == SessionStartupPref::LAST &&
-      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
+  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
     // We don't store session information when incognito. If the user has
     // chosen to restore last session and launched incognito, fallback to
     // default launch behavior.",Chrome,7a0dee9d17d0ee7fd1b40b017442f4952384a7c2,278e05fafb1fc77c5d23425c3c1c5ee5a4082f17,1,"SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

  // IsChromeFirstRun() looks for a sentinel file to determine whether the user
  // is starting Chrome for the first time. On Chrome OS, the sentinel is stored
  // in a location shared by all users and the check is meaningless. Query the
  // UserManager instead to determine whether the user is new.
#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  // On ChromeOS restarts force the user to login again. The expectation is that
  // after a login the user gets clean state. For this reason we ignore
  // StartupBrowserCreator::WasRestarted(). However
  // StartupBrowserCreator::WasRestarted has to be called in order to correctly
  // update pref values.
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  // The pref has an OS-dependent default value. For the first run only, this
  // default is overridden with SessionStartupPref::DEFAULT so that first run
  // behavior (sync promo, welcome page) is consistently invoked.
  // This applies only if the pref is still at its default and has not been
  // set by the user, managed prefs or policy.
  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  // The switches::kRestoreLastSession command line switch is used to restore
  // sessions after a browser self restart (e.g. after a Chrome upgrade).
  // However, new profiles can be created from a browser process that has this
  // switch so do not set the session pref to SessionStartupPref::LAST for
  // those as there is nothing to restore.
  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  // A browser starting for a profile being unlocked should always restore.
  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
//flaw_line_below:
  if (pref.type == SessionStartupPref::LAST &&
//flaw_line_below:
      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
//fix_flaw_line_below:
//  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
     // We don't store session information when incognito. If the user has
     // chosen to restore last session and launched incognito, fallback to
     // default launch behavior.
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
"
8682,186418,,Remote,Not required,,CVE-2017-5008,https://www.cvedetails.com/cve/CVE-2017-5008/,CWE-79,Medium,,Partial,,2017-02-17,4.3,"Blink in Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, allowed attacker controlled JavaScript to be run during the invocation of a private script method, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via a crafted HTML page.",2018-01-04,XSS ,6,https://github.com/chromium/chromium/commit/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9,c093b7a74ddce32dd3b0e0be60f31becc6ce32f9,"Don't touch the prototype chain to get the private script controller.

Prior to this patch, private scripts attempted to get the
""privateScriptController"" property off the global object without verifying if
the property actually exists on the global. If the property hasn't been set yet,
this operation could descend into the prototype chain and potentially return
a named property from the WindowProperties object, leading to release asserts
and general confusion.

BUG=668552

Review-Url: https://codereview.chromium.org/2529163002
Cr-Commit-Position: refs/heads/master@{#434627}",6,third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp,"{""sha"": ""1560d1019cd74abcf6c6d6d16fc0ed9e83f91c1b"", ""filename"": ""third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash-expected.txt"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash-expected.txt?ref=c093b7a74ddce32dd3b0e0be60f31becc6ce32f9"", ""patch"": ""@@ -0,0 +1,2 @@\n+ \n+Test that a named property doesn't interfere with a private script (https://crbug.com/668552). If the test is successful, it should not crash.""}<_**next**_>{""sha"": ""1e410c0447a83fab2da5eb9fb6693d754719d9e8"", ""filename"": ""third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash.html"", ""status"": ""added"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash.html?ref=c093b7a74ddce32dd3b0e0be60f31becc6ce32f9"", ""patch"": ""@@ -0,0 +1,15 @@\n+<!DOCTYPE html>\n+<html>\n+<body>\n+<script>\n+if (window.testRunner)\n+    testRunner.dumpAsText();\n+</script>\n+<img name=\""privateScriptController\"">\n+<marquee></marquee>\n+<div>\n+Test that a named property doesn't interfere with a private script (https://crbug.com/668552).\n+If the test is successful, it should not crash.\n+</div>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""eb4974e91d06882361bb7a1470c0d82fbb358bd7"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp?ref=c093b7a74ddce32dd3b0e0be60f31becc6ce32f9"", ""patch"": ""@@ -57,12 +57,12 @@ static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,\n \n   v8::Local<v8::Context> context = scriptState->context();\n   v8::Local<v8::Object> global = context->Global();\n-  v8::Local<v8::Value> privateScriptController =\n-      global->Get(context, v8String(isolate, \""privateScriptController\""))\n-          .ToLocalChecked();\n-  RELEASE_ASSERT(privateScriptController->IsUndefined() ||\n-                 privateScriptController->IsObject());\n-  if (privateScriptController->IsObject()) {\n+  v8::Local<v8::String> key = v8String(isolate, \""privateScriptController\"");\n+\n+  if (global->HasOwnProperty(context, key).ToChecked()) {\n+    v8::Local<v8::Value> privateScriptController =\n+        global->Get(context, key).ToLocalChecked();\n+    CHECK(privateScriptController->IsObject());\n     v8::Local<v8::Object> privateScriptControllerObject =\n         privateScriptController.As<v8::Object>();\n     v8::Local<v8::Value> importFunctionValue =""}<_**next**_>{""sha"": ""e2571f43f7722dbf99cb78d37b6c9948ff06e6aa"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.js?ref=c093b7a74ddce32dd3b0e0be60f31becc6ce32f9"", ""patch"": ""@@ -139,7 +139,7 @@ PrivateScriptController.prototype = {\n     },\n }\n \n-if (typeof window.privateScriptController === 'undefined')\n+if (!window.hasOwnProperty(\""privateScriptController\""))\n     window.privateScriptController = new PrivateScriptController();\n \n // This line must be the last statement of this JS file.""}","static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");

  if (global->HasOwnProperty(context, key).ToChecked()) {
    v8::Local<v8::Value> privateScriptController =
        global->Get(context, key).ToLocalChecked();
    CHECK(privateScriptController->IsObject());
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
","static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
  v8::Local<v8::Value> privateScriptController =
      global->Get(context, v8String(isolate, ""privateScriptController""))
          .ToLocalChecked();
  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
                 privateScriptController->IsObject());
  if (privateScriptController->IsObject()) {
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
",C,"  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");

  if (global->HasOwnProperty(context, key).ToChecked()) {
    v8::Local<v8::Value> privateScriptController =
        global->Get(context, key).ToLocalChecked();
    CHECK(privateScriptController->IsObject());
","  v8::Local<v8::Value> privateScriptController =
      global->Get(context, v8String(isolate, ""privateScriptController""))
          .ToLocalChecked();
  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
                 privateScriptController->IsObject());
  if (privateScriptController->IsObject()) {
",,"@@ -57,12 +57,12 @@ static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
-  v8::Local<v8::Value> privateScriptController =
-      global->Get(context, v8String(isolate, ""privateScriptController""))
-          .ToLocalChecked();
-  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
-                 privateScriptController->IsObject());
-  if (privateScriptController->IsObject()) {
+  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");
+
+  if (global->HasOwnProperty(context, key).ToChecked()) {
+    v8::Local<v8::Value> privateScriptController =
+        global->Get(context, key).ToLocalChecked();
+    CHECK(privateScriptController->IsObject());
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =",Chrome,c093b7a74ddce32dd3b0e0be60f31becc6ce32f9,42839ee8c1195b25fbe327057e10c54f592b6693,1,"static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
//flaw_line_below:
  v8::Local<v8::Value> privateScriptController =
//flaw_line_below:
      global->Get(context, v8String(isolate, ""privateScriptController""))
//flaw_line_below:
          .ToLocalChecked();
//flaw_line_below:
  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
//flaw_line_below:
                 privateScriptController->IsObject());
//flaw_line_below:
  if (privateScriptController->IsObject()) {
//fix_flaw_line_below:
//  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  if (global->HasOwnProperty(context, key).ToChecked()) {
//fix_flaw_line_below:
//    v8::Local<v8::Value> privateScriptController =
//fix_flaw_line_below:
//        global->Get(context, key).ToLocalChecked();
//fix_flaw_line_below:
//    CHECK(privateScriptController->IsObject());
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      // This is a memory leak, FunctionTemplates are eternal.
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
"
8728,186464,,Remote,Not required,,CVE-2016-5204,https://www.cvedetails.com/cve/CVE-2016-5204/,CWE-79,Medium,,Partial,,2017-01-19,4.3,"Leaking of an SVG shadow tree leading to corruption of the DOM tree in Blink in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via a crafted HTML page.",2018-01-04,XSS ,2,https://github.com/chromium/chromium/commit/e1e67d5d341d82c61cab2c41ff4163f17caf14ae,e1e67d5d341d82c61cab2c41ff4163f17caf14ae,"Add boolean to UserIntiatedInfo noting if an input event led to navigation.

Also refactor UkmPageLoadMetricsObserver to use this new boolean to
report the user initiated metric in RecordPageLoadExtraInfoMetrics, so
that it works correctly in the case when the page load failed.

Bug: 925104
Change-Id: Ie08e7d3912cb1da484190d838005e95e57a209ff
Reviewed-on: https://chromium-review.googlesource.com/c/1450460
Commit-Queue: Annie Sullivan <sullivan@chromium.org>
Reviewed-by: Bryan McQuade <bmcquade@chromium.org>
Cr-Commit-Position: refs/heads/master@{#630870}",1,chrome/browser/page_load_metrics/metrics_web_contents_observer.cc,"{""sha"": ""84aefa862231c8d85a72fa28455f44beac54da47"", ""filename"": ""chrome/browser/page_load_metrics/metrics_web_contents_observer.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/metrics_web_contents_observer.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/metrics_web_contents_observer.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/page_load_metrics/metrics_web_contents_observer.cc?ref=e1e67d5d341d82c61cab2c41ff4163f17caf14ae"", ""patch"": ""@@ -55,7 +55,8 @@ UserInitiatedInfo CreateUserInitiatedInfo(\n     return UserInitiatedInfo::BrowserInitiated();\n \n   return UserInitiatedInfo::RenderInitiated(\n-      navigation_handle->HasUserGesture());\n+      navigation_handle->HasUserGesture(),\n+      !navigation_handle->NavigationInputStart().is_null());\n }\n \n }  // namespace""}<_**next**_>{""sha"": ""63a77f5e9c8e26cafaba4f913cec16dfe8903e63"", ""filename"": ""chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 10, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer.cc?ref=e1e67d5d341d82c61cab2c41ff4163f17caf14ae"", ""patch"": ""@@ -161,16 +161,6 @@ void UkmPageLoadMetricsObserver::RecordTimingMetrics(\n     const page_load_metrics::mojom::PageLoadTiming& timing,\n     const page_load_metrics::PageLoadExtraInfo& info) {\n   ukm::builders::PageLoad builder(info.source_id);\n-  bool is_user_initiated_navigation =\n-      // All browser initiated page loads are user-initiated.\n-      info.user_initiated_info.browser_initiated ||\n-\n-      // Renderer-initiated navigations are user-initiated if there is an\n-      // associated input timestamp.\n-      timing.input_to_navigation_start;\n-\n-  builder.SetExperimental_Navigation_UserInitiated(\n-      is_user_initiated_navigation);\n   if (timing.input_to_navigation_start) {\n     builder.SetExperimental_InputToNavigationStart(\n         timing.input_to_navigation_start.value().InMilliseconds());\n@@ -294,6 +284,17 @@ void UkmPageLoadMetricsObserver::RecordPageLoadExtraInfoMetrics(\n         foreground_duration.value().InMilliseconds());\n   }\n \n+  bool is_user_initiated_navigation =\n+      // All browser initiated page loads are user-initiated.\n+      info.user_initiated_info.browser_initiated ||\n+\n+      // Renderer-initiated navigations are user-initiated if there is an\n+      // associated input event.\n+      info.user_initiated_info.user_input_event;\n+\n+  builder.SetExperimental_Navigation_UserInitiated(\n+      is_user_initiated_navigation);\n+\n   // Convert to the EffectiveConnectionType as used in SystemProfileProto\n   // before persisting the metric.\n   metrics::SystemProfileProto::Network::EffectiveConnectionType""}<_**next**_>{""sha"": ""cae25b045701d0c64d6a56d617d9ceb3745fc468"", ""filename"": ""chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer_unittest.cc?ref=e1e67d5d341d82c61cab2c41ff4163f17caf14ae"", ""patch"": ""@@ -202,6 +202,9 @@ TEST_F(UkmPageLoadMetricsObserverTest, FailedProvisionalLoad) {\n     EXPECT_TRUE(test_ukm_recorder().EntryHasMetric(\n         kv.second.get(),\n         PageLoad::kPageTiming_NavigationToFailedProvisionalLoadName));\n+    test_ukm_recorder().ExpectEntryMetric(\n+        kv.second.get(), PageLoad::kExperimental_Navigation_UserInitiatedName,\n+        false);\n   }\n }\n ""}<_**next**_>{""sha"": ""fc8f72ece37391372c5b919ed8d2143b236d6133"", ""filename"": ""chrome/browser/page_load_metrics/page_load_metrics_observer.h"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 6, ""changes"": 25, ""blob_url"": ""https://github.com/chromium/chromium/blob/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/page_load_metrics_observer.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/page_load_metrics_observer.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/page_load_metrics/page_load_metrics_observer.h?ref=e1e67d5d341d82c61cab2c41ff4163f17caf14ae"", ""patch"": ""@@ -86,15 +86,16 @@ struct FailedProvisionalLoadInfo {\n // element are examples of user initiation actions.\n struct UserInitiatedInfo {\n   static UserInitiatedInfo NotUserInitiated() {\n-    return UserInitiatedInfo(false, false);\n+    return UserInitiatedInfo(false, false, false);\n   }\n \n   static UserInitiatedInfo BrowserInitiated() {\n-    return UserInitiatedInfo(true, false);\n+    return UserInitiatedInfo(true, false, false);\n   }\n \n-  static UserInitiatedInfo RenderInitiated(bool user_gesture) {\n-    return UserInitiatedInfo(false, user_gesture);\n+  static UserInitiatedInfo RenderInitiated(bool user_gesture,\n+                                           bool user_input_event) {\n+    return UserInitiatedInfo(false, user_gesture, user_input_event);\n   }\n \n   // Whether the associated action was initiated from the browser process, as\n@@ -104,11 +105,23 @@ struct UserInitiatedInfo {\n \n   // Whether the associated action was initiated by a user, according to user\n   // gesture tracking in content and Blink, as reported by NavigationHandle.\n+  // This is based on the heuristic the popup blocker uses.\n   bool user_gesture;\n \n+  // Whether an input even directly led to the navigation, according to\n+  // input start time tracking in the renderer, as reported by NavigationHandle.\n+  // Note that this metric is still experimental and may not be fully\n+  // implemented. All known issues are blocking crbug.com/889220. Currently\n+  // all known gaps affect browser-side navigations.\n+  bool user_input_event;\n+\n  private:\n-  UserInitiatedInfo(bool browser_initiated, bool user_gesture)\n-      : browser_initiated(browser_initiated), user_gesture(user_gesture) {}\n+  UserInitiatedInfo(bool browser_initiated,\n+                    bool user_gesture,\n+                    bool user_input_event)\n+      : browser_initiated(browser_initiated),\n+        user_gesture(user_gesture),\n+        user_input_event(user_input_event) {}\n };\n \n struct PageLoadExtraInfo {""}","UserInitiatedInfo CreateUserInitiatedInfo(
    content::NavigationHandle* navigation_handle,
    PageLoadTracker* committed_load) {
  if (!navigation_handle->IsRendererInitiated())
     return UserInitiatedInfo::BrowserInitiated();
 
   return UserInitiatedInfo::RenderInitiated(
      navigation_handle->HasUserGesture(),
      !navigation_handle->NavigationInputStart().is_null());
 }
","UserInitiatedInfo CreateUserInitiatedInfo(
    content::NavigationHandle* navigation_handle,
    PageLoadTracker* committed_load) {
  if (!navigation_handle->IsRendererInitiated())
     return UserInitiatedInfo::BrowserInitiated();
 
   return UserInitiatedInfo::RenderInitiated(
      navigation_handle->HasUserGesture());
 }
",C,"      navigation_handle->HasUserGesture(),
      !navigation_handle->NavigationInputStart().is_null());
","      navigation_handle->HasUserGesture());
",,"@@ -55,7 +55,8 @@ UserInitiatedInfo CreateUserInitiatedInfo(
     return UserInitiatedInfo::BrowserInitiated();
 
   return UserInitiatedInfo::RenderInitiated(
-      navigation_handle->HasUserGesture());
+      navigation_handle->HasUserGesture(),
+      !navigation_handle->NavigationInputStart().is_null());
 }
 
 }  // namespace",Chrome,e1e67d5d341d82c61cab2c41ff4163f17caf14ae,3a1541f5115ec0d20b3a834dd2597acf4ca645af,1,"UserInitiatedInfo CreateUserInitiatedInfo(
    content::NavigationHandle* navigation_handle,
    PageLoadTracker* committed_load) {
  if (!navigation_handle->IsRendererInitiated())
     return UserInitiatedInfo::BrowserInitiated();
 
   return UserInitiatedInfo::RenderInitiated(
//flaw_line_below:
      navigation_handle->HasUserGesture());
//fix_flaw_line_below:
//      navigation_handle->HasUserGesture(),
//fix_flaw_line_below:
//      !navigation_handle->NavigationInputStart().is_null());
 }
"
8729,186465,,Remote,Not required,,CVE-2016-5204,https://www.cvedetails.com/cve/CVE-2016-5204/,CWE-79,Medium,,Partial,,2017-01-19,4.3,"Leaking of an SVG shadow tree leading to corruption of the DOM tree in Blink in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via a crafted HTML page.",2018-01-04,XSS ,11,https://github.com/chromium/chromium/commit/e1e67d5d341d82c61cab2c41ff4163f17caf14ae,e1e67d5d341d82c61cab2c41ff4163f17caf14ae,"Add boolean to UserIntiatedInfo noting if an input event led to navigation.

Also refactor UkmPageLoadMetricsObserver to use this new boolean to
report the user initiated metric in RecordPageLoadExtraInfoMetrics, so
that it works correctly in the case when the page load failed.

Bug: 925104
Change-Id: Ie08e7d3912cb1da484190d838005e95e57a209ff
Reviewed-on: https://chromium-review.googlesource.com/c/1450460
Commit-Queue: Annie Sullivan <sullivan@chromium.org>
Reviewed-by: Bryan McQuade <bmcquade@chromium.org>
Cr-Commit-Position: refs/heads/master@{#630870}",0,chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer.cc,"{""sha"": ""84aefa862231c8d85a72fa28455f44beac54da47"", ""filename"": ""chrome/browser/page_load_metrics/metrics_web_contents_observer.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/metrics_web_contents_observer.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/metrics_web_contents_observer.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/page_load_metrics/metrics_web_contents_observer.cc?ref=e1e67d5d341d82c61cab2c41ff4163f17caf14ae"", ""patch"": ""@@ -55,7 +55,8 @@ UserInitiatedInfo CreateUserInitiatedInfo(\n     return UserInitiatedInfo::BrowserInitiated();\n \n   return UserInitiatedInfo::RenderInitiated(\n-      navigation_handle->HasUserGesture());\n+      navigation_handle->HasUserGesture(),\n+      !navigation_handle->NavigationInputStart().is_null());\n }\n \n }  // namespace""}<_**next**_>{""sha"": ""63a77f5e9c8e26cafaba4f913cec16dfe8903e63"", ""filename"": ""chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 10, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer.cc?ref=e1e67d5d341d82c61cab2c41ff4163f17caf14ae"", ""patch"": ""@@ -161,16 +161,6 @@ void UkmPageLoadMetricsObserver::RecordTimingMetrics(\n     const page_load_metrics::mojom::PageLoadTiming& timing,\n     const page_load_metrics::PageLoadExtraInfo& info) {\n   ukm::builders::PageLoad builder(info.source_id);\n-  bool is_user_initiated_navigation =\n-      // All browser initiated page loads are user-initiated.\n-      info.user_initiated_info.browser_initiated ||\n-\n-      // Renderer-initiated navigations are user-initiated if there is an\n-      // associated input timestamp.\n-      timing.input_to_navigation_start;\n-\n-  builder.SetExperimental_Navigation_UserInitiated(\n-      is_user_initiated_navigation);\n   if (timing.input_to_navigation_start) {\n     builder.SetExperimental_InputToNavigationStart(\n         timing.input_to_navigation_start.value().InMilliseconds());\n@@ -294,6 +284,17 @@ void UkmPageLoadMetricsObserver::RecordPageLoadExtraInfoMetrics(\n         foreground_duration.value().InMilliseconds());\n   }\n \n+  bool is_user_initiated_navigation =\n+      // All browser initiated page loads are user-initiated.\n+      info.user_initiated_info.browser_initiated ||\n+\n+      // Renderer-initiated navigations are user-initiated if there is an\n+      // associated input event.\n+      info.user_initiated_info.user_input_event;\n+\n+  builder.SetExperimental_Navigation_UserInitiated(\n+      is_user_initiated_navigation);\n+\n   // Convert to the EffectiveConnectionType as used in SystemProfileProto\n   // before persisting the metric.\n   metrics::SystemProfileProto::Network::EffectiveConnectionType""}<_**next**_>{""sha"": ""cae25b045701d0c64d6a56d617d9ceb3745fc468"", ""filename"": ""chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer_unittest.cc?ref=e1e67d5d341d82c61cab2c41ff4163f17caf14ae"", ""patch"": ""@@ -202,6 +202,9 @@ TEST_F(UkmPageLoadMetricsObserverTest, FailedProvisionalLoad) {\n     EXPECT_TRUE(test_ukm_recorder().EntryHasMetric(\n         kv.second.get(),\n         PageLoad::kPageTiming_NavigationToFailedProvisionalLoadName));\n+    test_ukm_recorder().ExpectEntryMetric(\n+        kv.second.get(), PageLoad::kExperimental_Navigation_UserInitiatedName,\n+        false);\n   }\n }\n ""}<_**next**_>{""sha"": ""fc8f72ece37391372c5b919ed8d2143b236d6133"", ""filename"": ""chrome/browser/page_load_metrics/page_load_metrics_observer.h"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 6, ""changes"": 25, ""blob_url"": ""https://github.com/chromium/chromium/blob/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/page_load_metrics_observer.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/page_load_metrics_observer.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/page_load_metrics/page_load_metrics_observer.h?ref=e1e67d5d341d82c61cab2c41ff4163f17caf14ae"", ""patch"": ""@@ -86,15 +86,16 @@ struct FailedProvisionalLoadInfo {\n // element are examples of user initiation actions.\n struct UserInitiatedInfo {\n   static UserInitiatedInfo NotUserInitiated() {\n-    return UserInitiatedInfo(false, false);\n+    return UserInitiatedInfo(false, false, false);\n   }\n \n   static UserInitiatedInfo BrowserInitiated() {\n-    return UserInitiatedInfo(true, false);\n+    return UserInitiatedInfo(true, false, false);\n   }\n \n-  static UserInitiatedInfo RenderInitiated(bool user_gesture) {\n-    return UserInitiatedInfo(false, user_gesture);\n+  static UserInitiatedInfo RenderInitiated(bool user_gesture,\n+                                           bool user_input_event) {\n+    return UserInitiatedInfo(false, user_gesture, user_input_event);\n   }\n \n   // Whether the associated action was initiated from the browser process, as\n@@ -104,11 +105,23 @@ struct UserInitiatedInfo {\n \n   // Whether the associated action was initiated by a user, according to user\n   // gesture tracking in content and Blink, as reported by NavigationHandle.\n+  // This is based on the heuristic the popup blocker uses.\n   bool user_gesture;\n \n+  // Whether an input even directly led to the navigation, according to\n+  // input start time tracking in the renderer, as reported by NavigationHandle.\n+  // Note that this metric is still experimental and may not be fully\n+  // implemented. All known issues are blocking crbug.com/889220. Currently\n+  // all known gaps affect browser-side navigations.\n+  bool user_input_event;\n+\n  private:\n-  UserInitiatedInfo(bool browser_initiated, bool user_gesture)\n-      : browser_initiated(browser_initiated), user_gesture(user_gesture) {}\n+  UserInitiatedInfo(bool browser_initiated,\n+                    bool user_gesture,\n+                    bool user_input_event)\n+      : browser_initiated(browser_initiated),\n+        user_gesture(user_gesture),\n+        user_input_event(user_input_event) {}\n };\n \n struct PageLoadExtraInfo {""}","void UkmPageLoadMetricsObserver::RecordPageLoadExtraInfoMetrics(
    const page_load_metrics::PageLoadExtraInfo& info,
    base::TimeTicks app_background_time) {
  ukm::builders::PageLoad builder(info.source_id);
  base::Optional<base::TimeDelta> foreground_duration =
      page_load_metrics::GetInitialForegroundDuration(info,
                                                      app_background_time);
  if (foreground_duration) {
    builder.SetPageTiming_ForegroundDuration(
         foreground_duration.value().InMilliseconds());
   }
 
  bool is_user_initiated_navigation =
      // All browser initiated page loads are user-initiated.
      info.user_initiated_info.browser_initiated ||

      // Renderer-initiated navigations are user-initiated if there is an
      // associated input event.
      info.user_initiated_info.user_input_event;

  builder.SetExperimental_Navigation_UserInitiated(
      is_user_initiated_navigation);

   metrics::SystemProfileProto::Network::EffectiveConnectionType
      proto_effective_connection_type =
          metrics::ConvertEffectiveConnectionType(effective_connection_type_);
  if (proto_effective_connection_type !=
      metrics::SystemProfileProto::Network::EFFECTIVE_CONNECTION_TYPE_UNKNOWN) {
    builder.SetNet_EffectiveConnectionType2_OnNavigationStart(
        static_cast<int64_t>(proto_effective_connection_type));
  }

  if (http_response_code_) {
    builder.SetNet_HttpResponseCode(
        static_cast<int64_t>(http_response_code_.value()));
  }
  if (http_rtt_estimate_) {
    builder.SetNet_HttpRttEstimate_OnNavigationStart(
        static_cast<int64_t>(http_rtt_estimate_.value().InMilliseconds()));
  }
  if (transport_rtt_estimate_) {
    builder.SetNet_TransportRttEstimate_OnNavigationStart(
        static_cast<int64_t>(transport_rtt_estimate_.value().InMilliseconds()));
  }
  if (downstream_kbps_estimate_) {
    builder.SetNet_DownstreamKbpsEstimate_OnNavigationStart(
        static_cast<int64_t>(downstream_kbps_estimate_.value()));
  }
  builder.SetNavigation_PageTransition(static_cast<int64_t>(page_transition_));
  builder.SetNavigation_PageEndReason(
      static_cast<int64_t>(info.page_end_reason));
  if (info.did_commit && was_cached_) {
    builder.SetWasCached(1);
  }
  builder.Record(ukm::UkmRecorder::Get());
}
","void UkmPageLoadMetricsObserver::RecordPageLoadExtraInfoMetrics(
    const page_load_metrics::PageLoadExtraInfo& info,
    base::TimeTicks app_background_time) {
  ukm::builders::PageLoad builder(info.source_id);
  base::Optional<base::TimeDelta> foreground_duration =
      page_load_metrics::GetInitialForegroundDuration(info,
                                                      app_background_time);
  if (foreground_duration) {
    builder.SetPageTiming_ForegroundDuration(
         foreground_duration.value().InMilliseconds());
   }
 
   metrics::SystemProfileProto::Network::EffectiveConnectionType
      proto_effective_connection_type =
          metrics::ConvertEffectiveConnectionType(effective_connection_type_);
  if (proto_effective_connection_type !=
      metrics::SystemProfileProto::Network::EFFECTIVE_CONNECTION_TYPE_UNKNOWN) {
    builder.SetNet_EffectiveConnectionType2_OnNavigationStart(
        static_cast<int64_t>(proto_effective_connection_type));
  }

  if (http_response_code_) {
    builder.SetNet_HttpResponseCode(
        static_cast<int64_t>(http_response_code_.value()));
  }
  if (http_rtt_estimate_) {
    builder.SetNet_HttpRttEstimate_OnNavigationStart(
        static_cast<int64_t>(http_rtt_estimate_.value().InMilliseconds()));
  }
  if (transport_rtt_estimate_) {
    builder.SetNet_TransportRttEstimate_OnNavigationStart(
        static_cast<int64_t>(transport_rtt_estimate_.value().InMilliseconds()));
  }
  if (downstream_kbps_estimate_) {
    builder.SetNet_DownstreamKbpsEstimate_OnNavigationStart(
        static_cast<int64_t>(downstream_kbps_estimate_.value()));
  }
  builder.SetNavigation_PageTransition(static_cast<int64_t>(page_transition_));
  builder.SetNavigation_PageEndReason(
      static_cast<int64_t>(info.page_end_reason));
  if (info.did_commit && was_cached_) {
    builder.SetWasCached(1);
  }
  builder.Record(ukm::UkmRecorder::Get());
}
",C,"  bool is_user_initiated_navigation =
      // All browser initiated page loads are user-initiated.
      info.user_initiated_info.browser_initiated ||

      // Renderer-initiated navigations are user-initiated if there is an
      // associated input event.
      info.user_initiated_info.user_input_event;

  builder.SetExperimental_Navigation_UserInitiated(
      is_user_initiated_navigation);

",,,"@@ -161,16 +161,6 @@ void UkmPageLoadMetricsObserver::RecordTimingMetrics(
     const page_load_metrics::mojom::PageLoadTiming& timing,
     const page_load_metrics::PageLoadExtraInfo& info) {
   ukm::builders::PageLoad builder(info.source_id);
-  bool is_user_initiated_navigation =
-      // All browser initiated page loads are user-initiated.
-      info.user_initiated_info.browser_initiated ||
-
-      // Renderer-initiated navigations are user-initiated if there is an
-      // associated input timestamp.
-      timing.input_to_navigation_start;
-
-  builder.SetExperimental_Navigation_UserInitiated(
-      is_user_initiated_navigation);
   if (timing.input_to_navigation_start) {
     builder.SetExperimental_InputToNavigationStart(
         timing.input_to_navigation_start.value().InMilliseconds());
@@ -294,6 +284,17 @@ void UkmPageLoadMetricsObserver::RecordPageLoadExtraInfoMetrics(
         foreground_duration.value().InMilliseconds());
   }
 
+  bool is_user_initiated_navigation =
+      // All browser initiated page loads are user-initiated.
+      info.user_initiated_info.browser_initiated ||
+
+      // Renderer-initiated navigations are user-initiated if there is an
+      // associated input event.
+      info.user_initiated_info.user_input_event;
+
+  builder.SetExperimental_Navigation_UserInitiated(
+      is_user_initiated_navigation);
+
   // Convert to the EffectiveConnectionType as used in SystemProfileProto
   // before persisting the metric.
   metrics::SystemProfileProto::Network::EffectiveConnectionType",Chrome,e1e67d5d341d82c61cab2c41ff4163f17caf14ae,3a1541f5115ec0d20b3a834dd2597acf4ca645af,1,"void UkmPageLoadMetricsObserver::RecordPageLoadExtraInfoMetrics(
    const page_load_metrics::PageLoadExtraInfo& info,
    base::TimeTicks app_background_time) {
  ukm::builders::PageLoad builder(info.source_id);
  base::Optional<base::TimeDelta> foreground_duration =
      page_load_metrics::GetInitialForegroundDuration(info,
                                                      app_background_time);
  if (foreground_duration) {
    builder.SetPageTiming_ForegroundDuration(
         foreground_duration.value().InMilliseconds());
   }
 
//fix_flaw_line_below:
//  bool is_user_initiated_navigation =
//fix_flaw_line_below:
//      // All browser initiated page loads are user-initiated.
//fix_flaw_line_below:
//      info.user_initiated_info.browser_initiated ||
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      // Renderer-initiated navigations are user-initiated if there is an
//fix_flaw_line_below:
//      // associated input event.
//fix_flaw_line_below:
//      info.user_initiated_info.user_input_event;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  builder.SetExperimental_Navigation_UserInitiated(
//fix_flaw_line_below:
//      is_user_initiated_navigation);
//fix_flaw_line_below:
//
   // Convert to the EffectiveConnectionType as used in SystemProfileProto
   // before persisting the metric.
   metrics::SystemProfileProto::Network::EffectiveConnectionType
      proto_effective_connection_type =
          metrics::ConvertEffectiveConnectionType(effective_connection_type_);
  if (proto_effective_connection_type !=
      metrics::SystemProfileProto::Network::EFFECTIVE_CONNECTION_TYPE_UNKNOWN) {
    builder.SetNet_EffectiveConnectionType2_OnNavigationStart(
        static_cast<int64_t>(proto_effective_connection_type));
  }

  if (http_response_code_) {
    builder.SetNet_HttpResponseCode(
        static_cast<int64_t>(http_response_code_.value()));
  }
  if (http_rtt_estimate_) {
    builder.SetNet_HttpRttEstimate_OnNavigationStart(
        static_cast<int64_t>(http_rtt_estimate_.value().InMilliseconds()));
  }
  if (transport_rtt_estimate_) {
    builder.SetNet_TransportRttEstimate_OnNavigationStart(
        static_cast<int64_t>(transport_rtt_estimate_.value().InMilliseconds()));
  }
  if (downstream_kbps_estimate_) {
    builder.SetNet_DownstreamKbpsEstimate_OnNavigationStart(
        static_cast<int64_t>(downstream_kbps_estimate_.value()));
  }
  // page_transition_ fits in a uint32_t, so we can safely cast to int64_t.
  builder.SetNavigation_PageTransition(static_cast<int64_t>(page_transition_));
  // info.page_end_reason fits in a uint32_t, so we can safely cast to int64_t.
  builder.SetNavigation_PageEndReason(
      static_cast<int64_t>(info.page_end_reason));
  if (info.did_commit && was_cached_) {
    builder.SetWasCached(1);
  }
  builder.Record(ukm::UkmRecorder::Get());
}
"
8730,186466,,Remote,Not required,,CVE-2016-5204,https://www.cvedetails.com/cve/CVE-2016-5204/,CWE-79,Medium,,Partial,,2017-01-19,4.3,"Leaking of an SVG shadow tree leading to corruption of the DOM tree in Blink in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via a crafted HTML page.",2018-01-04,XSS ,0,https://github.com/chromium/chromium/commit/e1e67d5d341d82c61cab2c41ff4163f17caf14ae,e1e67d5d341d82c61cab2c41ff4163f17caf14ae,"Add boolean to UserIntiatedInfo noting if an input event led to navigation.

Also refactor UkmPageLoadMetricsObserver to use this new boolean to
report the user initiated metric in RecordPageLoadExtraInfoMetrics, so
that it works correctly in the case when the page load failed.

Bug: 925104
Change-Id: Ie08e7d3912cb1da484190d838005e95e57a209ff
Reviewed-on: https://chromium-review.googlesource.com/c/1450460
Commit-Queue: Annie Sullivan <sullivan@chromium.org>
Reviewed-by: Bryan McQuade <bmcquade@chromium.org>
Cr-Commit-Position: refs/heads/master@{#630870}",5,chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer.cc,"{""sha"": ""84aefa862231c8d85a72fa28455f44beac54da47"", ""filename"": ""chrome/browser/page_load_metrics/metrics_web_contents_observer.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/metrics_web_contents_observer.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/metrics_web_contents_observer.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/page_load_metrics/metrics_web_contents_observer.cc?ref=e1e67d5d341d82c61cab2c41ff4163f17caf14ae"", ""patch"": ""@@ -55,7 +55,8 @@ UserInitiatedInfo CreateUserInitiatedInfo(\n     return UserInitiatedInfo::BrowserInitiated();\n \n   return UserInitiatedInfo::RenderInitiated(\n-      navigation_handle->HasUserGesture());\n+      navigation_handle->HasUserGesture(),\n+      !navigation_handle->NavigationInputStart().is_null());\n }\n \n }  // namespace""}<_**next**_>{""sha"": ""63a77f5e9c8e26cafaba4f913cec16dfe8903e63"", ""filename"": ""chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 10, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer.cc?ref=e1e67d5d341d82c61cab2c41ff4163f17caf14ae"", ""patch"": ""@@ -161,16 +161,6 @@ void UkmPageLoadMetricsObserver::RecordTimingMetrics(\n     const page_load_metrics::mojom::PageLoadTiming& timing,\n     const page_load_metrics::PageLoadExtraInfo& info) {\n   ukm::builders::PageLoad builder(info.source_id);\n-  bool is_user_initiated_navigation =\n-      // All browser initiated page loads are user-initiated.\n-      info.user_initiated_info.browser_initiated ||\n-\n-      // Renderer-initiated navigations are user-initiated if there is an\n-      // associated input timestamp.\n-      timing.input_to_navigation_start;\n-\n-  builder.SetExperimental_Navigation_UserInitiated(\n-      is_user_initiated_navigation);\n   if (timing.input_to_navigation_start) {\n     builder.SetExperimental_InputToNavigationStart(\n         timing.input_to_navigation_start.value().InMilliseconds());\n@@ -294,6 +284,17 @@ void UkmPageLoadMetricsObserver::RecordPageLoadExtraInfoMetrics(\n         foreground_duration.value().InMilliseconds());\n   }\n \n+  bool is_user_initiated_navigation =\n+      // All browser initiated page loads are user-initiated.\n+      info.user_initiated_info.browser_initiated ||\n+\n+      // Renderer-initiated navigations are user-initiated if there is an\n+      // associated input event.\n+      info.user_initiated_info.user_input_event;\n+\n+  builder.SetExperimental_Navigation_UserInitiated(\n+      is_user_initiated_navigation);\n+\n   // Convert to the EffectiveConnectionType as used in SystemProfileProto\n   // before persisting the metric.\n   metrics::SystemProfileProto::Network::EffectiveConnectionType""}<_**next**_>{""sha"": ""cae25b045701d0c64d6a56d617d9ceb3745fc468"", ""filename"": ""chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/page_load_metrics/observers/ukm_page_load_metrics_observer_unittest.cc?ref=e1e67d5d341d82c61cab2c41ff4163f17caf14ae"", ""patch"": ""@@ -202,6 +202,9 @@ TEST_F(UkmPageLoadMetricsObserverTest, FailedProvisionalLoad) {\n     EXPECT_TRUE(test_ukm_recorder().EntryHasMetric(\n         kv.second.get(),\n         PageLoad::kPageTiming_NavigationToFailedProvisionalLoadName));\n+    test_ukm_recorder().ExpectEntryMetric(\n+        kv.second.get(), PageLoad::kExperimental_Navigation_UserInitiatedName,\n+        false);\n   }\n }\n ""}<_**next**_>{""sha"": ""fc8f72ece37391372c5b919ed8d2143b236d6133"", ""filename"": ""chrome/browser/page_load_metrics/page_load_metrics_observer.h"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 6, ""changes"": 25, ""blob_url"": ""https://github.com/chromium/chromium/blob/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/page_load_metrics_observer.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e1e67d5d341d82c61cab2c41ff4163f17caf14ae/chrome/browser/page_load_metrics/page_load_metrics_observer.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/page_load_metrics/page_load_metrics_observer.h?ref=e1e67d5d341d82c61cab2c41ff4163f17caf14ae"", ""patch"": ""@@ -86,15 +86,16 @@ struct FailedProvisionalLoadInfo {\n // element are examples of user initiation actions.\n struct UserInitiatedInfo {\n   static UserInitiatedInfo NotUserInitiated() {\n-    return UserInitiatedInfo(false, false);\n+    return UserInitiatedInfo(false, false, false);\n   }\n \n   static UserInitiatedInfo BrowserInitiated() {\n-    return UserInitiatedInfo(true, false);\n+    return UserInitiatedInfo(true, false, false);\n   }\n \n-  static UserInitiatedInfo RenderInitiated(bool user_gesture) {\n-    return UserInitiatedInfo(false, user_gesture);\n+  static UserInitiatedInfo RenderInitiated(bool user_gesture,\n+                                           bool user_input_event) {\n+    return UserInitiatedInfo(false, user_gesture, user_input_event);\n   }\n \n   // Whether the associated action was initiated from the browser process, as\n@@ -104,11 +105,23 @@ struct UserInitiatedInfo {\n \n   // Whether the associated action was initiated by a user, according to user\n   // gesture tracking in content and Blink, as reported by NavigationHandle.\n+  // This is based on the heuristic the popup blocker uses.\n   bool user_gesture;\n \n+  // Whether an input even directly led to the navigation, according to\n+  // input start time tracking in the renderer, as reported by NavigationHandle.\n+  // Note that this metric is still experimental and may not be fully\n+  // implemented. All known issues are blocking crbug.com/889220. Currently\n+  // all known gaps affect browser-side navigations.\n+  bool user_input_event;\n+\n  private:\n-  UserInitiatedInfo(bool browser_initiated, bool user_gesture)\n-      : browser_initiated(browser_initiated), user_gesture(user_gesture) {}\n+  UserInitiatedInfo(bool browser_initiated,\n+                    bool user_gesture,\n+                    bool user_input_event)\n+      : browser_initiated(browser_initiated),\n+        user_gesture(user_gesture),\n+        user_input_event(user_input_event) {}\n };\n \n struct PageLoadExtraInfo {""}","void UkmPageLoadMetricsObserver::RecordTimingMetrics(
     const page_load_metrics::mojom::PageLoadTiming& timing,
     const page_load_metrics::PageLoadExtraInfo& info) {
   ukm::builders::PageLoad builder(info.source_id);
   if (timing.input_to_navigation_start) {
     builder.SetExperimental_InputToNavigationStart(
         timing.input_to_navigation_start.value().InMilliseconds());
  }
  if (timing.parse_timing->parse_start) {
    builder.SetParseTiming_NavigationToParseStart(
        timing.parse_timing->parse_start.value().InMilliseconds());
  }
  if (timing.document_timing->dom_content_loaded_event_start) {
    builder.SetDocumentTiming_NavigationToDOMContentLoadedEventFired(
        timing.document_timing->dom_content_loaded_event_start.value()
            .InMilliseconds());
  }
  if (timing.document_timing->load_event_start) {
    builder.SetDocumentTiming_NavigationToLoadEventFired(
        timing.document_timing->load_event_start.value().InMilliseconds());
  }
  if (timing.paint_timing->first_paint) {
    builder.SetPaintTiming_NavigationToFirstPaint(
        timing.paint_timing->first_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->first_contentful_paint) {
    builder.SetPaintTiming_NavigationToFirstContentfulPaint(
        timing.paint_timing->first_contentful_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->first_meaningful_paint) {
    builder.SetExperimental_PaintTiming_NavigationToFirstMeaningfulPaint(
        timing.paint_timing->first_meaningful_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->largest_image_paint.has_value() &&
      WasStartedInForegroundOptionalEventInForeground(
          timing.paint_timing->largest_image_paint, info)) {
    builder.SetExperimental_PaintTiming_NavigationToLargestImagePaint(
        timing.paint_timing->largest_image_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->last_image_paint.has_value() &&
      WasStartedInForegroundOptionalEventInForeground(
          timing.paint_timing->last_image_paint, info)) {
    builder.SetExperimental_PaintTiming_NavigationToLastImagePaint(
        timing.paint_timing->last_image_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->largest_text_paint.has_value() &&
      WasStartedInForegroundOptionalEventInForeground(
          timing.paint_timing->largest_text_paint, info)) {
    builder.SetExperimental_PaintTiming_NavigationToLargestTextPaint(
        timing.paint_timing->largest_text_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->last_text_paint.has_value() &&
      WasStartedInForegroundOptionalEventInForeground(
          timing.paint_timing->last_text_paint, info)) {
    builder.SetExperimental_PaintTiming_NavigationToLastTextPaint(
        timing.paint_timing->last_text_paint.value().InMilliseconds());
  }
  base::Optional<base::TimeDelta> largest_content_paint_time;
  uint64_t largest_content_paint_size;
  AssignTimeAndSizeForLargestContentfulPaint(largest_content_paint_time,
                                             largest_content_paint_size,
                                             timing.paint_timing);
  if (largest_content_paint_size > 0 &&
      WasStartedInForegroundOptionalEventInForeground(
          largest_content_paint_time, info)) {
    builder.SetExperimental_PaintTiming_NavigationToLargestContentPaint(
        largest_content_paint_time.value().InMilliseconds());
  }
  if (timing.interactive_timing->interactive) {
    base::TimeDelta time_to_interactive =
        timing.interactive_timing->interactive.value();
    if (!timing.interactive_timing->first_invalidating_input ||
        timing.interactive_timing->first_invalidating_input.value() >
            time_to_interactive) {
      builder.SetExperimental_NavigationToInteractive(
          time_to_interactive.InMilliseconds());
    }
  }
  if (timing.interactive_timing->first_input_delay) {
    base::TimeDelta first_input_delay =
        timing.interactive_timing->first_input_delay.value();
    builder.SetInteractiveTiming_FirstInputDelay2(
        first_input_delay.InMilliseconds());
  }
  if (timing.interactive_timing->first_input_timestamp) {
    base::TimeDelta first_input_timestamp =
        timing.interactive_timing->first_input_timestamp.value();
    builder.SetInteractiveTiming_FirstInputTimestamp2(
        first_input_timestamp.InMilliseconds());
  }

  if (timing.interactive_timing->longest_input_delay) {
    base::TimeDelta longest_input_delay =
        timing.interactive_timing->longest_input_delay.value();
    builder.SetInteractiveTiming_LongestInputDelay2(
        longest_input_delay.InMilliseconds());
  }
  if (timing.interactive_timing->longest_input_timestamp) {
    base::TimeDelta longest_input_timestamp =
        timing.interactive_timing->longest_input_timestamp.value();
    builder.SetInteractiveTiming_LongestInputTimestamp2(
        longest_input_timestamp.InMilliseconds());
  }

  builder.SetNet_CacheBytes(ukm::GetExponentialBucketMin(cache_bytes_, 1.3));
  builder.SetNet_NetworkBytes(
      ukm::GetExponentialBucketMin(network_bytes_, 1.3));

  if (main_frame_timing_)
    ReportMainResourceTimingMetrics(timing, &builder);

  builder.Record(ukm::UkmRecorder::Get());
}
","void UkmPageLoadMetricsObserver::RecordTimingMetrics(
     const page_load_metrics::mojom::PageLoadTiming& timing,
     const page_load_metrics::PageLoadExtraInfo& info) {
   ukm::builders::PageLoad builder(info.source_id);
  bool is_user_initiated_navigation =
      info.user_initiated_info.browser_initiated ||
      timing.input_to_navigation_start;
  builder.SetExperimental_Navigation_UserInitiated(
      is_user_initiated_navigation);
   if (timing.input_to_navigation_start) {
     builder.SetExperimental_InputToNavigationStart(
         timing.input_to_navigation_start.value().InMilliseconds());
  }
  if (timing.parse_timing->parse_start) {
    builder.SetParseTiming_NavigationToParseStart(
        timing.parse_timing->parse_start.value().InMilliseconds());
  }
  if (timing.document_timing->dom_content_loaded_event_start) {
    builder.SetDocumentTiming_NavigationToDOMContentLoadedEventFired(
        timing.document_timing->dom_content_loaded_event_start.value()
            .InMilliseconds());
  }
  if (timing.document_timing->load_event_start) {
    builder.SetDocumentTiming_NavigationToLoadEventFired(
        timing.document_timing->load_event_start.value().InMilliseconds());
  }
  if (timing.paint_timing->first_paint) {
    builder.SetPaintTiming_NavigationToFirstPaint(
        timing.paint_timing->first_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->first_contentful_paint) {
    builder.SetPaintTiming_NavigationToFirstContentfulPaint(
        timing.paint_timing->first_contentful_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->first_meaningful_paint) {
    builder.SetExperimental_PaintTiming_NavigationToFirstMeaningfulPaint(
        timing.paint_timing->first_meaningful_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->largest_image_paint.has_value() &&
      WasStartedInForegroundOptionalEventInForeground(
          timing.paint_timing->largest_image_paint, info)) {
    builder.SetExperimental_PaintTiming_NavigationToLargestImagePaint(
        timing.paint_timing->largest_image_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->last_image_paint.has_value() &&
      WasStartedInForegroundOptionalEventInForeground(
          timing.paint_timing->last_image_paint, info)) {
    builder.SetExperimental_PaintTiming_NavigationToLastImagePaint(
        timing.paint_timing->last_image_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->largest_text_paint.has_value() &&
      WasStartedInForegroundOptionalEventInForeground(
          timing.paint_timing->largest_text_paint, info)) {
    builder.SetExperimental_PaintTiming_NavigationToLargestTextPaint(
        timing.paint_timing->largest_text_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->last_text_paint.has_value() &&
      WasStartedInForegroundOptionalEventInForeground(
          timing.paint_timing->last_text_paint, info)) {
    builder.SetExperimental_PaintTiming_NavigationToLastTextPaint(
        timing.paint_timing->last_text_paint.value().InMilliseconds());
  }
  base::Optional<base::TimeDelta> largest_content_paint_time;
  uint64_t largest_content_paint_size;
  AssignTimeAndSizeForLargestContentfulPaint(largest_content_paint_time,
                                             largest_content_paint_size,
                                             timing.paint_timing);
  if (largest_content_paint_size > 0 &&
      WasStartedInForegroundOptionalEventInForeground(
          largest_content_paint_time, info)) {
    builder.SetExperimental_PaintTiming_NavigationToLargestContentPaint(
        largest_content_paint_time.value().InMilliseconds());
  }
  if (timing.interactive_timing->interactive) {
    base::TimeDelta time_to_interactive =
        timing.interactive_timing->interactive.value();
    if (!timing.interactive_timing->first_invalidating_input ||
        timing.interactive_timing->first_invalidating_input.value() >
            time_to_interactive) {
      builder.SetExperimental_NavigationToInteractive(
          time_to_interactive.InMilliseconds());
    }
  }
  if (timing.interactive_timing->first_input_delay) {
    base::TimeDelta first_input_delay =
        timing.interactive_timing->first_input_delay.value();
    builder.SetInteractiveTiming_FirstInputDelay2(
        first_input_delay.InMilliseconds());
  }
  if (timing.interactive_timing->first_input_timestamp) {
    base::TimeDelta first_input_timestamp =
        timing.interactive_timing->first_input_timestamp.value();
    builder.SetInteractiveTiming_FirstInputTimestamp2(
        first_input_timestamp.InMilliseconds());
  }

  if (timing.interactive_timing->longest_input_delay) {
    base::TimeDelta longest_input_delay =
        timing.interactive_timing->longest_input_delay.value();
    builder.SetInteractiveTiming_LongestInputDelay2(
        longest_input_delay.InMilliseconds());
  }
  if (timing.interactive_timing->longest_input_timestamp) {
    base::TimeDelta longest_input_timestamp =
        timing.interactive_timing->longest_input_timestamp.value();
    builder.SetInteractiveTiming_LongestInputTimestamp2(
        longest_input_timestamp.InMilliseconds());
  }

  builder.SetNet_CacheBytes(ukm::GetExponentialBucketMin(cache_bytes_, 1.3));
  builder.SetNet_NetworkBytes(
      ukm::GetExponentialBucketMin(network_bytes_, 1.3));

  if (main_frame_timing_)
    ReportMainResourceTimingMetrics(timing, &builder);

  builder.Record(ukm::UkmRecorder::Get());
}
",C,,"  bool is_user_initiated_navigation =
      info.user_initiated_info.browser_initiated ||
      timing.input_to_navigation_start;
  builder.SetExperimental_Navigation_UserInitiated(
      is_user_initiated_navigation);
",,"@@ -161,16 +161,6 @@ void UkmPageLoadMetricsObserver::RecordTimingMetrics(
     const page_load_metrics::mojom::PageLoadTiming& timing,
     const page_load_metrics::PageLoadExtraInfo& info) {
   ukm::builders::PageLoad builder(info.source_id);
-  bool is_user_initiated_navigation =
-      // All browser initiated page loads are user-initiated.
-      info.user_initiated_info.browser_initiated ||
-
-      // Renderer-initiated navigations are user-initiated if there is an
-      // associated input timestamp.
-      timing.input_to_navigation_start;
-
-  builder.SetExperimental_Navigation_UserInitiated(
-      is_user_initiated_navigation);
   if (timing.input_to_navigation_start) {
     builder.SetExperimental_InputToNavigationStart(
         timing.input_to_navigation_start.value().InMilliseconds());
@@ -294,6 +284,17 @@ void UkmPageLoadMetricsObserver::RecordPageLoadExtraInfoMetrics(
         foreground_duration.value().InMilliseconds());
   }
 
+  bool is_user_initiated_navigation =
+      // All browser initiated page loads are user-initiated.
+      info.user_initiated_info.browser_initiated ||
+
+      // Renderer-initiated navigations are user-initiated if there is an
+      // associated input event.
+      info.user_initiated_info.user_input_event;
+
+  builder.SetExperimental_Navigation_UserInitiated(
+      is_user_initiated_navigation);
+
   // Convert to the EffectiveConnectionType as used in SystemProfileProto
   // before persisting the metric.
   metrics::SystemProfileProto::Network::EffectiveConnectionType",Chrome,e1e67d5d341d82c61cab2c41ff4163f17caf14ae,3a1541f5115ec0d20b3a834dd2597acf4ca645af,1,"void UkmPageLoadMetricsObserver::RecordTimingMetrics(
     const page_load_metrics::mojom::PageLoadTiming& timing,
     const page_load_metrics::PageLoadExtraInfo& info) {
   ukm::builders::PageLoad builder(info.source_id);
//flaw_line_below:
  bool is_user_initiated_navigation =
//flaw_line_below:
      // All browser initiated page loads are user-initiated.
//flaw_line_below:
      info.user_initiated_info.browser_initiated ||
//flaw_line_below:

//flaw_line_below:
      // Renderer-initiated navigations are user-initiated if there is an
//flaw_line_below:
      // associated input timestamp.
//flaw_line_below:
      timing.input_to_navigation_start;
//flaw_line_below:

//flaw_line_below:
  builder.SetExperimental_Navigation_UserInitiated(
//flaw_line_below:
      is_user_initiated_navigation);
   if (timing.input_to_navigation_start) {
     builder.SetExperimental_InputToNavigationStart(
         timing.input_to_navigation_start.value().InMilliseconds());
  }
  if (timing.parse_timing->parse_start) {
    builder.SetParseTiming_NavigationToParseStart(
        timing.parse_timing->parse_start.value().InMilliseconds());
  }
  if (timing.document_timing->dom_content_loaded_event_start) {
    builder.SetDocumentTiming_NavigationToDOMContentLoadedEventFired(
        timing.document_timing->dom_content_loaded_event_start.value()
            .InMilliseconds());
  }
  if (timing.document_timing->load_event_start) {
    builder.SetDocumentTiming_NavigationToLoadEventFired(
        timing.document_timing->load_event_start.value().InMilliseconds());
  }
  if (timing.paint_timing->first_paint) {
    builder.SetPaintTiming_NavigationToFirstPaint(
        timing.paint_timing->first_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->first_contentful_paint) {
    builder.SetPaintTiming_NavigationToFirstContentfulPaint(
        timing.paint_timing->first_contentful_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->first_meaningful_paint) {
    builder.SetExperimental_PaintTiming_NavigationToFirstMeaningfulPaint(
        timing.paint_timing->first_meaningful_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->largest_image_paint.has_value() &&
      WasStartedInForegroundOptionalEventInForeground(
          timing.paint_timing->largest_image_paint, info)) {
    builder.SetExperimental_PaintTiming_NavigationToLargestImagePaint(
        timing.paint_timing->largest_image_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->last_image_paint.has_value() &&
      WasStartedInForegroundOptionalEventInForeground(
          timing.paint_timing->last_image_paint, info)) {
    builder.SetExperimental_PaintTiming_NavigationToLastImagePaint(
        timing.paint_timing->last_image_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->largest_text_paint.has_value() &&
      WasStartedInForegroundOptionalEventInForeground(
          timing.paint_timing->largest_text_paint, info)) {
    builder.SetExperimental_PaintTiming_NavigationToLargestTextPaint(
        timing.paint_timing->largest_text_paint.value().InMilliseconds());
  }
  if (timing.paint_timing->last_text_paint.has_value() &&
      WasStartedInForegroundOptionalEventInForeground(
          timing.paint_timing->last_text_paint, info)) {
    builder.SetExperimental_PaintTiming_NavigationToLastTextPaint(
        timing.paint_timing->last_text_paint.value().InMilliseconds());
  }
  base::Optional<base::TimeDelta> largest_content_paint_time;
  uint64_t largest_content_paint_size;
  AssignTimeAndSizeForLargestContentfulPaint(largest_content_paint_time,
                                             largest_content_paint_size,
                                             timing.paint_timing);
  if (largest_content_paint_size > 0 &&
      WasStartedInForegroundOptionalEventInForeground(
          largest_content_paint_time, info)) {
    builder.SetExperimental_PaintTiming_NavigationToLargestContentPaint(
        largest_content_paint_time.value().InMilliseconds());
  }
  if (timing.interactive_timing->interactive) {
    base::TimeDelta time_to_interactive =
        timing.interactive_timing->interactive.value();
    if (!timing.interactive_timing->first_invalidating_input ||
        timing.interactive_timing->first_invalidating_input.value() >
            time_to_interactive) {
      builder.SetExperimental_NavigationToInteractive(
          time_to_interactive.InMilliseconds());
    }
  }
  if (timing.interactive_timing->first_input_delay) {
    base::TimeDelta first_input_delay =
        timing.interactive_timing->first_input_delay.value();
    builder.SetInteractiveTiming_FirstInputDelay2(
        first_input_delay.InMilliseconds());
  }
  if (timing.interactive_timing->first_input_timestamp) {
    base::TimeDelta first_input_timestamp =
        timing.interactive_timing->first_input_timestamp.value();
    builder.SetInteractiveTiming_FirstInputTimestamp2(
        first_input_timestamp.InMilliseconds());
  }

  if (timing.interactive_timing->longest_input_delay) {
    base::TimeDelta longest_input_delay =
        timing.interactive_timing->longest_input_delay.value();
    builder.SetInteractiveTiming_LongestInputDelay2(
        longest_input_delay.InMilliseconds());
  }
  if (timing.interactive_timing->longest_input_timestamp) {
    base::TimeDelta longest_input_timestamp =
        timing.interactive_timing->longest_input_timestamp.value();
    builder.SetInteractiveTiming_LongestInputTimestamp2(
        longest_input_timestamp.InMilliseconds());
  }

  // Use a bucket spacing factor of 1.3 for bytes.
  builder.SetNet_CacheBytes(ukm::GetExponentialBucketMin(cache_bytes_, 1.3));
  builder.SetNet_NetworkBytes(
      ukm::GetExponentialBucketMin(network_bytes_, 1.3));

  if (main_frame_timing_)
    ReportMainResourceTimingMetrics(timing, &builder);

  builder.Record(ukm::UkmRecorder::Get());
}
"
8934,186670,,Remote,Not required,,CVE-2018-6051,https://www.cvedetails.com/cve/CVE-2018-6051/,CWE-79,Medium,Partial,,,2018-09-25,4.3,"XSS Auditor in Google Chrome prior to 64.0.3282.119, did not ensure the reporting URL was in the same origin as the page it was on, which allowed a remote attacker to obtain referrer details via a crafted HTML page.",2018-11-15,XSS ,7,https://github.com/chromium/chromium/commit/0da6dcdbe8e34740133773d20cc466b89d399d0a,0da6dcdbe8e34740133773d20cc466b89d399d0a,"Restrict the xss audit report URL to same origin

BUG=441275
R=tsepez@chromium.org,mkwst@chromium.org

Change-Id: I27bc8e251b9ad962c3b4fdebf084a2b9152f915d
Reviewed-on: https://chromium-review.googlesource.com/768367
Reviewed-by: Tom Sepez <tsepez@chromium.org>
Reviewed-by: Mike West <mkwst@chromium.org>
Commit-Queue: Jochen Eisinger <jochen@chromium.org>
Cr-Commit-Position: refs/heads/master@{#516666}",0,third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp,"{""sha"": ""f991b2454bb8761dcd41fdcbfccaba4aab310f42"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin-expected.txt"", ""status"": ""added"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin-expected.txt?ref=0da6dcdbe8e34740133773d20cc466b89d399d0a"", ""patch"": ""@@ -0,0 +1,11 @@\n+CONSOLE ERROR: Error parsing header X-XSS-Protection: 1; report=http://localhost:8080/security/contentSecurityPolicy/resources/save-report.php?test=report-script-tag.html: reporting URL is not same scheme, host, and port as page at character position 10. The default protections will be applied.\n+CONSOLE ERROR: line 4: The XSS Auditor blocked access to 'http://127.0.0.1:8000/security/xssAuditor/resources/echo-intertag.pl?test=report-script-tag.html&echo-report=1&enable-report-cross-origin=1&q=%3Cscript%3Ealert(String.fromCharCode(0x58,0x53,0x53))%3C/script%3E%3Cp%3EIf%20you%20see%20this%20message,%20no%20JavaScript%20alert(),%20and%20not%20dump%20of%20a%20report%20is%20displayed%20below,%20then%20the%20test%20PASSED.%3C/p%3E' because the source code of a script was found within the request. The server sent an 'X-XSS-Protection' header requesting this behavior.\n+This tests that the X-XSS-Protection reports are sent out properly\n+\n+\n+\n+--------\n+Frame: 'frame'\n+--------\n+Could not load the requested resource.\n+Error code: -28 (net::ERR_BLOCKED_BY_XSS_AUDITOR)""}<_**next**_>{""sha"": ""ca8a315df359e6b57849c3d798aa87496719b89f"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin.html"", ""status"": ""added"", ""additions"": 25, ""deletions"": 0, ""changes"": 25, ""blob_url"": ""https://github.com/chromium/chromium/blob/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin.html?ref=0da6dcdbe8e34740133773d20cc466b89d399d0a"", ""patch"": ""@@ -0,0 +1,25 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<script src=\""http://localhost:8000/security/xssAuditor/resources/utilities.js\""></script>\n+<script>\n+if (window.testRunner) {\n+    testRunner.dumpAsText();\n+    testRunner.dumpChildFramesAsText();\n+    testRunner.waitUntilDone();\n+    testRunner.setXSSAuditorEnabled(true);\n+}\n+\n+function notify() {\n+  if (window.testRunner) {\n+    setTimeout(testRunner.notifyDone.bind(testRunner), 0);\n+  }\n+}\n+</script>\n+</head>\n+<body>\n+<p>This tests that the X-XSS-Protection reports are sent out properly</p>\n+<iframe onload=\""notify()\"" name=\""frame\"" src=\""http://127.0.0.1:8000/security/xssAuditor/resources/echo-intertag.pl?test=report-script-tag.html&echo-report=1&enable-report-cross-origin=1&q=<script>alert(String.fromCharCode(0x58,0x53,0x53))</script><p>If you see this message, no JavaScript alert(), and not dump of a report is displayed below, then the test PASSED.</p>\"">\n+</iframe>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""d3cb1524857b6ca8557df334e6feeb380123f922"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/resources/echo-intertag.pl"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/resources/echo-intertag.pl"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/resources/echo-intertag.pl"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/resources/echo-intertag.pl?ref=0da6dcdbe8e34740133773d20cc466b89d399d0a"", ""patch"": ""@@ -13,6 +13,8 @@\n     print \""X-XSS-Protection: 1; mode=block\\n\"";\n } elsif ($cgi->param('enable-report')) {\n     print \""X-XSS-Protection: 1; report=/security/contentSecurityPolicy/resources/save-report.php?test=\"" . $cgi->param('test') . \""\\n\"";\n+} elsif ($cgi->param('enable-report-cross-origin')) {\n+    print \""X-XSS-Protection: 1; report=http://localhost:8080/security/contentSecurityPolicy/resources/save-report.php?test=\"" . $cgi->param('test') . \""\\n\"";\n } elsif ($cgi->param('enable-full-block-report')) {\n     print \""X-XSS-Protection: 1; mode=block; report=/security/contentSecurityPolicy/resources/save-report.php?test=\"" . $cgi->param('test') . \""\\n\"";\n } elsif ($cgi->param('valid-header')) {""}<_**next**_>{""sha"": ""4005f3b4c046b0d63dd7c2dfdc71790ee4849bdf"", ""filename"": ""third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp?ref=0da6dcdbe8e34740133773d20cc466b89d399d0a"", ""patch"": ""@@ -425,6 +425,13 @@ void XSSAuditor::Init(Document* document,\n          xss_protection_header == kBlockReflectedXSS) &&\n         !report_url.IsEmpty()) {\n       xss_protection_report_url = document->CompleteURL(report_url);\n+      if (!SecurityOrigin::Create(xss_protection_report_url)\n+               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {\n+        error_details =\n+            \""reporting URL is not same scheme, host, and port as page\"";\n+        xss_protection_header = kReflectedXSSInvalid;\n+        xss_protection_report_url = KURL();\n+      }\n       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),\n                                               xss_protection_report_url)) {\n         error_details = \""insecure reporting URL for secure page\"";""}","void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
      if (!SecurityOrigin::Create(xss_protection_report_url)
               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
        error_details =
            ""reporting URL is not same scheme, host, and port as page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
","void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
",C,"      if (!SecurityOrigin::Create(xss_protection_report_url)
               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
        error_details =
            ""reporting URL is not same scheme, host, and port as page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
",,,"@@ -425,6 +425,13 @@ void XSSAuditor::Init(Document* document,
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
+      if (!SecurityOrigin::Create(xss_protection_report_url)
+               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
+        error_details =
+            ""reporting URL is not same scheme, host, and port as page"";
+        xss_protection_header = kReflectedXSSInvalid;
+        xss_protection_report_url = KURL();
+      }
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";",Chrome,0da6dcdbe8e34740133773d20cc466b89d399d0a,c99c6fa1c62d04fb36be582fae389b9f34c2c089,1,"void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  // In theory, the Document could have detached from the LocalFrame after the
  // XSSAuditor was constructed.
  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    // The URL can be empty when opening a new browser window or calling
    // window.open("""").
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
//fix_flaw_line_below:
//      if (!SecurityOrigin::Create(xss_protection_report_url)
//fix_flaw_line_below:
//               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
//fix_flaw_line_below:
//        error_details =
//fix_flaw_line_below:
//            ""reporting URL is not same scheme, host, and port as page"";
//fix_flaw_line_below:
//        xss_protection_header = kReflectedXSSInvalid;
//fix_flaw_line_below:
//        xss_protection_report_url = KURL();
//fix_flaw_line_below:
//      }
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
"
9137,186873,,Remote,Not required,,CVE-2018-6070,https://www.cvedetails.com/cve/CVE-2018-6070/,CWE-79,Medium,,Partial,,2018-11-14,4.3,Lack of CSP enforcement on WebUI pages in Bink in Google Chrome prior to 65.0.3325.146 allowed an attacker who convinced a user to install a malicious extension to bypass content security policy via a crafted Chrome Extension.,2019-10-02,XSS Bypass ,0,https://github.com/chromium/chromium/commit/f283cdf7c850f3db923a5303c7e01bd929d4117f,f283cdf7c850f3db923a5303c7e01bd929d4117f,"Move Initialize() to VaapiImageDecoder parent class.

This CL moves the implementation of Initialize() to VaapiImageDecoder,
since it is common to all implementing classes.

Bug: 877694
Test: jpeg_decode_accelerator_unittest
Change-Id: Ic99601953ae1c7a572ba8a0b0bf43675b2b0969d
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1654249
Commit-Queue: Gil Dekel <gildekel@chromium.org>
Reviewed-by: Andres Calderon Jaramillo <andrescj@chromium.org>
Reviewed-by: Miguel Casas <mcasas@chromium.org>
Cr-Commit-Position: refs/heads/master@{#668645}",8,media/gpu/vaapi/vaapi_jpeg_decoder.cc,"{""sha"": ""7671f22290878c00f91af2e1d87d9de0140ae980"", ""filename"": ""media/gpu/vaapi/OWNERS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/OWNERS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/OWNERS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/OWNERS?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -4,3 +4,6 @@ posciak@chromium.org\n \n # (M)JPEG related stuff\n per-file *jpeg*=andrescj@chromium.org\n+\n+# General VA-API decoding related stuff\n+per-file *image_decoder*=andrescj@chromium.org""}<_**next**_>{""sha"": ""5bafbd695cceeb07b4e15d0812f1e3ecfb60573a"", ""filename"": ""media/gpu/vaapi/vaapi_image_decoder.cc"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_image_decoder.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_image_decoder.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/vaapi_image_decoder.cc?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -6,13 +6,37 @@\n \n #include <va/va.h>\n \n+#include \""base/logging.h\""\n #include \""media/gpu/vaapi/vaapi_wrapper.h\""\n \n namespace media {\n \n+namespace {\n+\n+VAProfile ConvertToVAProfile(VaapiImageDecoder::Type type) {\n+  switch (type) {\n+    case VaapiImageDecoder::Type::kJpeg:\n+      return VAProfileJPEGBaseline;\n+    case VaapiImageDecoder::Type::kWebP:\n+      return VAProfileVP8Version0_3;\n+    default:\n+      NOTREACHED() << \""Undefined Type value\"";\n+      return VAProfileNone;\n+  }\n+}\n+\n+}  // namespace\n+\n VaapiImageDecoder::VaapiImageDecoder()\n     : va_surface_id_(VA_INVALID_SURFACE), va_rt_format_(kInvalidVaRtFormat) {}\n \n VaapiImageDecoder::~VaapiImageDecoder() = default;\n \n+bool VaapiImageDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {\n+  const VAProfile va_profile = ConvertToVAProfile(GetType());\n+  vaapi_wrapper_ =\n+      VaapiWrapper::Create(VaapiWrapper::kDecode, va_profile, error_uma_cb);\n+  return !!vaapi_wrapper_;\n+}\n+\n }  // namespace media""}<_**next**_>{""sha"": ""68eaf26e7e53f695f831bf805696d423cb2da451"", ""filename"": ""media/gpu/vaapi/vaapi_image_decoder.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 3, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_image_decoder.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_image_decoder.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/vaapi_image_decoder.h?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -50,11 +50,17 @@ enum class VaapiImageDecodeStatus : uint32_t {\n // more implementing classes are added (e.g. VaapiWebPDecoder).\n class VaapiImageDecoder {\n  public:\n+  // Type of image decoder.\n+  enum class Type {\n+    kJpeg,\n+    kWebP,\n+  };\n+\n   virtual ~VaapiImageDecoder();\n \n-  // Initializes |vaapi_wrapper_| in kDecode mode with the appropriate VAAPI\n-  // profile and |error_uma_cb| for error reporting.\n-  virtual bool Initialize(const base::RepeatingClosure& error_uma_cb) = 0;\n+  // Uses GetType() to initialize |vaapi_wrapper_| in kDecode mode with the\n+  // appropriate VAAPI profile and |error_uma_cb| for error reporting.\n+  bool Initialize(const base::RepeatingClosure& error_uma_cb);\n \n   // Decodes a picture. It will fill VA-API parameters and call the\n   // corresponding VA-API methods according to the image in |encoded_image|.\n@@ -66,6 +72,9 @@ class VaapiImageDecoder {\n       base::span<const uint8_t> encoded_image,\n       VaapiImageDecodeStatus* status) = 0;\n \n+  // Returns the type of the current decoder.\n+  virtual Type GetType() const = 0;\n+\n  protected:\n   VaapiImageDecoder();\n ""}<_**next**_>{""sha"": ""53b26a84045c8af0fb54071850b5be48e0bad649"", ""filename"": ""media/gpu/vaapi/vaapi_jpeg_decoder.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 10, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_jpeg_decoder.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_jpeg_decoder.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/vaapi_jpeg_decoder.cc?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -217,16 +217,6 @@ VaapiJpegDecoder::~VaapiJpegDecoder() {\n   }\n }\n \n-bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {\n-  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,\n-                                        VAProfileJPEGBaseline, error_uma_cb);\n-  if (!vaapi_wrapper_) {\n-    VLOGF(1) << \""Failed initializing VAAPI\"";\n-    return false;\n-  }\n-  return true;\n-}\n-\n scoped_refptr<VASurface> VaapiJpegDecoder::Decode(\n     base::span<const uint8_t> encoded_image,\n     VaapiImageDecodeStatus* status) {\n@@ -342,6 +332,10 @@ scoped_refptr<VASurface> VaapiJpegDecoder::Decode(\n                                          base::DoNothing() /* release_cb */);\n }\n \n+VaapiImageDecoder::Type VaapiJpegDecoder::GetType() const {\n+  return VaapiImageDecoder::Type::kJpeg;\n+}\n+\n std::unique_ptr<ScopedVAImage> VaapiJpegDecoder::GetImage(\n     uint32_t preferred_image_fourcc,\n     VaapiImageDecodeStatus* status) {""}<_**next**_>{""sha"": ""270a7481b9e75f7c4ce657b5c84b6a5d059c12e5"", ""filename"": ""media/gpu/vaapi/vaapi_jpeg_decoder.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_jpeg_decoder.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_jpeg_decoder.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/vaapi_jpeg_decoder.h?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -30,9 +30,9 @@ class VaapiJpegDecoder : public VaapiImageDecoder {\n   ~VaapiJpegDecoder() override;\n \n   // VaapiImageDecoder implementation.\n-  bool Initialize(const base::RepeatingClosure& error_uma_cb) override;\n   scoped_refptr<VASurface> Decode(base::span<const uint8_t> encoded_image,\n                                   VaapiImageDecodeStatus* status) override;\n+  Type GetType() const override;\n \n   // Get the decoded data from the last Decode() call as a ScopedVAImage. The\n   // VAImage's format will be either |preferred_image_fourcc| if the conversion""}","bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
","bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
                                        VAProfileJPEGBaseline, error_uma_cb);
  if (!vaapi_wrapper_) {
    VLOGF(1) << ""Failed initializing VAAPI"";
    return false;
  }
  return true;
}
",C,,"  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
                                        VAProfileJPEGBaseline, error_uma_cb);
  if (!vaapi_wrapper_) {
    VLOGF(1) << ""Failed initializing VAAPI"";
    return false;
  }
  return true;
}
",,"@@ -217,16 +217,6 @@ VaapiJpegDecoder::~VaapiJpegDecoder() {
   }
 }
 
-bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
-  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
-                                        VAProfileJPEGBaseline, error_uma_cb);
-  if (!vaapi_wrapper_) {
-    VLOGF(1) << ""Failed initializing VAAPI"";
-    return false;
-  }
-  return true;
-}
-
 scoped_refptr<VASurface> VaapiJpegDecoder::Decode(
     base::span<const uint8_t> encoded_image,
     VaapiImageDecodeStatus* status) {
@@ -342,6 +332,10 @@ scoped_refptr<VASurface> VaapiJpegDecoder::Decode(
                                          base::DoNothing() /* release_cb */);
 }
 
+VaapiImageDecoder::Type VaapiJpegDecoder::GetType() const {
+  return VaapiImageDecoder::Type::kJpeg;
+}
+
 std::unique_ptr<ScopedVAImage> VaapiJpegDecoder::GetImage(
     uint32_t preferred_image_fourcc,
     VaapiImageDecodeStatus* status) {",Chrome,f283cdf7c850f3db923a5303c7e01bd929d4117f,4f67ec23d9cf3ea7ab718a8dc7cd618674317472,1,"bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
//flaw_line_below:
  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
//flaw_line_below:
                                        VAProfileJPEGBaseline, error_uma_cb);
//flaw_line_below:
  if (!vaapi_wrapper_) {
//flaw_line_below:
    VLOGF(1) << ""Failed initializing VAAPI"";
//flaw_line_below:
    return false;
//flaw_line_below:
  }
//flaw_line_below:
  return true;
//flaw_line_below:
}
"
9144,186880,,Remote,Not required,,CVE-2018-6076,https://www.cvedetails.com/cve/CVE-2018-6076/,CWE-79,Medium,,Partial,,2018-11-14,4.3,Insufficient encoding of URL fragment identifiers in Blink in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to perform a DOM based XSS attack via a crafted HTML page.,2018-12-19,XSS ,1,https://github.com/chromium/chromium/commit/f8f6ed59949be4451ee2f5443d8a313f102fde60,f8f6ed59949be4451ee2f5443d8a313f102fde60,"Percent-encode UTF8 characters in URL fragment identifiers.

This brings us into line with Firefox, Safari, and the spec.

Bug: 758523
Change-Id: I7e354ab441222d9fd08e45f0e70f91ad4e35fafe
Reviewed-on: https://chromium-review.googlesource.com/668363
Commit-Queue: Mike West <mkwst@chromium.org>
Reviewed-by: Jochen Eisinger <jochen@chromium.org>
Reviewed-by: Andy Paicu <andypaicu@chromium.org>
Cr-Commit-Position: refs/heads/master@{#507481}",3,url/url_canon_etc.cc,"{""sha"": ""fc7148cbdeb0750f0a4a6371d06f512679e0f321"", ""filename"": ""components/url_formatter/elide_url_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_formatter/elide_url_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_formatter/elide_url_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/url_formatter/elide_url_unittest.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -338,13 +338,14 @@ TEST(TextEliderTest, TestElisionSpecialCases) {\n \n       // Unescaping.\n       {\""http://www/%E4%BD%A0%E5%A5%BD?q=%E4%BD%A0%E5%A5%BD#\\xe4\\xbd\\xa0\"",\n-       \""www/\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd?q=\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd#\\xe4\\xbd\\xa0\""},\n+       \""www/\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd?q=\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd#\"" +\n+           kEllipsisStr},\n \n       // Invalid unescaping for path. The ref will always be valid UTF-8. We\n       // don't bother to do too many edge cases, since these are handled by the\n       // escaper unittest.\n       {\""http://www/%E4%A0%E5%A5%BD?q=%E4%BD%A0%E5%A5%BD#\\xe4\\xbd\\xa0\"",\n-       \""www/%E4%A0%E5%A5%BD?q=\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd#\\xe4\\xbd\\xa0\""},\n+       \""www/%E4%A0%E5%A5%BD?q=\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd#\"" + kEllipsisStr},\n   };\n \n   RunElisionTest(testcases);""}<_**next**_>{""sha"": ""522cb4576fc3fd45800effb5c5951d8914ef5a3a"", ""filename"": ""components/url_formatter/url_formatter_unittest.cc"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 19, ""changes"": 40, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_formatter/url_formatter_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_formatter/url_formatter_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/url_formatter/url_formatter_unittest.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -762,7 +762,7 @@ TEST(UrlFormatterTest, FormatUrl) {\n \n       {\""With a port number and a reference\"",\n        \""http://www.google.com:8080/#\\xE3\\x82\\xB0\"", default_format_type,\n-       net::UnescapeRule::NORMAL, L\""http://www.google.com:8080/#\\x30B0\"", 7},\n+       net::UnescapeRule::NORMAL, L\""http://www.google.com:8080/#%E3%82%B0\"", 7},\n \n       // -------- IDN tests --------\n       {\""Japanese IDN with ja\"", \""http://xn--l8jvb1ey91xtjb.jp\"",\n@@ -1027,9 +1027,10 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n                      \""%E3%82%B0/?q=%E3%82%B0#\\xE3\\x82\\xB0\""),\n                 kFormatUrlOmitNothing, net::UnescapeRule::NONE,\n                 &parsed, nullptr, nullptr);\n-  EXPECT_EQ(WideToUTF16(\n-      L\""http://%E3%82%B0:%E3%83%BC@\\x30B0\\x30FC\\x30B0\\x30EB.jp:8080\""\n-      L\""/%E3%82%B0/?q=%E3%82%B0#\\x30B0\""), formatted);\n+  EXPECT_EQ(\n+      WideToUTF16(L\""http://%E3%82%B0:%E3%83%BC@\\x30B0\\x30FC\\x30B0\\x30EB.jp:8080\""\n+                  L\""/%E3%82%B0/?q=%E3%82%B0#%E3%82%B0\""),\n+      formatted);\n   EXPECT_EQ(WideToUTF16(L\""%E3%82%B0\""),\n       formatted.substr(parsed.username.begin, parsed.username.len));\n   EXPECT_EQ(WideToUTF16(L\""%E3%83%BC\""),\n@@ -1042,8 +1043,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n       formatted.substr(parsed.path.begin, parsed.path.len));\n   EXPECT_EQ(WideToUTF16(L\""q=%E3%82%B0\""),\n       formatted.substr(parsed.query.begin, parsed.query.len));\n-  EXPECT_EQ(WideToUTF16(L\""\\x30B0\""),\n-      formatted.substr(parsed.ref.begin, parsed.ref.len));\n+  EXPECT_EQ(WideToUTF16(L\""%E3%82%B0\""),\n+            formatted.substr(parsed.ref.begin, parsed.ref.len));\n \n   // Unescape case.\n   formatted =\n@@ -1052,7 +1053,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n                 kFormatUrlOmitNothing, net::UnescapeRule::NORMAL, &parsed,\n                 nullptr, nullptr);\n   EXPECT_EQ(WideToUTF16(L\""http://\\x30B0:\\x30FC@\\x30B0\\x30FC\\x30B0\\x30EB.jp:8080\""\n-      L\""/\\x30B0/?q=\\x30B0#\\x30B0\""), formatted);\n+                        L\""/\\x30B0/?q=\\x30B0#%E3%82%B0\""),\n+            formatted);\n   EXPECT_EQ(WideToUTF16(L\""\\x30B0\""),\n       formatted.substr(parsed.username.begin, parsed.username.len));\n   EXPECT_EQ(WideToUTF16(L\""\\x30FC\""),\n@@ -1065,8 +1067,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n       formatted.substr(parsed.path.begin, parsed.path.len));\n   EXPECT_EQ(WideToUTF16(L\""q=\\x30B0\""),\n       formatted.substr(parsed.query.begin, parsed.query.len));\n-  EXPECT_EQ(WideToUTF16(L\""\\x30B0\""),\n-      formatted.substr(parsed.ref.begin, parsed.ref.len));\n+  EXPECT_EQ(WideToUTF16(L\""%E3%82%B0\""),\n+            formatted.substr(parsed.ref.begin, parsed.ref.len));\n \n   // Omit_username_password + unescape case.\n   formatted =\n@@ -1075,7 +1077,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n                 kFormatUrlOmitUsernamePassword, net::UnescapeRule::NORMAL,\n                 &parsed, nullptr, nullptr);\n   EXPECT_EQ(WideToUTF16(L\""http://\\x30B0\\x30FC\\x30B0\\x30EB.jp:8080\""\n-      L\""/\\x30B0/?q=\\x30B0#\\x30B0\""), formatted);\n+                        L\""/\\x30B0/?q=\\x30B0#%E3%82%B0\""),\n+            formatted);\n   EXPECT_FALSE(parsed.username.is_valid());\n   EXPECT_FALSE(parsed.password.is_valid());\n   EXPECT_EQ(WideToUTF16(L\""\\x30B0\\x30FC\\x30B0\\x30EB.jp\""),\n@@ -1086,8 +1089,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n       formatted.substr(parsed.path.begin, parsed.path.len));\n   EXPECT_EQ(WideToUTF16(L\""q=\\x30B0\""),\n       formatted.substr(parsed.query.begin, parsed.query.len));\n-  EXPECT_EQ(WideToUTF16(L\""\\x30B0\""),\n-      formatted.substr(parsed.ref.begin, parsed.ref.len));\n+  EXPECT_EQ(WideToUTF16(L\""%E3%82%B0\""),\n+            formatted.substr(parsed.ref.begin, parsed.ref.len));\n \n   // View-source case.\n   formatted =\n@@ -1320,14 +1323,13 @@ TEST(UrlFormatterTest, FormatUrlWithOffsets) {\n       kFormatUrlOmitNothing, net::UnescapeRule::SPACES, unescape_offsets);\n \n   const size_t ref_offsets[] = {\n-    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n-    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, kNpos, kNpos, 32, kNpos, kNpos,\n-    33\n-  };\n+      0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16,\n+      17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,\n+      34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49};\n   // Unescape to \""http://www.google.com/foo.html#\\x30B0\\x30B0z\"".\n-  CheckAdjustedOffsets(\n-      \""http://www.google.com/foo.html#\\xE3\\x82\\xB0\\xE3\\x82\\xB0z\"",\n-      kFormatUrlOmitNothing, net::UnescapeRule::NORMAL, ref_offsets);\n+  CheckAdjustedOffsets(\""http://www.google.com/foo.html#%E3%82%B0%E3%82%B0z\"",\n+                       kFormatUrlOmitNothing, net::UnescapeRule::NORMAL,\n+                       ref_offsets);\n \n   const size_t omit_http_offsets[] = {\n     0, kNpos, kNpos, kNpos, kNpos, kNpos, kNpos, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,""}<_**next**_>{""sha"": ""7672b12a6db0bdccdb4ea8940cda31afe9969a87"", ""filename"": ""components/url_matcher/url_matcher_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_matcher/url_matcher_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_matcher/url_matcher_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/url_matcher/url_matcher_unittest.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -168,7 +168,7 @@ TEST(URLMatcherConditionFactoryTest, GURLCharacterSet) {\n   EXPECT_TRUE(base::IsStringASCII(url.host()));\n   EXPECT_TRUE(base::IsStringASCII(url.path()));\n   EXPECT_TRUE(base::IsStringASCII(url.query()));\n-  EXPECT_FALSE(base::IsStringASCII(url.ref()));\n+  EXPECT_TRUE(base::IsStringASCII(url.ref()));\n }\n \n TEST(URLMatcherConditionFactoryTest, Criteria) {""}<_**next**_>{""sha"": ""46aa9d9fba31d9c3fec30db76a89ac7516a52dbc"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/url/url-setters-expected.txt"", ""status"": ""renamed"", ""additions"": 7, ""deletions"": 7, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/external/wpt/url/url-setters-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/external/wpt/url/url-setters-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/url/url-setters-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 574 tests; 248 PASS, 326 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 574 tests; 251 PASS, 323 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n FAIL URL: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged. assert_equals: expected \""a://example.net\"" but got \""file:///A://example.net\""\n FAIL <a>: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged. assert_equals: expected \""a://example.net\"" but got \""file:///A://example.net\""\n@@ -565,12 +565,12 @@ FAIL <area>: Setting <https://example.net?lang=en-US#nav>.hash = '#' assert_equa\n PASS URL: Setting <https://example.net?lang=en-US#nav>.hash = ''\n PASS <a>: Setting <https://example.net?lang=en-US#nav>.hash = ''\n PASS <area>: Setting <https://example.net?lang=en-US#nav>.hash = ''\n-FAIL URL: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9\""\n-FAIL <a>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9\""\n-FAIL <area>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9\""\n-FAIL URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n+FAIL URL: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n+FAIL <a>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n+FAIL <area>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n+PASS URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n PASS URL: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <a>: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <area>: Setting <javascript:alert(1)>.hash = 'castle'"", ""previous_filename"": ""third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-setters-expected.txt""}<_**next**_>{""sha"": ""5422190a3d98f83155961158319fe379a4c4c8b3"", ""filename"": ""third_party/WebKit/LayoutTests/fast/domurl/url-hash.html"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/domurl/url-hash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/domurl/url-hash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/domurl/url-hash.html?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -55,7 +55,7 @@\n     assert_equals(url.hash, '');\n \n     url.hash = '\\udc01\\ud802a';\n-    assert_equals(url.hash, '#\\ufffd\\ufffda');\n+    assert_equals(url.hash, '#%EF%BF%BD%EF%BF%BDa');\n }, 'hash with unmatched surrogates');\n \n </script>""}<_**next**_>{""sha"": ""6fe9c1b320ef5f270baf8b8ea1b45fed616bbcb9"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/anchor-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/anchor-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/anchor-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/anchor-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -4,11 +4,11 @@ On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\n \n \n PASS canonicalize('http://www.example.com/#hello, world') is 'http://www.example.com/#hello, world'\n-PASS canonicalize('http://www.example.com/#\u00c2\u00a9') is 'http://www.example.com/#\u00c2\u00a9'\n-PASS canonicalize('http://www.example.com/#\ud800\udf00ss') is 'http://www.example.com/#\ud800\udf00ss'\n+PASS canonicalize('http://www.example.com/#\u00c2\u00a9') is 'http://www.example.com/#%C3%82%C2%A9'\n+PASS canonicalize('http://www.example.com/#\ud800\udf00ss') is 'http://www.example.com/#%F0%90%8C%80ss'\n PASS canonicalize('http://www.example.com/#%41%a') is 'http://www.example.com/#%41%a'\n-PASS canonicalize('http://www.example.com/#\\ud800\\u597d') is 'http://www.example.com/#\\uFFFD\\u597D'\n-FAIL canonicalize('http://www.example.com/#a\\uFDD0') should be http://www.example.com/#a\ufdd0. Was http://www.example.com/#a\ufffd.\n+PASS canonicalize('http://www.example.com/#\\ud800\\u597d') is 'http://www.example.com/#%EF%BF%BD%E5%A5%BD'\n+PASS canonicalize('http://www.example.com/#a\\uFDD0') is 'http://www.example.com/#a%EF%BF%BD'\n PASS canonicalize('http://www.example.com/#asdf#qwer') is 'http://www.example.com/#asdf#qwer'\n PASS canonicalize('http://www.example.com/##asdf') is 'http://www.example.com/##asdf'\n PASS canonicalize('http://www.example.com/#a\\nb\\rc\\td') is 'http://www.example.com/#abcd'""}<_**next**_>{""sha"": ""08654b3fe5287df8683769c414c2b741081d29aa"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/file-http-base-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/file-http-base-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/file-http-base-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/file-http-base-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,8 +20,8 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n FAIL canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') should be file://7:////foo/bar.html. Was file:///7:////foo/bar.html.\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///filer/home/me.\n FAIL canonicalize('file:///C:/foo/../../../bar.html') should be file:///C:/bar.html. Was file:///bar.html.\n-PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#\\xc2'\n-PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#\u00c2'\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n+PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n PASS canonicalize('file:c:\\\\foo\\\\bar.html') is 'file:///c:/foo/bar.html'\n PASS canonicalize('file:c|//foo\\\\bar.html') is 'file:///c%7C//foo/bar.html'""}<_**next**_>{""sha"": ""2ad64ae1134a8b1bc2c2d40b9a0b3c9aa86ae481"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/anchor.js"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/anchor.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/anchor.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/anchor.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -2,11 +2,11 @@ description(\""Test URLs that have an anchor.\"");\n \n cases = [ \n   [\""hello, world\"", \""hello, world\""],\n-  [\""\\xc2\\xa9\"", \""\\xc2\\xa9\""],\n-  [\""\\ud800\\udf00ss\"", \""\\ud800\\udf00ss\""],\n+  [\""\\xc2\\xa9\"", \""%C3%82%C2%A9\""],\n+  [\""\\ud800\\udf00ss\"", \""%F0%90%8C%80ss\""],\n   [\""%41%a\"", \""%41%a\""],\n-  [\""\\\\ud800\\\\u597d\"", \""\\\\uFFFD\\\\u597D\""],\n-  [\""a\\\\uFDD0\"", \""a\\\\uFDD0\""],\n+  [\""\\\\ud800\\\\u597d\"", \""%EF%BF%BD%E5%A5%BD\""],\n+  [\""a\\\\uFDD0\"", \""a%EF%BF%BD\""],\n   [\""asdf#qwer\"", \""asdf#qwer\""],\n   [\""#asdf\"", \""#asdf\""],\n   [\""a\\\\nb\\\\rc\\\\td\"", \""abcd\""],""}<_**next**_>{""sha"": ""db9386372bec5d3ed93d777839f8eb630b282b86"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/file-http-base.js"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/file-http-base.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/file-http-base.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/file-http-base.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -36,8 +36,8 @@ cases = [\n     // Make sure relative paths can't go above the \""C:\""\n     [\""file:///C:/foo/../../../bar.html\"", \""file:///C:/bar.html\""],\n     // Busted refs shouldn't make the whole thing fail.\n-    [\""file:///C:/asdf#\\\\xc2\"", \""file:///C:/asdf#\\\\xc2\""],\n-    [\""file:///C:/asdf#\\xc2\"", \""file:///C:/asdf#\\xc2\""],\n+    [\""file:///C:/asdf#\\\\xc2\"", \""file:///C:/asdf#%C3%82\""],\n+    [\""file:///C:/asdf#\\xc2\"", \""file:///C:/asdf#%C3%82\""],\n \n     // Unix-style paths\n     [\""file:///home/me\"", \""file:///home/me\""],""}<_**next**_>{""sha"": ""0fc34b79acb7eb8b99cf001b750ef13f12f5f3b5"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/file.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/file.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/file.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/file.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -36,7 +36,7 @@ cases = [\n     // Make sure relative paths can't go above the \""C:\""\n     [\""file:///C:/foo/../../../bar.html\"", \""file:///C:/bar.html\""],\n     // Busted refs shouldn't make the whole thing fail.\n-    [\""file:///C:/asdf#\\\\xc2\"", \""file:///C:/asdf#\\\\xef\\\\xbf\\\\xbd\""],\n+    [\""file:///C:/asdf#\\\\xc2\"", \""file:///C:/asdf#%C3%82\""],\n \n     // Unix-style paths\n     [\""file:///home/me\"", \""file:///home/me\""],""}<_**next**_>{""sha"": ""af075a5c2c7ed601137bf0086f8efec691b7e3a7"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/segments.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/segments.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/segments.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/segments.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -98,7 +98,7 @@ cases = [\n   [\""/a%2fc\"",                                  [\""http:\"",\""example.org\"",\""\"",\""/a%2fc\"",\""\"",\""\""]],\n   [\""/a/%2f/c\"",                                [\""http:\"",\""example.org\"",\""\"",\""/a/%2f/c\"",\""\"",\""\""]],\n \n-  [\""#\\u03B2\"",                                 [\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#\\u03B2\""]],\n+  [\""#\\u03B2\"",                                 [\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#%CE%B2\""]],\n ];\n \n var originalBaseURL = canonicalize(\"".\"");""}<_**next**_>{""sha"": ""75e2422895ceeec756f849b049d4af98ab2b9f4c"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/standard-url.js"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/standard-url.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/standard-url.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/standard-url.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -2,7 +2,7 @@ description(\""Canonicalization of standard URLs\"");\n \n cases = [\n   [\""http://www.google.com/foo?bar=baz#\"", \""http://www.google.com/foo?bar=baz#\""],\n-  [\""http://www.google.com/foo?bar=baz# \\u00bb\"", \""http://www.google.com/foo?bar=baz# \\u00bb\""],\n+  [\""http://www.google.com/foo?bar=baz# \\u00bb\"", \""http://www.google.com/foo?bar=baz# %C2%BB\""],\n   [\""http://[www.google.com]/\"", \""http://[www.google.com]/\""],\n   [\""http://www.google.com\"", \""http://www.google.com/\""],\n   // Disabled because whitespace gets treated different in this API.\n@@ -17,7 +17,7 @@ cases = [\n   // Backslashes should get converted to forward slashes.\n   [\""http:\\\\\\\\\\\\\\\\www.google.com\\\\\\\\foo\"", \""http://www.google.com/foo\""],\n   // Busted refs shouldn't make the whole thing fail.\n-  [\""http://www.google.com/asdf#\\\\ud800\"", \""http://www.google.com/asdf#\\\\uFFFD\""],\n+  [\""http://www.google.com/asdf#\\\\ud800\"", \""http://www.google.com/asdf#%EF%BF%BD\""],\n   // Basic port tests.\n   [\""http://foo:80/\"", \""http://foo/\""],\n   [\""http://foo:81/\"", \""http://foo:81/\""],""}<_**next**_>{""sha"": ""94e75e111e55c8e1bee9fd228b004991651df549"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/segments-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/segments-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/segments-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/segments-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -97,7 +97,7 @@ PASS segments('/a/b/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/b/c\"",\""\"",\""\""]'\n PASS segments('/a/ /c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%20/c\"",\""\"",\""\""]'\n PASS segments('/a%2fc') is '[\""http:\"",\""example.org\"",\""\"",\""/a%2fc\"",\""\"",\""\""]'\n PASS segments('/a/%2f/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%2f/c\"",\""\"",\""\""]'\n-PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#\u03b2\""]'\n+PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#%CE%B2\""]'\n PASS successfullyParsed is true\n \n TEST COMPLETE""}<_**next**_>{""sha"": ""03c416b46404d8384da523031ab83e060ba769ef"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/uri/resolve-encoding-relative-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/http/tests/uri/resolve-encoding-relative-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/http/tests/uri/resolve-encoding-relative-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/uri/resolve-encoding-relative-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -2,8 +2,8 @@ Test how non-ASCII characters are encoded in relative URLs.\n \n 1 2 3 4 5\n 1. PASS\n-2. FAIL: http://127.0.0.1:8000/uri/resolve-encoding-relative.html#\u0444\u0440\u0430\u0433\u043c\u0435\u043d\u0442\n+2. PASS\n 3. PASS\n 4. PASS\n-5. FAIL: http://127.0.0.1:8000/%D0%BF%D1%83%D1%82%D1%8C?%E7%E0%EF%F0%EE%F1#\u0444\u0440\u0430\u0433\u043c\u0435\u043d\u0442\n+5. PASS\n ""}<_**next**_>{""sha"": ""cc508032946f6bab21f5e3371e4af78bc7646bbb"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 328 PASS, 181 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 331 PASS, 178 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""cc508032946f6bab21f5e3371e4af78bc7646bbb"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-xhtml-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-xhtml-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-xhtml-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-xhtml-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 328 PASS, 181 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 331 PASS, 178 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""6296888f4bb5fe59945fb2d94fa2af24b9a5ed05"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-constructor-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-constructor-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-constructor-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-constructor-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 513 tests; 398 PASS, 115 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 513 tests; 401 PASS, 112 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS URL.searchParams getter\n PASS URL.searchParams updating, clearing\n PASS URL.searchParams setter, invalid values\n@@ -107,7 +107,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -166,7 +166,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -272,7 +272,7 @@ PASS Parsing: <http://\ufdd0zyx.com> against <http://other.com/>\n PASS Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/>\n PASS Parsing: <https://\ufffd> against <about:blank>\n PASS Parsing: <https://%EF%BF%BD> against <about:blank>\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw""}<_**next**_>{""sha"": ""964048981fb6ae1cdc1bcd5734e523684b3b5c67"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-setters-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-setters-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-setters-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-setters-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 574 tests; 275 PASS, 299 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 574 tests; 278 PASS, 296 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS URL: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.\n PASS <a>: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.\n@@ -568,9 +568,9 @@ PASS <area>: Setting <https://example.net?lang=en-US#nav>.hash = ''\n FAIL URL: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n FAIL <a>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n FAIL <area>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n-FAIL URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n+PASS URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n PASS URL: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <a>: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <area>: Setting <javascript:alert(1)>.hash = 'castle'""}<_**next**_>{""sha"": ""3a61cfad77f97af1358a7a05eb5fe31abeeece0b"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/url/file-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,7 +20,7 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n FAIL canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') should be file://7:////foo/bar.html. Was file:///7:////foo/bar.html.\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///tmp/mock/filer/home/me.\n FAIL canonicalize('file:///C:/foo/../../../bar.html') should be file:///C:/bar.html. Was file:///bar.html.\n-FAIL canonicalize('file:///C:/asdf#\\xc2') should be file:///C:/asdf#\u00ef\u00bf\u00bd. Was file:///C:/asdf#\u00c2.\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n FAIL canonicalize('file:c:\\\\foo\\\\bar.html') should be file:///c:/foo/bar.html. Was file:///tmp/mock/c:/foo/bar.html.\n FAIL canonicalize('file:c|//foo\\\\bar.html') should be file:///c%7C//foo/bar.html. Was file:///tmp/mock/c%7C//foo/bar.html.""}<_**next**_>{""sha"": ""08654b3fe5287df8683769c414c2b741081d29aa"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/url/file-http-base-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-http-base-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-http-base-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-http-base-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,8 +20,8 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n FAIL canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') should be file://7:////foo/bar.html. Was file:///7:////foo/bar.html.\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///filer/home/me.\n FAIL canonicalize('file:///C:/foo/../../../bar.html') should be file:///C:/bar.html. Was file:///bar.html.\n-PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#\\xc2'\n-PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#\u00c2'\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n+PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n PASS canonicalize('file:c:\\\\foo\\\\bar.html') is 'file:///c:/foo/bar.html'\n PASS canonicalize('file:c|//foo\\\\bar.html') is 'file:///c%7C//foo/bar.html'""}<_**next**_>{""sha"": ""94e75e111e55c8e1bee9fd228b004991651df549"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/url/segments-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/segments-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/segments-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/url/segments-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -97,7 +97,7 @@ PASS segments('/a/b/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/b/c\"",\""\"",\""\""]'\n PASS segments('/a/ /c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%20/c\"",\""\"",\""\""]'\n PASS segments('/a%2fc') is '[\""http:\"",\""example.org\"",\""\"",\""/a%2fc\"",\""\"",\""\""]'\n PASS segments('/a/%2f/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%2f/c\"",\""\"",\""\""]'\n-PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#\u03b2\""]'\n+PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#%CE%B2\""]'\n PASS successfullyParsed is true\n \n TEST COMPLETE""}<_**next**_>{""sha"": ""483f690834c953f23acf32886c9ac9fce8778ab5"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/url/standard-url-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/standard-url-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/standard-url-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/url/standard-url-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -4,7 +4,7 @@ On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\n \n \n PASS canonicalize('http://www.google.com/foo?bar=baz#') is 'http://www.google.com/foo?bar=baz#'\n-PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# \u00bb'\n+PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# %C2%BB'\n PASS canonicalize('http://[www.google.com]/') is 'http://[www.google.com]/'\n PASS canonicalize('http://www.google.com') is 'http://www.google.com/'\n PASS canonicalize('http:////////user:@google.com:99?foo') is 'http://user@google.com:99/?foo'\n@@ -13,7 +13,7 @@ PASS canonicalize('http://www/foo%2Ehtml') is 'http://www/foo.html'\n PASS canonicalize('http://user:pass@/') is 'http://user:pass@/'\n PASS canonicalize('http://%25DOMAIN:foobar@foodomain.com/') is 'http://%25DOMAIN:foobar@foodomain.com/'\n PASS canonicalize('http:\\\\\\\\www.google.com\\\\foo') is 'http://www.google.com/foo'\n-PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#\\uFFFD'\n+PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#%EF%BF%BD'\n PASS canonicalize('http://foo:80/') is 'http://foo/'\n PASS canonicalize('http://foo:81/') is 'http://foo:81/'\n PASS canonicalize('httpa://foo:80/') is 'httpa://foo:80/'""}<_**next**_>{""sha"": ""cc508032946f6bab21f5e3371e4af78bc7646bbb"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 328 PASS, 181 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 331 PASS, 178 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""cc508032946f6bab21f5e3371e4af78bc7646bbb"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-xhtml-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-xhtml-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-xhtml-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-xhtml-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 328 PASS, 181 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 331 PASS, 178 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""6296888f4bb5fe59945fb2d94fa2af24b9a5ed05"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-constructor-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-constructor-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-constructor-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-constructor-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 513 tests; 398 PASS, 115 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 513 tests; 401 PASS, 112 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS URL.searchParams getter\n PASS URL.searchParams updating, clearing\n PASS URL.searchParams setter, invalid values\n@@ -107,7 +107,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -166,7 +166,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -272,7 +272,7 @@ PASS Parsing: <http://\ufdd0zyx.com> against <http://other.com/>\n PASS Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/>\n PASS Parsing: <https://\ufffd> against <about:blank>\n PASS Parsing: <https://%EF%BF%BD> against <about:blank>\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw""}<_**next**_>{""sha"": ""964048981fb6ae1cdc1bcd5734e523684b3b5c67"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-setters-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-setters-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-setters-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-setters-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 574 tests; 275 PASS, 299 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 574 tests; 278 PASS, 296 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS URL: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.\n PASS <a>: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.\n@@ -568,9 +568,9 @@ PASS <area>: Setting <https://example.net?lang=en-US#nav>.hash = ''\n FAIL URL: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n FAIL <a>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n FAIL <area>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n-FAIL URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n+PASS URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n PASS URL: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <a>: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <area>: Setting <javascript:alert(1)>.hash = 'castle'""}<_**next**_>{""sha"": ""3a61cfad77f97af1358a7a05eb5fe31abeeece0b"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/fast/url/file-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/fast/url/file-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/fast/url/file-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/fast/url/file-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,7 +20,7 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n FAIL canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') should be file://7:////foo/bar.html. Was file:///7:////foo/bar.html.\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///tmp/mock/filer/home/me.\n FAIL canonicalize('file:///C:/foo/../../../bar.html') should be file:///C:/bar.html. Was file:///bar.html.\n-FAIL canonicalize('file:///C:/asdf#\\xc2') should be file:///C:/asdf#\u00ef\u00bf\u00bd. Was file:///C:/asdf#\u00c2.\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n FAIL canonicalize('file:c:\\\\foo\\\\bar.html') should be file:///c:/foo/bar.html. Was file:///tmp/mock/c:/foo/bar.html.\n FAIL canonicalize('file:c|//foo\\\\bar.html') should be file:///c%7C//foo/bar.html. Was file:///tmp/mock/c%7C//foo/bar.html.""}<_**next**_>{""sha"": ""483f690834c953f23acf32886c9ac9fce8778ab5"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/fast/url/standard-url-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/fast/url/standard-url-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/fast/url/standard-url-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/fast/url/standard-url-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -4,7 +4,7 @@ On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\n \n \n PASS canonicalize('http://www.google.com/foo?bar=baz#') is 'http://www.google.com/foo?bar=baz#'\n-PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# \u00bb'\n+PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# %C2%BB'\n PASS canonicalize('http://[www.google.com]/') is 'http://[www.google.com]/'\n PASS canonicalize('http://www.google.com') is 'http://www.google.com/'\n PASS canonicalize('http:////////user:@google.com:99?foo') is 'http://user@google.com:99/?foo'\n@@ -13,7 +13,7 @@ PASS canonicalize('http://www/foo%2Ehtml') is 'http://www/foo.html'\n PASS canonicalize('http://user:pass@/') is 'http://user:pass@/'\n PASS canonicalize('http://%25DOMAIN:foobar@foodomain.com/') is 'http://%25DOMAIN:foobar@foodomain.com/'\n PASS canonicalize('http:\\\\\\\\www.google.com\\\\foo') is 'http://www.google.com/foo'\n-PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#\\uFFFD'\n+PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#%EF%BF%BD'\n PASS canonicalize('http://foo:80/') is 'http://foo/'\n PASS canonicalize('http://foo:81/') is 'http://foo:81/'\n PASS canonicalize('httpa://foo:80/') is 'httpa://foo:80/'""}<_**next**_>{""sha"": ""e966f7357806b26bd6eb3e5d09b1bd46c52402fa"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 324 PASS, 185 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 327 PASS, 182 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///C:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""e966f7357806b26bd6eb3e5d09b1bd46c52402fa"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-xhtml-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-xhtml-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-xhtml-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-xhtml-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 324 PASS, 185 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 327 PASS, 182 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///C:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""1b7414e269228933412bab601cbb152ec66e4200"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-constructor-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-constructor-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-constructor-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-constructor-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 513 tests; 392 PASS, 121 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 513 tests; 395 PASS, 118 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS URL.searchParams getter\n PASS URL.searchParams updating, clearing\n PASS URL.searchParams setter, invalid values\n@@ -107,7 +107,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///C:/foo/bar.html\""\n@@ -166,7 +166,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -272,7 +272,7 @@ PASS Parsing: <http://\ufdd0zyx.com> against <http://other.com/>\n PASS Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/>\n PASS Parsing: <https://\ufffd> against <about:blank>\n PASS Parsing: <https://%EF%BF%BD> against <about:blank>\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw""}<_**next**_>{""sha"": ""6c8cd6b4b4443053d60525e36956fee495b7b6f7"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/fast/url/file-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/file-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/file-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/fast/url/file-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,7 +20,7 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n PASS canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') is 'file://7:////foo/bar.html'\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///tmp/mock/filer/home/me.\n PASS canonicalize('file:///C:/foo/../../../bar.html') is 'file:///C:/bar.html'\n-FAIL canonicalize('file:///C:/asdf#\\xc2') should be file:///C:/asdf#\u00ef\u00bf\u00bd. Was file:///C:/asdf#\u00c2.\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n FAIL canonicalize('file:c:\\\\foo\\\\bar.html') should be file:///c:/foo/bar.html. Was file:///C:/foo/bar.html.\n FAIL canonicalize('file:c|//foo\\\\bar.html') should be file:///c%7C//foo/bar.html. Was file:///C://foo/bar.html.""}<_**next**_>{""sha"": ""e331b5e2c7ad2956b78a496e1ae3723e6f7e358a"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/fast/url/file-http-base-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/file-http-base-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/file-http-base-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/fast/url/file-http-base-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,8 +20,8 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n PASS canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') is 'file://7:////foo/bar.html'\n PASS canonicalize('file:filer/home\\\\me') is 'file://filer/home/me'\n PASS canonicalize('file:///C:/foo/../../../bar.html') is 'file:///C:/bar.html'\n-PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#\\xc2'\n-PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#\u00c2'\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n+PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n FAIL canonicalize('file:c:\\\\foo\\\\bar.html') should be file:///c:/foo/bar.html. Was file:///C:/foo/bar.html.\n FAIL canonicalize('file:c|//foo\\\\bar.html') should be file:///c%7C//foo/bar.html. Was file:///C://foo/bar.html.""}<_**next**_>{""sha"": ""0fb1a0301f109feb9e6dd386dbf83a00c0343f05"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/fast/url/segments-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/segments-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/segments-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/fast/url/segments-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -97,7 +97,7 @@ PASS segments('/a/b/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/b/c\"",\""\"",\""\""]'\n PASS segments('/a/ /c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%20/c\"",\""\"",\""\""]'\n PASS segments('/a%2fc') is '[\""http:\"",\""example.org\"",\""\"",\""/a%2fc\"",\""\"",\""\""]'\n PASS segments('/a/%2f/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%2f/c\"",\""\"",\""\""]'\n-PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#\u03b2\""]'\n+PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#%CE%B2\""]'\n PASS successfullyParsed is true\n \n TEST COMPLETE""}<_**next**_>{""sha"": ""9373dcc8dfa2032009e78c8871ce6ddd45a5cbec"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/fast/url/standard-url-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/standard-url-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/standard-url-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/fast/url/standard-url-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -4,7 +4,7 @@ On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\n \n \n PASS canonicalize('http://www.google.com/foo?bar=baz#') is 'http://www.google.com/foo?bar=baz#'\n-PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# \u00bb'\n+PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# %C2%BB'\n PASS canonicalize('http://[www.google.com]/') is 'http://[www.google.com]/'\n PASS canonicalize('http://www.google.com') is 'http://www.google.com/'\n PASS canonicalize('http:////////user:@google.com:99?foo') is 'http://user@google.com:99/?foo'\n@@ -13,7 +13,7 @@ PASS canonicalize('http://www/foo%2Ehtml') is 'http://www/foo.html'\n PASS canonicalize('http://user:pass@/') is 'http://user:pass@/'\n PASS canonicalize('http://%25DOMAIN:foobar@foodomain.com/') is 'http://%25DOMAIN:foobar@foodomain.com/'\n PASS canonicalize('http:\\\\\\\\www.google.com\\\\foo') is 'http://www.google.com/foo'\n-PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#\\uFFFD'\n+PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#%EF%BF%BD'\n PASS canonicalize('http://foo:80/') is 'http://foo/'\n PASS canonicalize('http://foo:81/') is 'http://foo:81/'\n PASS canonicalize('httpa://foo:80/') is 'httpa://foo:80/'""}<_**next**_>{""sha"": ""dc386c57ab5f3083b1b77947dd1116c7612a248d"", ""filename"": ""third_party/WebKit/Source/platform/weborigin/KURLTest.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/Source/platform/weborigin/KURLTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/Source/platform/weborigin/KURLTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/weborigin/KURLTest.cpp?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -61,7 +61,7 @@ TEST(KURLTest, Getters) {\n        // shouldn't return it in percent-encoded form.\n        \""http://www.google.com/foo/blah?bar=baz#\\xce\\xb1\\xce\\xb2\"", \""http\"",\n        \""www.google.com\"", 0, \""\"", 0, \""/foo/blah\"", \""blah\"", \""bar=baz\"",\n-       \""\\xce\\xb1\\xce\\xb2\"", true},\n+       \""%CE%B1%CE%B2\"", true},\n       {\""http://foo.com:1234/foo/bar/\"", \""http\"", \""foo.com\"", 1234, \""\"", 0,\n        \""/foo/bar/\"", \""bar\"", 0, 0, false},\n       {\""http://www.google.com?#\"", \""http\"", \""www.google.com\"", 0, \""\"", 0, \""/\"", 0,""}<_**next**_>{""sha"": ""5dc81052311965a922f571c59f9be0064328dc82"", ""filename"": ""url/url_canon_etc.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 7, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/url/url_canon_etc.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/url/url_canon_etc.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/url/url_canon_etc.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -275,13 +275,7 @@ void DoCanonicalizeRef(const CHAR* spec,\n       // Normal ASCII characters are just appended.\n       output->push_back(static_cast<char>(spec[i]));\n     } else {\n-      // Non-ASCII characters are appended unescaped, but only when they are\n-      // valid. Invalid Unicode characters are replaced with the \""invalid\n-      // character\"" as IE seems to (ReadUTFChar puts the unicode replacement\n-      // character in the output on failure for us).\n-      unsigned code_point;\n-      ReadUTFChar(spec, &i, end, &code_point);\n-      AppendUTF8Value(code_point, output);\n+      AppendUTF8EscapedChar(spec, &i, end, output);\n     }\n   }\n ""}<_**next**_>{""sha"": ""feac82c44b350d5be2be6ff8730ea7c9352c422a"", ""filename"": ""url/url_canon_unittest.cc"", ""status"": ""modified"", ""additions"": 83, ""deletions"": 58, ""changes"": 141, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/url/url_canon_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/url/url_canon_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/url/url_canon_unittest.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1274,21 +1274,23 @@ TEST(URLCanonTest, Ref) {\n   // Refs are trivial, it just checks the encoding.\n   DualComponentCase ref_cases[] = {\n       // Regular one, we shouldn't escape spaces, et al.\n-    {\""hello, world\"", L\""hello, world\"", \""#hello, world\"", Component(1, 12), true},\n+      {\""hello, world\"", L\""hello, world\"", \""#hello, world\"", Component(1, 12),\n+       true},\n       // UTF-8/wide input should be preserved\n-    {\""\\xc2\\xa9\"", L\""\\xa9\"", \""#\\xc2\\xa9\"", Component(1, 2), true},\n+      {\""\\xc2\\xa9\"", L\""\\xa9\"", \""#%C2%A9\"", Component(1, 6), true},\n       // Test a characer that takes > 16 bits (U+10300 = old italic letter A)\n-    {\""\\xF0\\x90\\x8C\\x80ss\"", L\""\\xd800\\xdf00ss\"", \""#\\xF0\\x90\\x8C\\x80ss\"", Component(1, 6), true},\n+      {\""\\xF0\\x90\\x8C\\x80ss\"", L\""\\xd800\\xdf00ss\"", \""#%F0%90%8C%80ss\"",\n+       Component(1, 14), true},\n       // Escaping should be preserved unchanged, even invalid ones\n-    {\""%41%a\"", L\""%41%a\"", \""#%41%a\"", Component(1, 5), true},\n+      {\""%41%a\"", L\""%41%a\"", \""#%41%a\"", Component(1, 5), true},\n       // Invalid UTF-8/16 input should be flagged and the input made valid\n-    {\""\\xc2\"", NULL, \""#\\xef\\xbf\\xbd\"", Component(1, 3), true},\n-    {NULL, L\""\\xd800\\x597d\"", \""#\\xef\\xbf\\xbd\\xe5\\xa5\\xbd\"", Component(1, 6), true},\n+      {\""\\xc2\"", NULL, \""#%EF%BF%BD\"", Component(1, 9), true},\n+      {NULL, L\""\\xd800\\x597d\"", \""#%EF%BF%BD%E5%A5%BD\"", Component(1, 18), true},\n       // Test a Unicode invalid character.\n-    {\""a\\xef\\xb7\\x90\"", L\""a\\xfdd0\"", \""#a\\xef\\xbf\\xbd\"", Component(1, 4), true},\n+      {\""a\\xef\\xb7\\x90\"", L\""a\\xfdd0\"", \""#a%EF%BF%BD\"", Component(1, 10), true},\n       // Refs can have # signs and we should preserve them.\n-    {\""asdf#qwer\"", L\""asdf#qwer\"", \""#asdf#qwer\"", Component(1, 9), true},\n-    {\""#asdf\"", L\""#asdf\"", \""##asdf\"", Component(1, 5), true},\n+      {\""asdf#qwer\"", L\""asdf#qwer\"", \""#asdf#qwer\"", Component(1, 9), true},\n+      {\""#asdf\"", L\""#asdf\"", \""##asdf\"", Component(1, 5), true},\n   };\n \n   for (size_t i = 0; i < arraysize(ref_cases); i++) {\n@@ -1351,49 +1353,56 @@ TEST(URLCanonTest, CanonicalizeStandardURL) {\n     const char* expected;\n     bool expected_success;\n   } cases[] = {\n-    {\""http://www.google.com/foo?bar=baz#\"", \""http://www.google.com/foo?bar=baz#\"", true},\n-    {\""http://[www.google.com]/\"", \""http://[www.google.com]/\"", false},\n-    {\""ht\\ttp:@www.google.com:80/;p?#\"", \""ht%09tp://www.google.com:80/;p?#\"", false},\n-    {\""http:////////user:@google.com:99?foo\"", \""http://user@google.com:99/?foo\"", true},\n-    {\""www.google.com\"", \"":www.google.com/\"", false},\n-    {\""http://192.0x00A80001\"", \""http://192.168.0.1/\"", true},\n-    {\""http://www/foo%2Ehtml\"", \""http://www/foo.html\"", true},\n-    {\""http://user:pass@/\"", \""http://user:pass@/\"", false},\n-    {\""http://%25DOMAIN:foobar@foodomain.com/\"", \""http://%25DOMAIN:foobar@foodomain.com/\"", true},\n+      {\""http://www.google.com/foo?bar=baz#\"",\n+       \""http://www.google.com/foo?bar=baz#\"", true},\n+      {\""http://[www.google.com]/\"", \""http://[www.google.com]/\"", false},\n+      {\""ht\\ttp:@www.google.com:80/;p?#\"", \""ht%09tp://www.google.com:80/;p?#\"",\n+       false},\n+      {\""http:////////user:@google.com:99?foo\"", \""http://user@google.com:99/?foo\"",\n+       true},\n+      {\""www.google.com\"", \"":www.google.com/\"", false},\n+      {\""http://192.0x00A80001\"", \""http://192.168.0.1/\"", true},\n+      {\""http://www/foo%2Ehtml\"", \""http://www/foo.html\"", true},\n+      {\""http://user:pass@/\"", \""http://user:pass@/\"", false},\n+      {\""http://%25DOMAIN:foobar@foodomain.com/\"",\n+       \""http://%25DOMAIN:foobar@foodomain.com/\"", true},\n \n       // Backslashes should get converted to forward slashes.\n-    {\""http:\\\\\\\\www.google.com\\\\foo\"", \""http://www.google.com/foo\"", true},\n+      {\""http:\\\\\\\\www.google.com\\\\foo\"", \""http://www.google.com/foo\"", true},\n \n       // Busted refs shouldn't make the whole thing fail.\n-    {\""http://www.google.com/asdf#\\xc2\"", \""http://www.google.com/asdf#\\xef\\xbf\\xbd\"", true},\n+      {\""http://www.google.com/asdf#\\xc2\"",\n+       \""http://www.google.com/asdf#%EF%BF%BD\"", true},\n \n       // Basic port tests.\n-    {\""http://foo:80/\"", \""http://foo/\"", true},\n-    {\""http://foo:81/\"", \""http://foo:81/\"", true},\n-    {\""httpa://foo:80/\"", \""httpa://foo:80/\"", true},\n-    {\""http://foo:-80/\"", \""http://foo:-80/\"", false},\n-\n-    {\""https://foo:443/\"", \""https://foo/\"", true},\n-    {\""https://foo:80/\"", \""https://foo:80/\"", true},\n-    {\""ftp://foo:21/\"", \""ftp://foo/\"", true},\n-    {\""ftp://foo:80/\"", \""ftp://foo:80/\"", true},\n-    {\""gopher://foo:70/\"", \""gopher://foo/\"", true},\n-    {\""gopher://foo:443/\"", \""gopher://foo:443/\"", true},\n-    {\""ws://foo:80/\"", \""ws://foo/\"", true},\n-    {\""ws://foo:81/\"", \""ws://foo:81/\"", true},\n-    {\""ws://foo:443/\"", \""ws://foo:443/\"", true},\n-    {\""ws://foo:815/\"", \""ws://foo:815/\"", true},\n-    {\""wss://foo:80/\"", \""wss://foo:80/\"", true},\n-    {\""wss://foo:81/\"", \""wss://foo:81/\"", true},\n-    {\""wss://foo:443/\"", \""wss://foo/\"", true},\n-    {\""wss://foo:815/\"", \""wss://foo:815/\"", true},\n+      {\""http://foo:80/\"", \""http://foo/\"", true},\n+      {\""http://foo:81/\"", \""http://foo:81/\"", true},\n+      {\""httpa://foo:80/\"", \""httpa://foo:80/\"", true},\n+      {\""http://foo:-80/\"", \""http://foo:-80/\"", false},\n+\n+      {\""https://foo:443/\"", \""https://foo/\"", true},\n+      {\""https://foo:80/\"", \""https://foo:80/\"", true},\n+      {\""ftp://foo:21/\"", \""ftp://foo/\"", true},\n+      {\""ftp://foo:80/\"", \""ftp://foo:80/\"", true},\n+      {\""gopher://foo:70/\"", \""gopher://foo/\"", true},\n+      {\""gopher://foo:443/\"", \""gopher://foo:443/\"", true},\n+      {\""ws://foo:80/\"", \""ws://foo/\"", true},\n+      {\""ws://foo:81/\"", \""ws://foo:81/\"", true},\n+      {\""ws://foo:443/\"", \""ws://foo:443/\"", true},\n+      {\""ws://foo:815/\"", \""ws://foo:815/\"", true},\n+      {\""wss://foo:80/\"", \""wss://foo:80/\"", true},\n+      {\""wss://foo:81/\"", \""wss://foo:81/\"", true},\n+      {\""wss://foo:443/\"", \""wss://foo/\"", true},\n+      {\""wss://foo:815/\"", \""wss://foo:815/\"", true},\n \n       // This particular code path ends up \""backing up\"" to replace an invalid\n       // host ICU generated with an escaped version. Test that in the context\n       // of a full URL to make sure the backing up doesn't mess up the non-host\n       // parts of the URL. \""EF B9 AA\"" is U+FE6A which is a type of percent that\n       // ICU will convert to an ASCII one, generating \""%81\"".\n-    {\""ws:)W\\x1eW\\xef\\xb9\\xaa\""\""81:80/\"", \""ws://%29w%1ew%81/\"", false},\n+      {\""ws:)W\\x1eW\\xef\\xb9\\xaa\""\n+       \""81:80/\"",\n+       \""ws://%29w%1ew%81/\"", false},\n   };\n \n   for (size_t i = 0; i < arraysize(cases); i++) {\n@@ -1683,41 +1692,57 @@ TEST(URLCanonTest, CanonicalizeFileURL) {\n   } cases[] = {\n #ifdef _WIN32\n       // Windows-style paths\n-    {\""file:c:\\\\foo\\\\bar.html\"", \""file:///C:/foo/bar.html\"", true, Component(), Component(7, 16)},\n-    {\""  File:c|////foo\\\\bar.html\"", \""file:///C:////foo/bar.html\"", true, Component(), Component(7, 19)},\n-    {\""file:\"", \""file:///\"", true, Component(), Component(7, 1)},\n-    {\""file:UNChost/path\"", \""file://unchost/path\"", true, Component(7, 7), Component(14, 5)},\n+      {\""file:c:\\\\foo\\\\bar.html\"", \""file:///C:/foo/bar.html\"", true, Component(),\n+       Component(7, 16)},\n+      {\""  File:c|////foo\\\\bar.html\"", \""file:///C:////foo/bar.html\"", true,\n+       Component(), Component(7, 19)},\n+      {\""file:\"", \""file:///\"", true, Component(), Component(7, 1)},\n+      {\""file:UNChost/path\"", \""file://unchost/path\"", true, Component(7, 7),\n+       Component(14, 5)},\n       // CanonicalizeFileURL supports absolute Windows style paths for IE\n       // compatibility. Note that the caller must decide that this is a file\n       // URL itself so it can call the file canonicalizer. This is usually\n       // done automatically as part of relative URL resolving.\n-    {\""c:\\\\foo\\\\bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n-    {\""C|/foo/bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n-    {\""/C|\\\\foo\\\\bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n-    {\""//C|/foo/bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n-    {\""//server/file\"", \""file://server/file\"", true, Component(7, 6), Component(13, 5)},\n-    {\""\\\\\\\\server\\\\file\"", \""file://server/file\"", true, Component(7, 6), Component(13, 5)},\n-    {\""/\\\\server/file\"", \""file://server/file\"", true, Component(7, 6), Component(13, 5)},\n+      {\""c:\\\\foo\\\\bar\"", \""file:///C:/foo/bar\"", true, Component(),\n+       Component(7, 11)},\n+      {\""C|/foo/bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n+      {\""/C|\\\\foo\\\\bar\"", \""file:///C:/foo/bar\"", true, Component(),\n+       Component(7, 11)},\n+      {\""//C|/foo/bar\"", \""file:///C:/foo/bar\"", true, Component(),\n+       Component(7, 11)},\n+      {\""//server/file\"", \""file://server/file\"", true, Component(7, 6),\n+       Component(13, 5)},\n+      {\""\\\\\\\\server\\\\file\"", \""file://server/file\"", true, Component(7, 6),\n+       Component(13, 5)},\n+      {\""/\\\\server/file\"", \""file://server/file\"", true, Component(7, 6),\n+       Component(13, 5)},\n       // We should preserve the number of slashes after the colon for IE\n       // compatibility, except when there is none, in which case we should\n       // add one.\n-    {\""file:c:foo/bar.html\"", \""file:///C:/foo/bar.html\"", true, Component(), Component(7, 16)},\n-    {\""file:/\\\\/\\\\C:\\\\\\\\//foo\\\\bar.html\"", \""file:///C:////foo/bar.html\"", true, Component(), Component(7, 19)},\n+      {\""file:c:foo/bar.html\"", \""file:///C:/foo/bar.html\"", true, Component(),\n+       Component(7, 16)},\n+      {\""file:/\\\\/\\\\C:\\\\\\\\//foo\\\\bar.html\"", \""file:///C:////foo/bar.html\"", true,\n+       Component(), Component(7, 19)},\n       // Three slashes should be non-UNC, even if there is no drive spec (IE\n       // does this, which makes the resulting request invalid).\n-    {\""file:///foo/bar.txt\"", \""file:///foo/bar.txt\"", true, Component(), Component(7, 12)},\n+      {\""file:///foo/bar.txt\"", \""file:///foo/bar.txt\"", true, Component(),\n+       Component(7, 12)},\n       // TODO(brettw) we should probably fail for invalid host names, which\n       // would change the expected result on this test. We also currently allow\n       // colon even though it's probably invalid, because its currently the\n       // \""natural\"" result of the way the canonicalizer is written. There doesn't\n       // seem to be a strong argument for why allowing it here would be bad, so\n       // we just tolerate it and the load will fail later.\n-    {\""FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html\"", \""file://7:////foo/bar.html\"", false, Component(7, 2), Component(9, 16)},\n-    {\""file:filer/home\\\\me\"", \""file://filer/home/me\"", true, Component(7, 5), Component(12, 8)},\n+      {\""FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html\"", \""file://7:////foo/bar.html\"", false,\n+       Component(7, 2), Component(9, 16)},\n+      {\""file:filer/home\\\\me\"", \""file://filer/home/me\"", true, Component(7, 5),\n+       Component(12, 8)},\n       // Make sure relative paths can't go above the \""C:\""\n-    {\""file:///C:/foo/../../../bar.html\"", \""file:///C:/bar.html\"", true, Component(), Component(7, 12)},\n+      {\""file:///C:/foo/../../../bar.html\"", \""file:///C:/bar.html\"", true,\n+       Component(), Component(7, 12)},\n       // Busted refs shouldn't make the whole thing fail.\n-    {\""file:///C:/asdf#\\xc2\"", \""file:///C:/asdf#\\xef\\xbf\\xbd\"", true, Component(), Component(7, 8)},\n+      {\""file:///C:/asdf#\\xc2\"", \""file:///C:/asdf#%EF%BF%BD\"", true, Component(),\n+       Component(7, 8)},\n #else\n       // Unix-style paths\n     {\""file:///home/me\"", \""file:///home/me\"", true, Component(), Component(7, 8)},""}","void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    *out_ref = Component();
    return;
  }

  output->push_back('#');
  out_ref->begin = output->length();

  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       output->push_back(static_cast<char>(spec[i]));
     } else {
      AppendUTF8EscapedChar(spec, &i, end, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
","void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    *out_ref = Component();
    return;
  }

  output->push_back('#');
  out_ref->begin = output->length();

  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       output->push_back(static_cast<char>(spec[i]));
     } else {
      unsigned code_point;
      ReadUTFChar(spec, &i, end, &code_point);
      AppendUTF8Value(code_point, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
",C,"      AppendUTF8EscapedChar(spec, &i, end, output);
","      unsigned code_point;
      ReadUTFChar(spec, &i, end, &code_point);
      AppendUTF8Value(code_point, output);
",,"@@ -275,13 +275,7 @@ void DoCanonicalizeRef(const CHAR* spec,
       // Normal ASCII characters are just appended.
       output->push_back(static_cast<char>(spec[i]));
     } else {
-      // Non-ASCII characters are appended unescaped, but only when they are
-      // valid. Invalid Unicode characters are replaced with the ""invalid
-      // character"" as IE seems to (ReadUTFChar puts the unicode replacement
-      // character in the output on failure for us).
-      unsigned code_point;
-      ReadUTFChar(spec, &i, end, &code_point);
-      AppendUTF8Value(code_point, output);
+      AppendUTF8EscapedChar(spec, &i, end, output);
     }
   }
 ",Chrome,f8f6ed59949be4451ee2f5443d8a313f102fde60,0a918e900a759b04f177cc5b8bca668140751136,1,"void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    // Common case of no ref.
    *out_ref = Component();
    return;
  }

  // Append the ref separator. Note that we need to do this even when the ref
  // is empty but present.
  output->push_back('#');
  out_ref->begin = output->length();

  // Now iterate through all the characters, converting to UTF-8 and validating.
  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      // IE just strips NULLs, so we do too.
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      // Unline IE seems to, we escape control characters. This will probably
      // make the reference fragment unusable on a web page, but people
      // shouldn't be using control characters in their anchor names.
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       // Normal ASCII characters are just appended.
       output->push_back(static_cast<char>(spec[i]));
     } else {
//flaw_line_below:
      // Non-ASCII characters are appended unescaped, but only when they are
//flaw_line_below:
      // valid. Invalid Unicode characters are replaced with the ""invalid
//flaw_line_below:
      // character"" as IE seems to (ReadUTFChar puts the unicode replacement
//flaw_line_below:
      // character in the output on failure for us).
//flaw_line_below:
      unsigned code_point;
//flaw_line_below:
      ReadUTFChar(spec, &i, end, &code_point);
//flaw_line_below:
      AppendUTF8Value(code_point, output);
//fix_flaw_line_below:
//      AppendUTF8EscapedChar(spec, &i, end, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
"
9178,186914,,Remote,Not required,,CVE-2017-15427,https://www.cvedetails.com/cve/CVE-2017-15427/,CWE-79,Medium,,Partial,,2018-08-28,4.3,Insufficient policy enforcement in Omnibox in Google Chrome prior to 63.0.3239.84 allowed a socially engineered user to XSS themselves by dragging and dropping a javascript: URL into the URL bar.,2018-11-02,XSS ,2,https://github.com/chromium/chromium/commit/16c719e0e275d2ee5d5c69e4962b744bcaf0fe40,16c719e0e275d2ee5d5c69e4962b744bcaf0fe40,"Strip JavaScript schemas on Linux text drop

When dropping text onto the Omnibox, any leading JavaScript schemes
should be stripped to avoid a ""self-XSS"" attack. This stripping already
occurs in all cases except when plaintext is dropped on Linux. This CL
corrects that oversight.

Bug: 768910
Change-Id: I43af24ace4a13cf61d15a32eb9382dcdd498a062
Reviewed-on: https://chromium-review.googlesource.com/685638
Reviewed-by: Justin Donnelly <jdonnelly@chromium.org>
Commit-Queue: Eric Lawrence <elawrence@chromium.org>
Cr-Commit-Position: refs/heads/master@{#504695}",1,chrome/browser/ui/views/omnibox/omnibox_view_views.cc,"{""sha"": ""98a8ac9c38531ee785f98f7ce297dde52f5ad7fa"", ""filename"": ""chrome/browser/ui/views/omnibox/omnibox_view_views.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/16c719e0e275d2ee5d5c69e4962b744bcaf0fe40/chrome/browser/ui/views/omnibox/omnibox_view_views.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/16c719e0e275d2ee5d5c69e4962b744bcaf0fe40/chrome/browser/ui/views/omnibox/omnibox_view_views.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/omnibox/omnibox_view_views.cc?ref=16c719e0e275d2ee5d5c69e4962b744bcaf0fe40"", ""patch"": ""@@ -1098,7 +1098,8 @@ int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {\n   } else if (data.HasString()) {\n     base::string16 text;\n     if (data.GetString(&text)) {\n-      base::string16 collapsed_text(base::CollapseWhitespace(text, true));\n+      base::string16 collapsed_text(\n+          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));\n       if (model()->CanPasteAndGo(collapsed_text))\n         model()->PasteAndGo(collapsed_text);\n       return ui::DragDropTypes::DRAG_COPY;""}","int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
      base::string16 collapsed_text(
          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
","int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
",C,"      base::string16 collapsed_text(
          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
","      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
",,"@@ -1098,7 +1098,8 @@ int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
-      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
+      base::string16 collapsed_text(
+          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;",Chrome,16c719e0e275d2ee5d5c69e4962b744bcaf0fe40,4a165e1b93e099fceb38de3ade51e368ce949075,1,"int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
//flaw_line_below:
      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
//fix_flaw_line_below:
//      base::string16 collapsed_text(
//fix_flaw_line_below:
//          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
"
9179,186915,,Remote,Not required,,CVE-2017-15429,https://www.cvedetails.com/cve/CVE-2017-15429/,CWE-79,Medium,,Partial,,2018-08-28,4.3,Inappropriate implementation in V8 WebAssembly JS bindings in Google Chrome prior to 63.0.3239.108 allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via a crafted HTML page.,2018-11-07,XSS ,2,https://github.com/chromium/chromium/commit/c5a59182a8406f67333c283a31f257714f082b7d,c5a59182a8406f67333c283a31f257714f082b7d,"[wasm] Use correct bindings APIs

Use ScriptState::ForCurrentRealm in static methods, instead of
ForRelevantRealm().

Bug: chromium:788453
Change-Id: I63bd25e3f5a4e8d7cbaff945da8df0d71aa65527
Reviewed-on: https://chromium-review.googlesource.com/795096
Commit-Queue: Mircea Trofin <mtrofin@chromium.org>
Reviewed-by: Yuki Shiino <yukishiino@chromium.org>
Reviewed-by: Kentaro Hara <haraken@chromium.org>
Cr-Commit-Position: refs/heads/master@{#520174}",2,third_party/WebKit/Source/bindings/modules/v8/wasm/WasmResponseExtensions.cpp,"{""sha"": ""0e76edd65b7baf5316fc9d0c4da59a3502e4c27a"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/wasm_streaming/resources/blank.html"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/c5a59182a8406f67333c283a31f257714f082b7d/third_party/WebKit/LayoutTests/http/tests/wasm_streaming/resources/blank.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c5a59182a8406f67333c283a31f257714f082b7d/third_party/WebKit/LayoutTests/http/tests/wasm_streaming/resources/blank.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/wasm_streaming/resources/blank.html?ref=c5a59182a8406f67333c283a31f257714f082b7d"", ""patch"": ""@@ -0,0 +1 @@\n+<!DOCTYPE html>""}<_**next**_>{""sha"": ""0e3e69afa1b2b28c3b8ae4844ddd102917ed8717"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/wasm_streaming/wasm_streaming_xss.https.html"", ""status"": ""added"", ""additions"": 51, ""deletions"": 0, ""changes"": 51, ""blob_url"": ""https://github.com/chromium/chromium/blob/c5a59182a8406f67333c283a31f257714f082b7d/third_party/WebKit/LayoutTests/http/tests/wasm_streaming/wasm_streaming_xss.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c5a59182a8406f67333c283a31f257714f082b7d/third_party/WebKit/LayoutTests/http/tests/wasm_streaming/wasm_streaming_xss.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/wasm_streaming/wasm_streaming_xss.https.html?ref=c5a59182a8406f67333c283a31f257714f082b7d"", ""patch"": ""@@ -0,0 +1,51 @@\n+<!DOCTYPE html>\n+<script src=\""../../../resources/testharness.js\""></script>\n+<script src=\""../../../resources/testharnessreport.js\""></script>\n+<script src=\""../resources/get-host-info.js\""></script>\n+<body>\n+ <script>\n+  var other_origin = get_host_info().UNAUTHENTICATED_ORIGIN + \""wasm_streaming/resources/blank.html\"";\n+  promise_test(() => {\n+    return new Promise((resolve, reject) => {\n+      frame = document.body.appendChild(document.createElement(\""iframe\""));\n+      frame.src = other_origin;\n+      frame.onload = () => {\n+        var wnd = frame.contentWindow;\n+        var promise = WebAssembly.compileStreaming.call(wnd);\n+        var objConstructor = promise.__proto__.__proto__.constructor;\n+        var promiseConstructor = Promise.__proto__.__proto__.constructor;\n+        promise.catch(e => {\n+          assert_true(e instanceof TypeError);\n+          if (objConstructor === promiseConstructor) {\n+            resolve();\n+          } else {\n+            reject();\n+          };\n+       });\n+     }\n+    });\n+  }, \""wasm compileStreaming does not leak foreign contexts\"");\n+\n+    promise_test(() => {\n+    return new Promise((resolve, reject) => {\n+      frame = document.body.appendChild(document.createElement(\""iframe\""));\n+      frame.src = other_origin;\n+      frame.onload = () => {\n+        var wnd = frame.contentWindow;\n+        var promise = WebAssembly.instantiateStreaming.call(wnd);\n+        var objConstructor = promise.__proto__.__proto__.constructor;\n+        var promiseConstructor = Promise.__proto__.__proto__.constructor;\n+        promise.catch(e => {\n+          assert_true(e instanceof TypeError);\n+          if (objConstructor === promiseConstructor) {\n+            resolve();\n+          } else {\n+            reject();\n+          };\n+       });\n+     }\n+    });\n+  }, \""wasm instantiateStreaming does not leak foreign contexts\"");\n+\n+</script>\n+</body>""}<_**next**_>{""sha"": ""a57fa980b31c9c37dfb269aa1a5ef84efaf61317"", ""filename"": ""third_party/WebKit/Source/bindings/modules/v8/wasm/WasmResponseExtensions.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c5a59182a8406f67333c283a31f257714f082b7d/third_party/WebKit/Source/bindings/modules/v8/wasm/WasmResponseExtensions.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c5a59182a8406f67333c283a31f257714f082b7d/third_party/WebKit/Source/bindings/modules/v8/wasm/WasmResponseExtensions.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/modules/v8/wasm/WasmResponseExtensions.cpp?ref=c5a59182a8406f67333c283a31f257714f082b7d"", ""patch"": ""@@ -129,7 +129,7 @@ void CompileFromResponseCallback(\n                                  \""WebAssembly\"", \""compile\"");\n   ExceptionToRejectPromiseScope reject_promise_scope(args, exception_state);\n \n-  ScriptState* script_state = ScriptState::ForRelevantRealm(args);\n+  ScriptState* script_state = ScriptState::ForCurrentRealm(args);\n   if (!ExecutionContext::From(script_state)) {\n     V8SetReturnValue(args, ScriptPromise().V8Value());\n     return;\n@@ -142,7 +142,7 @@ void CompileFromResponseCallback(\n         ScriptPromise::Reject(\n             script_state, V8ThrowException::CreateTypeError(\n                               script_state->GetIsolate(),\n-                              \""An argument must be provided, which must be a\""\n+                              \""An argument must be provided, which must be a \""\n                               \""Response or Promise<Response> object\""))\n             .V8Value());\n     return;\n@@ -189,7 +189,7 @@ void CompileFromResponseCallback(\n // See https://crbug.com/708238 for tracking avoiding the hand-generated code.\n void WasmCompileStreamingImpl(const v8::FunctionCallbackInfo<v8::Value>& args) {\n   v8::Isolate* isolate = args.GetIsolate();\n-  ScriptState* script_state = ScriptState::ForRelevantRealm(args);\n+  ScriptState* script_state = ScriptState::ForCurrentRealm(args);\n \n   v8::Local<v8::Function> compile_callback =\n       v8::Function::New(isolate, CompileFromResponseCallback);""}","void CompileFromResponseCallback(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  ExceptionState exception_state(args.GetIsolate(),
                                 ExceptionState::kExecutionContext,
                                  ""WebAssembly"", ""compile"");
   ExceptionToRejectPromiseScope reject_promise_scope(args, exception_state);
 
  ScriptState* script_state = ScriptState::ForCurrentRealm(args);
   if (!ExecutionContext::From(script_state)) {
     V8SetReturnValue(args, ScriptPromise().V8Value());
     return;
  }

  if (args.Length() < 1 || !args[0]->IsObject() ||
      !V8Response::hasInstance(args[0], args.GetIsolate())) {
    V8SetReturnValue(
        args,
         ScriptPromise::Reject(
             script_state, V8ThrowException::CreateTypeError(
                               script_state->GetIsolate(),
                              ""An argument must be provided, which must be a ""
                               ""Response or Promise<Response> object""))
             .V8Value());
     return;
  }

  Response* response = V8Response::ToImpl(v8::Local<v8::Object>::Cast(args[0]));
  if (response->MimeType() != ""application/wasm"") {
    V8SetReturnValue(
        args,
        ScriptPromise::Reject(
            script_state,
            V8ThrowException::CreateTypeError(
                script_state->GetIsolate(),
                ""Incorrect response MIME type. Expected 'application/wasm'.""))
            .V8Value());
    return;
  }
  v8::Local<v8::Value> promise;
  if (response->IsBodyLocked() || response->bodyUsed()) {
    promise = ScriptPromise::Reject(script_state,
                                    V8ThrowException::CreateTypeError(
                                        script_state->GetIsolate(),
                                        ""Cannot compile WebAssembly.Module ""
                                        ""from an already read Response""))
                  .V8Value();
  } else {
    if (response->BodyBuffer()) {
      FetchDataLoaderAsWasmModule* loader =
          new FetchDataLoaderAsWasmModule(script_state);

      promise = loader->GetPromise();
      response->BodyBuffer()->StartLoading(loader, new WasmDataLoaderClient());
    } else {
      promise = ScriptPromise::Reject(script_state,
                                      V8ThrowException::CreateTypeError(
                                          script_state->GetIsolate(),
                                          ""Response object has a null body.""))
                    .V8Value();
    }
  }
  V8SetReturnValue(args, promise);
}
","void CompileFromResponseCallback(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  ExceptionState exception_state(args.GetIsolate(),
                                 ExceptionState::kExecutionContext,
                                  ""WebAssembly"", ""compile"");
   ExceptionToRejectPromiseScope reject_promise_scope(args, exception_state);
 
  ScriptState* script_state = ScriptState::ForRelevantRealm(args);
   if (!ExecutionContext::From(script_state)) {
     V8SetReturnValue(args, ScriptPromise().V8Value());
     return;
  }

  if (args.Length() < 1 || !args[0]->IsObject() ||
      !V8Response::hasInstance(args[0], args.GetIsolate())) {
    V8SetReturnValue(
        args,
         ScriptPromise::Reject(
             script_state, V8ThrowException::CreateTypeError(
                               script_state->GetIsolate(),
                              ""An argument must be provided, which must be a""
                               ""Response or Promise<Response> object""))
             .V8Value());
     return;
  }

  Response* response = V8Response::ToImpl(v8::Local<v8::Object>::Cast(args[0]));
  if (response->MimeType() != ""application/wasm"") {
    V8SetReturnValue(
        args,
        ScriptPromise::Reject(
            script_state,
            V8ThrowException::CreateTypeError(
                script_state->GetIsolate(),
                ""Incorrect response MIME type. Expected 'application/wasm'.""))
            .V8Value());
    return;
  }
  v8::Local<v8::Value> promise;
  if (response->IsBodyLocked() || response->bodyUsed()) {
    promise = ScriptPromise::Reject(script_state,
                                    V8ThrowException::CreateTypeError(
                                        script_state->GetIsolate(),
                                        ""Cannot compile WebAssembly.Module ""
                                        ""from an already read Response""))
                  .V8Value();
  } else {
    if (response->BodyBuffer()) {
      FetchDataLoaderAsWasmModule* loader =
          new FetchDataLoaderAsWasmModule(script_state);

      promise = loader->GetPromise();
      response->BodyBuffer()->StartLoading(loader, new WasmDataLoaderClient());
    } else {
      promise = ScriptPromise::Reject(script_state,
                                      V8ThrowException::CreateTypeError(
                                          script_state->GetIsolate(),
                                          ""Response object has a null body.""))
                    .V8Value();
    }
  }
  V8SetReturnValue(args, promise);
}
",C,"  ScriptState* script_state = ScriptState::ForCurrentRealm(args);
                              ""An argument must be provided, which must be a ""
","  ScriptState* script_state = ScriptState::ForRelevantRealm(args);
                              ""An argument must be provided, which must be a""
",,"@@ -129,7 +129,7 @@ void CompileFromResponseCallback(
                                  ""WebAssembly"", ""compile"");
   ExceptionToRejectPromiseScope reject_promise_scope(args, exception_state);
 
-  ScriptState* script_state = ScriptState::ForRelevantRealm(args);
+  ScriptState* script_state = ScriptState::ForCurrentRealm(args);
   if (!ExecutionContext::From(script_state)) {
     V8SetReturnValue(args, ScriptPromise().V8Value());
     return;
@@ -142,7 +142,7 @@ void CompileFromResponseCallback(
         ScriptPromise::Reject(
             script_state, V8ThrowException::CreateTypeError(
                               script_state->GetIsolate(),
-                              ""An argument must be provided, which must be a""
+                              ""An argument must be provided, which must be a ""
                               ""Response or Promise<Response> object""))
             .V8Value());
     return;
@@ -189,7 +189,7 @@ void CompileFromResponseCallback(
 // See https://crbug.com/708238 for tracking avoiding the hand-generated code.
 void WasmCompileStreamingImpl(const v8::FunctionCallbackInfo<v8::Value>& args) {
   v8::Isolate* isolate = args.GetIsolate();
-  ScriptState* script_state = ScriptState::ForRelevantRealm(args);
+  ScriptState* script_state = ScriptState::ForCurrentRealm(args);
 
   v8::Local<v8::Function> compile_callback =
       v8::Function::New(isolate, CompileFromResponseCallback);",Chrome,c5a59182a8406f67333c283a31f257714f082b7d,935287a983dccb4a60e1729cac7a47fc7b85425f,1,"void CompileFromResponseCallback(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  ExceptionState exception_state(args.GetIsolate(),
                                 ExceptionState::kExecutionContext,
                                  ""WebAssembly"", ""compile"");
   ExceptionToRejectPromiseScope reject_promise_scope(args, exception_state);
 
//flaw_line_below:
  ScriptState* script_state = ScriptState::ForRelevantRealm(args);
//fix_flaw_line_below:
//  ScriptState* script_state = ScriptState::ForCurrentRealm(args);
   if (!ExecutionContext::From(script_state)) {
     V8SetReturnValue(args, ScriptPromise().V8Value());
     return;
  }

  if (args.Length() < 1 || !args[0]->IsObject() ||
      !V8Response::hasInstance(args[0], args.GetIsolate())) {
    V8SetReturnValue(
        args,
         ScriptPromise::Reject(
             script_state, V8ThrowException::CreateTypeError(
                               script_state->GetIsolate(),
//flaw_line_below:
                              ""An argument must be provided, which must be a""
//fix_flaw_line_below:
//                              ""An argument must be provided, which must be a ""
                               ""Response or Promise<Response> object""))
             .V8Value());
     return;
  }

  Response* response = V8Response::ToImpl(v8::Local<v8::Object>::Cast(args[0]));
  if (response->MimeType() != ""application/wasm"") {
    V8SetReturnValue(
        args,
        ScriptPromise::Reject(
            script_state,
            V8ThrowException::CreateTypeError(
                script_state->GetIsolate(),
                ""Incorrect response MIME type. Expected 'application/wasm'.""))
            .V8Value());
    return;
  }
  v8::Local<v8::Value> promise;
  if (response->IsBodyLocked() || response->bodyUsed()) {
    promise = ScriptPromise::Reject(script_state,
                                    V8ThrowException::CreateTypeError(
                                        script_state->GetIsolate(),
                                        ""Cannot compile WebAssembly.Module ""
                                        ""from an already read Response""))
                  .V8Value();
  } else {
    if (response->BodyBuffer()) {
      FetchDataLoaderAsWasmModule* loader =
          new FetchDataLoaderAsWasmModule(script_state);

      promise = loader->GetPromise();
      response->BodyBuffer()->StartLoading(loader, new WasmDataLoaderClient());
    } else {
      promise = ScriptPromise::Reject(script_state,
                                      V8ThrowException::CreateTypeError(
                                          script_state->GetIsolate(),
                                          ""Response object has a null body.""))
                    .V8Value();
    }
  }
  V8SetReturnValue(args, promise);
}
"
9180,186916,,Remote,Not required,,CVE-2017-15429,https://www.cvedetails.com/cve/CVE-2017-15429/,CWE-79,Medium,,Partial,,2018-08-28,4.3,Inappropriate implementation in V8 WebAssembly JS bindings in Google Chrome prior to 63.0.3239.108 allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via a crafted HTML page.,2018-11-07,XSS ,1,https://github.com/chromium/chromium/commit/c5a59182a8406f67333c283a31f257714f082b7d,c5a59182a8406f67333c283a31f257714f082b7d,"[wasm] Use correct bindings APIs

Use ScriptState::ForCurrentRealm in static methods, instead of
ForRelevantRealm().

Bug: chromium:788453
Change-Id: I63bd25e3f5a4e8d7cbaff945da8df0d71aa65527
Reviewed-on: https://chromium-review.googlesource.com/795096
Commit-Queue: Mircea Trofin <mtrofin@chromium.org>
Reviewed-by: Yuki Shiino <yukishiino@chromium.org>
Reviewed-by: Kentaro Hara <haraken@chromium.org>
Cr-Commit-Position: refs/heads/master@{#520174}",1,third_party/WebKit/Source/bindings/modules/v8/wasm/WasmResponseExtensions.cpp,"{""sha"": ""0e76edd65b7baf5316fc9d0c4da59a3502e4c27a"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/wasm_streaming/resources/blank.html"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/c5a59182a8406f67333c283a31f257714f082b7d/third_party/WebKit/LayoutTests/http/tests/wasm_streaming/resources/blank.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c5a59182a8406f67333c283a31f257714f082b7d/third_party/WebKit/LayoutTests/http/tests/wasm_streaming/resources/blank.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/wasm_streaming/resources/blank.html?ref=c5a59182a8406f67333c283a31f257714f082b7d"", ""patch"": ""@@ -0,0 +1 @@\n+<!DOCTYPE html>""}<_**next**_>{""sha"": ""0e3e69afa1b2b28c3b8ae4844ddd102917ed8717"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/wasm_streaming/wasm_streaming_xss.https.html"", ""status"": ""added"", ""additions"": 51, ""deletions"": 0, ""changes"": 51, ""blob_url"": ""https://github.com/chromium/chromium/blob/c5a59182a8406f67333c283a31f257714f082b7d/third_party/WebKit/LayoutTests/http/tests/wasm_streaming/wasm_streaming_xss.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c5a59182a8406f67333c283a31f257714f082b7d/third_party/WebKit/LayoutTests/http/tests/wasm_streaming/wasm_streaming_xss.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/wasm_streaming/wasm_streaming_xss.https.html?ref=c5a59182a8406f67333c283a31f257714f082b7d"", ""patch"": ""@@ -0,0 +1,51 @@\n+<!DOCTYPE html>\n+<script src=\""../../../resources/testharness.js\""></script>\n+<script src=\""../../../resources/testharnessreport.js\""></script>\n+<script src=\""../resources/get-host-info.js\""></script>\n+<body>\n+ <script>\n+  var other_origin = get_host_info().UNAUTHENTICATED_ORIGIN + \""wasm_streaming/resources/blank.html\"";\n+  promise_test(() => {\n+    return new Promise((resolve, reject) => {\n+      frame = document.body.appendChild(document.createElement(\""iframe\""));\n+      frame.src = other_origin;\n+      frame.onload = () => {\n+        var wnd = frame.contentWindow;\n+        var promise = WebAssembly.compileStreaming.call(wnd);\n+        var objConstructor = promise.__proto__.__proto__.constructor;\n+        var promiseConstructor = Promise.__proto__.__proto__.constructor;\n+        promise.catch(e => {\n+          assert_true(e instanceof TypeError);\n+          if (objConstructor === promiseConstructor) {\n+            resolve();\n+          } else {\n+            reject();\n+          };\n+       });\n+     }\n+    });\n+  }, \""wasm compileStreaming does not leak foreign contexts\"");\n+\n+    promise_test(() => {\n+    return new Promise((resolve, reject) => {\n+      frame = document.body.appendChild(document.createElement(\""iframe\""));\n+      frame.src = other_origin;\n+      frame.onload = () => {\n+        var wnd = frame.contentWindow;\n+        var promise = WebAssembly.instantiateStreaming.call(wnd);\n+        var objConstructor = promise.__proto__.__proto__.constructor;\n+        var promiseConstructor = Promise.__proto__.__proto__.constructor;\n+        promise.catch(e => {\n+          assert_true(e instanceof TypeError);\n+          if (objConstructor === promiseConstructor) {\n+            resolve();\n+          } else {\n+            reject();\n+          };\n+       });\n+     }\n+    });\n+  }, \""wasm instantiateStreaming does not leak foreign contexts\"");\n+\n+</script>\n+</body>""}<_**next**_>{""sha"": ""a57fa980b31c9c37dfb269aa1a5ef84efaf61317"", ""filename"": ""third_party/WebKit/Source/bindings/modules/v8/wasm/WasmResponseExtensions.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c5a59182a8406f67333c283a31f257714f082b7d/third_party/WebKit/Source/bindings/modules/v8/wasm/WasmResponseExtensions.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c5a59182a8406f67333c283a31f257714f082b7d/third_party/WebKit/Source/bindings/modules/v8/wasm/WasmResponseExtensions.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/modules/v8/wasm/WasmResponseExtensions.cpp?ref=c5a59182a8406f67333c283a31f257714f082b7d"", ""patch"": ""@@ -129,7 +129,7 @@ void CompileFromResponseCallback(\n                                  \""WebAssembly\"", \""compile\"");\n   ExceptionToRejectPromiseScope reject_promise_scope(args, exception_state);\n \n-  ScriptState* script_state = ScriptState::ForRelevantRealm(args);\n+  ScriptState* script_state = ScriptState::ForCurrentRealm(args);\n   if (!ExecutionContext::From(script_state)) {\n     V8SetReturnValue(args, ScriptPromise().V8Value());\n     return;\n@@ -142,7 +142,7 @@ void CompileFromResponseCallback(\n         ScriptPromise::Reject(\n             script_state, V8ThrowException::CreateTypeError(\n                               script_state->GetIsolate(),\n-                              \""An argument must be provided, which must be a\""\n+                              \""An argument must be provided, which must be a \""\n                               \""Response or Promise<Response> object\""))\n             .V8Value());\n     return;\n@@ -189,7 +189,7 @@ void CompileFromResponseCallback(\n // See https://crbug.com/708238 for tracking avoiding the hand-generated code.\n void WasmCompileStreamingImpl(const v8::FunctionCallbackInfo<v8::Value>& args) {\n   v8::Isolate* isolate = args.GetIsolate();\n-  ScriptState* script_state = ScriptState::ForRelevantRealm(args);\n+  ScriptState* script_state = ScriptState::ForCurrentRealm(args);\n \n   v8::Local<v8::Function> compile_callback =\n       v8::Function::New(isolate, CompileFromResponseCallback);""}"," void WasmCompileStreamingImpl(const v8::FunctionCallbackInfo<v8::Value>& args) {
   v8::Isolate* isolate = args.GetIsolate();
  ScriptState* script_state = ScriptState::ForCurrentRealm(args);
 
   v8::Local<v8::Function> compile_callback =
       v8::Function::New(isolate, CompileFromResponseCallback);


  V8SetReturnValue(args, ScriptPromise::Cast(script_state, args[0])
                             .Then(compile_callback)
                             .V8Value());

}
"," void WasmCompileStreamingImpl(const v8::FunctionCallbackInfo<v8::Value>& args) {
   v8::Isolate* isolate = args.GetIsolate();
  ScriptState* script_state = ScriptState::ForRelevantRealm(args);
 
   v8::Local<v8::Function> compile_callback =
       v8::Function::New(isolate, CompileFromResponseCallback);


  V8SetReturnValue(args, ScriptPromise::Cast(script_state, args[0])
                             .Then(compile_callback)
                             .V8Value());

}
",C,"  ScriptState* script_state = ScriptState::ForCurrentRealm(args);
","  ScriptState* script_state = ScriptState::ForRelevantRealm(args);
",,"@@ -129,7 +129,7 @@ void CompileFromResponseCallback(
                                  ""WebAssembly"", ""compile"");
   ExceptionToRejectPromiseScope reject_promise_scope(args, exception_state);
 
-  ScriptState* script_state = ScriptState::ForRelevantRealm(args);
+  ScriptState* script_state = ScriptState::ForCurrentRealm(args);
   if (!ExecutionContext::From(script_state)) {
     V8SetReturnValue(args, ScriptPromise().V8Value());
     return;
@@ -142,7 +142,7 @@ void CompileFromResponseCallback(
         ScriptPromise::Reject(
             script_state, V8ThrowException::CreateTypeError(
                               script_state->GetIsolate(),
-                              ""An argument must be provided, which must be a""
+                              ""An argument must be provided, which must be a ""
                               ""Response or Promise<Response> object""))
             .V8Value());
     return;
@@ -189,7 +189,7 @@ void CompileFromResponseCallback(
 // See https://crbug.com/708238 for tracking avoiding the hand-generated code.
 void WasmCompileStreamingImpl(const v8::FunctionCallbackInfo<v8::Value>& args) {
   v8::Isolate* isolate = args.GetIsolate();
-  ScriptState* script_state = ScriptState::ForRelevantRealm(args);
+  ScriptState* script_state = ScriptState::ForCurrentRealm(args);
 
   v8::Local<v8::Function> compile_callback =
       v8::Function::New(isolate, CompileFromResponseCallback);",Chrome,c5a59182a8406f67333c283a31f257714f082b7d,935287a983dccb4a60e1729cac7a47fc7b85425f,1," void WasmCompileStreamingImpl(const v8::FunctionCallbackInfo<v8::Value>& args) {
   v8::Isolate* isolate = args.GetIsolate();
//flaw_line_below:
  ScriptState* script_state = ScriptState::ForRelevantRealm(args);
//fix_flaw_line_below:
//  ScriptState* script_state = ScriptState::ForCurrentRealm(args);
 
   v8::Local<v8::Function> compile_callback =
       v8::Function::New(isolate, CompileFromResponseCallback);

  // treat either case of parameter as
  // Promise.resolve(parameter)
  // as per https://www.w3.org/2001/tag/doc/promises-guide#resolve-arguments

  // Ending with:
  //    return Promise.resolve(parameter).then(compileCallback);
  V8SetReturnValue(args, ScriptPromise::Cast(script_state, args[0])
                             .Then(compile_callback)
                             .V8Value());

}
"
9366,187102,,Remote,Not required,,CVE-2019-5778,https://www.cvedetails.com/cve/CVE-2019-5778/,CWE-79,Medium,,Partial,,2019-02-19,4.3,A missing case for handling special schemes in permission request checks in Extensions in Google Chrome prior to 72.0.3626.81 allowed an attacker who convinced a user to install a malicious extension to bypass extension permission checks for privileged pages via a crafted Chrome Extension.,2019-04-18,XSS Bypass ,28,https://github.com/chromium/chromium/commit/e13eb21898c7eba584f680e3d17ca1b9e28bc505,e13eb21898c7eba584f680e3d17ca1b9e28bc505,"[Extensions] Have URLPattern::Contains() properly check schemes

Have URLPattern::Contains() properly check the schemes of the patterns
when evaluating if one pattern contains another. This is important in
order to prevent extensions from requesting chrome:-scheme permissions
via the permissions API when <all_urls> is specified as an optional
permission.

Bug: 859600,918470

Change-Id: If04d945ad0c939e84a80d83502c0f84b6ef0923d
Reviewed-on: https://chromium-review.googlesource.com/c/1396561
Commit-Queue: Devlin <rdevlin.cronin@chromium.org>
Reviewed-by: Karan Bhatia <karandeepb@chromium.org>
Cr-Commit-Position: refs/heads/master@{#621410}",5,chrome/browser/extensions/api/permissions/permissions_api_helpers.cc,"{""sha"": ""4fb41c7426cd25c4346fab63aa8ff6a0526e1cbf"", ""filename"": ""chrome/browser/extensions/api/permissions/permissions_api_helpers.cc"", ""status"": ""modified"", ""additions"": 29, ""deletions"": 5, ""changes"": 34, ""blob_url"": ""https://github.com/chromium/chromium/blob/e13eb21898c7eba584f680e3d17ca1b9e28bc505/chrome/browser/extensions/api/permissions/permissions_api_helpers.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e13eb21898c7eba584f680e3d17ca1b9e28bc505/chrome/browser/extensions/api/permissions/permissions_api_helpers.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/api/permissions/permissions_api_helpers.cc?ref=e13eb21898c7eba584f680e3d17ca1b9e28bc505"", ""patch"": ""@@ -10,6 +10,7 @@\n #include \""base/json/json_writer.h\""\n #include \""base/values.h\""\n #include \""chrome/common/extensions/api/permissions.h\""\n+#include \""content/public/common/url_constants.h\""\n #include \""extensions/common/error_utils.h\""\n #include \""extensions/common/extension.h\""\n #include \""extensions/common/permissions/permission_set.h\""\n@@ -149,6 +150,25 @@ bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,\n     explicit_schemes &= ~URLPattern::SCHEME_FILE;\n   }\n \n+  auto filter_chrome_scheme = [](URLPattern* pattern) {\n+    // We disallow the chrome:-scheme unless the pattern is explicitly\n+    // \""chrome://...\"" - that is, <all_urls> should not match the chrome:-scheme.\n+    // Patterns which explicitly specify the chrome:-scheme are safe, since\n+    // manifest parsing won't allow them unless the kExtensionsOnChromeURLs\n+    // switch is enabled.\n+    // Note that we don't check PermissionsData::AllUrlsIncludesChromeUrls()\n+    // here, since that's only needed for Chromevox (which doesn't use optional\n+    // permissions).\n+    if (pattern->scheme() != content::kChromeUIScheme) {\n+      // NOTE: We use pattern->valid_schemes() here (instead of\n+      // |user_script_schemes| or |explicit_schemes|) because\n+      // URLPattern::Parse() can mutate the valid schemes for a pattern, and we\n+      // don't want to override those changes.\n+      pattern->SetValidSchemes(pattern->valid_schemes() &\n+                               ~URLPattern::SCHEME_CHROMEUI);\n+    }\n+  };\n+\n   for (const auto& origin_str : origins_input) {\n     URLPattern explicit_origin(explicit_schemes);\n     URLPattern::ParseResult parse_result = explicit_origin.Parse(origin_str);\n@@ -159,6 +179,8 @@ bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,\n       return false;\n     }\n \n+    filter_chrome_scheme(&explicit_origin);\n+\n     bool used_origin = false;\n     if (required_permissions.explicit_hosts().ContainsPattern(\n             explicit_origin)) {\n@@ -172,11 +194,13 @@ bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,\n \n     URLPattern scriptable_origin(user_script_schemes);\n     if (scriptable_origin.Parse(origin_str) ==\n-            URLPattern::ParseResult::kSuccess &&\n-        required_permissions.scriptable_hosts().ContainsPattern(\n-            scriptable_origin)) {\n-      used_origin = true;\n-      result->required_scriptable_hosts.AddPattern(scriptable_origin);\n+        URLPattern::ParseResult::kSuccess) {\n+      filter_chrome_scheme(&scriptable_origin);\n+      if (required_permissions.scriptable_hosts().ContainsPattern(\n+              scriptable_origin)) {\n+        used_origin = true;\n+        result->required_scriptable_hosts.AddPattern(scriptable_origin);\n+      }\n     }\n \n     if (!used_origin)""}<_**next**_>{""sha"": ""8f7cd522c721d6bc34453e41f2f4ba229d332c6b"", ""filename"": ""chrome/browser/extensions/api/permissions/permissions_api_helpers_unittest.cc"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/e13eb21898c7eba584f680e3d17ca1b9e28bc505/chrome/browser/extensions/api/permissions/permissions_api_helpers_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e13eb21898c7eba584f680e3d17ca1b9e28bc505/chrome/browser/extensions/api/permissions/permissions_api_helpers_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/api/permissions/permissions_api_helpers_unittest.cc?ref=e13eb21898c7eba584f680e3d17ca1b9e28bc505"", ""patch"": ""@@ -330,4 +330,28 @@ TEST(ExtensionPermissionsAPIHelpers, Unpack_UnsupportedAPIPermission) {\n       APIPermission::kWallpaper));\n }\n \n+// Tests that unpacking works correctly with wildcard schemes (which are\n+// interesting, because they only match http | https, and not all schemes).\n+TEST(ExtensionPermissionsAPIHelpers, Unpack_WildcardSchemes) {\n+  constexpr char kWildcardSchemePattern[] = \""*://*/*\"";\n+\n+  PermissionSet optional_permissions(\n+      APIPermissionSet(), ManifestPermissionSet(),\n+      URLPatternSet({URLPattern(Extension::kValidHostPermissionSchemes,\n+                                kWildcardSchemePattern)}),\n+      URLPatternSet());\n+\n+  Permissions permissions_object;\n+  permissions_object.origins = std::make_unique<std::vector<std::string>>(\n+      std::vector<std::string>({kWildcardSchemePattern}));\n+\n+  std::string error;\n+  std::unique_ptr<UnpackPermissionSetResult> unpack_result =\n+      UnpackPermissionSet(permissions_object, PermissionSet(),\n+                          optional_permissions, true, &error);\n+  ASSERT_TRUE(unpack_result) << error;\n+  EXPECT_THAT(GetPatternsAsStrings(unpack_result->optional_explicit_hosts),\n+              testing::ElementsAre(kWildcardSchemePattern));\n+}\n+\n }  // namespace extensions""}<_**next**_>{""sha"": ""bb62775351b3c7bba44caeba71c9870b6abc64af"", ""filename"": ""chrome/browser/extensions/api/permissions/permissions_api_unittest.cc"", ""status"": ""modified"", ""additions"": 53, ""deletions"": 1, ""changes"": 54, ""blob_url"": ""https://github.com/chromium/chromium/blob/e13eb21898c7eba584f680e3d17ca1b9e28bc505/chrome/browser/extensions/api/permissions/permissions_api_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e13eb21898c7eba584f680e3d17ca1b9e28bc505/chrome/browser/extensions/api/permissions/permissions_api_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/api/permissions/permissions_api_unittest.cc?ref=e13eb21898c7eba584f680e3d17ca1b9e28bc505"", ""patch"": ""@@ -19,13 +19,17 @@\n #include \""components/crx_file/id_util.h\""\n #include \""extensions/common/extension_builder.h\""\n #include \""extensions/common/extension_features.h\""\n+#include \""extensions/common/manifest_handlers/permissions_parser.h\""\n #include \""testing/gmock/include/gmock/gmock.h\""\n #include \""testing/gtest/include/gtest/gtest.h\""\n \n namespace extensions {\n \n namespace {\n \n+constexpr char kNotInManifestError[] =\n+    \""Only permissions specified in the manifest may be requested.\"";\n+\n using permissions_test_util::GetPatternsAsStrings;\n \n scoped_refptr<const Extension> CreateExtensionWithPermissions(\n@@ -556,7 +560,7 @@ TEST_F(PermissionsAPIUnitTest, RequestingPermissionsNotSpecifiedInManifest) {\n   auto function = base::MakeRefCounted<PermissionsRequestFunction>();\n   function->set_user_gesture(true);\n   function->set_extension(extension.get());\n-  EXPECT_EQ(\""Only permissions specified in the manifest may be requested.\"",\n+  EXPECT_EQ(kNotInManifestError,\n             extension_function_test_utils::RunFunctionAndReturnError(\n                 function.get(),\n                 R\""([{\n@@ -617,4 +621,52 @@ TEST_F(PermissionsAPIUnitTest, RequestingAlreadyGrantedWithheldPermissions) {\n           kGoogleCom));\n }\n \n+// Test that requesting chrome:-scheme URLs is disallowed in the permissions\n+// API.\n+TEST_F(PermissionsAPIUnitTest, RequestingChromeURLs) {\n+  scoped_refptr<const Extension> extension =\n+      ExtensionBuilder(\""extension\"")\n+          .SetManifestKey(\""optional_permissions\"",\n+                          ListBuilder().Append(\""<all_urls>\"").Build())\n+          .Build();\n+  AddExtensionAndGrantPermissions(*extension);\n+\n+  const GURL chrome_url(\""chrome://settings\"");\n+\n+  // By default, the extension should not have access to chrome://settings.\n+  EXPECT_FALSE(extension->permissions_data()->HasHostPermission(chrome_url));\n+  // The optional permissions should also omit the chrome:-scheme for the\n+  // <all_urls> pattern.\n+  EXPECT_FALSE(PermissionsParser::GetOptionalPermissions(extension.get())\n+                   .explicit_hosts()\n+                   .MatchesURL(chrome_url));\n+\n+  {\n+    // Trying to request \""chrome://settings/*\"" should fail, since it's not in\n+    // the optional permissions.\n+    auto function = base::MakeRefCounted<PermissionsRequestFunction>();\n+    function->set_user_gesture(true);\n+    function->set_extension(extension.get());\n+    std::string error =\n+        extension_function_test_utils::RunFunctionAndReturnError(\n+            function.get(), R\""([{\""origins\"": [\""chrome://settings/*\""]}])\"",\n+            browser(), api_test_utils::NONE);\n+    EXPECT_EQ(kNotInManifestError, error);\n+  }\n+  // chrome://settings should still be restricted.\n+  EXPECT_FALSE(extension->permissions_data()->HasHostPermission(chrome_url));\n+\n+  // The extension can request <all_urls>, but it should not grant access to the\n+  // chrome:-scheme.\n+  std::unique_ptr<const PermissionSet> prompted_permissions;\n+  RunRequestFunction(*extension, browser(), R\""([{\""origins\"": [\""<all_urls>\""]}])\"",\n+                     &prompted_permissions);\n+  EXPECT_THAT(GetPatternsAsStrings(prompted_permissions->effective_hosts()),\n+              testing::UnorderedElementsAre(\""<all_urls>\""));\n+\n+  EXPECT_FALSE(extension->permissions_data()->HasHostPermission(chrome_url));\n+  EXPECT_TRUE(extension->permissions_data()->HasHostPermission(\n+      GURL(\""https://example.com\"")));\n+}\n+\n }  // namespace extensions""}<_**next**_>{""sha"": ""1723926a52e7d0431e87c4da36d64f7e2bb88ddf"", ""filename"": ""chrome/browser/extensions/permissions_updater_unittest.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/e13eb21898c7eba584f680e3d17ca1b9e28bc505/chrome/browser/extensions/permissions_updater_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e13eb21898c7eba584f680e3d17ca1b9e28bc505/chrome/browser/extensions/permissions_updater_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/permissions_updater_unittest.cc?ref=e13eb21898c7eba584f680e3d17ca1b9e28bc505"", ""patch"": ""@@ -703,8 +703,10 @@ TEST_F(PermissionsUpdaterTest, ChromeFaviconIsNotARevokableHost) {\n         ExtensionBuilder(\""all urls extension\"")\n             .AddPermission(\""<all_urls>\"")\n             .Build();\n-    URLPattern all_urls_pattern(Extension::kValidHostPermissionSchemes,\n-                                \""<all_urls>\"");\n+    URLPattern all_urls_pattern(\n+        Extension::kValidHostPermissionSchemes &\n+            ~(URLPattern::SCHEME_CHROMEUI | URLPattern::SCHEME_FILE),\n+        \""<all_urls>\"");\n     PermissionsUpdater updater(profile());\n     updater.InitializePermissions(extension.get());\n \n@@ -720,11 +722,8 @@ TEST_F(PermissionsUpdaterTest, ChromeFaviconIsNotARevokableHost) {\n \n     std::unique_ptr<const PermissionSet> revokable_permissions =\n         updater.GetRevokablePermissions(extension.get());\n-    // TODO(https://crbug.com/859600): <all_urls> will report containing\n-    // chrome://favicon/, even though it shouldn't since the scheme doesn't\n-    // match.\n-    // EXPECT_FALSE(revokable_permissions->explicit_hosts().ContainsPattern(\n-    //     chrome_favicon_pattern));\n+    EXPECT_FALSE(revokable_permissions->explicit_hosts().ContainsPattern(\n+        chrome_favicon_pattern));\n     EXPECT_TRUE(revokable_permissions->explicit_hosts().ContainsPattern(\n         all_urls_pattern));\n ""}<_**next**_>{""sha"": ""e7d5cf1f8aa4cd35d2ce10f94640e40891c7cd19"", ""filename"": ""extensions/common/permissions/permissions_data.cc"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 4, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/e13eb21898c7eba584f680e3d17ca1b9e28bc505/extensions/common/permissions/permissions_data.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e13eb21898c7eba584f680e3d17ca1b9e28bc505/extensions/common/permissions/permissions_data.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/common/permissions/permissions_data.cc?ref=e13eb21898c7eba584f680e3d17ca1b9e28bc505"", ""patch"": ""@@ -387,10 +387,16 @@ bool PermissionsData::CanCaptureVisiblePage(\n     has_active_tab = tab_permissions &&\n                      tab_permissions->HasAPIPermission(APIPermission::kTab);\n \n-    const URLPattern all_urls(URLPattern::SCHEME_ALL,\n-                              URLPattern::kAllUrlsPattern);\n-    has_all_urls =\n-        active_permissions_unsafe_->explicit_hosts().ContainsPattern(all_urls);\n+    // Check if any of the host permissions match all urls. We don't use\n+    // URLPatternSet::ContainsPattern() here because a) the schemes may be\n+    // different and b) this is more efficient.\n+    for (const auto& pattern : active_permissions_unsafe_->explicit_hosts()) {\n+      if (pattern.match_all_urls()) {\n+        has_all_urls = true;\n+        break;\n+      }\n+    }\n+\n     has_page_capture = active_permissions_unsafe_->HasAPIPermission(\n         APIPermission::kPageCapture);\n   }""}<_**next**_>{""sha"": ""91e788b562993229421f4f7a17aa2678fa30617e"", ""filename"": ""extensions/common/url_pattern.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/e13eb21898c7eba584f680e3d17ca1b9e28bc505/extensions/common/url_pattern.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e13eb21898c7eba584f680e3d17ca1b9e28bc505/extensions/common/url_pattern.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/common/url_pattern.cc?ref=e13eb21898c7eba584f680e3d17ca1b9e28bc505"", ""patch"": ""@@ -352,6 +352,10 @@ URLPattern::ParseResult URLPattern::Parse(base::StringPiece pattern,\n }\n \n void URLPattern::SetValidSchemes(int valid_schemes) {\n+  // TODO(devlin): Should we check that valid_schemes agrees with |scheme_|\n+  // here? Otherwise, valid_schemes_ and schemes_ may stop agreeing with each\n+  // other (e.g., in the case of `*://*/*`, where the scheme should only be\n+  // http or https).\n   spec_.clear();\n   valid_schemes_ = valid_schemes;\n }\n@@ -433,6 +437,8 @@ bool URLPattern::MatchesURL(const GURL& test) const {\n     test_url = test.inner_url();\n   }\n \n+  // Ensure the scheme matches first, since <all_urls> may not match this URL if\n+  // the scheme is excluded.\n   if (!MatchesScheme(test_url->scheme_piece()))\n     return false;\n \n@@ -632,8 +638,14 @@ bool URLPattern::OverlapsWith(const URLPattern& other) const {\n }\n \n bool URLPattern::Contains(const URLPattern& other) const {\n-  if (match_all_urls())\n+  // Important: it's not enough to just check match_all_urls(); we also need to\n+  // make sure that the schemes in this pattern are a superset of those in\n+  // |other|.\n+  if (match_all_urls() &&\n+      (valid_schemes_ & other.valid_schemes_) == other.valid_schemes_) {\n     return true;\n+  }\n+\n   return MatchesAllSchemes(other.GetExplicitSchemes()) &&\n          MatchesHost(other.host()) &&\n          (!other.match_subdomains_ || match_subdomains_) &&""}<_**next**_>{""sha"": ""3bedc4326c02d1e9ef305dec2fd17cfb3c4b0970"", ""filename"": ""extensions/common/url_pattern_unittest.cc"", ""status"": ""modified"", ""additions"": 49, ""deletions"": 0, ""changes"": 49, ""blob_url"": ""https://github.com/chromium/chromium/blob/e13eb21898c7eba584f680e3d17ca1b9e28bc505/extensions/common/url_pattern_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e13eb21898c7eba584f680e3d17ca1b9e28bc505/extensions/common/url_pattern_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/common/url_pattern_unittest.cc?ref=e13eb21898c7eba584f680e3d17ca1b9e28bc505"", ""patch"": ""@@ -1250,4 +1250,53 @@ TEST(ExtensionURLPatternTest, ValidSchemeIntersection) {\n   }\n }\n \n+// Tests that <all_urls> patterns correctly check schemes when testing if one\n+// contains the other.\n+TEST(ExtensionURLPatternTest, ContainsSchemes) {\n+  const URLPattern http(URLPattern::SCHEME_HTTP, URLPattern::kAllUrlsPattern);\n+  const URLPattern chrome(URLPattern::SCHEME_CHROMEUI,\n+                          URLPattern::kAllUrlsPattern);\n+  const URLPattern http_and_https(\n+      URLPattern::SCHEME_HTTP | URLPattern::SCHEME_HTTPS,\n+      URLPattern::kAllUrlsPattern);\n+  const URLPattern http_https_and_chrome(URLPattern::SCHEME_HTTP |\n+                                             URLPattern::SCHEME_HTTPS |\n+                                             URLPattern::SCHEME_CHROMEUI,\n+                                         URLPattern::kAllUrlsPattern);\n+\n+  // A map between each URLPattern and the other patterns it should contain.\n+  const std::map<const URLPattern*, std::set<const URLPattern*>> contains_map =\n+      {\n+          {&http, {}},\n+          {&chrome, {}},\n+          {&http_and_https, {&http}},\n+          {&http_https_and_chrome, {&http, &http_and_https, &chrome}},\n+      };\n+\n+  const URLPattern* all_patterns[] = {&http, &chrome, &http_and_https,\n+                                      &http_https_and_chrome};\n+\n+  // Verify that each pattern contains exactly the expected patterns.\n+  for (const auto& entry : contains_map) {\n+    const URLPattern* pattern = entry.first;\n+    const std::set<const URLPattern*>& contains_patterns = entry.second;\n+    for (const URLPattern* other_pattern : all_patterns) {\n+      SCOPED_TRACE(base::StringPrintf(\""Checking if %d contains %d\"",\n+                                      pattern->valid_schemes(),\n+                                      other_pattern->valid_schemes()));\n+      bool expect_contains =\n+          // Patterns should always contain themselves.\n+          pattern == other_pattern || contains_patterns.count(other_pattern);\n+      EXPECT_EQ(expect_contains, pattern->Contains(*other_pattern));\n+    }\n+  }\n+\n+  // Fun edge case for bonus points: |http| doesn't contain all the valid\n+  // schemes of the other pattern, but does in practice (since the scheme is\n+  // restricted to http by the match pattern).\n+  EXPECT_TRUE(http.Contains(\n+      URLPattern(URLPattern::SCHEME_HTTP | URLPattern::SCHEME_HTTPS,\n+                 \""http://google.com/*\"")));\n+}\n+\n }  // namespace""}","bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,
                             const PermissionSet& required_permissions,
                             const PermissionSet& optional_permissions,
                             bool allow_file_access,
                             UnpackPermissionSetResult* result,
                             std::string* error) {
  int user_script_schemes = UserScript::ValidUserScriptSchemes();
  int explicit_schemes = Extension::kValidHostPermissionSchemes;
  if (!allow_file_access) {
    user_script_schemes &= ~URLPattern::SCHEME_FILE;
     explicit_schemes &= ~URLPattern::SCHEME_FILE;
   }
 
  auto filter_chrome_scheme = [](URLPattern* pattern) {
    // We disallow the chrome:-scheme unless the pattern is explicitly
    // ""chrome://..."" - that is, <all_urls> should not match the chrome:-scheme.
    // Patterns which explicitly specify the chrome:-scheme are safe, since
    // manifest parsing won't allow them unless the kExtensionsOnChromeURLs
    // switch is enabled.
    // Note that we don't check PermissionsData::AllUrlsIncludesChromeUrls()
    // here, since that's only needed for Chromevox (which doesn't use optional
    // permissions).
    if (pattern->scheme() != content::kChromeUIScheme) {
      // NOTE: We use pattern->valid_schemes() here (instead of
      // |user_script_schemes| or |explicit_schemes|) because
      // URLPattern::Parse() can mutate the valid schemes for a pattern, and we
      // don't want to override those changes.
      pattern->SetValidSchemes(pattern->valid_schemes() &
                               ~URLPattern::SCHEME_CHROMEUI);
    }
  };

   for (const auto& origin_str : origins_input) {
     URLPattern explicit_origin(explicit_schemes);
     URLPattern::ParseResult parse_result = explicit_origin.Parse(origin_str);
    if (URLPattern::ParseResult::kSuccess != parse_result) {
      *error = ErrorUtils::FormatErrorMessage(
          kInvalidOrigin, origin_str,
          URLPattern::GetParseResultString(parse_result));
       return false;
     }
 
    filter_chrome_scheme(&explicit_origin);

     bool used_origin = false;
     if (required_permissions.explicit_hosts().ContainsPattern(
             explicit_origin)) {
      used_origin = true;
      result->required_explicit_hosts.AddPattern(explicit_origin);
    } else if (optional_permissions.explicit_hosts().ContainsPattern(
                   explicit_origin)) {
      used_origin = true;
      result->optional_explicit_hosts.AddPattern(explicit_origin);
    }
 
     URLPattern scriptable_origin(user_script_schemes);
     if (scriptable_origin.Parse(origin_str) ==
        URLPattern::ParseResult::kSuccess) {
      filter_chrome_scheme(&scriptable_origin);
      if (required_permissions.scriptable_hosts().ContainsPattern(
              scriptable_origin)) {
        used_origin = true;
        result->required_scriptable_hosts.AddPattern(scriptable_origin);
      }
     }
 
     if (!used_origin)
      result->unlisted_hosts.AddPattern(explicit_origin);
  }

  return true;
}
","bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,
                             const PermissionSet& required_permissions,
                             const PermissionSet& optional_permissions,
                             bool allow_file_access,
                             UnpackPermissionSetResult* result,
                             std::string* error) {
  int user_script_schemes = UserScript::ValidUserScriptSchemes();
  int explicit_schemes = Extension::kValidHostPermissionSchemes;
  if (!allow_file_access) {
    user_script_schemes &= ~URLPattern::SCHEME_FILE;
     explicit_schemes &= ~URLPattern::SCHEME_FILE;
   }
 
   for (const auto& origin_str : origins_input) {
     URLPattern explicit_origin(explicit_schemes);
     URLPattern::ParseResult parse_result = explicit_origin.Parse(origin_str);
    if (URLPattern::ParseResult::kSuccess != parse_result) {
      *error = ErrorUtils::FormatErrorMessage(
          kInvalidOrigin, origin_str,
          URLPattern::GetParseResultString(parse_result));
       return false;
     }
 
     bool used_origin = false;
     if (required_permissions.explicit_hosts().ContainsPattern(
             explicit_origin)) {
      used_origin = true;
      result->required_explicit_hosts.AddPattern(explicit_origin);
    } else if (optional_permissions.explicit_hosts().ContainsPattern(
                   explicit_origin)) {
      used_origin = true;
      result->optional_explicit_hosts.AddPattern(explicit_origin);
    }
 
     URLPattern scriptable_origin(user_script_schemes);
     if (scriptable_origin.Parse(origin_str) ==
            URLPattern::ParseResult::kSuccess &&
        required_permissions.scriptable_hosts().ContainsPattern(
            scriptable_origin)) {
      used_origin = true;
      result->required_scriptable_hosts.AddPattern(scriptable_origin);
     }
 
     if (!used_origin)
      result->unlisted_hosts.AddPattern(explicit_origin);
  }

  return true;
}
",C,"  auto filter_chrome_scheme = [](URLPattern* pattern) {
    // We disallow the chrome:-scheme unless the pattern is explicitly
    // ""chrome://..."" - that is, <all_urls> should not match the chrome:-scheme.
    // Patterns which explicitly specify the chrome:-scheme are safe, since
    // manifest parsing won't allow them unless the kExtensionsOnChromeURLs
    // switch is enabled.
    // Note that we don't check PermissionsData::AllUrlsIncludesChromeUrls()
    // here, since that's only needed for Chromevox (which doesn't use optional
    // permissions).
    if (pattern->scheme() != content::kChromeUIScheme) {
      // NOTE: We use pattern->valid_schemes() here (instead of
      // |user_script_schemes| or |explicit_schemes|) because
      // URLPattern::Parse() can mutate the valid schemes for a pattern, and we
      // don't want to override those changes.
      pattern->SetValidSchemes(pattern->valid_schemes() &
                               ~URLPattern::SCHEME_CHROMEUI);
    }
  };

    filter_chrome_scheme(&explicit_origin);

        URLPattern::ParseResult::kSuccess) {
      filter_chrome_scheme(&scriptable_origin);
      if (required_permissions.scriptable_hosts().ContainsPattern(
              scriptable_origin)) {
        used_origin = true;
        result->required_scriptable_hosts.AddPattern(scriptable_origin);
      }
","            URLPattern::ParseResult::kSuccess &&
        required_permissions.scriptable_hosts().ContainsPattern(
            scriptable_origin)) {
      used_origin = true;
      result->required_scriptable_hosts.AddPattern(scriptable_origin);
",,"@@ -10,6 +10,7 @@
 #include ""base/json/json_writer.h""
 #include ""base/values.h""
 #include ""chrome/common/extensions/api/permissions.h""
+#include ""content/public/common/url_constants.h""
 #include ""extensions/common/error_utils.h""
 #include ""extensions/common/extension.h""
 #include ""extensions/common/permissions/permission_set.h""
@@ -149,6 +150,25 @@ bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,
     explicit_schemes &= ~URLPattern::SCHEME_FILE;
   }
 
+  auto filter_chrome_scheme = [](URLPattern* pattern) {
+    // We disallow the chrome:-scheme unless the pattern is explicitly
+    // ""chrome://..."" - that is, <all_urls> should not match the chrome:-scheme.
+    // Patterns which explicitly specify the chrome:-scheme are safe, since
+    // manifest parsing won't allow them unless the kExtensionsOnChromeURLs
+    // switch is enabled.
+    // Note that we don't check PermissionsData::AllUrlsIncludesChromeUrls()
+    // here, since that's only needed for Chromevox (which doesn't use optional
+    // permissions).
+    if (pattern->scheme() != content::kChromeUIScheme) {
+      // NOTE: We use pattern->valid_schemes() here (instead of
+      // |user_script_schemes| or |explicit_schemes|) because
+      // URLPattern::Parse() can mutate the valid schemes for a pattern, and we
+      // don't want to override those changes.
+      pattern->SetValidSchemes(pattern->valid_schemes() &
+                               ~URLPattern::SCHEME_CHROMEUI);
+    }
+  };
+
   for (const auto& origin_str : origins_input) {
     URLPattern explicit_origin(explicit_schemes);
     URLPattern::ParseResult parse_result = explicit_origin.Parse(origin_str);
@@ -159,6 +179,8 @@ bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,
       return false;
     }
 
+    filter_chrome_scheme(&explicit_origin);
+
     bool used_origin = false;
     if (required_permissions.explicit_hosts().ContainsPattern(
             explicit_origin)) {
@@ -172,11 +194,13 @@ bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,
 
     URLPattern scriptable_origin(user_script_schemes);
     if (scriptable_origin.Parse(origin_str) ==
-            URLPattern::ParseResult::kSuccess &&
-        required_permissions.scriptable_hosts().ContainsPattern(
-            scriptable_origin)) {
-      used_origin = true;
-      result->required_scriptable_hosts.AddPattern(scriptable_origin);
+        URLPattern::ParseResult::kSuccess) {
+      filter_chrome_scheme(&scriptable_origin);
+      if (required_permissions.scriptable_hosts().ContainsPattern(
+              scriptable_origin)) {
+        used_origin = true;
+        result->required_scriptable_hosts.AddPattern(scriptable_origin);
+      }
     }
 
     if (!used_origin)",Chrome,e13eb21898c7eba584f680e3d17ca1b9e28bc505,dc1204ca18cc08b4babece3966c2f2927b10d8e9,1,"bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,
                             const PermissionSet& required_permissions,
                             const PermissionSet& optional_permissions,
                             bool allow_file_access,
                             UnpackPermissionSetResult* result,
                             std::string* error) {
  int user_script_schemes = UserScript::ValidUserScriptSchemes();
  int explicit_schemes = Extension::kValidHostPermissionSchemes;
  if (!allow_file_access) {
    user_script_schemes &= ~URLPattern::SCHEME_FILE;
     explicit_schemes &= ~URLPattern::SCHEME_FILE;
   }
 
//fix_flaw_line_below:
//  auto filter_chrome_scheme = [](URLPattern* pattern) {
//fix_flaw_line_below:
//    // We disallow the chrome:-scheme unless the pattern is explicitly
//fix_flaw_line_below:
//    // ""chrome://..."" - that is, <all_urls> should not match the chrome:-scheme.
//fix_flaw_line_below:
//    // Patterns which explicitly specify the chrome:-scheme are safe, since
//fix_flaw_line_below:
//    // manifest parsing won't allow them unless the kExtensionsOnChromeURLs
//fix_flaw_line_below:
//    // switch is enabled.
//fix_flaw_line_below:
//    // Note that we don't check PermissionsData::AllUrlsIncludesChromeUrls()
//fix_flaw_line_below:
//    // here, since that's only needed for Chromevox (which doesn't use optional
//fix_flaw_line_below:
//    // permissions).
//fix_flaw_line_below:
//    if (pattern->scheme() != content::kChromeUIScheme) {
//fix_flaw_line_below:
//      // NOTE: We use pattern->valid_schemes() here (instead of
//fix_flaw_line_below:
//      // |user_script_schemes| or |explicit_schemes|) because
//fix_flaw_line_below:
//      // URLPattern::Parse() can mutate the valid schemes for a pattern, and we
//fix_flaw_line_below:
//      // don't want to override those changes.
//fix_flaw_line_below:
//      pattern->SetValidSchemes(pattern->valid_schemes() &
//fix_flaw_line_below:
//                               ~URLPattern::SCHEME_CHROMEUI);
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//  };
//fix_flaw_line_below:
//
   for (const auto& origin_str : origins_input) {
     URLPattern explicit_origin(explicit_schemes);
     URLPattern::ParseResult parse_result = explicit_origin.Parse(origin_str);
    if (URLPattern::ParseResult::kSuccess != parse_result) {
      *error = ErrorUtils::FormatErrorMessage(
          kInvalidOrigin, origin_str,
          URLPattern::GetParseResultString(parse_result));
       return false;
     }
 
//fix_flaw_line_below:
//    filter_chrome_scheme(&explicit_origin);
//fix_flaw_line_below:
//
     bool used_origin = false;
     if (required_permissions.explicit_hosts().ContainsPattern(
             explicit_origin)) {
      used_origin = true;
      result->required_explicit_hosts.AddPattern(explicit_origin);
    } else if (optional_permissions.explicit_hosts().ContainsPattern(
                   explicit_origin)) {
      used_origin = true;
      result->optional_explicit_hosts.AddPattern(explicit_origin);
    }
 
     URLPattern scriptable_origin(user_script_schemes);
     if (scriptable_origin.Parse(origin_str) ==
//flaw_line_below:
            URLPattern::ParseResult::kSuccess &&
//flaw_line_below:
        required_permissions.scriptable_hosts().ContainsPattern(
//flaw_line_below:
            scriptable_origin)) {
//flaw_line_below:
      used_origin = true;
//flaw_line_below:
      result->required_scriptable_hosts.AddPattern(scriptable_origin);
//fix_flaw_line_below:
//        URLPattern::ParseResult::kSuccess) {
//fix_flaw_line_below:
//      filter_chrome_scheme(&scriptable_origin);
//fix_flaw_line_below:
//      if (required_permissions.scriptable_hosts().ContainsPattern(
//fix_flaw_line_below:
//              scriptable_origin)) {
//fix_flaw_line_below:
//        used_origin = true;
//fix_flaw_line_below:
//        result->required_scriptable_hosts.AddPattern(scriptable_origin);
//fix_flaw_line_below:
//      }
     }
 
     if (!used_origin)
      result->unlisted_hosts.AddPattern(explicit_origin);
  }

  return true;
}
"
9367,187103,,Remote,Not required,,CVE-2019-5778,https://www.cvedetails.com/cve/CVE-2019-5778/,CWE-79,Medium,,Partial,,2019-02-19,4.3,A missing case for handling special schemes in permission request checks in Extensions in Google Chrome prior to 72.0.3626.81 allowed an attacker who convinced a user to install a malicious extension to bypass extension permission checks for privileged pages via a crafted Chrome Extension.,2019-04-18,XSS Bypass ,10,https://github.com/chromium/chromium/commit/e13eb21898c7eba584f680e3d17ca1b9e28bc505,e13eb21898c7eba584f680e3d17ca1b9e28bc505,"[Extensions] Have URLPattern::Contains() properly check schemes

Have URLPattern::Contains() properly check the schemes of the patterns
when evaluating if one pattern contains another. This is important in
order to prevent extensions from requesting chrome:-scheme permissions
via the permissions API when <all_urls> is specified as an optional
permission.

Bug: 859600,918470

Change-Id: If04d945ad0c939e84a80d83502c0f84b6ef0923d
Reviewed-on: https://chromium-review.googlesource.com/c/1396561
Commit-Queue: Devlin <rdevlin.cronin@chromium.org>
Reviewed-by: Karan Bhatia <karandeepb@chromium.org>
Cr-Commit-Position: refs/heads/master@{#621410}",4,extensions/common/permissions/permissions_data.cc,"{""sha"": ""4fb41c7426cd25c4346fab63aa8ff6a0526e1cbf"", ""filename"": ""chrome/browser/extensions/api/permissions/permissions_api_helpers.cc"", ""status"": ""modified"", ""additions"": 29, ""deletions"": 5, ""changes"": 34, ""blob_url"": ""https://github.com/chromium/chromium/blob/e13eb21898c7eba584f680e3d17ca1b9e28bc505/chrome/browser/extensions/api/permissions/permissions_api_helpers.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e13eb21898c7eba584f680e3d17ca1b9e28bc505/chrome/browser/extensions/api/permissions/permissions_api_helpers.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/api/permissions/permissions_api_helpers.cc?ref=e13eb21898c7eba584f680e3d17ca1b9e28bc505"", ""patch"": ""@@ -10,6 +10,7 @@\n #include \""base/json/json_writer.h\""\n #include \""base/values.h\""\n #include \""chrome/common/extensions/api/permissions.h\""\n+#include \""content/public/common/url_constants.h\""\n #include \""extensions/common/error_utils.h\""\n #include \""extensions/common/extension.h\""\n #include \""extensions/common/permissions/permission_set.h\""\n@@ -149,6 +150,25 @@ bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,\n     explicit_schemes &= ~URLPattern::SCHEME_FILE;\n   }\n \n+  auto filter_chrome_scheme = [](URLPattern* pattern) {\n+    // We disallow the chrome:-scheme unless the pattern is explicitly\n+    // \""chrome://...\"" - that is, <all_urls> should not match the chrome:-scheme.\n+    // Patterns which explicitly specify the chrome:-scheme are safe, since\n+    // manifest parsing won't allow them unless the kExtensionsOnChromeURLs\n+    // switch is enabled.\n+    // Note that we don't check PermissionsData::AllUrlsIncludesChromeUrls()\n+    // here, since that's only needed for Chromevox (which doesn't use optional\n+    // permissions).\n+    if (pattern->scheme() != content::kChromeUIScheme) {\n+      // NOTE: We use pattern->valid_schemes() here (instead of\n+      // |user_script_schemes| or |explicit_schemes|) because\n+      // URLPattern::Parse() can mutate the valid schemes for a pattern, and we\n+      // don't want to override those changes.\n+      pattern->SetValidSchemes(pattern->valid_schemes() &\n+                               ~URLPattern::SCHEME_CHROMEUI);\n+    }\n+  };\n+\n   for (const auto& origin_str : origins_input) {\n     URLPattern explicit_origin(explicit_schemes);\n     URLPattern::ParseResult parse_result = explicit_origin.Parse(origin_str);\n@@ -159,6 +179,8 @@ bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,\n       return false;\n     }\n \n+    filter_chrome_scheme(&explicit_origin);\n+\n     bool used_origin = false;\n     if (required_permissions.explicit_hosts().ContainsPattern(\n             explicit_origin)) {\n@@ -172,11 +194,13 @@ bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,\n \n     URLPattern scriptable_origin(user_script_schemes);\n     if (scriptable_origin.Parse(origin_str) ==\n-            URLPattern::ParseResult::kSuccess &&\n-        required_permissions.scriptable_hosts().ContainsPattern(\n-            scriptable_origin)) {\n-      used_origin = true;\n-      result->required_scriptable_hosts.AddPattern(scriptable_origin);\n+        URLPattern::ParseResult::kSuccess) {\n+      filter_chrome_scheme(&scriptable_origin);\n+      if (required_permissions.scriptable_hosts().ContainsPattern(\n+              scriptable_origin)) {\n+        used_origin = true;\n+        result->required_scriptable_hosts.AddPattern(scriptable_origin);\n+      }\n     }\n \n     if (!used_origin)""}<_**next**_>{""sha"": ""8f7cd522c721d6bc34453e41f2f4ba229d332c6b"", ""filename"": ""chrome/browser/extensions/api/permissions/permissions_api_helpers_unittest.cc"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/e13eb21898c7eba584f680e3d17ca1b9e28bc505/chrome/browser/extensions/api/permissions/permissions_api_helpers_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e13eb21898c7eba584f680e3d17ca1b9e28bc505/chrome/browser/extensions/api/permissions/permissions_api_helpers_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/api/permissions/permissions_api_helpers_unittest.cc?ref=e13eb21898c7eba584f680e3d17ca1b9e28bc505"", ""patch"": ""@@ -330,4 +330,28 @@ TEST(ExtensionPermissionsAPIHelpers, Unpack_UnsupportedAPIPermission) {\n       APIPermission::kWallpaper));\n }\n \n+// Tests that unpacking works correctly with wildcard schemes (which are\n+// interesting, because they only match http | https, and not all schemes).\n+TEST(ExtensionPermissionsAPIHelpers, Unpack_WildcardSchemes) {\n+  constexpr char kWildcardSchemePattern[] = \""*://*/*\"";\n+\n+  PermissionSet optional_permissions(\n+      APIPermissionSet(), ManifestPermissionSet(),\n+      URLPatternSet({URLPattern(Extension::kValidHostPermissionSchemes,\n+                                kWildcardSchemePattern)}),\n+      URLPatternSet());\n+\n+  Permissions permissions_object;\n+  permissions_object.origins = std::make_unique<std::vector<std::string>>(\n+      std::vector<std::string>({kWildcardSchemePattern}));\n+\n+  std::string error;\n+  std::unique_ptr<UnpackPermissionSetResult> unpack_result =\n+      UnpackPermissionSet(permissions_object, PermissionSet(),\n+                          optional_permissions, true, &error);\n+  ASSERT_TRUE(unpack_result) << error;\n+  EXPECT_THAT(GetPatternsAsStrings(unpack_result->optional_explicit_hosts),\n+              testing::ElementsAre(kWildcardSchemePattern));\n+}\n+\n }  // namespace extensions""}<_**next**_>{""sha"": ""bb62775351b3c7bba44caeba71c9870b6abc64af"", ""filename"": ""chrome/browser/extensions/api/permissions/permissions_api_unittest.cc"", ""status"": ""modified"", ""additions"": 53, ""deletions"": 1, ""changes"": 54, ""blob_url"": ""https://github.com/chromium/chromium/blob/e13eb21898c7eba584f680e3d17ca1b9e28bc505/chrome/browser/extensions/api/permissions/permissions_api_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e13eb21898c7eba584f680e3d17ca1b9e28bc505/chrome/browser/extensions/api/permissions/permissions_api_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/api/permissions/permissions_api_unittest.cc?ref=e13eb21898c7eba584f680e3d17ca1b9e28bc505"", ""patch"": ""@@ -19,13 +19,17 @@\n #include \""components/crx_file/id_util.h\""\n #include \""extensions/common/extension_builder.h\""\n #include \""extensions/common/extension_features.h\""\n+#include \""extensions/common/manifest_handlers/permissions_parser.h\""\n #include \""testing/gmock/include/gmock/gmock.h\""\n #include \""testing/gtest/include/gtest/gtest.h\""\n \n namespace extensions {\n \n namespace {\n \n+constexpr char kNotInManifestError[] =\n+    \""Only permissions specified in the manifest may be requested.\"";\n+\n using permissions_test_util::GetPatternsAsStrings;\n \n scoped_refptr<const Extension> CreateExtensionWithPermissions(\n@@ -556,7 +560,7 @@ TEST_F(PermissionsAPIUnitTest, RequestingPermissionsNotSpecifiedInManifest) {\n   auto function = base::MakeRefCounted<PermissionsRequestFunction>();\n   function->set_user_gesture(true);\n   function->set_extension(extension.get());\n-  EXPECT_EQ(\""Only permissions specified in the manifest may be requested.\"",\n+  EXPECT_EQ(kNotInManifestError,\n             extension_function_test_utils::RunFunctionAndReturnError(\n                 function.get(),\n                 R\""([{\n@@ -617,4 +621,52 @@ TEST_F(PermissionsAPIUnitTest, RequestingAlreadyGrantedWithheldPermissions) {\n           kGoogleCom));\n }\n \n+// Test that requesting chrome:-scheme URLs is disallowed in the permissions\n+// API.\n+TEST_F(PermissionsAPIUnitTest, RequestingChromeURLs) {\n+  scoped_refptr<const Extension> extension =\n+      ExtensionBuilder(\""extension\"")\n+          .SetManifestKey(\""optional_permissions\"",\n+                          ListBuilder().Append(\""<all_urls>\"").Build())\n+          .Build();\n+  AddExtensionAndGrantPermissions(*extension);\n+\n+  const GURL chrome_url(\""chrome://settings\"");\n+\n+  // By default, the extension should not have access to chrome://settings.\n+  EXPECT_FALSE(extension->permissions_data()->HasHostPermission(chrome_url));\n+  // The optional permissions should also omit the chrome:-scheme for the\n+  // <all_urls> pattern.\n+  EXPECT_FALSE(PermissionsParser::GetOptionalPermissions(extension.get())\n+                   .explicit_hosts()\n+                   .MatchesURL(chrome_url));\n+\n+  {\n+    // Trying to request \""chrome://settings/*\"" should fail, since it's not in\n+    // the optional permissions.\n+    auto function = base::MakeRefCounted<PermissionsRequestFunction>();\n+    function->set_user_gesture(true);\n+    function->set_extension(extension.get());\n+    std::string error =\n+        extension_function_test_utils::RunFunctionAndReturnError(\n+            function.get(), R\""([{\""origins\"": [\""chrome://settings/*\""]}])\"",\n+            browser(), api_test_utils::NONE);\n+    EXPECT_EQ(kNotInManifestError, error);\n+  }\n+  // chrome://settings should still be restricted.\n+  EXPECT_FALSE(extension->permissions_data()->HasHostPermission(chrome_url));\n+\n+  // The extension can request <all_urls>, but it should not grant access to the\n+  // chrome:-scheme.\n+  std::unique_ptr<const PermissionSet> prompted_permissions;\n+  RunRequestFunction(*extension, browser(), R\""([{\""origins\"": [\""<all_urls>\""]}])\"",\n+                     &prompted_permissions);\n+  EXPECT_THAT(GetPatternsAsStrings(prompted_permissions->effective_hosts()),\n+              testing::UnorderedElementsAre(\""<all_urls>\""));\n+\n+  EXPECT_FALSE(extension->permissions_data()->HasHostPermission(chrome_url));\n+  EXPECT_TRUE(extension->permissions_data()->HasHostPermission(\n+      GURL(\""https://example.com\"")));\n+}\n+\n }  // namespace extensions""}<_**next**_>{""sha"": ""1723926a52e7d0431e87c4da36d64f7e2bb88ddf"", ""filename"": ""chrome/browser/extensions/permissions_updater_unittest.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/e13eb21898c7eba584f680e3d17ca1b9e28bc505/chrome/browser/extensions/permissions_updater_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e13eb21898c7eba584f680e3d17ca1b9e28bc505/chrome/browser/extensions/permissions_updater_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/permissions_updater_unittest.cc?ref=e13eb21898c7eba584f680e3d17ca1b9e28bc505"", ""patch"": ""@@ -703,8 +703,10 @@ TEST_F(PermissionsUpdaterTest, ChromeFaviconIsNotARevokableHost) {\n         ExtensionBuilder(\""all urls extension\"")\n             .AddPermission(\""<all_urls>\"")\n             .Build();\n-    URLPattern all_urls_pattern(Extension::kValidHostPermissionSchemes,\n-                                \""<all_urls>\"");\n+    URLPattern all_urls_pattern(\n+        Extension::kValidHostPermissionSchemes &\n+            ~(URLPattern::SCHEME_CHROMEUI | URLPattern::SCHEME_FILE),\n+        \""<all_urls>\"");\n     PermissionsUpdater updater(profile());\n     updater.InitializePermissions(extension.get());\n \n@@ -720,11 +722,8 @@ TEST_F(PermissionsUpdaterTest, ChromeFaviconIsNotARevokableHost) {\n \n     std::unique_ptr<const PermissionSet> revokable_permissions =\n         updater.GetRevokablePermissions(extension.get());\n-    // TODO(https://crbug.com/859600): <all_urls> will report containing\n-    // chrome://favicon/, even though it shouldn't since the scheme doesn't\n-    // match.\n-    // EXPECT_FALSE(revokable_permissions->explicit_hosts().ContainsPattern(\n-    //     chrome_favicon_pattern));\n+    EXPECT_FALSE(revokable_permissions->explicit_hosts().ContainsPattern(\n+        chrome_favicon_pattern));\n     EXPECT_TRUE(revokable_permissions->explicit_hosts().ContainsPattern(\n         all_urls_pattern));\n ""}<_**next**_>{""sha"": ""e7d5cf1f8aa4cd35d2ce10f94640e40891c7cd19"", ""filename"": ""extensions/common/permissions/permissions_data.cc"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 4, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/e13eb21898c7eba584f680e3d17ca1b9e28bc505/extensions/common/permissions/permissions_data.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e13eb21898c7eba584f680e3d17ca1b9e28bc505/extensions/common/permissions/permissions_data.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/common/permissions/permissions_data.cc?ref=e13eb21898c7eba584f680e3d17ca1b9e28bc505"", ""patch"": ""@@ -387,10 +387,16 @@ bool PermissionsData::CanCaptureVisiblePage(\n     has_active_tab = tab_permissions &&\n                      tab_permissions->HasAPIPermission(APIPermission::kTab);\n \n-    const URLPattern all_urls(URLPattern::SCHEME_ALL,\n-                              URLPattern::kAllUrlsPattern);\n-    has_all_urls =\n-        active_permissions_unsafe_->explicit_hosts().ContainsPattern(all_urls);\n+    // Check if any of the host permissions match all urls. We don't use\n+    // URLPatternSet::ContainsPattern() here because a) the schemes may be\n+    // different and b) this is more efficient.\n+    for (const auto& pattern : active_permissions_unsafe_->explicit_hosts()) {\n+      if (pattern.match_all_urls()) {\n+        has_all_urls = true;\n+        break;\n+      }\n+    }\n+\n     has_page_capture = active_permissions_unsafe_->HasAPIPermission(\n         APIPermission::kPageCapture);\n   }""}<_**next**_>{""sha"": ""91e788b562993229421f4f7a17aa2678fa30617e"", ""filename"": ""extensions/common/url_pattern.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/e13eb21898c7eba584f680e3d17ca1b9e28bc505/extensions/common/url_pattern.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e13eb21898c7eba584f680e3d17ca1b9e28bc505/extensions/common/url_pattern.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/common/url_pattern.cc?ref=e13eb21898c7eba584f680e3d17ca1b9e28bc505"", ""patch"": ""@@ -352,6 +352,10 @@ URLPattern::ParseResult URLPattern::Parse(base::StringPiece pattern,\n }\n \n void URLPattern::SetValidSchemes(int valid_schemes) {\n+  // TODO(devlin): Should we check that valid_schemes agrees with |scheme_|\n+  // here? Otherwise, valid_schemes_ and schemes_ may stop agreeing with each\n+  // other (e.g., in the case of `*://*/*`, where the scheme should only be\n+  // http or https).\n   spec_.clear();\n   valid_schemes_ = valid_schemes;\n }\n@@ -433,6 +437,8 @@ bool URLPattern::MatchesURL(const GURL& test) const {\n     test_url = test.inner_url();\n   }\n \n+  // Ensure the scheme matches first, since <all_urls> may not match this URL if\n+  // the scheme is excluded.\n   if (!MatchesScheme(test_url->scheme_piece()))\n     return false;\n \n@@ -632,8 +638,14 @@ bool URLPattern::OverlapsWith(const URLPattern& other) const {\n }\n \n bool URLPattern::Contains(const URLPattern& other) const {\n-  if (match_all_urls())\n+  // Important: it's not enough to just check match_all_urls(); we also need to\n+  // make sure that the schemes in this pattern are a superset of those in\n+  // |other|.\n+  if (match_all_urls() &&\n+      (valid_schemes_ & other.valid_schemes_) == other.valid_schemes_) {\n     return true;\n+  }\n+\n   return MatchesAllSchemes(other.GetExplicitSchemes()) &&\n          MatchesHost(other.host()) &&\n          (!other.match_subdomains_ || match_subdomains_) &&""}<_**next**_>{""sha"": ""3bedc4326c02d1e9ef305dec2fd17cfb3c4b0970"", ""filename"": ""extensions/common/url_pattern_unittest.cc"", ""status"": ""modified"", ""additions"": 49, ""deletions"": 0, ""changes"": 49, ""blob_url"": ""https://github.com/chromium/chromium/blob/e13eb21898c7eba584f680e3d17ca1b9e28bc505/extensions/common/url_pattern_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/e13eb21898c7eba584f680e3d17ca1b9e28bc505/extensions/common/url_pattern_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/common/url_pattern_unittest.cc?ref=e13eb21898c7eba584f680e3d17ca1b9e28bc505"", ""patch"": ""@@ -1250,4 +1250,53 @@ TEST(ExtensionURLPatternTest, ValidSchemeIntersection) {\n   }\n }\n \n+// Tests that <all_urls> patterns correctly check schemes when testing if one\n+// contains the other.\n+TEST(ExtensionURLPatternTest, ContainsSchemes) {\n+  const URLPattern http(URLPattern::SCHEME_HTTP, URLPattern::kAllUrlsPattern);\n+  const URLPattern chrome(URLPattern::SCHEME_CHROMEUI,\n+                          URLPattern::kAllUrlsPattern);\n+  const URLPattern http_and_https(\n+      URLPattern::SCHEME_HTTP | URLPattern::SCHEME_HTTPS,\n+      URLPattern::kAllUrlsPattern);\n+  const URLPattern http_https_and_chrome(URLPattern::SCHEME_HTTP |\n+                                             URLPattern::SCHEME_HTTPS |\n+                                             URLPattern::SCHEME_CHROMEUI,\n+                                         URLPattern::kAllUrlsPattern);\n+\n+  // A map between each URLPattern and the other patterns it should contain.\n+  const std::map<const URLPattern*, std::set<const URLPattern*>> contains_map =\n+      {\n+          {&http, {}},\n+          {&chrome, {}},\n+          {&http_and_https, {&http}},\n+          {&http_https_and_chrome, {&http, &http_and_https, &chrome}},\n+      };\n+\n+  const URLPattern* all_patterns[] = {&http, &chrome, &http_and_https,\n+                                      &http_https_and_chrome};\n+\n+  // Verify that each pattern contains exactly the expected patterns.\n+  for (const auto& entry : contains_map) {\n+    const URLPattern* pattern = entry.first;\n+    const std::set<const URLPattern*>& contains_patterns = entry.second;\n+    for (const URLPattern* other_pattern : all_patterns) {\n+      SCOPED_TRACE(base::StringPrintf(\""Checking if %d contains %d\"",\n+                                      pattern->valid_schemes(),\n+                                      other_pattern->valid_schemes()));\n+      bool expect_contains =\n+          // Patterns should always contain themselves.\n+          pattern == other_pattern || contains_patterns.count(other_pattern);\n+      EXPECT_EQ(expect_contains, pattern->Contains(*other_pattern));\n+    }\n+  }\n+\n+  // Fun edge case for bonus points: |http| doesn't contain all the valid\n+  // schemes of the other pattern, but does in practice (since the scheme is\n+  // restricted to http by the match pattern).\n+  EXPECT_TRUE(http.Contains(\n+      URLPattern(URLPattern::SCHEME_HTTP | URLPattern::SCHEME_HTTPS,\n+                 \""http://google.com/*\"")));\n+}\n+\n }  // namespace""}","bool PermissionsData::CanCaptureVisiblePage(
    const GURL& document_url,
    int tab_id,
    std::string* error,
    CaptureRequirement capture_requirement) const {
  bool has_active_tab = false;
  bool has_all_urls = false;
  bool has_page_capture = false;
  url::Origin origin = url::Origin::Create(document_url);
  const GURL origin_url = origin.GetURL();
  {
    base::AutoLock auto_lock(runtime_lock_);
    if (location_ != Manifest::COMPONENT &&
        IsPolicyBlockedHostUnsafe(origin_url)) {
      if (error)
        *error = extension_misc::kPolicyBlockedScripting;
      return false;
    }

    const PermissionSet* tab_permissions = GetTabSpecificPermissions(tab_id);
     has_active_tab = tab_permissions &&
                      tab_permissions->HasAPIPermission(APIPermission::kTab);
 
    // Check if any of the host permissions match all urls. We don't use
    // URLPatternSet::ContainsPattern() here because a) the schemes may be
    // different and b) this is more efficient.
    for (const auto& pattern : active_permissions_unsafe_->explicit_hosts()) {
      if (pattern.match_all_urls()) {
        has_all_urls = true;
        break;
      }
    }

     has_page_capture = active_permissions_unsafe_->HasAPIPermission(
         APIPermission::kPageCapture);
   }
  std::string access_error;
  if (capture_requirement == CaptureRequirement::kActiveTabOrAllUrls) {
    if (!has_active_tab && !has_all_urls) {
      if (error)
        *error = manifest_errors::kAllURLOrActiveTabNeeded;
      return false;
    }

    if (GetPageAccess(origin_url, tab_id, &access_error) ==
        PageAccess::kAllowed)
      return true;
  } else {
    DCHECK_EQ(CaptureRequirement::kPageCapture, capture_requirement);
    if (!has_page_capture) {
      if (error)
        *error = manifest_errors::kPageCaptureNeeded;
    }

    if ((origin_url.SchemeIs(url::kHttpScheme) ||
         origin_url.SchemeIs(url::kHttpsScheme)) &&
        !origin.IsSameOriginWith(url::Origin::Create(
            ExtensionsClient::Get()->GetWebstoreBaseURL()))) {
      return true;
    }
  }


  if (origin_url.host() == extension_id_)
    return true;

  bool allowed_with_active_tab =
      origin_url.SchemeIs(content::kChromeUIScheme) ||
      origin_url.SchemeIs(kExtensionScheme) ||
      document_url.SchemeIs(url::kDataScheme) ||
      origin.IsSameOriginWith(
          url::Origin::Create(ExtensionsClient::Get()->GetWebstoreBaseURL()));

  if (!allowed_with_active_tab) {
    if (error)
      *error = access_error;
    return false;
  }
  if (has_active_tab)
    return true;

  if (error)
    *error = manifest_errors::kActiveTabPermissionNotGranted;
  return false;
}
","bool PermissionsData::CanCaptureVisiblePage(
    const GURL& document_url,
    int tab_id,
    std::string* error,
    CaptureRequirement capture_requirement) const {
  bool has_active_tab = false;
  bool has_all_urls = false;
  bool has_page_capture = false;
  url::Origin origin = url::Origin::Create(document_url);
  const GURL origin_url = origin.GetURL();
  {
    base::AutoLock auto_lock(runtime_lock_);
    if (location_ != Manifest::COMPONENT &&
        IsPolicyBlockedHostUnsafe(origin_url)) {
      if (error)
        *error = extension_misc::kPolicyBlockedScripting;
      return false;
    }

    const PermissionSet* tab_permissions = GetTabSpecificPermissions(tab_id);
     has_active_tab = tab_permissions &&
                      tab_permissions->HasAPIPermission(APIPermission::kTab);
 
    const URLPattern all_urls(URLPattern::SCHEME_ALL,
                              URLPattern::kAllUrlsPattern);
    has_all_urls =
        active_permissions_unsafe_->explicit_hosts().ContainsPattern(all_urls);
     has_page_capture = active_permissions_unsafe_->HasAPIPermission(
         APIPermission::kPageCapture);
   }
  std::string access_error;
  if (capture_requirement == CaptureRequirement::kActiveTabOrAllUrls) {
    if (!has_active_tab && !has_all_urls) {
      if (error)
        *error = manifest_errors::kAllURLOrActiveTabNeeded;
      return false;
    }

    if (GetPageAccess(origin_url, tab_id, &access_error) ==
        PageAccess::kAllowed)
      return true;
  } else {
    DCHECK_EQ(CaptureRequirement::kPageCapture, capture_requirement);
    if (!has_page_capture) {
      if (error)
        *error = manifest_errors::kPageCaptureNeeded;
    }

    if ((origin_url.SchemeIs(url::kHttpScheme) ||
         origin_url.SchemeIs(url::kHttpsScheme)) &&
        !origin.IsSameOriginWith(url::Origin::Create(
            ExtensionsClient::Get()->GetWebstoreBaseURL()))) {
      return true;
    }
  }


  if (origin_url.host() == extension_id_)
    return true;

  bool allowed_with_active_tab =
      origin_url.SchemeIs(content::kChromeUIScheme) ||
      origin_url.SchemeIs(kExtensionScheme) ||
      document_url.SchemeIs(url::kDataScheme) ||
      origin.IsSameOriginWith(
          url::Origin::Create(ExtensionsClient::Get()->GetWebstoreBaseURL()));

  if (!allowed_with_active_tab) {
    if (error)
      *error = access_error;
    return false;
  }
  if (has_active_tab)
    return true;

  if (error)
    *error = manifest_errors::kActiveTabPermissionNotGranted;
  return false;
}
",C,"    // Check if any of the host permissions match all urls. We don't use
    // URLPatternSet::ContainsPattern() here because a) the schemes may be
    // different and b) this is more efficient.
    for (const auto& pattern : active_permissions_unsafe_->explicit_hosts()) {
      if (pattern.match_all_urls()) {
        has_all_urls = true;
        break;
      }
    }

","    const URLPattern all_urls(URLPattern::SCHEME_ALL,
                              URLPattern::kAllUrlsPattern);
    has_all_urls =
        active_permissions_unsafe_->explicit_hosts().ContainsPattern(all_urls);
",,"@@ -387,10 +387,16 @@ bool PermissionsData::CanCaptureVisiblePage(
     has_active_tab = tab_permissions &&
                      tab_permissions->HasAPIPermission(APIPermission::kTab);
 
-    const URLPattern all_urls(URLPattern::SCHEME_ALL,
-                              URLPattern::kAllUrlsPattern);
-    has_all_urls =
-        active_permissions_unsafe_->explicit_hosts().ContainsPattern(all_urls);
+    // Check if any of the host permissions match all urls. We don't use
+    // URLPatternSet::ContainsPattern() here because a) the schemes may be
+    // different and b) this is more efficient.
+    for (const auto& pattern : active_permissions_unsafe_->explicit_hosts()) {
+      if (pattern.match_all_urls()) {
+        has_all_urls = true;
+        break;
+      }
+    }
+
     has_page_capture = active_permissions_unsafe_->HasAPIPermission(
         APIPermission::kPageCapture);
   }",Chrome,e13eb21898c7eba584f680e3d17ca1b9e28bc505,dc1204ca18cc08b4babece3966c2f2927b10d8e9,1,"bool PermissionsData::CanCaptureVisiblePage(
    const GURL& document_url,
    int tab_id,
    std::string* error,
    CaptureRequirement capture_requirement) const {
  bool has_active_tab = false;
  bool has_all_urls = false;
  bool has_page_capture = false;
  // Check the real origin, in order to account for filesystem:, blob:, etc.
  // (url::Origin grabs the inner origin of these, whereas GURL::GetOrigin()
  // does not.)
  url::Origin origin = url::Origin::Create(document_url);
  const GURL origin_url = origin.GetURL();
  {
    base::AutoLock auto_lock(runtime_lock_);
    // Disallow capturing policy-blocked hosts. No exceptions.
    // Note: This isn't foolproof, since an extension could embed a policy-
    // blocked host in a different page and then capture that, but it's better
    // than nothing (and policy hosts can set their x-frame options
    // accordingly).
    if (location_ != Manifest::COMPONENT &&
        IsPolicyBlockedHostUnsafe(origin_url)) {
      if (error)
        *error = extension_misc::kPolicyBlockedScripting;
      return false;
    }

    const PermissionSet* tab_permissions = GetTabSpecificPermissions(tab_id);
     has_active_tab = tab_permissions &&
                      tab_permissions->HasAPIPermission(APIPermission::kTab);
 
//flaw_line_below:
    const URLPattern all_urls(URLPattern::SCHEME_ALL,
//flaw_line_below:
                              URLPattern::kAllUrlsPattern);
//flaw_line_below:
    has_all_urls =
//flaw_line_below:
        active_permissions_unsafe_->explicit_hosts().ContainsPattern(all_urls);
//fix_flaw_line_below:
//    // Check if any of the host permissions match all urls. We don't use
//fix_flaw_line_below:
//    // URLPatternSet::ContainsPattern() here because a) the schemes may be
//fix_flaw_line_below:
//    // different and b) this is more efficient.
//fix_flaw_line_below:
//    for (const auto& pattern : active_permissions_unsafe_->explicit_hosts()) {
//fix_flaw_line_below:
//      if (pattern.match_all_urls()) {
//fix_flaw_line_below:
//        has_all_urls = true;
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     has_page_capture = active_permissions_unsafe_->HasAPIPermission(
         APIPermission::kPageCapture);
   }
  std::string access_error;
  if (capture_requirement == CaptureRequirement::kActiveTabOrAllUrls) {
    if (!has_active_tab && !has_all_urls) {
      if (error)
        *error = manifest_errors::kAllURLOrActiveTabNeeded;
      return false;
    }

    // We check GetPageAccess() (in addition to the <all_urls> and activeTab
    // checks below) for the case of URLs that can be conditionally granted
    // (such as file:// URLs or chrome:// URLs for component extensions). If an
    // extension has <all_urls>, GetPageAccess() will still (correctly) return
    // false if, for instance, the URL is a file:// URL and the extension does
    // not have file access. See https://crbug.com/810220. If the extension has
    // page access (and has activeTab or <all_urls>), allow the capture.
    if (GetPageAccess(origin_url, tab_id, &access_error) ==
        PageAccess::kAllowed)
      return true;
  } else {
    DCHECK_EQ(CaptureRequirement::kPageCapture, capture_requirement);
    if (!has_page_capture) {
      if (error)
        *error = manifest_errors::kPageCaptureNeeded;
    }

    // If the URL is a typical web URL, the pageCapture permission is
    // sufficient.
    if ((origin_url.SchemeIs(url::kHttpScheme) ||
         origin_url.SchemeIs(url::kHttpsScheme)) &&
        !origin.IsSameOriginWith(url::Origin::Create(
            ExtensionsClient::Get()->GetWebstoreBaseURL()))) {
      return true;
    }
  }

  // The extension doesn't have explicit page access. However, there are a
  // number of cases where tab capture may still be allowed.

  // First special case: an extension's own pages.
  // These aren't restricted URLs, but won't be matched by <all_urls> or
  // activeTab (since the extension scheme is not included in the list of
  // valid schemes for extension permissions). To capture an extension's own
  // page, either activeTab or <all_urls> is needed (it's no higher privilege
  // than a normal web page). At least one of these is still needed because
  // the extension page may have embedded web content.
  // TODO(devlin): Should activeTab/<all_urls> account for the extension's own
  // domain?
  if (origin_url.host() == extension_id_)
    return true;

  // The following are special cases that require activeTab explicitly. Normal
  // extensions will never have full access to these pages (i.e., can never
  // inject scripts or otherwise modify the page), but capturing the page can
  // still be useful for e.g. screenshots. We allow these pages only if the
  // extension has been explicitly granted activeTab, which serves as a
  // stronger guarantee that the user wants to run the extension on the site.
  // These origins include:
  // - chrome:-scheme pages.
  // - Other extension's pages.
  // - data: URLs (which don't have a defined underlying origin).
  // - The Chrome Web Store.
  bool allowed_with_active_tab =
      origin_url.SchemeIs(content::kChromeUIScheme) ||
      origin_url.SchemeIs(kExtensionScheme) ||
      // Note: The origin of a data: url is empty, so check the url itself.
      document_url.SchemeIs(url::kDataScheme) ||
      origin.IsSameOriginWith(
          url::Origin::Create(ExtensionsClient::Get()->GetWebstoreBaseURL()));

  if (!allowed_with_active_tab) {
    if (error)
      *error = access_error;
    return false;
  }
  // If the extension has activeTab, these origins are allowed.
  if (has_active_tab)
    return true;

  // Otherwise, access is denied.
  if (error)
    *error = manifest_errors::kActiveTabPermissionNotGranted;
  return false;
}
"
9540,187276,,Remote,Not required,,CVE-2018-6145,https://www.cvedetails.com/cve/CVE-2018-6145/,CWE-79,Medium,,Partial,,2019-06-27,4.3,Insufficient data validation in HTML parser in Google Chrome prior to 67.0.3396.62 allowed a remote attacker to bypass same origin policy via a crafted HTML page.,2019-07-02,XSS Bypass ,4,https://github.com/chromium/chromium/commit/133bc5c262b2555af223263452e9875a95db9eb7,133bc5c262b2555af223263452e9875a95db9eb7,"HTML parser: Fix ""HTML integration point"" implementation in HTMLTreeBuilderSimulator.

HTMLTreeBuilderSimulator assumed only <foreignObject> as an HTML
integration point. This CL adds <annotation-xml>, <desc>, and SVG
<title>.

Bug: 805924
Change-Id: I6793d9163d4c6bc8bf0790415baedddaac7a1fc2
Reviewed-on: https://chromium-review.googlesource.com/964038
Commit-Queue: Kent Tamura <tkent@chromium.org>
Reviewed-by: Kouhei Ueno <kouhei@chromium.org>
Cr-Commit-Position: refs/heads/master@{#543634}",5,third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.cpp,"{""sha"": ""be6b42d07d0257fcc2ffc13401be3777395a02fb"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/html/syntax/parsing/html-integration-point.html"", ""status"": ""added"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/chromium/chromium/blob/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/LayoutTests/external/wpt/html/syntax/parsing/html-integration-point.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/LayoutTests/external/wpt/html/syntax/parsing/html-integration-point.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/html/syntax/parsing/html-integration-point.html?ref=133bc5c262b2555af223263452e9875a95db9eb7"", ""patch"": ""@@ -0,0 +1,31 @@\n+<!DOCTYPE html>\n+<link rel=\""help\"" href=\""https://html.spec.whatwg.org/multipage/parsing.html#tree-construction:html-integration-point\"">\n+<body>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+\n+<math><annotation-xml id=\""point-1\"" encoding=\""text/html\""><xmp>&lt;/xmp&gt;&lt;img></xmp></annotation-xml></math>\n+<math><annotation-xml id=\""point-2\"" encoding=\""application/xhtml+xml\""><style>&lt;/style&gt;&lt;img></style></annotation-xml></math>\n+<svg><foreignObject id=\""point-3\""><iframe>&lt;/iframe&gt;&lt;img></iframe></foreignObject></svg>\n+<svg><desc id=\""point-4\""><noembed>&lt;/noembed&gt;&lt;img></noembed></desc></svg>\n+<svg><title id=\""point-5\""><noframes>&lt;/noframes&gt;&lt;img></noframes></title></svg>\n+\n+<script>\n+function generate_test(id) {\n+  return () => {\n+    let point = document.querySelector('#' + id);\n+    assert_not_equals(point.namespaceURI, 'http://www.w3.org/1999/xhtml');\n+    let rawTextElement = point.firstChild;\n+    assert_equals(rawTextElement.namespaceURI, 'http://www.w3.org/1999/xhtml');\n+    assert_equals(rawTextElement.textContent.substr(0, 4), '&lt;',\n+                  'Entity references should not be decoded.');\n+  };\n+}\n+\n+test(generate_test('point-1'), 'MathML annotation-xml with encoding=text/html should be an HTML integration point');\n+test(generate_test('point-2'), 'MathML annotation-xml with encoding=application/xhtml+xml should be an HTML integration point');\n+test(generate_test('point-3'), 'SVG foreignObject should be an HTML integration point');\n+test(generate_test('point-4'), 'SVG desc should be an HTML integration point');\n+test(generate_test('point-5'), 'SVG title should be an HTML integration point');\n+</script>\n+</body>""}<_**next**_>{""sha"": ""1029c22a1afb3ea6dfc12e98952ba2e98302ef03"", ""filename"": ""third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.cpp"", ""status"": ""modified"", ""additions"": 59, ""deletions"": 12, ""changes"": 71, ""blob_url"": ""https://github.com/chromium/chromium/blob/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.cpp?ref=133bc5c262b2555af223263452e9875a95db9eb7"", ""patch"": ""@@ -82,13 +82,6 @@ static bool TokenExitsForeignContent(const CompactHTMLToken& token) {\n            token.GetAttributeItem(sizeAttr)));\n }\n \n-static bool TokenExitsSVG(const CompactHTMLToken& token) {\n-  // FIXME: It's very fragile that we special case foreignObject here to be\n-  // case-insensitive.\n-  return DeprecatedEqualIgnoringCase(token.Data(),\n-                                     SVGNames::foreignObjectTag.LocalName());\n-}\n-\n static bool TokenExitsMath(const CompactHTMLToken& token) {\n   // FIXME: This is copied from HTMLElementStack::isMathMLTextIntegrationPoint\n   // and changed to use threadSafeMatch.\n@@ -148,10 +141,10 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(\n       namespace_stack_.push_back(kMathML);\n     if (InForeignContent() && TokenExitsForeignContent(token))\n       namespace_stack_.pop_back();\n-    if ((namespace_stack_.back() == SVG && TokenExitsSVG(token)) ||\n-        (namespace_stack_.back() == kMathML && TokenExitsMath(token)))\n+    if (IsHTMLIntegrationPointForStartTag(token) ||\n+        (namespace_stack_.back() == kMathML && TokenExitsMath(token))) {\n       namespace_stack_.push_back(HTML);\n-    if (!InForeignContent()) {\n+    } else if (!InForeignContent()) {\n       // FIXME: This is just a copy of Tokenizer::updateStateFor which uses\n       // threadSafeMatches.\n       if (ThreadSafeMatch(tag_name, textareaTag) ||\n@@ -203,8 +196,7 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(\n          ThreadSafeMatch(tag_name, SVGNames::svgTag)) ||\n         (namespace_stack_.back() == kMathML &&\n          ThreadSafeMatch(tag_name, MathMLNames::mathTag)) ||\n-        (namespace_stack_.Contains(SVG) && namespace_stack_.back() == HTML &&\n-         TokenExitsSVG(token)) ||\n+        IsHTMLIntegrationPointForEndTag(token) ||\n         (namespace_stack_.Contains(kMathML) &&\n          namespace_stack_.back() == HTML && TokenExitsMath(token))) {\n       namespace_stack_.pop_back();\n@@ -226,4 +218,59 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(\n   return simulated_token;\n }\n \n+// https://html.spec.whatwg.org/multipage/parsing.html#html-integration-point\n+bool HTMLTreeBuilderSimulator::IsHTMLIntegrationPointForStartTag(\n+    const CompactHTMLToken& token) const {\n+  DCHECK(token.GetType() == HTMLToken::kStartTag) << token.GetType();\n+\n+  Namespace tokens_ns = namespace_stack_.back();\n+  const String& tag_name = token.Data();\n+  if (tokens_ns == kMathML) {\n+    if (!ThreadSafeMatch(tag_name, MathMLNames::annotation_xmlTag))\n+      return false;\n+    if (auto* encoding = token.GetAttributeItem(MathMLNames::encodingAttr)) {\n+      return EqualIgnoringASCIICase(encoding->Value(), \""text/html\"") ||\n+             EqualIgnoringASCIICase(encoding->Value(), \""application/xhtml+xml\"");\n+    }\n+  } else if (tokens_ns == SVG) {\n+    // FIXME: It's very fragile that we special case foreignObject here to be\n+    // case-insensitive.\n+    if (DeprecatedEqualIgnoringCase(tag_name,\n+                                    SVGNames::foreignObjectTag.LocalName()))\n+      return true;\n+    return ThreadSafeMatch(tag_name, SVGNames::descTag) ||\n+           ThreadSafeMatch(tag_name, SVGNames::titleTag);\n+  }\n+  return false;\n+}\n+\n+// https://html.spec.whatwg.org/multipage/parsing.html#html-integration-point\n+bool HTMLTreeBuilderSimulator::IsHTMLIntegrationPointForEndTag(\n+    const CompactHTMLToken& token) const {\n+  if (token.GetType() != HTMLToken::kEndTag)\n+    return false;\n+\n+  // If it's inside an HTML integration point, the top namespace is\n+  // HTML, and its next namespace is not HTML.\n+  if (namespace_stack_.back() != HTML)\n+    return false;\n+  if (namespace_stack_.size() < 2)\n+    return false;\n+  Namespace tokens_ns = namespace_stack_[namespace_stack_.size() - 2];\n+\n+  const String& tag_name = token.Data();\n+  if (tokens_ns == kMathML)\n+    return ThreadSafeMatch(tag_name, MathMLNames::annotation_xmlTag);\n+  if (tokens_ns == SVG) {\n+    // FIXME: It's very fragile that we special case foreignObject here to be\n+    // case-insensitive.\n+    if (DeprecatedEqualIgnoringCase(tag_name,\n+                                    SVGNames::foreignObjectTag.LocalName()))\n+      return true;\n+    return ThreadSafeMatch(tag_name, SVGNames::descTag) ||\n+           ThreadSafeMatch(tag_name, SVGNames::titleTag);\n+  }\n+  return false;\n+}\n+\n }  // namespace blink""}<_**next**_>{""sha"": ""2fd9f921ce33ccc4daf367f1ce3f793e78617521"", ""filename"": ""third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.h?ref=133bc5c262b2555af223263452e9875a95db9eb7"", ""patch"": ""@@ -64,6 +64,8 @@ class CORE_EXPORT HTMLTreeBuilderSimulator {\n \n  private:\n   bool InForeignContent() const { return namespace_stack_.back() != HTML; }\n+  bool IsHTMLIntegrationPointForStartTag(const CompactHTMLToken&) const;\n+  bool IsHTMLIntegrationPointForEndTag(const CompactHTMLToken&) const;\n \n   HTMLParserOptions options_;\n   State namespace_stack_;""}","HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(
    const CompactHTMLToken& token,
    HTMLTokenizer* tokenizer) {
  SimulatedToken simulated_token = kOtherToken;

  if (token.GetType() == HTMLToken::kStartTag) {
    const String& tag_name = token.Data();
    if (ThreadSafeMatch(tag_name, SVGNames::svgTag))
      namespace_stack_.push_back(SVG);
    if (ThreadSafeMatch(tag_name, MathMLNames::mathTag))
       namespace_stack_.push_back(kMathML);
     if (InForeignContent() && TokenExitsForeignContent(token))
       namespace_stack_.pop_back();
    if (IsHTMLIntegrationPointForStartTag(token) ||
        (namespace_stack_.back() == kMathML && TokenExitsMath(token))) {
       namespace_stack_.push_back(HTML);
    } else if (!InForeignContent()) {
       if (ThreadSafeMatch(tag_name, textareaTag) ||
          ThreadSafeMatch(tag_name, titleTag)) {
        tokenizer->SetState(HTMLTokenizer::kRCDATAState);
      } else if (ThreadSafeMatch(tag_name, scriptTag)) {
        tokenizer->SetState(HTMLTokenizer::kScriptDataState);
        simulated_token = kScriptStart;
      } else if (ThreadSafeMatch(tag_name, linkTag)) {
        simulated_token = kLink;
      } else if (!in_select_insertion_mode_) {
        if (ThreadSafeMatch(tag_name, plaintextTag) &&
            !in_select_insertion_mode_) {
          tokenizer->SetState(HTMLTokenizer::kPLAINTEXTState);
        } else if (ThreadSafeMatch(tag_name, styleTag) ||
                   ThreadSafeMatch(tag_name, iframeTag) ||
                   ThreadSafeMatch(tag_name, xmpTag) ||
                   (ThreadSafeMatch(tag_name, noembedTag) &&
                    options_.plugins_enabled) ||
                   ThreadSafeMatch(tag_name, noframesTag) ||
                   (ThreadSafeMatch(tag_name, noscriptTag) &&
                    options_.script_enabled)) {
          tokenizer->SetState(HTMLTokenizer::kRAWTEXTState);
        }
      }

      if (ThreadSafeMatch(tag_name, selectTag)) {
        in_select_insertion_mode_ = true;
      } else if (in_select_insertion_mode_ && TokenExitsInSelect(token)) {
        in_select_insertion_mode_ = false;
      }
    }
  }

  if (token.GetType() == HTMLToken::kEndTag ||
      (token.GetType() == HTMLToken::kStartTag && token.SelfClosing() &&
       InForeignContent())) {
    const String& tag_name = token.Data();
    if ((namespace_stack_.back() == SVG &&
          ThreadSafeMatch(tag_name, SVGNames::svgTag)) ||
         (namespace_stack_.back() == kMathML &&
          ThreadSafeMatch(tag_name, MathMLNames::mathTag)) ||
        IsHTMLIntegrationPointForEndTag(token) ||
         (namespace_stack_.Contains(kMathML) &&
          namespace_stack_.back() == HTML && TokenExitsMath(token))) {
       namespace_stack_.pop_back();
    }
    if (ThreadSafeMatch(tag_name, scriptTag)) {
      if (!InForeignContent())
        tokenizer->SetState(HTMLTokenizer::kDataState);
      return kScriptEnd;
    } else if (ThreadSafeMatch(tag_name, selectTag)) {
      in_select_insertion_mode_ = false;
    }
    if (ThreadSafeMatch(tag_name, styleTag))
      simulated_token = kStyleEnd;
  }

  tokenizer->SetForceNullCharacterReplacement(InForeignContent());
  tokenizer->SetShouldAllowCDATA(InForeignContent());
   return simulated_token;
 }
","HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(
    const CompactHTMLToken& token,
    HTMLTokenizer* tokenizer) {
  SimulatedToken simulated_token = kOtherToken;

  if (token.GetType() == HTMLToken::kStartTag) {
    const String& tag_name = token.Data();
    if (ThreadSafeMatch(tag_name, SVGNames::svgTag))
      namespace_stack_.push_back(SVG);
    if (ThreadSafeMatch(tag_name, MathMLNames::mathTag))
       namespace_stack_.push_back(kMathML);
     if (InForeignContent() && TokenExitsForeignContent(token))
       namespace_stack_.pop_back();
    if ((namespace_stack_.back() == SVG && TokenExitsSVG(token)) ||
        (namespace_stack_.back() == kMathML && TokenExitsMath(token)))
       namespace_stack_.push_back(HTML);
    if (!InForeignContent()) {
       if (ThreadSafeMatch(tag_name, textareaTag) ||
          ThreadSafeMatch(tag_name, titleTag)) {
        tokenizer->SetState(HTMLTokenizer::kRCDATAState);
      } else if (ThreadSafeMatch(tag_name, scriptTag)) {
        tokenizer->SetState(HTMLTokenizer::kScriptDataState);
        simulated_token = kScriptStart;
      } else if (ThreadSafeMatch(tag_name, linkTag)) {
        simulated_token = kLink;
      } else if (!in_select_insertion_mode_) {
        if (ThreadSafeMatch(tag_name, plaintextTag) &&
            !in_select_insertion_mode_) {
          tokenizer->SetState(HTMLTokenizer::kPLAINTEXTState);
        } else if (ThreadSafeMatch(tag_name, styleTag) ||
                   ThreadSafeMatch(tag_name, iframeTag) ||
                   ThreadSafeMatch(tag_name, xmpTag) ||
                   (ThreadSafeMatch(tag_name, noembedTag) &&
                    options_.plugins_enabled) ||
                   ThreadSafeMatch(tag_name, noframesTag) ||
                   (ThreadSafeMatch(tag_name, noscriptTag) &&
                    options_.script_enabled)) {
          tokenizer->SetState(HTMLTokenizer::kRAWTEXTState);
        }
      }

      if (ThreadSafeMatch(tag_name, selectTag)) {
        in_select_insertion_mode_ = true;
      } else if (in_select_insertion_mode_ && TokenExitsInSelect(token)) {
        in_select_insertion_mode_ = false;
      }
    }
  }

  if (token.GetType() == HTMLToken::kEndTag ||
      (token.GetType() == HTMLToken::kStartTag && token.SelfClosing() &&
       InForeignContent())) {
    const String& tag_name = token.Data();
    if ((namespace_stack_.back() == SVG &&
          ThreadSafeMatch(tag_name, SVGNames::svgTag)) ||
         (namespace_stack_.back() == kMathML &&
          ThreadSafeMatch(tag_name, MathMLNames::mathTag)) ||
        (namespace_stack_.Contains(SVG) && namespace_stack_.back() == HTML &&
         TokenExitsSVG(token)) ||
         (namespace_stack_.Contains(kMathML) &&
          namespace_stack_.back() == HTML && TokenExitsMath(token))) {
       namespace_stack_.pop_back();
    }
    if (ThreadSafeMatch(tag_name, scriptTag)) {
      if (!InForeignContent())
        tokenizer->SetState(HTMLTokenizer::kDataState);
      return kScriptEnd;
    } else if (ThreadSafeMatch(tag_name, selectTag)) {
      in_select_insertion_mode_ = false;
    }
    if (ThreadSafeMatch(tag_name, styleTag))
      simulated_token = kStyleEnd;
  }

  tokenizer->SetForceNullCharacterReplacement(InForeignContent());
  tokenizer->SetShouldAllowCDATA(InForeignContent());
   return simulated_token;
 }
",C,"    if (IsHTMLIntegrationPointForStartTag(token) ||
        (namespace_stack_.back() == kMathML && TokenExitsMath(token))) {
    } else if (!InForeignContent()) {
        IsHTMLIntegrationPointForEndTag(token) ||
","    if ((namespace_stack_.back() == SVG && TokenExitsSVG(token)) ||
        (namespace_stack_.back() == kMathML && TokenExitsMath(token)))
    if (!InForeignContent()) {
        (namespace_stack_.Contains(SVG) && namespace_stack_.back() == HTML &&
         TokenExitsSVG(token)) ||
",,"@@ -82,13 +82,6 @@ static bool TokenExitsForeignContent(const CompactHTMLToken& token) {
            token.GetAttributeItem(sizeAttr)));
 }
 
-static bool TokenExitsSVG(const CompactHTMLToken& token) {
-  // FIXME: It's very fragile that we special case foreignObject here to be
-  // case-insensitive.
-  return DeprecatedEqualIgnoringCase(token.Data(),
-                                     SVGNames::foreignObjectTag.LocalName());
-}
-
 static bool TokenExitsMath(const CompactHTMLToken& token) {
   // FIXME: This is copied from HTMLElementStack::isMathMLTextIntegrationPoint
   // and changed to use threadSafeMatch.
@@ -148,10 +141,10 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(
       namespace_stack_.push_back(kMathML);
     if (InForeignContent() && TokenExitsForeignContent(token))
       namespace_stack_.pop_back();
-    if ((namespace_stack_.back() == SVG && TokenExitsSVG(token)) ||
-        (namespace_stack_.back() == kMathML && TokenExitsMath(token)))
+    if (IsHTMLIntegrationPointForStartTag(token) ||
+        (namespace_stack_.back() == kMathML && TokenExitsMath(token))) {
       namespace_stack_.push_back(HTML);
-    if (!InForeignContent()) {
+    } else if (!InForeignContent()) {
       // FIXME: This is just a copy of Tokenizer::updateStateFor which uses
       // threadSafeMatches.
       if (ThreadSafeMatch(tag_name, textareaTag) ||
@@ -203,8 +196,7 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(
          ThreadSafeMatch(tag_name, SVGNames::svgTag)) ||
         (namespace_stack_.back() == kMathML &&
          ThreadSafeMatch(tag_name, MathMLNames::mathTag)) ||
-        (namespace_stack_.Contains(SVG) && namespace_stack_.back() == HTML &&
-         TokenExitsSVG(token)) ||
+        IsHTMLIntegrationPointForEndTag(token) ||
         (namespace_stack_.Contains(kMathML) &&
          namespace_stack_.back() == HTML && TokenExitsMath(token))) {
       namespace_stack_.pop_back();
@@ -226,4 +218,59 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(
   return simulated_token;
 }
 
+// https://html.spec.whatwg.org/multipage/parsing.html#html-integration-point
+bool HTMLTreeBuilderSimulator::IsHTMLIntegrationPointForStartTag(
+    const CompactHTMLToken& token) const {
+  DCHECK(token.GetType() == HTMLToken::kStartTag) << token.GetType();
+
+  Namespace tokens_ns = namespace_stack_.back();
+  const String& tag_name = token.Data();
+  if (tokens_ns == kMathML) {
+    if (!ThreadSafeMatch(tag_name, MathMLNames::annotation_xmlTag))
+      return false;
+    if (auto* encoding = token.GetAttributeItem(MathMLNames::encodingAttr)) {
+      return EqualIgnoringASCIICase(encoding->Value(), ""text/html"") ||
+             EqualIgnoringASCIICase(encoding->Value(), ""application/xhtml+xml"");
+    }
+  } else if (tokens_ns == SVG) {
+    // FIXME: It's very fragile that we special case foreignObject here to be
+    // case-insensitive.
+    if (DeprecatedEqualIgnoringCase(tag_name,
+                                    SVGNames::foreignObjectTag.LocalName()))
+      return true;
+    return ThreadSafeMatch(tag_name, SVGNames::descTag) ||
+           ThreadSafeMatch(tag_name, SVGNames::titleTag);
+  }
+  return false;
+}
+
+// https://html.spec.whatwg.org/multipage/parsing.html#html-integration-point
+bool HTMLTreeBuilderSimulator::IsHTMLIntegrationPointForEndTag(
+    const CompactHTMLToken& token) const {
+  if (token.GetType() != HTMLToken::kEndTag)
+    return false;
+
+  // If it's inside an HTML integration point, the top namespace is
+  // HTML, and its next namespace is not HTML.
+  if (namespace_stack_.back() != HTML)
+    return false;
+  if (namespace_stack_.size() < 2)
+    return false;
+  Namespace tokens_ns = namespace_stack_[namespace_stack_.size() - 2];
+
+  const String& tag_name = token.Data();
+  if (tokens_ns == kMathML)
+    return ThreadSafeMatch(tag_name, MathMLNames::annotation_xmlTag);
+  if (tokens_ns == SVG) {
+    // FIXME: It's very fragile that we special case foreignObject here to be
+    // case-insensitive.
+    if (DeprecatedEqualIgnoringCase(tag_name,
+                                    SVGNames::foreignObjectTag.LocalName()))
+      return true;
+    return ThreadSafeMatch(tag_name, SVGNames::descTag) ||
+           ThreadSafeMatch(tag_name, SVGNames::titleTag);
+  }
+  return false;
+}
+
 }  // namespace blink",Chrome,133bc5c262b2555af223263452e9875a95db9eb7,1e8327c88920544f1503004b4e32850c935d4efb,1,"HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(
    const CompactHTMLToken& token,
    HTMLTokenizer* tokenizer) {
  SimulatedToken simulated_token = kOtherToken;

  if (token.GetType() == HTMLToken::kStartTag) {
    const String& tag_name = token.Data();
    if (ThreadSafeMatch(tag_name, SVGNames::svgTag))
      namespace_stack_.push_back(SVG);
    if (ThreadSafeMatch(tag_name, MathMLNames::mathTag))
       namespace_stack_.push_back(kMathML);
     if (InForeignContent() && TokenExitsForeignContent(token))
       namespace_stack_.pop_back();
//flaw_line_below:
    if ((namespace_stack_.back() == SVG && TokenExitsSVG(token)) ||
//flaw_line_below:
        (namespace_stack_.back() == kMathML && TokenExitsMath(token)))
//fix_flaw_line_below:
//    if (IsHTMLIntegrationPointForStartTag(token) ||
//fix_flaw_line_below:
//        (namespace_stack_.back() == kMathML && TokenExitsMath(token))) {
       namespace_stack_.push_back(HTML);
//flaw_line_below:
    if (!InForeignContent()) {
//fix_flaw_line_below:
//    } else if (!InForeignContent()) {
       // FIXME: This is just a copy of Tokenizer::updateStateFor which uses
       // threadSafeMatches.
       if (ThreadSafeMatch(tag_name, textareaTag) ||
          ThreadSafeMatch(tag_name, titleTag)) {
        tokenizer->SetState(HTMLTokenizer::kRCDATAState);
      } else if (ThreadSafeMatch(tag_name, scriptTag)) {
        tokenizer->SetState(HTMLTokenizer::kScriptDataState);
        simulated_token = kScriptStart;
      } else if (ThreadSafeMatch(tag_name, linkTag)) {
        simulated_token = kLink;
      } else if (!in_select_insertion_mode_) {
        // If we're in the ""in select"" insertion mode, all of these tags are
        // ignored, so we shouldn't change the tokenizer state:
        // https://html.spec.whatwg.org/#parsing-main-inselect
        if (ThreadSafeMatch(tag_name, plaintextTag) &&
            !in_select_insertion_mode_) {
          tokenizer->SetState(HTMLTokenizer::kPLAINTEXTState);
        } else if (ThreadSafeMatch(tag_name, styleTag) ||
                   ThreadSafeMatch(tag_name, iframeTag) ||
                   ThreadSafeMatch(tag_name, xmpTag) ||
                   (ThreadSafeMatch(tag_name, noembedTag) &&
                    options_.plugins_enabled) ||
                   ThreadSafeMatch(tag_name, noframesTag) ||
                   (ThreadSafeMatch(tag_name, noscriptTag) &&
                    options_.script_enabled)) {
          tokenizer->SetState(HTMLTokenizer::kRAWTEXTState);
        }
      }

      // We need to track whether we're in the ""in select"" insertion mode
      // in order to determine whether '<plaintext>' will put the tokenizer
      // into PLAINTEXTState, and whether '<xmp>' and others will consume
      // textual content.
      //
      // https://html.spec.whatwg.org/#parsing-main-inselect
      if (ThreadSafeMatch(tag_name, selectTag)) {
        in_select_insertion_mode_ = true;
      } else if (in_select_insertion_mode_ && TokenExitsInSelect(token)) {
        in_select_insertion_mode_ = false;
      }
    }
  }

  if (token.GetType() == HTMLToken::kEndTag ||
      (token.GetType() == HTMLToken::kStartTag && token.SelfClosing() &&
       InForeignContent())) {
    const String& tag_name = token.Data();
    if ((namespace_stack_.back() == SVG &&
          ThreadSafeMatch(tag_name, SVGNames::svgTag)) ||
         (namespace_stack_.back() == kMathML &&
          ThreadSafeMatch(tag_name, MathMLNames::mathTag)) ||
//flaw_line_below:
        (namespace_stack_.Contains(SVG) && namespace_stack_.back() == HTML &&
//flaw_line_below:
         TokenExitsSVG(token)) ||
//fix_flaw_line_below:
//        IsHTMLIntegrationPointForEndTag(token) ||
         (namespace_stack_.Contains(kMathML) &&
          namespace_stack_.back() == HTML && TokenExitsMath(token))) {
       namespace_stack_.pop_back();
    }
    if (ThreadSafeMatch(tag_name, scriptTag)) {
      if (!InForeignContent())
        tokenizer->SetState(HTMLTokenizer::kDataState);
      return kScriptEnd;
    } else if (ThreadSafeMatch(tag_name, selectTag)) {
      in_select_insertion_mode_ = false;
    }
    if (ThreadSafeMatch(tag_name, styleTag))
      simulated_token = kStyleEnd;
  }

  // FIXME: Also setForceNullCharacterReplacement when in text mode.
  tokenizer->SetForceNullCharacterReplacement(InForeignContent());
  tokenizer->SetShouldAllowCDATA(InForeignContent());
   return simulated_token;
 }
"
9541,187277,,Remote,Not required,,CVE-2018-6145,https://www.cvedetails.com/cve/CVE-2018-6145/,CWE-79,Medium,,Partial,,2019-06-27,4.3,Insufficient data validation in HTML parser in Google Chrome prior to 67.0.3396.62 allowed a remote attacker to bypass same origin policy via a crafted HTML page.,2019-07-02,XSS Bypass ,0,https://github.com/chromium/chromium/commit/133bc5c262b2555af223263452e9875a95db9eb7,133bc5c262b2555af223263452e9875a95db9eb7,"HTML parser: Fix ""HTML integration point"" implementation in HTMLTreeBuilderSimulator.

HTMLTreeBuilderSimulator assumed only <foreignObject> as an HTML
integration point. This CL adds <annotation-xml>, <desc>, and SVG
<title>.

Bug: 805924
Change-Id: I6793d9163d4c6bc8bf0790415baedddaac7a1fc2
Reviewed-on: https://chromium-review.googlesource.com/964038
Commit-Queue: Kent Tamura <tkent@chromium.org>
Reviewed-by: Kouhei Ueno <kouhei@chromium.org>
Cr-Commit-Position: refs/heads/master@{#543634}",3,third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.cpp,"{""sha"": ""be6b42d07d0257fcc2ffc13401be3777395a02fb"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/html/syntax/parsing/html-integration-point.html"", ""status"": ""added"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/chromium/chromium/blob/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/LayoutTests/external/wpt/html/syntax/parsing/html-integration-point.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/LayoutTests/external/wpt/html/syntax/parsing/html-integration-point.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/html/syntax/parsing/html-integration-point.html?ref=133bc5c262b2555af223263452e9875a95db9eb7"", ""patch"": ""@@ -0,0 +1,31 @@\n+<!DOCTYPE html>\n+<link rel=\""help\"" href=\""https://html.spec.whatwg.org/multipage/parsing.html#tree-construction:html-integration-point\"">\n+<body>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+\n+<math><annotation-xml id=\""point-1\"" encoding=\""text/html\""><xmp>&lt;/xmp&gt;&lt;img></xmp></annotation-xml></math>\n+<math><annotation-xml id=\""point-2\"" encoding=\""application/xhtml+xml\""><style>&lt;/style&gt;&lt;img></style></annotation-xml></math>\n+<svg><foreignObject id=\""point-3\""><iframe>&lt;/iframe&gt;&lt;img></iframe></foreignObject></svg>\n+<svg><desc id=\""point-4\""><noembed>&lt;/noembed&gt;&lt;img></noembed></desc></svg>\n+<svg><title id=\""point-5\""><noframes>&lt;/noframes&gt;&lt;img></noframes></title></svg>\n+\n+<script>\n+function generate_test(id) {\n+  return () => {\n+    let point = document.querySelector('#' + id);\n+    assert_not_equals(point.namespaceURI, 'http://www.w3.org/1999/xhtml');\n+    let rawTextElement = point.firstChild;\n+    assert_equals(rawTextElement.namespaceURI, 'http://www.w3.org/1999/xhtml');\n+    assert_equals(rawTextElement.textContent.substr(0, 4), '&lt;',\n+                  'Entity references should not be decoded.');\n+  };\n+}\n+\n+test(generate_test('point-1'), 'MathML annotation-xml with encoding=text/html should be an HTML integration point');\n+test(generate_test('point-2'), 'MathML annotation-xml with encoding=application/xhtml+xml should be an HTML integration point');\n+test(generate_test('point-3'), 'SVG foreignObject should be an HTML integration point');\n+test(generate_test('point-4'), 'SVG desc should be an HTML integration point');\n+test(generate_test('point-5'), 'SVG title should be an HTML integration point');\n+</script>\n+</body>""}<_**next**_>{""sha"": ""1029c22a1afb3ea6dfc12e98952ba2e98302ef03"", ""filename"": ""third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.cpp"", ""status"": ""modified"", ""additions"": 59, ""deletions"": 12, ""changes"": 71, ""blob_url"": ""https://github.com/chromium/chromium/blob/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.cpp?ref=133bc5c262b2555af223263452e9875a95db9eb7"", ""patch"": ""@@ -82,13 +82,6 @@ static bool TokenExitsForeignContent(const CompactHTMLToken& token) {\n            token.GetAttributeItem(sizeAttr)));\n }\n \n-static bool TokenExitsSVG(const CompactHTMLToken& token) {\n-  // FIXME: It's very fragile that we special case foreignObject here to be\n-  // case-insensitive.\n-  return DeprecatedEqualIgnoringCase(token.Data(),\n-                                     SVGNames::foreignObjectTag.LocalName());\n-}\n-\n static bool TokenExitsMath(const CompactHTMLToken& token) {\n   // FIXME: This is copied from HTMLElementStack::isMathMLTextIntegrationPoint\n   // and changed to use threadSafeMatch.\n@@ -148,10 +141,10 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(\n       namespace_stack_.push_back(kMathML);\n     if (InForeignContent() && TokenExitsForeignContent(token))\n       namespace_stack_.pop_back();\n-    if ((namespace_stack_.back() == SVG && TokenExitsSVG(token)) ||\n-        (namespace_stack_.back() == kMathML && TokenExitsMath(token)))\n+    if (IsHTMLIntegrationPointForStartTag(token) ||\n+        (namespace_stack_.back() == kMathML && TokenExitsMath(token))) {\n       namespace_stack_.push_back(HTML);\n-    if (!InForeignContent()) {\n+    } else if (!InForeignContent()) {\n       // FIXME: This is just a copy of Tokenizer::updateStateFor which uses\n       // threadSafeMatches.\n       if (ThreadSafeMatch(tag_name, textareaTag) ||\n@@ -203,8 +196,7 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(\n          ThreadSafeMatch(tag_name, SVGNames::svgTag)) ||\n         (namespace_stack_.back() == kMathML &&\n          ThreadSafeMatch(tag_name, MathMLNames::mathTag)) ||\n-        (namespace_stack_.Contains(SVG) && namespace_stack_.back() == HTML &&\n-         TokenExitsSVG(token)) ||\n+        IsHTMLIntegrationPointForEndTag(token) ||\n         (namespace_stack_.Contains(kMathML) &&\n          namespace_stack_.back() == HTML && TokenExitsMath(token))) {\n       namespace_stack_.pop_back();\n@@ -226,4 +218,59 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(\n   return simulated_token;\n }\n \n+// https://html.spec.whatwg.org/multipage/parsing.html#html-integration-point\n+bool HTMLTreeBuilderSimulator::IsHTMLIntegrationPointForStartTag(\n+    const CompactHTMLToken& token) const {\n+  DCHECK(token.GetType() == HTMLToken::kStartTag) << token.GetType();\n+\n+  Namespace tokens_ns = namespace_stack_.back();\n+  const String& tag_name = token.Data();\n+  if (tokens_ns == kMathML) {\n+    if (!ThreadSafeMatch(tag_name, MathMLNames::annotation_xmlTag))\n+      return false;\n+    if (auto* encoding = token.GetAttributeItem(MathMLNames::encodingAttr)) {\n+      return EqualIgnoringASCIICase(encoding->Value(), \""text/html\"") ||\n+             EqualIgnoringASCIICase(encoding->Value(), \""application/xhtml+xml\"");\n+    }\n+  } else if (tokens_ns == SVG) {\n+    // FIXME: It's very fragile that we special case foreignObject here to be\n+    // case-insensitive.\n+    if (DeprecatedEqualIgnoringCase(tag_name,\n+                                    SVGNames::foreignObjectTag.LocalName()))\n+      return true;\n+    return ThreadSafeMatch(tag_name, SVGNames::descTag) ||\n+           ThreadSafeMatch(tag_name, SVGNames::titleTag);\n+  }\n+  return false;\n+}\n+\n+// https://html.spec.whatwg.org/multipage/parsing.html#html-integration-point\n+bool HTMLTreeBuilderSimulator::IsHTMLIntegrationPointForEndTag(\n+    const CompactHTMLToken& token) const {\n+  if (token.GetType() != HTMLToken::kEndTag)\n+    return false;\n+\n+  // If it's inside an HTML integration point, the top namespace is\n+  // HTML, and its next namespace is not HTML.\n+  if (namespace_stack_.back() != HTML)\n+    return false;\n+  if (namespace_stack_.size() < 2)\n+    return false;\n+  Namespace tokens_ns = namespace_stack_[namespace_stack_.size() - 2];\n+\n+  const String& tag_name = token.Data();\n+  if (tokens_ns == kMathML)\n+    return ThreadSafeMatch(tag_name, MathMLNames::annotation_xmlTag);\n+  if (tokens_ns == SVG) {\n+    // FIXME: It's very fragile that we special case foreignObject here to be\n+    // case-insensitive.\n+    if (DeprecatedEqualIgnoringCase(tag_name,\n+                                    SVGNames::foreignObjectTag.LocalName()))\n+      return true;\n+    return ThreadSafeMatch(tag_name, SVGNames::descTag) ||\n+           ThreadSafeMatch(tag_name, SVGNames::titleTag);\n+  }\n+  return false;\n+}\n+\n }  // namespace blink""}<_**next**_>{""sha"": ""2fd9f921ce33ccc4daf367f1ce3f793e78617521"", ""filename"": ""third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.h?ref=133bc5c262b2555af223263452e9875a95db9eb7"", ""patch"": ""@@ -64,6 +64,8 @@ class CORE_EXPORT HTMLTreeBuilderSimulator {\n \n  private:\n   bool InForeignContent() const { return namespace_stack_.back() != HTML; }\n+  bool IsHTMLIntegrationPointForStartTag(const CompactHTMLToken&) const;\n+  bool IsHTMLIntegrationPointForEndTag(const CompactHTMLToken&) const;\n \n   HTMLParserOptions options_;\n   State namespace_stack_;""}","static bool TokenExitsSVG(const CompactHTMLToken& token) {
","static bool TokenExitsSVG(const CompactHTMLToken& token) {
  return DeprecatedEqualIgnoringCase(token.Data(),
                                     SVGNames::foreignObjectTag.LocalName());
}
",C,,"  return DeprecatedEqualIgnoringCase(token.Data(),
                                     SVGNames::foreignObjectTag.LocalName());
}
",,"@@ -82,13 +82,6 @@ static bool TokenExitsForeignContent(const CompactHTMLToken& token) {
            token.GetAttributeItem(sizeAttr)));
 }
 
-static bool TokenExitsSVG(const CompactHTMLToken& token) {
-  // FIXME: It's very fragile that we special case foreignObject here to be
-  // case-insensitive.
-  return DeprecatedEqualIgnoringCase(token.Data(),
-                                     SVGNames::foreignObjectTag.LocalName());
-}
-
 static bool TokenExitsMath(const CompactHTMLToken& token) {
   // FIXME: This is copied from HTMLElementStack::isMathMLTextIntegrationPoint
   // and changed to use threadSafeMatch.
@@ -148,10 +141,10 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(
       namespace_stack_.push_back(kMathML);
     if (InForeignContent() && TokenExitsForeignContent(token))
       namespace_stack_.pop_back();
-    if ((namespace_stack_.back() == SVG && TokenExitsSVG(token)) ||
-        (namespace_stack_.back() == kMathML && TokenExitsMath(token)))
+    if (IsHTMLIntegrationPointForStartTag(token) ||
+        (namespace_stack_.back() == kMathML && TokenExitsMath(token))) {
       namespace_stack_.push_back(HTML);
-    if (!InForeignContent()) {
+    } else if (!InForeignContent()) {
       // FIXME: This is just a copy of Tokenizer::updateStateFor which uses
       // threadSafeMatches.
       if (ThreadSafeMatch(tag_name, textareaTag) ||
@@ -203,8 +196,7 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(
          ThreadSafeMatch(tag_name, SVGNames::svgTag)) ||
         (namespace_stack_.back() == kMathML &&
          ThreadSafeMatch(tag_name, MathMLNames::mathTag)) ||
-        (namespace_stack_.Contains(SVG) && namespace_stack_.back() == HTML &&
-         TokenExitsSVG(token)) ||
+        IsHTMLIntegrationPointForEndTag(token) ||
         (namespace_stack_.Contains(kMathML) &&
          namespace_stack_.back() == HTML && TokenExitsMath(token))) {
       namespace_stack_.pop_back();
@@ -226,4 +218,59 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(
   return simulated_token;
 }
 
+// https://html.spec.whatwg.org/multipage/parsing.html#html-integration-point
+bool HTMLTreeBuilderSimulator::IsHTMLIntegrationPointForStartTag(
+    const CompactHTMLToken& token) const {
+  DCHECK(token.GetType() == HTMLToken::kStartTag) << token.GetType();
+
+  Namespace tokens_ns = namespace_stack_.back();
+  const String& tag_name = token.Data();
+  if (tokens_ns == kMathML) {
+    if (!ThreadSafeMatch(tag_name, MathMLNames::annotation_xmlTag))
+      return false;
+    if (auto* encoding = token.GetAttributeItem(MathMLNames::encodingAttr)) {
+      return EqualIgnoringASCIICase(encoding->Value(), ""text/html"") ||
+             EqualIgnoringASCIICase(encoding->Value(), ""application/xhtml+xml"");
+    }
+  } else if (tokens_ns == SVG) {
+    // FIXME: It's very fragile that we special case foreignObject here to be
+    // case-insensitive.
+    if (DeprecatedEqualIgnoringCase(tag_name,
+                                    SVGNames::foreignObjectTag.LocalName()))
+      return true;
+    return ThreadSafeMatch(tag_name, SVGNames::descTag) ||
+           ThreadSafeMatch(tag_name, SVGNames::titleTag);
+  }
+  return false;
+}
+
+// https://html.spec.whatwg.org/multipage/parsing.html#html-integration-point
+bool HTMLTreeBuilderSimulator::IsHTMLIntegrationPointForEndTag(
+    const CompactHTMLToken& token) const {
+  if (token.GetType() != HTMLToken::kEndTag)
+    return false;
+
+  // If it's inside an HTML integration point, the top namespace is
+  // HTML, and its next namespace is not HTML.
+  if (namespace_stack_.back() != HTML)
+    return false;
+  if (namespace_stack_.size() < 2)
+    return false;
+  Namespace tokens_ns = namespace_stack_[namespace_stack_.size() - 2];
+
+  const String& tag_name = token.Data();
+  if (tokens_ns == kMathML)
+    return ThreadSafeMatch(tag_name, MathMLNames::annotation_xmlTag);
+  if (tokens_ns == SVG) {
+    // FIXME: It's very fragile that we special case foreignObject here to be
+    // case-insensitive.
+    if (DeprecatedEqualIgnoringCase(tag_name,
+                                    SVGNames::foreignObjectTag.LocalName()))
+      return true;
+    return ThreadSafeMatch(tag_name, SVGNames::descTag) ||
+           ThreadSafeMatch(tag_name, SVGNames::titleTag);
+  }
+  return false;
+}
+
 }  // namespace blink",Chrome,133bc5c262b2555af223263452e9875a95db9eb7,1e8327c88920544f1503004b4e32850c935d4efb,1,"static bool TokenExitsSVG(const CompactHTMLToken& token) {
//flaw_line_below:
  // FIXME: It's very fragile that we special case foreignObject here to be
//flaw_line_below:
  // case-insensitive.
//flaw_line_below:
  return DeprecatedEqualIgnoringCase(token.Data(),
//flaw_line_below:
                                     SVGNames::foreignObjectTag.LocalName());
//flaw_line_below:
}
"
